[
    {
        "type": "Move Method",
        "description": "Move Method\tpublic versionWithParserThatThrowsAssertionError() : LanguageVersion from class net.sourceforge.pmd.processor.PmdRunnableTest to public versionWithParserThatThrowsAssertionError() : LanguageVersion from class net.sourceforge.pmd.lang.DummyLanguageModule",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/processor/PmdRunnableTest.java",
                "startLine": 162,
                "endLine": 164,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/lang/DummyLanguageModule.java",
                "startLine": 57,
                "endLine": 59,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public static LanguageVersion versionWithParserThatThrowsAssertionError() {\n        return DummyLanguageModule.getInstance().getVersion(THROWS_ASSERTION_ERROR);\n    }",
        "filePathBefore": "pmd-core/src/test/java/net/sourceforge/pmd/processor/PmdRunnableTest.java",
        "isPureRefactoring": true,
        "commitId": "d5b3478c8a5d06ab221c2a8d31d976a508beb0a8",
        "packageNameBefore": "net.sourceforge.pmd.processor",
        "classNameBefore": "net.sourceforge.pmd.processor.PmdRunnableTest",
        "methodNameBefore": "net.sourceforge.pmd.processor.PmdRunnableTest#versionWithParserThatThrowsAssertionError",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.DummyLanguageModule#getInstance\n methodBody: public static DummyLanguageModule getInstance() {\nreturn (DummyLanguageModule)Objects.requireNonNull(LanguageRegistry.PMD.getLanguageByFullName(NAME));\n}",
        "classSignatureBefore": "public class PmdRunnableTest ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.processor.PmdRunnableTest#versionWithParserThatThrowsAssertionError"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.processor.PmdRunnableTest"
        ],
        "classSignatureBeforeSet": [
            "public class PmdRunnableTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.processor;\n\nimport static org.hamcrest.CoreMatchers.instanceOf;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.hasSize;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.Mockito.contains;\nimport static org.mockito.Mockito.eq;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.spy;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\n\nimport java.util.List;\nimport java.util.function.BiConsumer;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\nimport org.slf4j.event.Level;\n\nimport net.sourceforge.pmd.PMDConfiguration;\nimport net.sourceforge.pmd.Report;\nimport net.sourceforge.pmd.Report.GlobalReportBuilderListener;\nimport net.sourceforge.pmd.Report.ProcessingError;\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RuleContext;\nimport net.sourceforge.pmd.RuleSet;\nimport net.sourceforge.pmd.RuleSets;\nimport net.sourceforge.pmd.internal.SystemProps;\nimport net.sourceforge.pmd.internal.util.ContextedAssertionError;\nimport net.sourceforge.pmd.lang.DummyLanguageModule;\nimport net.sourceforge.pmd.lang.DummyLanguageModule.Handler;\nimport net.sourceforge.pmd.lang.Language;\nimport net.sourceforge.pmd.lang.LanguageVersion;\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.ast.Parser;\nimport net.sourceforge.pmd.lang.ast.RootNode;\nimport net.sourceforge.pmd.lang.document.TextFile;\nimport net.sourceforge.pmd.lang.rule.AbstractRule;\nimport net.sourceforge.pmd.processor.MonoThreadProcessor.MonothreadRunnable;\nimport net.sourceforge.pmd.util.log.MessageReporter;\n\nimport com.github.stefanbirkner.systemlambda.SystemLambda;\n\npublic class PmdRunnableTest {\n\n    public static final String TEST_MESSAGE_SEMANTIC_ERROR = \"An error occurred!\";\n    private static final String PARSER_REPORTS_SEMANTIC_ERROR = \"1.9-semantic_error\";\n    private static final String THROWS_SEMANTIC_ERROR = \"1.9-throws_semantic_error\";\n    private static final String THROWS_ASSERTION_ERROR = \"1.9-throws\";\n\n    private PMDConfiguration configuration;\n    private PmdRunnable pmdRunnable;\n    private MessageReporter reporter;\n    private Rule rule;\n\n\n    @BeforeEach\n    public void prepare() {\n        // reset data\n        rule = spy(new RuleThatThrows());\n        configuration = new PMDConfiguration();\n        reporter = mock(MessageReporter.class);\n        configuration.setReporter(reporter);\n\n        // will be populated by a call to process(LanguageVersion)\n        pmdRunnable = null;\n    }\n\n\n    private Report process(LanguageVersion lv) {\n        TextFile dataSource = TextFile.forCharSeq(\"test\", \"test.dummy\", lv);\n\n        GlobalReportBuilderListener reportBuilder = new GlobalReportBuilderListener();\n\n        pmdRunnable = new MonothreadRunnable(new RuleSets(RuleSet.forSingleRule(rule)),\n                                             dataSource,\n                                             reportBuilder,\n                                             configuration);\n\n        pmdRunnable.run();\n        reportBuilder.close();\n        return reportBuilder.getResult();\n    }\n\n    @Test\n    public void inErrorRecoveryModeErrorsShouldBeLoggedByParser() throws Exception {\n        SystemLambda.restoreSystemProperties(() -> {\n            System.setProperty(SystemProps.PMD_ERROR_RECOVERY, \"\");\n\n            Report report = process(versionWithParserThatThrowsAssertionError());\n\n            assertEquals(1, report.getProcessingErrors().size());\n        });\n    }\n\n    @Test\n    public void inErrorRecoveryModeErrorsShouldBeLoggedByRule() throws Exception {\n        SystemLambda.restoreSystemProperties(() -> {\n            System.setProperty(SystemProps.PMD_ERROR_RECOVERY, \"\");\n\n            Report report = process(DummyLanguageModule.getInstance().getDefaultVersion());\n\n            List<ProcessingError> errors = report.getProcessingErrors();\n            assertThat(errors, hasSize(1));\n            assertThat(errors.get(0).getError(), instanceOf(ContextedAssertionError.class));\n        });\n\n    }\n\n    @Test\n    public void withoutErrorRecoveryModeProcessingShouldBeAbortedByParser() throws Exception {\n        SystemLambda.restoreSystemProperties(() -> {\n            System.clearProperty(SystemProps.PMD_ERROR_RECOVERY);\n            assertThrows(AssertionError.class, () -> process(versionWithParserThatThrowsAssertionError()));\n        });\n    }\n\n    @Test\n    public void withoutErrorRecoveryModeProcessingShouldBeAbortedByRule() throws Exception {\n        SystemLambda.restoreSystemProperties(() -> {\n            System.clearProperty(SystemProps.PMD_ERROR_RECOVERY);\n            assertThrows(AssertionError.class, () -> process(DummyLanguageModule.getInstance().getDefaultVersion()));\n        });\n    }\n\n\n    @Test\n    public void semanticErrorShouldAbortTheRun() {\n        Report report = process(versionWithParserThatReportsSemanticError());\n\n        verify(reporter, times(1))\n            .log(eq(Level.ERROR), eq(\"at !debug only! test.dummy:1:1: \" + TEST_MESSAGE_SEMANTIC_ERROR));\n        verify(rule, never()).apply(Mockito.any(), Mockito.any());\n\n        assertEquals(1, report.getProcessingErrors().size());\n    }\n\n    @Test\n    public void semanticErrorThrownShouldAbortTheRun() {\n        Report report = process(getVersionWithParserThatThrowsSemanticError());\n\n        verify(reporter, times(1)).log(eq(Level.ERROR), contains(TEST_MESSAGE_SEMANTIC_ERROR));\n        verify(rule, never()).apply(Mockito.any(), Mockito.any());\n\n        assertEquals(1, report.getProcessingErrors().size());\n    }\n\n    public static void registerCustomVersions(BiConsumer<String, Handler> addVersion) {\n        addVersion.accept(THROWS_ASSERTION_ERROR, new HandlerWithParserThatThrows());\n        addVersion.accept(PARSER_REPORTS_SEMANTIC_ERROR, new HandlerWithParserThatReportsSemanticError());\n        addVersion.accept(THROWS_SEMANTIC_ERROR, new HandlerWithParserThatThrowsSemanticError());\n    }\n\n    public static LanguageVersion versionWithParserThatThrowsAssertionError() {\n        return DummyLanguageModule.getInstance().getVersion(THROWS_ASSERTION_ERROR);\n    }\n\n    public static LanguageVersion getVersionWithParserThatThrowsSemanticError() {\n        return DummyLanguageModule.getInstance().getVersion(THROWS_SEMANTIC_ERROR);\n    }\n\n    public static LanguageVersion versionWithParserThatReportsSemanticError() {\n        return DummyLanguageModule.getInstance().getVersion(PARSER_REPORTS_SEMANTIC_ERROR);\n    }\n\n    private static class RuleThatThrows extends AbstractRule {\n\n        RuleThatThrows() {\n            Language dummyLanguage = DummyLanguageModule.getInstance();\n            setLanguage(dummyLanguage);\n        }\n\n        @Override\n        public void apply(Node target, RuleContext ctx) {\n            throw new AssertionError(\"test\");\n        }\n    }\n\n    public static class HandlerWithParserThatThrowsSemanticError extends Handler {\n\n        @Override\n        public Parser getParser() {\n            return task -> {\n                RootNode root = super.getParser().parse(task);\n                throw task.getReporter().error(root, TEST_MESSAGE_SEMANTIC_ERROR);\n            };\n        }\n    }\n\n    public static class HandlerWithParserThatThrows extends Handler {\n\n        @Override\n        public Parser getParser() {\n            return task -> {\n                throw new AssertionError(\"test error while parsing\");\n            };\n        }\n    }\n\n    public static class HandlerWithParserThatReportsSemanticError extends Handler {\n\n        @Override\n        public Parser getParser() {\n            return task -> {\n                RootNode root = super.getParser().parse(task);\n                task.getReporter().error(root, TEST_MESSAGE_SEMANTIC_ERROR);\n                return root;\n            };\n        }\n    }\n}\n",
        "filePathAfter": "pmd-core/src/test/java/net/sourceforge/pmd/lang/DummyLanguageModule.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang;\n\nimport java.util.Objects;\n\nimport net.sourceforge.pmd.RuleViolation;\nimport net.sourceforge.pmd.lang.ast.DummyNode;\nimport net.sourceforge.pmd.lang.ast.DummyNode.DummyRootNode;\nimport net.sourceforge.pmd.lang.ast.ParseException;\nimport net.sourceforge.pmd.lang.ast.Parser;\nimport net.sourceforge.pmd.lang.ast.Parser.ParserTask;\nimport net.sourceforge.pmd.lang.ast.RootNode;\nimport net.sourceforge.pmd.lang.ast.SemanticErrorReporter;\nimport net.sourceforge.pmd.lang.document.Chars;\nimport net.sourceforge.pmd.lang.document.TextDocument;\nimport net.sourceforge.pmd.lang.document.TextFile;\nimport net.sourceforge.pmd.lang.document.TextRegion;\nimport net.sourceforge.pmd.reporting.ViolationDecorator;\n\n/**\n * Dummy language used for testing PMD.\n */\npublic class DummyLanguageModule extends BaseLanguageModule {\n\n    public static final String NAME = \"Dummy\";\n    public static final String TERSE_NAME = \"dummy\";\n\n    public static final String TEST_MESSAGE_SEMANTIC_ERROR = \"An error occurred!\";\n    private static final String PARSER_REPORTS_SEMANTIC_ERROR = \"1.9-semantic_error\";\n    private static final String THROWS_SEMANTIC_ERROR = \"1.9-throws_semantic_error\";\n    private static final String THROWS_ASSERTION_ERROR = \"1.9-throws\";\n\n    public DummyLanguageModule() {\n        super(NAME, null, TERSE_NAME, \"dummy\");\n        addVersion(\"1.0\", new Handler());\n        addVersion(\"1.1\", new Handler());\n        addVersion(\"1.2\", new Handler());\n        addVersion(\"1.3\", new Handler());\n        addVersion(\"1.4\", new Handler());\n        addVersion(\"1.5\", new Handler(), \"5\");\n        addVersion(\"1.6\", new Handler(), \"6\");\n        addDefaultVersion(\"1.7\", new Handler(), \"7\");\n        addVersion(\"1.8\", new Handler(), \"8\");\n\n        addVersion(THROWS_ASSERTION_ERROR, new HandlerWithParserThatThrows());\n        addVersion(PARSER_REPORTS_SEMANTIC_ERROR, new HandlerWithParserThatReportsSemanticError());\n        addVersion(THROWS_SEMANTIC_ERROR, new HandlerWithParserThatThrowsSemanticError());\n    }\n\n    public static DummyLanguageModule getInstance() {\n        return (DummyLanguageModule) Objects.requireNonNull(LanguageRegistry.PMD.getLanguageByFullName(NAME));\n    }\n\n    public static LanguageVersion versionWithParserThatThrowsAssertionError() {\n        return DummyLanguageModule.getInstance().getVersion(THROWS_ASSERTION_ERROR);\n    }\n\n    public static LanguageVersion getVersionWithParserThatThrowsSemanticError() {\n        return DummyLanguageModule.getInstance().getVersion(THROWS_SEMANTIC_ERROR);\n    }\n\n    public static LanguageVersion versionWithParserThatReportsSemanticError() {\n        return DummyLanguageModule.getInstance().getVersion(PARSER_REPORTS_SEMANTIC_ERROR);\n    }\n\n    public static DummyRootNode parse(String code) {\n        return parse(code, TextFile.UNKNOWN_FILENAME);\n    }\n\n    public static DummyRootNode parse(String code, String filename) {\n        LanguageVersion version = DummyLanguageModule.getInstance().getDefaultVersion();\n        ParserTask task = new ParserTask(\n            TextDocument.readOnlyString(code, filename, version),\n            SemanticErrorReporter.noop()\n        );\n        return (DummyRootNode) version.getLanguageVersionHandler().getParser().parse(task);\n    }\n\n    public static class Handler extends AbstractPmdLanguageVersionHandler {\n\n        @Override\n        public Parser getParser() {\n            return DummyLanguageModule::readLispNode;\n        }\n\n        @Override\n        public ViolationDecorator getViolationDecorator() {\n            return (node, data) -> data.put(RuleViolation.PACKAGE_NAME, \"foo\");\n        }\n    }\n\n    /**\n     * Creates a tree of nodes that corresponds to the nesting structures\n     * of parentheses in the text. The image of each node is also populated.\n     * This is useful to create non-trivial trees with all the relevant\n     * data (eg coordinates) set properly.\n     *\n     * Eg {@code (a(b)x(c))} will create a tree with a node \"a\", with two\n     * children \"b\" and \"c\". \"x\" is ignored. The node \"a\" is not the root\n     * node, it has a {@link DummyRootNode} as parent, whose image is \"\".\n     */\n    private static DummyRootNode readLispNode(ParserTask task) {\n        TextDocument document = task.getTextDocument();\n        final DummyRootNode root = new DummyRootNode().withTaskInfo(task);\n        root.setRegion(document.getEntireRegion());\n\n        DummyNode top = root;\n        int lastNodeStart = 0;\n        Chars text = document.getText();\n        for (int i = 0; i < text.length(); i++) {\n            char c = text.charAt(i);\n            if (c == '(') {\n                DummyNode node = new DummyNode();\n                node.setParent(top);\n                top.addChild(node, top.getNumChildren());\n                // setup coordinates, temporary (will be completed when node closes)\n                node.setRegion(TextRegion.caretAt(i));\n\n                // cut out image\n                if (top.getImage() == null) {\n                    // image may be non null if this is not the first child of 'top'\n                    // eg in (a(b)x(c)), the image of the parent is set to \"a\".\n                    // When we're processing \"(c\", we ignore \"x\".\n                    String image = text.substring(lastNodeStart, i);\n                    top.setImage(image);\n                }\n                lastNodeStart = i + 1;\n                // node is the top of the stack now\n                top = node;\n            } else if (c == ')') {\n                if (top == null) {\n                    throw new ParseException(\"Unbalanced parentheses: \" + text);\n                }\n\n                top.setRegion(TextRegion.fromBothOffsets(top.getTextRegion().getStartOffset(), i));\n\n                if (top.getImage() == null) {\n                    // cut out image (if node doesn't have children it hasn't been populated yet)\n                    String image = text.substring(lastNodeStart, i);\n                    top.setImage(image);\n                    lastNodeStart = i + 1;\n                }\n                top = top.getParent();\n            }\n        }\n        if (top != root) {\n            throw new ParseException(\"Unbalanced parentheses: \" + text);\n        }\n        return root;\n    }\n\n    private static class HandlerWithParserThatThrowsSemanticError extends Handler {\n\n        @Override\n        public Parser getParser() {\n            return task -> {\n                RootNode root = super.getParser().parse(task);\n                throw task.getReporter().error(root, TEST_MESSAGE_SEMANTIC_ERROR);\n            };\n        }\n    }\n\n    private static class HandlerWithParserThatThrows extends Handler {\n\n        @Override\n        public Parser getParser() {\n            return task -> {\n                throw new AssertionError(\"test error while parsing\");\n            };\n        }\n    }\n\n    private static class HandlerWithParserThatReportsSemanticError extends Handler {\n\n        @Override\n        public Parser getParser() {\n            return task -> {\n                RootNode root = super.getParser().parse(task);\n                task.getReporter().error(root, TEST_MESSAGE_SEMANTIC_ERROR);\n                return root;\n            };\n        }\n    }\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.DummyLanguageModule#getInstance\n methodBody: public static DummyLanguageModule getInstance() {\nreturn (DummyLanguageModule)Objects.requireNonNull(LanguageRegistry.PMD.getLanguageByFullName(NAME));\n}"
        ],
        "sourceCodeAfterRefactoring": "public static LanguageVersion versionWithParserThatThrowsAssertionError() {\n        return DummyLanguageModule.getInstance().getVersion(THROWS_ASSERTION_ERROR);\n    }",
        "diffSourceCode": "-   57:     private static final String THROWS_ASSERTION_ERROR = \"1.9-throws\";\n-   58: \n-   59:     private PMDConfiguration configuration;\n-  162:     public static LanguageVersion versionWithParserThatThrowsAssertionError() {\n-  163:         return DummyLanguageModule.getInstance().getVersion(THROWS_ASSERTION_ERROR);\n+   57:     public static LanguageVersion versionWithParserThatThrowsAssertionError() {\n+   58:         return DummyLanguageModule.getInstance().getVersion(THROWS_ASSERTION_ERROR);\n+   59:     }\n+  162:             };\n+  163:         }\n   164:     }\n",
        "uniqueId": "d5b3478c8a5d06ab221c2a8d31d976a508beb0a8_162_164__57_59",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Inline Method",
        "description": "Inline Method\tpublic runTestFromString(code String, rule Rule, languageVersion LanguageVersion, isUseAuxClasspath boolean) : Report inlined to package runTestFromString(code String, rule Rule, languageVersion LanguageVersion) : Report in class net.sourceforge.pmd.testframework.RuleTst",
        "diffLocations": [
            {
                "filePath": "pmd-test/src/main/java/net/sourceforge/pmd/testframework/RuleTst.java",
                "startLine": 238,
                "endLine": 245,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-test/src/main/java/net/sourceforge/pmd/testframework/RuleTst.java",
                "startLine": 237,
                "endLine": 273,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-test/src/main/java/net/sourceforge/pmd/testframework/RuleTst.java",
                "startLine": 247,
                "endLine": 283,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@InternalApi\n    @Deprecated\n    public Report runTestFromString(String code, Rule rule, LanguageVersion languageVersion,\n            boolean isUseAuxClasspath) {\n        try {\n            PMDConfiguration configuration = new PMDConfiguration();\n            configuration.setIgnoreIncrementalAnalysis(true);\n            configuration.setDefaultLanguageVersion(languageVersion);\n            configuration.setThreads(1);\n            // regardless of isUseAuxClasspath the auxclasspath is always used (#3976 / #3302)\n            // configure the \"auxclasspath\" option for unit testing\n            // we share a single classloader so that pmd-java doesn't create\n            // a new TypeSystem for every test. This problem will go\n            // away when languages have a lifecycle.\n            configuration.setClassLoader(classpathClassLoader);\n\n            try (GlobalReportBuilderListener reportBuilder = new GlobalReportBuilderListener();\n                 // Add a listener that throws when an error occurs:\n                 //  this replaces ruleContext.setIgnoreExceptions(false)\n                 GlobalAnalysisListener listener = GlobalAnalysisListener.tee(listOf(GlobalAnalysisListener.exceptionThrower(), reportBuilder))) {\n\n                AbstractPMDProcessor.runSingleFile(\n                    listOf(RuleSet.forSingleRule(rule)),\n                    TextFile.forCharSeq(code, \"testFile\", languageVersion),\n                    listener,\n                    configuration\n                );\n\n                listener.close();\n                return reportBuilder.getResult();\n            }\n        } catch (RuntimeException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }",
        "filePathBefore": "pmd-test/src/main/java/net/sourceforge/pmd/testframework/RuleTst.java",
        "isPureRefactoring": true,
        "commitId": "d05148e4bdbd876fd19a6cb6d1b905f667019217",
        "packageNameBefore": "net.sourceforge.pmd.testframework",
        "classNameBefore": "net.sourceforge.pmd.testframework.RuleTst",
        "methodNameBefore": "net.sourceforge.pmd.testframework.RuleTst#runTestFromString",
        "classSignatureBefore": "public abstract class RuleTst ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.testframework.RuleTst#runTestFromString"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.testframework.RuleTst"
        ],
        "classSignatureBeforeSet": [
            "public abstract class RuleTst "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.testframework;\n\nimport static net.sourceforge.pmd.util.CollectionUtil.listOf;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.StringWriter;\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.junit.jupiter.api.DynamicTest;\nimport org.junit.jupiter.api.TestFactory;\nimport org.xml.sax.InputSource;\n\nimport net.sourceforge.pmd.PMDConfiguration;\nimport net.sourceforge.pmd.Report;\nimport net.sourceforge.pmd.Report.GlobalReportBuilderListener;\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RuleSet;\nimport net.sourceforge.pmd.RuleSetLoadException;\nimport net.sourceforge.pmd.RuleSetLoader;\nimport net.sourceforge.pmd.RuleViolation;\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.lang.LanguageVersion;\nimport net.sourceforge.pmd.lang.document.TextFile;\nimport net.sourceforge.pmd.processor.AbstractPMDProcessor;\nimport net.sourceforge.pmd.properties.PropertyDescriptor;\nimport net.sourceforge.pmd.renderers.TextRenderer;\nimport net.sourceforge.pmd.reporting.GlobalAnalysisListener;\nimport net.sourceforge.pmd.test.schema.RuleTestCollection;\nimport net.sourceforge.pmd.test.schema.RuleTestDescriptor;\nimport net.sourceforge.pmd.test.schema.TestSchemaParser;\n\n/**\n * Advanced methods for test cases\n */\npublic abstract class RuleTst {\n    /** Use a single classloader for all tests. */\n    private final ClassLoader classpathClassLoader;\n\n    public RuleTst() {\n        classpathClassLoader = makeClassPathClassLoader();\n    }\n\n    private ClassLoader makeClassPathClassLoader() {\n        final ClassLoader classpathClassLoader;\n        PMDConfiguration config = new PMDConfiguration();\n        config.prependAuxClasspath(\".\");\n        classpathClassLoader = config.getClassLoader();\n        return classpathClassLoader;\n    }\n\n\n    protected void setUp() {\n        // This method is intended to be overridden by subclasses.\n    }\n\n    protected List<Rule> getRules() {\n        return Collections.emptyList();\n    }\n\n    /**\n     * Find a rule in a certain ruleset by name\n     *\n     * todo make this static\n     */\n    public Rule findRule(String ruleSet, String ruleName) {\n        try {\n            RuleSet parsedRset = new RuleSetLoader().warnDeprecated(false).loadFromResource(ruleSet);\n            Rule rule = parsedRset.getRuleByName(ruleName);\n            if (rule == null) {\n                fail(\"Rule \" + ruleName + \" not found in ruleset \" + ruleSet);\n            } else {\n                rule.setRuleSetName(ruleSet);\n            }\n            return rule;\n        } catch (RuleSetLoadException e) {\n            e.printStackTrace();\n            fail(\"Couldn't find ruleset \" + ruleSet);\n            return null;\n        }\n    }\n\n    /**\n     * Run the rule on the given code, and check the expected number of violations.\n     */\n    void runTest(RuleTestDescriptor test) {\n        Rule rule = test.getRule();\n\n        // always reinitialize the rule, regardless of test.getReinitializeRule() (#3976 / #3302)\n        rule = reinitializeRule(rule);\n\n        Map<PropertyDescriptor<?>, Object> oldProperties = rule.getPropertiesByPropertyDescriptor();\n        try {\n            int res;\n            Report report;\n            try {\n                // Set test specific properties onto the Rule\n                if (test.getProperties() != null) {\n                    for (Map.Entry<Object, Object> entry : test.getProperties().entrySet()) {\n                        String propertyName = (String) entry.getKey();\n                        PropertyDescriptor propertyDescriptor = rule.getPropertyDescriptor(propertyName);\n                        if (propertyDescriptor == null) {\n                            throw new IllegalArgumentException(\n                                    \"No such property '\" + propertyName + \"' on Rule \" + rule.getName());\n                        }\n\n                        Object value = propertyDescriptor.valueFrom((String) entry.getValue());\n                        rule.setProperty(propertyDescriptor, value);\n                    }\n                }\n\n                String dysfunctionReason = rule.dysfunctionReason();\n                if (StringUtils.isNotBlank(dysfunctionReason)) {\n                    throw new RuntimeException(\"Rule is not configured correctly: \" + dysfunctionReason);\n                }\n\n                report = processUsingStringReader(test, rule);\n                res = report.getViolations().size();\n            } catch (Exception e) {\n                e.printStackTrace();\n                throw new RuntimeException('\"' + test.getDescription() + \"\\\" failed\", e);\n            }\n            if (test.getExpectedProblems() != res) {\n                printReport(test, report);\n            }\n            assertEquals(test.getExpectedProblems(), res,\n                    '\"' + test.getDescription() + \"\\\" resulted in wrong number of failures,\");\n            assertMessages(report, test);\n            assertLineNumbers(report, test);\n        } finally {\n            // Restore old properties\n            for (Map.Entry<PropertyDescriptor<?>, Object> entry : oldProperties.entrySet()) {\n                rule.setProperty((PropertyDescriptor) entry.getKey(), entry.getValue());\n            }\n        }\n    }\n\n\n    /**\n     * Code to be executed if the rule is reinitialised.\n     *\n     * @param rule The rule to reinitialise\n     *\n     * @return The rule once it has been reinitialised\n     */\n    protected Rule reinitializeRule(Rule rule) {\n        return findRule(rule.getRuleSetName(), rule.getName());\n    }\n\n\n    private void assertMessages(Report report, RuleTestDescriptor test) {\n        if (report == null || test.getExpectedMessages().isEmpty()) {\n            return;\n        }\n\n        List<String> expectedMessages = test.getExpectedMessages();\n        if (report.getViolations().size() != expectedMessages.size()) {\n            throw new RuntimeException(\"Test setup error: number of expected messages doesn't match \"\n                    + \"number of violations for test case '\" + test.getDescription() + \"'\");\n        }\n\n        int index = 0;\n        for (RuleViolation violation : report.getViolations()) {\n            String actual = violation.getDescription();\n            if (!expectedMessages.get(index).equals(actual)) {\n                printReport(test, report);\n            }\n            assertEquals(expectedMessages.get(index), actual,\n                         '\"' + test.getDescription() + \"\\\" produced wrong message on violation number \" + (index + 1) + \".\");\n            index++;\n        }\n    }\n\n    private void assertLineNumbers(Report report, RuleTestDescriptor test) {\n        if (report == null || test.getExpectedLineNumbers().isEmpty()) {\n            return;\n        }\n\n        List<Integer> expected = test.getExpectedLineNumbers();\n        if (report.getViolations().size() != expected.size()) {\n            throw new RuntimeException(\"Test setup error: number of expected line numbers \" + expected.size()\n                    + \" doesn't match number of violations \" + report.getViolations().size() + \" for test case '\"\n                    + test.getDescription() + \"'\");\n        }\n\n        int index = 0;\n        for (RuleViolation violation : report.getViolations()) {\n            Integer actual = violation.getBeginLine();\n            if (expected.get(index) != actual.intValue()) {\n                printReport(test, report);\n            }\n            assertEquals(expected.get(index), actual,\n                         '\"' + test.getDescription() + \"\\\" violation on wrong line number: violation number \"\n                         + (index + 1) + \".\");\n            index++;\n        }\n    }\n\n    private void printReport(RuleTestDescriptor test, Report report) {\n        System.out.println(\"--------------------------------------------------------------\");\n        System.out.println(\"Test Failure: \" + test.getDescription());\n        System.out.println(\" -> Expected \" + test.getExpectedProblems() + \" problem(s), \" + report.getViolations().size()\n                + \" problem(s) found.\");\n        System.out.println(\" -> Expected messages: \" + test.getExpectedMessages());\n        System.out.println(\" -> Expected line numbers: \" + test.getExpectedLineNumbers());\n        System.out.println();\n        TextRenderer renderer = new TextRenderer();\n        renderer.setWriter(new StringWriter());\n        try {\n            renderer.start();\n            renderer.renderFileReport(report);\n            renderer.end();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        System.out.println(renderer.getWriter().toString());\n        System.out.println(\"--------------------------------------------------------------\");\n    }\n\n    private Report processUsingStringReader(RuleTestDescriptor test, Rule rule) {\n        return runTestFromString(test.getCode(), rule, test.getLanguageVersion());\n    }\n\n    /**\n     * Run the rule on the given code and put the violations in the report.\n     */\n    @InternalApi\n    @Deprecated\n    public Report runTestFromString(String code, Rule rule, LanguageVersion languageVersion) {\n        return runTestFromString(code, rule, languageVersion, true);\n    }\n\n    @InternalApi\n    @Deprecated\n    public Report runTestFromString(String code, Rule rule, LanguageVersion languageVersion,\n            boolean isUseAuxClasspath) {\n        try {\n            PMDConfiguration configuration = new PMDConfiguration();\n            configuration.setIgnoreIncrementalAnalysis(true);\n            configuration.setDefaultLanguageVersion(languageVersion);\n            configuration.setThreads(1);\n            // regardless of isUseAuxClasspath the auxclasspath is always used (#3976 / #3302)\n            // configure the \"auxclasspath\" option for unit testing\n            // we share a single classloader so that pmd-java doesn't create\n            // a new TypeSystem for every test. This problem will go\n            // away when languages have a lifecycle.\n            configuration.setClassLoader(classpathClassLoader);\n\n            try (GlobalReportBuilderListener reportBuilder = new GlobalReportBuilderListener();\n                 // Add a listener that throws when an error occurs:\n                 //  this replaces ruleContext.setIgnoreExceptions(false)\n                 GlobalAnalysisListener listener = GlobalAnalysisListener.tee(listOf(GlobalAnalysisListener.exceptionThrower(), reportBuilder))) {\n\n                AbstractPMDProcessor.runSingleFile(\n                    listOf(RuleSet.forSingleRule(rule)),\n                    TextFile.forCharSeq(code, \"testFile\", languageVersion),\n                    listener,\n                    configuration\n                );\n\n                listener.close();\n                return reportBuilder.getResult();\n            }\n        } catch (RuntimeException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    /**\n     * getResourceAsStream tries to find the XML file in weird locations if the\n     * ruleName includes the package, so we strip it here.\n     */\n    private String getCleanRuleName(Rule rule) {\n        String fullClassName = rule.getClass().getName();\n        if (fullClassName.equals(rule.getName())) {\n            // We got the full class name, so we'll use the stripped name\n            // instead\n            String packageName = rule.getClass().getPackage().getName();\n            return fullClassName.substring(packageName.length() + 1);\n        } else {\n            return rule.getName(); // Test is using findRule, smart!\n        }\n    }\n\n    /**\n     * Extract a set of tests from an XML file. The file should be\n     * ./xml/RuleName.xml relative to the test class. The format is defined in\n     * rule-tests_1_0_0.xsd in pmd-test-schema.\n     */\n    RuleTestCollection parseTestCollection(Rule rule) {\n        String testsFileName = getCleanRuleName(rule);\n        return parseTestCollection(rule, testsFileName);\n    }\n\n    private RuleTestCollection parseTestCollection(Rule rule, String testsFileName) {\n        return parseTestXml(rule, testsFileName, \"xml/\");\n    }\n\n    /**\n     * Extract a set of tests from an XML file with the given name. The file\n     * should be ./xml/[testsFileName].xml relative to the test class. The\n     * format is defined in test-data.xsd.\n     */\n    private RuleTestCollection parseTestXml(Rule rule, String testsFileName, String baseDirectory) {\n        String testXmlFileName = baseDirectory + testsFileName + \".xml\";\n        String absoluteUriToTestXmlFile = new File(\".\").getAbsoluteFile().toURI() + \"/src/test/resources/\"\n                + this.getClass().getPackage().getName().replaceAll(\"\\\\.\", \"/\")\n                + \"/\" + testXmlFileName;\n\n        try (InputStream inputStream = getClass().getResourceAsStream(testXmlFileName)) {\n            if (inputStream == null) {\n                throw new RuntimeException(\"Couldn't find \" + testXmlFileName);\n            }\n            InputSource source = new InputSource();\n            source.setByteStream(inputStream);\n            source.setSystemId(testXmlFileName);\n            TestSchemaParser parser = new TestSchemaParser();\n            RuleTestCollection ruleTestCollection = parser.parse(rule, source);\n            ruleTestCollection.setAbsoluteUriToTestXmlFile(absoluteUriToTestXmlFile);\n            return ruleTestCollection;\n        } catch (Exception e) {\n            throw new RuntimeException(\"Couldn't parse \" + testXmlFileName + \", due to: \" + e, e);\n        }\n    }\n\n    /**\n     * Run a set of tests defined in an XML test-data file for a rule. The file\n     * should be ./xml/RuleName.xml relative to the test-class. The format is\n     * defined in test-data.xsd.\n     */\n    public void runTests(Rule rule) {\n        runTests(parseTestCollection(rule));\n    }\n\n    /**\n     * Run a set of tests defined in a XML test-data file. The file should be\n     * ./xml/[testsFileName].xml relative to the test-class. The format is\n     * defined in test-data.xsd.\n     */\n    public void runTests(Rule rule, String testsFileName) {\n        runTests(parseTestCollection(rule, testsFileName));\n    }\n\n    private void runTests(RuleTestCollection tests) {\n        for (RuleTestDescriptor test : tests.getTests()) {\n            runTest(test);\n        }\n    }\n\n    @TestFactory\n    Collection<DynamicTest> ruleTests() {\n        setUp();\n        final List<Rule> rules = new ArrayList<>(getRules());\n        rules.sort(Comparator.comparing(Rule::getName));\n\n        List<DynamicTest> tests = new ArrayList<>();\n        for (Rule r : rules) {\n            RuleTestCollection ruleTests = parseTestCollection(r);\n            RuleTestDescriptor focused = ruleTests.getFocusedTestOrNull();\n            for (RuleTestDescriptor t : ruleTests.getTests()) {\n                if (focused != null && !focused.equals(t)) {\n                    t.setDisabled(true); // disable it\n                }\n                tests.add(toDynamicTest(ruleTests, t));\n            }\n        }\n        return tests;\n    }\n\n    private DynamicTest toDynamicTest(RuleTestCollection collection, RuleTestDescriptor testDescriptor) {\n        URI testSourceUri = URI.create(collection.getAbsoluteUriToTestXmlFile() + \"?line=\" + testDescriptor.getLineNumber());\n        if (testDescriptor.isDisabled()) {\n            return DynamicTest.dynamicTest(\"[IGNORED] \" + testDescriptor.getDescription(),\n                    testSourceUri,\n                    () -> {});\n        }\n        return DynamicTest.dynamicTest(testDescriptor.getDescription(),\n                testSourceUri,\n                () -> runTest(testDescriptor));\n    }\n}\n",
        "filePathAfter": "pmd-test/src/main/java/net/sourceforge/pmd/testframework/RuleTst.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.testframework;\n\nimport static net.sourceforge.pmd.util.CollectionUtil.listOf;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.StringWriter;\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.junit.jupiter.api.DynamicTest;\nimport org.junit.jupiter.api.TestFactory;\nimport org.xml.sax.InputSource;\n\nimport net.sourceforge.pmd.PMDConfiguration;\nimport net.sourceforge.pmd.Report;\nimport net.sourceforge.pmd.Report.GlobalReportBuilderListener;\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RuleSet;\nimport net.sourceforge.pmd.RuleSetLoadException;\nimport net.sourceforge.pmd.RuleSetLoader;\nimport net.sourceforge.pmd.RuleViolation;\nimport net.sourceforge.pmd.lang.LanguageVersion;\nimport net.sourceforge.pmd.lang.document.TextFile;\nimport net.sourceforge.pmd.processor.AbstractPMDProcessor;\nimport net.sourceforge.pmd.properties.PropertyDescriptor;\nimport net.sourceforge.pmd.renderers.TextRenderer;\nimport net.sourceforge.pmd.reporting.GlobalAnalysisListener;\nimport net.sourceforge.pmd.test.schema.RuleTestCollection;\nimport net.sourceforge.pmd.test.schema.RuleTestDescriptor;\nimport net.sourceforge.pmd.test.schema.TestSchemaParser;\n\n/**\n * Advanced methods for test cases\n */\npublic abstract class RuleTst {\n    /** Use a single classloader for all tests. */\n    private final ClassLoader classpathClassLoader;\n\n    public RuleTst() {\n        classpathClassLoader = makeClassPathClassLoader();\n    }\n\n    private ClassLoader makeClassPathClassLoader() {\n        final ClassLoader classpathClassLoader;\n        PMDConfiguration config = new PMDConfiguration();\n        config.prependAuxClasspath(\".\");\n        classpathClassLoader = config.getClassLoader();\n        return classpathClassLoader;\n    }\n\n\n    protected void setUp() {\n        // This method is intended to be overridden by subclasses.\n    }\n\n    protected List<Rule> getRules() {\n        return Collections.emptyList();\n    }\n\n    /**\n     * Find a rule in a certain ruleset by name\n     *\n     * todo make this static\n     */\n    public Rule findRule(String ruleSet, String ruleName) {\n        try {\n            RuleSet parsedRset = new RuleSetLoader().warnDeprecated(false).loadFromResource(ruleSet);\n            Rule rule = parsedRset.getRuleByName(ruleName);\n            if (rule == null) {\n                fail(\"Rule \" + ruleName + \" not found in ruleset \" + ruleSet);\n            } else {\n                rule.setRuleSetName(ruleSet);\n            }\n            return rule;\n        } catch (RuleSetLoadException e) {\n            e.printStackTrace();\n            fail(\"Couldn't find ruleset \" + ruleSet);\n            return null;\n        }\n    }\n\n    /**\n     * Run the rule on the given code, and check the expected number of violations.\n     */\n    void runTest(RuleTestDescriptor test) {\n        Rule rule = test.getRule();\n\n        // always reinitialize the rule, regardless of test.getReinitializeRule() (#3976 / #3302)\n        rule = reinitializeRule(rule);\n\n        Map<PropertyDescriptor<?>, Object> oldProperties = rule.getPropertiesByPropertyDescriptor();\n        try {\n            int res;\n            Report report;\n            try {\n                // Set test specific properties onto the Rule\n                if (test.getProperties() != null) {\n                    for (Map.Entry<Object, Object> entry : test.getProperties().entrySet()) {\n                        String propertyName = (String) entry.getKey();\n                        PropertyDescriptor propertyDescriptor = rule.getPropertyDescriptor(propertyName);\n                        if (propertyDescriptor == null) {\n                            throw new IllegalArgumentException(\n                                    \"No such property '\" + propertyName + \"' on Rule \" + rule.getName());\n                        }\n\n                        Object value = propertyDescriptor.valueFrom((String) entry.getValue());\n                        rule.setProperty(propertyDescriptor, value);\n                    }\n                }\n\n                String dysfunctionReason = rule.dysfunctionReason();\n                if (StringUtils.isNotBlank(dysfunctionReason)) {\n                    throw new RuntimeException(\"Rule is not configured correctly: \" + dysfunctionReason);\n                }\n\n                report = processUsingStringReader(test, rule);\n                res = report.getViolations().size();\n            } catch (Exception e) {\n                e.printStackTrace();\n                throw new RuntimeException('\"' + test.getDescription() + \"\\\" failed\", e);\n            }\n            if (test.getExpectedProblems() != res) {\n                printReport(test, report);\n            }\n            assertEquals(test.getExpectedProblems(), res,\n                    '\"' + test.getDescription() + \"\\\" resulted in wrong number of failures,\");\n            assertMessages(report, test);\n            assertLineNumbers(report, test);\n        } finally {\n            // Restore old properties\n            for (Map.Entry<PropertyDescriptor<?>, Object> entry : oldProperties.entrySet()) {\n                rule.setProperty((PropertyDescriptor) entry.getKey(), entry.getValue());\n            }\n        }\n    }\n\n\n    /**\n     * Code to be executed if the rule is reinitialised.\n     *\n     * @param rule The rule to reinitialise\n     *\n     * @return The rule once it has been reinitialised\n     */\n    protected Rule reinitializeRule(Rule rule) {\n        return findRule(rule.getRuleSetName(), rule.getName());\n    }\n\n\n    private void assertMessages(Report report, RuleTestDescriptor test) {\n        if (report == null || test.getExpectedMessages().isEmpty()) {\n            return;\n        }\n\n        List<String> expectedMessages = test.getExpectedMessages();\n        if (report.getViolations().size() != expectedMessages.size()) {\n            throw new RuntimeException(\"Test setup error: number of expected messages doesn't match \"\n                    + \"number of violations for test case '\" + test.getDescription() + \"'\");\n        }\n\n        int index = 0;\n        for (RuleViolation violation : report.getViolations()) {\n            String actual = violation.getDescription();\n            if (!expectedMessages.get(index).equals(actual)) {\n                printReport(test, report);\n            }\n            assertEquals(expectedMessages.get(index), actual,\n                         '\"' + test.getDescription() + \"\\\" produced wrong message on violation number \" + (index + 1) + \".\");\n            index++;\n        }\n    }\n\n    private void assertLineNumbers(Report report, RuleTestDescriptor test) {\n        if (report == null || test.getExpectedLineNumbers().isEmpty()) {\n            return;\n        }\n\n        List<Integer> expected = test.getExpectedLineNumbers();\n        if (report.getViolations().size() != expected.size()) {\n            throw new RuntimeException(\"Test setup error: number of expected line numbers \" + expected.size()\n                    + \" doesn't match number of violations \" + report.getViolations().size() + \" for test case '\"\n                    + test.getDescription() + \"'\");\n        }\n\n        int index = 0;\n        for (RuleViolation violation : report.getViolations()) {\n            Integer actual = violation.getBeginLine();\n            if (expected.get(index) != actual.intValue()) {\n                printReport(test, report);\n            }\n            assertEquals(expected.get(index), actual,\n                         '\"' + test.getDescription() + \"\\\" violation on wrong line number: violation number \"\n                         + (index + 1) + \".\");\n            index++;\n        }\n    }\n\n    private void printReport(RuleTestDescriptor test, Report report) {\n        System.out.println(\"--------------------------------------------------------------\");\n        System.out.println(\"Test Failure: \" + test.getDescription());\n        System.out.println(\" -> Expected \" + test.getExpectedProblems() + \" problem(s), \" + report.getViolations().size()\n                + \" problem(s) found.\");\n        System.out.println(\" -> Expected messages: \" + test.getExpectedMessages());\n        System.out.println(\" -> Expected line numbers: \" + test.getExpectedLineNumbers());\n        System.out.println();\n        TextRenderer renderer = new TextRenderer();\n        renderer.setWriter(new StringWriter());\n        try {\n            renderer.start();\n            renderer.renderFileReport(report);\n            renderer.end();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        System.out.println(renderer.getWriter().toString());\n        System.out.println(\"--------------------------------------------------------------\");\n    }\n\n    private Report processUsingStringReader(RuleTestDescriptor test, Rule rule) {\n        return runTestFromString(test.getCode(), rule, test.getLanguageVersion());\n    }\n\n    /**\n     * Run the rule on the given code and put the violations in the report.\n     */\n    Report runTestFromString(String code, Rule rule, LanguageVersion languageVersion) {\n        try {\n            PMDConfiguration configuration = new PMDConfiguration();\n            configuration.setIgnoreIncrementalAnalysis(true);\n            configuration.setDefaultLanguageVersion(languageVersion);\n            configuration.setThreads(1);\n            // the auxclasspath is always used (#3976 / #3302)\n            // configure the \"auxclasspath\" option for unit testing\n            // we share a single classloader so that pmd-java doesn't create\n            // a new TypeSystem for every test. This problem will go\n            // away when languages have a lifecycle.\n            configuration.setClassLoader(classpathClassLoader);\n\n            try (GlobalReportBuilderListener reportBuilder = new GlobalReportBuilderListener();\n                 // Add a listener that throws when an error occurs:\n                 //  this replaces ruleContext.setIgnoreExceptions(false)\n                 GlobalAnalysisListener listener = GlobalAnalysisListener.tee(listOf(GlobalAnalysisListener.exceptionThrower(), reportBuilder))) {\n\n                AbstractPMDProcessor.runSingleFile(\n                    listOf(RuleSet.forSingleRule(rule)),\n                    TextFile.forCharSeq(code, \"testFile\", languageVersion),\n                    listener,\n                    configuration\n                );\n\n                listener.close();\n                return reportBuilder.getResult();\n            }\n        } catch (RuntimeException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    /**\n     * getResourceAsStream tries to find the XML file in weird locations if the\n     * ruleName includes the package, so we strip it here.\n     */\n    private String getCleanRuleName(Rule rule) {\n        String fullClassName = rule.getClass().getName();\n        if (fullClassName.equals(rule.getName())) {\n            // We got the full class name, so we'll use the stripped name\n            // instead\n            String packageName = rule.getClass().getPackage().getName();\n            return fullClassName.substring(packageName.length() + 1);\n        } else {\n            return rule.getName(); // Test is using findRule, smart!\n        }\n    }\n\n    /**\n     * Extract a set of tests from an XML file. The file should be\n     * ./xml/RuleName.xml relative to the test class. The format is defined in\n     * rule-tests_1_0_0.xsd in pmd-test-schema.\n     */\n    RuleTestCollection parseTestCollection(Rule rule) {\n        String testsFileName = getCleanRuleName(rule);\n        return parseTestCollection(rule, testsFileName);\n    }\n\n    private RuleTestCollection parseTestCollection(Rule rule, String testsFileName) {\n        return parseTestXml(rule, testsFileName, \"xml/\");\n    }\n\n    /**\n     * Extract a set of tests from an XML file with the given name. The file\n     * should be ./xml/[testsFileName].xml relative to the test class. The\n     * format is defined in test-data.xsd.\n     */\n    private RuleTestCollection parseTestXml(Rule rule, String testsFileName, String baseDirectory) {\n        String testXmlFileName = baseDirectory + testsFileName + \".xml\";\n        String absoluteUriToTestXmlFile = new File(\".\").getAbsoluteFile().toURI() + \"/src/test/resources/\"\n                + this.getClass().getPackage().getName().replaceAll(\"\\\\.\", \"/\")\n                + \"/\" + testXmlFileName;\n\n        try (InputStream inputStream = getClass().getResourceAsStream(testXmlFileName)) {\n            if (inputStream == null) {\n                throw new RuntimeException(\"Couldn't find \" + testXmlFileName);\n            }\n            InputSource source = new InputSource();\n            source.setByteStream(inputStream);\n            source.setSystemId(testXmlFileName);\n            TestSchemaParser parser = new TestSchemaParser();\n            RuleTestCollection ruleTestCollection = parser.parse(rule, source);\n            ruleTestCollection.setAbsoluteUriToTestXmlFile(absoluteUriToTestXmlFile);\n            return ruleTestCollection;\n        } catch (Exception e) {\n            throw new RuntimeException(\"Couldn't parse \" + testXmlFileName + \", due to: \" + e, e);\n        }\n    }\n\n    /**\n     * Run a set of tests defined in an XML test-data file for a rule. The file\n     * should be ./xml/RuleName.xml relative to the test-class. The format is\n     * defined in test-data.xsd.\n     */\n    public void runTests(Rule rule) {\n        runTests(parseTestCollection(rule));\n    }\n\n    /**\n     * Run a set of tests defined in a XML test-data file. The file should be\n     * ./xml/[testsFileName].xml relative to the test-class. The format is\n     * defined in test-data.xsd.\n     */\n    public void runTests(Rule rule, String testsFileName) {\n        runTests(parseTestCollection(rule, testsFileName));\n    }\n\n    private void runTests(RuleTestCollection tests) {\n        for (RuleTestDescriptor test : tests.getTests()) {\n            runTest(test);\n        }\n    }\n\n    @TestFactory\n    Collection<DynamicTest> ruleTests() {\n        setUp();\n        final List<Rule> rules = new ArrayList<>(getRules());\n        rules.sort(Comparator.comparing(Rule::getName));\n\n        List<DynamicTest> tests = new ArrayList<>();\n        for (Rule r : rules) {\n            RuleTestCollection ruleTests = parseTestCollection(r);\n            RuleTestDescriptor focused = ruleTests.getFocusedTestOrNull();\n            for (RuleTestDescriptor t : ruleTests.getTests()) {\n                if (focused != null && !focused.equals(t)) {\n                    t.setDisabled(true); // disable it\n                }\n                tests.add(toDynamicTest(ruleTests, t));\n            }\n        }\n        return tests;\n    }\n\n    private DynamicTest toDynamicTest(RuleTestCollection collection, RuleTestDescriptor testDescriptor) {\n        URI testSourceUri = URI.create(collection.getAbsoluteUriToTestXmlFile() + \"?line=\" + testDescriptor.getLineNumber());\n        if (testDescriptor.isDisabled()) {\n            return DynamicTest.dynamicTest(\"[IGNORED] \" + testDescriptor.getDescription(),\n                    testSourceUri,\n                    () -> {});\n        }\n        return DynamicTest.dynamicTest(testDescriptor.getDescription(),\n                testSourceUri,\n                () -> runTest(testDescriptor));\n    }\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "/**\n     * Run the rule on the given code and put the violations in the report.\n     */\n    Report runTestFromString(String code, Rule rule, LanguageVersion languageVersion) {\n        try {\n            PMDConfiguration configuration = new PMDConfiguration();\n            configuration.setIgnoreIncrementalAnalysis(true);\n            configuration.setDefaultLanguageVersion(languageVersion);\n            configuration.setThreads(1);\n            // the auxclasspath is always used (#3976 / #3302)\n            // configure the \"auxclasspath\" option for unit testing\n            // we share a single classloader so that pmd-java doesn't create\n            // a new TypeSystem for every test. This problem will go\n            // away when languages have a lifecycle.\n            configuration.setClassLoader(classpathClassLoader);\n\n            try (GlobalReportBuilderListener reportBuilder = new GlobalReportBuilderListener();\n                 // Add a listener that throws when an error occurs:\n                 //  this replaces ruleContext.setIgnoreExceptions(false)\n                 GlobalAnalysisListener listener = GlobalAnalysisListener.tee(listOf(GlobalAnalysisListener.exceptionThrower(), reportBuilder))) {\n\n                AbstractPMDProcessor.runSingleFile(\n                    listOf(RuleSet.forSingleRule(rule)),\n                    TextFile.forCharSeq(code, \"testFile\", languageVersion),\n                    listener,\n                    configuration\n                );\n\n                listener.close();\n                return reportBuilder.getResult();\n            }\n        } catch (RuntimeException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }",
        "diffSourceCode": "-  237: \n-  238:     /**\n-  239:      * Run the rule on the given code and put the violations in the report.\n-  240:      */\n-  241:     @InternalApi\n-  242:     @Deprecated\n-  243:     public Report runTestFromString(String code, Rule rule, LanguageVersion languageVersion) {\n-  244:         return runTestFromString(code, rule, languageVersion, true);\n-  245:     }\n-  246: \n-  247:     @InternalApi\n-  248:     @Deprecated\n-  249:     public Report runTestFromString(String code, Rule rule, LanguageVersion languageVersion,\n-  250:             boolean isUseAuxClasspath) {\n-  251:         try {\n-  252:             PMDConfiguration configuration = new PMDConfiguration();\n-  253:             configuration.setIgnoreIncrementalAnalysis(true);\n-  254:             configuration.setDefaultLanguageVersion(languageVersion);\n-  255:             configuration.setThreads(1);\n-  256:             // regardless of isUseAuxClasspath the auxclasspath is always used (#3976 / #3302)\n-  257:             // configure the \"auxclasspath\" option for unit testing\n-  258:             // we share a single classloader so that pmd-java doesn't create\n-  259:             // a new TypeSystem for every test. This problem will go\n-  260:             // away when languages have a lifecycle.\n-  261:             configuration.setClassLoader(classpathClassLoader);\n-  262: \n-  263:             try (GlobalReportBuilderListener reportBuilder = new GlobalReportBuilderListener();\n-  264:                  // Add a listener that throws when an error occurs:\n-  265:                  //  this replaces ruleContext.setIgnoreExceptions(false)\n-  266:                  GlobalAnalysisListener listener = GlobalAnalysisListener.tee(listOf(GlobalAnalysisListener.exceptionThrower(), reportBuilder))) {\n-  267: \n-  268:                 AbstractPMDProcessor.runSingleFile(\n-  269:                     listOf(RuleSet.forSingleRule(rule)),\n-  270:                     TextFile.forCharSeq(code, \"testFile\", languageVersion),\n-  271:                     listener,\n-  272:                     configuration\n-  273:                 );\n+  237:     /**\n+  238:      * Run the rule on the given code and put the violations in the report.\n+  239:      */\n+  240:     Report runTestFromString(String code, Rule rule, LanguageVersion languageVersion) {\n+  241:         try {\n+  242:             PMDConfiguration configuration = new PMDConfiguration();\n+  243:             configuration.setIgnoreIncrementalAnalysis(true);\n+  244:             configuration.setDefaultLanguageVersion(languageVersion);\n+  245:             configuration.setThreads(1);\n+  246:             // the auxclasspath is always used (#3976 / #3302)\n+  247:             // configure the \"auxclasspath\" option for unit testing\n+  248:             // we share a single classloader so that pmd-java doesn't create\n+  249:             // a new TypeSystem for every test. This problem will go\n+  250:             // away when languages have a lifecycle.\n+  251:             configuration.setClassLoader(classpathClassLoader);\n+  252: \n+  253:             try (GlobalReportBuilderListener reportBuilder = new GlobalReportBuilderListener();\n+  254:                  // Add a listener that throws when an error occurs:\n+  255:                  //  this replaces ruleContext.setIgnoreExceptions(false)\n+  256:                  GlobalAnalysisListener listener = GlobalAnalysisListener.tee(listOf(GlobalAnalysisListener.exceptionThrower(), reportBuilder))) {\n+  257: \n+  258:                 AbstractPMDProcessor.runSingleFile(\n+  259:                     listOf(RuleSet.forSingleRule(rule)),\n+  260:                     TextFile.forCharSeq(code, \"testFile\", languageVersion),\n+  261:                     listener,\n+  262:                     configuration\n+  263:                 );\n+  264: \n+  265:                 listener.close();\n+  266:                 return reportBuilder.getResult();\n+  267:             }\n+  268:         } catch (RuntimeException e) {\n+  269:             throw e;\n+  270:         } catch (Exception e) {\n+  271:             throw new RuntimeException(e);\n+  272:         }\n+  273:     }\n   274: \n-  275:                 listener.close();\n-  276:                 return reportBuilder.getResult();\n-  277:             }\n-  278:         } catch (RuntimeException e) {\n-  279:             throw e;\n-  280:         } catch (Exception e) {\n-  281:             throw new RuntimeException(e);\n-  282:         }\n-  283:     }\n+  275:     /**\n+  276:      * getResourceAsStream tries to find the XML file in weird locations if the\n+  277:      * ruleName includes the package, so we strip it here.\n+  278:      */\n+  279:     private String getCleanRuleName(Rule rule) {\n+  280:         String fullClassName = rule.getClass().getName();\n+  281:         if (fullClassName.equals(rule.getName())) {\n+  282:             // We got the full class name, so we'll use the stripped name\n+  283:             // instead\n",
        "uniqueId": "d05148e4bdbd876fd19a6cb6d1b905f667019217_238_245__237_273_247_283",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 9,
                "covered": 51
            },
            "LINE": {
                "missed": 4,
                "covered": 12
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic getTypeAnnotations() : List<SymAnnot> extracted from public unbox() : JTypeMirror in class net.sourceforge.pmd.lang.java.types.BoxedPrimitive & moved to class net.sourceforge.pmd.lang.java.types.JArrayType",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/BoxedPrimitive.java",
                "startLine": 30,
                "endLine": 33,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/BoxedPrimitive.java",
                "startLine": 46,
                "endLine": 49,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/BoxedPrimitive.java",
                "startLine": 63,
                "endLine": 66,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n    public JTypeMirror unbox() {\n        return unboxed;\n    }",
        "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/BoxedPrimitive.java",
        "isPureRefactoring": true,
        "commitId": "994b8402d59773888977d768d395526acfe5cf16",
        "packageNameBefore": "net.sourceforge.pmd.lang.java.types",
        "classNameBefore": "net.sourceforge.pmd.lang.java.types.BoxedPrimitive",
        "methodNameBefore": "net.sourceforge.pmd.lang.java.types.BoxedPrimitive#unbox",
        "classSignatureBefore": "final class BoxedPrimitive extends ClassTypeImpl ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.types.BoxedPrimitive#unbox"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.types.BoxedPrimitive"
        ],
        "classSignatureBeforeSet": [
            "final class BoxedPrimitive extends ClassTypeImpl "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.types;\n\nimport java.util.Collections;\n\nimport net.sourceforge.pmd.lang.java.symbols.JClassSymbol;\n\n/**\n * Special primitive wrappers, these are the only ones for which\n * {@link #unbox()} is not the identity conversion.\n *\n * <p>Order of initialization is tricky since there is a circular\n * dependency between JPrimitiveType constants and their PrimitiveWrapper.\n * The current solution is to leak the 'this' instance in the enum\n * constructor.\n */\nfinal class BoxedPrimitive extends ClassTypeImpl {\n\n    private final JPrimitiveType unboxed;\n\n    // constructor called by JPrimitiveType, exactly once per type system and per primitive\n    BoxedPrimitive(TypeSystem factory, JClassSymbol boxType, JPrimitiveType unboxed) {\n        super(factory, boxType, Collections.emptyList(), true); // not erased\n        this.unboxed = unboxed;\n    }\n\n    @Override\n    public JTypeMirror unbox() {\n        return unboxed;\n    }\n\n    @Override\n    public JClassType getErasure() {\n        return this;\n    }\n}\n",
        "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/BoxedPrimitive.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.types;\n\nimport static java.util.Collections.emptyList;\n\nimport java.util.List;\n\nimport net.sourceforge.pmd.lang.java.symbols.JClassSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.SymbolicValue.SymAnnot;\n\n/**\n * Special primitive wrappers, these are the only ones for which\n * {@link #unbox()} is not the identity conversion.\n *\n * <p>Order of initialization is tricky since there is a circular\n * dependency between JPrimitiveType constants and their PrimitiveWrapper.\n * The current solution is to leak the 'this' instance in the enum\n * constructor.\n */\nfinal class BoxedPrimitive extends ClassTypeImpl {\n\n    private final JPrimitiveType unboxed;\n\n    // constructor called by JPrimitiveType, exactly once per type system and per primitive\n    BoxedPrimitive(TypeSystem factory, JClassSymbol boxType, JPrimitiveType unboxed, List<SymAnnot> typeAnnots) {\n        super(factory, boxType, emptyList(), true, typeAnnots); // not erased\n        this.unboxed = unboxed;\n    }\n\n    @Override\n    public JTypeMirror withAnnotations(List<SymAnnot> symAnnots) {\n        if (symAnnots.equals(this.getTypeAnnotations())) {\n            return this;\n        }\n        return new BoxedPrimitive(\n            getTypeSystem(),\n            this.getSymbol(),\n            this.unboxed,\n            symAnnots\n        );\n    }\n\n    @Override\n    public JTypeMirror unbox() {\n        return unboxed.withAnnotations(this.getTypeAnnotations());\n    }\n\n    @Override\n    public JClassType getErasure() {\n        return this;\n    }\n}\n",
        "diffSourceCodeSet": [
            ""
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "@Override\n    public JTypeMirror unbox() {\n        return unboxed.withAnnotations(this.getTypeAnnotations());\n    }\n",
        "diffSourceCode": "-   30:     @Override\n-   31:     public JTypeMirror unbox() {\n-   32:         return unboxed;\n-   33:     }\n+   30:         this.unboxed = unboxed;\n+   31:     }\n+   32: \n+   33:     @Override\n+   46:     @Override\n+   47:     public JTypeMirror unbox() {\n+   48:         return unboxed.withAnnotations(this.getTypeAnnotations());\n+   49:     }\n",
        "uniqueId": "994b8402d59773888977d768d395526acfe5cf16_30_33_63_66_46_49",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 3
            },
            "LINE": {
                "missed": 0,
                "covered": 1
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic supportedRenderers() : Set<String> extracted from private getReports() : String in class net.sourceforge.pmd.cli.PMDCommandLineInterface & moved to class net.sourceforge.pmd.renderers.RendererFactory",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/cli/PMDCommandLineInterface.java",
                "startLine": 167,
                "endLine": 190,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/cli/PMDCommandLineInterface.java",
                "startLine": 167,
                "endLine": 190,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/cli/PMDCommandLineInterface.java",
                "startLine": 56,
                "endLine": 63,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private static String getReports() {\n        StringBuilder buf = new StringBuilder();\n        for (String reportName : RendererFactory.REPORT_FORMAT_TO_RENDERER.keySet()) {\n            Renderer renderer = RendererFactory.createRenderer(reportName, new Properties());\n            buf.append(\"   \").append(reportName).append(\": \");\n            if (!reportName.equals(renderer.getName())) {\n                buf.append(\" Deprecated alias for '\").append(renderer.getName()).append(PMD.EOL);\n                continue;\n            }\n            buf.append(renderer.getDescription()).append(PMD.EOL);\n\n            for (PropertyDescriptor<?> property : renderer.getPropertyDescriptors()) {\n                buf.append(\"        \").append(property.name()).append(\" - \");\n                buf.append(property.description());\n                Object deflt = property.defaultValue();\n                if (deflt != null) {\n                    buf.append(\"   default: \").append(deflt);\n                }\n                buf.append(PMD.EOL);\n            }\n\n        }\n        return buf.toString();\n    }",
        "filePathBefore": "pmd-core/src/main/java/net/sourceforge/pmd/cli/PMDCommandLineInterface.java",
        "isPureRefactoring": true,
        "commitId": "e4f5d027b2d86f675208d8da53d0bb4b6365ad20",
        "packageNameBefore": "net.sourceforge.pmd.cli",
        "classNameBefore": "net.sourceforge.pmd.cli.PMDCommandLineInterface",
        "methodNameBefore": "net.sourceforge.pmd.cli.PMDCommandLineInterface#getReports",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.ant.Formatter#toString\n methodBody: public String toString() {\nreturn \"file = \" + toFile + \"; renderer = \" + type;\n}\nmethodSignature: net.sourceforge.pmd.ant.Formatter#createRenderer\n methodBody: Renderer createRenderer() {\nif(StringUtils.isBlank(type)){throw new BuildException(unknownRendererMessage(\"<unspecified>\"));\n}Properties properties=createProperties();\nRenderer renderer=RendererFactory.createRenderer(type,properties);\nrenderer.setShowSuppressedViolations(showSuppressed);\nreturn renderer;\n}\nmethodSignature: net.sourceforge.pmd.renderers.RendererFactory#createRenderer\n methodBody: public static Renderer createRenderer(String reportFormat, Properties properties) {\nAssertionUtil.requireParamNotNull(\"reportFormat\",reportFormat);\nClass<? extends Renderer> rendererClass=getRendererClass(reportFormat);\nConstructor<? extends Renderer> constructor=getRendererConstructor(rendererClass);\nRenderer renderer;\ntryif(constructor.getParameterTypes().length > 0){LOG.warn(\"The renderer uses a deprecated mechanism to use the properties. Please define the needed properties with this.definePropertyDescriptor(..).\");\nrenderer=constructor.newInstance(properties);\n}{renderer=constructor.newInstance();\nfor(PropertyDescriptor<?> prop: renderer.getPropertyDescriptors()){String value=properties.getProperty(prop.name());\nif(value != null){@SuppressWarnings(\"unchecked\") PropertyDescriptor<Object> prop2=(PropertyDescriptor<Object>)prop;\nObject valueFrom=prop2.valueFrom(value);\nrenderer.setProperty(prop2,valueFrom);\n}}}catch(InstantiationException|IllegalAccessException e)throw new IllegalArgumentException(\"Unable to construct report renderer class: \" + e.getLocalizedMessage(),e);\ncatch(InvocationTargetException e)throw new IllegalArgumentException(\"Unable to construct report renderer class: \" + e.getTargetException().getLocalizedMessage(),e);\nif(REPORT_FORMAT_TO_RENDERER.containsKey(reportFormat) && !reportFormat.equals(renderer.getName())){LOG.warn(\"Report format '{}' is deprecated, and has been replaced with '{}'. \" + \"Future versions of PMD will remove support for this deprecated Report format usage.\",reportFormat,renderer.getName());\n}return renderer;\n}",
        "classSignatureBefore": "public final class PMDCommandLineInterface ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.cli.PMDCommandLineInterface#getReports"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.cli.PMDCommandLineInterface"
        ],
        "classSignatureBeforeSet": [
            "public final class PMDCommandLineInterface "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.cli;\n\nimport java.util.Properties;\n\nimport net.sourceforge.pmd.PMD;\nimport net.sourceforge.pmd.PMD.StatusCode;\nimport net.sourceforge.pmd.PMDVersion;\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.lang.Language;\nimport net.sourceforge.pmd.lang.LanguageRegistry;\nimport net.sourceforge.pmd.properties.PropertyDescriptor;\nimport net.sourceforge.pmd.renderers.Renderer;\nimport net.sourceforge.pmd.renderers.RendererFactory;\n\nimport com.beust.jcommander.JCommander;\nimport com.beust.jcommander.ParameterException;\n\n/**\n * @author Romain Pelisse &lt;belaran@gmail.com&gt;\n * @deprecated Internal API. Use {@link PMD#runPmd(String...)} or {@link PMD#main(String[])},\n *     or {@link PmdParametersParseResult} if you just want to produce a configuration.\n */\n@Deprecated\n@InternalApi\npublic final class PMDCommandLineInterface {\n\n    @Deprecated\n    public static final String PROG_NAME = \"pmd\";\n\n    /**\n     * @deprecated This is used for testing, but support for it will be removed in PMD 7.\n     * Use {@link PMD#runPmd(String...)} or an overload to avoid exiting the VM. In PMD 7,\n     * {@link PMD#main(String[])} will call {@link System#exit(int)} always.\n     */\n    @Deprecated\n    public static final String NO_EXIT_AFTER_RUN = \"net.sourceforge.pmd.cli.noExit\";\n\n    /**\n     * @deprecated This is used for testing, but support for it will be removed in PMD 7.\n     * Use {@link PMD#runPmd(String...)} or an overload to avoid exiting the VM. In PMD 7,\n     * {@link PMD#main(String[])} will call {@link System#exit(int)} always.\n     */\n    @Deprecated\n    public static final String STATUS_CODE_PROPERTY = \"net.sourceforge.pmd.cli.status\";\n\n    /**\n     * @deprecated Use {@link StatusCode#OK}\n     */\n    @Deprecated\n    public static final int NO_ERRORS_STATUS = 0;\n    /**\n     * @deprecated Use {@link StatusCode#ERROR}\n     */\n    @Deprecated\n    public static final int ERROR_STATUS = 1;\n    /**\n     * @deprecated Use {@link StatusCode#VIOLATIONS_FOUND}\n     */\n    @Deprecated\n    public static final int VIOLATIONS_FOUND = 4;\n\n    private PMDCommandLineInterface() { }\n\n    /**\n     * Note: this may terminate the VM.\n     *\n     * @deprecated Use {@link PmdParametersParseResult#extractParameters(String...)}\n     */\n    @Deprecated\n    public static PMDParameters extractParameters(PMDParameters arguments, String[] args, String progName) {\n        JCommander jcommander = new JCommander(arguments);\n        jcommander.setProgramName(progName);\n\n        try {\n            jcommander.parse(args);\n            if (arguments.isHelp()) {\n                jcommander.usage();\n                System.out.println(buildUsageText());\n                setStatusCodeOrExit(NO_ERRORS_STATUS);\n            }\n        } catch (ParameterException e) {\n            jcommander.usage();\n            System.out.println(buildUsageText());\n            System.err.println(e.getMessage());\n            setStatusCodeOrExit(ERROR_STATUS);\n        }\n        return arguments;\n    }\n\n    public static String buildUsageText() {\n        // TODO: Externalize that to a file available within the classpath ? -\n        // with a poor's man templating ?\n        String fullText = PMD.EOL + \"Mandatory arguments:\" + PMD.EOL + \"1) A java source code filename or directory\"\n                + PMD.EOL + \"2) A report format \" + PMD.EOL\n                + \"3) A ruleset filename or a comma-delimited string of ruleset filenames\" + PMD.EOL + PMD.EOL\n                + \"For example: \" + PMD.EOL + getWindowsLaunchCmd()\n                + \" -d c:\\\\my\\\\source\\\\code -f html -R java-unusedcode\" + PMD.EOL + PMD.EOL;\n\n        fullText += supportedVersions() + PMD.EOL;\n\n        fullText += \"Available report formats and their configuration properties are:\" + PMD.EOL + getReports()\n                + PMD.EOL + getExamples() + PMD.EOL + PMD.EOL + PMD.EOL;\n\n        return fullText;\n    }\n\n    @Deprecated\n    public static String buildUsageText(JCommander jcommander) {\n        return buildUsageText();\n    }\n\n    private static String getExamples() {\n        return getWindowsExample() + getUnixExample();\n    }\n\n    private static String getWindowsLaunchCmd() {\n        final String WINDOWS_PROMPT = \"C:\\\\>\";\n        final String launchCmd = \"pmd-bin-\" + PMDVersion.VERSION + \"\\\\bin\\\\pmd.bat\";\n        return WINDOWS_PROMPT + launchCmd;\n    }\n\n    private static String getWindowsExample() {\n        final String launchCmd = getWindowsLaunchCmd();\n        final String WINDOWS_PATH_TO_CODE = \"c:\\\\my\\\\source\\\\code \";\n\n        return \"For example on windows: \" + PMD.EOL\n                + launchCmd + \" -dir \" + WINDOWS_PATH_TO_CODE + \"-format text -R rulesets/java/quickstart.xml -version 1.5 -language java -debug\" + PMD.EOL\n                + launchCmd + \" -dir \" + WINDOWS_PATH_TO_CODE + \"-f xml -rulesets rulesets/java/quickstart.xml,category/java/codestyle.xml -encoding UTF-8\" + PMD.EOL\n                + launchCmd + \" -d \" + WINDOWS_PATH_TO_CODE + \"-rulesets rulesets/java/quickstart.xml -auxclasspath lib\\\\commons-collections.jar;lib\\\\derby.jar\" + PMD.EOL\n                + launchCmd + \" -d \" + WINDOWS_PATH_TO_CODE + \"-f html -R rulesets/java/quickstart.xml -auxclasspath file:///C:/my/classpathfile\" + PMD.EOL + PMD.EOL;\n    }\n\n    private static String getUnixExample() {\n        final String launchCmd = \"$ pmd-bin-\" + PMDVersion.VERSION + \"/bin/run.sh pmd\";\n        return \"For example on *nix: \" + PMD.EOL\n                + launchCmd + \" -dir /home/workspace/src/main/java/code -f html -rulesets rulesets/java/quickstart.xml,category/java/codestyle.xml\" + PMD.EOL\n                + launchCmd + \" -d ./src/main/java/code -R rulesets/java/quickstart.xml -f xslt -property xsltFilename=my-own.xsl\" + PMD.EOL\n                + launchCmd + \" -d ./src/main/java/code -f html -R rulesets/java/quickstart.xml -auxclasspath commons-collections.jar:derby.jar\" + PMD.EOL;\n    }\n\n    private static String supportedVersions() {\n        return \"Languages and version suported:\" + PMD.EOL\n                + LanguageRegistry.PMD.commaSeparatedList(Language::getId)\n                + PMD.EOL;\n    }\n\n    /**\n     * For testing purpose only...\n     *\n     * @param args\n     *\n     * @deprecated Use {@link PMD#runPmd(String...)}\n     */\n    @Deprecated\n    public static void main(String[] args) {\n        System.out.println(PMDCommandLineInterface.buildUsageText());\n    }\n\n    public static String jarName() {\n        return \"pmd-\" + PMDVersion.VERSION + \".jar\";\n    }\n\n    private static String getReports() {\n        StringBuilder buf = new StringBuilder();\n        for (String reportName : RendererFactory.REPORT_FORMAT_TO_RENDERER.keySet()) {\n            Renderer renderer = RendererFactory.createRenderer(reportName, new Properties());\n            buf.append(\"   \").append(reportName).append(\": \");\n            if (!reportName.equals(renderer.getName())) {\n                buf.append(\" Deprecated alias for '\").append(renderer.getName()).append(PMD.EOL);\n                continue;\n            }\n            buf.append(renderer.getDescription()).append(PMD.EOL);\n\n            for (PropertyDescriptor<?> property : renderer.getPropertyDescriptors()) {\n                buf.append(\"        \").append(property.name()).append(\" - \");\n                buf.append(property.description());\n                Object deflt = property.defaultValue();\n                if (deflt != null) {\n                    buf.append(\"   default: \").append(deflt);\n                }\n                buf.append(PMD.EOL);\n            }\n\n        }\n        return buf.toString();\n    }\n\n    public static void setStatusCodeOrExit(int status) {\n        if (isExitAfterRunSet()) {\n            System.exit(status);\n        } else {\n            setStatusCode(status);\n        }\n    }\n\n    private static boolean isExitAfterRunSet() {\n        String noExit = System.getenv(NO_EXIT_AFTER_RUN);\n        if (noExit == null) {\n            noExit = System.getProperty(NO_EXIT_AFTER_RUN);\n        }\n        return noExit == null;\n    }\n\n    private static void setStatusCode(int statusCode) {\n        System.setProperty(STATUS_CODE_PROPERTY, Integer.toString(statusCode));\n    }\n\n    public static void printJcommanderUsageOnConsole() {\n        new JCommander(new PMDParameters()).usage();\n    }\n}\n",
        "filePathAfter": "pmd-core/src/main/java/net/sourceforge/pmd/cli/PMDCommandLineInterface.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.cli;\n\nimport java.util.Properties;\n\nimport net.sourceforge.pmd.PMD;\nimport net.sourceforge.pmd.PMD.StatusCode;\nimport net.sourceforge.pmd.PMDVersion;\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.lang.Language;\nimport net.sourceforge.pmd.lang.LanguageRegistry;\nimport net.sourceforge.pmd.properties.PropertyDescriptor;\nimport net.sourceforge.pmd.renderers.Renderer;\nimport net.sourceforge.pmd.renderers.RendererFactory;\n\nimport com.beust.jcommander.JCommander;\nimport com.beust.jcommander.ParameterException;\n\n/**\n * @author Romain Pelisse &lt;belaran@gmail.com&gt;\n * @deprecated Internal API. Use {@link PMD#runPmd(String...)} or {@link PMD#main(String[])},\n *     or {@link PmdParametersParseResult} if you just want to produce a configuration.\n */\n@Deprecated\n@InternalApi\npublic final class PMDCommandLineInterface {\n\n    @Deprecated\n    public static final String PROG_NAME = \"pmd\";\n\n    /**\n     * @deprecated This is used for testing, but support for it will be removed in PMD 7.\n     * Use {@link PMD#runPmd(String...)} or an overload to avoid exiting the VM. In PMD 7,\n     * {@link PMD#main(String[])} will call {@link System#exit(int)} always.\n     */\n    @Deprecated\n    public static final String NO_EXIT_AFTER_RUN = \"net.sourceforge.pmd.cli.noExit\";\n\n    /**\n     * @deprecated This is used for testing, but support for it will be removed in PMD 7.\n     * Use {@link PMD#runPmd(String...)} or an overload to avoid exiting the VM. In PMD 7,\n     * {@link PMD#main(String[])} will call {@link System#exit(int)} always.\n     */\n    @Deprecated\n    public static final String STATUS_CODE_PROPERTY = \"net.sourceforge.pmd.cli.status\";\n\n    /**\n     * @deprecated Use {@link StatusCode#OK}\n     */\n    @Deprecated\n    public static final int NO_ERRORS_STATUS = 0;\n    /**\n     * @deprecated Use {@link StatusCode#ERROR}\n     */\n    @Deprecated\n    public static final int ERROR_STATUS = 1;\n    /**\n     * @deprecated Use {@link StatusCode#VIOLATIONS_FOUND}\n     */\n    @Deprecated\n    public static final int VIOLATIONS_FOUND = 4;\n\n    private PMDCommandLineInterface() { }\n\n    /**\n     * Note: this may terminate the VM.\n     *\n     * @deprecated Use {@link PmdParametersParseResult#extractParameters(String...)}\n     */\n    @Deprecated\n    public static PMDParameters extractParameters(PMDParameters arguments, String[] args, String progName) {\n        JCommander jcommander = new JCommander(arguments);\n        jcommander.setProgramName(progName);\n\n        try {\n            jcommander.parse(args);\n            if (arguments.isHelp()) {\n                jcommander.usage();\n                System.out.println(buildUsageText());\n                setStatusCodeOrExit(NO_ERRORS_STATUS);\n            }\n        } catch (ParameterException e) {\n            jcommander.usage();\n            System.out.println(buildUsageText());\n            System.err.println(e.getMessage());\n            setStatusCodeOrExit(ERROR_STATUS);\n        }\n        return arguments;\n    }\n\n    public static String buildUsageText() {\n        // TODO: Externalize that to a file available within the classpath ? -\n        // with a poor's man templating ?\n        String fullText = PMD.EOL + \"Mandatory arguments:\" + PMD.EOL + \"1) A java source code filename or directory\"\n                + PMD.EOL + \"2) A report format \" + PMD.EOL\n                + \"3) A ruleset filename or a comma-delimited string of ruleset filenames\" + PMD.EOL + PMD.EOL\n                + \"For example: \" + PMD.EOL + getWindowsLaunchCmd()\n                + \" -d c:\\\\my\\\\source\\\\code -f html -R java-unusedcode\" + PMD.EOL + PMD.EOL;\n\n        fullText += supportedVersions() + PMD.EOL;\n\n        fullText += \"Available report formats and their configuration properties are:\" + PMD.EOL + getReports()\n                + PMD.EOL + getExamples() + PMD.EOL + PMD.EOL + PMD.EOL;\n\n        return fullText;\n    }\n\n    @Deprecated\n    public static String buildUsageText(JCommander jcommander) {\n        return buildUsageText();\n    }\n\n    private static String getExamples() {\n        return getWindowsExample() + getUnixExample();\n    }\n\n    private static String getWindowsLaunchCmd() {\n        final String WINDOWS_PROMPT = \"C:\\\\>\";\n        final String launchCmd = \"pmd-bin-\" + PMDVersion.VERSION + \"\\\\bin\\\\pmd.bat\";\n        return WINDOWS_PROMPT + launchCmd;\n    }\n\n    private static String getWindowsExample() {\n        final String launchCmd = getWindowsLaunchCmd();\n        final String WINDOWS_PATH_TO_CODE = \"c:\\\\my\\\\source\\\\code \";\n\n        return \"For example on windows: \" + PMD.EOL\n                + launchCmd + \" -dir \" + WINDOWS_PATH_TO_CODE + \"-format text -R rulesets/java/quickstart.xml -version 1.5 -language java -debug\" + PMD.EOL\n                + launchCmd + \" -dir \" + WINDOWS_PATH_TO_CODE + \"-f xml -rulesets rulesets/java/quickstart.xml,category/java/codestyle.xml -encoding UTF-8\" + PMD.EOL\n                + launchCmd + \" -d \" + WINDOWS_PATH_TO_CODE + \"-rulesets rulesets/java/quickstart.xml -auxclasspath lib\\\\commons-collections.jar;lib\\\\derby.jar\" + PMD.EOL\n                + launchCmd + \" -d \" + WINDOWS_PATH_TO_CODE + \"-f html -R rulesets/java/quickstart.xml -auxclasspath file:///C:/my/classpathfile\" + PMD.EOL + PMD.EOL;\n    }\n\n    private static String getUnixExample() {\n        final String launchCmd = \"$ pmd-bin-\" + PMDVersion.VERSION + \"/bin/run.sh pmd\";\n        return \"For example on *nix: \" + PMD.EOL\n                + launchCmd + \" -dir /home/workspace/src/main/java/code -f html -rulesets rulesets/java/quickstart.xml,category/java/codestyle.xml\" + PMD.EOL\n                + launchCmd + \" -d ./src/main/java/code -R rulesets/java/quickstart.xml -f xslt -property xsltFilename=my-own.xsl\" + PMD.EOL\n                + launchCmd + \" -d ./src/main/java/code -f html -R rulesets/java/quickstart.xml -auxclasspath commons-collections.jar:derby.jar\" + PMD.EOL;\n    }\n\n    private static String supportedVersions() {\n        return \"Languages and version suported:\" + PMD.EOL\n                + LanguageRegistry.PMD.commaSeparatedList(Language::getId)\n                + PMD.EOL;\n    }\n\n    /**\n     * For testing purpose only...\n     *\n     * @param args\n     *\n     * @deprecated Use {@link PMD#runPmd(String...)}\n     */\n    @Deprecated\n    public static void main(String[] args) {\n        System.out.println(PMDCommandLineInterface.buildUsageText());\n    }\n\n    public static String jarName() {\n        return \"pmd-\" + PMDVersion.VERSION + \".jar\";\n    }\n\n    private static String getReports() {\n        StringBuilder buf = new StringBuilder();\n        for (String reportName : RendererFactory.supportedRenderers()) {\n            Renderer renderer = RendererFactory.createRenderer(reportName, new Properties());\n            buf.append(\"   \").append(reportName).append(\": \");\n            if (!reportName.equals(renderer.getName())) {\n                buf.append(\" Deprecated alias for '\").append(renderer.getName()).append(PMD.EOL);\n                continue;\n            }\n            buf.append(renderer.getDescription()).append(PMD.EOL);\n\n            for (PropertyDescriptor<?> property : renderer.getPropertyDescriptors()) {\n                buf.append(\"        \").append(property.name()).append(\" - \");\n                buf.append(property.description());\n                Object deflt = property.defaultValue();\n                if (deflt != null) {\n                    buf.append(\"   default: \").append(deflt);\n                }\n                buf.append(PMD.EOL);\n            }\n\n        }\n        return buf.toString();\n    }\n\n    public static void setStatusCodeOrExit(int status) {\n        if (isExitAfterRunSet()) {\n            System.exit(status);\n        } else {\n            setStatusCode(status);\n        }\n    }\n\n    private static boolean isExitAfterRunSet() {\n        String noExit = System.getenv(NO_EXIT_AFTER_RUN);\n        if (noExit == null) {\n            noExit = System.getProperty(NO_EXIT_AFTER_RUN);\n        }\n        return noExit == null;\n    }\n\n    private static void setStatusCode(int statusCode) {\n        System.setProperty(STATUS_CODE_PROPERTY, Integer.toString(statusCode));\n    }\n\n    public static void printJcommanderUsageOnConsole() {\n        new JCommander(new PMDParameters()).usage();\n    }\n}\n",
        "diffSourceCodeSet": [
            "* @deprecated Use {@link StatusCode#ERROR}\n     */\n    @Deprecated\n    public static final int ERROR_STATUS = 1;\n    /**\n     * @deprecated Use {@link StatusCode#VIOLATIONS_FOUND}\n     */\n    @Deprecated"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.ant.Formatter#toString\n methodBody: public String toString() {\nreturn \"file = \" + toFile + \"; renderer = \" + type;\n}",
            "methodSignature: net.sourceforge.pmd.ant.Formatter#createRenderer\n methodBody: Renderer createRenderer() {\nif(StringUtils.isBlank(type)){throw new BuildException(unknownRendererMessage(\"<unspecified>\"));\n}Properties properties=createProperties();\nRenderer renderer=RendererFactory.createRenderer(type,properties);\nrenderer.setShowSuppressedViolations(showSuppressed);\nreturn renderer;\n}",
            "methodSignature: net.sourceforge.pmd.renderers.RendererFactory#createRenderer\n methodBody: public static Renderer createRenderer(String reportFormat, Properties properties) {\nAssertionUtil.requireParamNotNull(\"reportFormat\",reportFormat);\nClass<? extends Renderer> rendererClass=getRendererClass(reportFormat);\nConstructor<? extends Renderer> constructor=getRendererConstructor(rendererClass);\nRenderer renderer;\ntryif(constructor.getParameterTypes().length > 0){LOG.warn(\"The renderer uses a deprecated mechanism to use the properties. Please define the needed properties with this.definePropertyDescriptor(..).\");\nrenderer=constructor.newInstance(properties);\n}{renderer=constructor.newInstance();\nfor(PropertyDescriptor<?> prop: renderer.getPropertyDescriptors()){String value=properties.getProperty(prop.name());\nif(value != null){@SuppressWarnings(\"unchecked\") PropertyDescriptor<Object> prop2=(PropertyDescriptor<Object>)prop;\nObject valueFrom=prop2.valueFrom(value);\nrenderer.setProperty(prop2,valueFrom);\n}}}catch(InstantiationException|IllegalAccessException e)throw new IllegalArgumentException(\"Unable to construct report renderer class: \" + e.getLocalizedMessage(),e);\ncatch(InvocationTargetException e)throw new IllegalArgumentException(\"Unable to construct report renderer class: \" + e.getTargetException().getLocalizedMessage(),e);\nif(REPORT_FORMAT_TO_RENDERER.containsKey(reportFormat) && !reportFormat.equals(renderer.getName())){LOG.warn(\"Report format '{}' is deprecated, and has been replaced with '{}'. \" + \"Future versions of PMD will remove support for this deprecated Report format usage.\",reportFormat,renderer.getName());\n}return renderer;\n}"
        ],
        "sourceCodeAfterRefactoring": "private static String getReports() {\n        StringBuilder buf = new StringBuilder();\n        for (String reportName : RendererFactory.supportedRenderers()) {\n            Renderer renderer = RendererFactory.createRenderer(reportName, new Properties());\n            buf.append(\"   \").append(reportName).append(\": \");\n            if (!reportName.equals(renderer.getName())) {\n                buf.append(\" Deprecated alias for '\").append(renderer.getName()).append(PMD.EOL);\n                continue;\n            }\n            buf.append(renderer.getDescription()).append(PMD.EOL);\n\n            for (PropertyDescriptor<?> property : renderer.getPropertyDescriptors()) {\n                buf.append(\"        \").append(property.name()).append(\" - \");\n                buf.append(property.description());\n                Object deflt = property.defaultValue();\n                if (deflt != null) {\n                    buf.append(\"   default: \").append(deflt);\n                }\n                buf.append(PMD.EOL);\n            }\n\n        }\n        return buf.toString();\n    }\n* @deprecated Use {@link StatusCode#ERROR}\n     */\n    @Deprecated\n    public static final int ERROR_STATUS = 1;\n    /**\n     * @deprecated Use {@link StatusCode#VIOLATIONS_FOUND}\n     */\n    @Deprecated",
        "diffSourceCode": "    56:      * @deprecated Use {@link StatusCode#ERROR}\n    57:      */\n    58:     @Deprecated\n    59:     public static final int ERROR_STATUS = 1;\n    60:     /**\n    61:      * @deprecated Use {@link StatusCode#VIOLATIONS_FOUND}\n    62:      */\n    63:     @Deprecated\n   167:     private static String getReports() {\n   168:         StringBuilder buf = new StringBuilder();\n-  169:         for (String reportName : RendererFactory.REPORT_FORMAT_TO_RENDERER.keySet()) {\n+  169:         for (String reportName : RendererFactory.supportedRenderers()) {\n   170:             Renderer renderer = RendererFactory.createRenderer(reportName, new Properties());\n   171:             buf.append(\"   \").append(reportName).append(\": \");\n   172:             if (!reportName.equals(renderer.getName())) {\n   173:                 buf.append(\" Deprecated alias for '\").append(renderer.getName()).append(PMD.EOL);\n   174:                 continue;\n   175:             }\n   176:             buf.append(renderer.getDescription()).append(PMD.EOL);\n   177: \n   178:             for (PropertyDescriptor<?> property : renderer.getPropertyDescriptors()) {\n   179:                 buf.append(\"        \").append(property.name()).append(\" - \");\n   180:                 buf.append(property.description());\n   181:                 Object deflt = property.defaultValue();\n   182:                 if (deflt != null) {\n   183:                     buf.append(\"   default: \").append(deflt);\n   184:                 }\n   185:                 buf.append(PMD.EOL);\n   186:             }\n   187: \n   188:         }\n   189:         return buf.toString();\n   190:     }\n",
        "uniqueId": "e4f5d027b2d86f675208d8da53d0bb4b6365ad20_167_190_56_63_167_190",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 10,
                "covered": 86
            },
            "BRANCH": {
                "missed": 1,
                "covered": 7
            },
            "LINE": {
                "missed": 2,
                "covered": 16
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 4
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Move And Rename Method",
        "description": "Move And Rename Method\tpublic provideParameters() : Object[] from class net.sourceforge.pmd.lang.document.TextDocumentTest.DocumentsProvider to package documentProvider() : Object[] from class net.sourceforge.pmd.lang.document.TextDocumentTest",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/lang/document/TextDocumentTest.java",
                "startLine": 215,
                "endLine": 224,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/lang/document/TextDocumentTest.java",
                "startLine": 207,
                "endLine": 216,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@SuppressWarnings(\"resource\")\n        public static Object[] provideParameters() {\n            LanguageVersion dummyVersion = DummyLanguageModule.getInstance().getDefaultVersion();\n            return new TextDocument[] {\n                TextDocument.readOnlyString(\"bonjour\\noha\\ntristesse\", dummyVersion),\n                TextDocument.readOnlyString(\"bonjour\\n\", dummyVersion),\n                TextDocument.readOnlyString(\"\\n\", dummyVersion),\n                TextDocument.readOnlyString(\"\", dummyVersion),\n                };\n        }",
        "filePathBefore": "pmd-core/src/test/java/net/sourceforge/pmd/lang/document/TextDocumentTest.java",
        "isPureRefactoring": true,
        "commitId": "868883819020b0780313358e00f6132b3e8dc73f",
        "packageNameBefore": "net.sourceforge.pmd.lang.document.TextDocumentTest",
        "classNameBefore": "net.sourceforge.pmd.lang.document.TextDocumentTest.DocumentsProvider",
        "methodNameBefore": "net.sourceforge.pmd.lang.document.TextDocumentTest.DocumentsProvider#provideParameters",
        "classSignatureBefore": "public static final class DocumentsProvider ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.document.TextDocumentTest.DocumentsProvider#provideParameters"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.document.TextDocumentTest.DocumentsProvider"
        ],
        "classSignatureBeforeSet": [
            "public static final class DocumentsProvider "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.document;\n\nimport static net.sourceforge.pmd.PmdCoreTestUtils.dummyVersion;\nimport static net.sourceforge.pmd.lang.document.TextPos2d.pos2d;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertThrows;\n\nimport java.io.IOException;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\n\nimport net.sourceforge.pmd.lang.DummyLanguageModule;\nimport net.sourceforge.pmd.lang.LanguageVersion;\nimport net.sourceforge.pmd.util.IOUtil;\n\nimport junitparams.JUnitParamsRunner;\nimport junitparams.Parameters;\n\n@RunWith(JUnitParamsRunner.class)\npublic class TextDocumentTest {\n\n    @Test\n    public void testSingleLineRegion() {\n        TextDocument doc = TextDocument.readOnlyString(\"bonjour\\ntristesse\", dummyVersion());\n\n        TextRegion region = TextRegion.fromOffsetLength(0, \"bonjour\".length());\n\n        assertEquals(0, region.getStartOffset());\n        assertEquals(\"bonjour\".length(), region.getLength());\n        assertEquals(\"bonjour\".length(), region.getEndOffset());\n\n        FileLocation withLines = doc.toLocation(region);\n\n        assertEquals(1, withLines.getStartLine());\n        assertEquals(1, withLines.getEndLine());\n        assertEquals(1, withLines.getStartColumn());\n        assertEquals(1 + \"bonjour\".length(), withLines.getEndColumn());\n        assertEquals(\"bonjour\".length(), withLines.getEndColumn() - withLines.getStartColumn());\n    }\n\n    @Test\n    public void testRegionAtEol() {\n        TextDocument doc = TextDocument.readOnlyString(\"bonjour\\ntristesse\", dummyVersion());\n\n        TextRegion region = TextRegion.fromOffsetLength(0, \"bonjour\\n\".length());\n        assertEquals(\"bonjour\\n\", doc.sliceOriginalText(region).toString());\n        FileLocation withLines = doc.toLocation(region);\n\n        assertEquals(1, withLines.getStartLine());\n        assertEquals(1, withLines.getEndLine());\n        assertEquals(1, withLines.getStartColumn());\n        assertEquals(1 + \"bonjour\\n\".length(), withLines.getEndColumn());\n        assertEquals(\"bonjour\\n\".length(), withLines.getEndColumn() - withLines.getStartColumn());\n    }\n\n    @Test\n    public void testEmptyRegionAtEol() {\n        TextDocument doc = TextDocument.readOnlyString(\"bonjour\\ntristesse\", dummyVersion());\n        //                                                             ^ The caret position right after the \\n\n        //                                                               We consider it's part of the next line\n\n        TextRegion region = TextRegion.fromOffsetLength(\"bonjour\\n\".length(), 0);\n        assertEquals(\"\", doc.sliceOriginalText(region).toString());\n\n        FileLocation withLines = doc.toLocation(region);\n\n        assertEquals(2, withLines.getStartLine());\n        assertEquals(2, withLines.getEndLine());\n        assertEquals(1, withLines.getStartColumn());\n        assertEquals(1, withLines.getEndColumn());\n    }\n\n    @Test\n    public void testRegionForEol() {\n        TextDocument doc = TextDocument.readOnlyString(\"bonjour\\ntristesse\", dummyVersion());\n        //                                                           [ [ The region containing the \\n\n        //                                                               We consider it ends on the same line, not the next one\n\n\n        TextRegion region = TextRegion.fromOffsetLength(\"bonjour\".length(), 1);\n        assertEquals(\"\\n\", doc.sliceOriginalText(region).toString());\n\n        FileLocation withLines = doc.toLocation(region);\n\n        assertEquals(1, withLines.getStartLine());\n        assertEquals(1, withLines.getEndLine());\n        assertEquals(1 + \"bonjour\".length(), withLines.getStartColumn());\n        assertEquals(1 + \"bonjour\\n\".length(), withLines.getEndColumn());\n    }\n\n    @Test\n    public void testRegionAtEndOfFile() {\n        TextDocument doc = TextDocument.readOnlyString(\"flemme\", dummyVersion());\n\n        TextRegion region = TextRegion.fromOffsetLength(0, doc.getLength());\n        assertEquals(doc.getText(), doc.sliceOriginalText(region));\n\n        FileLocation withLines = doc.toLocation(region);\n\n        assertEquals(1, withLines.getStartLine());\n        assertEquals(1, withLines.getEndLine());\n        assertEquals(1, withLines.getStartColumn());\n        assertEquals(1 + doc.getLength(), withLines.getEndColumn());\n    }\n\n    @Test\n    public void testMultiLineRegion() {\n        TextDocument doc = TextDocument.readOnlyString(\"bonjour\\noha\\ntristesse\", dummyVersion());\n\n        TextRegion region = TextRegion.fromOffsetLength(\"bonjou\".length(), \"r\\noha\\ntri\".length());\n\n        assertEquals(\"bonjou\".length(), region.getStartOffset());\n        assertEquals(\"r\\noha\\ntri\".length(), region.getLength());\n        assertEquals(\"bonjour\\noha\\ntri\".length(), region.getEndOffset());\n\n        FileLocation withLines = doc.toLocation(region);\n\n        assertEquals(1, withLines.getStartLine());\n        assertEquals(3, withLines.getEndLine());\n        assertEquals(1 + \"bonjou\".length(), withLines.getStartColumn());\n        assertEquals(1 + \"tri\".length(), withLines.getEndColumn());\n    }\n\n\n    @Test\n    public void testLineColumnFromOffset() {\n        TextDocument doc = TextDocument.readOnlyString(\"ab\\ncd\\n\", dummyVersion());\n\n        assertPos2dEqualsAt(doc, 0, \"a\", pos2d(1, 1), true);\n        assertPos2dEqualsAt(doc, 0, \"a\", pos2d(1, 1), false);\n        assertPos2dEqualsAt(doc, 1, \"b\", pos2d(1, 2), true);\n        assertPos2dEqualsAt(doc, 2, \"\\n\", pos2d(1, 3), true);\n        assertPos2dEqualsAt(doc, 3, \"c\", pos2d(2, 1), true);\n        assertPos2dEqualsAt(doc, 3, \"c\", pos2d(1, 4), false);\n        assertPos2dEqualsAt(doc, 4, \"d\", pos2d(2, 2), true);\n        assertPos2dEqualsAt(doc, 5, \"\\n\", pos2d(2, 3), true);\n        // EOF caret position\n        assertEquals(pos2d(3, 1), doc.lineColumnAtOffset(6));\n        assertThrows(IndexOutOfBoundsException.class, () -> doc.lineColumnAtOffset(7));\n    }\n\n    private void assertPos2dEqualsAt(TextDocument doc, int offset, String c, TextPos2d pos, boolean inclusive) {\n        Chars slicedChar = doc.sliceTranslatedText(TextRegion.fromOffsetLength(offset, 1));\n        assertEquals(c, slicedChar.toString());\n        assertEquals(pos, doc.lineColumnAtOffset(offset, inclusive));\n    }\n\n    @Test\n    public void testEmptyRegion() {\n        TextDocument doc = TextDocument.readOnlyString(\"bonjour\\noha\\ntristesse\", dummyVersion());\n\n        TextRegion region = TextRegion.fromOffsetLength(\"bonjour\".length(), 0);\n\n        assertEquals(\"bonjour\".length(), region.getStartOffset());\n        assertEquals(0, region.getLength());\n        assertEquals(region.getStartOffset(), region.getEndOffset());\n\n        FileLocation withLines = doc.toLocation(region);\n\n        assertEquals(1, withLines.getStartLine());\n        assertEquals(1, withLines.getEndLine());\n        assertEquals(1 + \"bonjour\".length(), withLines.getStartColumn());\n        assertEquals(1 + \"bonjour\".length(), withLines.getEndColumn());\n    }\n\n\n    @Test\n    public void testLineRange() {\n        TextDocument doc = TextDocument.readOnlyString(\"bonjour\\noha\\ntristesse\", dummyVersion());\n\n        assertEquals(Chars.wrap(\"bonjour\\n\"), doc.sliceTranslatedText(doc.createLineRange(1, 1)));\n        assertEquals(Chars.wrap(\"bonjour\\noha\\n\"), doc.sliceTranslatedText(doc.createLineRange(1, 2)));\n        assertEquals(Chars.wrap(\"oha\\n\"), doc.sliceTranslatedText(doc.createLineRange(2, 2)));\n        assertEquals(Chars.wrap(\"oha\\ntristesse\"), doc.sliceTranslatedText(doc.createLineRange(2, 3)));\n        assertThrows(IndexOutOfBoundsException.class, () -> doc.createLineRange(2, 1));\n        assertThrows(IndexOutOfBoundsException.class, () -> doc.createLineRange(1, 5));\n        assertThrows(IndexOutOfBoundsException.class, () -> doc.createLineRange(0, 2));\n    }\n\n    @Test\n    @Parameters(source = DocumentsProvider.class)\n    public void testEntireRegion(TextDocument doc) {\n        assertEquals(\"getEntireRegion should return something based on length\",\n                     TextRegion.fromOffsetLength(0, doc.getLength()),\n                     doc.getEntireRegion());\n    }\n\n    @Test\n    @Parameters(source = DocumentsProvider.class)\n    public void testReader(TextDocument doc) throws IOException {\n\n        assertEquals(\"NewReader should read the text\",\n                     doc.getText().toString(),\n                     IOUtil.readToString(doc.newReader())\n        );\n\n    }\n\n    @Test\n    public void testRegionOutOfBounds() {\n        TextDocument doc = TextDocument.readOnlyString(\"bonjour\\noha\\ntristesse\", dummyVersion());\n\n        assertThrows(AssertionError.class, () -> TextRegion.isValidRegion(0, 40, doc));\n    }\n\n    // for junit params runner\n    public static final class DocumentsProvider {\n\n\n        @SuppressWarnings(\"resource\")\n        public static Object[] provideParameters() {\n            LanguageVersion dummyVersion = DummyLanguageModule.getInstance().getDefaultVersion();\n            return new TextDocument[] {\n                TextDocument.readOnlyString(\"bonjour\\noha\\ntristesse\", dummyVersion),\n                TextDocument.readOnlyString(\"bonjour\\n\", dummyVersion),\n                TextDocument.readOnlyString(\"\\n\", dummyVersion),\n                TextDocument.readOnlyString(\"\", dummyVersion),\n                };\n        }\n    }\n\n}\n",
        "filePathAfter": "pmd-core/src/test/java/net/sourceforge/pmd/lang/document/TextDocumentTest.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.document;\n\nimport static net.sourceforge.pmd.PmdCoreTestUtils.dummyVersion;\nimport static net.sourceforge.pmd.lang.document.TextPos2d.pos2d;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\nimport net.sourceforge.pmd.lang.DummyLanguageModule;\nimport net.sourceforge.pmd.lang.LanguageVersion;\nimport net.sourceforge.pmd.util.IOUtil;\n\nclass TextDocumentTest {\n\n    @Test\n    void testSingleLineRegion() {\n        TextDocument doc = TextDocument.readOnlyString(\"bonjour\\ntristesse\", dummyVersion());\n\n        TextRegion region = TextRegion.fromOffsetLength(0, \"bonjour\".length());\n\n        assertEquals(0, region.getStartOffset());\n        assertEquals(\"bonjour\".length(), region.getLength());\n        assertEquals(\"bonjour\".length(), region.getEndOffset());\n\n        FileLocation withLines = doc.toLocation(region);\n\n        assertEquals(1, withLines.getStartLine());\n        assertEquals(1, withLines.getEndLine());\n        assertEquals(1, withLines.getStartColumn());\n        assertEquals(1 + \"bonjour\".length(), withLines.getEndColumn());\n        assertEquals(\"bonjour\".length(), withLines.getEndColumn() - withLines.getStartColumn());\n    }\n\n    @Test\n    void testRegionAtEol() {\n        TextDocument doc = TextDocument.readOnlyString(\"bonjour\\ntristesse\", dummyVersion());\n\n        TextRegion region = TextRegion.fromOffsetLength(0, \"bonjour\\n\".length());\n        assertEquals(\"bonjour\\n\", doc.sliceOriginalText(region).toString());\n        FileLocation withLines = doc.toLocation(region);\n\n        assertEquals(1, withLines.getStartLine());\n        assertEquals(1, withLines.getEndLine());\n        assertEquals(1, withLines.getStartColumn());\n        assertEquals(1 + \"bonjour\\n\".length(), withLines.getEndColumn());\n        assertEquals(\"bonjour\\n\".length(), withLines.getEndColumn() - withLines.getStartColumn());\n    }\n\n    @Test\n    void testEmptyRegionAtEol() {\n        TextDocument doc = TextDocument.readOnlyString(\"bonjour\\ntristesse\", dummyVersion());\n        //                                                             ^ The caret position right after the \\n\n        //                                                               We consider it's part of the next line\n\n        TextRegion region = TextRegion.fromOffsetLength(\"bonjour\\n\".length(), 0);\n        assertEquals(\"\", doc.sliceOriginalText(region).toString());\n\n        FileLocation withLines = doc.toLocation(region);\n\n        assertEquals(2, withLines.getStartLine());\n        assertEquals(2, withLines.getEndLine());\n        assertEquals(1, withLines.getStartColumn());\n        assertEquals(1, withLines.getEndColumn());\n    }\n\n    @Test\n    void testRegionForEol() {\n        TextDocument doc = TextDocument.readOnlyString(\"bonjour\\ntristesse\", dummyVersion());\n        //                                                           [ [ The region containing the \\n\n        //                                                               We consider it ends on the same line, not the next one\n\n\n        TextRegion region = TextRegion.fromOffsetLength(\"bonjour\".length(), 1);\n        assertEquals(\"\\n\", doc.sliceOriginalText(region).toString());\n\n        FileLocation withLines = doc.toLocation(region);\n\n        assertEquals(1, withLines.getStartLine());\n        assertEquals(1, withLines.getEndLine());\n        assertEquals(1 + \"bonjour\".length(), withLines.getStartColumn());\n        assertEquals(1 + \"bonjour\\n\".length(), withLines.getEndColumn());\n    }\n\n    @Test\n    void testRegionAtEndOfFile() {\n        TextDocument doc = TextDocument.readOnlyString(\"flemme\", dummyVersion());\n\n        TextRegion region = TextRegion.fromOffsetLength(0, doc.getLength());\n        assertEquals(doc.getText(), doc.sliceOriginalText(region));\n\n        FileLocation withLines = doc.toLocation(region);\n\n        assertEquals(1, withLines.getStartLine());\n        assertEquals(1, withLines.getEndLine());\n        assertEquals(1, withLines.getStartColumn());\n        assertEquals(1 + doc.getLength(), withLines.getEndColumn());\n    }\n\n    @Test\n    void testMultiLineRegion() {\n        TextDocument doc = TextDocument.readOnlyString(\"bonjour\\noha\\ntristesse\", dummyVersion());\n\n        TextRegion region = TextRegion.fromOffsetLength(\"bonjou\".length(), \"r\\noha\\ntri\".length());\n\n        assertEquals(\"bonjou\".length(), region.getStartOffset());\n        assertEquals(\"r\\noha\\ntri\".length(), region.getLength());\n        assertEquals(\"bonjour\\noha\\ntri\".length(), region.getEndOffset());\n\n        FileLocation withLines = doc.toLocation(region);\n\n        assertEquals(1, withLines.getStartLine());\n        assertEquals(3, withLines.getEndLine());\n        assertEquals(1 + \"bonjou\".length(), withLines.getStartColumn());\n        assertEquals(1 + \"tri\".length(), withLines.getEndColumn());\n    }\n\n\n    @Test\n    void testLineColumnFromOffset() {\n        TextDocument doc = TextDocument.readOnlyString(\"ab\\ncd\\n\", dummyVersion());\n\n        assertPos2dEqualsAt(doc, 0, \"a\", pos2d(1, 1), true);\n        assertPos2dEqualsAt(doc, 0, \"a\", pos2d(1, 1), false);\n        assertPos2dEqualsAt(doc, 1, \"b\", pos2d(1, 2), true);\n        assertPos2dEqualsAt(doc, 2, \"\\n\", pos2d(1, 3), true);\n        assertPos2dEqualsAt(doc, 3, \"c\", pos2d(2, 1), true);\n        assertPos2dEqualsAt(doc, 3, \"c\", pos2d(1, 4), false);\n        assertPos2dEqualsAt(doc, 4, \"d\", pos2d(2, 2), true);\n        assertPos2dEqualsAt(doc, 5, \"\\n\", pos2d(2, 3), true);\n        // EOF caret position\n        assertEquals(pos2d(3, 1), doc.lineColumnAtOffset(6));\n        assertThrows(IndexOutOfBoundsException.class, () -> doc.lineColumnAtOffset(7));\n    }\n\n    private void assertPos2dEqualsAt(TextDocument doc, int offset, String c, TextPos2d pos, boolean inclusive) {\n        Chars slicedChar = doc.sliceTranslatedText(TextRegion.fromOffsetLength(offset, 1));\n        assertEquals(c, slicedChar.toString());\n        assertEquals(pos, doc.lineColumnAtOffset(offset, inclusive));\n    }\n\n    @Test\n    void testEmptyRegion() {\n        TextDocument doc = TextDocument.readOnlyString(\"bonjour\\noha\\ntristesse\", dummyVersion());\n\n        TextRegion region = TextRegion.fromOffsetLength(\"bonjour\".length(), 0);\n\n        assertEquals(\"bonjour\".length(), region.getStartOffset());\n        assertEquals(0, region.getLength());\n        assertEquals(region.getStartOffset(), region.getEndOffset());\n\n        FileLocation withLines = doc.toLocation(region);\n\n        assertEquals(1, withLines.getStartLine());\n        assertEquals(1, withLines.getEndLine());\n        assertEquals(1 + \"bonjour\".length(), withLines.getStartColumn());\n        assertEquals(1 + \"bonjour\".length(), withLines.getEndColumn());\n    }\n\n\n    @Test\n    void testLineRange() {\n        TextDocument doc = TextDocument.readOnlyString(\"bonjour\\noha\\ntristesse\", dummyVersion());\n\n        assertEquals(Chars.wrap(\"bonjour\\n\"), doc.sliceTranslatedText(doc.createLineRange(1, 1)));\n        assertEquals(Chars.wrap(\"bonjour\\noha\\n\"), doc.sliceTranslatedText(doc.createLineRange(1, 2)));\n        assertEquals(Chars.wrap(\"oha\\n\"), doc.sliceTranslatedText(doc.createLineRange(2, 2)));\n        assertEquals(Chars.wrap(\"oha\\ntristesse\"), doc.sliceTranslatedText(doc.createLineRange(2, 3)));\n        assertThrows(IndexOutOfBoundsException.class, () -> doc.createLineRange(2, 1));\n        assertThrows(IndexOutOfBoundsException.class, () -> doc.createLineRange(1, 5));\n        assertThrows(IndexOutOfBoundsException.class, () -> doc.createLineRange(0, 2));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"documentProvider\")\n    void testEntireRegion(TextDocument doc) {\n        assertEquals(TextRegion.fromOffsetLength(0, doc.getLength()),\n                doc.getEntireRegion(),\n                \"getEntireRegion should return something based on length\");\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"documentProvider\")\n    void testReader(TextDocument doc) throws IOException {\n\n        assertEquals(doc.getText().toString(),\n                     IOUtil.readToString(doc.newReader()),\n                    \"NewReader should read the text\");\n\n    }\n\n    @Test\n    void testRegionOutOfBounds() {\n        TextDocument doc = TextDocument.readOnlyString(\"bonjour\\noha\\ntristesse\", dummyVersion());\n\n        assertThrows(AssertionError.class, () -> TextRegion.isValidRegion(0, 40, doc));\n    }\n\n    @SuppressWarnings(\"resource\")\n    static Object[] documentProvider() {\n        LanguageVersion dummyVersion = DummyLanguageModule.getInstance().getDefaultVersion();\n        return new TextDocument[] {\n            TextDocument.readOnlyString(\"bonjour\\noha\\ntristesse\", dummyVersion),\n            TextDocument.readOnlyString(\"bonjour\\n\", dummyVersion),\n            TextDocument.readOnlyString(\"\\n\", dummyVersion),\n            TextDocument.readOnlyString(\"\", dummyVersion),\n            };\n    }\n\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "@SuppressWarnings(\"resource\")\n    static Object[] documentProvider() {\n        LanguageVersion dummyVersion = DummyLanguageModule.getInstance().getDefaultVersion();\n        return new TextDocument[] {\n            TextDocument.readOnlyString(\"bonjour\\noha\\ntristesse\", dummyVersion),\n            TextDocument.readOnlyString(\"bonjour\\n\", dummyVersion),\n            TextDocument.readOnlyString(\"\\n\", dummyVersion),\n            TextDocument.readOnlyString(\"\", dummyVersion),\n            };\n    }",
        "diffSourceCode": "-  207: \n-  208:         assertThrows(AssertionError.class, () -> TextRegion.isValidRegion(0, 40, doc));\n-  209:     }\n-  210: \n-  211:     // for junit params runner\n-  212:     public static final class DocumentsProvider {\n-  213: \n-  214: \n-  215:         @SuppressWarnings(\"resource\")\n-  216:         public static Object[] provideParameters() {\n-  217:             LanguageVersion dummyVersion = DummyLanguageModule.getInstance().getDefaultVersion();\n-  218:             return new TextDocument[] {\n-  219:                 TextDocument.readOnlyString(\"bonjour\\noha\\ntristesse\", dummyVersion),\n-  220:                 TextDocument.readOnlyString(\"bonjour\\n\", dummyVersion),\n-  221:                 TextDocument.readOnlyString(\"\\n\", dummyVersion),\n-  222:                 TextDocument.readOnlyString(\"\", dummyVersion),\n-  223:                 };\n-  224:         }\n+  207:     @SuppressWarnings(\"resource\")\n+  208:     static Object[] documentProvider() {\n+  209:         LanguageVersion dummyVersion = DummyLanguageModule.getInstance().getDefaultVersion();\n+  210:         return new TextDocument[] {\n+  211:             TextDocument.readOnlyString(\"bonjour\\noha\\ntristesse\", dummyVersion),\n+  212:             TextDocument.readOnlyString(\"bonjour\\n\", dummyVersion),\n+  213:             TextDocument.readOnlyString(\"\\n\", dummyVersion),\n+  214:             TextDocument.readOnlyString(\"\", dummyVersion),\n+  215:             };\n+  216:     }\n+  217: \n+  218: }\n",
        "uniqueId": "868883819020b0780313358e00f6132b3e8dc73f_215_224__207_216",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Move Method",
        "description": "Move Method\tpublic isComment(t JavaccToken) : boolean from class net.sourceforge.pmd.lang.java.ast.JavaTokenDocument to public isComment(t JavaccToken) : boolean from class net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JavaTokenDocument.java",
                "startLine": 31,
                "endLine": 43,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/internal/JavaAstUtils.java",
                "startLine": 719,
                "endLine": 731,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Returns true if the given token is a Java comment.\n     */\n    public static boolean isComment(JavaccToken t) {\n        switch (t.kind) {\n        case FORMAL_COMMENT:\n        case MULTI_LINE_COMMENT:\n        case SINGLE_LINE_COMMENT:\n            return true;\n        default:\n            return false;\n        }\n    }",
        "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JavaTokenDocument.java",
        "isPureRefactoring": true,
        "commitId": "e9ecc8aaa7ce266faa008977e8d153e96bd7188f",
        "packageNameBefore": "net.sourceforge.pmd.lang.java.ast",
        "classNameBefore": "net.sourceforge.pmd.lang.java.ast.JavaTokenDocument",
        "methodNameBefore": "net.sourceforge.pmd.lang.java.ast.JavaTokenDocument#isComment",
        "classSignatureBefore": "final class JavaTokenDocument extends JavaccTokenDocument ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.ast.JavaTokenDocument#isComment"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.ast.JavaTokenDocument"
        ],
        "classSignatureBeforeSet": [
            "final class JavaTokenDocument extends JavaccTokenDocument "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.ast;\n\nimport static net.sourceforge.pmd.lang.java.ast.JavaTokenKinds.FORMAL_COMMENT;\nimport static net.sourceforge.pmd.lang.java.ast.JavaTokenKinds.GT;\nimport static net.sourceforge.pmd.lang.java.ast.JavaTokenKinds.MULTI_LINE_COMMENT;\nimport static net.sourceforge.pmd.lang.java.ast.JavaTokenKinds.RSIGNEDSHIFT;\nimport static net.sourceforge.pmd.lang.java.ast.JavaTokenKinds.RUNSIGNEDSHIFT;\nimport static net.sourceforge.pmd.lang.java.ast.JavaTokenKinds.SINGLE_LINE_COMMENT;\nimport static net.sourceforge.pmd.lang.java.ast.JavaTokenKinds.WHITESPACE;\n\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport net.sourceforge.pmd.lang.ast.CharStream;\nimport net.sourceforge.pmd.lang.ast.impl.javacc.JavaccToken;\nimport net.sourceforge.pmd.lang.ast.impl.javacc.JavaccTokenDocument;\nimport net.sourceforge.pmd.lang.document.TextDocument;\n\n/**\n * {@link JavaccTokenDocument} for Java.\n */\nfinal class JavaTokenDocument extends JavaccTokenDocument {\n\n    JavaTokenDocument(TextDocument fullText) {\n        super(fullText);\n    }\n\n    /**\n     * Returns true if the given token is a Java comment.\n     */\n    public static boolean isComment(JavaccToken t) {\n        switch (t.kind) {\n        case FORMAL_COMMENT:\n        case MULTI_LINE_COMMENT:\n        case SINGLE_LINE_COMMENT:\n            return true;\n        default:\n            return false;\n        }\n    }\n\n\n    @Override\n    protected @Nullable String describeKindImpl(int kind) {\n        return JavaTokenKinds.describe(kind);\n    }\n\n    @Override\n    public JavaccToken createToken(int kind, CharStream jcs, @Nullable String image) {\n        switch (kind) {\n        case RUNSIGNEDSHIFT:\n        case RSIGNEDSHIFT:\n        case GT:\n            return new GTToken(\n                GT,\n                kind,\n                \">\",\n                jcs.getStartOffset(),\n                jcs.getEndOffset(),\n                jcs.getTokenDocument()\n            );\n\n        case WHITESPACE:\n            // We don't create a new string for the image of whitespace tokens eagerly\n\n            // It's unlikely that anybody cares about that, and since\n            // they're still 30% of all tokens this is advantageous\n            return new LazyImageToken(\n                kind,\n                jcs.getStartOffset(),\n                jcs.getEndOffset(),\n                jcs.getTokenDocument()\n            );\n\n        default:\n            return super.createToken(kind, jcs, image);\n        }\n    }\n\n    static int getRealKind(JavaccToken token) {\n        return token instanceof GTToken ? ((GTToken) token).realKind : token.kind;\n    }\n\n    private static final class LazyImageToken extends JavaccToken {\n\n        LazyImageToken(int kind, int startInclusive, int endExclusive, JavaccTokenDocument document) {\n            super(kind, null, startInclusive, endExclusive, document);\n        }\n\n        @Override\n        public String getImage() {\n            return getDocument().getTextDocument().sliceText(getRegion()).toString();\n        }\n    }\n\n    private static final class GTToken extends JavaccToken {\n\n        final int realKind;\n\n        GTToken(int kind, int realKind, CharSequence image, int startOffset, int endOffset, JavaccTokenDocument doc) {\n            super(kind, image, startOffset, endOffset, doc);\n            this.realKind = realKind;\n        }\n\n    }\n\n\n}\n",
        "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/internal/JavaAstUtils.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.ast.internal;\n\nimport static net.sourceforge.pmd.lang.java.ast.JavaTokenKinds.FORMAL_COMMENT;\nimport static net.sourceforge.pmd.lang.java.ast.JavaTokenKinds.MULTI_LINE_COMMENT;\nimport static net.sourceforge.pmd.lang.java.ast.JavaTokenKinds.SINGLE_LINE_COMMENT;\n\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport net.sourceforge.pmd.lang.ast.GenericToken;\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.ast.NodeStream;\nimport net.sourceforge.pmd.lang.ast.impl.javacc.JavaccToken;\nimport net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTArgumentList;\nimport net.sourceforge.pmd.lang.java.ast.ASTArrayAllocation;\nimport net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr.ASTNamedReferenceExpr;\nimport net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr.AccessType;\nimport net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTBooleanLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTBreakStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTCastExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType;\nimport net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;\nimport net.sourceforge.pmd.lang.java.ast.ASTExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTExpressionStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTFieldAccess;\nimport net.sourceforge.pmd.lang.java.ast.ASTForStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;\nimport net.sourceforge.pmd.lang.java.ast.ASTFormalParameters;\nimport net.sourceforge.pmd.lang.java.ast.ASTInfixExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTLabeledStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTList;\nimport net.sourceforge.pmd.lang.java.ast.ASTLocalVariableDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTLoopStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTMethodCall;\nimport net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTMethodOrConstructorDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTNullLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTNumericLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTSuperExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTSwitchBranch;\nimport net.sourceforge.pmd.lang.java.ast.ASTSwitchStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTThisExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTUnaryExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;\nimport net.sourceforge.pmd.lang.java.ast.AccessNode.Visibility;\nimport net.sourceforge.pmd.lang.java.ast.Annotatable;\nimport net.sourceforge.pmd.lang.java.ast.BinaryOp;\nimport net.sourceforge.pmd.lang.java.ast.JavaNode;\nimport net.sourceforge.pmd.lang.java.ast.JavaTokenKinds;\nimport net.sourceforge.pmd.lang.java.ast.QualifiableExpression;\nimport net.sourceforge.pmd.lang.java.ast.TypeNode;\nimport net.sourceforge.pmd.lang.java.ast.UnaryOp;\nimport net.sourceforge.pmd.lang.java.rule.internal.JavaRuleUtil;\nimport net.sourceforge.pmd.lang.java.symbols.JFieldSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.internal.ast.AstLocalVarSym;\nimport net.sourceforge.pmd.lang.java.types.JMethodSig;\nimport net.sourceforge.pmd.lang.java.types.JPrimitiveType.PrimitiveTypeKind;\nimport net.sourceforge.pmd.lang.java.types.JTypeMirror;\nimport net.sourceforge.pmd.lang.java.types.TypeTestUtil;\nimport net.sourceforge.pmd.util.CollectionUtil;\nimport net.sourceforge.pmd.util.OptionalBool;\n\n/**\n * Common utility functions to work with the Java AST. See also\n * {@link TypeTestUtil}. Only add here things that are not specific to\n * rules (use {@link JavaRuleUtil} for that). This API may be eventually\n * published.\n */\npublic final class JavaAstUtils {\n\n    private JavaAstUtils() {\n        // utility class\n    }\n\n\n    public static boolean isConditional(JavaNode ifx) {\n        return isInfixExprWithOperator(ifx, BinaryOp.CONDITIONAL_OPS);\n    }\n\n    public static int numAlternatives(ASTSwitchBranch n) {\n        return n.isDefault() ? 1 : n.getLabel().getExprList().count();\n    }\n\n    /**\n     * Returns true if this is a numeric literal with the given int value.\n     * This also considers long literals.\n     */\n    public static boolean isLiteralInt(JavaNode e, int value) {\n        return e instanceof ASTNumericLiteral\n                && ((ASTNumericLiteral) e).isIntegral()\n                && ((ASTNumericLiteral) e).getValueAsInt() == value;\n    }\n\n    /** This is type-aware, so will not pick up on numeric addition. */\n    public static boolean isStringConcatExpr(@Nullable JavaNode e) {\n        if (e instanceof ASTInfixExpression) {\n            ASTInfixExpression infix = (ASTInfixExpression) e;\n            return infix.getOperator() == BinaryOp.ADD && TypeTestUtil.isA(String.class, infix);\n        }\n        return false;\n    }\n\n    /**\n     * If the parameter is an operand of a binary infix expression,\n     * returns the other operand. Otherwise returns null.\n     */\n    public static @Nullable ASTExpression getOtherOperandIfInInfixExpr(@Nullable JavaNode e) {\n        if (e != null && e.getParent() instanceof ASTInfixExpression) {\n            return (ASTExpression) e.getParent().getChild(1 - e.getIndexInParent());\n        }\n        return null;\n    }\n\n    public static @Nullable ASTExpression getOtherOperandIfInAssignmentExpr(@Nullable JavaNode e) {\n        if (e != null && e.getParent() instanceof ASTAssignmentExpression) {\n            return (ASTExpression) e.getParent().getChild(1 - e.getIndexInParent());\n        }\n        return null;\n    }\n\n    /**\n     * Returns true if the node is a {@link ASTMethodDeclaration} that\n     * is a main method.\n     */\n    public static boolean isMainMethod(JavaNode node) {\n        return node instanceof ASTMethodDeclaration\n                && ((ASTMethodDeclaration) node).isMainMethod();\n    }\n\n    public static boolean hasField(ASTAnyTypeDeclaration node, String name) {\n        for (JFieldSymbol f : node.getSymbol().getDeclaredFields()) {\n            String fname = f.getSimpleName();\n            if (fname.startsWith(\"m_\") || fname.startsWith(\"_\")) {\n                fname = fname.substring(fname.indexOf('_') + 1);\n            }\n            if (fname.equalsIgnoreCase(name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns true if the formal parameters of the method or constructor\n     * match the given types exactly. Note that for varargs methods, the\n     * last param must have an array type (but it is not checked to be varargs).\n     * This will return false if we're not sure.\n     *\n     * @param node  Method or ctor\n     * @param types List of types to match (may be empty)\n     *\n     * @throws NullPointerException If any of the classes is null, or the node is null\n     * @see TypeTestUtil#isExactlyA(Class, TypeNode)\n     */\n    public static boolean hasParameters(ASTMethodOrConstructorDeclaration node, Class<?>... types) {\n        ASTFormalParameters formals = node.getFormalParameters();\n        if (formals.size() != types.length) {\n            return false;\n        }\n        for (int i = 0; i < formals.size(); i++) {\n            ASTFormalParameter fi = formals.get(i);\n            if (!TypeTestUtil.isExactlyA(types[i], fi)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns true if the {@code throws} declaration of the method or constructor\n     * matches the given types exactly.\n     *\n     * @param node  Method or ctor\n     * @param types List of exception types to match (may be empty)\n     *\n     * @throws NullPointerException If any of the classes is null, or the node is null\n     * @see TypeTestUtil#isExactlyA(Class, TypeNode)\n     */\n    @SafeVarargs\n    public static boolean hasExceptionList(ASTMethodOrConstructorDeclaration node, Class<? extends Throwable>... types) {\n        @NonNull List<ASTClassOrInterfaceType> formals = ASTList.orEmpty(node.getThrowsList());\n        if (formals.size() != types.length) {\n            return false;\n        }\n        for (int i = 0; i < formals.size(); i++) {\n            ASTClassOrInterfaceType fi = formals.get(i);\n            if (!TypeTestUtil.isExactlyA(types[i], fi)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * True if the variable is never used. Note that the visibility of\n     * the variable must be less than {@link Visibility#V_PRIVATE} for\n     * us to be sure of it.\n     */\n    public static boolean isNeverUsed(ASTVariableDeclaratorId varId) {\n        return CollectionUtil.none(varId.getLocalUsages(), JavaAstUtils::isReadUsage);\n    }\n\n    private static boolean isReadUsage(ASTNamedReferenceExpr expr) {\n        return expr.getAccessType() == AccessType.READ\n            // x++ as a method argument or used in other expression\n            || expr.getParent() instanceof ASTUnaryExpression\n            && !(expr.getParent().getParent() instanceof ASTExpressionStatement);\n    }\n\n    /**\n     * True if the variable is incremented or decremented via a compound\n     * assignment operator, or a unary increment/decrement expression.\n     */\n    public static boolean isVarAccessReadAndWrite(ASTNamedReferenceExpr expr) {\n        return expr.getAccessType() == AccessType.WRITE\n            && (!(expr.getParent() instanceof ASTAssignmentExpression)\n            || ((ASTAssignmentExpression) expr.getParent()).getOperator().isCompound());\n    }\n\n    /**\n     * True if the variable access is a non-compound assignment.\n     */\n    public static boolean isVarAccessStrictlyWrite(ASTNamedReferenceExpr expr) {\n        return expr.getParent() instanceof ASTAssignmentExpression\n            && expr.getIndexInParent() == 0\n            && !((ASTAssignmentExpression) expr.getParent()).getOperator().isCompound();\n    }\n\n    /**\n     * Returns the set of labels on this statement.\n     */\n    public static Set<String> getStatementLabels(ASTStatement node) {\n        if (!(node.getParent() instanceof ASTLabeledStatement)) {\n            return Collections.emptySet();\n        }\n\n        return node.ancestors().takeWhile(it -> it instanceof ASTLabeledStatement)\n                   .toStream()\n                   .map(it -> ((ASTLabeledStatement) it).getLabel())\n                   .collect(Collectors.toSet());\n    }\n\n    public static boolean isAnonymousClassCreation(@Nullable ASTExpression expression) {\n        return expression instanceof ASTConstructorCall\n                && ((ASTConstructorCall) expression).isAnonymousClass();\n    }\n\n    /**\n     * Will cut through argument lists, except those of enum constants\n     * and explicit invocation nodes.\n     */\n    public static @NonNull ASTExpression getTopLevelExpr(ASTExpression expr) {\n        JavaNode last = expr.ancestorsOrSelf()\n                            .takeWhile(it -> it instanceof ASTExpression\n                                || it instanceof ASTArgumentList && it.getParent() instanceof ASTExpression)\n                            .last();\n        return (ASTExpression) Objects.requireNonNull(last);\n    }\n\n    /**\n     * Returns the variable IDS corresponding to variables declared in\n     * the init clause of the loop.\n     */\n    public static NodeStream<ASTVariableDeclaratorId> getLoopVariables(ASTForStatement loop) {\n        return NodeStream.of(loop.getInit())\n                         .filterIs(ASTLocalVariableDeclaration.class)\n                         .flatMap(ASTLocalVariableDeclaration::getVarIds);\n    }\n\n    /**\n     * Whether one expression is the boolean negation of the other. Many\n     * forms are not yet supported. This method is symmetric so only needs\n     * to be called once.\n     */\n    public static boolean areComplements(ASTExpression e1, ASTExpression e2) {\n        if (isBooleanNegation(e1)) {\n            return areEqual(unaryOperand(e1), e2);\n        } else if (isBooleanNegation(e2)) {\n            return areEqual(e1, unaryOperand(e2));\n        } else if (e1 instanceof ASTInfixExpression && e2 instanceof ASTInfixExpression) {\n            ASTInfixExpression ifx1 = (ASTInfixExpression) e1;\n            ASTInfixExpression ifx2 = (ASTInfixExpression) e2;\n            if (ifx1.getOperator().getComplement() != ifx2.getOperator()) {\n                return false;\n            }\n            if (ifx1.getOperator().hasSamePrecedenceAs(BinaryOp.EQ)) {\n                // NOT(a == b, a != b)\n                // NOT(a == b, b != a)\n                return areEqual(ifx1.getLeftOperand(), ifx2.getLeftOperand())\n                    && areEqual(ifx1.getRightOperand(), ifx2.getRightOperand())\n                    || areEqual(ifx2.getLeftOperand(), ifx1.getLeftOperand())\n                    && areEqual(ifx2.getRightOperand(), ifx1.getRightOperand());\n            }\n            // todo we could continue with de Morgan and such\n        }\n        return false;\n    }\n\n    private static boolean areEqual(ASTExpression e1, ASTExpression e2) {\n        return tokenEquals(e1, e2);\n    }\n\n    /**\n     * Returns true if both nodes have exactly the same tokens.\n     *\n     * @param node First node\n     * @param that Other node\n     */\n    public static boolean tokenEquals(JavaNode node, JavaNode that) {\n        return tokenEquals(node, that, null);\n    }\n\n    /**\n     * Returns true if both nodes have the same tokens, modulo some renaming\n     * function. The renaming function maps unqualified variables and type\n     * identifiers of the first node to the other. This should be used\n     * in nodes living in the same lexical scope, so that unqualified\n     * names mean the same thing.\n     *\n     * @param node       First node\n     * @param other      Other node\n     * @param varRenamer A renaming function. If null, no renaming is applied.\n     *                   Must not return null, if no renaming occurs, returns its argument.\n     */\n    public static boolean tokenEquals(@NonNull JavaNode node,\n                                      @NonNull JavaNode other,\n                                      @Nullable Function<String, @NonNull String> varRenamer) {\n        // Since type and variable names obscure one another,\n        // it's ok to use a single renaming function.\n\n        Iterator<JavaccToken> thisIt = GenericToken.range(node.getFirstToken(), node.getLastToken());\n        Iterator<JavaccToken> thatIt = GenericToken.range(other.getFirstToken(), other.getLastToken());\n        int lastKind = 0;\n        while (thisIt.hasNext()) {\n            if (!thatIt.hasNext()) {\n                return false;\n            }\n            JavaccToken o1 = thisIt.next();\n            JavaccToken o2 = thatIt.next();\n            if (o1.kind != o2.kind) {\n                return false;\n            }\n\n            String mappedImage = o1.getImage();\n            if (varRenamer != null\n                && o1.kind == JavaTokenKinds.IDENTIFIER\n                && lastKind != JavaTokenKinds.DOT\n                && lastKind != JavaTokenKinds.METHOD_REF\n                //method name\n                && o1.getNext() != null && o1.getNext().kind != JavaTokenKinds.LPAREN) {\n                mappedImage = varRenamer.apply(mappedImage);\n            }\n\n            if (!o2.getImage().equals(mappedImage)) {\n                return false;\n            }\n\n            lastKind = o1.kind;\n        }\n        return !thatIt.hasNext();\n    }\n\n    public static boolean isNullLiteral(ASTExpression node) {\n        return node instanceof ASTNullLiteral;\n    }\n\n    /** Returns true if the node is a boolean literal with any value. */\n    public static boolean isBooleanLiteral(JavaNode e) {\n        return e instanceof ASTBooleanLiteral;\n    }\n\n    /** Returns true if the node is a boolean literal with the given constant value. */\n    public static boolean isBooleanLiteral(JavaNode e, boolean value) {\n        return e instanceof ASTBooleanLiteral && ((ASTBooleanLiteral) e).isTrue() == value;\n    }\n\n    public static boolean isBooleanNegation(JavaNode e) {\n        return e instanceof ASTUnaryExpression && ((ASTUnaryExpression) e).getOperator() == UnaryOp.NEGATION;\n    }\n\n    /**\n     * If the argument is a unary expression, returns its operand, otherwise\n     * returns null.\n     */\n    public static @Nullable ASTExpression unaryOperand(@Nullable ASTExpression e) {\n        return e instanceof ASTUnaryExpression ? ((ASTUnaryExpression) e).getOperand()\n                                               : null;\n    }\n\n    /**\n     * Whether the expression is an access to a field of this instance,\n     * not inherited, qualified or not ({@code this.field} or just {@code field}).\n     */\n    public static boolean isThisFieldAccess(ASTExpression e) {\n        if (!(e instanceof ASTNamedReferenceExpr)) {\n            return false;\n        }\n        JVariableSymbol sym = ((ASTNamedReferenceExpr) e).getReferencedSym();\n        return sym instanceof JFieldSymbol\n                && !((JFieldSymbol) sym).isStatic()\n                // not inherited\n                && ((JFieldSymbol) sym).getEnclosingClass().equals(e.getEnclosingType().getSymbol())\n                // correct syntactic form\n                && (e instanceof ASTVariableAccess || isSyntacticThisFieldAccess(e));\n    }\n\n    /**\n     * Whether the expression is a {@code this.field}, with no outer\n     * instance qualifier ({@code Outer.this.field}). The field symbol\n     * is not checked to resolve to a field declared in this class (it\n     * may be inherited)\n     */\n    public static boolean isSyntacticThisFieldAccess(ASTExpression e) {\n        if (e instanceof ASTFieldAccess) {\n            ASTExpression qualifier = ((ASTFieldAccess) e).getQualifier();\n            if (qualifier instanceof ASTThisExpression) {\n                // unqualified this\n                return ((ASTThisExpression) qualifier).getQualifier() == null;\n            }\n        }\n        return false;\n    }\n\n    public static boolean hasAnyAnnotation(Annotatable node, Collection<String> qualifiedNames) {\n        return qualifiedNames.stream().anyMatch(node::isAnnotationPresent);\n    }\n\n    /**\n     * Returns true if the expression is the default field value for\n     * the given type.\n     */\n    public static boolean isDefaultValue(JTypeMirror type, ASTExpression expr) {\n        if (type.isPrimitive()) {\n            if (type.isPrimitive(PrimitiveTypeKind.BOOLEAN)) {\n                return expr instanceof ASTBooleanLiteral && !((ASTBooleanLiteral) expr).isTrue();\n            } else {\n                Object constValue = expr.getConstValue();\n                return constValue instanceof Number && ((Number) constValue).doubleValue() == 0d\n                    || constValue instanceof Character && constValue.equals('\\u0000');\n            }\n        } else {\n            return expr instanceof ASTNullLiteral;\n        }\n    }\n\n    /**\n     * Returns true if the expression is a {@link ASTNamedReferenceExpr}\n     * that references the symbol.\n     */\n    public static boolean isReferenceToVar(@Nullable ASTExpression expression, @NonNull JVariableSymbol symbol) {\n        return expression instanceof ASTNamedReferenceExpr\n            && symbol.equals(((ASTNamedReferenceExpr) expression).getReferencedSym());\n    }\n\n    public static boolean isUnqualifiedThis(ASTExpression e) {\n        return e instanceof ASTThisExpression && ((ASTThisExpression) e).getQualifier() == null;\n    }\n\n    public static boolean isUnqualifiedSuper(ASTExpression e) {\n        return e instanceof ASTSuperExpression && ((ASTSuperExpression) e).getQualifier() == null;\n    }\n\n    public static boolean isUnqualifiedThisOrSuper(ASTExpression e) {\n        return isUnqualifiedSuper(e) || isUnqualifiedThis(e);\n    }\n\n    /**\n     * Returns true if the expression is a {@link ASTNamedReferenceExpr}\n     * that references any of the symbol in the set.\n     */\n    public static boolean isReferenceToVar(@Nullable ASTExpression expression, @NonNull Set<? extends JVariableSymbol> symbols) {\n        return expression instanceof ASTNamedReferenceExpr\n            && symbols.contains(((ASTNamedReferenceExpr) expression).getReferencedSym());\n    }\n\n    /**\n     * Returns true if both expressions refer to the same variable.\n     * A \"variable\" here can also means a field path, eg, {@code this.field.a}.\n     * This method unifies {@code this.field} and {@code field} if possible,\n     * and also considers {@code this}.\n     *\n     * <p>Note that while this is more useful than just checking whether\n     * both expressions access the same symbol, it still does not mean that\n     * they both access the same <i>value</i>. The actual value is data-flow\n     * dependent.\n     */\n    public static boolean isReferenceToSameVar(ASTExpression e1, ASTExpression e2) {\n        if (e1 instanceof ASTNamedReferenceExpr && e2 instanceof ASTNamedReferenceExpr) {\n            if (OptionalBool.YES != referenceSameSymbol((ASTNamedReferenceExpr) e1, (ASTNamedReferenceExpr) e2)) {\n                return false;\n            }\n\n            if (e1.getClass() != e2.getClass()) {\n                // unify `this.f` and `f`\n                // note, we already know that the symbol is the same so there's no scoping problem\n                return isSyntacticThisFieldAccess(e1) || isSyntacticThisFieldAccess(e2);\n            } else if (e1 instanceof ASTFieldAccess && e2 instanceof ASTFieldAccess) {\n                return isReferenceToSameVar(((ASTFieldAccess) e1).getQualifier(),\n                                            ((ASTFieldAccess) e2).getQualifier());\n            }\n            return e1 instanceof ASTVariableAccess && e2 instanceof ASTVariableAccess;\n        } else if (e1 instanceof ASTThisExpression || e2 instanceof ASTThisExpression) {\n            return e1.getClass() == e2.getClass();\n        }\n        return false;\n    }\n\n    private static OptionalBool referenceSameSymbol(ASTNamedReferenceExpr e1, ASTNamedReferenceExpr e2) {\n        if (!e1.getName().equals(e2.getName())) {\n            return OptionalBool.NO;\n        }\n        JVariableSymbol ref1 = e1.getReferencedSym();\n        JVariableSymbol ref2 = e2.getReferencedSym();\n        if (ref1 == null || ref2 == null) {\n            return OptionalBool.UNKNOWN;\n        }\n        return OptionalBool.definitely(ref1.equals(ref2));\n    }\n\n    /**\n     * Returns true if the expression is a reference to a local variable.\n     */\n    public static boolean isReferenceToLocal(ASTExpression expr) {\n        return expr instanceof ASTVariableAccess\n                && ((ASTVariableAccess) expr).getReferencedSym() instanceof AstLocalVarSym;\n    }\n\n    /**\n     * Returns true if the expression has the form `field`, or `this.field`,\n     * where `field` is a field declared in the enclosing class. Considers\n     * inherited fields. Assumes we're not in a static context.\n     */\n    public static boolean isRefToFieldOfThisInstance(ASTExpression usage) {\n        if (!(usage instanceof ASTNamedReferenceExpr)) {\n            return false;\n        }\n        JVariableSymbol symbol = ((ASTNamedReferenceExpr) usage).getReferencedSym();\n        if (!(symbol instanceof JFieldSymbol)) {\n            return false;\n        }\n\n        if (usage instanceof ASTVariableAccess) {\n            return !Modifier.isStatic(((JFieldSymbol) symbol).getModifiers());\n        } else if (usage instanceof ASTFieldAccess) {\n            return isUnqualifiedThisOrSuper(((ASTFieldAccess) usage).getQualifier());\n        }\n        return false;\n    }\n\n    /**\n     * Returns true if the expression is a reference to a field declared\n     * in this class (not a superclass), on any instance (not just `this`).\n     */\n    public static boolean isRefToFieldOfThisClass(ASTExpression usage) {\n        if (!(usage instanceof ASTNamedReferenceExpr)) {\n            return false;\n        }\n        JVariableSymbol symbol = ((ASTNamedReferenceExpr) usage).getReferencedSym();\n        if (!(symbol instanceof JFieldSymbol)) {\n            return false;\n        }\n\n        if (usage instanceof ASTVariableAccess) {\n            return !Modifier.isStatic(((JFieldSymbol) symbol).getModifiers());\n        } else if (usage instanceof ASTFieldAccess) {\n            return Objects.equals(((JFieldSymbol) symbol).getEnclosingClass(),\n                                  usage.getEnclosingType().getSymbol());\n        }\n        return false;\n    }\n\n    public static boolean isCallOnThisInstance(ASTMethodCall call) {\n        // syntactic approach.\n        if (call.getQualifier() != null) {\n            return isUnqualifiedThisOrSuper(call.getQualifier());\n        }\n\n        // unqualified call\n        JMethodSig mtype = call.getMethodType();\n        return !mtype.getSymbol().isUnresolved()\n            && mtype.getSymbol().getEnclosingClass().equals(call.getEnclosingType().getSymbol());\n    }\n\n    public static ASTClassOrInterfaceType getThisOrSuperQualifier(ASTExpression expr) {\n        if (expr instanceof ASTThisExpression) {\n            return ((ASTThisExpression) expr).getQualifier();\n        } else if (expr instanceof ASTSuperExpression) {\n            return ((ASTSuperExpression) expr).getQualifier();\n        }\n        return null;\n    }\n\n    public static boolean isThisOrSuper(ASTExpression expr) {\n        return expr instanceof ASTThisExpression || expr instanceof ASTSuperExpression;\n    }\n\n    /**\n     * Return a node stream containing all the operands of an addition expression.\n     * For instance, {@code a+b+c} will be parsed as a tree with two levels.\n     * This method will return a flat node stream containing {@code a, b, c}.\n     *\n     * @param e An expression, if it is not a string concatenation expression,\n     *          then returns an empty node stream.\n     */\n    public static NodeStream<ASTExpression> flattenOperands(ASTExpression e) {\n        List<ASTExpression> result = new ArrayList<>();\n        flattenOperandsRec(e, result);\n        return NodeStream.fromIterable(result);\n    }\n\n    private static void flattenOperandsRec(ASTExpression e, List<ASTExpression> result) {\n        if (isStringConcatExpr(e)) {\n            ASTInfixExpression infix = (ASTInfixExpression) e;\n            flattenOperandsRec(infix.getLeftOperand(), result);\n            flattenOperandsRec(infix.getRightOperand(), result);\n        } else {\n            result.add(e);\n        }\n    }\n\n    /**\n     * Returns true if the node is the last child of its parent. Returns\n     * false if this is the root node.\n     */\n    public static boolean isLastChild(Node it) {\n        Node parent = it.getParent();\n        return parent != null && it.getIndexInParent() == parent.getNumChildren() - 1;\n    }\n\n    /**\n     * Returns a node stream of enclosing expressions in the same call chain.\n     * For instance in {@code a.b().c().d()}, called on {@code a}, this will\n     * yield {@code a.b()}, and {@code a.b().c()}.\n     */\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public static NodeStream<QualifiableExpression> followingCallChain(ASTExpression expr) {\n        return (NodeStream) expr.ancestors().takeWhile(it -> it instanceof QualifiableExpression);\n    }\n\n    public static ASTExpression peelCasts(@Nullable ASTExpression expr) {\n        while (expr instanceof ASTCastExpression) {\n            expr = ((ASTCastExpression) expr).getOperand();\n        }\n        return expr;\n    }\n\n    public static boolean isArrayInitializer(ASTExpression expr) {\n        return expr instanceof ASTArrayAllocation && ((ASTArrayAllocation) expr).getArrayInitializer() != null;\n    }\n\n    public static boolean isCloneMethod(ASTMethodDeclaration node) {\n        // this is enough as in valid code, this signature overrides Object#clone\n        // and the other things like visibility are checked by the compiler\n        return \"clone\".equals(node.getName())\n            && node.getArity() == 0\n            && !node.isStatic();\n    }\n\n    public static boolean isArrayLengthFieldAccess(ASTExpression node) {\n        if (node instanceof ASTFieldAccess) {\n            ASTFieldAccess field = (ASTFieldAccess) node;\n            return \"length\".equals(field.getName())\n                && field.getQualifier().getTypeMirror().isArray();\n        }\n        return false;\n    }\n\n    /**\n     * @see ASTBreakStatement#getTarget()\n     */\n    public static boolean mayBeBreakTarget(JavaNode it) {\n        return it instanceof ASTLoopStatement\n            || it instanceof ASTSwitchStatement\n            || it instanceof ASTLabeledStatement;\n    }\n\n    /**\n     * Tests if the node is an {@link ASTInfixExpression} with one of the given operators.\n     */\n    public static boolean isInfixExprWithOperator(@Nullable JavaNode e, Set<BinaryOp> operators) {\n        if (e instanceof ASTInfixExpression) {\n            ASTInfixExpression infix = (ASTInfixExpression) e;\n            return operators.contains(infix.getOperator());\n        }\n        return false;\n    }\n\n    /**\n     * Tests if the node is an {@link ASTInfixExpression} with the given operator.\n     */\n    public static boolean isInfixExprWithOperator(@Nullable JavaNode e, BinaryOp operator) {\n        if (e instanceof ASTInfixExpression) {\n            ASTInfixExpression infix = (ASTInfixExpression) e;\n            return operator == infix.getOperator();\n        }\n        return false;\n    }\n\n    /**\n     * Returns true if the given token is a Java comment.\n     */\n    public static boolean isComment(JavaccToken t) {\n        switch (t.kind) {\n        case FORMAL_COMMENT:\n        case MULTI_LINE_COMMENT:\n        case SINGLE_LINE_COMMENT:\n            return true;\n        default:\n            return false;\n        }\n    }\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "/**\n     * Returns true if the given token is a Java comment.\n     */\n    public static boolean isComment(JavaccToken t) {\n        switch (t.kind) {\n        case FORMAL_COMMENT:\n        case MULTI_LINE_COMMENT:\n        case SINGLE_LINE_COMMENT:\n            return true;\n        default:\n            return false;\n        }\n    }",
        "diffSourceCode": "-   31:     /**\n-   32:      * Returns true if the given token is a Java comment.\n-   33:      */\n-   34:     public static boolean isComment(JavaccToken t) {\n-   35:         switch (t.kind) {\n-   36:         case FORMAL_COMMENT:\n-   37:         case MULTI_LINE_COMMENT:\n-   38:         case SINGLE_LINE_COMMENT:\n-   39:             return true;\n-   40:         default:\n-   41:             return false;\n-   42:         }\n-   43:     }\n+   31: import net.sourceforge.pmd.lang.java.ast.ASTArrayAllocation;\n+   32: import net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr.ASTNamedReferenceExpr;\n+   33: import net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr.AccessType;\n+   34: import net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression;\n+   35: import net.sourceforge.pmd.lang.java.ast.ASTBooleanLiteral;\n+   36: import net.sourceforge.pmd.lang.java.ast.ASTBreakStatement;\n+   37: import net.sourceforge.pmd.lang.java.ast.ASTCastExpression;\n+   38: import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType;\n+   39: import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;\n+   40: import net.sourceforge.pmd.lang.java.ast.ASTExpression;\n+   41: import net.sourceforge.pmd.lang.java.ast.ASTExpressionStatement;\n+   42: import net.sourceforge.pmd.lang.java.ast.ASTFieldAccess;\n+   43: import net.sourceforge.pmd.lang.java.ast.ASTForStatement;\n+  719:     /**\n+  720:      * Returns true if the given token is a Java comment.\n+  721:      */\n+  722:     public static boolean isComment(JavaccToken t) {\n+  723:         switch (t.kind) {\n+  724:         case FORMAL_COMMENT:\n+  725:         case MULTI_LINE_COMMENT:\n+  726:         case SINGLE_LINE_COMMENT:\n+  727:             return true;\n+  728:         default:\n+  729:             return false;\n+  730:         }\n+  731:     }\n",
        "uniqueId": "e9ecc8aaa7ce266faa008977e8d153e96bd7188f_31_43__719_731",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 7
            },
            "BRANCH": {
                "missed": 0,
                "covered": 2
            },
            "LINE": {
                "missed": 0,
                "covered": 3
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 2
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate isInLambda(node Node) : boolean extracted from private isImmutableField(field VariableNameDeclaration, usages List<NameOccurrence>, allConstructors Set<ASTConstructorDeclaration>) : boolean in class net.sourceforge.pmd.lang.java.rule.design.ImmutableFieldRule",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/ImmutableFieldRule.java",
                "startLine": 80,
                "endLine": 116,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/ImmutableFieldRule.java",
                "startLine": 80,
                "endLine": 104,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/ImmutableFieldRule.java",
                "startLine": 106,
                "endLine": 108,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private boolean isImmutableField(VariableNameDeclaration field, List<NameOccurrence> usages, Set<ASTConstructorDeclaration> allConstructors) {\n        boolean assignedInMethod = false;\n        boolean assignedInLambda = false;\n        Set<ASTConstructorDeclaration> consSet = new HashSet<>(); // set of constructors accessing the field\n        for (NameOccurrence occ : usages) {\n            JavaNameOccurrence jocc = (JavaNameOccurrence) occ;\n            if (jocc.isOnLeftHandSide() || jocc.isSelfAssignment()) {\n                Node node = jocc.getLocation();\n                ASTConstructorDeclaration constructor = node.getFirstParentOfType(ASTConstructorDeclaration.class);\n                if (constructor != null && isSameClass(field, constructor)) {\n                    if (inLoopOrTry(node)) {\n                        assignedInMethod = true;\n                        continue;\n                    }\n\n                    if (inAnonymousInnerClass(node)) {\n                        assignedInMethod = true;\n                    } else if (node.getFirstParentOfType(ASTLambdaExpression.class) != null) {\n                        assignedInLambda = true;\n                    } else {\n                        consSet.add(constructor);\n                    }\n                } else {\n                    if (node.getFirstParentOfType(ASTLambdaExpression.class) != null) {\n                        assignedInLambda = true;\n                    } else {\n                        assignedInMethod = true;\n                    }\n                }\n            }\n        }\n        if (assignedInLambda || assignedInMethod) {\n            return false;\n        }\n        return (allConstructors.equals(consSet) && !allConstructors.isEmpty())\n               ^ initializedWhenDeclared(field);\n    }",
        "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/ImmutableFieldRule.java",
        "isPureRefactoring": true,
        "commitId": "5d8b210e6ddd8d7653d359fc78cc4602aa3f6904",
        "packageNameBefore": "net.sourceforge.pmd.lang.java.rule.design",
        "classNameBefore": "net.sourceforge.pmd.lang.java.rule.design.ImmutableFieldRule",
        "methodNameBefore": "net.sourceforge.pmd.lang.java.rule.design.ImmutableFieldRule#isImmutableField",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.java.rule.design.ImmutableFieldRule#inLoopOrTry\n methodBody: private boolean inLoopOrTry(Node node) {\nreturn node.getFirstParentOfType(ASTTryStatement.class) != null || node.getFirstParentOfType(ASTForStatement.class) != null || node.getFirstParentOfType(ASTWhileStatement.class) != null || node.getFirstParentOfType(ASTDoStatement.class) != null;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.rule.design.ImmutableFieldRule#initializedWhenDeclared\n methodBody: private boolean initializedWhenDeclared(VariableNameDeclaration field) {\nreturn field.getAccessNodeParent().hasDescendantOfType(ASTVariableInitializer.class);\n}\nmethodSignature: net.sourceforge.pmd.lang.java.rule.design.ImmutableFieldRule#isSameClass\n methodBody: private boolean isSameClass(VariableNameDeclaration field, ASTConstructorDeclaration constructor) {\nreturn constructor.getFirstParentOfType(ASTClassOrInterfaceBody.class) == field.getNode().getFirstParentOfType(ASTClassOrInterfaceBody.class);\n}\nmethodSignature: net.sourceforge.pmd.lang.java.rule.design.ImmutableFieldRule#inAnonymousInnerClass\n methodBody: private boolean inAnonymousInnerClass(Node node) {\nASTClassOrInterfaceBodyDeclaration parent=node.getFirstParentOfType(ASTClassOrInterfaceBodyDeclaration.class);\nreturn parent != null && parent.isAnonymousInnerClass();\n}",
        "classSignatureBefore": "public class ImmutableFieldRule extends AbstractLombokAwareRule ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.rule.design.ImmutableFieldRule#isImmutableField"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.rule.design.ImmutableFieldRule"
        ],
        "classSignatureBeforeSet": [
            "public class ImmutableFieldRule extends AbstractLombokAwareRule "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.rule.design;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody;\nimport net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBodyDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTDoStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTForStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTLambdaExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTTryStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableInitializer;\nimport net.sourceforge.pmd.lang.java.ast.ASTWhileStatement;\nimport net.sourceforge.pmd.lang.java.ast.AccessNode;\nimport net.sourceforge.pmd.lang.java.ast.Annotatable;\nimport net.sourceforge.pmd.lang.java.rule.AbstractLombokAwareRule;\nimport net.sourceforge.pmd.lang.java.symboltable.JavaNameOccurrence;\nimport net.sourceforge.pmd.lang.java.symboltable.VariableNameDeclaration;\nimport net.sourceforge.pmd.lang.symboltable.NameOccurrence;\n\n/**\n * @author Olander\n */\npublic class ImmutableFieldRule extends AbstractLombokAwareRule {\n\n    @Override\n    protected Collection<String> defaultSuppressionAnnotations() {\n        Collection<String> defaultValues = new ArrayList<>(super.defaultSuppressionAnnotations());\n        defaultValues.add(\"org.mockito.Captor\");\n        defaultValues.add(\"org.mockito.InjectMocks\");\n        defaultValues.add(\"org.mockito.Mock\");\n        defaultValues.add(\"org.springframework.beans.factory.annotation.Autowired\");\n        defaultValues.add(\"org.springframework.beans.factory.annotation.Value\");\n        defaultValues.add(\"org.springframework.boot.test.mock.mockito.MockBean\");\n\n        return defaultValues;\n    }\n\n    @Override\n    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {\n        Object result = super.visit(node, data);\n\n        Map<VariableNameDeclaration, List<NameOccurrence>> vars = node.getScope()\n                .getDeclarations(VariableNameDeclaration.class);\n        Set<ASTConstructorDeclaration> constructors = Collections.unmodifiableSet(new HashSet<>(findAllConstructors(node)));\n        for (Map.Entry<VariableNameDeclaration, List<NameOccurrence>> entry : vars.entrySet()) {\n            VariableNameDeclaration field = entry.getKey();\n            AccessNode accessNodeParent = field.getAccessNodeParent();\n            if (accessNodeParent.isStatic() || !accessNodeParent.isPrivate() || accessNodeParent.isFinal()\n                    || accessNodeParent.isVolatile()\n                    || hasLombokAnnotation(node)\n                    || hasIgnoredAnnotation((Annotatable) accessNodeParent)) {\n                continue;\n            }\n\n            List<NameOccurrence> usages = entry.getValue();\n            if (isImmutableField(field, usages, constructors)) {\n                addViolation(data, field.getNode(), field.getImage());\n            }\n        }\n        return result;\n    }\n\n    private boolean initializedWhenDeclared(VariableNameDeclaration field) {\n        return field.getAccessNodeParent().hasDescendantOfType(ASTVariableInitializer.class);\n    }\n\n    private boolean isImmutableField(VariableNameDeclaration field, List<NameOccurrence> usages, Set<ASTConstructorDeclaration> allConstructors) {\n        boolean assignedInMethod = false;\n        boolean assignedInLambda = false;\n        Set<ASTConstructorDeclaration> consSet = new HashSet<>(); // set of constructors accessing the field\n        for (NameOccurrence occ : usages) {\n            JavaNameOccurrence jocc = (JavaNameOccurrence) occ;\n            if (jocc.isOnLeftHandSide() || jocc.isSelfAssignment()) {\n                Node node = jocc.getLocation();\n                ASTConstructorDeclaration constructor = node.getFirstParentOfType(ASTConstructorDeclaration.class);\n                if (constructor != null && isSameClass(field, constructor)) {\n                    if (inLoopOrTry(node)) {\n                        assignedInMethod = true;\n                        continue;\n                    }\n\n                    if (inAnonymousInnerClass(node)) {\n                        assignedInMethod = true;\n                    } else if (node.getFirstParentOfType(ASTLambdaExpression.class) != null) {\n                        assignedInLambda = true;\n                    } else {\n                        consSet.add(constructor);\n                    }\n                } else {\n                    if (node.getFirstParentOfType(ASTLambdaExpression.class) != null) {\n                        assignedInLambda = true;\n                    } else {\n                        assignedInMethod = true;\n                    }\n                }\n            }\n        }\n        if (assignedInLambda || assignedInMethod) {\n            return false;\n        }\n        return (allConstructors.equals(consSet) && !allConstructors.isEmpty())\n               ^ initializedWhenDeclared(field);\n    }\n\n    /**\n     * Checks whether the given constructor belongs to the class, in which the field is declared.\n     * This might not be the case for inner classes, which accesses the fields of the outer class.\n     */\n    private boolean isSameClass(VariableNameDeclaration field, ASTConstructorDeclaration constructor) {\n        return constructor.getFirstParentOfType(ASTClassOrInterfaceBody.class) == field.getNode().getFirstParentOfType(ASTClassOrInterfaceBody.class);\n    }\n\n    private boolean inLoopOrTry(Node node) {\n        return node.getFirstParentOfType(ASTTryStatement.class) != null\n                || node.getFirstParentOfType(ASTForStatement.class) != null\n                || node.getFirstParentOfType(ASTWhileStatement.class) != null\n                || node.getFirstParentOfType(ASTDoStatement.class) != null;\n    }\n\n    private boolean inAnonymousInnerClass(Node node) {\n        ASTClassOrInterfaceBodyDeclaration parent = node.getFirstParentOfType(ASTClassOrInterfaceBodyDeclaration.class);\n        return parent != null && parent.isAnonymousInnerClass();\n    }\n\n    private List<ASTConstructorDeclaration> findAllConstructors(ASTClassOrInterfaceDeclaration node) {\n        return node.getFirstChildOfType(ASTClassOrInterfaceBody.class)\n                .findDescendantsOfType(ASTConstructorDeclaration.class);\n    }\n}\n",
        "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/ImmutableFieldRule.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.rule.design;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody;\nimport net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBodyDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTDoStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTForStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTLambdaExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTTryStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableInitializer;\nimport net.sourceforge.pmd.lang.java.ast.ASTWhileStatement;\nimport net.sourceforge.pmd.lang.java.ast.AccessNode;\nimport net.sourceforge.pmd.lang.java.ast.Annotatable;\nimport net.sourceforge.pmd.lang.java.rule.AbstractLombokAwareRule;\nimport net.sourceforge.pmd.lang.java.symboltable.JavaNameOccurrence;\nimport net.sourceforge.pmd.lang.java.symboltable.VariableNameDeclaration;\nimport net.sourceforge.pmd.lang.symboltable.NameOccurrence;\n\n/**\n * @author Olander\n */\npublic class ImmutableFieldRule extends AbstractLombokAwareRule {\n\n    @Override\n    protected Collection<String> defaultSuppressionAnnotations() {\n        Collection<String> defaultValues = new ArrayList<>(super.defaultSuppressionAnnotations());\n        defaultValues.add(\"org.mockito.Captor\");\n        defaultValues.add(\"org.mockito.InjectMocks\");\n        defaultValues.add(\"org.mockito.Mock\");\n        defaultValues.add(\"org.springframework.beans.factory.annotation.Autowired\");\n        defaultValues.add(\"org.springframework.beans.factory.annotation.Value\");\n        defaultValues.add(\"org.springframework.boot.test.mock.mockito.MockBean\");\n\n        return defaultValues;\n    }\n\n    @Override\n    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {\n        Object result = super.visit(node, data);\n\n        Map<VariableNameDeclaration, List<NameOccurrence>> vars = node.getScope()\n                .getDeclarations(VariableNameDeclaration.class);\n        Set<ASTConstructorDeclaration> constructors = Collections.unmodifiableSet(new HashSet<>(findAllConstructors(node)));\n        for (Map.Entry<VariableNameDeclaration, List<NameOccurrence>> entry : vars.entrySet()) {\n            VariableNameDeclaration field = entry.getKey();\n            AccessNode accessNodeParent = field.getAccessNodeParent();\n            if (accessNodeParent.isStatic() || !accessNodeParent.isPrivate() || accessNodeParent.isFinal()\n                    || accessNodeParent.isVolatile()\n                    || hasLombokAnnotation(node)\n                    || hasIgnoredAnnotation((Annotatable) accessNodeParent)) {\n                continue;\n            }\n\n            List<NameOccurrence> usages = entry.getValue();\n            if (isImmutableField(field, usages, constructors)) {\n                addViolation(data, field.getNode(), field.getImage());\n            }\n        }\n        return result;\n    }\n\n    private boolean initializedWhenDeclared(VariableNameDeclaration field) {\n        return field.getAccessNodeParent().hasDescendantOfType(ASTVariableInitializer.class);\n    }\n\n    private boolean isImmutableField(VariableNameDeclaration field, List<NameOccurrence> usages, Set<ASTConstructorDeclaration> allConstructors) {\n        Set<ASTConstructorDeclaration> consSet = new HashSet<>(); // set of constructors accessing the field\n        for (NameOccurrence occ : usages) {\n            JavaNameOccurrence jocc = (JavaNameOccurrence) occ;\n            if (jocc.isOnLeftHandSide() || jocc.isSelfAssignment()) {\n                Node node = jocc.getLocation();\n                ASTConstructorDeclaration constructor = node.getFirstParentOfType(ASTConstructorDeclaration.class);\n                if (constructor != null && isSameClass(field, constructor)) {\n                    if (inLoopOrTry(node)) {\n                        return false;\n                    }\n\n                    if (inAnonymousInnerClass(node) || isInLambda(node)) {\n                        return false; // leaks\n                    } else {\n                        consSet.add(constructor);\n                    }\n                } else if (inAnonymousInnerClass(node) || isInLambda(node)) {\n                    return false; // leaks\n                }\n            }\n        }\n        return (allConstructors.equals(consSet) && !allConstructors.isEmpty())\n               ^ initializedWhenDeclared(field);\n    }\n\n    private boolean isInLambda(Node node) {\n        return node.getFirstParentOfType(ASTLambdaExpression.class) != null;\n    }\n\n    /**\n     * Checks whether the given constructor belongs to the class, in which the field is declared.\n     * This might not be the case for inner classes, which accesses the fields of the outer class.\n     */\n    private boolean isSameClass(VariableNameDeclaration field, ASTConstructorDeclaration constructor) {\n        return constructor.getFirstParentOfType(ASTClassOrInterfaceBody.class) == field.getNode().getFirstParentOfType(ASTClassOrInterfaceBody.class);\n    }\n\n    private boolean inLoopOrTry(Node node) {\n        return node.getFirstParentOfType(ASTTryStatement.class) != null\n                || node.getFirstParentOfType(ASTForStatement.class) != null\n                || node.getFirstParentOfType(ASTWhileStatement.class) != null\n                || node.getFirstParentOfType(ASTDoStatement.class) != null;\n    }\n\n    private boolean inAnonymousInnerClass(Node node) {\n        ASTClassOrInterfaceBodyDeclaration parent = node.getFirstParentOfType(ASTClassOrInterfaceBodyDeclaration.class);\n        return parent != null && parent.isAnonymousInnerClass();\n    }\n\n    private List<ASTConstructorDeclaration> findAllConstructors(ASTClassOrInterfaceDeclaration node) {\n        return node.getFirstChildOfType(ASTClassOrInterfaceBody.class)\n                .findDescendantsOfType(ASTConstructorDeclaration.class);\n    }\n}\n",
        "diffSourceCodeSet": [
            "private boolean isInLambda(Node node) {\n        return node.getFirstParentOfType(ASTLambdaExpression.class) != null;\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.java.rule.design.ImmutableFieldRule#inLoopOrTry\n methodBody: private boolean inLoopOrTry(Node node) {\nreturn node.getFirstParentOfType(ASTTryStatement.class) != null || node.getFirstParentOfType(ASTForStatement.class) != null || node.getFirstParentOfType(ASTWhileStatement.class) != null || node.getFirstParentOfType(ASTDoStatement.class) != null;\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.rule.design.ImmutableFieldRule#initializedWhenDeclared\n methodBody: private boolean initializedWhenDeclared(VariableNameDeclaration field) {\nreturn field.getAccessNodeParent().hasDescendantOfType(ASTVariableInitializer.class);\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.rule.design.ImmutableFieldRule#isSameClass\n methodBody: private boolean isSameClass(VariableNameDeclaration field, ASTConstructorDeclaration constructor) {\nreturn constructor.getFirstParentOfType(ASTClassOrInterfaceBody.class) == field.getNode().getFirstParentOfType(ASTClassOrInterfaceBody.class);\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.rule.design.ImmutableFieldRule#inAnonymousInnerClass\n methodBody: private boolean inAnonymousInnerClass(Node node) {\nASTClassOrInterfaceBodyDeclaration parent=node.getFirstParentOfType(ASTClassOrInterfaceBodyDeclaration.class);\nreturn parent != null && parent.isAnonymousInnerClass();\n}"
        ],
        "sourceCodeAfterRefactoring": "private boolean isImmutableField(VariableNameDeclaration field, List<NameOccurrence> usages, Set<ASTConstructorDeclaration> allConstructors) {\n        Set<ASTConstructorDeclaration> consSet = new HashSet<>(); // set of constructors accessing the field\n        for (NameOccurrence occ : usages) {\n            JavaNameOccurrence jocc = (JavaNameOccurrence) occ;\n            if (jocc.isOnLeftHandSide() || jocc.isSelfAssignment()) {\n                Node node = jocc.getLocation();\n                ASTConstructorDeclaration constructor = node.getFirstParentOfType(ASTConstructorDeclaration.class);\n                if (constructor != null && isSameClass(field, constructor)) {\n                    if (inLoopOrTry(node)) {\n                        return false;\n                    }\n\n                    if (inAnonymousInnerClass(node) || isInLambda(node)) {\n                        return false; // leaks\n                    } else {\n                        consSet.add(constructor);\n                    }\n                } else if (inAnonymousInnerClass(node) || isInLambda(node)) {\n                    return false; // leaks\n                }\n            }\n        }\n        return (allConstructors.equals(consSet) && !allConstructors.isEmpty())\n               ^ initializedWhenDeclared(field);\n    }\nprivate boolean isInLambda(Node node) {\n        return node.getFirstParentOfType(ASTLambdaExpression.class) != null;\n    }",
        "diffSourceCode": "    80:     private boolean isImmutableField(VariableNameDeclaration field, List<NameOccurrence> usages, Set<ASTConstructorDeclaration> allConstructors) {\n-   81:         boolean assignedInMethod = false;\n-   82:         boolean assignedInLambda = false;\n-   83:         Set<ASTConstructorDeclaration> consSet = new HashSet<>(); // set of constructors accessing the field\n-   84:         for (NameOccurrence occ : usages) {\n-   85:             JavaNameOccurrence jocc = (JavaNameOccurrence) occ;\n-   86:             if (jocc.isOnLeftHandSide() || jocc.isSelfAssignment()) {\n-   87:                 Node node = jocc.getLocation();\n-   88:                 ASTConstructorDeclaration constructor = node.getFirstParentOfType(ASTConstructorDeclaration.class);\n-   89:                 if (constructor != null && isSameClass(field, constructor)) {\n-   90:                     if (inLoopOrTry(node)) {\n-   91:                         assignedInMethod = true;\n-   92:                         continue;\n-   93:                     }\n-   94: \n-   95:                     if (inAnonymousInnerClass(node)) {\n-   96:                         assignedInMethod = true;\n-   97:                     } else if (node.getFirstParentOfType(ASTLambdaExpression.class) != null) {\n-   98:                         assignedInLambda = true;\n-   99:                     } else {\n-  100:                         consSet.add(constructor);\n-  101:                     }\n-  102:                 } else {\n-  103:                     if (node.getFirstParentOfType(ASTLambdaExpression.class) != null) {\n-  104:                         assignedInLambda = true;\n-  105:                     } else {\n-  106:                         assignedInMethod = true;\n-  107:                     }\n-  108:                 }\n-  109:             }\n-  110:         }\n-  111:         if (assignedInLambda || assignedInMethod) {\n-  112:             return false;\n-  113:         }\n-  114:         return (allConstructors.equals(consSet) && !allConstructors.isEmpty())\n-  115:                ^ initializedWhenDeclared(field);\n+   81:         Set<ASTConstructorDeclaration> consSet = new HashSet<>(); // set of constructors accessing the field\n+   82:         for (NameOccurrence occ : usages) {\n+   83:             JavaNameOccurrence jocc = (JavaNameOccurrence) occ;\n+   84:             if (jocc.isOnLeftHandSide() || jocc.isSelfAssignment()) {\n+   85:                 Node node = jocc.getLocation();\n+   86:                 ASTConstructorDeclaration constructor = node.getFirstParentOfType(ASTConstructorDeclaration.class);\n+   87:                 if (constructor != null && isSameClass(field, constructor)) {\n+   88:                     if (inLoopOrTry(node)) {\n+   89:                         return false;\n+   90:                     }\n+   91: \n+   92:                     if (inAnonymousInnerClass(node) || isInLambda(node)) {\n+   93:                         return false; // leaks\n+   94:                     } else {\n+   95:                         consSet.add(constructor);\n+   96:                     }\n+   97:                 } else if (inAnonymousInnerClass(node) || isInLambda(node)) {\n+   98:                     return false; // leaks\n+   99:                 }\n+  100:             }\n+  101:         }\n+  102:         return (allConstructors.equals(consSet) && !allConstructors.isEmpty())\n+  103:                ^ initializedWhenDeclared(field);\n+  104:     }\n+  105: \n+  106:     private boolean isInLambda(Node node) {\n+  107:         return node.getFirstParentOfType(ASTLambdaExpression.class) != null;\n+  108:     }\n+  109: \n+  110:     /**\n+  111:      * Checks whether the given constructor belongs to the class, in which the field is declared.\n+  112:      * This might not be the case for inner classes, which accesses the fields of the outer class.\n+  113:      */\n+  114:     private boolean isSameClass(VariableNameDeclaration field, ASTConstructorDeclaration constructor) {\n+  115:         return constructor.getFirstParentOfType(ASTClassOrInterfaceBody.class) == field.getNode().getFirstParentOfType(ASTClassOrInterfaceBody.class);\n   116:     }\n",
        "uniqueId": "5d8b210e6ddd8d7653d359fc78cc4602aa3f6904_80_116_106_108_80_104",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 99
            },
            "BRANCH": {
                "missed": 0,
                "covered": 26
            },
            "LINE": {
                "missed": 0,
                "covered": 25
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 14
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17
    },
    {
        "type": "Move Method",
        "description": "Move Method\tprivate peekStack() : JSymbolTable from class net.sourceforge.pmd.lang.java.symbols.table.internal.SymbolTableResolver to private peekStack() : JSymbolTable from class net.sourceforge.pmd.lang.java.symbols.table.internal.SymbolTableResolver.MyVisitor",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/SymbolTableResolver.java",
                "startLine": 126,
                "endLine": 128,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/SymbolTableResolver.java",
                "startLine": 309,
                "endLine": 311,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private JSymbolTable peekStack() {\n        return this.myStackTop;\n    }",
        "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/SymbolTableResolver.java",
        "isPureRefactoring": true,
        "commitId": "e5fa9da6386330562cd9af3c62324f4d8ab69ad8",
        "packageNameBefore": "net.sourceforge.pmd.lang.java.symbols.table.internal",
        "classNameBefore": "net.sourceforge.pmd.lang.java.symbols.table.internal.SymbolTableResolver",
        "methodNameBefore": "net.sourceforge.pmd.lang.java.symbols.table.internal.SymbolTableResolver#peekStack",
        "classSignatureBefore": "public final class SymbolTableResolver ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.symbols.table.internal.SymbolTableResolver#peekStack"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.symbols.table.internal.SymbolTableResolver"
        ],
        "classSignatureBeforeSet": [
            "public final class SymbolTableResolver "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\n\npackage net.sourceforge.pmd.lang.java.symbols.table.internal;\n\nimport static net.sourceforge.pmd.lang.java.symbols.table.internal.TypeOnlySymTable.localClassesOf;\nimport static net.sourceforge.pmd.lang.java.symbols.table.internal.TypeOnlySymTable.nestedClassesOf;\nimport static net.sourceforge.pmd.lang.java.symbols.table.internal.VarOnlySymTable.formalsOf;\nimport static net.sourceforge.pmd.lang.java.symbols.table.internal.VarOnlySymTable.resourceIds;\nimport static net.sourceforge.pmd.lang.java.symbols.table.internal.VarOnlySymTable.varsOfBlock;\nimport static net.sourceforge.pmd.lang.java.symbols.table.internal.VarOnlySymTable.varsOfInit;\nimport static net.sourceforge.pmd.lang.java.symbols.table.internal.VarOnlySymTable.varsOfSwitchBlock;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.ast.NodeStream;\nimport net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTBlock;\nimport net.sourceforge.pmd.lang.java.ast.ASTCatchClause;\nimport net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;\nimport net.sourceforge.pmd.lang.java.ast.ASTForStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTForeachStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTLambdaExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTMethodOrConstructorDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTModifierList;\nimport net.sourceforge.pmd.lang.java.ast.ASTResourceList;\nimport net.sourceforge.pmd.lang.java.ast.ASTSwitchExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTSwitchLike;\nimport net.sourceforge.pmd.lang.java.ast.ASTSwitchStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTTryStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTTypeBody;\nimport net.sourceforge.pmd.lang.java.ast.InternalApiBridge;\nimport net.sourceforge.pmd.lang.java.ast.JavaNode;\nimport net.sourceforge.pmd.lang.java.ast.SideEffectingVisitorAdapter;\nimport net.sourceforge.pmd.lang.java.symbols.SymbolResolver;\nimport net.sourceforge.pmd.lang.java.symbols.table.JSymbolTable;\n\n\n/**\n * Visitor that builds all symbol table stacks for a compilation unit.\n * It's bound to a compilation unit and cannot be reused for several ACUs.\n *\n * @since 7.0.0\n */\npublic final class SymbolTableResolver {\n\n    private final SymbolTableHelper myResolveHelper;\n    private final ASTCompilationUnit root;\n    // current top of the stack\n    private JSymbolTable myStackTop;\n\n\n    /**\n     * Initialize this resolver using an analysis context and a root node.\n     *\n     * @param symResolver Resolver for external references\n     * @param root        The root node\n     */\n    public SymbolTableResolver(SymbolResolver symResolver,\n                               SemanticChecksLogger logger,\n                               ASTCompilationUnit root) {\n        this.root = root;\n        myResolveHelper = new SymbolTableHelper(root.getPackageName(), symResolver, logger);\n        // this is the only place pushOnStack can be circumvented\n        myStackTop = EmptySymbolTable.getInstance();\n\n    }\n\n    /**\n     * Start the analysis.\n     */\n    public void traverse() {\n        assert myStackTop instanceof EmptySymbolTable\n            : \"Top should be an empty symtable when starting the traversal\";\n\n        root.jjtAccept(new MyVisitor(), null);\n\n        assert myStackTop instanceof EmptySymbolTable\n            : \"Unbalanced stack push/pop! Top is \" + myStackTop;\n    }\n\n\n    /**\n     * Create a new symbol table using {@link TableLinker#createAndLink(JSymbolTable, SymbolTableHelper, Object)},\n     * linking it to the top of the stack as its parent.\n     *\n     * Pushes must naturally be balanced with {@link #popStack()} calls.\n     *\n     * @param data Additional param passed to the linker. Passing parameters\n     *             like this avoids having to create a capturing lambda.\n     *\n     * @return 1 if the table was pushed, 0 if not\n     */\n    private <T> int pushOnStack(TableLinker<T> tableLinker, T data) {\n        AbstractSymbolTable created = tableLinker.createAndLink(peekStack(), myResolveHelper, data);\n        return pushOnStack(created) ? 1 : 0;\n    }\n\n    private boolean pushOnStack(AbstractSymbolTable table) {\n        assert table.getParent() == peekStack() : \"Wrong parent\";\n        if (table.isPrunable()) {\n            return false; // and don't set the stack top\n        }\n        this.myStackTop = table;\n        return true;\n    }\n\n    private JSymbolTable popStack() {\n        JSymbolTable curTop = this.myStackTop;\n        this.myStackTop = curTop.getParent();\n        return curTop;\n    }\n\n    private void popStack(int times) {\n        while (times-- > 0) {\n            popStack();\n        }\n    }\n\n    private JSymbolTable peekStack() {\n        return this.myStackTop;\n    }\n\n    @FunctionalInterface\n    private interface TableLinker<T> {\n\n        /**\n         * Create a symbol table, given its parent, a helper instance,\n         * and some other data passed by {@link #pushOnStack(TableLinker, Object)}.\n         *\n         * @param stackTop Top of the stack, becomes the parent of the new node\n         * @param helper   Shared helper\n         * @param data     Additional parameter\n         */\n        AbstractSymbolTable createAndLink(JSymbolTable stackTop, SymbolTableHelper helper, T data);\n    }\n\n    private class MyVisitor extends SideEffectingVisitorAdapter<Void> {\n\n\n        // The AstAnalysisConfiguration is only used in the constructor\n        // The parameter on the visit methods is unnecessary\n        // TODO introduce another visitor with `void visit(Node);` signature\n\n        @Override\n        public void visit(ASTModifierList node, Void data) {\n            // do nothing\n        }\n\n        @Override\n        public void visit(ASTCompilationUnit node, Void data) {\n            Map<Boolean, List<ASTImportDeclaration>> isImportOnDemand = node.children(ASTImportDeclaration.class)\n                                                                            .collect(Collectors.partitioningBy(ASTImportDeclaration::isImportOnDemand));\n\n            int pushed = 0;\n            pushed += pushOnStack(ImportOnDemandSymbolTable::new, isImportOnDemand.get(true));\n            pushed += pushOnStack(JavaLangSymbolTable::new, node);\n            pushed += pushOnStack(SamePackageSymbolTable::new, node);\n            pushed += pushOnStack(SingleImportSymbolTable::new, isImportOnDemand.get(false));\n            // types declared inside the compilation unit\n            pushed += pushOnStack(TypeOnlySymTable::new, node.getTypeDeclarations());\n\n            // All of the header symbol tables belong to the CompilationUnit\n            setTopSymbolTableAndRecurse(node);\n            popStack(pushed);\n        }\n\n\n        @Override\n        public void visit(ASTAnyTypeDeclaration node, Void data) {\n            setTopSymbolTable(node.getModifiers());\n\n            int pushed = 0;\n            pushed += pushOnStack(TypeOnlySymTable::new, node); // pushes its own name, overrides type params of enclosing type\n\n            if (pushOnStack(TypeOnlySymTable::new, node.getTypeParameters()) > 0) {\n                // there are type parameters: the extends/implements/type parameter section know about them\n\n                NodeStream<? extends JavaNode> notBody = node.children().drop(1).filterNot(it -> it instanceof ASTTypeBody);\n                for (JavaNode it : notBody) {\n                    setTopSymbolTable(it);\n                }\n\n                popStack();\n            }\n\n            // the following is just for the body\n\n            pushed += pushOnStack(TypeMemberSymTable::new, node); // methods & fields & inherited classes\n            pushed += pushOnStack(TypeOnlySymTable::new, nestedClassesOf(node)); // declared classes\n            pushed += pushOnStack(TypeOnlySymTable::new, node.getTypeParameters()); // shadow type names of the former 2\n\n            setTopSymbolTableAndRecurse(node.getBody());\n\n            popStack(pushed);\n        }\n\n        @Override\n        public void visit(ASTMethodOrConstructorDeclaration node, Void data) {\n            setTopSymbolTable(node.getModifiers());\n\n            int pushed = 0;\n            pushed += pushOnStack(TypeOnlySymTable::new, node.getTypeParameters());\n            pushed += pushOnStack(VarOnlySymTable::new, formalsOf(node));\n\n            setTopSymbolTableAndRecurse(node);\n            popStack(pushed);\n        }\n\n        @Override\n        public void visit(ASTLambdaExpression node, Void data) {\n            int pushed = pushOnStack(VarOnlySymTable::new, formalsOf(node));\n            setTopSymbolTableAndRecurse(node);\n            popStack(pushed);\n        }\n\n        @Override\n        public void visit(ASTBlock node, Void data) {\n            int pushed = 0;\n            pushed += pushOnStack(VarOnlySymTable::new, varsOfBlock(node));\n            pushed += pushOnStack(TypeOnlySymTable::new, localClassesOf(node));\n            setTopSymbolTableAndRecurse(node);\n            popStack(pushed);\n        }\n\n        @Override\n        public void visit(ASTForeachStatement node, Void data) {\n            int pushed = pushOnStack(VarOnlySymTable::new, node.getVarId());\n            setTopSymbolTableAndRecurse(node);\n            popStack(pushed);\n        }\n\n        @Override\n        public void visit(ASTForStatement node, Void data) {\n            int pushed = pushOnStack(VarOnlySymTable::new, varsOfInit(node));\n            setTopSymbolTableAndRecurse(node);\n            popStack(pushed);\n        }\n\n        @Override\n        public void visit(ASTSwitchStatement node, Void data) {\n            visitSwitch(node);\n        }\n\n        @Override\n        public void visit(ASTSwitchExpression node, Void data) {\n            visitSwitch(node);\n        }\n\n        private void visitSwitch(ASTSwitchLike node) {\n            setTopSymbolTable(node);\n            visitSubtree(node.getTestedExpression());\n\n            // since there's no node for the block we have to set children individually\n            int pushed = pushOnStack(VarOnlySymTable::new, varsOfSwitchBlock(node));\n\n            for (JavaNode notExpr : node.children().drop(1)) {\n                setTopSymbolTableAndRecurse(notExpr);\n            }\n\n            popStack(pushed);\n        }\n\n        @Override\n        public void visit(ASTTryStatement node, Void data) {\n\n            ASTResourceList resources = node.getResources();\n            if (resources != null) {\n                int pushed = pushOnStack(VarOnlySymTable::new, resourceIds(resources));\n\n                setTopSymbolTableAndRecurse(resources);\n\n                ASTBlock body = node.getBody();\n                body.jjtAccept(this, data);\n\n                popStack(pushed); // pop resources table before visiting catch & finally\n\n                for (Node child : body.asStream().followingSiblings()) {\n                    ((JavaNode) child).jjtAccept(this, data);\n                }\n            } else {\n                super.visit(node, data);\n            }\n        }\n\n        @Override\n        public void visit(ASTCatchClause node, Void data) {\n            int pushed = pushOnStack(VarOnlySymTable::new, node.getParameter().getVarId());\n            setTopSymbolTableAndRecurse(node);\n            popStack(pushed);\n        }\n\n        private void setTopSymbolTable(JavaNode node) {\n            InternalApiBridge.setSymbolTable(node, peekStack());\n        }\n\n        private void setTopSymbolTableAndRecurse(JavaNode node) {\n            setTopSymbolTable(node);\n            visitSubtree(node);\n        }\n\n        private void visitSubtree(JavaNode node) {\n            for (JavaNode child : node.children()) {\n                child.jjtAccept(this, null);\n            }\n        }\n    }\n\n}\n",
        "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/SymbolTableResolver.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\n\npackage net.sourceforge.pmd.lang.java.symbols.table.internal;\n\nimport static net.sourceforge.pmd.lang.java.symbols.table.internal.TypeOnlySymTable.localClassesOf;\nimport static net.sourceforge.pmd.lang.java.symbols.table.internal.TypeOnlySymTable.nestedClassesOf;\nimport static net.sourceforge.pmd.lang.java.symbols.table.internal.VarOnlySymTable.formalsOf;\nimport static net.sourceforge.pmd.lang.java.symbols.table.internal.VarOnlySymTable.resourceIds;\nimport static net.sourceforge.pmd.lang.java.symbols.table.internal.VarOnlySymTable.varsOfBlock;\nimport static net.sourceforge.pmd.lang.java.symbols.table.internal.VarOnlySymTable.varsOfInit;\nimport static net.sourceforge.pmd.lang.java.symbols.table.internal.VarOnlySymTable.varsOfSwitchBlock;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.ast.NodeStream;\nimport net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTBlock;\nimport net.sourceforge.pmd.lang.java.ast.ASTCatchClause;\nimport net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;\nimport net.sourceforge.pmd.lang.java.ast.ASTForStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTForeachStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTLambdaExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTMethodOrConstructorDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTModifierList;\nimport net.sourceforge.pmd.lang.java.ast.ASTResourceList;\nimport net.sourceforge.pmd.lang.java.ast.ASTSwitchExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTSwitchLike;\nimport net.sourceforge.pmd.lang.java.ast.ASTSwitchStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTTryStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTTypeBody;\nimport net.sourceforge.pmd.lang.java.ast.InternalApiBridge;\nimport net.sourceforge.pmd.lang.java.ast.JavaNode;\nimport net.sourceforge.pmd.lang.java.ast.SideEffectingVisitorAdapter;\nimport net.sourceforge.pmd.lang.java.internal.JavaAstProcessor;\nimport net.sourceforge.pmd.lang.java.symbols.table.JSymbolTable;\n\n\n/**\n * Visitor that builds all symbol table stacks for a compilation unit.\n * It's bound to a compilation unit and cannot be reused for several ACUs.\n *\n * @since 7.0.0\n */\npublic final class SymbolTableResolver {\n\n    private SymbolTableResolver() {\n        // fa\u00e7ade\n    }\n\n    public static void traverse(JavaAstProcessor processor, ASTCompilationUnit root) {\n        SymbolTableHelper helper = new SymbolTableHelper(root.getPackageName(), processor);\n        new MyVisitor(root, helper).traverse();\n    }\n\n\n    @FunctionalInterface\n    private interface TableLinker<T> {\n\n        /**\n         * Create a symbol table, given its parent, a helper instance,\n         * and some other data passed by {@link MyVisitor#pushOnStack(TableLinker, Object)}.\n         *\n         * @param stackTop Top of the stack, becomes the parent of the new node\n         * @param helper   Shared helper\n         * @param data     Additional parameter\n         */\n        AbstractSymbolTable createAndLink(JSymbolTable stackTop, SymbolTableHelper helper, T data);\n    }\n\n    private static class MyVisitor extends SideEffectingVisitorAdapter<Void> {\n\n        private final ASTCompilationUnit root;\n        private final SymbolTableHelper myResolveHelper;\n        private JSymbolTable myStackTop;\n\n        public MyVisitor(ASTCompilationUnit root, SymbolTableHelper helper) {\n            this.root = root;\n            myResolveHelper = helper;\n            // this is the only place pushOnStack can be circumvented\n            myStackTop = EmptySymbolTable.getInstance();\n        }\n\n\n        /**\n         * Start the analysis.\n         */\n        public void traverse() {\n            assert myStackTop instanceof EmptySymbolTable\n                : \"Top should be an empty symtable when starting the traversal\";\n\n            root.jjtAccept(this, null);\n\n            assert myStackTop instanceof EmptySymbolTable\n                : \"Unbalanced stack push/pop! Top is \" + myStackTop;\n        }\n\n        @Override\n        public void visit(ASTModifierList node, Void data) {\n            // do nothing\n        }\n\n        @Override\n        public void visit(ASTCompilationUnit node, Void data) {\n            Map<Boolean, List<ASTImportDeclaration>> isImportOnDemand = node.children(ASTImportDeclaration.class)\n                                                                            .collect(Collectors.partitioningBy(ASTImportDeclaration::isImportOnDemand));\n\n            int pushed = 0;\n            pushed += pushOnStack(ImportOnDemandSymbolTable::new, isImportOnDemand.get(true));\n            pushed += pushOnStack(JavaLangSymbolTable::new, node);\n            pushed += pushOnStack(SamePackageSymbolTable::new, node);\n            pushed += pushOnStack(SingleImportSymbolTable::new, isImportOnDemand.get(false));\n            // types declared inside the compilation unit\n            pushed += pushOnStack(TypeOnlySymTable::new, node.getTypeDeclarations());\n\n            // All of the header symbol tables belong to the CompilationUnit\n            setTopSymbolTableAndRecurse(node);\n            popStack(pushed);\n        }\n\n\n        @Override\n        public void visit(ASTAnyTypeDeclaration node, Void data) {\n            setTopSymbolTable(node.getModifiers());\n\n            int pushed = 0;\n            pushed += pushOnStack(TypeOnlySymTable::new, node); // pushes its own name, overrides type params of enclosing type\n\n            if (pushOnStack(TypeOnlySymTable::new, node.getTypeParameters()) > 0) {\n                // there are type parameters: the extends/implements/type parameter section know about them\n\n                NodeStream<? extends JavaNode> notBody = node.children().drop(1).filterNot(it -> it instanceof ASTTypeBody);\n                for (JavaNode it : notBody) {\n                    setTopSymbolTable(it);\n                }\n\n                popStack();\n            }\n\n            // the following is just for the body\n\n            pushed += pushOnStack(TypeMemberSymTable::new, node); // methods & fields & inherited classes\n            pushed += pushOnStack(TypeOnlySymTable::new, nestedClassesOf(node)); // declared classes\n            pushed += pushOnStack(TypeOnlySymTable::new, node.getTypeParameters()); // shadow type names of the former 2\n\n            setTopSymbolTableAndRecurse(node.getBody());\n\n            popStack(pushed);\n        }\n\n        @Override\n        public void visit(ASTMethodOrConstructorDeclaration node, Void data) {\n            setTopSymbolTable(node.getModifiers());\n\n            int pushed = 0;\n            pushed += pushOnStack(TypeOnlySymTable::new, node.getTypeParameters());\n            pushed += pushOnStack(VarOnlySymTable::new, formalsOf(node));\n\n            setTopSymbolTableAndRecurse(node);\n            popStack(pushed);\n        }\n\n        @Override\n        public void visit(ASTLambdaExpression node, Void data) {\n            int pushed = pushOnStack(VarOnlySymTable::new, formalsOf(node));\n            setTopSymbolTableAndRecurse(node);\n            popStack(pushed);\n        }\n\n        @Override\n        public void visit(ASTBlock node, Void data) {\n            int pushed = 0;\n            pushed += pushOnStack(VarOnlySymTable::new, varsOfBlock(node));\n            pushed += pushOnStack(TypeOnlySymTable::new, localClassesOf(node));\n            setTopSymbolTableAndRecurse(node);\n            popStack(pushed);\n        }\n\n        @Override\n        public void visit(ASTForeachStatement node, Void data) {\n            int pushed = pushOnStack(VarOnlySymTable::new, node.getVarId());\n            setTopSymbolTableAndRecurse(node);\n            popStack(pushed);\n        }\n\n        @Override\n        public void visit(ASTForStatement node, Void data) {\n            int pushed = pushOnStack(VarOnlySymTable::new, varsOfInit(node));\n            setTopSymbolTableAndRecurse(node);\n            popStack(pushed);\n        }\n\n        @Override\n        public void visit(ASTSwitchStatement node, Void data) {\n            visitSwitch(node);\n        }\n\n        @Override\n        public void visit(ASTSwitchExpression node, Void data) {\n            visitSwitch(node);\n        }\n\n        private void visitSwitch(ASTSwitchLike node) {\n            setTopSymbolTable(node);\n            visitSubtree(node.getTestedExpression());\n\n            // since there's no node for the block we have to set children individually\n            int pushed = pushOnStack(VarOnlySymTable::new, varsOfSwitchBlock(node));\n\n            for (JavaNode notExpr : node.children().drop(1)) {\n                setTopSymbolTableAndRecurse(notExpr);\n            }\n\n            popStack(pushed);\n        }\n\n        @Override\n        public void visit(ASTTryStatement node, Void data) {\n\n            ASTResourceList resources = node.getResources();\n            if (resources != null) {\n                int pushed = pushOnStack(VarOnlySymTable::new, resourceIds(resources));\n\n                setTopSymbolTableAndRecurse(resources);\n\n                ASTBlock body = node.getBody();\n                body.jjtAccept(this, data);\n\n                popStack(pushed); // pop resources table before visiting catch & finally\n\n                for (Node child : body.asStream().followingSiblings()) {\n                    ((JavaNode) child).jjtAccept(this, data);\n                }\n            } else {\n                super.visit(node, data);\n            }\n        }\n\n        @Override\n        public void visit(ASTCatchClause node, Void data) {\n            int pushed = pushOnStack(VarOnlySymTable::new, node.getParameter().getVarId());\n            setTopSymbolTableAndRecurse(node);\n            popStack(pushed);\n        }\n\n\n        // <editor-fold defaultstate=\"collapsed\" desc=\"Stack manipulation routines\">\n\n        private void setTopSymbolTable(JavaNode node) {\n            InternalApiBridge.setSymbolTable(node, peekStack());\n        }\n\n        private void setTopSymbolTableAndRecurse(JavaNode node) {\n            setTopSymbolTable(node);\n            visitSubtree(node);\n        }\n\n        private void visitSubtree(JavaNode node) {\n            for (JavaNode child : node.children()) {\n                child.jjtAccept(this, null);\n            }\n        }\n\n\n\n        /**\n         * Create a new symbol table using {@link TableLinker#createAndLink(JSymbolTable, SymbolTableHelper, Object)},\n         * linking it to the top of the stack as its parent.\n         *\n         * Pushes must naturally be balanced with {@link #popStack()} calls.\n         *\n         * @param data Additional param passed to the linker. Passing parameters\n         *             like this avoids having to create a capturing lambda.\n         *\n         * @return 1 if the table was pushed, 0 if not\n         */\n        private <T> int pushOnStack(TableLinker<T> tableLinker, T data) {\n            AbstractSymbolTable created = tableLinker.createAndLink(peekStack(), myResolveHelper, data);\n            return pushOnStack(created) ? 1 : 0;\n        }\n\n        private boolean pushOnStack(AbstractSymbolTable table) {\n            assert table.getParent() == peekStack() : \"Wrong parent\";\n            if (table.isPrunable()) {\n                return false; // and don't set the stack top\n            }\n            this.myStackTop = table;\n            return true;\n        }\n\n        private JSymbolTable popStack() {\n            JSymbolTable curTop = this.myStackTop;\n            this.myStackTop = curTop.getParent();\n            return curTop;\n        }\n\n        private void popStack(int times) {\n            while (times-- > 0) {\n                popStack();\n            }\n        }\n\n        private JSymbolTable peekStack() {\n            return this.myStackTop;\n        }\n\n        // </editor-fold>\n\n    }\n\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "private JSymbolTable peekStack() {\n            return this.myStackTop;\n        }",
        "diffSourceCode": "-  126:     private JSymbolTable peekStack() {\n-  127:         return this.myStackTop;\n-  128:     }\n-  309:             for (JavaNode child : node.children()) {\n-  310:                 child.jjtAccept(this, null);\n-  311:             }\n+  126: \n+  127: \n+  128:         @Override\n+  309:         private JSymbolTable peekStack() {\n+  310:             return this.myStackTop;\n+  311:         }\n",
        "uniqueId": "e5fa9da6386330562cd9af3c62324f4d8ab69ad8_126_128__309_311",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 3
            },
            "LINE": {
                "missed": 0,
                "covered": 1
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate nodeImpl(node DummyNode, children DummyNode...) : DummyNode extracted from public node(children DummyNode...) : DummyNode in class net.sourceforge.pmd.lang.ast.DummyTreeUtil",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/lang/ast/DummyTreeUtil.java",
                "startLine": 24,
                "endLine": 38,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/lang/ast/DummyTreeUtil.java",
                "startLine": 26,
                "endLine": 35,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/lang/ast/DummyTreeUtil.java",
                "startLine": 42,
                "endLine": 49,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/** Creates a dummy node with the given children. */\n    public static DummyNode node(DummyNode... children) {\n        DummyNode node = new DummyNode(0) {\n            @Override\n            public String toString() {\n                return getImage();\n            }\n        };\n        node.children = children;\n        for (int i = 0; i < children.length; i++) {\n            children[i].jjtSetParent(node);\n            children[i].jjtSetChildIndex(i);\n        }\n        return node;\n    }",
        "filePathBefore": "pmd-core/src/test/java/net/sourceforge/pmd/lang/ast/DummyTreeUtil.java",
        "isPureRefactoring": true,
        "commitId": "170360b309ec58599a5b863616fea0654e207c98",
        "packageNameBefore": "net.sourceforge.pmd.lang.ast",
        "classNameBefore": "net.sourceforge.pmd.lang.ast.DummyTreeUtil",
        "methodNameBefore": "net.sourceforge.pmd.lang.ast.DummyTreeUtil#node",
        "classSignatureBefore": "public final class DummyTreeUtil ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.ast.DummyTreeUtil#node"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.ast.DummyTreeUtil"
        ],
        "classSignatureBeforeSet": [
            "public final class DummyTreeUtil "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.ast;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\n\n\n/**\n * @author Cl\u00e9ment Fournier\n */\npublic final class DummyTreeUtil {\n\n\n    private DummyTreeUtil() {\n\n    }\n\n\n    /** Creates a dummy node with the given children. */\n    public static DummyNode node(DummyNode... children) {\n        DummyNode node = new DummyNode(0) {\n            @Override\n            public String toString() {\n                return getImage();\n            }\n        };\n        node.children = children;\n        for (int i = 0; i < children.length; i++) {\n            children[i].jjtSetParent(node);\n            children[i].jjtSetChildIndex(i);\n        }\n        return node;\n    }\n\n\n    public static DummyNode followPath(DummyNode root, String path) {\n        List<Integer> pathIndices = Arrays.stream(path.split(\"\")).map(Integer::valueOf).collect(Collectors.toList());\n\n        Node current = root;\n        for (int i : pathIndices) {\n            current = current.getChild(i);\n        }\n\n        return (DummyNode) current;\n    }\n\n\n    /**\n     * Must wrap the actual {@link #node(DummyNode...)} usages to assign each node the\n     * image of its path from the root (in indices). E.g.\n     *\n     * <pre>\n     * node(         \"\"\n     *   node(       \"0\"\n     *     node(),   \"00\"\n     *     node(     \"01\"\n     *       node()  \"010\n     *     )\n     *   ),\n     *   node()      \"1\"\n     * )\n     * </pre>\n     */\n    public static DummyNode tree(Supplier<DummyNode> supplier) {\n        DummyNode dummyNode = supplier.get();\n        assignPathImage(dummyNode, \"\");\n        return dummyNode;\n    }\n\n\n    private static void assignPathImage(Node node, String curPath) {\n        node.setImage(curPath);\n\n        for (int i = 0; i < node.getNumChildren(); i++) {\n            assignPathImage(node.getChild(i), curPath + i);\n        }\n    }\n\n    /** List of the images of the stream. */\n    public static List<String> pathsOf(NodeStream<?> stream) {\n        return stream.toList(Node::getImage);\n    }\n}\n",
        "filePathAfter": "pmd-core/src/test/java/net/sourceforge/pmd/lang/ast/DummyTreeUtil.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.ast;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\n\nimport net.sourceforge.pmd.lang.ast.DummyNode.DummyNodeTypeB;\n\n\n/**\n * @author Cl\u00e9ment Fournier\n */\npublic final class DummyTreeUtil {\n\n\n    private DummyTreeUtil() {\n\n    }\n\n\n    /** Creates a dummy node with the given children. */\n    public static DummyNode node(DummyNode... children) {\n        DummyNode node = new DummyNode() {\n            @Override\n            public String toString() {\n                return getImage();\n            }\n        };\n        return nodeImpl(node, children);\n    }\n\n    /** Creates a dummy node with the given children. */\n    public static DummyNode nodeB(DummyNode... children) {\n        return nodeImpl(new DummyNodeTypeB(), children);\n    }\n\n    private static DummyNode nodeImpl(DummyNode node, DummyNode... children) {\n        node.children = children;\n        for (int i = 0; i < children.length; i++) {\n            children[i].jjtSetParent(node);\n            children[i].jjtSetChildIndex(i);\n        }\n        return node;\n    }\n\n\n    public static DummyNode followPath(DummyNode root, String path) {\n        List<Integer> pathIndices = Arrays.stream(path.split(\"\")).map(Integer::valueOf).collect(Collectors.toList());\n\n        Node current = root;\n        for (int i : pathIndices) {\n            current = current.getChild(i);\n        }\n\n        return (DummyNode) current;\n    }\n\n\n    /**\n     * Must wrap the actual {@link #node(DummyNode...)} usages to assign each node the\n     * image of its path from the root (in indices). E.g.\n     *\n     * <pre>\n     * node(         \"\"\n     *   node(       \"0\"\n     *     node(),   \"00\"\n     *     node(     \"01\"\n     *       node()  \"010\n     *     )\n     *   ),\n     *   node()      \"1\"\n     * )\n     * </pre>\n     */\n    public static DummyNode tree(Supplier<DummyNode> supplier) {\n        DummyNode dummyNode = supplier.get();\n        assignPathImage(dummyNode, \"\");\n        return dummyNode;\n    }\n\n\n    private static void assignPathImage(Node node, String curPath) {\n        node.setImage(curPath);\n\n        for (int i = 0; i < node.getNumChildren(); i++) {\n            assignPathImage(node.getChild(i), curPath + i);\n        }\n    }\n\n    /** List of the images of the stream. */\n    public static List<String> pathsOf(NodeStream<?> stream) {\n        return stream.toList(Node::getImage);\n    }\n}\n",
        "diffSourceCodeSet": [
            "private static DummyNode nodeImpl(DummyNode node, DummyNode... children) {\n        node.children = children;\n        for (int i = 0; i < children.length; i++) {\n            children[i].jjtSetParent(node);\n            children[i].jjtSetChildIndex(i);\n        }\n        return node;\n    }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "/** Creates a dummy node with the given children. */\n    public static DummyNode node(DummyNode... children) {\n        DummyNode node = new DummyNode() {\n            @Override\n            public String toString() {\n                return getImage();\n            }\n        };\n        return nodeImpl(node, children);\n    }\nprivate static DummyNode nodeImpl(DummyNode node, DummyNode... children) {\n        node.children = children;\n        for (int i = 0; i < children.length; i++) {\n            children[i].jjtSetParent(node);\n            children[i].jjtSetChildIndex(i);\n        }\n        return node;\n    }",
        "diffSourceCode": "-   24:     /** Creates a dummy node with the given children. */\n-   25:     public static DummyNode node(DummyNode... children) {\n-   26:         DummyNode node = new DummyNode(0) {\n-   27:             @Override\n-   28:             public String toString() {\n-   29:                 return getImage();\n-   30:             }\n-   31:         };\n-   32:         node.children = children;\n-   33:         for (int i = 0; i < children.length; i++) {\n-   34:             children[i].jjtSetParent(node);\n-   35:             children[i].jjtSetChildIndex(i);\n-   36:         }\n-   37:         return node;\n-   38:     }\n-   42:         List<Integer> pathIndices = Arrays.stream(path.split(\"\")).map(Integer::valueOf).collect(Collectors.toList());\n-   43: \n-   44:         Node current = root;\n-   45:         for (int i : pathIndices) {\n-   46:             current = current.getChild(i);\n+   24: \n+   25: \n+   26:     /** Creates a dummy node with the given children. */\n+   27:     public static DummyNode node(DummyNode... children) {\n+   28:         DummyNode node = new DummyNode() {\n+   29:             @Override\n+   30:             public String toString() {\n+   31:                 return getImage();\n+   32:             }\n+   33:         };\n+   34:         return nodeImpl(node, children);\n+   35:     }\n+   36: \n+   37:     /** Creates a dummy node with the given children. */\n+   38:     public static DummyNode nodeB(DummyNode... children) {\n+   42:     private static DummyNode nodeImpl(DummyNode node, DummyNode... children) {\n+   43:         node.children = children;\n+   44:         for (int i = 0; i < children.length; i++) {\n+   45:             children[i].jjtSetParent(node);\n+   46:             children[i].jjtSetChildIndex(i);\n    47:         }\n-   48: \n-   49:         return (DummyNode) current;\n+   48:         return node;\n+   49:     }\n",
        "uniqueId": "170360b309ec58599a5b863616fea0654e207c98_24_38_42_49_26_35",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic splitUnions(expr Expression) : Iterable<Expression> extracted from private analyzeXPathForRuleChain(xpathEvaluator XPathEvaluator) : void in class net.sourceforge.pmd.lang.rule.xpath.SaxonXPathRuleQuery & moved to class net.sourceforge.pmd.lang.rule.xpath.internal.RuleChainAnalyzer",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/SaxonXPathRuleQuery.java",
                "startLine": 260,
                "endLine": 301,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/SaxonXPathRuleQuery.java",
                "startLine": 259,
                "endLine": 293,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/SaxonXPathRuleQuery.java",
                "startLine": 103,
                "endLine": 114,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private void analyzeXPathForRuleChain(final XPathEvaluator xpathEvaluator) {\n        final Expression expr = xpathExpression.getInternalExpression();\n\n        boolean useRuleChain = true;\n\n        // First step: Split the union venn expressions into single expressions\n        List<Expression> subexpressions = new ArrayList<>();\n        SplitUnions unions = new SplitUnions();\n        unions.visit(expr);\n        if (unions.getExpressions().isEmpty()) {\n            subexpressions.add(expr);\n        } else {\n            subexpressions.addAll(unions.getExpressions());\n        }\n\n        // Second step: Analyze each expression separately\n        for (Expression subexpression : subexpressions) {\n            RuleChainAnalyzer rca = new RuleChainAnalyzer(xpathEvaluator.getConfiguration());\n            Expression modified = rca.visit(subexpression);\n\n            if (rca.getRootElement() != null) {\n                addExpressionForNode(rca.getRootElement(), modified);\n            } else {\n                // couldn't find a root element for the expression, that means, we can't use rule chain at all\n                // even though, it would be possible for part of the expression.\n                useRuleChain = false;\n                break;\n            }\n        }\n\n        if (useRuleChain) {\n            super.ruleChainVisits.addAll(nodeNameToXPaths.keySet());\n        } else {\n            nodeNameToXPaths.clear();\n            if (LOG.isLoggable(Level.FINE)) {\n                LOG.log(Level.FINE, \"Unable to use RuleChain for XPath: \" + xpath);\n            }\n        }\n\n        // always add fallback expression\n        addExpressionForNode(AST_ROOT, xpathExpression.getInternalExpression());\n    }",
        "filePathBefore": "pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/SaxonXPathRuleQuery.java",
        "isPureRefactoring": true,
        "commitId": "20a3c39b4d88b0e5716b9e72880ad91d810d6b04",
        "packageNameBefore": "net.sourceforge.pmd.lang.rule.xpath",
        "classNameBefore": "net.sourceforge.pmd.lang.rule.xpath.SaxonXPathRuleQuery",
        "methodNameBefore": "net.sourceforge.pmd.lang.rule.xpath.SaxonXPathRuleQuery#analyzeXPathForRuleChain",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.rule.xpath.internal.SplitUnions#getExpressions\n methodBody: public List<Expression> getExpressions() {\nreturn expressions;\n}\nmethodSignature: net.sourceforge.pmd.lang.rule.xpath.internal.RuleChainAnalyzer#visit\n methodBody: public Expression visit(AxisExpression e) {\nif(rootElement == null && e.getNodeTest() instanceof NameTest){NameTest test=(NameTest)e.getNodeTest();\nif(test.getPrimitiveType() == Type.ELEMENT && e.getAxis() == Axis.DESCENDANT){rootElement=configuration.getNamePool().getClarkName(test.getFingerprint());\n}if(test.getPrimitiveType() == Type.ELEMENT && e.getAxis() == Axis.CHILD){rootElement=configuration.getNamePool().getClarkName(test.getFingerprint());\n}}return super.visit(e);\n}\nmethodSignature: net.sourceforge.pmd.lang.rule.xpath.internal.SplitUnions#visit\n methodBody: public Expression visit(VennExpression e) {\nif(e.getOperator() == Token.UNION){for(Expression operand: e.getOperands()){if(operand instanceof VennExpression){visit(operand);\n}{expressions.add(operand);\n}}}return e;\n}\nmethodSignature: net.sourceforge.pmd.lang.rule.xpath.SaxonXPathRuleQuery#addExpressionForNode\n methodBody: private void addExpressionForNode(String nodeName, Expression expression) {\nif(!nodeNameToXPaths.containsKey(nodeName)){nodeNameToXPaths.put(nodeName,new LinkedList<Expression>());\n}nodeNameToXPaths.get(nodeName).add(expression);\n}\nmethodSignature: net.sourceforge.pmd.lang.rule.xpath.internal.RuleChainAnalyzer#getRootElement\n methodBody: public String getRootElement() {\nreturn rootElement;\n}",
        "classSignatureBefore": "public class SaxonXPathRuleQuery extends AbstractXPathRuleQuery ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.rule.xpath.SaxonXPathRuleQuery#analyzeXPathForRuleChain"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.rule.xpath.SaxonXPathRuleQuery"
        ],
        "classSignatureBeforeSet": [
            "public class SaxonXPathRuleQuery extends AbstractXPathRuleQuery "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable Changes in the body \n Severe changes",
                "description": "Return expression has been added within the Extract Method mechanics - with non-mapped leaves",
                "mappingState": 2
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.rule.xpath;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\n\nimport net.sourceforge.pmd.RuleContext;\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.ast.xpath.saxon.DocumentNode;\nimport net.sourceforge.pmd.lang.ast.xpath.saxon.ElementNode;\nimport net.sourceforge.pmd.lang.rule.xpath.internal.RuleChainAnalyzer;\nimport net.sourceforge.pmd.lang.rule.xpath.internal.SplitUnions;\nimport net.sourceforge.pmd.lang.xpath.Initializer;\nimport net.sourceforge.pmd.properties.PropertyDescriptor;\n\nimport net.sf.saxon.expr.Expression;\nimport net.sf.saxon.om.Item;\nimport net.sf.saxon.om.NamespaceConstant;\nimport net.sf.saxon.om.SequenceIterator;\nimport net.sf.saxon.om.ValueRepresentation;\nimport net.sf.saxon.sxpath.AbstractStaticContext;\nimport net.sf.saxon.sxpath.IndependentContext;\nimport net.sf.saxon.sxpath.XPathDynamicContext;\nimport net.sf.saxon.sxpath.XPathEvaluator;\nimport net.sf.saxon.sxpath.XPathExpression;\nimport net.sf.saxon.sxpath.XPathStaticContext;\nimport net.sf.saxon.sxpath.XPathVariable;\nimport net.sf.saxon.trans.XPathException;\nimport net.sf.saxon.value.AtomicValue;\nimport net.sf.saxon.value.BigIntegerValue;\nimport net.sf.saxon.value.BooleanValue;\nimport net.sf.saxon.value.DoubleValue;\nimport net.sf.saxon.value.EmptySequence;\nimport net.sf.saxon.value.FloatValue;\nimport net.sf.saxon.value.Int64Value;\nimport net.sf.saxon.value.SequenceExtent;\nimport net.sf.saxon.value.StringValue;\nimport net.sf.saxon.value.UntypedAtomicValue;\nimport net.sf.saxon.value.Value;\n\n/**\n * This is a Saxon based XPathRule query.\n */\npublic class SaxonXPathRuleQuery extends AbstractXPathRuleQuery {\n    /**\n     * Special nodeName that references the root expression.\n     */\n    static final String AST_ROOT = \"_AST_ROOT_\";\n\n    private static final Logger LOG = Logger.getLogger(SaxonXPathRuleQuery.class.getName());\n\n    private static final int MAX_CACHE_SIZE = 20;\n    private static final Map<Node, DocumentNode> CACHE = new LinkedHashMap<Node, DocumentNode>(MAX_CACHE_SIZE) {\n        private static final long serialVersionUID = -7653916493967142443L;\n\n        @Override\n        protected boolean removeEldestEntry(final Map.Entry<Node, DocumentNode> eldest) {\n            return size() > MAX_CACHE_SIZE;\n        }\n    };\n\n    /**\n     * Contains for each nodeName a sub expression, used for implementing rule chain.\n     */\n    Map<String, List<Expression>> nodeNameToXPaths = new HashMap<>();\n\n    /**\n     * Representation of an XPath query, created at {@link #initializeXPathExpression()} using {@link #xpath}.\n     */\n    private XPathExpression xpathExpression;\n\n    /**\n     * Holds the static context later used to match the variables in the dynamic context in\n     * {@link #createDynamicContext(ElementNode)}. Created at {@link #initializeXPathExpression()}\n     * using the properties descriptors in {@link #properties}.\n     */\n    private List<XPathVariable> xpathVariables;\n\n    @Override\n    public boolean isSupportedVersion(String version) {\n        return XPATH_1_0_COMPATIBILITY.equals(version) || XPATH_2_0.equals(version);\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public List<Node> evaluate(final Node node, final RuleContext data) {\n        initializeXPathExpression();\n\n        try {\n            final DocumentNode documentNode = getDocumentNodeForRootNode(node);\n\n            // Map AST Node -> Saxon Node\n            final ElementNode rootElementNode = documentNode.nodeToElementNode.get(node);\n            final XPathDynamicContext xpathDynamicContext = createDynamicContext(rootElementNode);\n\n            final List<ElementNode> nodes = new LinkedList<>();\n            List<Expression> expressions = getXPathExpressionForNodeOrDefault(node.getXPathNodeName());\n            for (Expression expression : expressions) {\n                SequenceIterator iterator = expression.iterate(xpathDynamicContext.getXPathContextObject());\n                Item current = iterator.next();\n                while (current != null) {\n                    nodes.add((ElementNode) current);\n                    current = iterator.next();\n                }\n            }\n\n            /*\n             Map List of Saxon Nodes -> List of AST Nodes, which were detected to match the XPath expression\n             (i.e. violation found)\n              */\n            final List<Node> results = new ArrayList<>(nodes.size());\n            for (final ElementNode elementNode : nodes) {\n                results.add((Node) elementNode.getUnderlyingNode());\n            }\n            Collections.sort(results, RuleChainAnalyzer.documentOrderComparator());\n            return results;\n        } catch (final XPathException e) {\n            throw new RuntimeException(super.xpath + \" had problem: \" + e.getMessage(), e);\n        }\n    }\n\n    private List<Expression> getXPathExpressionForNodeOrDefault(String nodeName) {\n        if (nodeNameToXPaths.containsKey(nodeName)) {\n            return nodeNameToXPaths.get(nodeName);\n        }\n        return nodeNameToXPaths.get(AST_ROOT);\n    }\n\n    /**\n     * Attempt to create a dynamic context on which to evaluate the {@link #xpathExpression}.\n     *\n     * @param elementNode the node on which to create the context; generally this node is the root node of the Saxon\n     *                    Tree\n     * @return the dynamic context on which to run the query\n     * @throws XPathException if the supplied value does not conform to the required type of the\n     * variable, when setting up the dynamic context; or if the supplied value contains a node that does not belong to\n     * this Configuration (or another Configuration that shares the same namePool)\n     */\n    private XPathDynamicContext createDynamicContext(final ElementNode elementNode) throws XPathException {\n        final XPathDynamicContext dynamicContext = xpathExpression.createDynamicContext(elementNode);\n\n        // Set variable values on the dynamic context\n        for (final XPathVariable xpathVariable : xpathVariables) {\n            final String variableName = xpathVariable.getVariableQName().getLocalName();\n            for (final Map.Entry<PropertyDescriptor<?>, Object> entry : super.properties.entrySet()) {\n                if (variableName.equals(entry.getKey().name())) {\n                    final ValueRepresentation valueRepresentation = getRepresentation(entry.getKey(), entry.getValue());\n                    dynamicContext.setVariable(xpathVariable, valueRepresentation);\n                }\n            }\n        }\n        return dynamicContext;\n    }\n\n\n    private ValueRepresentation getRepresentation(final PropertyDescriptor<?> descriptor, final Object value) {\n        if (descriptor.isMultiValue()) {\n            return getSequenceRepresentation((List<?>) value);\n        } else {\n            return getAtomicRepresentation(value);\n        }\n    }\n\n    /**\n     * Gets the DocumentNode representation for the whole AST in which the node is, that is, if the node is not the root\n     * of the AST, then the AST is traversed all the way up until the root node is found. If the DocumentNode was\n     * cached because this method was previously called, then a new DocumentNode will not be instanced.\n     *\n     * @param node the node from which the root node will be looked for.\n     * @return the DocumentNode representing the whole AST\n     */\n    private DocumentNode getDocumentNodeForRootNode(final Node node) {\n        final Node root = getRootNode(node);\n\n        DocumentNode documentNode;\n        synchronized (CACHE) {\n            documentNode = CACHE.get(root);\n            if (documentNode == null) {\n                documentNode = new DocumentNode(root);\n                CACHE.put(root, documentNode);\n            }\n        }\n        return documentNode;\n    }\n\n    /**\n     * Traverse the AST until the root node is found.\n     *\n     * @param node the node from where to start traversing the tree\n     * @return the root node\n     */\n    private Node getRootNode(final Node node) {\n        Node root = node;\n        while (root.getParent() != null) {\n            root = root.getParent();\n        }\n        return root;\n    }\n\n    private void addExpressionForNode(String nodeName, Expression expression) {\n        if (!nodeNameToXPaths.containsKey(nodeName)) {\n            nodeNameToXPaths.put(nodeName, new LinkedList<Expression>());\n        }\n        nodeNameToXPaths.get(nodeName).add(expression);\n    }\n\n    /**\n     * Initialize the {@link #xpathExpression} and the {@link #xpathVariables}.\n     */\n    private void initializeXPathExpression() {\n        if (xpathExpression != null) {\n            return;\n        }\n        try {\n            final XPathEvaluator xpathEvaluator = new XPathEvaluator();\n            final XPathStaticContext xpathStaticContext = xpathEvaluator.getStaticContext();\n\n            // Enable XPath 1.0 compatibility\n            if (XPATH_1_0_COMPATIBILITY.equals(version)) {\n                ((AbstractStaticContext) xpathStaticContext).setBackwardsCompatibilityMode(true);\n            }\n\n            ((IndependentContext) xpathEvaluator.getStaticContext()).declareNamespace(\"fn\", NamespaceConstant.FN);\n\n            // Register PMD functions\n            Initializer.initialize((IndependentContext) xpathStaticContext);\n\n            /*\n            Create XPathVariables for later use. It is a Saxon quirk that XPathVariables must be defined on the\n            static context, and reused later to associate an actual value on the dynamic context creation, in\n            createDynamicContext(ElementNode).\n            */\n            xpathVariables = new ArrayList<>();\n            for (final PropertyDescriptor<?> propertyDescriptor : super.properties.keySet()) {\n                final String name = propertyDescriptor.name();\n                if (!\"xpath\".equals(name)) {\n                    final XPathVariable xpathVariable = xpathStaticContext.declareVariable(null, name);\n                    xpathVariables.add(xpathVariable);\n                }\n            }\n\n            xpathExpression = xpathEvaluator.createExpression(super.xpath);\n            analyzeXPathForRuleChain(xpathEvaluator);\n        } catch (final XPathException e) {\n            throw new RuntimeException(e);\n        }\n    }\n    \n    private void analyzeXPathForRuleChain(final XPathEvaluator xpathEvaluator) {\n        final Expression expr = xpathExpression.getInternalExpression();\n\n        boolean useRuleChain = true;\n\n        // First step: Split the union venn expressions into single expressions\n        List<Expression> subexpressions = new ArrayList<>();\n        SplitUnions unions = new SplitUnions();\n        unions.visit(expr);\n        if (unions.getExpressions().isEmpty()) {\n            subexpressions.add(expr);\n        } else {\n            subexpressions.addAll(unions.getExpressions());\n        }\n\n        // Second step: Analyze each expression separately\n        for (Expression subexpression : subexpressions) {\n            RuleChainAnalyzer rca = new RuleChainAnalyzer(xpathEvaluator.getConfiguration());\n            Expression modified = rca.visit(subexpression);\n\n            if (rca.getRootElement() != null) {\n                addExpressionForNode(rca.getRootElement(), modified);\n            } else {\n                // couldn't find a root element for the expression, that means, we can't use rule chain at all\n                // even though, it would be possible for part of the expression.\n                useRuleChain = false;\n                break;\n            }\n        }\n\n        if (useRuleChain) {\n            super.ruleChainVisits.addAll(nodeNameToXPaths.keySet());\n        } else {\n            nodeNameToXPaths.clear();\n            if (LOG.isLoggable(Level.FINE)) {\n                LOG.log(Level.FINE, \"Unable to use RuleChain for XPath: \" + xpath);\n            }\n        }\n\n        // always add fallback expression\n        addExpressionForNode(AST_ROOT, xpathExpression.getInternalExpression());\n    }\n\n    /**\n     * Gets the Saxon representation of the parameter, if its type corresponds\n     * to an XPath 2.0 atomic datatype.\n     *\n     * @param value The value to convert\n     *\n     * @return The converted AtomicValue\n     */\n    public static AtomicValue getAtomicRepresentation(final Object value) {\n\n        /*\n        FUTURE When supported, we should consider refactor this implementation to use Pattern Matching\n        (see http://openjdk.java.net/jeps/305) so that it looks clearer.\n        */\n        if (value == null) {\n            return UntypedAtomicValue.ZERO_LENGTH_UNTYPED;\n        } else if (value instanceof Enum) {\n            // enums use their toString\n            return new StringValue(value.toString());\n        } else if (value instanceof String) {\n            return new StringValue((String) value);\n        } else if (value instanceof Boolean) {\n            return BooleanValue.get((Boolean) value);\n        } else if (value instanceof Integer) {\n            return Int64Value.makeIntegerValue((Integer) value);\n        } else if (value instanceof Long) {\n            return new BigIntegerValue((Long) value);\n        } else if (value instanceof Double) {\n            return new DoubleValue((Double) value);\n        } else if (value instanceof Character) {\n            return new StringValue(value.toString());\n        } else if (value instanceof Float) {\n            return new FloatValue((Float) value);\n        } else if (value instanceof Pattern) {\n            return new StringValue(String.valueOf(value));\n        } else {\n            // We could maybe use UntypedAtomicValue\n            throw new RuntimeException(\"Unable to create ValueRepresentation for value of type: \" + value.getClass());\n        }\n    }\n\n    public static Value getSequenceRepresentation(List<?> list) {\n        if (list == null || list.isEmpty()) {\n            return EmptySequence.getInstance();\n        }\n        final Item[] converted = new Item[list.size()];\n        for (int i = 0; i < list.size(); i++) {\n            converted[i] = getAtomicRepresentation(list.get(i));\n        }\n        return new SequenceExtent(converted);\n    }\n\n    @Override\n    public List<String> getRuleChainVisits() {\n        initializeXPathExpression();\n        return super.getRuleChainVisits();\n    }\n}\n",
        "filePathAfter": "pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/SaxonXPathRuleQuery.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.rule.xpath;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\n\nimport net.sourceforge.pmd.RuleContext;\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.ast.xpath.saxon.DocumentNode;\nimport net.sourceforge.pmd.lang.ast.xpath.saxon.ElementNode;\nimport net.sourceforge.pmd.lang.rule.xpath.internal.RuleChainAnalyzer;\nimport net.sourceforge.pmd.lang.xpath.Initializer;\nimport net.sourceforge.pmd.properties.PropertyDescriptor;\n\nimport net.sf.saxon.expr.Expression;\nimport net.sf.saxon.om.Item;\nimport net.sf.saxon.om.NamespaceConstant;\nimport net.sf.saxon.om.SequenceIterator;\nimport net.sf.saxon.om.ValueRepresentation;\nimport net.sf.saxon.sxpath.AbstractStaticContext;\nimport net.sf.saxon.sxpath.IndependentContext;\nimport net.sf.saxon.sxpath.XPathDynamicContext;\nimport net.sf.saxon.sxpath.XPathEvaluator;\nimport net.sf.saxon.sxpath.XPathExpression;\nimport net.sf.saxon.sxpath.XPathStaticContext;\nimport net.sf.saxon.sxpath.XPathVariable;\nimport net.sf.saxon.trans.XPathException;\nimport net.sf.saxon.value.AtomicValue;\nimport net.sf.saxon.value.BigIntegerValue;\nimport net.sf.saxon.value.BooleanValue;\nimport net.sf.saxon.value.DoubleValue;\nimport net.sf.saxon.value.EmptySequence;\nimport net.sf.saxon.value.FloatValue;\nimport net.sf.saxon.value.Int64Value;\nimport net.sf.saxon.value.SequenceExtent;\nimport net.sf.saxon.value.StringValue;\nimport net.sf.saxon.value.UntypedAtomicValue;\nimport net.sf.saxon.value.Value;\n\n/**\n * This is a Saxon based XPathRule query.\n */\npublic class SaxonXPathRuleQuery extends AbstractXPathRuleQuery {\n    /**\n     * Special nodeName that references the root expression.\n     */\n    static final String AST_ROOT = \"_AST_ROOT_\";\n\n    private static final Logger LOG = Logger.getLogger(SaxonXPathRuleQuery.class.getName());\n\n    private static final int MAX_CACHE_SIZE = 20;\n    private static final Map<Node, DocumentNode> CACHE = new LinkedHashMap<Node, DocumentNode>(MAX_CACHE_SIZE) {\n        private static final long serialVersionUID = -7653916493967142443L;\n\n        @Override\n        protected boolean removeEldestEntry(final Map.Entry<Node, DocumentNode> eldest) {\n            return size() > MAX_CACHE_SIZE;\n        }\n    };\n\n    /**\n     * Contains for each nodeName a sub expression, used for implementing rule chain.\n     */\n    Map<String, List<Expression>> nodeNameToXPaths = new HashMap<>();\n\n    /**\n     * Representation of an XPath query, created at {@link #initializeXPathExpression()} using {@link #xpath}.\n     */\n    private XPathExpression xpathExpression;\n\n    /**\n     * Holds the static context later used to match the variables in the dynamic context in\n     * {@link #createDynamicContext(ElementNode)}. Created at {@link #initializeXPathExpression()}\n     * using the properties descriptors in {@link #properties}.\n     */\n    private List<XPathVariable> xpathVariables;\n\n    @Override\n    public boolean isSupportedVersion(String version) {\n        return XPATH_1_0_COMPATIBILITY.equals(version) || XPATH_2_0.equals(version);\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public List<Node> evaluate(final Node node, final RuleContext data) {\n        initializeXPathExpression();\n\n        try {\n            final DocumentNode documentNode = getDocumentNodeForRootNode(node);\n\n            // Map AST Node -> Saxon Node\n            final ElementNode rootElementNode = documentNode.nodeToElementNode.get(node);\n            final XPathDynamicContext xpathDynamicContext = createDynamicContext(rootElementNode);\n\n            final List<ElementNode> nodes = new LinkedList<>();\n            List<Expression> expressions = getXPathExpressionForNodeOrDefault(node.getXPathNodeName());\n            for (Expression expression : expressions) {\n                SequenceIterator iterator = expression.iterate(xpathDynamicContext.getXPathContextObject());\n                Item current = iterator.next();\n                while (current != null) {\n                    nodes.add((ElementNode) current);\n                    current = iterator.next();\n                }\n            }\n\n            /*\n             Map List of Saxon Nodes -> List of AST Nodes, which were detected to match the XPath expression\n             (i.e. violation found)\n              */\n            final List<Node> results = new ArrayList<>(nodes.size());\n            for (final ElementNode elementNode : nodes) {\n                results.add((Node) elementNode.getUnderlyingNode());\n            }\n            Collections.sort(results, RuleChainAnalyzer.documentOrderComparator());\n            return results;\n        } catch (final XPathException e) {\n            throw new RuntimeException(super.xpath + \" had problem: \" + e.getMessage(), e);\n        }\n    }\n\n    private List<Expression> getXPathExpressionForNodeOrDefault(String nodeName) {\n        if (nodeNameToXPaths.containsKey(nodeName)) {\n            return nodeNameToXPaths.get(nodeName);\n        }\n        return nodeNameToXPaths.get(AST_ROOT);\n    }\n\n    /**\n     * Attempt to create a dynamic context on which to evaluate the {@link #xpathExpression}.\n     *\n     * @param elementNode the node on which to create the context; generally this node is the root node of the Saxon\n     *                    Tree\n     * @return the dynamic context on which to run the query\n     * @throws XPathException if the supplied value does not conform to the required type of the\n     * variable, when setting up the dynamic context; or if the supplied value contains a node that does not belong to\n     * this Configuration (or another Configuration that shares the same namePool)\n     */\n    private XPathDynamicContext createDynamicContext(final ElementNode elementNode) throws XPathException {\n        final XPathDynamicContext dynamicContext = xpathExpression.createDynamicContext(elementNode);\n\n        // Set variable values on the dynamic context\n        for (final XPathVariable xpathVariable : xpathVariables) {\n            final String variableName = xpathVariable.getVariableQName().getLocalName();\n            for (final Map.Entry<PropertyDescriptor<?>, Object> entry : super.properties.entrySet()) {\n                if (variableName.equals(entry.getKey().name())) {\n                    final ValueRepresentation valueRepresentation = getRepresentation(entry.getKey(), entry.getValue());\n                    dynamicContext.setVariable(xpathVariable, valueRepresentation);\n                }\n            }\n        }\n        return dynamicContext;\n    }\n\n\n    private ValueRepresentation getRepresentation(final PropertyDescriptor<?> descriptor, final Object value) {\n        if (descriptor.isMultiValue()) {\n            return getSequenceRepresentation((List<?>) value);\n        } else {\n            return getAtomicRepresentation(value);\n        }\n    }\n\n    /**\n     * Gets the DocumentNode representation for the whole AST in which the node is, that is, if the node is not the root\n     * of the AST, then the AST is traversed all the way up until the root node is found. If the DocumentNode was\n     * cached because this method was previously called, then a new DocumentNode will not be instanced.\n     *\n     * @param node the node from which the root node will be looked for.\n     * @return the DocumentNode representing the whole AST\n     */\n    private DocumentNode getDocumentNodeForRootNode(final Node node) {\n        final Node root = getRootNode(node);\n\n        DocumentNode documentNode;\n        synchronized (CACHE) {\n            documentNode = CACHE.get(root);\n            if (documentNode == null) {\n                documentNode = new DocumentNode(root);\n                CACHE.put(root, documentNode);\n            }\n        }\n        return documentNode;\n    }\n\n    /**\n     * Traverse the AST until the root node is found.\n     *\n     * @param node the node from where to start traversing the tree\n     * @return the root node\n     */\n    private Node getRootNode(final Node node) {\n        Node root = node;\n        while (root.getParent() != null) {\n            root = root.getParent();\n        }\n        return root;\n    }\n\n    private void addExpressionForNode(String nodeName, Expression expression) {\n        if (!nodeNameToXPaths.containsKey(nodeName)) {\n            nodeNameToXPaths.put(nodeName, new LinkedList<Expression>());\n        }\n        nodeNameToXPaths.get(nodeName).add(expression);\n    }\n\n    /**\n     * Initialize the {@link #xpathExpression} and the {@link #xpathVariables}.\n     */\n    private void initializeXPathExpression() {\n        if (xpathExpression != null) {\n            return;\n        }\n        try {\n            final XPathEvaluator xpathEvaluator = new XPathEvaluator();\n            final XPathStaticContext xpathStaticContext = xpathEvaluator.getStaticContext();\n\n            // Enable XPath 1.0 compatibility\n            if (XPATH_1_0_COMPATIBILITY.equals(version)) {\n                ((AbstractStaticContext) xpathStaticContext).setBackwardsCompatibilityMode(true);\n            }\n\n            ((IndependentContext) xpathEvaluator.getStaticContext()).declareNamespace(\"fn\", NamespaceConstant.FN);\n\n            // Register PMD functions\n            Initializer.initialize((IndependentContext) xpathStaticContext);\n\n            /*\n            Create XPathVariables for later use. It is a Saxon quirk that XPathVariables must be defined on the\n            static context, and reused later to associate an actual value on the dynamic context creation, in\n            createDynamicContext(ElementNode).\n            */\n            xpathVariables = new ArrayList<>();\n            for (final PropertyDescriptor<?> propertyDescriptor : super.properties.keySet()) {\n                final String name = propertyDescriptor.name();\n                if (!\"xpath\".equals(name)) {\n                    final XPathVariable xpathVariable = xpathStaticContext.declareVariable(null, name);\n                    xpathVariables.add(xpathVariable);\n                }\n            }\n\n            xpathExpression = xpathEvaluator.createExpression(super.xpath);\n            analyzeXPathForRuleChain(xpathEvaluator);\n        } catch (final XPathException e) {\n            throw new RuntimeException(e);\n        }\n    }\n    \n    private void analyzeXPathForRuleChain(final XPathEvaluator xpathEvaluator) {\n        final Expression expr = xpathExpression.getInternalExpression();\n\n        boolean useRuleChain = true;\n\n        // First step: Split the union venn expressions into single expressions\n        Iterable<Expression> subexpressions = RuleChainAnalyzer.splitUnions(expr);\n\n        // Second step: Analyze each expression separately\n        for (Expression subexpression : subexpressions) {\n            RuleChainAnalyzer rca = new RuleChainAnalyzer(xpathEvaluator.getConfiguration());\n            Expression modified = rca.visit(subexpression);\n\n            if (rca.getRootElement() != null) {\n                addExpressionForNode(rca.getRootElement(), modified);\n            } else {\n                // couldn't find a root element for the expression, that means, we can't use rule chain at all\n                // even though, it would be possible for part of the expression.\n                useRuleChain = false;\n                break;\n            }\n        }\n\n        if (useRuleChain) {\n            super.ruleChainVisits.addAll(nodeNameToXPaths.keySet());\n        } else {\n            nodeNameToXPaths.clear();\n            if (LOG.isLoggable(Level.FINE)) {\n                LOG.log(Level.FINE, \"Unable to use RuleChain for XPath: \" + xpath);\n            }\n        }\n\n        // always add fallback expression\n        addExpressionForNode(AST_ROOT, xpathExpression.getInternalExpression());\n    }\n\n    /**\n     * Gets the Saxon representation of the parameter, if its type corresponds\n     * to an XPath 2.0 atomic datatype.\n     *\n     * @param value The value to convert\n     *\n     * @return The converted AtomicValue\n     */\n    public static AtomicValue getAtomicRepresentation(final Object value) {\n\n        /*\n        FUTURE When supported, we should consider refactor this implementation to use Pattern Matching\n        (see http://openjdk.java.net/jeps/305) so that it looks clearer.\n        */\n        if (value == null) {\n            return UntypedAtomicValue.ZERO_LENGTH_UNTYPED;\n        } else if (value instanceof Enum) {\n            // enums use their toString\n            return new StringValue(value.toString());\n        } else if (value instanceof String) {\n            return new StringValue((String) value);\n        } else if (value instanceof Boolean) {\n            return BooleanValue.get((Boolean) value);\n        } else if (value instanceof Integer) {\n            return Int64Value.makeIntegerValue((Integer) value);\n        } else if (value instanceof Long) {\n            return new BigIntegerValue((Long) value);\n        } else if (value instanceof Double) {\n            return new DoubleValue((Double) value);\n        } else if (value instanceof Character) {\n            return new StringValue(value.toString());\n        } else if (value instanceof Float) {\n            return new FloatValue((Float) value);\n        } else if (value instanceof Pattern) {\n            return new StringValue(String.valueOf(value));\n        } else {\n            // We could maybe use UntypedAtomicValue\n            throw new RuntimeException(\"Unable to create ValueRepresentation for value of type: \" + value.getClass());\n        }\n    }\n\n    public static Value getSequenceRepresentation(List<?> list) {\n        if (list == null || list.isEmpty()) {\n            return EmptySequence.getInstance();\n        }\n        final Item[] converted = new Item[list.size()];\n        for (int i = 0; i < list.size(); i++) {\n            converted[i] = getAtomicRepresentation(list.get(i));\n        }\n        return new SequenceExtent(converted);\n    }\n\n    @Override\n    public List<String> getRuleChainVisits() {\n        initializeXPathExpression();\n        return super.getRuleChainVisits();\n    }\n}\n",
        "diffSourceCodeSet": [
            "final ElementNode rootElementNode = documentNode.nodeToElementNode.get(node);\n            final XPathDynamicContext xpathDynamicContext = createDynamicContext(rootElementNode);\n\n            final List<ElementNode> nodes = new LinkedList<>();\n            List<Expression> expressions = getXPathExpressionForNodeOrDefault(node.getXPathNodeName());\n            for (Expression expression : expressions) {\n                SequenceIterator iterator = expression.iterate(xpathDynamicContext.getXPathContextObject());\n                Item current = iterator.next();\n                while (current != null) {\n                    nodes.add((ElementNode) current);\n                    current = iterator.next();\n                }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.rule.xpath.internal.SplitUnions#getExpressions\n methodBody: public List<Expression> getExpressions() {\nreturn expressions;\n}",
            "methodSignature: net.sourceforge.pmd.lang.rule.xpath.internal.RuleChainAnalyzer#visit\n methodBody: public Expression visit(AxisExpression e) {\nif(rootElement == null && e.getNodeTest() instanceof NameTest){NameTest test=(NameTest)e.getNodeTest();\nif(test.getPrimitiveType() == Type.ELEMENT && e.getAxis() == Axis.DESCENDANT){rootElement=configuration.getNamePool().getClarkName(test.getFingerprint());\n}if(test.getPrimitiveType() == Type.ELEMENT && e.getAxis() == Axis.CHILD){rootElement=configuration.getNamePool().getClarkName(test.getFingerprint());\n}}return super.visit(e);\n}",
            "methodSignature: net.sourceforge.pmd.lang.rule.xpath.internal.SplitUnions#visit\n methodBody: public Expression visit(VennExpression e) {\nif(e.getOperator() == Token.UNION){for(Expression operand: e.getOperands()){if(operand instanceof VennExpression){visit(operand);\n}{expressions.add(operand);\n}}}return e;\n}",
            "methodSignature: net.sourceforge.pmd.lang.rule.xpath.SaxonXPathRuleQuery#addExpressionForNode\n methodBody: private void addExpressionForNode(String nodeName, Expression expression) {\nif(!nodeNameToXPaths.containsKey(nodeName)){nodeNameToXPaths.put(nodeName,new LinkedList<Expression>());\n}nodeNameToXPaths.get(nodeName).add(expression);\n}",
            "methodSignature: net.sourceforge.pmd.lang.rule.xpath.internal.RuleChainAnalyzer#getRootElement\n methodBody: public String getRootElement() {\nreturn rootElement;\n}"
        ],
        "sourceCodeAfterRefactoring": "private void analyzeXPathForRuleChain(final XPathEvaluator xpathEvaluator) {\n        final Expression expr = xpathExpression.getInternalExpression();\n\n        boolean useRuleChain = true;\n\n        // First step: Split the union venn expressions into single expressions\n        Iterable<Expression> subexpressions = RuleChainAnalyzer.splitUnions(expr);\n\n        // Second step: Analyze each expression separately\n        for (Expression subexpression : subexpressions) {\n            RuleChainAnalyzer rca = new RuleChainAnalyzer(xpathEvaluator.getConfiguration());\n            Expression modified = rca.visit(subexpression);\n\n            if (rca.getRootElement() != null) {\n                addExpressionForNode(rca.getRootElement(), modified);\n            } else {\n                // couldn't find a root element for the expression, that means, we can't use rule chain at all\n                // even though, it would be possible for part of the expression.\n                useRuleChain = false;\n                break;\n            }\n        }\n\n        if (useRuleChain) {\n            super.ruleChainVisits.addAll(nodeNameToXPaths.keySet());\n        } else {\n            nodeNameToXPaths.clear();\n            if (LOG.isLoggable(Level.FINE)) {\n                LOG.log(Level.FINE, \"Unable to use RuleChain for XPath: \" + xpath);\n            }\n        }\n\n        // always add fallback expression\n        addExpressionForNode(AST_ROOT, xpathExpression.getInternalExpression());\n    }\nfinal ElementNode rootElementNode = documentNode.nodeToElementNode.get(node);\n            final XPathDynamicContext xpathDynamicContext = createDynamicContext(rootElementNode);\n\n            final List<ElementNode> nodes = new LinkedList<>();\n            List<Expression> expressions = getXPathExpressionForNodeOrDefault(node.getXPathNodeName());\n            for (Expression expression : expressions) {\n                SequenceIterator iterator = expression.iterate(xpathDynamicContext.getXPathContextObject());\n                Item current = iterator.next();\n                while (current != null) {\n                    nodes.add((ElementNode) current);\n                    current = iterator.next();\n                }",
        "diffSourceCode": "-  103:             // Map AST Node -> Saxon Node\n-  104:             final ElementNode rootElementNode = documentNode.nodeToElementNode.get(node);\n-  105:             final XPathDynamicContext xpathDynamicContext = createDynamicContext(rootElementNode);\n-  106: \n-  107:             final List<ElementNode> nodes = new LinkedList<>();\n-  108:             List<Expression> expressions = getXPathExpressionForNodeOrDefault(node.getXPathNodeName());\n-  109:             for (Expression expression : expressions) {\n-  110:                 SequenceIterator iterator = expression.iterate(xpathDynamicContext.getXPathContextObject());\n-  111:                 Item current = iterator.next();\n-  112:                 while (current != null) {\n-  113:                     nodes.add((ElementNode) current);\n-  114:                     current = iterator.next();\n-  259:     \n-  260:     private void analyzeXPathForRuleChain(final XPathEvaluator xpathEvaluator) {\n-  261:         final Expression expr = xpathExpression.getInternalExpression();\n-  262: \n-  263:         boolean useRuleChain = true;\n-  264: \n-  265:         // First step: Split the union venn expressions into single expressions\n-  266:         List<Expression> subexpressions = new ArrayList<>();\n-  267:         SplitUnions unions = new SplitUnions();\n-  268:         unions.visit(expr);\n-  269:         if (unions.getExpressions().isEmpty()) {\n-  270:             subexpressions.add(expr);\n-  271:         } else {\n-  272:             subexpressions.addAll(unions.getExpressions());\n-  273:         }\n-  274: \n-  275:         // Second step: Analyze each expression separately\n-  276:         for (Expression subexpression : subexpressions) {\n-  277:             RuleChainAnalyzer rca = new RuleChainAnalyzer(xpathEvaluator.getConfiguration());\n-  278:             Expression modified = rca.visit(subexpression);\n-  279: \n-  280:             if (rca.getRootElement() != null) {\n-  281:                 addExpressionForNode(rca.getRootElement(), modified);\n-  282:             } else {\n-  283:                 // couldn't find a root element for the expression, that means, we can't use rule chain at all\n-  284:                 // even though, it would be possible for part of the expression.\n-  285:                 useRuleChain = false;\n-  286:                 break;\n-  287:             }\n-  288:         }\n-  289: \n-  290:         if (useRuleChain) {\n-  291:             super.ruleChainVisits.addAll(nodeNameToXPaths.keySet());\n-  292:         } else {\n-  293:             nodeNameToXPaths.clear();\n-  294:             if (LOG.isLoggable(Level.FINE)) {\n-  295:                 LOG.log(Level.FINE, \"Unable to use RuleChain for XPath: \" + xpath);\n-  296:             }\n-  297:         }\n-  298: \n-  299:         // always add fallback expression\n-  300:         addExpressionForNode(AST_ROOT, xpathExpression.getInternalExpression());\n-  301:     }\n+  103:             final ElementNode rootElementNode = documentNode.nodeToElementNode.get(node);\n+  104:             final XPathDynamicContext xpathDynamicContext = createDynamicContext(rootElementNode);\n+  105: \n+  106:             final List<ElementNode> nodes = new LinkedList<>();\n+  107:             List<Expression> expressions = getXPathExpressionForNodeOrDefault(node.getXPathNodeName());\n+  108:             for (Expression expression : expressions) {\n+  109:                 SequenceIterator iterator = expression.iterate(xpathDynamicContext.getXPathContextObject());\n+  110:                 Item current = iterator.next();\n+  111:                 while (current != null) {\n+  112:                     nodes.add((ElementNode) current);\n+  113:                     current = iterator.next();\n+  114:                 }\n+  259:     private void analyzeXPathForRuleChain(final XPathEvaluator xpathEvaluator) {\n+  260:         final Expression expr = xpathExpression.getInternalExpression();\n+  261: \n+  262:         boolean useRuleChain = true;\n+  263: \n+  264:         // First step: Split the union venn expressions into single expressions\n+  265:         Iterable<Expression> subexpressions = RuleChainAnalyzer.splitUnions(expr);\n+  266: \n+  267:         // Second step: Analyze each expression separately\n+  268:         for (Expression subexpression : subexpressions) {\n+  269:             RuleChainAnalyzer rca = new RuleChainAnalyzer(xpathEvaluator.getConfiguration());\n+  270:             Expression modified = rca.visit(subexpression);\n+  271: \n+  272:             if (rca.getRootElement() != null) {\n+  273:                 addExpressionForNode(rca.getRootElement(), modified);\n+  274:             } else {\n+  275:                 // couldn't find a root element for the expression, that means, we can't use rule chain at all\n+  276:                 // even though, it would be possible for part of the expression.\n+  277:                 useRuleChain = false;\n+  278:                 break;\n+  279:             }\n+  280:         }\n+  281: \n+  282:         if (useRuleChain) {\n+  283:             super.ruleChainVisits.addAll(nodeNameToXPaths.keySet());\n+  284:         } else {\n+  285:             nodeNameToXPaths.clear();\n+  286:             if (LOG.isLoggable(Level.FINE)) {\n+  287:                 LOG.log(Level.FINE, \"Unable to use RuleChain for XPath: \" + xpath);\n+  288:             }\n+  289:         }\n+  290: \n+  291:         // always add fallback expression\n+  292:         addExpressionForNode(AST_ROOT, xpathExpression.getInternalExpression());\n+  293:     }\n+  294: \n+  295:     /**\n+  296:      * Gets the Saxon representation of the parameter, if its type corresponds\n+  297:      * to an XPath 2.0 atomic datatype.\n+  298:      *\n+  299:      * @param value The value to convert\n+  300:      *\n+  301:      * @return The converted AtomicValue\n",
        "uniqueId": "20a3c39b4d88b0e5716b9e72880ad91d810d6b04_260_301_103_114_259_293",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 22,
                "covered": 79
            },
            "BRANCH": {
                "missed": 4,
                "covered": 6
            },
            "LINE": {
                "missed": 5,
                "covered": 18
            },
            "COMPLEXITY": {
                "missed": 3,
                "covered": 3
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprotected getCachedMethodResults(simpleName String) : List<JMethodSymbol> extracted from public resolveMethodName(simpleName String) : Stream<JMethodSymbol> in class net.sourceforge.pmd.lang.java.symbols.table.internal.AbstractSymbolTable",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/AbstractSymbolTable.java",
                "startLine": 65,
                "endLine": 75,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/AbstractSymbolTable.java",
                "startLine": 65,
                "endLine": 85,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/AbstractSymbolTable.java",
                "startLine": 100,
                "endLine": 103,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n    public final Stream<JMethodSymbol> resolveMethodName(String simpleName) {\n        // This allows the stream contributed by the parent to be resolved lazily,\n        // ie not evaluated unless the stream contributed by this table runs out of values,\n        // a behaviour that Stream.concat can't provide\n\n        return Stream.<Supplier<Stream<JMethodSymbol>>>of(\n            () -> resolveMethodNameImpl(simpleName),\n            () -> parent.resolveMethodName(simpleName)\n        ).flatMap(Supplier::get);\n    }",
        "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/AbstractSymbolTable.java",
        "isPureRefactoring": true,
        "commitId": "946df6fc07c39b98599a4e0548ccc9aec3c7c5da",
        "packageNameBefore": "net.sourceforge.pmd.lang.java.symbols.table.internal",
        "classNameBefore": "net.sourceforge.pmd.lang.java.symbols.table.internal.AbstractSymbolTable",
        "methodNameBefore": "net.sourceforge.pmd.lang.java.symbols.table.internal.AbstractSymbolTable#resolveMethodName",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.java.symbols.table.internal.AbstractSymbolTable#resolveMethodName\n methodBody: public final Stream<JMethodSymbol> resolveMethodName(String simpleName) {\nreturn Stream.<Supplier<Stream<JMethodSymbol>>>of(() -> resolveMethodNameImpl(simpleName),() -> parent.resolveMethodName(simpleName)).flatMap(Supplier::get);\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.table.JSymbolTable#resolveMethodName\n methodBody: Stream<JMethodSymbol> resolveMethodName(String simpleName);\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.table.internal.TypeMemberSymTable#resolveMethodNameImpl\n methodBody: protected Stream<JMethodSymbol> resolveMethodNameImpl(String simpleName) {\nif(simpleName.equals(JConstructorSymbol.CTOR_NAME)){return Stream.empty();\n}return typeSym.getDeclaredMethods(simpleName).stream();\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.table.internal.AbstractSymbolTable#resolveMethodNameImpl\n methodBody: protected Stream<JMethodSymbol> resolveMethodNameImpl(String simpleName) {\nreturn Stream.empty();\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.table.internal.AbstractImportSymbolTable#resolveMethodNameImpl\n methodBody: protected Stream<JMethodSymbol> resolveMethodNameImpl(String simpleName) {\nreturn importedStaticMethods.getOrDefault(simpleName,Collections.emptyList()).stream();\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.table.internal.EmptySymbolTable#resolveMethodName\n methodBody: public Stream<JMethodSymbol> resolveMethodName(String simpleName) {\nreturn Stream.empty();\n}",
        "classSignatureBefore": "abstract class AbstractSymbolTable implements JSymbolTable ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.symbols.table.internal.AbstractSymbolTable#resolveMethodName"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.symbols.table.internal.AbstractSymbolTable"
        ],
        "classSignatureBeforeSet": [
            "abstract class AbstractSymbolTable implements JSymbolTable "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.symbols.table.internal;\n\nimport java.util.function.Supplier;\nimport java.util.stream.Stream;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration;\nimport net.sourceforge.pmd.lang.java.symbols.JClassSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JTypeDeclSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.table.JSymbolTable;\nimport net.sourceforge.pmd.lang.java.symbols.table.ResolveResult;\n\n\n/**\n * Base implementation.\n *\n * @since 7.0.0\n */\nabstract class AbstractSymbolTable implements JSymbolTable {\n\n    /** Additional info about the context. */\n    protected final SymbolTableHelper helper;\n    private final JSymbolTable parent;\n\n    AbstractSymbolTable(JSymbolTable parent, SymbolTableHelper helper) {\n        assert parent != null : \"Null parent!\";\n        assert helper != null : \"Null helper!\";\n\n        this.parent = parent;\n        this.helper = helper;\n    }\n\n\n    @Override\n    @NonNull\n    public final JSymbolTable getParent() {\n        return parent;\n    }\n\n\n    @Nullable\n    @Override\n    public final ResolveResult<JTypeDeclSymbol> resolveTypeName(String simpleName) {\n        @Nullable ResolveResult<JTypeDeclSymbol> result = resolveTypeNameImpl(simpleName);\n        return result != null ? result : parent.resolveTypeName(simpleName);\n    }\n\n\n    @Nullable\n    @Override\n    public final ResolveResult<JVariableSymbol> resolveValueName(String simpleName) {\n        @Nullable ResolveResult<JVariableSymbol> result = resolveValueNameImpl(simpleName);\n        return result != null ? result : parent.resolveValueName(simpleName);\n    }\n\n\n    @Override\n    public final Stream<JMethodSymbol> resolveMethodName(String simpleName) {\n        // This allows the stream contributed by the parent to be resolved lazily,\n        // ie not evaluated unless the stream contributed by this table runs out of values,\n        // a behaviour that Stream.concat can't provide\n\n        return Stream.<Supplier<Stream<JMethodSymbol>>>of(\n            () -> resolveMethodNameImpl(simpleName),\n            () -> parent.resolveMethodName(simpleName)\n        ).flatMap(Supplier::get);\n    }\n\n\n    /** Finds the matching methods among the declarations tracked by this table without asking the parent. */\n    protected Stream<JMethodSymbol> resolveMethodNameImpl(String simpleName) {\n        return Stream.empty();\n    }\n\n    // We could internally avoid using Optional to reduce the number of created optionals as an optimisation\n\n\n    /**\n     * Finds a type name among the declarations tracked by this table without asking the parent.\n     */\n    protected @Nullable ResolveResult<JTypeDeclSymbol> resolveTypeNameImpl(String simpleName) {\n        return ResolveResultImpl.failed();\n    }\n\n\n    /** Finds a value among the declarations tracked by this table without asking the parent. */\n    protected @Nullable ResolveResult<JVariableSymbol> resolveValueNameImpl(String simpleName) {\n        return ResolveResultImpl.failed();\n    }\n\n\n    /**\n     * Tries to load a class and logs it if it is not found.\n     *\n     * @param anImport Node owning the warning\n     * @param fqcn     Binary name of the class to load\n     *\n     * @return The class, or null if it couldn't be resolved\n     */\n    @Nullable\n    final JClassSymbol loadClassReportFailure(ASTImportDeclaration anImport, String fqcn) {\n        JClassSymbol loaded = helper.loadClassOrFail(fqcn);\n        if (loaded == null) {\n            helper.getLogger().warning(anImport, SemanticChecksLogger.CANNOT_FIND_CLASSPATH_SYMBOL, fqcn);\n        }\n\n        return loaded;\n    }\n\n\n    /**\n     * Tries to load a class, not logging failure.\n     *\n     * @param canonicalName Canonical name of the class to load\n     *\n     * @return The class, or null if it couldn't be resolved\n     */\n    @Nullable\n    final JClassSymbol loadClassIgnoreFailure(String canonicalName) {\n        return helper.loadClassOrFail(canonicalName);\n    }\n\n    /**\n     * Returns true if this table doesn't contain any information, and\n     * can be eliminated from the stack entirely.\n     */\n    boolean isPrunable() {\n        // TODO would be better to conside the three channels separate.\n        //  That way local scopes with no class declaration skip directly to type declaration scope\n        return false;\n    }\n}\n",
        "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/AbstractSymbolTable.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.symbols.table.internal;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration;\nimport net.sourceforge.pmd.lang.java.symbols.JClassSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JTypeDeclSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.table.JSymbolTable;\nimport net.sourceforge.pmd.lang.java.symbols.table.ResolveResult;\n\n\n/**\n * Base implementation.\n *\n * @since 7.0.0\n */\nabstract class AbstractSymbolTable implements JSymbolTable {\n\n    /** Additional info about the context. */\n    protected final SymbolTableHelper helper;\n    private final JSymbolTable parent;\n\n    AbstractSymbolTable(JSymbolTable parent, SymbolTableHelper helper) {\n        assert parent != null : \"Null parent!\";\n        assert helper != null : \"Null helper!\";\n\n        this.parent = parent;\n        this.helper = helper;\n    }\n\n\n    @Override\n    @NonNull\n    public final JSymbolTable getParent() {\n        return parent;\n    }\n\n\n    @Nullable\n    @Override\n    public final ResolveResult<JTypeDeclSymbol> resolveTypeName(String simpleName) {\n        @Nullable ResolveResult<JTypeDeclSymbol> result = resolveTypeNameImpl(simpleName);\n        return result != null ? result : parent.resolveTypeName(simpleName);\n    }\n\n\n    @Override\n    public final @Nullable ResolveResult<JVariableSymbol> resolveValueName(String simpleName) {\n        @Nullable ResolveResult<JVariableSymbol> result = resolveValueNameImpl(simpleName);\n        return result != null ? result : parent.resolveValueName(simpleName);\n    }\n\n\n    @Override\n    public final List<JMethodSymbol> resolveMethodName(String simpleName) {\n        // the default implementation always returns the parent results\n        // if the table has methods itself, it needs to override this\n        List<JMethodSymbol> result = getCachedMethodResults(simpleName);\n        if (result != null) {\n            return result;\n        }\n        // Otherwise, create the list from the union\n        List<JMethodSymbol> localResult = resolveMethodNamesHere(simpleName);\n        List<JMethodSymbol> parentResult = parent.resolveMethodName(simpleName); // recurse on parent\n        if (localResult.isEmpty()) {\n            result = parentResult; // parent result is already unmodifiable\n        } else {\n            result = localResult;\n            result.addAll(parentResult);\n            result = Collections.unmodifiableList(result);\n        }\n        cacheMethodResult(simpleName, result);\n        return result;\n    }\n\n    /**\n     * Finds the matching methods among the declarations tracked by this\n     * table *without asking the parent*. Returns a mutable list.\n     *\n     * <p>This method is only called if {@link #getCachedMethodResults(String)}\n     * returns a null result. For that reason, that method must be overridden\n     * if this one is to be used.\n     */\n    protected /*Mutable*/List<JMethodSymbol> resolveMethodNamesHere(String simpleName) {\n        // dead code if getCachedMethodResults is not overridden\n        return new ArrayList<>();\n    }\n\n    @Nullable\n    protected List<JMethodSymbol> getCachedMethodResults(String simpleName) {\n        return parent.resolveMethodName(simpleName); // this table is empty\n    }\n\n    protected void cacheMethodResult(String simpleName, List<JMethodSymbol> sigs) {\n        // do nothing, dead code if getCachedMethodResults is not overridden\n    }\n\n    /**\n     * Finds a type name among the declarations tracked by this table without asking the parent.\n     */\n    protected @Nullable ResolveResult<JTypeDeclSymbol> resolveTypeNameImpl(String simpleName) {\n        return null;\n    }\n\n\n    /** Finds a value among the declarations tracked by this table without asking the parent. */\n    protected @Nullable ResolveResult<JVariableSymbol> resolveValueNameImpl(String simpleName) {\n        return null;\n    }\n\n\n    /**\n     * Tries to load a class and logs it if it is not found.\n     *\n     * @param anImport Node owning the warning\n     * @param fqcn     Binary name of the class to load\n     *\n     * @return The class, or null if it couldn't be resolved\n     */\n    @Nullable\n    final JClassSymbol loadClassReportFailure(ASTImportDeclaration anImport, String fqcn) {\n        JClassSymbol loaded = helper.loadClassOrFail(fqcn);\n        if (loaded == null) {\n            helper.getLogger().warning(anImport, SemanticChecksLogger.CANNOT_FIND_CLASSPATH_SYMBOL, fqcn);\n        }\n\n        return loaded;\n    }\n\n\n    /**\n     * Tries to load a class, not logging failure.\n     *\n     * @param canonicalName Canonical name of the class to load\n     *\n     * @return The class, or null if it couldn't be resolved\n     */\n    @Nullable\n    final JClassSymbol loadClassIgnoreFailure(String canonicalName) {\n        return helper.loadClassOrFail(canonicalName);\n    }\n\n    /**\n     * Returns true if this table doesn't contain any information, and\n     * can be eliminated from the stack entirely.\n     */\n    boolean isPrunable() {\n        // TODO would be better to conside the three channels separate.\n        //  That way local scopes with no class declaration skip directly to type declaration scope\n        return false;\n    }\n}\n",
        "diffSourceCodeSet": [
            "@Nullable\n    protected List<JMethodSymbol> getCachedMethodResults(String simpleName) {\n        return parent.resolveMethodName(simpleName); // this table is empty\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.java.symbols.table.internal.AbstractSymbolTable#resolveMethodName\n methodBody: public final Stream<JMethodSymbol> resolveMethodName(String simpleName) {\nreturn Stream.<Supplier<Stream<JMethodSymbol>>>of(() -> resolveMethodNameImpl(simpleName),() -> parent.resolveMethodName(simpleName)).flatMap(Supplier::get);\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.symbols.table.JSymbolTable#resolveMethodName\n methodBody: Stream<JMethodSymbol> resolveMethodName(String simpleName);",
            "methodSignature: net.sourceforge.pmd.lang.java.symbols.table.internal.TypeMemberSymTable#resolveMethodNameImpl\n methodBody: protected Stream<JMethodSymbol> resolveMethodNameImpl(String simpleName) {\nif(simpleName.equals(JConstructorSymbol.CTOR_NAME)){return Stream.empty();\n}return typeSym.getDeclaredMethods(simpleName).stream();\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.symbols.table.internal.AbstractSymbolTable#resolveMethodNameImpl\n methodBody: protected Stream<JMethodSymbol> resolveMethodNameImpl(String simpleName) {\nreturn Stream.empty();\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.symbols.table.internal.AbstractImportSymbolTable#resolveMethodNameImpl\n methodBody: protected Stream<JMethodSymbol> resolveMethodNameImpl(String simpleName) {\nreturn importedStaticMethods.getOrDefault(simpleName,Collections.emptyList()).stream();\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.symbols.table.internal.EmptySymbolTable#resolveMethodName\n methodBody: public Stream<JMethodSymbol> resolveMethodName(String simpleName) {\nreturn Stream.empty();\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n    public final List<JMethodSymbol> resolveMethodName(String simpleName) {\n        // the default implementation always returns the parent results\n        // if the table has methods itself, it needs to override this\n        List<JMethodSymbol> result = getCachedMethodResults(simpleName);\n        if (result != null) {\n            return result;\n        }\n        // Otherwise, create the list from the union\n        List<JMethodSymbol> localResult = resolveMethodNamesHere(simpleName);\n        List<JMethodSymbol> parentResult = parent.resolveMethodName(simpleName); // recurse on parent\n        if (localResult.isEmpty()) {\n            result = parentResult; // parent result is already unmodifiable\n        } else {\n            result = localResult;\n            result.addAll(parentResult);\n            result = Collections.unmodifiableList(result);\n        }\n        cacheMethodResult(simpleName, result);\n        return result;\n    }\n@Nullable\n    protected List<JMethodSymbol> getCachedMethodResults(String simpleName) {\n        return parent.resolveMethodName(simpleName); // this table is empty\n    }",
        "diffSourceCode": "    65:     @Override\n-   66:     public final Stream<JMethodSymbol> resolveMethodName(String simpleName) {\n-   67:         // This allows the stream contributed by the parent to be resolved lazily,\n-   68:         // ie not evaluated unless the stream contributed by this table runs out of values,\n-   69:         // a behaviour that Stream.concat can't provide\n-   70: \n-   71:         return Stream.<Supplier<Stream<JMethodSymbol>>>of(\n-   72:             () -> resolveMethodNameImpl(simpleName),\n-   73:             () -> parent.resolveMethodName(simpleName)\n-   74:         ).flatMap(Supplier::get);\n-   75:     }\n-   76: \n-   77: \n-   78:     /** Finds the matching methods among the declarations tracked by this table without asking the parent. */\n-   79:     protected Stream<JMethodSymbol> resolveMethodNameImpl(String simpleName) {\n-   80:         return Stream.empty();\n-   81:     }\n-   82: \n-   83:     // We could internally avoid using Optional to reduce the number of created optionals as an optimisation\n-   84: \n-   85: \n-  100:     /**\n-  101:      * Tries to load a class and logs it if it is not found.\n-  102:      *\n-  103:      * @param anImport Node owning the warning\n+   66:     public final List<JMethodSymbol> resolveMethodName(String simpleName) {\n+   67:         // the default implementation always returns the parent results\n+   68:         // if the table has methods itself, it needs to override this\n+   69:         List<JMethodSymbol> result = getCachedMethodResults(simpleName);\n+   70:         if (result != null) {\n+   71:             return result;\n+   72:         }\n+   73:         // Otherwise, create the list from the union\n+   74:         List<JMethodSymbol> localResult = resolveMethodNamesHere(simpleName);\n+   75:         List<JMethodSymbol> parentResult = parent.resolveMethodName(simpleName); // recurse on parent\n+   76:         if (localResult.isEmpty()) {\n+   77:             result = parentResult; // parent result is already unmodifiable\n+   78:         } else {\n+   79:             result = localResult;\n+   80:             result.addAll(parentResult);\n+   81:             result = Collections.unmodifiableList(result);\n+   82:         }\n+   83:         cacheMethodResult(simpleName, result);\n+   84:         return result;\n+   85:     }\n+  100:     @Nullable\n+  101:     protected List<JMethodSymbol> getCachedMethodResults(String simpleName) {\n+  102:         return parent.resolveMethodName(simpleName); // this table is empty\n+  103:     }\n",
        "uniqueId": "946df6fc07c39b98599a4e0548ccc9aec3c7c5da_65_75_100_103_65_85",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 18
            },
            "LINE": {
                "missed": 0,
                "covered": 2
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic size() : int extracted from public getParameterCount() : int in class net.sourceforge.pmd.lang.java.ast.ASTFormalParameters",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTFormalParameters.java",
                "startLine": 27,
                "endLine": 31,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTFormalParameters.java",
                "startLine": 33,
                "endLine": 39,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTFormalParameters.java",
                "startLine": 27,
                "endLine": 31,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public int getParameterCount() {\n        final List<ASTFormalParameter> parameters = findChildrenOfType(ASTFormalParameter.class);\n        return !parameters.isEmpty() && parameters.get(0).isExplicitReceiverParameter()\n               ? parameters.size() - 1 : parameters.size();\n    }",
        "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTFormalParameters.java",
        "isPureRefactoring": true,
        "commitId": "80cba026c2ecda9fc7c770cd78df134ca0803e79",
        "packageNameBefore": "net.sourceforge.pmd.lang.java.ast",
        "classNameBefore": "net.sourceforge.pmd.lang.java.ast.ASTFormalParameters",
        "methodNameBefore": "net.sourceforge.pmd.lang.java.ast.ASTFormalParameters#getParameterCount",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.java.multifile.signature.JavaOperationSignature.Role#get\n methodBody: private static Role get(ASTMethodDeclaration node) {\nif(node.isStatic()){return STATIC;\n}if(isGetterOrSetter(node)){return GETTER_OR_SETTER;\n}{return METHOD;\n}}",
        "classSignatureBefore": "public class ASTFormalParameters extends AbstractJavaNode implements Iterable<ASTFormalParameter> ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.ast.ASTFormalParameters#getParameterCount"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.ast.ASTFormalParameters"
        ],
        "classSignatureBeforeSet": [
            "public class ASTFormalParameters extends AbstractJavaNode implements Iterable<ASTFormalParameter> "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.ast;\n\nimport java.util.Iterator;\nimport java.util.List;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\n\n\npublic class ASTFormalParameters extends AbstractJavaNode implements Iterable<ASTFormalParameter> {\n\n    @InternalApi\n    @Deprecated\n    public ASTFormalParameters(int id) {\n        super(id);\n    }\n\n    @InternalApi\n    @Deprecated\n    public ASTFormalParameters(JavaParser p, int id) {\n        super(p, id);\n    }\n\n    public int getParameterCount() {\n        final List<ASTFormalParameter> parameters = findChildrenOfType(ASTFormalParameter.class);\n        return !parameters.isEmpty() && parameters.get(0).isExplicitReceiverParameter()\n               ? parameters.size() - 1 : parameters.size();\n    }\n\n    @Override\n    public Object jjtAccept(JavaParserVisitor visitor, Object data) {\n        return visitor.visit(this, data);\n    }\n\n\n    @Override\n    public Iterator<ASTFormalParameter> iterator() {\n        return new NodeChildrenIterator<>(this, ASTFormalParameter.class);\n    }\n}\n",
        "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTFormalParameters.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.ast;\n\nimport java.util.Iterator;\nimport java.util.List;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\n\n\npublic class ASTFormalParameters extends AbstractJavaNode implements Iterable<ASTFormalParameter> {\n\n    @InternalApi\n    @Deprecated\n    public ASTFormalParameters(int id) {\n        super(id);\n    }\n\n    @InternalApi\n    @Deprecated\n    public ASTFormalParameters(JavaParser p, int id) {\n        super(p, id);\n    }\n\n    public int size() {\n        final List<ASTFormalParameter> parameters = findChildrenOfType(ASTFormalParameter.class);\n        return !parameters.isEmpty() && parameters.get(0).isExplicitReceiverParameter()\n               ? parameters.size() - 1 : parameters.size();\n    }\n\n    /**\n     * @deprecated for removal. Use {@link #size()} instead.\n     */\n    @Deprecated\n    public int getParameterCount() {\n        return size();\n    }\n\n    @Override\n    public Object jjtAccept(JavaParserVisitor visitor, Object data) {\n        return visitor.visit(this, data);\n    }\n\n\n    @Override\n    public Iterator<ASTFormalParameter> iterator() {\n        return new NodeChildrenIterator<>(this, ASTFormalParameter.class);\n    }\n}\n",
        "diffSourceCodeSet": [
            "public int size() {\n        final List<ASTFormalParameter> parameters = findChildrenOfType(ASTFormalParameter.class);\n        return !parameters.isEmpty() && parameters.get(0).isExplicitReceiverParameter()\n               ? parameters.size() - 1 : parameters.size();\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.java.multifile.signature.JavaOperationSignature.Role#get\n methodBody: private static Role get(ASTMethodDeclaration node) {\nif(node.isStatic()){return STATIC;\n}if(isGetterOrSetter(node)){return GETTER_OR_SETTER;\n}{return METHOD;\n}}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * @deprecated for removal. Use {@link #size()} instead.\n     */\n    @Deprecated\n    public int getParameterCount() {\n        return size();\n    }\npublic int size() {\n        final List<ASTFormalParameter> parameters = findChildrenOfType(ASTFormalParameter.class);\n        return !parameters.isEmpty() && parameters.get(0).isExplicitReceiverParameter()\n               ? parameters.size() - 1 : parameters.size();\n    }",
        "diffSourceCode": "-   27:     public int getParameterCount() {\n+   27:     public int size() {\n    28:         final List<ASTFormalParameter> parameters = findChildrenOfType(ASTFormalParameter.class);\n    29:         return !parameters.isEmpty() && parameters.get(0).isExplicitReceiverParameter()\n    30:                ? parameters.size() - 1 : parameters.size();\n    31:     }\n-   33:     @Override\n-   34:     public Object jjtAccept(JavaParserVisitor visitor, Object data) {\n-   35:         return visitor.visit(this, data);\n-   36:     }\n-   37: \n-   38: \n-   39:     @Override\n+   33:     /**\n+   34:      * @deprecated for removal. Use {@link #size()} instead.\n+   35:      */\n+   36:     @Deprecated\n+   37:     public int getParameterCount() {\n+   38:         return size();\n+   39:     }\n",
        "uniqueId": "80cba026c2ecda9fc7c770cd78df134ca0803e79_27_31_27_31_33_39",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 21
            },
            "BRANCH": {
                "missed": 0,
                "covered": 4
            },
            "LINE": {
                "missed": 0,
                "covered": 3
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 3
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate getNumericLiteralValue(literal ASTLiteral) : double extracted from public visit(fieldDeclaration ASTFieldDeclaration, data Object) : Object in class net.sourceforge.pmd.lang.java.rule.performance.RedundantFieldInitializerRule",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/RedundantFieldInitializerRule.java",
                "startLine": 33,
                "endLine": 107,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/RedundantFieldInitializerRule.java",
                "startLine": 48,
                "endLine": 52,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/RedundantFieldInitializerRule.java",
                "startLine": 77,
                "endLine": 88,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n    public Object visit(ASTFieldDeclaration fieldDeclaration, Object data) {\n        // Finals can only be initialized once.\n        if (fieldDeclaration.isFinal()) {\n            return data;\n        }\n\n        // Look for a match to the following XPath:\n        // VariableDeclarator/VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Literal\n        for (ASTVariableDeclarator variableDeclarator : fieldDeclaration\n                .findChildrenOfType(ASTVariableDeclarator.class)) {\n            if (variableDeclarator.getNumChildren() > 1) {\n                final Node variableInitializer = variableDeclarator.getChild(1);\n                if (variableInitializer.getChild(0) instanceof ASTExpression) {\n                    final Node expression = variableInitializer.getChild(0);\n                    final Node primaryExpression;\n                    if (expression.getNumChildren() == 1) {\n                        if (expression.getChild(0) instanceof ASTPrimaryExpression) {\n                            primaryExpression = expression.getChild(0);\n                        } else if (expression.getChild(0) instanceof ASTCastExpression\n                                && expression.getChild(0).getChild(1) instanceof ASTPrimaryExpression) {\n                            primaryExpression = expression.getChild(0).getChild(1);\n                        } else {\n                            continue;\n                        }\n                    } else {\n                        continue;\n                    }\n                    final Node primaryPrefix = primaryExpression.getChild(0);\n                    if (primaryPrefix.getNumChildren() == 1 && primaryPrefix.getChild(0) instanceof ASTLiteral) {\n                        final ASTLiteral literal = (ASTLiteral) primaryPrefix.getChild(0);\n                        if (isRef(fieldDeclaration, variableDeclarator)) {\n                            // Reference type\n                            if (literal.getNumChildren() == 1 && literal.getChild(0) instanceof ASTNullLiteral) {\n                                addViolation(data, variableDeclarator);\n                            }\n                        } else {\n                            // Primitive type\n                            if (literal.getNumChildren() == 1\n                                    && literal.getChild(0) instanceof ASTBooleanLiteral) {\n                                // boolean type\n                                ASTBooleanLiteral booleanLiteral = (ASTBooleanLiteral) literal.getChild(0);\n                                if (!booleanLiteral.isTrue()) {\n                                    addViolation(data, variableDeclarator);\n                                }\n                            } else if (literal.getNumChildren() == 0) {\n                                // numeric type\n                                // Note: Not catching NumberFormatException, as\n                                // it shouldn't be happening on valid source\n                                // code.\n                                Number value = -1;\n                                if (literal.isIntLiteral()) {\n                                    value = literal.getValueAsInt();\n                                } else if (literal.isLongLiteral()) {\n                                    value = literal.getValueAsLong();\n                                } else if (literal.isFloatLiteral()) {\n                                    value = literal.getValueAsFloat();\n                                } else if (literal.isDoubleLiteral()) {\n                                    value = literal.getValueAsDouble();\n                                } else if (literal.isCharLiteral()) {\n                                    value = (int) literal.getImage().charAt(1);\n                                }\n\n                                if (value.doubleValue() == 0) {\n                                    addViolation(data, variableDeclarator);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return data;\n    }",
        "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/RedundantFieldInitializerRule.java",
        "isPureRefactoring": true,
        "commitId": "a707d9451325811748061cbd0eeda5207f920cf4",
        "packageNameBefore": "net.sourceforge.pmd.lang.java.rule.performance",
        "classNameBefore": "net.sourceforge.pmd.lang.java.rule.performance.RedundantFieldInitializerRule",
        "methodNameBefore": "net.sourceforge.pmd.lang.java.rule.performance.RedundantFieldInitializerRule#visit",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.java.rule.performance.RedundantFieldInitializerRule#addViolation\n methodBody: private void addViolation(Object data, ASTVariableDeclarator variableDeclarator) {\nsuper.addViolation(data,variableDeclarator,variableDeclarator.getChild(0).getImage());\n}\nmethodSignature: net.sourceforge.pmd.lang.java.rule.performance.RedundantFieldInitializerRule#isRef\n methodBody: private boolean isRef(ASTFieldDeclaration fieldDeclaration, ASTVariableDeclarator variableDeclarator) {\nNode type=fieldDeclaration.getChild(0).getChild(0);\nif(type instanceof ASTReferenceType){return true;\n}{return ((ASTVariableDeclaratorId)variableDeclarator.getChild(0)).isArray();\n}}",
        "classSignatureBefore": "public class RedundantFieldInitializerRule extends AbstractJavaRule ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.rule.performance.RedundantFieldInitializerRule#visit"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.rule.performance.RedundantFieldInitializerRule"
        ],
        "classSignatureBeforeSet": [
            "public class RedundantFieldInitializerRule extends AbstractJavaRule "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.rule.performance;\n\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.java.ast.ASTBooleanLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTCastExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTNullLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTReferenceType;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableDeclarator;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;\nimport net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;\n\n/**\n * Detects redundant field initializers, i.e. the field initializer expressions\n * the JVM would assign by default.\n *\n * @author lucian.ciufudean@gmail.com\n * @since Apr 10, 2009\n */\npublic class RedundantFieldInitializerRule extends AbstractJavaRule {\n\n    public RedundantFieldInitializerRule() {\n        addRuleChainVisit(ASTFieldDeclaration.class);\n    }\n\n    @Override\n    public Object visit(ASTFieldDeclaration fieldDeclaration, Object data) {\n        // Finals can only be initialized once.\n        if (fieldDeclaration.isFinal()) {\n            return data;\n        }\n\n        // Look for a match to the following XPath:\n        // VariableDeclarator/VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Literal\n        for (ASTVariableDeclarator variableDeclarator : fieldDeclaration\n                .findChildrenOfType(ASTVariableDeclarator.class)) {\n            if (variableDeclarator.getNumChildren() > 1) {\n                final Node variableInitializer = variableDeclarator.getChild(1);\n                if (variableInitializer.getChild(0) instanceof ASTExpression) {\n                    final Node expression = variableInitializer.getChild(0);\n                    final Node primaryExpression;\n                    if (expression.getNumChildren() == 1) {\n                        if (expression.getChild(0) instanceof ASTPrimaryExpression) {\n                            primaryExpression = expression.getChild(0);\n                        } else if (expression.getChild(0) instanceof ASTCastExpression\n                                && expression.getChild(0).getChild(1) instanceof ASTPrimaryExpression) {\n                            primaryExpression = expression.getChild(0).getChild(1);\n                        } else {\n                            continue;\n                        }\n                    } else {\n                        continue;\n                    }\n                    final Node primaryPrefix = primaryExpression.getChild(0);\n                    if (primaryPrefix.getNumChildren() == 1 && primaryPrefix.getChild(0) instanceof ASTLiteral) {\n                        final ASTLiteral literal = (ASTLiteral) primaryPrefix.getChild(0);\n                        if (isRef(fieldDeclaration, variableDeclarator)) {\n                            // Reference type\n                            if (literal.getNumChildren() == 1 && literal.getChild(0) instanceof ASTNullLiteral) {\n                                addViolation(data, variableDeclarator);\n                            }\n                        } else {\n                            // Primitive type\n                            if (literal.getNumChildren() == 1\n                                    && literal.getChild(0) instanceof ASTBooleanLiteral) {\n                                // boolean type\n                                ASTBooleanLiteral booleanLiteral = (ASTBooleanLiteral) literal.getChild(0);\n                                if (!booleanLiteral.isTrue()) {\n                                    addViolation(data, variableDeclarator);\n                                }\n                            } else if (literal.getNumChildren() == 0) {\n                                // numeric type\n                                // Note: Not catching NumberFormatException, as\n                                // it shouldn't be happening on valid source\n                                // code.\n                                Number value = -1;\n                                if (literal.isIntLiteral()) {\n                                    value = literal.getValueAsInt();\n                                } else if (literal.isLongLiteral()) {\n                                    value = literal.getValueAsLong();\n                                } else if (literal.isFloatLiteral()) {\n                                    value = literal.getValueAsFloat();\n                                } else if (literal.isDoubleLiteral()) {\n                                    value = literal.getValueAsDouble();\n                                } else if (literal.isCharLiteral()) {\n                                    value = (int) literal.getImage().charAt(1);\n                                }\n\n                                if (value.doubleValue() == 0) {\n                                    addViolation(data, variableDeclarator);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return data;\n    }\n\n    /**\n     * Checks if a FieldDeclaration is a reference type (includes arrays). The\n     * reference information is in the FieldDeclaration for this example:\n     *\n     * <pre>\n     * int[] ia1\n     * </pre>\n     *\n     * and in the VariableDeclarator for this example:\n     *\n     * <pre>\n     * int ia2[];\n     * </pre>\n     *\n     * .\n     *\n     * @param fieldDeclaration\n     *            the field to check.\n     * @param variableDeclarator\n     *            the variable declarator to check.\n     * @return <code>true</code> if the field is a reference. <code>false</code>\n     *         otherwise.\n     */\n    private boolean isRef(ASTFieldDeclaration fieldDeclaration, ASTVariableDeclarator variableDeclarator) {\n        Node type = fieldDeclaration.getChild(0).getChild(0);\n        if (type instanceof ASTReferenceType) {\n            // Reference type, array or otherwise\n            return true;\n        } else {\n            // Primitive array?\n            return ((ASTVariableDeclaratorId) variableDeclarator.getChild(0)).isArray();\n        }\n    }\n\n    private void addViolation(Object data, ASTVariableDeclarator variableDeclarator) {\n        super.addViolation(data, variableDeclarator, variableDeclarator.getChild(0).getImage());\n    }\n}\n",
        "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/RedundantFieldInitializerRule.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.rule.performance;\n\nimport java.util.List;\n\nimport net.sourceforge.pmd.lang.java.ast.ASTBooleanLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTNullLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimitiveType;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableDeclarator;\nimport net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;\n\n/**\n * Detects redundant field initializers, i.e. the field initializer expressions\n * the JVM would assign by default.\n *\n * @author lucian.ciufudean@gmail.com\n * @since Apr 10, 2009\n */\npublic class RedundantFieldInitializerRule extends AbstractJavaRule {\n\n    public RedundantFieldInitializerRule() {\n        addRuleChainVisit(ASTFieldDeclaration.class);\n    }\n\n    @Override\n    public Object visit(ASTFieldDeclaration fieldDeclaration, Object data) {\n        if (declaresNotFinalField(fieldDeclaration)) {\n            List<ASTVariableDeclarator> varDecls = fieldDeclaration.findDescendantsOfType(ASTVariableDeclarator.class);\n            for (ASTVariableDeclarator varDecl : varDecls) {\n                if (hasRedundantInitializer(fieldDeclaration, varDecl)) {\n                    addViolation(data, varDecl);\n                }\n            }\n        }\n        return data;\n    }\n\n    private boolean declaresNotFinalField(ASTFieldDeclaration fieldDeclaration) {\n        return !fieldDeclaration.isFinal();\n    }\n\n    private boolean hasRedundantInitializer(ASTFieldDeclaration fieldDeclaration, ASTVariableDeclarator varDecl) {\n        return declaresFieldOfPrimitiveType(fieldDeclaration)\n                && hasRedundantInitializerOfPrimitive(varDecl)\n                || hasRedundantInitializerOfReference(varDecl);\n    }\n\n    private boolean declaresFieldOfPrimitiveType(ASTFieldDeclaration fieldDeclaration) {\n        return fieldDeclaration.getChild(0).getChild(0) instanceof ASTPrimitiveType;\n    }\n\n    private boolean hasRedundantInitializerOfPrimitive(ASTVariableDeclarator varDecl) {\n        ASTLiteral literal = getLiteralValue(varDecl);\n        if (literal != null) {\n            if (isNumericLiteral(literal)) {\n                return getNumericLiteralValue(literal) == 0;\n            }\n            if (literal.isCharLiteral()) {\n                return hasDefaultCharLiteralValue(literal);\n            }\n            return isDefaultBooleanLiteral(literal);\n        }\n        return false;\n    }\n\n    private boolean isNumericLiteral(ASTLiteral literal) {\n        return literal.isIntLiteral() || literal.isLongLiteral()\n                || literal.isFloatLiteral() || literal.isDoubleLiteral();\n    }\n\n    private double getNumericLiteralValue(ASTLiteral literal) {\n        if (literal.isIntLiteral()) {\n            return literal.getValueAsInt();\n        }\n        if (literal.isLongLiteral()) {\n            return literal.getValueAsLong();\n        }\n        if (literal.isFloatLiteral()) {\n            return literal.getValueAsFloat();\n        }\n        return literal.getValueAsDouble();\n    }\n\n    private boolean hasDefaultCharLiteralValue(ASTLiteral literal) {\n        String img = literal.getImage();\n        return img.contains(\"\\u0000\") || img.contains(\"\\\\0\");\n    }\n\n    private boolean isDefaultBooleanLiteral(ASTLiteral literal) {\n        ASTBooleanLiteral booleanLiteral = literal.getFirstDescendantOfType(ASTBooleanLiteral.class);\n        return booleanLiteral != null && !booleanLiteral.isTrue();\n    }\n\n    private boolean hasRedundantInitializerOfReference(ASTVariableDeclarator varDecl) {\n        ASTLiteral literal = getLiteralValue(varDecl);\n        return literal != null && isNullLiteral(literal);\n    }\n\n    private ASTLiteral getLiteralValue(ASTVariableDeclarator varDecl) {\n        ASTPrimaryPrefix prefix = varDecl.getFirstDescendantOfType(ASTPrimaryPrefix.class);\n        return prefix != null && prefix.getNumChildren() == 1\n                ? prefix.getFirstChildOfType(ASTLiteral.class)\n                : null;\n    }\n\n    private boolean isNullLiteral(ASTLiteral literal) {\n        return literal.getFirstDescendantOfType(ASTNullLiteral.class) != null;\n    }\n}\n",
        "diffSourceCodeSet": [
            "private double getNumericLiteralValue(ASTLiteral literal) {\n        if (literal.isIntLiteral()) {\n            return literal.getValueAsInt();\n        }\n        if (literal.isLongLiteral()) {\n            return literal.getValueAsLong();\n        }\n        if (literal.isFloatLiteral()) {\n            return literal.getValueAsFloat();\n        }\n        return literal.getValueAsDouble();\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.java.rule.performance.RedundantFieldInitializerRule#addViolation\n methodBody: private void addViolation(Object data, ASTVariableDeclarator variableDeclarator) {\nsuper.addViolation(data,variableDeclarator,variableDeclarator.getChild(0).getImage());\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.rule.performance.RedundantFieldInitializerRule#isRef\n methodBody: private boolean isRef(ASTFieldDeclaration fieldDeclaration, ASTVariableDeclarator variableDeclarator) {\nNode type=fieldDeclaration.getChild(0).getChild(0);\nif(type instanceof ASTReferenceType){return true;\n}{return ((ASTVariableDeclaratorId)variableDeclarator.getChild(0)).isArray();\n}}"
        ],
        "sourceCodeAfterRefactoring": "private boolean hasRedundantInitializer(ASTFieldDeclaration fieldDeclaration, ASTVariableDeclarator varDecl) {\n        return declaresFieldOfPrimitiveType(fieldDeclaration)\n                && hasRedundantInitializerOfPrimitive(varDecl)\n                || hasRedundantInitializerOfReference(varDecl);\n    }\nprivate double getNumericLiteralValue(ASTLiteral literal) {\n        if (literal.isIntLiteral()) {\n            return literal.getValueAsInt();\n        }\n        if (literal.isLongLiteral()) {\n            return literal.getValueAsLong();\n        }\n        if (literal.isFloatLiteral()) {\n            return literal.getValueAsFloat();\n        }\n        return literal.getValueAsDouble();\n    }",
        "diffSourceCode": "-   33:     @Override\n-   34:     public Object visit(ASTFieldDeclaration fieldDeclaration, Object data) {\n-   35:         // Finals can only be initialized once.\n-   36:         if (fieldDeclaration.isFinal()) {\n-   37:             return data;\n-   38:         }\n-   39: \n-   40:         // Look for a match to the following XPath:\n-   41:         // VariableDeclarator/VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Literal\n-   42:         for (ASTVariableDeclarator variableDeclarator : fieldDeclaration\n-   43:                 .findChildrenOfType(ASTVariableDeclarator.class)) {\n-   44:             if (variableDeclarator.getNumChildren() > 1) {\n-   45:                 final Node variableInitializer = variableDeclarator.getChild(1);\n-   46:                 if (variableInitializer.getChild(0) instanceof ASTExpression) {\n-   47:                     final Node expression = variableInitializer.getChild(0);\n-   48:                     final Node primaryExpression;\n-   49:                     if (expression.getNumChildren() == 1) {\n-   50:                         if (expression.getChild(0) instanceof ASTPrimaryExpression) {\n-   51:                             primaryExpression = expression.getChild(0);\n-   52:                         } else if (expression.getChild(0) instanceof ASTCastExpression\n-   53:                                 && expression.getChild(0).getChild(1) instanceof ASTPrimaryExpression) {\n-   54:                             primaryExpression = expression.getChild(0).getChild(1);\n-   55:                         } else {\n-   56:                             continue;\n-   57:                         }\n-   58:                     } else {\n-   59:                         continue;\n-   60:                     }\n-   61:                     final Node primaryPrefix = primaryExpression.getChild(0);\n-   62:                     if (primaryPrefix.getNumChildren() == 1 && primaryPrefix.getChild(0) instanceof ASTLiteral) {\n-   63:                         final ASTLiteral literal = (ASTLiteral) primaryPrefix.getChild(0);\n-   64:                         if (isRef(fieldDeclaration, variableDeclarator)) {\n-   65:                             // Reference type\n-   66:                             if (literal.getNumChildren() == 1 && literal.getChild(0) instanceof ASTNullLiteral) {\n-   67:                                 addViolation(data, variableDeclarator);\n-   68:                             }\n-   69:                         } else {\n-   70:                             // Primitive type\n-   71:                             if (literal.getNumChildren() == 1\n-   72:                                     && literal.getChild(0) instanceof ASTBooleanLiteral) {\n-   73:                                 // boolean type\n-   74:                                 ASTBooleanLiteral booleanLiteral = (ASTBooleanLiteral) literal.getChild(0);\n-   75:                                 if (!booleanLiteral.isTrue()) {\n-   76:                                     addViolation(data, variableDeclarator);\n-   77:                                 }\n-   78:                             } else if (literal.getNumChildren() == 0) {\n-   79:                                 // numeric type\n-   80:                                 // Note: Not catching NumberFormatException, as\n-   81:                                 // it shouldn't be happening on valid source\n-   82:                                 // code.\n-   83:                                 Number value = -1;\n-   84:                                 if (literal.isIntLiteral()) {\n-   85:                                     value = literal.getValueAsInt();\n-   86:                                 } else if (literal.isLongLiteral()) {\n-   87:                                     value = literal.getValueAsLong();\n-   88:                                 } else if (literal.isFloatLiteral()) {\n-   89:                                     value = literal.getValueAsFloat();\n-   90:                                 } else if (literal.isDoubleLiteral()) {\n-   91:                                     value = literal.getValueAsDouble();\n-   92:                                 } else if (literal.isCharLiteral()) {\n-   93:                                     value = (int) literal.getImage().charAt(1);\n-   94:                                 }\n-   95: \n-   96:                                 if (value.doubleValue() == 0) {\n-   97:                                     addViolation(data, variableDeclarator);\n-   98:                                 }\n-   99:                             }\n-  100:                         }\n-  101:                     }\n-  102:                 }\n-  103:             }\n-  104:         }\n-  105: \n-  106:         return data;\n-  107:     }\n+   33:         if (declaresNotFinalField(fieldDeclaration)) {\n+   34:             List<ASTVariableDeclarator> varDecls = fieldDeclaration.findDescendantsOfType(ASTVariableDeclarator.class);\n+   35:             for (ASTVariableDeclarator varDecl : varDecls) {\n+   36:                 if (hasRedundantInitializer(fieldDeclaration, varDecl)) {\n+   37:                     addViolation(data, varDecl);\n+   38:                 }\n+   39:             }\n+   40:         }\n+   41:         return data;\n+   42:     }\n+   43: \n+   44:     private boolean declaresNotFinalField(ASTFieldDeclaration fieldDeclaration) {\n+   45:         return !fieldDeclaration.isFinal();\n+   46:     }\n+   47: \n+   48:     private boolean hasRedundantInitializer(ASTFieldDeclaration fieldDeclaration, ASTVariableDeclarator varDecl) {\n+   49:         return declaresFieldOfPrimitiveType(fieldDeclaration)\n+   50:                 && hasRedundantInitializerOfPrimitive(varDecl)\n+   51:                 || hasRedundantInitializerOfReference(varDecl);\n+   52:     }\n+   53: \n+   54:     private boolean declaresFieldOfPrimitiveType(ASTFieldDeclaration fieldDeclaration) {\n+   55:         return fieldDeclaration.getChild(0).getChild(0) instanceof ASTPrimitiveType;\n+   56:     }\n+   57: \n+   58:     private boolean hasRedundantInitializerOfPrimitive(ASTVariableDeclarator varDecl) {\n+   59:         ASTLiteral literal = getLiteralValue(varDecl);\n+   60:         if (literal != null) {\n+   61:             if (isNumericLiteral(literal)) {\n+   62:                 return getNumericLiteralValue(literal) == 0;\n+   63:             }\n+   64:             if (literal.isCharLiteral()) {\n+   65:                 return hasDefaultCharLiteralValue(literal);\n+   66:             }\n+   67:             return isDefaultBooleanLiteral(literal);\n+   68:         }\n+   69:         return false;\n+   70:     }\n+   71: \n+   72:     private boolean isNumericLiteral(ASTLiteral literal) {\n+   73:         return literal.isIntLiteral() || literal.isLongLiteral()\n+   74:                 || literal.isFloatLiteral() || literal.isDoubleLiteral();\n+   75:     }\n+   76: \n+   77:     private double getNumericLiteralValue(ASTLiteral literal) {\n+   78:         if (literal.isIntLiteral()) {\n+   79:             return literal.getValueAsInt();\n+   80:         }\n+   81:         if (literal.isLongLiteral()) {\n+   82:             return literal.getValueAsLong();\n+   83:         }\n+   84:         if (literal.isFloatLiteral()) {\n+   85:             return literal.getValueAsFloat();\n+   86:         }\n+   87:         return literal.getValueAsDouble();\n+   88:     }\n+   89: \n+   90:     private boolean hasDefaultCharLiteralValue(ASTLiteral literal) {\n+   91:         String img = literal.getImage();\n+   92:         return img.contains(\"\\u0000\") || img.contains(\"\\\\0\");\n+   93:     }\n+   94: \n+   95:     private boolean isDefaultBooleanLiteral(ASTLiteral literal) {\n+   96:         ASTBooleanLiteral booleanLiteral = literal.getFirstDescendantOfType(ASTBooleanLiteral.class);\n+   97:         return booleanLiteral != null && !booleanLiteral.isTrue();\n+   98:     }\n+   99: \n+  100:     private boolean hasRedundantInitializerOfReference(ASTVariableDeclarator varDecl) {\n+  101:         ASTLiteral literal = getLiteralValue(varDecl);\n+  102:         return literal != null && isNullLiteral(literal);\n+  103:     }\n+  104: \n+  105:     private ASTLiteral getLiteralValue(ASTVariableDeclarator varDecl) {\n+  106:         ASTPrimaryPrefix prefix = varDecl.getFirstDescendantOfType(ASTPrimaryPrefix.class);\n+  107:         return prefix != null && prefix.getNumChildren() == 1\n",
        "uniqueId": "a707d9451325811748061cbd0eeda5207f920cf4_33_107_77_88_48_52",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 184
            },
            "BRANCH": {
                "missed": 8,
                "covered": 38
            },
            "LINE": {
                "missed": 0,
                "covered": 41
            },
            "COMPLEXITY": {
                "missed": 8,
                "covered": 16
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Move Method",
        "description": "Move Method\tprivate keyFor(rv RuleViolation) : String from class net.sourceforge.pmd.Report to private keyFor(rv RuleViolation) : String from class net.sourceforge.pmd.renderers.TextColorRenderer",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/Report.java",
                "startLine": 180,
                "endLine": 183,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/renderers/TextColorRenderer.java",
                "startLine": 212,
                "endLine": 214,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private static String keyFor(RuleViolation rv) {\n\n        return StringUtils.isNotBlank(rv.getPackageName()) ? rv.getPackageName() + '.' + rv.getClassName() : \"\";\n    }",
        "filePathBefore": "pmd-core/src/main/java/net/sourceforge/pmd/Report.java",
        "isPureRefactoring": true,
        "commitId": "7db6f3809c07c93729a8183cf80c19a9643d0837",
        "packageNameBefore": "net.sourceforge.pmd",
        "classNameBefore": "net.sourceforge.pmd.Report",
        "methodNameBefore": "net.sourceforge.pmd.Report#keyFor",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.dfa.report.ClassNode#getClassName\n methodBody: public String getClassName() {\nreturn className;\n}\nmethodSignature: net.sourceforge.pmd.lang.dfa.report.PackageNode#getPackageName\n methodBody: public String getPackageName() {\nreturn this.packageName;\n}",
        "classSignatureBefore": "public class Report implements Iterable<RuleViolation> ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.Report#keyFor"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.Report"
        ],
        "classSignatureBeforeSet": [
            "public class Report implements Iterable<RuleViolation> "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.commons.lang3.StringUtils;\n\nimport net.sourceforge.pmd.lang.dfa.report.ReportTree;\nimport net.sourceforge.pmd.renderers.AbstractAccumulatingRenderer;\nimport net.sourceforge.pmd.util.DateTimeUtil;\nimport net.sourceforge.pmd.util.NumericConstants;\n\n/**\n * A {@link Report} collects all informations during a PMD execution. This\n * includes violations, suppressed violations, metrics, error during processing\n * and configuration errors.\n */\npublic class Report implements Iterable<RuleViolation> {\n\n    /*\n     * The idea is to store the violations in a tree instead of a list, to do\n     * better and faster sort and filter mechanism and to visualize the result\n     * as tree. (ide plugins).\n     */\n    private final ReportTree violationTree = new ReportTree();\n\n    // Note that this and the above data structure are both being maintained for\n    // a bit\n    private final List<RuleViolation> violations = new ArrayList<>();\n    private final List<ThreadSafeReportListener> listeners = new ArrayList<>();\n    private List<ProcessingError> errors;\n    private List<ConfigurationError> configErrors;\n    private long start;\n    private long end;\n    private List<SuppressedViolation> suppressedRuleViolations = new ArrayList<>();\n\n    /**\n     * Creates a new, initialized, empty report for the given file name.\n     *\n     * @param ctx\n     *            The context to use to connect to the report\n     * @param fileName\n     *            the filename used to report any violations\n     * @return the new report\n     */\n    public static Report createReport(RuleContext ctx, String fileName) {\n        Report report = new Report();\n\n        // overtake the listener\n        report.addListeners(ctx.getReport().getListeners());\n\n        ctx.setReport(report);\n        ctx.setSourceCodeFile(new File(fileName));\n        return report;\n    }\n\n    /**\n     * Represents a duration. Useful for reporting processing time.\n     */\n    public static class ReadableDuration {\n        private final long duration;\n\n        /**\n         * Creates a new duration.\n         *\n         * @param duration\n         *            the duration in milliseconds.\n         */\n        public ReadableDuration(long duration) {\n            this.duration = duration;\n        }\n\n        /**\n         * Gets a human readable representation of the duration, such as \"1h 3m\n         * 5s\".\n         *\n         * @return human readable representation of the duration\n         */\n        public String getTime() {\n            return DateTimeUtil.asHoursMinutesSeconds(duration);\n        }\n    }\n\n    /**\n     * Represents a configuration error.\n     */\n    public static class ConfigurationError {\n        private final Rule rule;\n        private final String issue;\n\n        /**\n         * Creates a new configuration error for a specific rule.\n         *\n         * @param theRule\n         *            the rule which is configured wrongly\n         * @param theIssue\n         *            the reason, why the configuration is wrong\n         */\n        public ConfigurationError(Rule theRule, String theIssue) {\n            rule = theRule;\n            issue = theIssue;\n        }\n\n        /**\n         * Gets the wrongly configured rule\n         *\n         * @return the wrongly configured rule\n         */\n        public Rule rule() {\n            return rule;\n        }\n\n        /**\n         * Gets the reason for the configuration error.\n         *\n         * @return the issue\n         */\n        public String issue() {\n            return issue;\n        }\n    }\n\n    /**\n     * Represents a processing error, such as a parse error.\n     */\n    public static class ProcessingError {\n        private final Throwable error;\n        private final String file;\n\n        /**\n         * Creates a new processing error\n         *\n         * @param error\n         *            the error\n         * @param file\n         *            the file during which the error occurred\n         */\n        public ProcessingError(Throwable error, String file) {\n            this.error = error;\n            this.file = file;\n        }\n\n        public String getMsg() {\n            return error.getClass().getSimpleName() + \": \" + error.getMessage();\n        }\n\n        public String getDetail() {\n            try (StringWriter stringWriter = new StringWriter();\n                    PrintWriter writer = new PrintWriter(stringWriter)) {\n                error.printStackTrace(writer);\n                return stringWriter.toString();\n            } catch (IOException e) {\n                // IOException on close - should never happen when using StringWriter\n                throw new RuntimeException(e);\n            }\n        }\n\n        public String getFile() {\n            return file;\n        }\n\n        public Throwable getError() {\n            return error;\n        }\n    }\n\n\n    private static String keyFor(RuleViolation rv) {\n\n        return StringUtils.isNotBlank(rv.getPackageName()) ? rv.getPackageName() + '.' + rv.getClassName() : \"\";\n    }\n\n    /**\n     * Calculate a summary of violation counts per fully classified class name.\n     *\n     * @return violations per class name\n     */\n    public Map<String, Integer> getCountSummary() {\n        Map<String, Integer> summary = new HashMap<>();\n        for (RuleViolation rv : violationTree) {\n            String key = keyFor(rv);\n            Integer o = summary.get(key);\n            summary.put(key, o == null ? NumericConstants.ONE : o + 1);\n        }\n        return summary;\n    }\n\n    public ReportTree getViolationTree() {\n        return this.violationTree;\n    }\n\n    /**\n     * Calculate a summary of violations per rule.\n     *\n     * @return a Map summarizing the Report: String (rule name) -&gt; Integer (count\n     *         of violations)\n     */\n    public Map<String, Integer> getSummary() {\n        Map<String, Integer> summary = new HashMap<>();\n        for (RuleViolation rv : violations) {\n            String name = rv.getRule().getName();\n            if (!summary.containsKey(name)) {\n                summary.put(name, NumericConstants.ZERO);\n            }\n            Integer count = summary.get(name);\n            summary.put(name, count + 1);\n        }\n        return summary;\n    }\n\n    /**\n     * Registers a report listener\n     *\n     * @param listener\n     *            the listener\n     */\n    public void addListener(ThreadSafeReportListener listener) {\n        listeners.add(listener);\n    }\n\n    public List<SuppressedViolation> getSuppressedRuleViolations() {\n        return suppressedRuleViolations;\n    }\n\n    /**\n     * Represents a violation, that has been suppressed.\n     * TODO this should implement RuleViolation\n     */\n    public static class SuppressedViolation {\n        private final RuleViolation rv;\n        private final String userMessage;\n        private final ViolationSuppressor suppressor;\n\n        /**\n         * Creates a suppressed violation.\n         *\n         * @param rv          The violation, that has been suppressed\n         * @param suppressor  The suppressor which suppressed the violation\n         * @param userMessage Any relevant info given by the suppressor\n         */\n        public SuppressedViolation(RuleViolation rv, ViolationSuppressor suppressor, String userMessage) {\n            this.suppressor = suppressor;\n            this.rv = rv;\n            this.userMessage = userMessage;\n        }\n\n        public ViolationSuppressor getSuppressor() {\n            return suppressor;\n        }\n\n        public RuleViolation getRuleViolation() {\n            return this.rv;\n        }\n\n        public String getUserMessage() {\n            return userMessage;\n        }\n    }\n\n\n    public void addSuppressedViolation(SuppressedViolation sv) {\n        suppressedRuleViolations.add(sv);\n    }\n\n    /**\n     * Adds a new rule violation to the report and notify the listeners.\n     *\n     * @param violation\n     *            the violation to add\n     */\n    public void addRuleViolation(RuleViolation violation) {\n        int index = Collections.binarySearch(violations, violation, RuleViolationComparator.INSTANCE);\n        violations.add(index < 0 ? -index - 1 : index, violation);\n        violationTree.addRuleViolation(violation);\n        for (ThreadSafeReportListener listener : listeners) {\n            listener.ruleViolationAdded(violation);\n        }\n    }\n\n    /**\n     * Adds a new configuration error to the report.\n     *\n     * @param error\n     *            the error to add\n     */\n    public void addConfigError(ConfigurationError error) {\n        if (configErrors == null) {\n            configErrors = new ArrayList<>();\n        }\n        configErrors.add(error);\n    }\n\n    /**\n     * Adds a new processing error to the report.\n     *\n     * @param error\n     *            the error to add\n     */\n    public void addError(ProcessingError error) {\n        if (errors == null) {\n            errors = new ArrayList<>();\n        }\n        errors.add(error);\n    }\n\n    /**\n     * Merges the given report into this report. This might be necessary, if a\n     * summary over all violations is needed as PMD creates one report per file\n     * by default.\n     *\n     * @param r\n     *            the report to be merged into this.\n     * @see AbstractAccumulatingRenderer\n     */\n    public void merge(Report r) {\n        Iterator<ProcessingError> i = r.errors();\n        while (i.hasNext()) {\n            addError(i.next());\n        }\n        Iterator<ConfigurationError> ce = r.configErrors();\n        while (ce.hasNext()) {\n            addConfigError(ce.next());\n        }\n        Iterator<RuleViolation> v = r.iterator();\n        while (v.hasNext()) {\n            RuleViolation violation = v.next();\n            int index = Collections.binarySearch(violations, violation, RuleViolationComparator.INSTANCE);\n            violations.add(index < 0 ? -index - 1 : index, violation);\n            violationTree.addRuleViolation(violation);\n        }\n        Iterator<SuppressedViolation> s = r.getSuppressedRuleViolations().iterator();\n        while (s.hasNext()) {\n            suppressedRuleViolations.add(s.next());\n        }\n    }\n\n    public boolean isEmpty() {\n        return !violations.iterator().hasNext() && !hasErrors();\n    }\n\n    /**\n     * Checks whether any processing errors have been reported.\n     *\n     * @return <code>true</code> if there were any processing errors,\n     *         <code>false</code> otherwise\n     */\n    public boolean hasErrors() {\n        return errors != null && !errors.isEmpty();\n    }\n\n    /**\n     * Checks whether any configuration errors have been reported.\n     *\n     * @return <code>true</code> if there were any configuration errors,\n     *         <code>false</code> otherwise\n     */\n    public boolean hasConfigErrors() {\n        return configErrors != null && !configErrors.isEmpty();\n    }\n\n    /**\n     * Checks whether no violations have been reported.\n     *\n     * @return <code>true</code> if no violations have been reported,\n     *         <code>false</code> otherwise\n     */\n    public boolean treeIsEmpty() {\n        return !violationTree.iterator().hasNext();\n    }\n\n    /**\n     * Returns an iteration over the reported violations.\n     *\n     * @return an iterator\n     */\n    public Iterator<RuleViolation> treeIterator() {\n        return violationTree.iterator();\n    }\n\n    @Override\n    public Iterator<RuleViolation> iterator() {\n        return violations.iterator();\n    }\n\n    /**\n     * Returns an iterator of the reported processing errors.\n     *\n     * @return the iterator\n     */\n    public Iterator<ProcessingError> errors() {\n        return errors == null ? Collections.<ProcessingError>emptyIterator() : errors.iterator();\n    }\n\n    /**\n     * Returns an iterator of the reported configuration errors.\n     *\n     * @return the iterator\n     */\n    public Iterator<ConfigurationError> configErrors() {\n        return configErrors == null ? Collections.<ConfigurationError>emptyIterator() : configErrors.iterator();\n    }\n\n    /**\n     * The number of violations.\n     *\n     * @return number of violations.\n     */\n    public int treeSize() {\n        return violationTree.size();\n    }\n\n    /**\n     * The number of violations.\n     *\n     * @return number of violations.\n     */\n    public int size() {\n        return violations.size();\n    }\n\n    /**\n     * Mark the start time of the report. This is used to get the elapsed time\n     * in the end.\n     *\n     * @see #getElapsedTimeInMillis()\n     */\n    public void start() {\n        start = System.currentTimeMillis();\n    }\n\n    /**\n     * Mark the end time of the report. This is ued to get the elapsed time.\n     *\n     * @see #getElapsedTimeInMillis()\n     */\n    public void end() {\n        end = System.currentTimeMillis();\n    }\n\n    public long getElapsedTimeInMillis() {\n        return end - start;\n    }\n\n    public List<ThreadSafeReportListener> getListeners() {\n        return listeners;\n    }\n\n    /**\n     * Adds all given listeners to this report\n     *\n     * @param allListeners\n     *            the report listeners\n     */\n    public void addListeners(List<ThreadSafeReportListener> allListeners) {\n        listeners.addAll(allListeners);\n    }\n}\n",
        "filePathAfter": "pmd-core/src/main/java/net/sourceforge/pmd/renderers/TextColorRenderer.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.renderers;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\nimport org.apache.commons.lang3.StringUtils;\n\nimport net.sourceforge.pmd.PMD;\nimport net.sourceforge.pmd.Report;\nimport net.sourceforge.pmd.RuleViolation;\nimport net.sourceforge.pmd.properties.PropertyDescriptor;\nimport net.sourceforge.pmd.properties.PropertyFactory;\nimport net.sourceforge.pmd.util.NumericConstants;\n\n/**\n * <p>\n * A console renderer with optional color support under *nix systems.\n * </p>\n *\n * <pre>\n * * file: ./src/gilot/Test.java\n *     src:  Test.java:12\n *     rule: AtLeastOneConstructor\n *     msg:  Each class should declare at least one constructor\n *     code: public class Test\n *\n * * file: ./src/gilot/log/format/LogInterpreter.java\n *     src:  LogInterpreter.java:317\n *     rule: AvoidDuplicateLiterals\n *     msg:  The same String literal appears 4 times in this file; the first occurrence is on line 317\n *     code: logger.error( \"missing attribute 'app_arg' in rule '\" + ((Element)element.getParent()).getAttributeValue( \"name\" ) + \"'\" );\n *\n *     src:  LogInterpreter.java:317\n *     rule: AvoidDuplicateLiterals\n *     msg:  The same String literal appears 5 times in this file; the first occurrence is on line 317\n *     code: logger.error( \"missing attribute 'app_arg' in rule '\" + ((Element)element.getParent()).getAttributeValue( \"name\" ) + \"'\" );\n * * warnings: 3\n * </pre>\n * <p>\n * Colorization is turned on by supplying -D<b>pmd.color</b> - any value other\n * than '0' or 'false', enables color - including an empty value (''). <b>Nota\n * Bene:</b> colorization is atm only supported under *nix terminals accepting\n * ansi escape sequences, such as xterm, rxvt et cetera.\n * </p>\n */\npublic class TextColorRenderer extends AbstractAccumulatingRenderer {\n\n    public static final String NAME = \"textcolor\";\n\n    // What? TODO 7.0.0 Use a boolean property\n    // TODO should the \"textcolor\" renderer really support \"optional\" colors?\n    //   either use text or textcolor...\n    //   This property is really weird, the standard boolean properties\n    //   are false unless value is exactly \"true\", this one is true unless\n    //   \"false\" or \"0\"...\n    public static final PropertyDescriptor<String> COLOR = PropertyFactory.stringProperty(\"color\").desc(\"Enables colors with anything other than 'false' or '0'.\").defaultValue(\"yes\").build();\n    private static final String SYSTEM_PROPERTY_PMD_COLOR = \"pmd.color\";\n\n    /**\n     * Directory from where java was invoked.\n     */\n    private String pwd;\n\n    private String yellowBold = \"\";\n    private String whiteBold = \"\";\n    private String redBold = \"\";\n    private String red = \"\";\n    private String cyan = \"\";\n    private String green = \"\";\n\n    private String colorReset = \"\";\n\n    public TextColorRenderer() {\n        // This Renderer was originally submitted by Adrian Papari and was\n        // called the \"PapariTextRenderer\" pre-PMD 5.0.\n        super(NAME, \"Text format, with color support (requires ANSI console support, e.g. xterm, rxvt, etc.).\");\n        definePropertyDescriptor(COLOR);\n    }\n\n    @Override\n    public String defaultFileExtension() {\n        return \"txt\";\n    }\n\n    /**\n     * Enables colors on *nix systems - not windows. Color support depends on\n     * the pmd.color property, which should be set with the -D option during\n     * execution - a set value other than 'false' or '0' enables color.\n     * <p/>\n     * btw, is it possible to do this on windows (ie; console colors)?\n     */\n    private void initializeColorsIfSupported() {\n        if (isPropertyEnabled(getProperty(COLOR)) || isPropertyEnabled(System.getProperty(SYSTEM_PROPERTY_PMD_COLOR))) {\n            this.yellowBold = \"\\u001B[1;33m\";\n            this.whiteBold = \"\\u001B[1;37m\";\n            this.redBold = \"\\u001B[1;31m\";\n            this.red = \"\\u001B[0;31m\";\n            this.green = \"\\u001B[0;32m\";\n            this.cyan = \"\\u001B[0;36m\";\n\n            this.colorReset = \"\\u001B[0m\";\n        }\n    }\n\n    private boolean isPropertyEnabled(String property) {\n        return property != null && !(\"0\".equals(property) || \"false\".equalsIgnoreCase(property));\n    }\n\n    @Override\n    public void end() throws IOException {\n        StringBuilder buf = new StringBuilder(500);\n        buf.append(PMD.EOL);\n        initializeColorsIfSupported();\n        String lastFile = null;\n        int numberOfErrors = 0;\n        int numberOfWarnings = 0;\n\n        for (Iterator<RuleViolation> i = report.iterator(); i.hasNext();) {\n            buf.setLength(0);\n            numberOfWarnings++;\n            RuleViolation rv = i.next();\n            String nextFile = determineFileName(rv.getFilename());\n            if (!nextFile.equals(lastFile)) {\n                lastFile = nextFile;\n                buf.append(this.yellowBold + \"*\" + this.colorReset + \" file: \" + this.whiteBold\n                        + this.getRelativePath(lastFile) + this.colorReset + PMD.EOL);\n            }\n            buf.append(\n                    this.green + \"    src:  \" + this.cyan + lastFile.substring(lastFile.lastIndexOf(File.separator) + 1)\n                            + this.colorReset + \":\" + this.cyan + rv.getBeginLine()\n                            + (rv.getEndLine() == -1 ? \"\" : \":\" + rv.getEndLine()) + this.colorReset + PMD.EOL);\n            buf.append(this.green + \"    rule: \" + this.colorReset + rv.getRule().getName() + PMD.EOL);\n            buf.append(this.green + \"    msg:  \" + this.colorReset + rv.getDescription() + PMD.EOL);\n            buf.append(this.green + \"    code: \" + this.colorReset + this.getLine(lastFile, rv.getBeginLine()) + PMD.EOL\n                    + PMD.EOL);\n            writer.write(buf.toString());\n        }\n        writer.write(PMD.EOL + PMD.EOL);\n        writer.write(\"Summary:\" + PMD.EOL + PMD.EOL);\n        for (Map.Entry<String, Integer> entry : getCountSummary(report).entrySet()) {\n            buf.setLength(0);\n            String key = entry.getKey();\n            buf.append(key).append(\" : \").append(entry.getValue()).append(PMD.EOL);\n            writer.write(buf.toString());\n        }\n\n        for (Iterator<Report.ProcessingError> i = report.errors(); i.hasNext();) {\n            buf.setLength(0);\n            numberOfErrors++;\n            Report.ProcessingError error = i.next();\n            String nextFile = determineFileName(error.getFile());\n            if (!nextFile.equals(lastFile)) {\n                lastFile = nextFile;\n                buf.append(this.redBold + \"*\" + this.colorReset + \" file: \" + this.whiteBold\n                        + this.getRelativePath(lastFile) + this.colorReset + PMD.EOL);\n            }\n            buf.append(this.green + \"    err:  \" + this.cyan + error.getMsg() + this.colorReset + PMD.EOL)\n                .append(this.red).append(error.getDetail()).append(colorReset).append(PMD.EOL).append(PMD.EOL);\n            writer.write(buf.toString());\n        }\n\n        for (Iterator<Report.ConfigurationError> i = report.configErrors(); i.hasNext();) {\n            buf.setLength(0);\n            numberOfErrors++;\n            Report.ConfigurationError error = i.next();\n            buf.append(this.redBold + \"*\" + this.colorReset + \" rule: \" + this.whiteBold\n                    + error.rule().getName() + this.colorReset + PMD.EOL);\n            buf.append(this.green + \"    err:  \" + this.cyan + error.issue() + this.colorReset + PMD.EOL + PMD.EOL);\n            writer.write(buf.toString());\n        }\n\n        // adding error message count, if any\n        if (numberOfErrors > 0) {\n            writer.write(this.redBold + \"*\" + this.colorReset + \" errors:   \" + this.whiteBold + numberOfErrors\n                             + this.colorReset + PMD.EOL);\n        }\n        writer.write(this.yellowBold + \"*\" + this.colorReset + \" warnings: \" + this.whiteBold + numberOfWarnings\n                         + this.colorReset + PMD.EOL);\n    }\n\n\n    /**\n     * Calculate a summary of violation counts per fully classified class name.\n     *\n     * @return violations per class name\n     */\n    private static Map<String, Integer> getCountSummary(Report report) {\n        Map<String, Integer> summary = new HashMap<>();\n        for (RuleViolation rv : report) {\n            String key = keyFor(rv);\n            if (key.isEmpty()) {\n                continue;\n            }\n            Integer o = summary.get(key);\n            summary.put(key, o == null ? NumericConstants.ONE : o + 1);\n        }\n        return summary;\n    }\n\n    private static String keyFor(RuleViolation rv) {\n        return StringUtils.isNotBlank(rv.getPackageName()) ? rv.getPackageName() + '.' + rv.getClassName() : \"\";\n    }\n\n\n    /**\n     * Retrieves the requested line from the specified file.\n     *\n     * @param sourceFile the java or cpp source file\n     * @param line       line number to extract\n     *\n     * @return a trimmed line of source code\n     */\n    private String getLine(String sourceFile, int line) {\n        String code = null;\n        try (BufferedReader br = new BufferedReader(getReader(sourceFile))) {\n            for (int i = 0; line > i; i++) {\n                String txt = br.readLine();\n                code = txt == null ? \"\" : txt.trim();\n            }\n        } catch (IOException ioErr) {\n            ioErr.printStackTrace();\n        }\n        return code;\n    }\n\n    protected Reader getReader(String sourceFile) throws FileNotFoundException {\n        try {\n            return Files.newBufferedReader(new File(sourceFile).toPath(), Charset.defaultCharset());\n        } catch (IOException e) {\n            FileNotFoundException ex = new FileNotFoundException(sourceFile);\n            ex.initCause(e);\n            throw ex;\n        }\n    }\n\n    /**\n     * Attempts to determine the relative path to the file. If relative path\n     * cannot be found, the original path is returnedi, ie - the current path\n     * for the supplied file.\n     *\n     * @param fileName\n     *            well, the file with its original path.\n     * @return the relative path to the file\n     */\n    private String getRelativePath(String fileName) {\n        String relativePath;\n\n        // check if working directory need to be assigned\n        if (pwd == null) {\n            try {\n                this.pwd = new File(\".\").getCanonicalPath();\n            } catch (IOException ioErr) {\n                // to avoid further error\n                this.pwd = \"\";\n            }\n        }\n\n        // make sure that strings match before doing any substring-ing\n        if (fileName.indexOf(this.pwd) == 0) {\n            relativePath = \".\" + fileName.substring(this.pwd.length());\n\n            // remove current dir occuring twice - occurs if . was supplied as\n            // path\n            if (relativePath.startsWith(\".\" + File.separator + \".\" + File.separator)) {\n                relativePath = relativePath.substring(2);\n            }\n        } else {\n            // this happens when pmd's supplied argument deviates from the pwd\n            // 'branch' (god knows this terminolgy - i hope i make some sense).\n            // for instance, if supplied=/usr/lots/of/src and\n            // pwd=/usr/lots/of/shared/source\n            // TODO: a fix to get relative path?\n            relativePath = fileName;\n        }\n\n        return relativePath;\n    }\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.dfa.report.ClassNode#getClassName\n methodBody: public String getClassName() {\nreturn className;\n}",
            "methodSignature: net.sourceforge.pmd.lang.dfa.report.PackageNode#getPackageName\n methodBody: public String getPackageName() {\nreturn this.packageName;\n}"
        ],
        "sourceCodeAfterRefactoring": "private static String keyFor(RuleViolation rv) {\n        return StringUtils.isNotBlank(rv.getPackageName()) ? rv.getPackageName() + '.' + rv.getClassName() : \"\";\n    }",
        "diffSourceCode": "-  180:     private static String keyFor(RuleViolation rv) {\n-  181: \n-  182:         return StringUtils.isNotBlank(rv.getPackageName()) ? rv.getPackageName() + '.' + rv.getClassName() : \"\";\n-  183:     }\n-  212:         for (RuleViolation rv : violations) {\n-  213:             String name = rv.getRule().getName();\n-  214:             if (!summary.containsKey(name)) {\n+  180:             buf.append(this.green + \"    err:  \" + this.cyan + error.issue() + this.colorReset + PMD.EOL + PMD.EOL);\n+  181:             writer.write(buf.toString());\n+  182:         }\n+  183: \n+  212:     private static String keyFor(RuleViolation rv) {\n+  213:         return StringUtils.isNotBlank(rv.getPackageName()) ? rv.getPackageName() + '.' + rv.getClassName() : \"\";\n+  214:     }\n",
        "uniqueId": "7db6f3809c07c93729a8183cf80c19a9643d0837_180_183__212_214",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 13,
                "covered": 6
            },
            "BRANCH": {
                "missed": 1,
                "covered": 1
            },
            "LINE": {
                "missed": 0,
                "covered": 1
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic getPrimitive(kind PrimitiveTypeKind) : JPrimitiveType extracted from public getClassSymbol(klass Class<?>) : JClassSymbol in class net.sourceforge.pmd.lang.java.types.TypeSystem",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/impl/reflect/ReflectionSymFactory.java",
                "startLine": 58,
                "endLine": 82,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeSystem.java",
                "startLine": 337,
                "endLine": 359,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeSystem.java",
                "startLine": 586,
                "endLine": 596,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n    @Nullable\n    public JClassSymbol getClassSymbol(@Nullable Class<?> klass) {\n        if (klass == null) {\n            return null;\n        }\n\n        Map<Class<?>, JClassSymbol> shared = getCommonSyms();\n        if (shared.containsKey(klass)) {\n            return shared.get(klass);\n        }\n\n        if (klass.getEnclosingClass() != null) {\n            JClassSymbol enclosing = getClassSymbol(klass.getEnclosingClass());\n            assert enclosing != null;\n            return createWithEnclosing(this, enclosing, klass);\n        }\n\n        if (klass.isArray()) {\n            JClassSymbol component = getClassSymbol(klass.getComponentType());\n            return makeArraySymbol(component);\n        }\n\n        return createOuterClass(this, klass);\n    }",
        "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/internal/impl/reflect/ReflectionSymFactory.java",
        "isPureRefactoring": true,
        "commitId": "2449f6404ec001dde8fe782febb993f262a5ddc1",
        "packageNameBefore": "net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect",
        "classNameBefore": "net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectionSymFactory",
        "methodNameBefore": "net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectionSymFactory#getClassSymbol",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectedClassImpl#getEnclosingClass\n methodBody: public JClassSymbol getEnclosingClass() {\nreturn enclosing;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.SymbolFactory#getClassSymbol\n methodBody: JClassSymbol getClassSymbol(@Nullable T klass);\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.UnresolvedClassImpl#getEnclosingClass\n methodBody: public JClassSymbol getEnclosingClass() {\nreturn enclosing;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectionSymFactory#getClassSymbol\n methodBody: public JClassSymbol getClassSymbol(@Nullable Class<?> klass) {\nif(klass == null){return null;\n}Map<Class<?>,JClassSymbol> shared=getCommonSyms();\nif(shared.containsKey(klass)){return shared.get(klass);\n}if(klass.getEnclosingClass() != null){JClassSymbol enclosing=getClassSymbol(klass.getEnclosingClass());\nassert enclosing != null;\nreturn createWithEnclosing(this,enclosing,klass);\n}if(klass.isArray()){JClassSymbol component=getClassSymbol(klass.getComponentType());\nreturn makeArraySymbol(component);\n}return createOuterClass(this,klass);\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectedClassImpl#createWithEnclosing\n methodBody: static ReflectedClassImpl createWithEnclosing(ReflectionSymFactory symbolFactory,\n                                                  @Nullable JClassSymbol enclosing,\n                                                  Class<?> myClass) {\nreturn new ReflectedClassImpl(symbolFactory,enclosing,myClass);\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.UnresolvedClassImpl#isArray\n methodBody: public boolean isArray() {\nreturn false;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.AbstractReflectedExecutableSymbol#getEnclosingClass\n methodBody: public final JClassSymbol getEnclosingClass() {\nreturn owner;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectedClassImpl#createOuterClass\n methodBody: static ReflectedClassImpl createOuterClass(ReflectionSymFactory symbolFactory, Class<?> myClass) {\nreturn new ReflectedClassImpl(symbolFactory,myClass);\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.ImplicitMemberSymbols.FakeExecutableSymBase#getEnclosingClass\n methodBody: public @NonNull JClassSymbol getEnclosingClass() {\nreturn owner;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.ArraySymbolImpl#isArray\n methodBody: public boolean isArray() {\nreturn true;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectedClassImpl#isArray\n methodBody: public boolean isArray() {\nreturn false;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.ast.AstClassSym#getEnclosingClass\n methodBody: public @Nullable JClassSymbol getEnclosingClass() {\nif(enclosing instanceof JClassSymbol){return (JClassSymbol)enclosing;\n}if(enclosing instanceof JExecutableSymbol){return enclosing.getEnclosingClass();\n}assert enclosing == null;\nreturn null;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.ast.AstFieldSym#getEnclosingClass\n methodBody: public @NonNull JClassSymbol getEnclosingClass() {\nreturn owner;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.ArraySymbolImpl#getEnclosingClass\n methodBody: public JClassSymbol getEnclosingClass() {\nreturn null;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.ImplicitMemberSymbols.FakeFieldSym#getEnclosingClass\n methodBody: public @NonNull JClassSymbol getEnclosingClass() {\nreturn owner;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.JTypeParameterSymbol#getEnclosingClass\n methodBody: default JClassSymbol getEnclosingClass() {\nJTypeParameterOwnerSymbol ownerSymbol=getDeclaringSymbol();\nreturn ownerSymbol instanceof JClassSymbol ? (JClassSymbol)ownerSymbol : ownerSymbol.getEnclosingClass();\n}\nmethodSignature: net.sourceforge.pmd.typeresolution.testdata.LocalGenericClass.localClassInGeneric.MyLocalClass#get\n methodBody: public Optional<T> get() {\nreturn Optional.empty();\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.JAccessibleElementSymbol#getEnclosingClass\n methodBody: JClassSymbol getEnclosingClass();\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.SymbolFactory#makeArraySymbol\n methodBody: default JClassSymbol makeArraySymbol(JTypeDeclSymbol component) {\nreturn new ArraySymbolImpl(this,component);\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.JClassSymbol#isArray\n methodBody: boolean isArray();\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.ast.AbstractAstExecSymbol#getEnclosingClass\n methodBody: public @NonNull JClassSymbol getEnclosingClass() {\nreturn owner;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectionSymFactory#getCommonSyms\n methodBody: private static Map<Class<?>, JClassSymbol> getCommonSyms() {\nMap<Class<?>,JClassSymbol> shared=commonSymbols;\nif(shared == null){synchronized(ReflectionSymFactory.class){shared=commonSymbols;\nif(shared == null){shared=initCommonSyms();\ncommonSymbols=shared;\n}}}return shared;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectedFieldImpl#getEnclosingClass\n methodBody: public JClassSymbol getEnclosingClass() {\nreturn owner;\n}\nmethodSignature: net.sourceforge.pmd.typeresolution.testdata.LocalGenericClass.MySupplier#get\n methodBody: S get();\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.ast.AstClassSym#isArray\n methodBody: public boolean isArray() {\nreturn false;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.JExecutableSymbol#getEnclosingClass\n methodBody: JClassSymbol getEnclosingClass();",
        "classSignatureBefore": "public final class ReflectionSymFactory implements SymbolFactory<Class<?>> ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectionSymFactory#getClassSymbol"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectionSymFactory"
        ],
        "classSignatureBeforeSet": [
            "public final class ReflectionSymFactory implements SymbolFactory<Class<?>> "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect;\n\n\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.BOOLEAN_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.BOXED_BOOLEAN_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.BOXED_BYTE_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.BOXED_CHAR_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.BOXED_DOUBLE_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.BOXED_FLOAT_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.BOXED_INT_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.BOXED_LONG_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.BOXED_SHORT_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.BOXED_VOID_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.BYTE_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.CHAR_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.CLONEABLE_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.DOUBLE_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.ENUM_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.FLOAT_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.INT_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.ITERABLE_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.LONG_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.OBJECT_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.SERIALIZABLE_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.SHORT_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.STRING_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectSymInternals.VOID_SYM;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectedClassImpl.createOuterClass;\nimport static net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectedClassImpl.createWithEnclosing;\n\nimport java.io.Serializable;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport net.sourceforge.pmd.lang.java.symbols.JClassSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.internal.impl.SymbolFactory;\n\n/**\n * Symbol factory building type symbols from {@link Class} instances.\n * Reflected symbol implementations carry an instance of this around,\n * so as to allow caching recently accessed symbols later on.\n */\npublic final class ReflectionSymFactory implements SymbolFactory<Class<?>> {\n\n    /**\n     * Lazy initialized to avoid class init cycle, because\n     * {@link SymbolFactory} creates reflected symbols.\n     */\n    private static Map<Class<?>, JClassSymbol> commonSymbols;\n\n    @Override\n    @Nullable\n    public JClassSymbol getClassSymbol(@Nullable Class<?> klass) {\n        if (klass == null) {\n            return null;\n        }\n\n        Map<Class<?>, JClassSymbol> shared = getCommonSyms();\n        if (shared.containsKey(klass)) {\n            return shared.get(klass);\n        }\n\n        if (klass.getEnclosingClass() != null) {\n            JClassSymbol enclosing = getClassSymbol(klass.getEnclosingClass());\n            assert enclosing != null;\n            return createWithEnclosing(this, enclosing, klass);\n        }\n\n        if (klass.isArray()) {\n            JClassSymbol component = getClassSymbol(klass.getComponentType());\n            return makeArraySymbol(component);\n        }\n\n        return createOuterClass(this, klass);\n    }\n\n    private static Map<Class<?>, JClassSymbol> getCommonSyms() {\n        Map<Class<?>, JClassSymbol> shared = commonSymbols;\n        if (shared == null) {\n            synchronized (ReflectionSymFactory.class) {\n                shared = commonSymbols;\n                if (shared == null) {\n                    shared = initCommonSyms();\n                    commonSymbols = shared;\n                }\n            }\n        }\n        return shared;\n    }\n\n    private static void putStr(Map<Class<?>, JClassSymbol> byClass,\n                               Class<?> booleanClass,\n                               JClassSymbol booleanSym) {\n        byClass.put(booleanClass, booleanSym);\n    }\n\n\n    private static Map<Class<?>, JClassSymbol> initCommonSyms() {\n        // consider putting whole java.lang + java.util in there ?\n\n        Map<Class<?>, JClassSymbol> specials = new HashMap<>();\n\n        putStr(specials, Object.class, OBJECT_SYM);\n\n        putStr(specials, boolean.class, BOOLEAN_SYM);\n        putStr(specials, byte.class, BYTE_SYM);\n        putStr(specials, char.class, CHAR_SYM);\n        putStr(specials, double.class, DOUBLE_SYM);\n        putStr(specials, float.class, FLOAT_SYM);\n        putStr(specials, int.class, INT_SYM);\n        putStr(specials, long.class, LONG_SYM);\n        putStr(specials, short.class, SHORT_SYM);\n        putStr(specials, void.class, VOID_SYM);\n\n        putStr(specials, Cloneable.class, CLONEABLE_SYM);\n        putStr(specials, Serializable.class, SERIALIZABLE_SYM);\n\n        putStr(specials, Boolean.class, BOXED_BOOLEAN_SYM);\n        putStr(specials, Byte.class, BOXED_BYTE_SYM);\n        putStr(specials, Character.class, BOXED_CHAR_SYM);\n        putStr(specials, Double.class, BOXED_DOUBLE_SYM);\n        putStr(specials, Float.class, BOXED_FLOAT_SYM);\n        putStr(specials, Integer.class, BOXED_INT_SYM);\n        putStr(specials, Long.class, BOXED_LONG_SYM);\n        putStr(specials, Short.class, BOXED_SHORT_SYM);\n        putStr(specials, Void.class, BOXED_VOID_SYM);\n\n        putStr(specials, Iterable.class, ITERABLE_SYM);\n        putStr(specials, Enum.class, ENUM_SYM);\n        putStr(specials, String.class, STRING_SYM);\n\n        return Collections.unmodifiableMap(specials);\n    }\n\n}\n",
        "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeSystem.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.types;\n\nimport static java.util.Collections.emptyList;\nimport static net.sourceforge.pmd.util.CollectionUtil.immutableSetOf;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.EnumMap;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.function.Function;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.internal.util.AssertionUtil;\nimport net.sourceforge.pmd.lang.java.symbols.JClassSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JExecutableSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JTypeDeclSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JTypeParameterSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.SymbolResolver;\nimport net.sourceforge.pmd.lang.java.symbols.internal.impl.SymbolFactory;\nimport net.sourceforge.pmd.lang.java.symbols.internal.impl.asm.AsmSymbolResolver;\nimport net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectedSymbols;\nimport net.sourceforge.pmd.lang.java.types.JPrimitiveType.PrimitiveTypeKind;\nimport net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar;\n\n/**\n * Root context object for type analysis. Type systems own a {@link SymbolFactory},\n * which creates and caches symbols. Methods of this class promote symbols\n * to types, and compose types together. {@link TypeOps} and {@link TypeConversion}\n * have some more operations on types.\n *\n * <p>Some special types are presented as constant fields, eg {@link #OBJECT}\n * or {@link #NULL_TYPE}. These are always comparable by reference.\n */\npublic final class TypeSystem {\n\n    /** Top type of the reference type system. */\n    public final JClassType OBJECT;\n\n    /**\n     * The bottom type of the reference type system. This is named\n     * the <i>null type</i> in the JLS and is not denotable in Java\n     * programs.\n     *\n     * <p>This implementation uses this as the type of the 'null' literal.\n     */\n    public final JTypeMirror NULL_TYPE = new JTypeMirror() {\n\n        @Override\n        public JTypeMirror subst(Function<? super SubstVar, ? extends @NonNull JTypeMirror> subst) {\n            return this;\n        }\n\n        @Override\n        public TypeSystem getTypeSystem() {\n            return TypeSystem.this;\n        }\n\n        @Override\n        public @Nullable JClassSymbol getSymbol() {\n            return null;\n        }\n\n        @Override\n        public <T, P> T acceptVisitor(JTypeVisitor<T, P> visitor, P p) {\n            return visitor.visitNullType(this, p);\n        }\n\n        @Override\n        public String toString() {\n            return \"null\";\n        }\n    };\n\n\n    // primitives\n    public final JPrimitiveType BOOLEAN;\n    public final JPrimitiveType CHAR;\n    public final JPrimitiveType BYTE;\n    public final JPrimitiveType SHORT;\n    public final JPrimitiveType INT;\n    public final JPrimitiveType LONG;\n    public final JPrimitiveType FLOAT;\n    public final JPrimitiveType DOUBLE;\n\n    /**\n     * The set of all primitive types. See {@link #getPrimitive(PrimitiveTypeKind)}.\n     */\n    public final Set<JPrimitiveType> allPrimitives;\n    private final EnumMap<PrimitiveTypeKind, JPrimitiveType> primitivesByKind;\n\n    /**\n     * A constant to represent the normal absence of a type. The\n     * primitive {@code void.class} represents that type, and this\n     * is the return type of a void method.\n     *\n     * <p>Note that the type of the class literal {@code void.class}\n     * is {@code Class<java.lang.Void>}, not NO_TYPE.\n     */\n    public final JTypeMirror NO_TYPE;\n\n    /**\n     * A constant to represent an unresolved type. This means, that resolution\n     * was attempted but failed and shouldn't be tried again.\n     */\n    public final JTypeMirror UNRESOLVED_TYPE;\n\n    /**\n     * Sentinel value for an unresolved method. This type corresponds to\n     * a method declaration in the type {@link #UNRESOLVED_TYPE},\n     * returning {@link #UNRESOLVED_TYPE}.\n     */\n    // TODO it doesn't need to be declared in UNRESOLVED_TYPE\n    public final JMethodSig UNRESOLVED_METHOD = new UnresolvedMethodSig(this);\n\n    /**\n     * A constant to represent a typing error. This would have been\n     * reported by a compiler.\n     */\n    public final JTypeMirror ERROR_TYPE = new SentinelType(this, \"/*error*/\");\n\n    /*\n     * Common, non-special types.\n     */\n\n    /** The unbounded wildcard, \"?\". */\n    public final JWildcardType UNBOUNDED_WILD;\n\n    // array supertypes\n    public final JClassType CLONEABLE;\n    public final JClassType SERIALIZABLE;\n\n    /**\n     * This is the boxed type of {@code Void.class}, not to be confused with\n     * {@code void.class}, which in this framework is represented by\n     * {@link #NO_TYPE}.\n     */\n    public final JClassType BOXED_VOID;\n\n\n    private final SymbolFactory symbolFactory;\n\n    /** Contains special types, that must be shared to be comparable by reference. */\n    private final Map<JTypeDeclSymbol, JTypeMirror> sharedTypes;\n    // test only\n    final AsmSymbolResolver resolver;\n\n    /**\n     * Builds a new type system. Its public fields will be initialized\n     * with fresh types, unrelated to other types.\n     *\n     * @param bootstrapResourceLoader Classloader used to resolve class files\n     *                                to populate the fields of the new type\n     *                                system\n     */\n    public TypeSystem(ClassLoader bootstrapResourceLoader) {\n        this.resolver = new AsmSymbolResolver(this, bootstrapResourceLoader);\n        this.symbolFactory = new SymbolFactory(this);\n\n        // initialize primitives. their constructor also initializes their box + box erasure\n\n        BOOLEAN = createPrimitive(PrimitiveTypeKind.BOOLEAN, Boolean.class);\n        CHAR = createPrimitive(PrimitiveTypeKind.CHAR, Character.class);\n        BYTE = createPrimitive(PrimitiveTypeKind.BYTE, Byte.class);\n        SHORT = createPrimitive(PrimitiveTypeKind.SHORT, Short.class);\n        INT = createPrimitive(PrimitiveTypeKind.INT, Integer.class);\n        LONG = createPrimitive(PrimitiveTypeKind.LONG, Long.class);\n        FLOAT = createPrimitive(PrimitiveTypeKind.FLOAT, Float.class);\n        DOUBLE = createPrimitive(PrimitiveTypeKind.DOUBLE, Double.class);\n\n        // this relies on the fact that setOf always returns immutable sets\n        BOOLEAN.superTypes = immutableSetOf(BOOLEAN);\n        CHAR.superTypes = immutableSetOf(CHAR, INT, LONG, FLOAT, DOUBLE);\n        BYTE.superTypes = immutableSetOf(BYTE, SHORT, INT, LONG, FLOAT, DOUBLE);\n        SHORT.superTypes = immutableSetOf(SHORT, INT, LONG, FLOAT, DOUBLE);\n        INT.superTypes = immutableSetOf(INT, LONG, FLOAT, DOUBLE);\n        LONG.superTypes = immutableSetOf(LONG, FLOAT, DOUBLE);\n        FLOAT.superTypes = immutableSetOf(FLOAT, DOUBLE);\n        DOUBLE.superTypes = immutableSetOf(DOUBLE);\n\n        this.allPrimitives = immutableSetOf(BOOLEAN, CHAR, BYTE, SHORT, INT, LONG, FLOAT, DOUBLE);\n        this.primitivesByKind = new EnumMap<>(PrimitiveTypeKind.class);\n        primitivesByKind.put(PrimitiveTypeKind.BOOLEAN, BOOLEAN);\n        primitivesByKind.put(PrimitiveTypeKind.CHAR, CHAR);\n        primitivesByKind.put(PrimitiveTypeKind.BYTE, BYTE);\n        primitivesByKind.put(PrimitiveTypeKind.SHORT, SHORT);\n        primitivesByKind.put(PrimitiveTypeKind.INT, INT);\n        primitivesByKind.put(PrimitiveTypeKind.LONG, LONG);\n        primitivesByKind.put(PrimitiveTypeKind.FLOAT, FLOAT);\n        primitivesByKind.put(PrimitiveTypeKind.DOUBLE, DOUBLE);\n\n        JClassSymbol unresolvedTypeSym = symbolFactory.makeUnresolvedReference(\"/*unresolved*/\", 0);\n        UNRESOLVED_TYPE = new SentinelType(this, \"/*unresolved*/\") {\n            @Override\n            public JTypeDeclSymbol getSymbol() {\n                return unresolvedTypeSym;\n            }\n        };\n\n        JClassSymbol primitiveVoidSym = ReflectedSymbols.getClassSymbol(symbolFactory, void.class);\n        assert primitiveVoidSym != null : \"void\";\n        NO_TYPE = new SentinelType(this, \"void\") {\n            @Override\n            public JTypeDeclSymbol getSymbol() {\n                return primitiveVoidSym;\n            }\n        };\n\n        // reuse instances for common types\n\n        // this map is vital to preserve some of the invariants of\n        // the framework, e.g., that primitive types are never represented\n        // by a ClassType, or that OBJECT is unique\n\n        // this is only appropriate for non-generic types\n\n        Map<JClassSymbol, JTypeMirror> shared = new HashMap<>();\n\n        OBJECT = addSpecial(Object.class, shared);\n        SERIALIZABLE = addSpecial(Serializable.class, shared);\n        CLONEABLE = addSpecial(Cloneable.class, shared);\n        BOXED_VOID = addSpecial(Void.class, shared);\n\n        shared.put(primitiveVoidSym, NO_TYPE);\n        shared.put(unresolvedTypeSym, UNRESOLVED_TYPE);\n\n        for (JPrimitiveType prim : allPrimitives) {\n            // primitives have a special implementation for their box\n            shared.put(prim.getSymbol(), prim);\n            shared.put(prim.box().getSymbol(), prim.box());\n        }\n\n        // make it really untouchable\n        this.sharedTypes = Collections.unmodifiableMap(new HashMap<>(shared));\n\n        UNBOUNDED_WILD = new WildcardTypeImpl(this, true, OBJECT);\n    }\n\n    @SuppressWarnings(\"IncompleteCopyConstructor\")\n    private TypeSystem(TypeSystem other) {\n        // create a new symbol factory, with an independent cache.\n        this.symbolFactory = new SymbolFactory(this);\n\n        this.resolver = other.resolver;\n        this.sharedTypes = other.sharedTypes;\n\n        this.OBJECT = other.OBJECT;\n        this.BOOLEAN = other.BOOLEAN;\n        this.CHAR = other.CHAR;\n        this.BYTE = other.BYTE;\n        this.SHORT = other.SHORT;\n        this.INT = other.INT;\n        this.LONG = other.LONG;\n        this.FLOAT = other.FLOAT;\n        this.DOUBLE = other.DOUBLE;\n        this.NO_TYPE = other.NO_TYPE;\n        this.allPrimitives = other.allPrimitives;\n        this.primitivesByKind = other.primitivesByKind;\n\n        this.UNRESOLVED_TYPE = other.UNRESOLVED_TYPE;\n        this.UNBOUNDED_WILD = other.UNBOUNDED_WILD;\n        this.CLONEABLE = other.CLONEABLE;\n        this.SERIALIZABLE = other.SERIALIZABLE;\n        this.BOXED_VOID = other.BOXED_VOID;\n    }\n\n    /**\n     * Returns a new, distinct type system, which caches symbols independently\n     * of this one. Constants such as {@link #INT} or {@link #OBJECT} are\n     * shared between this type system and all the sub-systems it spawns.\n     *\n     * <p>This provides a simple mechanism to localize cached symbols.\n     * Each file gets its own \"scope\", which, when garbage-collected,\n     * reclaims all symbols cached for the file. This also avoids concurrency\n     * issues.\n     *\n     * @return A new type system, based on this one.\n     */\n    public TypeSystem newScope() {\n        return new TypeSystem(this);\n    }\n\n    /**\n     * Returns the symbol factory associated with this type system.\n     * This is internal API, symbols are low-level abstractions that\n     * should not be created manually.\n     */\n    @InternalApi\n    public SymbolFactory symbols() {\n        return symbolFactory;\n    }\n\n    /**\n     * Returns the bootstrap symbol resolver. Concrete analysis passes\n     * may decorate this with different resolvers.\n     */\n    public SymbolResolver bootstrapResolver() {\n        return resolver;\n    }\n\n    // helpers for the constructor, cannot use typeOf, only for trusted types\n\n    private JClassType addSpecial(Class<?> klass, Map<JClassSymbol, JTypeMirror> shared) {\n        JClassSymbol sym = getBootStrapSymbol(klass);\n        JClassType nonErased = new ClassTypeImpl(this, sym, emptyList(), false);\n        shared.put(sym, nonErased);\n        return nonErased;\n    }\n\n    private JClassSymbol getBootStrapSymbol(Class<?> clazz) {\n        AssertionUtil.requireParamNotNull(\"clazz\", clazz);\n        JClassSymbol sym = resolver.resolveClassFromBinaryName(clazz.getName());\n        return Objects.requireNonNull(sym, \"sym\");\n    }\n\n    @NonNull\n    private JPrimitiveType createPrimitive(PrimitiveTypeKind kind, Class<?> box) {\n        return new JPrimitiveType(this, kind, new PrimitiveSymbol(this, kind), getBootStrapSymbol(box));\n    }\n\n\n    // type creation routines\n\n    /**\n     * Returns the class symbol for the given reflected class. This asks\n     * the classloader of this type system, but never returns null. Returns\n     * null if the parameter is null.\n     *\n     * @param clazz Class\n     */\n    @Nullable\n    public JClassSymbol getClassSymbol(@Nullable Class<?> clazz) {\n        if (clazz == null) {\n            return null;\n        } else if (clazz.isPrimitive()) {\n            return getPrimitive(PrimitiveTypeKind.fromName(clazz.getName())).getSymbol();\n        } else if (clazz.isArray()) {\n            return symbols().makeArraySymbol(getClassSymbol(clazz.getComponentType()));\n        }\n\n        JClassSymbol classLoaderPreferred = resolver.resolveClassFromBinaryName(clazz.getName());\n        if (classLoaderPreferred != null) {\n            return classLoaderPreferred;\n        }\n        return ReflectedSymbols.getClassSymbol(symbols(), clazz);\n    }\n\n    /**\n     * Returns a type mirror for the given symbol. If the symbol declares\n     * type parameters, then the resulting type is raw (differs from the\n     * behaviour of {@link #declaration(JClassSymbol)}), meaning all its\n     * supertypes are erased.\n     *\n     * <p>If the symbol is a {@link JTypeParameterSymbol type parameter},\n     * returns a {@link JTypeVar}.\n     *\n     * <p>If the symbol is a {@link JClassSymbol}, then:\n     * <ul>\n     * <li>If it represents a primitive type, the corresponding {@link JPrimitiveType}\n     * is returned (one of {@link #INT}, {@link #CHAR}, etc.).\n     * <li>If it represents an array type, a new {@link JArrayType} is\n     * returned. Note that the component type will always be erased;\n     * creating a generic array type should instead be done with\n     * {@link #arrayType(JTypeMirror, int)}.\n     * <li>If it represents a class or interface type, a {@link JClassType}\n     * is returned.\n     * <ul>\n     *     <li>If the parameter {@code isErased} is true, then the type\n     *     will be {@linkplain JClassType#hasErasedSuperTypes() erased},\n     *     which means all its generic supertypes are erased. In particular,\n     *     if the symbol declares type parameters itself, then it will be a\n     *     {@linkplain JClassType#isRaw() raw type}.\n     *     <li>Otherwise, the generic supertypes are preserved. In particular,\n     *     if the symbol declares type parameters itself, then it will\n     *     be a {@linkplain JClassType#isGenericTypeDeclaration() generic type declaration}.\n     * </ul>\n     * If the symbol is a non-static member of another class, then the given\n     * type's {@linkplain JClassType#getEnclosingType() enclosing type} is\n     * created, applying the above rules about erasure recursively. A type\n     * is either completely erased, or completely parameterized.\n     * </li>\n     * </ul>\n     *\n     * @param symbol   Symbol for the type declaration\n     * @param isErased Whether the type should be consider erased, if it\n     *                 represents a class or interface type. This does not\n     *                 erase type variables, or array types for that matter.\n     *\n     * @throws NullPointerException if the symbol is null\n     */\n    public JTypeMirror typeOf(JTypeDeclSymbol symbol, boolean isErased) {\n        Objects.requireNonNull(symbol, \"Argument shouldn't be null\");\n\n        // takes care of primitives, and constants like OBJECT or UNRESOLVED_TYPE\n        JTypeMirror common = specialCache(symbol);\n        if (common != null) {\n            return common;\n        }\n\n        if (symbol instanceof JClassSymbol) {\n            JClassSymbol classSym = (JClassSymbol) symbol;\n            if (classSym.isArray()) {\n                // generic array types are represented by a special\n                // type in the j.l.reflect API, so the component is\n                // also raw\n                JTypeMirror component = rawType(classSym.getArrayComponent());\n                return arrayType(component, 1);\n            } else {\n                return new ClassTypeImpl(this, classSym, emptyList(), !isErased);\n            }\n        } else if (symbol instanceof JTypeParameterSymbol) {\n            return ((JTypeParameterSymbol) symbol).getTypeMirror();\n        }\n        throw new AssertionError(\"Uncategorized type symbol \" + symbol.getClass() + \": \" + symbol);\n    }\n\n    /**\n     * Like {@link #typeOf(JTypeDeclSymbol, boolean)}, defaulting the\n     * erased parameter to\n     * @param klass\n     * @return\n     */\n    public JTypeMirror rawType(JTypeDeclSymbol klass) {\n        return typeOf(klass, true);\n    }\n\n    public JTypeMirror declaration(JClassSymbol klass) {\n        return typeOf(klass, false);\n    }\n\n\n    @NonNull\n    public JTypeMirror parameterise(JClassSymbol klass, List<? extends JTypeMirror> typeArgs) {\n        Objects.requireNonNull(klass, \"Null class symbol\");\n        Objects.requireNonNull(typeArgs, \"Null type arguments, use an empty list!\");\n\n        if (!klass.isUnresolved() && !typeArgs.isEmpty() && klass.getTypeParameterCount() != typeArgs.size()) {\n            throw new IllegalArgumentException(\"Cannot parameterize \" + klass + \" with \" + typeArgs);\n        } else if (typeArgs.isEmpty()) {\n            return rawType(klass);\n        }\n\n        // if the type arguments are mismatched, the constructor will throw\n        return new ClassTypeImpl(this, klass, new ArrayList<>(typeArgs), false);\n    }\n\n\n    /**\n     * Returns a new type variable for\n     */\n    public JTypeVar.FreshTypeVar newTypeVar(JTypeParameterSymbol symbol) {\n        return new TypeVarImpl(this, symbol);\n    }\n\n\n    /**\n     * Creates a new array type from an arbitrary element type.\n     *\n     * <pre>{@code\n     * arrayType(T, 0)          = T\n     * arrayType(T, 1)          = T[]\n     * arrayType(T, 3)          = T[][][]\n     * arrayType(T[], 2)        = T[][][]\n     * arrayType(ERROR_TYPE, _) = ERROR_TYPE\n     * }</pre>\n     *\n     * @param element       Element type\n     * @param numDimensions Number of dimensions\n     *\n     * @return A new array type\n     *\n     * @throws IllegalArgumentException If numDimensions is negative\n     * @throws IllegalArgumentException If the element type is a {@link JWildcardType},\n     *                                  the null type, or {@link #NO_TYPE void}.\n     * @throws NullPointerException     If the element type is null\n     */\n    public JTypeMirror arrayType(@NonNull JTypeMirror element, int numDimensions) {\n        AssertionUtil.requireNonNegative(\"numDimensions\", numDimensions);\n        AssertionUtil.requireParamNotNull(\"elementType\", element);\n\n        if (element instanceof JWildcardType\n            || element == NULL_TYPE\n            || element == NO_TYPE) {\n            throw new IllegalArgumentException(\"The type < \" + element + \" > is not a valid array element type \");\n        }\n\n        if (numDimensions == 0 || element == ERROR_TYPE) {\n            return element;\n        }\n\n        JArrayType res = new ArrayTypeImpl(this, element);\n        while (--numDimensions > 0) {\n            res = new ArrayTypeImpl(this, res);\n        }\n        return res;\n    }\n\n    public JMethodSig sigOf(JExecutableSymbol methodSym) {\n        return sigOf(methodSym, Substitution.EMPTY);\n    }\n\n    public JMethodSig sigOf(JExecutableSymbol methodSym, Substitution subst) {\n        JClassType klass = (JClassType) declaration(methodSym.getEnclosingClass());\n        return new ClassMethodSigImpl(klass.subst(subst), methodSym);\n    }\n\n    /**\n     * Builds an intersection type for the specified component types.\n     * This does not necessarily return a {@link JIntersectionType}.\n     *\n     * @param types Types to intersect\n     *\n     * @return An intersection type\n     *\n     * @throws NullPointerException     If the collection is null\n     * @throws IllegalArgumentException If the collection is empty\n     */\n    public JTypeMirror intersect(Collection<? extends JTypeMirror> types) {\n        if (types.isEmpty()) {\n            throw new IllegalArgumentException(\"Cannot intersect zero types\");\n        } else if (types.size() == 1) {\n            return types.iterator().next();\n        }\n        return new IntersectionTypeImpl(this, new ArrayList<>(types));\n    }\n\n\n    /**\n     * Builds a wildcard type with a single bound.\n     *\n     * <pre>{@code\n     *\n     * wildcard(true, T)      = ? extends T\n     * wildcard(false, T)     = ? super T\n     * wildcard(true, OBJECT) = ?\n     * wildcard(_, ERROR_TYPE) = ERROR_TYPE\n     *\n     * }</pre>\n     *\n     * @param isUpperBound If true, this is an \"extends\" wildcard, otherwise a \"super\"\n     * @param bound        Bound of the wildcard\n     *\n     * @return A wildcard\n     *\n     * @throws NullPointerException     If the bound is null\n     * @throws IllegalArgumentException If the bound is a primitive type,\n     *                                  or a wildcard type\n     * @throws IllegalArgumentException If the bound is OBJECT and this\n     *                                  is a lower-bounded wildcard (? super Object)\n     */\n    public JTypeMirror wildcard(boolean isUpperBound, @NonNull JTypeMirror bound) {\n        Objects.requireNonNull(bound, \"Argument shouldn't be null\");\n        if (bound == ERROR_TYPE) {\n            return bound;\n        }\n        if (bound.isPrimitive() || bound instanceof JWildcardType) {\n            throw new IllegalArgumentException(\"<\" + bound + \"> cannot be a wildcard bound\");\n        }\n        return isUpperBound && bound == OBJECT ? UNBOUNDED_WILD\n                                               : new WildcardTypeImpl(this, isUpperBound, bound);\n    }\n\n    /**\n     * Maps a type decl symbol to its shared representation. Eg this\n     * maps the symbol for {@code int.class} to {@link #INT}. Only\n     * non-generic types are cached.\n     */\n    private @Nullable JTypeMirror specialCache(JTypeDeclSymbol raw) {\n        return sharedTypes.get(raw);\n    }\n\n\n    /**\n     * Gets the primitive type identified by the given kind.\n     *\n     * @param kind Kind of primitive type\n     *\n     * @return A primitive type, or null if the argument is null\n     */\n    @Nullable\n    public JPrimitiveType getPrimitive(PrimitiveTypeKind kind) {\n        return primitivesByKind.get(kind);\n    }\n\n    /**\n     * The least upper bound, or \"lub\", of a set of reference types is\n     * a shared supertype that is more specific than any other shared\n     * supertype (that is, no other shared supertype is a subtype of the\n     * least upper bound).\n     *\n     * @throws IllegalArgumentException If types is empty\n     * @throws NullPointerException     If types is null\n     */\n    public JTypeMirror lub(Collection<? extends JTypeMirror> types) {\n        return Lub.lub(this, types);\n    }\n\n    /**\n     * Returns the greatest lower bound of the given set of types.\n     * This is defined in JLS\u00a75.1.10 (Capture Conversion):\n     *\n     * <blockquote>\n     * glb(V1,...,Vm) = V1 & ... & Vm\n     * glb(V) = V\n     * </blockquote>\n     *\n     * @throws IllegalArgumentException If some component is not a class, array, or wildcard type\n     * @throws IllegalArgumentException If there is more than one minimal class or array type\n     * @throws IllegalArgumentException If types is empty\n     * @throws NullPointerException     If types is null\n     */\n    public JTypeMirror glb(Collection<? extends JTypeMirror> types) {\n        if (types.isEmpty()) {\n            throw new IllegalArgumentException(\"Cannot compute GLB of empty set\");\n        }\n\n\n        ArrayList<JTypeMirror> list = new ArrayList<>(types.size());\n\n        for (JTypeMirror type : types) {\n            // flatten intersections: (A & (B & C)) => (A & B & C)\n            if (type instanceof JIntersectionType) {\n                list.addAll(((JIntersectionType) type).getComponents());\n            } else {\n                list.add(type);\n            }\n        }\n\n\n        JTypeMirror ck = OBJECT; // Ck is a class type\n\n        for (ListIterator<JTypeMirror> iterator = list.listIterator(); iterator.hasNext(); ) {\n            JTypeMirror ci = iterator.next();\n\n            if (ci.isPrimitive() || ci instanceof JWildcardType || ci instanceof JIntersectionType) {\n                throw new IllegalArgumentException(\"Bad intersection type component: \" + ci + \" in \" + types);\n            }\n\n            if (!isPossiblyAnInterface(ci)) {\n                // either Ci is an array, or Ci is a class\n                // Ci is not unresolved\n\n                if (ci.isSubtypeOf(ck)) {\n                    ck = ci; // Ci is more specific than Ck\n                    iterator.remove(); // remove bound\n                } else if (ck.isSubtypeOf(ci)) {\n                    // then our Ck is already more specific than Ci\n                    iterator.remove();\n                } else {\n                    throw new IllegalArgumentException(\n                        \"Bad intersection, unrelated class types \" + ci + \" and \" + ck + \" in \" + types);\n                }\n            } else if (!(ci instanceof JInferenceVar) && ck.isSubtypeOf(ci)) {\n                // then our Ck is already more specific than Ci\n                iterator.remove();\n            }\n        }\n\n        if (list.isEmpty()) {\n            return ck;\n        }\n\n        if (ck != OBJECT) {\n            // readd ck as first component\n            list.add(0, ck);\n        }\n\n        if (list.size() == 1) {\n            return list.get(0);\n        }\n\n        if (ck instanceof JTypeVar) {\n            return new IntersectionTypeImpl(this, list);\n        }\n\n        // We assume there cannot be an array type here. Why?\n        // In well-formed java programs an array type in a GLB can only occur in the following situation\n        //\n        // class C<T extends B1 & .. & Bn>      // nota: the Bi cannot be array types\n        //\n        // Somewhere: C<? extends Arr[]>\n\n        // And capture would merge the bounds of the wildcard and of the tvar\n        // into Arr[] & B1 & .. & Bn\n        // Now the C<? ...> would only typecheck if Arr[] <: Bi forall i\n        // (Note that this means, that Bi in { Serializable, Cloneable, Object })\n\n        // This means, that the loop above would find Ck = Arr[], and delete all Bi, since Ck <: Bi\n        // So in the end, we would return Arr[] alone, not create an intersection\n        // TODO this is order dependent: Arr[] & Serializable is ok, but Serializable & Arr[] is not\n        //   Possibly use TypeOps::mostSpecific to merge them\n        assert ck instanceof JClassType : \"Weird intersection involving multiple array types? \" + list;\n\n        return new IntersectionTypeImpl.MinimalIntersection(this, (JClassType) ck, list);\n    }\n\n\n    private boolean isPossiblyAnInterface(JTypeMirror ci) {\n        return ci.isInterface()\n            || ci instanceof JInferenceVar\n            || (ci.getSymbol() != null && ci.getSymbol().isUnresolved());\n    }\n\n    // package-private\n    JClassType erasedType(JClassSymbol symbol) {\n        JTypeMirror t = specialCache(symbol);\n        if (t != null) {\n            return (JClassType) t.getErasure();\n        } else {\n            return new ErasedClassType(this, symbol);\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * Gets the primitive type identified by the given kind.\n     *\n     * @param kind Kind of primitive type\n     *\n     * @return A primitive type, or null if the argument is null\n     */\n    @Nullable\n    public JPrimitiveType getPrimitive(PrimitiveTypeKind kind) {\n        return primitivesByKind.get(kind);\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectedClassImpl#getEnclosingClass\n methodBody: public JClassSymbol getEnclosingClass() {\nreturn enclosing;\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.SymbolFactory#getClassSymbol\n methodBody: JClassSymbol getClassSymbol(@Nullable T klass);",
            "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.UnresolvedClassImpl#getEnclosingClass\n methodBody: public JClassSymbol getEnclosingClass() {\nreturn enclosing;\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectionSymFactory#getClassSymbol\n methodBody: public JClassSymbol getClassSymbol(@Nullable Class<?> klass) {\nif(klass == null){return null;\n}Map<Class<?>,JClassSymbol> shared=getCommonSyms();\nif(shared.containsKey(klass)){return shared.get(klass);\n}if(klass.getEnclosingClass() != null){JClassSymbol enclosing=getClassSymbol(klass.getEnclosingClass());\nassert enclosing != null;\nreturn createWithEnclosing(this,enclosing,klass);\n}if(klass.isArray()){JClassSymbol component=getClassSymbol(klass.getComponentType());\nreturn makeArraySymbol(component);\n}return createOuterClass(this,klass);\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectedClassImpl#createWithEnclosing\n methodBody: static ReflectedClassImpl createWithEnclosing(ReflectionSymFactory symbolFactory,\n                                                  @Nullable JClassSymbol enclosing,\n                                                  Class<?> myClass) {\nreturn new ReflectedClassImpl(symbolFactory,enclosing,myClass);\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.UnresolvedClassImpl#isArray\n methodBody: public boolean isArray() {\nreturn false;\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.AbstractReflectedExecutableSymbol#getEnclosingClass\n methodBody: public final JClassSymbol getEnclosingClass() {\nreturn owner;\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectedClassImpl#createOuterClass\n methodBody: static ReflectedClassImpl createOuterClass(ReflectionSymFactory symbolFactory, Class<?> myClass) {\nreturn new ReflectedClassImpl(symbolFactory,myClass);\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.ImplicitMemberSymbols.FakeExecutableSymBase#getEnclosingClass\n methodBody: public @NonNull JClassSymbol getEnclosingClass() {\nreturn owner;\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.ArraySymbolImpl#isArray\n methodBody: public boolean isArray() {\nreturn true;\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectedClassImpl#isArray\n methodBody: public boolean isArray() {\nreturn false;\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.ast.AstClassSym#getEnclosingClass\n methodBody: public @Nullable JClassSymbol getEnclosingClass() {\nif(enclosing instanceof JClassSymbol){return (JClassSymbol)enclosing;\n}if(enclosing instanceof JExecutableSymbol){return enclosing.getEnclosingClass();\n}assert enclosing == null;\nreturn null;\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.ast.AstFieldSym#getEnclosingClass\n methodBody: public @NonNull JClassSymbol getEnclosingClass() {\nreturn owner;\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.ArraySymbolImpl#getEnclosingClass\n methodBody: public JClassSymbol getEnclosingClass() {\nreturn null;\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.ImplicitMemberSymbols.FakeFieldSym#getEnclosingClass\n methodBody: public @NonNull JClassSymbol getEnclosingClass() {\nreturn owner;\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.symbols.JTypeParameterSymbol#getEnclosingClass\n methodBody: default JClassSymbol getEnclosingClass() {\nJTypeParameterOwnerSymbol ownerSymbol=getDeclaringSymbol();\nreturn ownerSymbol instanceof JClassSymbol ? (JClassSymbol)ownerSymbol : ownerSymbol.getEnclosingClass();\n}",
            "methodSignature: net.sourceforge.pmd.typeresolution.testdata.LocalGenericClass.localClassInGeneric.MyLocalClass#get\n methodBody: public Optional<T> get() {\nreturn Optional.empty();\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.symbols.JAccessibleElementSymbol#getEnclosingClass\n methodBody: JClassSymbol getEnclosingClass();",
            "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.SymbolFactory#makeArraySymbol\n methodBody: default JClassSymbol makeArraySymbol(JTypeDeclSymbol component) {\nreturn new ArraySymbolImpl(this,component);\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.symbols.JClassSymbol#isArray\n methodBody: boolean isArray();",
            "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.ast.AbstractAstExecSymbol#getEnclosingClass\n methodBody: public @NonNull JClassSymbol getEnclosingClass() {\nreturn owner;\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectionSymFactory#getCommonSyms\n methodBody: private static Map<Class<?>, JClassSymbol> getCommonSyms() {\nMap<Class<?>,JClassSymbol> shared=commonSymbols;\nif(shared == null){synchronized(ReflectionSymFactory.class){shared=commonSymbols;\nif(shared == null){shared=initCommonSyms();\ncommonSymbols=shared;\n}}}return shared;\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.reflect.ReflectedFieldImpl#getEnclosingClass\n methodBody: public JClassSymbol getEnclosingClass() {\nreturn owner;\n}",
            "methodSignature: net.sourceforge.pmd.typeresolution.testdata.LocalGenericClass.MySupplier#get\n methodBody: S get();",
            "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.impl.ast.AstClassSym#isArray\n methodBody: public boolean isArray() {\nreturn false;\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.symbols.JExecutableSymbol#getEnclosingClass\n methodBody: JClassSymbol getEnclosingClass();"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Returns the class symbol for the given reflected class. This asks\n     * the classloader of this type system, but never returns null. Returns\n     * null if the parameter is null.\n     *\n     * @param clazz Class\n     */\n    @Nullable\n    public JClassSymbol getClassSymbol(@Nullable Class<?> clazz) {\n        if (clazz == null) {\n            return null;\n        } else if (clazz.isPrimitive()) {\n            return getPrimitive(PrimitiveTypeKind.fromName(clazz.getName())).getSymbol();\n        } else if (clazz.isArray()) {\n            return symbols().makeArraySymbol(getClassSymbol(clazz.getComponentType()));\n        }\n\n        JClassSymbol classLoaderPreferred = resolver.resolveClassFromBinaryName(clazz.getName());\n        if (classLoaderPreferred != null) {\n            return classLoaderPreferred;\n        }\n        return ReflectedSymbols.getClassSymbol(symbols(), clazz);\n    }\n/**\n     * Gets the primitive type identified by the given kind.\n     *\n     * @param kind Kind of primitive type\n     *\n     * @return A primitive type, or null if the argument is null\n     */\n    @Nullable\n    public JPrimitiveType getPrimitive(PrimitiveTypeKind kind) {\n        return primitivesByKind.get(kind);\n    }",
        "diffSourceCode": "-   58:     @Override\n-   59:     @Nullable\n-   60:     public JClassSymbol getClassSymbol(@Nullable Class<?> klass) {\n-   61:         if (klass == null) {\n-   62:             return null;\n-   63:         }\n-   64: \n-   65:         Map<Class<?>, JClassSymbol> shared = getCommonSyms();\n-   66:         if (shared.containsKey(klass)) {\n-   67:             return shared.get(klass);\n-   68:         }\n-   69: \n-   70:         if (klass.getEnclosingClass() != null) {\n-   71:             JClassSymbol enclosing = getClassSymbol(klass.getEnclosingClass());\n-   72:             assert enclosing != null;\n-   73:             return createWithEnclosing(this, enclosing, klass);\n-   74:         }\n-   75: \n-   76:         if (klass.isArray()) {\n-   77:             JClassSymbol component = getClassSymbol(klass.getComponentType());\n-   78:             return makeArraySymbol(component);\n-   79:         }\n-   80: \n-   81:         return createOuterClass(this, klass);\n-   82:     }\n+   58:      * <p>This implementation uses this as the type of the 'null' literal.\n+   59:      */\n+   60:     public final JTypeMirror NULL_TYPE = new JTypeMirror() {\n+   61: \n+   62:         @Override\n+   63:         public JTypeMirror subst(Function<? super SubstVar, ? extends @NonNull JTypeMirror> subst) {\n+   64:             return this;\n+   65:         }\n+   66: \n+   67:         @Override\n+   68:         public TypeSystem getTypeSystem() {\n+   69:             return TypeSystem.this;\n+   70:         }\n+   71: \n+   72:         @Override\n+   73:         public @Nullable JClassSymbol getSymbol() {\n+   74:             return null;\n+   75:         }\n+   76: \n+   77:         @Override\n+   78:         public <T, P> T acceptVisitor(JTypeVisitor<T, P> visitor, P p) {\n+   79:             return visitor.visitNullType(this, p);\n+   80:         }\n+   81: \n+   82:         @Override\n+  337:     /**\n+  338:      * Returns the class symbol for the given reflected class. This asks\n+  339:      * the classloader of this type system, but never returns null. Returns\n+  340:      * null if the parameter is null.\n+  341:      *\n+  342:      * @param clazz Class\n+  343:      */\n+  344:     @Nullable\n+  345:     public JClassSymbol getClassSymbol(@Nullable Class<?> clazz) {\n+  346:         if (clazz == null) {\n+  347:             return null;\n+  348:         } else if (clazz.isPrimitive()) {\n+  349:             return getPrimitive(PrimitiveTypeKind.fromName(clazz.getName())).getSymbol();\n+  350:         } else if (clazz.isArray()) {\n+  351:             return symbols().makeArraySymbol(getClassSymbol(clazz.getComponentType()));\n+  352:         }\n+  353: \n+  354:         JClassSymbol classLoaderPreferred = resolver.resolveClassFromBinaryName(clazz.getName());\n+  355:         if (classLoaderPreferred != null) {\n+  356:             return classLoaderPreferred;\n+  357:         }\n+  358:         return ReflectedSymbols.getClassSymbol(symbols(), clazz);\n+  359:     }\n+  586:     /**\n+  587:      * Gets the primitive type identified by the given kind.\n+  588:      *\n+  589:      * @param kind Kind of primitive type\n+  590:      *\n+  591:      * @return A primitive type, or null if the argument is null\n+  592:      */\n+  593:     @Nullable\n+  594:     public JPrimitiveType getPrimitive(PrimitiveTypeKind kind) {\n+  595:         return primitivesByKind.get(kind);\n+  596:     }\n",
        "uniqueId": "2449f6404ec001dde8fe782febb993f262a5ddc1_58_82_586_596_337_359",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 4,
                "covered": 48
            },
            "BRANCH": {
                "missed": 2,
                "covered": 10
            },
            "LINE": {
                "missed": 0,
                "covered": 13
            },
            "COMPLEXITY": {
                "missed": 2,
                "covered": 5
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate getParentMethodCallArgsSuffix(expr ASTPrimaryExpression) : ASTPrimarySuffix extracted from private isArgumentOfEqualsMethodCall(expr ASTPrimaryExpression) : boolean in class net.sourceforge.pmd.lang.java.rule.errorprone.UnnecessaryCaseChangeRule",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java",
                "startLine": 85,
                "endLine": 95,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java",
                "startLine": 85,
                "endLine": 94,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java",
                "startLine": 96,
                "endLine": 101,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private boolean isArgumentOfEqualsMethodCall(ASTPrimaryExpression expr) {\n        JavaNode parent = expr.getParent().getParent();\n        if (parent instanceof ASTArgumentList) {\n            ASTPrimarySuffix parentMethodCallArgs = parent.getFirstParentOfType(ASTPrimarySuffix.class);\n            List<JavaNode> parentNodes = parentMethodCallArgs.getParent().findChildrenOfType(JavaNode.class);\n            int parentMethodCallIndex = parentNodes.indexOf(parentMethodCallArgs) - 1;\n            JavaNode parentMethodCall = parentNodes.get(parentMethodCallIndex);\n            return isEqualsMethodCall(parentMethodCall, parentMethodCallArgs);\n        }\n        return false;\n    }",
        "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java",
        "isPureRefactoring": true,
        "commitId": "d69520f68fc68e40dc541604aa301246c8612ca7",
        "packageNameBefore": "net.sourceforge.pmd.lang.java.rule.errorprone",
        "classNameBefore": "net.sourceforge.pmd.lang.java.rule.errorprone.UnnecessaryCaseChangeRule",
        "methodNameBefore": "net.sourceforge.pmd.lang.java.rule.errorprone.UnnecessaryCaseChangeRule#isArgumentOfEqualsMethodCall",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.java.rule.errorprone.UnnecessaryCaseChangeRule#isEqualsMethodCall\n methodBody: private boolean isEqualsMethodCall(JavaNode methodCall, JavaNode methodCallArgs) {\nString methodName=methodCall.getImage();\nint methodArgsCount=getCalledMethodArgsCount(methodCallArgs);\nreturn methodName != null && EQUALITY_METHODS.contains(methodName) && methodArgsCount == 1;\n}",
        "classSignatureBefore": "public class UnnecessaryCaseChangeRule extends AbstractJavaRule ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.rule.errorprone.UnnecessaryCaseChangeRule#isArgumentOfEqualsMethodCall"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.rule.errorprone.UnnecessaryCaseChangeRule"
        ],
        "classSignatureBeforeSet": [
            "public class UnnecessaryCaseChangeRule extends AbstractJavaRule "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.rule.errorprone;\n\nimport static java.util.Arrays.asList;\n\nimport java.util.List;\n\nimport net.sourceforge.pmd.lang.java.ast.ASTArgumentList;\nimport net.sourceforge.pmd.lang.java.ast.ASTArguments;\nimport net.sourceforge.pmd.lang.java.ast.ASTName;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimarySuffix;\nimport net.sourceforge.pmd.lang.java.ast.JavaNode;\nimport net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;\n\npublic class UnnecessaryCaseChangeRule extends AbstractJavaRule {\n\n    private static final List<String> CASE_CHANGING_METHODS = asList(\"toLowerCase\", \"toUpperCase\");\n    private static final List<String> EQUALITY_METHODS = asList(\"equals\", \"equalsIgnoreCase\");\n\n    @Override\n    public Object visit(ASTPrimaryExpression expr, Object data) {\n        int caseChangingCallIndex = getCaseChangingMethodCallIndex(expr);\n        if (caseChangingCallIndex != -1) {\n            int chainedMethodCallIndex = caseChangingCallIndex + 2;\n            if (hasEqualsMethodCallChainedAtPosition(expr, chainedMethodCallIndex)\n                    || isArgumentOfEqualsMethodCall(expr)) {\n                addViolation(data, expr);\n            }\n        }\n        return super.visit(expr, data);\n    }\n\n    private int getCaseChangingMethodCallIndex(ASTPrimaryExpression expr) {\n        List<JavaNode> exprNodes = expr.findChildrenOfType(JavaNode.class);\n        for (int callArgsIndex = 1; callArgsIndex < exprNodes.size(); callArgsIndex++) {\n            int callIndex = callArgsIndex - 1;\n            if (isCaseChangingMethodCall(exprNodes.get(callIndex), exprNodes.get(callArgsIndex))) {\n                return callIndex;\n            }\n        }\n        return -1;\n    }\n\n    private boolean isCaseChangingMethodCall(JavaNode methodCall, JavaNode methodCallArgs) {\n        String methodName = getCalledMethodName(methodCall);\n        int methodArgsCount = getCalledMethodArgsCount(methodCallArgs);\n        return methodName != null\n                && isNameOfCaseChangingMethod(methodName) && methodArgsCount == 0;\n    }\n\n    private String getCalledMethodName(JavaNode methodCall) {\n        if (methodCall instanceof ASTPrimaryPrefix) {\n            ASTName methodName = methodCall.getFirstDescendantOfType(ASTName.class);\n            return methodName != null ? methodName.getImage() : null;\n        }\n        return methodCall.getImage();\n    }\n\n    private boolean isNameOfCaseChangingMethod(String methodName) {\n        for (String caseChangingMethod : CASE_CHANGING_METHODS) {\n            if (methodName.endsWith(caseChangingMethod)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean hasEqualsMethodCallChainedAtPosition(ASTPrimaryExpression expr, int pos) {\n        int argsPos = pos + 1;\n        if (hasNodeAtPosition(expr, argsPos)) {\n            return isEqualsMethodCall(expr.getChild(pos), expr.getChild(argsPos));\n        }\n        return false;\n    }\n\n    private boolean hasNodeAtPosition(ASTPrimaryExpression expr, int pos) {\n        return pos < expr.getNumChildren();\n    }\n\n    private boolean isArgumentOfEqualsMethodCall(ASTPrimaryExpression expr) {\n        JavaNode parent = expr.getParent().getParent();\n        if (parent instanceof ASTArgumentList) {\n            ASTPrimarySuffix parentMethodCallArgs = parent.getFirstParentOfType(ASTPrimarySuffix.class);\n            List<JavaNode> parentNodes = parentMethodCallArgs.getParent().findChildrenOfType(JavaNode.class);\n            int parentMethodCallIndex = parentNodes.indexOf(parentMethodCallArgs) - 1;\n            JavaNode parentMethodCall = parentNodes.get(parentMethodCallIndex);\n            return isEqualsMethodCall(parentMethodCall, parentMethodCallArgs);\n        }\n        return false;\n    }\n\n    private boolean isEqualsMethodCall(JavaNode methodCall, JavaNode methodCallArgs) {\n        String methodName = methodCall.getImage();\n        int methodArgsCount = getCalledMethodArgsCount(methodCallArgs);\n        return methodName != null\n                && EQUALITY_METHODS.contains(methodName) && methodArgsCount == 1;\n    }\n\n    private int getCalledMethodArgsCount(JavaNode methodCall) {\n        ASTArguments args = methodCall.getFirstDescendantOfType(ASTArguments.class);\n        return args != null ? args.size() : -1;\n    }\n}\n",
        "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.rule.errorprone;\n\nimport static java.util.Arrays.asList;\n\nimport java.util.List;\n\nimport net.sourceforge.pmd.lang.java.ast.ASTArgumentList;\nimport net.sourceforge.pmd.lang.java.ast.ASTArguments;\nimport net.sourceforge.pmd.lang.java.ast.ASTName;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimarySuffix;\nimport net.sourceforge.pmd.lang.java.ast.JavaNode;\nimport net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;\n\npublic class UnnecessaryCaseChangeRule extends AbstractJavaRule {\n\n    private static final List<String> CASE_CHANGING_METHODS = asList(\"toLowerCase\", \"toUpperCase\");\n    private static final List<String> EQUALITY_METHODS = asList(\"equals\", \"equalsIgnoreCase\");\n\n    @Override\n    public Object visit(ASTPrimaryExpression expr, Object data) {\n        int caseChangingCallIndex = getCaseChangingMethodCallIndex(expr);\n        if (caseChangingCallIndex != -1) {\n            int chainedMethodCallIndex = caseChangingCallIndex + 2;\n            if (hasEqualsMethodCallChainedAtPosition(expr, chainedMethodCallIndex)\n                    || isArgumentOfEqualsMethodCall(expr)) {\n                addViolation(data, expr);\n            }\n        }\n        return super.visit(expr, data);\n    }\n\n    private int getCaseChangingMethodCallIndex(ASTPrimaryExpression expr) {\n        List<JavaNode> exprNodes = expr.findChildrenOfType(JavaNode.class);\n        for (int callArgsIndex = 1; callArgsIndex < exprNodes.size(); callArgsIndex++) {\n            int callIndex = callArgsIndex - 1;\n            if (isCaseChangingMethodCall(exprNodes.get(callIndex), exprNodes.get(callArgsIndex))) {\n                return callIndex;\n            }\n        }\n        return -1;\n    }\n\n    private boolean isCaseChangingMethodCall(JavaNode methodCall, JavaNode methodCallArgs) {\n        String methodName = getCalledMethodName(methodCall);\n        int methodArgsCount = getCalledMethodArgsCount(methodCallArgs);\n        return methodName != null\n                && isNameOfCaseChangingMethod(methodName) && methodArgsCount == 0;\n    }\n\n    private String getCalledMethodName(JavaNode methodCall) {\n        if (methodCall instanceof ASTPrimaryPrefix) {\n            ASTName methodName = methodCall.getFirstDescendantOfType(ASTName.class);\n            return methodName != null ? methodName.getImage() : null;\n        }\n        return methodCall.getImage();\n    }\n\n    private boolean isNameOfCaseChangingMethod(String methodName) {\n        for (String caseChangingMethod : CASE_CHANGING_METHODS) {\n            if (methodName.endsWith(caseChangingMethod)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean hasEqualsMethodCallChainedAtPosition(ASTPrimaryExpression expr, int pos) {\n        int argsPos = pos + 1;\n        if (hasNodeAtPosition(expr, argsPos)) {\n            return isEqualsMethodCall(expr.getChild(pos), expr.getChild(argsPos));\n        }\n        return false;\n    }\n\n    private boolean hasNodeAtPosition(ASTPrimaryExpression expr, int pos) {\n        return pos < expr.getNumChildren();\n    }\n\n    private boolean isArgumentOfEqualsMethodCall(ASTPrimaryExpression expr) {\n        ASTPrimarySuffix parentMethodCallArgs = getParentMethodCallArgsSuffix(expr);\n        if (parentMethodCallArgs != null) {\n            List<JavaNode> parentNodes = parentMethodCallArgs.getParent().findChildrenOfType(JavaNode.class);\n            int parentMethodCallIndex = parentNodes.indexOf(parentMethodCallArgs) - 1;\n            JavaNode parentMethodCall = parentNodes.get(parentMethodCallIndex);\n            return isEqualsMethodCall(parentMethodCall, parentMethodCallArgs);\n        }\n        return false;\n    }\n\n    private ASTPrimarySuffix getParentMethodCallArgsSuffix(ASTPrimaryExpression expr) {\n        JavaNode parent = expr.getParent().getParent(); // ASTArgumentList/ASTExpression/ASTPrimaryExpression\n        return parent instanceof ASTArgumentList\n                ? parent.getFirstParentOfType(ASTPrimarySuffix.class)\n                : null;\n    }\n\n    private boolean isEqualsMethodCall(JavaNode methodCall, JavaNode methodCallArgs) {\n        String methodName = methodCall.getImage();\n        int methodArgsCount = getCalledMethodArgsCount(methodCallArgs);\n        return methodName != null\n                && EQUALITY_METHODS.contains(methodName) && methodArgsCount == 1;\n    }\n\n    private int getCalledMethodArgsCount(JavaNode methodCall) {\n        ASTArguments args = methodCall.getFirstDescendantOfType(ASTArguments.class);\n        return args != null ? args.size() : -1;\n    }\n}\n",
        "diffSourceCodeSet": [
            "private ASTPrimarySuffix getParentMethodCallArgsSuffix(ASTPrimaryExpression expr) {\n        JavaNode parent = expr.getParent().getParent(); // ASTArgumentList/ASTExpression/ASTPrimaryExpression\n        return parent instanceof ASTArgumentList\n                ? parent.getFirstParentOfType(ASTPrimarySuffix.class)\n                : null;\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.java.rule.errorprone.UnnecessaryCaseChangeRule#isEqualsMethodCall\n methodBody: private boolean isEqualsMethodCall(JavaNode methodCall, JavaNode methodCallArgs) {\nString methodName=methodCall.getImage();\nint methodArgsCount=getCalledMethodArgsCount(methodCallArgs);\nreturn methodName != null && EQUALITY_METHODS.contains(methodName) && methodArgsCount == 1;\n}"
        ],
        "sourceCodeAfterRefactoring": "private boolean isArgumentOfEqualsMethodCall(ASTPrimaryExpression expr) {\n        ASTPrimarySuffix parentMethodCallArgs = getParentMethodCallArgsSuffix(expr);\n        if (parentMethodCallArgs != null) {\n            List<JavaNode> parentNodes = parentMethodCallArgs.getParent().findChildrenOfType(JavaNode.class);\n            int parentMethodCallIndex = parentNodes.indexOf(parentMethodCallArgs) - 1;\n            JavaNode parentMethodCall = parentNodes.get(parentMethodCallIndex);\n            return isEqualsMethodCall(parentMethodCall, parentMethodCallArgs);\n        }\n        return false;\n    }\nprivate ASTPrimarySuffix getParentMethodCallArgsSuffix(ASTPrimaryExpression expr) {\n        JavaNode parent = expr.getParent().getParent(); // ASTArgumentList/ASTExpression/ASTPrimaryExpression\n        return parent instanceof ASTArgumentList\n                ? parent.getFirstParentOfType(ASTPrimarySuffix.class)\n                : null;\n    }",
        "diffSourceCode": "    85:     private boolean isArgumentOfEqualsMethodCall(ASTPrimaryExpression expr) {\n-   86:         JavaNode parent = expr.getParent().getParent();\n-   87:         if (parent instanceof ASTArgumentList) {\n-   88:             ASTPrimarySuffix parentMethodCallArgs = parent.getFirstParentOfType(ASTPrimarySuffix.class);\n-   89:             List<JavaNode> parentNodes = parentMethodCallArgs.getParent().findChildrenOfType(JavaNode.class);\n-   90:             int parentMethodCallIndex = parentNodes.indexOf(parentMethodCallArgs) - 1;\n-   91:             JavaNode parentMethodCall = parentNodes.get(parentMethodCallIndex);\n-   92:             return isEqualsMethodCall(parentMethodCall, parentMethodCallArgs);\n-   93:         }\n-   94:         return false;\n-   95:     }\n-   96: \n-   97:     private boolean isEqualsMethodCall(JavaNode methodCall, JavaNode methodCallArgs) {\n-   98:         String methodName = methodCall.getImage();\n-   99:         int methodArgsCount = getCalledMethodArgsCount(methodCallArgs);\n-  100:         return methodName != null\n-  101:                 && EQUALITY_METHODS.contains(methodName) && methodArgsCount == 1;\n+   86:         ASTPrimarySuffix parentMethodCallArgs = getParentMethodCallArgsSuffix(expr);\n+   87:         if (parentMethodCallArgs != null) {\n+   88:             List<JavaNode> parentNodes = parentMethodCallArgs.getParent().findChildrenOfType(JavaNode.class);\n+   89:             int parentMethodCallIndex = parentNodes.indexOf(parentMethodCallArgs) - 1;\n+   90:             JavaNode parentMethodCall = parentNodes.get(parentMethodCallIndex);\n+   91:             return isEqualsMethodCall(parentMethodCall, parentMethodCallArgs);\n+   92:         }\n+   93:         return false;\n+   94:     }\n+   95: \n+   96:     private ASTPrimarySuffix getParentMethodCallArgsSuffix(ASTPrimaryExpression expr) {\n+   97:         JavaNode parent = expr.getParent().getParent(); // ASTArgumentList/ASTExpression/ASTPrimaryExpression\n+   98:         return parent instanceof ASTArgumentList\n+   99:                 ? parent.getFirstParentOfType(ASTPrimarySuffix.class)\n+  100:                 : null;\n+  101:     }\n",
        "uniqueId": "d69520f68fc68e40dc541604aa301246c8612ca7_85_95_96_101_85_94",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 2,
                "covered": 35
            },
            "BRANCH": {
                "missed": 1,
                "covered": 1
            },
            "LINE": {
                "missed": 1,
                "covered": 7
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic getName() : String extracted from public getImage() : String in class net.sourceforge.pmd.lang.apex.ast.ASTFieldDeclaration",
        "diffLocations": [
            {
                "filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTFieldDeclaration.java",
                "startLine": 20,
                "endLine": 30,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTFieldDeclaration.java",
                "startLine": 20,
                "endLine": 23,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTFieldDeclaration.java",
                "startLine": 25,
                "endLine": 34,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n    public String getImage() {\n        if (node.getFieldInfo() != null) {\n            return node.getFieldInfo().getName();\n        }\n        ASTVariableExpression variable = getFirstChildOfType(ASTVariableExpression.class);\n        if (variable != null) {\n            return variable.getImage();\n        }\n        return null;\n    }",
        "filePathBefore": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTFieldDeclaration.java",
        "isPureRefactoring": true,
        "commitId": "e8f8e1ac7a9f4f21bb7a0f9242a81fe7ab7e599c",
        "packageNameBefore": "net.sourceforge.pmd.lang.apex.ast",
        "classNameBefore": "net.sourceforge.pmd.lang.apex.ast.ASTFieldDeclaration",
        "methodNameBefore": "net.sourceforge.pmd.lang.apex.ast.ASTFieldDeclaration#getImage",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.apex.ast.ASTField#getImage\n methodBody: public String getImage() {\nreturn node.getFieldInfo().getName();\n}\nmethodSignature: net.sourceforge.pmd.lang.apex.ast.ASTFieldDeclaration#getImage\n methodBody: public String getImage() {\nif(node.getFieldInfo() != null){return node.getFieldInfo().getName();\n}ASTVariableExpression variable=getFirstChildOfType(ASTVariableExpression.class);\nif(variable != null){return variable.getImage();\n}return null;\n}",
        "classSignatureBefore": "public class ASTFieldDeclaration extends AbstractApexNode<FieldDeclaration> ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.apex.ast.ASTFieldDeclaration#getImage"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.apex.ast.ASTFieldDeclaration"
        ],
        "classSignatureBeforeSet": [
            "public class ASTFieldDeclaration extends AbstractApexNode<FieldDeclaration> "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex.ast;\n\nimport apex.jorje.semantic.ast.statement.FieldDeclaration;\n\npublic class ASTFieldDeclaration extends AbstractApexNode<FieldDeclaration> {\n\n    public ASTFieldDeclaration(FieldDeclaration fieldDeclaration) {\n        super(fieldDeclaration);\n    }\n\n    @Override\n    public Object jjtAccept(ApexParserVisitor visitor, Object data) {\n        return visitor.visit(this, data);\n    }\n\n    @Override\n    public String getImage() {\n        if (node.getFieldInfo() != null) {\n            return node.getFieldInfo().getName();\n        }\n        ASTVariableExpression variable = getFirstChildOfType(ASTVariableExpression.class);\n        if (variable != null) {\n            return variable.getImage();\n        }\n        return null;\n    }\n}\n",
        "filePathAfter": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTFieldDeclaration.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex.ast;\n\nimport apex.jorje.semantic.ast.statement.FieldDeclaration;\n\npublic class ASTFieldDeclaration extends AbstractApexNode<FieldDeclaration> {\n\n    public ASTFieldDeclaration(FieldDeclaration fieldDeclaration) {\n        super(fieldDeclaration);\n    }\n\n    @Override\n    public Object jjtAccept(ApexParserVisitor visitor, Object data) {\n        return visitor.visit(this, data);\n    }\n\n    @Override\n    public String getImage() {\n        return getName();\n    }\n\n    public String getName() {\n        if (node.getFieldInfo() != null) {\n            return node.getFieldInfo().getName();\n        }\n        ASTVariableExpression variable = getFirstChildOfType(ASTVariableExpression.class);\n        if (variable != null) {\n            return variable.getImage();\n        }\n        return null;\n    }\n}\n",
        "diffSourceCodeSet": [
            "public String getName() {\n        if (node.getFieldInfo() != null) {\n            return node.getFieldInfo().getName();\n        }\n        ASTVariableExpression variable = getFirstChildOfType(ASTVariableExpression.class);\n        if (variable != null) {\n            return variable.getImage();\n        }\n        return null;\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.apex.ast.ASTField#getImage\n methodBody: public String getImage() {\nreturn node.getFieldInfo().getName();\n}",
            "methodSignature: net.sourceforge.pmd.lang.apex.ast.ASTFieldDeclaration#getImage\n methodBody: public String getImage() {\nif(node.getFieldInfo() != null){return node.getFieldInfo().getName();\n}ASTVariableExpression variable=getFirstChildOfType(ASTVariableExpression.class);\nif(variable != null){return variable.getImage();\n}return null;\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n    public String getImage() {\n        return getName();\n    }\npublic String getName() {\n        if (node.getFieldInfo() != null) {\n            return node.getFieldInfo().getName();\n        }\n        ASTVariableExpression variable = getFirstChildOfType(ASTVariableExpression.class);\n        if (variable != null) {\n            return variable.getImage();\n        }\n        return null;\n    }",
        "diffSourceCode": "    20:     @Override\n    21:     public String getImage() {\n-   22:         if (node.getFieldInfo() != null) {\n-   23:             return node.getFieldInfo().getName();\n-   24:         }\n-   25:         ASTVariableExpression variable = getFirstChildOfType(ASTVariableExpression.class);\n-   26:         if (variable != null) {\n-   27:             return variable.getImage();\n+   22:         return getName();\n+   23:     }\n+   24: \n+   25:     public String getName() {\n+   26:         if (node.getFieldInfo() != null) {\n+   27:             return node.getFieldInfo().getName();\n    28:         }\n-   29:         return null;\n-   30:     }\n-   31: }\n+   29:         ASTVariableExpression variable = getFirstChildOfType(ASTVariableExpression.class);\n+   30:         if (variable != null) {\n+   31:             return variable.getImage();\n+   32:         }\n+   33:         return null;\n+   34:     }\n",
        "uniqueId": "e8f8e1ac7a9f4f21bb7a0f9242a81fe7ab7e599c_20_30_25_34_20_23",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 8,
                "covered": 15
            },
            "BRANCH": {
                "missed": 2,
                "covered": 2
            },
            "LINE": {
                "missed": 2,
                "covered": 4
            },
            "COMPLEXITY": {
                "missed": 2,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic getName() : String extracted from public getImage() : String in class net.sourceforge.pmd.lang.apex.ast.ASTField",
        "diffLocations": [
            {
                "filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTField.java",
                "startLine": 22,
                "endLine": 25,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTField.java",
                "startLine": 22,
                "endLine": 25,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTField.java",
                "startLine": 47,
                "endLine": 49,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n    public String getImage() {\n        return node.getFieldInfo().getName();\n    }",
        "filePathBefore": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTField.java",
        "isPureRefactoring": true,
        "commitId": "e8f8e1ac7a9f4f21bb7a0f9242a81fe7ab7e599c",
        "packageNameBefore": "net.sourceforge.pmd.lang.apex.ast",
        "classNameBefore": "net.sourceforge.pmd.lang.apex.ast.ASTField",
        "methodNameBefore": "net.sourceforge.pmd.lang.apex.ast.ASTField#getImage",
        "classSignatureBefore": "public class ASTField extends AbstractApexNode<Field> implements CanSuppressWarnings ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.apex.ast.ASTField#getImage"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.apex.ast.ASTField"
        ],
        "classSignatureBeforeSet": [
            "public class ASTField extends AbstractApexNode<Field> implements CanSuppressWarnings "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex.ast;\n\nimport net.sourceforge.pmd.Rule;\n\nimport apex.jorje.semantic.ast.member.Field;\n\npublic class ASTField extends AbstractApexNode<Field> implements CanSuppressWarnings {\n\n    public ASTField(Field field) {\n        super(field);\n    }\n\n    @Override\n    public Object jjtAccept(ApexParserVisitor visitor, Object data) {\n        return visitor.visit(this, data);\n    }\n\n    @Override\n    public String getImage() {\n        return node.getFieldInfo().getName();\n    }\n\n    @Override\n    public boolean hasSuppressWarningsAnnotationFor(Rule rule) {\n        for (ASTModifierNode modifier : findChildrenOfType(ASTModifierNode.class)) {\n            for (ASTAnnotation a : modifier.findChildrenOfType(ASTAnnotation.class)) {\n                if (a.suppresses(rule)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public String getType() {\n        return node.getFieldInfo().getType().getApexName();\n    }\n\n    public ASTModifierNode getModifiers() {\n        return getFirstChildOfType(ASTModifierNode.class);\n    }\n\n    public String getValue() {\n        if (node.getFieldInfo().getValue() != null) {\n            return String.valueOf(node.getFieldInfo().getValue());\n        }\n        return null;\n    }\n}\n",
        "filePathAfter": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTField.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex.ast;\n\nimport net.sourceforge.pmd.Rule;\n\nimport apex.jorje.semantic.ast.member.Field;\n\npublic class ASTField extends AbstractApexNode<Field> implements CanSuppressWarnings {\n\n    public ASTField(Field field) {\n        super(field);\n    }\n\n    @Override\n    public Object jjtAccept(ApexParserVisitor visitor, Object data) {\n        return visitor.visit(this, data);\n    }\n\n    @Override\n    public String getImage() {\n        return getName();\n    }\n\n    @Override\n    public boolean hasSuppressWarningsAnnotationFor(Rule rule) {\n        for (ASTModifierNode modifier : findChildrenOfType(ASTModifierNode.class)) {\n            for (ASTAnnotation a : modifier.findChildrenOfType(ASTAnnotation.class)) {\n                if (a.suppresses(rule)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public String getType() {\n        return node.getFieldInfo().getType().getApexName();\n    }\n\n    public ASTModifierNode getModifiers() {\n        return getFirstChildOfType(ASTModifierNode.class);\n    }\n\n    public String getName() {\n        return node.getFieldInfo().getName();\n    }\n\n    public String getValue() {\n        if (node.getFieldInfo().getValue() != null) {\n            return String.valueOf(node.getFieldInfo().getValue());\n        }\n        return null;\n    }\n}\n",
        "diffSourceCodeSet": [
            "public String getName() {\n        return node.getFieldInfo().getName();\n    }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "@Override\n    public String getImage() {\n        return getName();\n    }\npublic String getName() {\n        return node.getFieldInfo().getName();\n    }",
        "diffSourceCode": "    22:     @Override\n    23:     public String getImage() {\n-   24:         return node.getFieldInfo().getName();\n+   24:         return getName();\n    25:     }\n-   47:     public String getValue() {\n-   48:         if (node.getFieldInfo().getValue() != null) {\n-   49:             return String.valueOf(node.getFieldInfo().getValue());\n+   47:     public String getName() {\n+   48:         return node.getFieldInfo().getName();\n+   49:     }\n",
        "uniqueId": "e8f8e1ac7a9f4f21bb7a0f9242a81fe7ab7e599c_22_25_47_49_22_25",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 3
            },
            "LINE": {
                "missed": 0,
                "covered": 1
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic getType() : String extracted from package getFQVariableName(variable ASTNewKeyValueObjectExpression) : String in class net.sourceforge.pmd.lang.apex.rule.security.Helper & moved to class net.sourceforge.pmd.lang.apex.ast.ASTNewKeyValueObjectExpression",
        "diffLocations": [
            {
                "filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/security/Helper.java",
                "startLine": 187,
                "endLine": 194,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/security/Helper.java",
                "startLine": 175,
                "endLine": 180,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/security/Helper.java",
                "startLine": 20,
                "endLine": 22,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "static String getFQVariableName(final ASTNewKeyValueObjectExpression variable) {\n        NewKeyValueObjectExpression n = variable.getNode();\n        TypeRef typeRef = n.getTypeRef();\n        String objType = typeRef.getNames().get(0).getValue();\n\n        StringBuilder sb = new StringBuilder().append(n.getDefiningType().getApexName()).append(\":\").append(objType);\n        return sb.toString();\n    }",
        "filePathBefore": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/security/Helper.java",
        "isPureRefactoring": true,
        "commitId": "91d0ebf4620b9cda44ce6f02232fe8a003d82efd",
        "packageNameBefore": "net.sourceforge.pmd.lang.apex.rule.security",
        "classNameBefore": "net.sourceforge.pmd.lang.apex.rule.security.Helper",
        "methodNameBefore": "net.sourceforge.pmd.lang.apex.rule.security.Helper#getFQVariableName",
        "classSignatureBefore": "public final class Helper ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.apex.rule.security.Helper#getFQVariableName"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.apex.rule.security.Helper"
        ],
        "classSignatureBeforeSet": [
            "public final class Helper "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Overlapped refactoring - can be identical by undoing the overlapped refactoring\n- Inline Variable-",
                "description": "Inline Variable on top of the extracted method - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex.rule.security;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\n\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlDeleteStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlInsertStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlMergeStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlUndeleteStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlUpdateStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlUpsertStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTField;\nimport net.sourceforge.pmd.lang.apex.ast.ASTFieldDeclaration;\nimport net.sourceforge.pmd.lang.apex.ast.ASTMethodCallExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTModifierNode;\nimport net.sourceforge.pmd.lang.apex.ast.ASTNewKeyValueObjectExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTParameter;\nimport net.sourceforge.pmd.lang.apex.ast.ASTReferenceExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTSoqlExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTSoslExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTUserClass;\nimport net.sourceforge.pmd.lang.apex.ast.ASTVariableDeclaration;\nimport net.sourceforge.pmd.lang.apex.ast.ASTVariableExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ApexNode;\n\nimport apex.jorje.data.Identifier;\nimport apex.jorje.data.ast.TypeRef;\nimport apex.jorje.semantic.ast.expression.MethodCallExpression;\nimport apex.jorje.semantic.ast.expression.NewKeyValueObjectExpression;\nimport apex.jorje.semantic.ast.expression.VariableExpression;\nimport apex.jorje.semantic.ast.member.Field;\nimport apex.jorje.semantic.ast.member.Parameter;\nimport apex.jorje.semantic.ast.statement.FieldDeclaration;\nimport apex.jorje.semantic.ast.statement.VariableDeclaration;\n\n/**\n * Helper methods\n * \n * @author sergey.gorbaty\n *\n */\npublic final class Helper {\n    static final String ANY_METHOD = \"*\";\n\n    private Helper() {\n        throw new AssertionError(\"Can't instantiate helper classes\");\n    }\n\n    static boolean isTestMethodOrClass(final ApexNode<?> node) {\n        final List<ASTModifierNode> modifierNode = node.findChildrenOfType(ASTModifierNode.class);\n        for (final ASTModifierNode m : modifierNode) {\n            if (m.isTest()) {\n                return true;\n            }\n        }\n\n        final String className = node.getNode().getDefiningType().getApexName();\n        return className.endsWith(\"Test\");\n    }\n\n    static boolean foundAnySOQLorSOSL(final ApexNode<?> node) {\n        final List<ASTSoqlExpression> dmlSoqlExpression = node.findDescendantsOfType(ASTSoqlExpression.class);\n        final List<ASTSoslExpression> dmlSoslExpression = node.findDescendantsOfType(ASTSoslExpression.class);\n\n        return !dmlSoqlExpression.isEmpty() || !dmlSoslExpression.isEmpty();\n    }\n\n    /**\n     * Finds DML operations in a given node descendants' path\n     * \n     * @param node\n     * \n     * @return true if found DML operations in node descendants\n     */\n    static boolean foundAnyDML(final ApexNode<?> node) {\n\n        final List<ASTDmlUpsertStatement> dmlUpsertStatement = node.findDescendantsOfType(ASTDmlUpsertStatement.class);\n        final List<ASTDmlUpdateStatement> dmlUpdateStatement = node.findDescendantsOfType(ASTDmlUpdateStatement.class);\n        final List<ASTDmlUndeleteStatement> dmlUndeleteStatement = node\n                .findDescendantsOfType(ASTDmlUndeleteStatement.class);\n        final List<ASTDmlMergeStatement> dmlMergeStatement = node.findDescendantsOfType(ASTDmlMergeStatement.class);\n        final List<ASTDmlInsertStatement> dmlInsertStatement = node.findDescendantsOfType(ASTDmlInsertStatement.class);\n        final List<ASTDmlDeleteStatement> dmlDeleteStatement = node.findDescendantsOfType(ASTDmlDeleteStatement.class);\n\n        return !dmlUpsertStatement.isEmpty() || !dmlUpdateStatement.isEmpty() || !dmlUndeleteStatement.isEmpty()\n                || !dmlMergeStatement.isEmpty() || !dmlInsertStatement.isEmpty() || !dmlDeleteStatement.isEmpty();\n    }\n\n    static boolean isMethodName(final ASTMethodCallExpression methodNode, final String className,\n            final String methodName) {\n        final ASTReferenceExpression reference = methodNode.getFirstChildOfType(ASTReferenceExpression.class);\n\n        return reference != null && reference.getNode().getNames().size() == 1\n                && reference.getNode().getNames().get(0).getValue().equalsIgnoreCase(className)\n                && (methodName.equals(ANY_METHOD) || isMethodName(methodNode, methodName));\n    }\n\n    static boolean isMethodName(final ASTMethodCallExpression m, final String methodName) {\n        return isMethodName(m.getNode(), methodName);\n    }\n\n    static boolean isMethodName(final MethodCallExpression m, final String methodName) {\n        return m.getMethodName().equalsIgnoreCase(methodName);\n    }\n\n    static boolean isMethodCallChain(final ASTMethodCallExpression methodNode, final String... methodNames) {\n        String methodName = methodNames[methodNames.length - 1];\n        if (Helper.isMethodName(methodNode, methodName)) {\n            final ASTReferenceExpression reference = methodNode.getFirstChildOfType(ASTReferenceExpression.class);\n            if (reference != null) {\n                final ASTMethodCallExpression nestedMethod = reference\n                        .getFirstChildOfType(ASTMethodCallExpression.class);\n                if (nestedMethod != null) {\n                    String[] newMethodNames = Arrays.copyOf(methodNames, methodNames.length - 1);\n                    return isMethodCallChain(nestedMethod, newMethodNames);\n                } else {\n                    String[] newClassName = Arrays.copyOf(methodNames, methodNames.length - 1);\n                    if (newClassName.length == 1) {\n                        return Helper.isMethodName(methodNode, newClassName[0], methodName);\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    static String getFQVariableName(final ASTVariableExpression variable) {\n        final ASTReferenceExpression ref = variable.getFirstChildOfType(ASTReferenceExpression.class);\n        String objectName = \"\";\n        if (ref != null) {\n            if (ref.getNode().getNames().size() == 1) {\n                objectName = ref.getNode().getNames().get(0).getValue() + \".\";\n            }\n        }\n\n        VariableExpression n = variable.getNode();\n        StringBuilder sb = new StringBuilder().append(n.getDefiningType().getApexName()).append(\":\").append(objectName)\n                .append(n.getIdentifier().getValue());\n        return sb.toString();\n    }\n\n    static String getFQVariableName(final ASTVariableDeclaration variable) {\n        VariableDeclaration n = variable.getNode();\n        StringBuilder sb = new StringBuilder().append(n.getDefiningType().getApexName()).append(\":\")\n                .append(n.getLocalInfo().getName());\n        return sb.toString();\n    }\n\n    static String getFQVariableName(final ASTField variable) {\n        Field n = variable.getNode();\n        StringBuilder sb = new StringBuilder().append(n.getDefiningType().getApexName()).append(\":\")\n                .append(n.getFieldInfo().getName());\n        return sb.toString();\n    }\n\n    static String getVariableType(final ASTField variable) {\n        Field n = variable.getNode();\n        StringBuilder sb = new StringBuilder().append(n.getDefiningType().getApexName()).append(\":\")\n                .append(n.getFieldInfo().getName());\n        return sb.toString();\n    }\n    \n    static String getFQVariableName(final ASTFieldDeclaration variable) {\n        FieldDeclaration n = variable.getNode();\n        String name = \"\";\n\n        try {\n            java.lang.reflect.Field f = n.getClass().getDeclaredField(\"name\");\n            f.setAccessible(true);\n            Identifier nameField = (Identifier) f.get(n);\n            name = nameField.getValue();\n\n        } catch (NoSuchFieldException | SecurityException | IllegalArgumentException | IllegalAccessException e) {\n            throw new RuntimeException(e);\n        }\n\n        StringBuilder sb = new StringBuilder().append(n.getDefiningType().getApexName()).append(\":\").append(name);\n        return sb.toString();\n    }\n\n    static String getFQVariableName(final ASTNewKeyValueObjectExpression variable) {\n        NewKeyValueObjectExpression n = variable.getNode();\n        TypeRef typeRef = n.getTypeRef();\n        String objType = typeRef.getNames().get(0).getValue();\n\n        StringBuilder sb = new StringBuilder().append(n.getDefiningType().getApexName()).append(\":\").append(objType);\n        return sb.toString();\n    }\n\n    static boolean isSystemLevelClass(ASTUserClass node) {\n        List<TypeRef> interfaces = node.getNode().getDefiningType().getCodeUnitDetails().getInterfaceTypeRefs();\n\n        for (TypeRef intObject : interfaces) {\n            if (isWhitelisted(intObject.getNames())) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private static boolean isWhitelisted(List<Identifier> ids) {\n        StringBuffer sb = new StringBuffer();\n\n        for (int i = 0; i < ids.size(); i++) {\n            sb.append(ids.get(i).getValue());\n\n            if (i != ids.size() - 1) {\n                sb.append(\".\");\n            }\n        }\n\n        switch (sb.toString().toLowerCase(Locale.ROOT)) {\n        case \"queueable\":\n        case \"database.batchable\":\n        case \"installhandler\":\n            return true;\n        default:\n            break;\n        }\n        return false;\n    }\n\n    public static String getFQVariableName(Parameter p) {\n        StringBuffer sb = new StringBuffer();\n        sb.append(p.getDefiningType()).append(\":\").append(p.getName().getValue());\n        return sb.toString();\n    }\n\n    static String getFQVariableName(ASTParameter p) {\n        StringBuffer sb = new StringBuffer();\n        sb.append(p.getNode().getDefiningType()).append(\":\").append(p.getImage());\n        return sb.toString();\n    }\n\n}\n",
        "filePathAfter": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/security/Helper.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex.rule.security;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\n\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlDeleteStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlInsertStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlMergeStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlUndeleteStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlUpdateStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlUpsertStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTField;\nimport net.sourceforge.pmd.lang.apex.ast.ASTFieldDeclaration;\nimport net.sourceforge.pmd.lang.apex.ast.ASTMethodCallExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTModifierNode;\nimport net.sourceforge.pmd.lang.apex.ast.ASTNewKeyValueObjectExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTParameter;\nimport net.sourceforge.pmd.lang.apex.ast.ASTReferenceExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTSoqlExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTSoslExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTUserClass;\nimport net.sourceforge.pmd.lang.apex.ast.ASTVariableDeclaration;\nimport net.sourceforge.pmd.lang.apex.ast.ASTVariableExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ApexNode;\n\nimport apex.jorje.data.Identifier;\nimport apex.jorje.data.ast.TypeRef;\nimport apex.jorje.semantic.ast.expression.MethodCallExpression;\nimport apex.jorje.semantic.ast.expression.VariableExpression;\nimport apex.jorje.semantic.ast.member.Field;\nimport apex.jorje.semantic.ast.member.Parameter;\nimport apex.jorje.semantic.ast.statement.VariableDeclaration;\n\n/**\n * Helper methods\n * \n * @author sergey.gorbaty\n *\n */\npublic final class Helper {\n    static final String ANY_METHOD = \"*\";\n\n    private Helper() {\n        throw new AssertionError(\"Can't instantiate helper classes\");\n    }\n\n    static boolean isTestMethodOrClass(final ApexNode<?> node) {\n        final List<ASTModifierNode> modifierNode = node.findChildrenOfType(ASTModifierNode.class);\n        for (final ASTModifierNode m : modifierNode) {\n            if (m.isTest()) {\n                return true;\n            }\n        }\n\n        final String className = node.getNode().getDefiningType().getApexName();\n        return className.endsWith(\"Test\");\n    }\n\n    static boolean foundAnySOQLorSOSL(final ApexNode<?> node) {\n        final List<ASTSoqlExpression> dmlSoqlExpression = node.findDescendantsOfType(ASTSoqlExpression.class);\n        final List<ASTSoslExpression> dmlSoslExpression = node.findDescendantsOfType(ASTSoslExpression.class);\n\n        return !dmlSoqlExpression.isEmpty() || !dmlSoslExpression.isEmpty();\n    }\n\n    /**\n     * Finds DML operations in a given node descendants' path\n     * \n     * @param node\n     * \n     * @return true if found DML operations in node descendants\n     */\n    static boolean foundAnyDML(final ApexNode<?> node) {\n\n        final List<ASTDmlUpsertStatement> dmlUpsertStatement = node.findDescendantsOfType(ASTDmlUpsertStatement.class);\n        final List<ASTDmlUpdateStatement> dmlUpdateStatement = node.findDescendantsOfType(ASTDmlUpdateStatement.class);\n        final List<ASTDmlUndeleteStatement> dmlUndeleteStatement = node\n                .findDescendantsOfType(ASTDmlUndeleteStatement.class);\n        final List<ASTDmlMergeStatement> dmlMergeStatement = node.findDescendantsOfType(ASTDmlMergeStatement.class);\n        final List<ASTDmlInsertStatement> dmlInsertStatement = node.findDescendantsOfType(ASTDmlInsertStatement.class);\n        final List<ASTDmlDeleteStatement> dmlDeleteStatement = node.findDescendantsOfType(ASTDmlDeleteStatement.class);\n\n        return !dmlUpsertStatement.isEmpty() || !dmlUpdateStatement.isEmpty() || !dmlUndeleteStatement.isEmpty()\n                || !dmlMergeStatement.isEmpty() || !dmlInsertStatement.isEmpty() || !dmlDeleteStatement.isEmpty();\n    }\n\n    static boolean isMethodName(final ASTMethodCallExpression methodNode, final String className,\n            final String methodName) {\n        final ASTReferenceExpression reference = methodNode.getFirstChildOfType(ASTReferenceExpression.class);\n\n        return reference != null && reference.getNode().getNames().size() == 1\n                && reference.getNode().getNames().get(0).getValue().equalsIgnoreCase(className)\n                && (methodName.equals(ANY_METHOD) || isMethodName(methodNode, methodName));\n    }\n\n    static boolean isMethodName(final ASTMethodCallExpression m, final String methodName) {\n        return isMethodName(m.getNode(), methodName);\n    }\n\n    static boolean isMethodName(final MethodCallExpression m, final String methodName) {\n        return m.getMethodName().equalsIgnoreCase(methodName);\n    }\n\n    static boolean isMethodCallChain(final ASTMethodCallExpression methodNode, final String... methodNames) {\n        String methodName = methodNames[methodNames.length - 1];\n        if (Helper.isMethodName(methodNode, methodName)) {\n            final ASTReferenceExpression reference = methodNode.getFirstChildOfType(ASTReferenceExpression.class);\n            if (reference != null) {\n                final ASTMethodCallExpression nestedMethod = reference\n                        .getFirstChildOfType(ASTMethodCallExpression.class);\n                if (nestedMethod != null) {\n                    String[] newMethodNames = Arrays.copyOf(methodNames, methodNames.length - 1);\n                    return isMethodCallChain(nestedMethod, newMethodNames);\n                } else {\n                    String[] newClassName = Arrays.copyOf(methodNames, methodNames.length - 1);\n                    if (newClassName.length == 1) {\n                        return Helper.isMethodName(methodNode, newClassName[0], methodName);\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    static String getFQVariableName(final ASTVariableExpression variable) {\n        final ASTReferenceExpression ref = variable.getFirstChildOfType(ASTReferenceExpression.class);\n        String objectName = \"\";\n        if (ref != null) {\n            if (ref.getNode().getNames().size() == 1) {\n                objectName = ref.getNode().getNames().get(0).getValue() + \".\";\n            }\n        }\n\n        VariableExpression n = variable.getNode();\n        StringBuilder sb = new StringBuilder().append(n.getDefiningType().getApexName()).append(\":\").append(objectName)\n                .append(n.getIdentifier().getValue());\n        return sb.toString();\n    }\n\n    static String getFQVariableName(final ASTVariableDeclaration variable) {\n        VariableDeclaration n = variable.getNode();\n        StringBuilder sb = new StringBuilder().append(n.getDefiningType().getApexName()).append(\":\")\n                .append(n.getLocalInfo().getName());\n        return sb.toString();\n    }\n\n    static String getFQVariableName(final ASTField variable) {\n        Field n = variable.getNode();\n        StringBuilder sb = new StringBuilder()\n                .append(n.getDefiningType().getApexName()).append(\":\")\n                .append(n.getFieldInfo().getName());\n        return sb.toString();\n    }\n\n    static String getVariableType(final ASTField variable) {\n        Field n = variable.getNode();\n        StringBuilder sb = new StringBuilder().append(n.getDefiningType().getApexName()).append(\":\")\n                .append(n.getFieldInfo().getName());\n        return sb.toString();\n    }\n    \n    static String getFQVariableName(final ASTFieldDeclaration variable) {\n        StringBuilder sb = new StringBuilder()\n                .append(variable.getNode().getDefiningType().getApexName()).append(\":\")\n                .append(variable.getImage());\n        return sb.toString();\n    }\n\n    static String getFQVariableName(final ASTNewKeyValueObjectExpression variable) {\n        StringBuilder sb = new StringBuilder()\n                .append(variable.getNode().getDefiningType().getApexName()).append(\":\")\n                .append(variable.getType());\n        return sb.toString();\n    }\n\n    static boolean isSystemLevelClass(ASTUserClass node) {\n        List<TypeRef> interfaces = node.getNode().getDefiningType().getCodeUnitDetails().getInterfaceTypeRefs();\n\n        for (TypeRef intObject : interfaces) {\n            if (isWhitelisted(intObject.getNames())) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private static boolean isWhitelisted(List<Identifier> ids) {\n        StringBuffer sb = new StringBuffer();\n\n        for (int i = 0; i < ids.size(); i++) {\n            sb.append(ids.get(i).getValue());\n\n            if (i != ids.size() - 1) {\n                sb.append(\".\");\n            }\n        }\n\n        switch (sb.toString().toLowerCase(Locale.ROOT)) {\n        case \"queueable\":\n        case \"database.batchable\":\n        case \"installhandler\":\n            return true;\n        default:\n            break;\n        }\n        return false;\n    }\n\n    public static String getFQVariableName(Parameter p) {\n        StringBuffer sb = new StringBuffer();\n        sb.append(p.getDefiningType()).append(\":\").append(p.getName().getValue());\n        return sb.toString();\n    }\n\n    static String getFQVariableName(ASTParameter p) {\n        StringBuffer sb = new StringBuffer();\n        sb.append(p.getNode().getDefiningType()).append(\":\").append(p.getImage());\n        return sb.toString();\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "import net.sourceforge.pmd.lang.apex.ast.ASTModifierNode;\nimport net.sourceforge.pmd.lang.apex.ast.ASTNewKeyValueObjectExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTParameter;"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "static String getFQVariableName(final ASTNewKeyValueObjectExpression variable) {\n        StringBuilder sb = new StringBuilder()\n                .append(variable.getNode().getDefiningType().getApexName()).append(\":\")\n                .append(variable.getType());\n        return sb.toString();\n    }\nimport net.sourceforge.pmd.lang.apex.ast.ASTModifierNode;\nimport net.sourceforge.pmd.lang.apex.ast.ASTNewKeyValueObjectExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTParameter;",
        "diffSourceCode": "    20: import net.sourceforge.pmd.lang.apex.ast.ASTModifierNode;\n    21: import net.sourceforge.pmd.lang.apex.ast.ASTNewKeyValueObjectExpression;\n    22: import net.sourceforge.pmd.lang.apex.ast.ASTParameter;\n-  175:             f.setAccessible(true);\n-  176:             Identifier nameField = (Identifier) f.get(n);\n-  177:             name = nameField.getValue();\n-  178: \n-  179:         } catch (NoSuchFieldException | SecurityException | IllegalArgumentException | IllegalAccessException e) {\n-  180:             throw new RuntimeException(e);\n-  187:     static String getFQVariableName(final ASTNewKeyValueObjectExpression variable) {\n-  188:         NewKeyValueObjectExpression n = variable.getNode();\n-  189:         TypeRef typeRef = n.getTypeRef();\n-  190:         String objType = typeRef.getNames().get(0).getValue();\n-  191: \n-  192:         StringBuilder sb = new StringBuilder().append(n.getDefiningType().getApexName()).append(\":\").append(objType);\n-  193:         return sb.toString();\n-  194:     }\n+  175:     static String getFQVariableName(final ASTNewKeyValueObjectExpression variable) {\n+  176:         StringBuilder sb = new StringBuilder()\n+  177:                 .append(variable.getNode().getDefiningType().getApexName()).append(\":\")\n+  178:                 .append(variable.getType());\n+  179:         return sb.toString();\n+  180:     }\n+  187:                 return true;\n+  188:             }\n+  189:         }\n+  190: \n+  191:         return false;\n+  192:     }\n+  193: \n+  194:     private static boolean isWhitelisted(List<Identifier> ids) {\n",
        "uniqueId": "91d0ebf4620b9cda44ce6f02232fe8a003d82efd_187_194_20_22_175_180",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 19
            },
            "LINE": {
                "missed": 0,
                "covered": 3
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic getValue() : String extracted from public getImage() : String in class net.sourceforge.pmd.lang.apex.ast.ASTAnnotationParameter",
        "diffLocations": [
            {
                "filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTAnnotationParameter.java",
                "startLine": 20,
                "endLine": 26,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTAnnotationParameter.java",
                "startLine": 39,
                "endLine": 42,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTAnnotationParameter.java",
                "startLine": 28,
                "endLine": 33,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n    public String getImage() {\n        if (node.getValue() != null) {\n            return node.getValueAsString();\n        }\n        return null;\n    }",
        "filePathBefore": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTAnnotationParameter.java",
        "isPureRefactoring": true,
        "commitId": "acb30271668581c270c352d85bda4c171b404ce2",
        "packageNameBefore": "net.sourceforge.pmd.lang.apex.ast",
        "classNameBefore": "net.sourceforge.pmd.lang.apex.ast.ASTAnnotationParameter",
        "methodNameBefore": "net.sourceforge.pmd.lang.apex.ast.ASTAnnotationParameter#getImage",
        "classSignatureBefore": "public class ASTAnnotationParameter extends AbstractApexNode<AnnotationParameter> ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.apex.ast.ASTAnnotationParameter#getImage"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.apex.ast.ASTAnnotationParameter"
        ],
        "classSignatureBeforeSet": [
            "public class ASTAnnotationParameter extends AbstractApexNode<AnnotationParameter> "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex.ast;\n\nimport apex.jorje.semantic.ast.modifier.AnnotationParameter;\n\npublic class ASTAnnotationParameter extends AbstractApexNode<AnnotationParameter> {\n\n    public ASTAnnotationParameter(AnnotationParameter annotationParameter) {\n        super(annotationParameter);\n    }\n\n    @Override\n    public Object jjtAccept(ApexParserVisitor visitor, Object data) {\n        return visitor.visit(this, data);\n    }\n\n    @Override\n    public String getImage() {\n        if (node.getValue() != null) {\n            return node.getValueAsString();\n        }\n        return null;\n    }\n}\n",
        "filePathAfter": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/ast/ASTAnnotationParameter.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex.ast;\n\nimport apex.jorje.semantic.ast.modifier.AnnotationParameter;\n\npublic class ASTAnnotationParameter extends AbstractApexNode<AnnotationParameter> {\n    public static final String SEE_ALL_DATA = \"seeAllData\";\n\n    public ASTAnnotationParameter(AnnotationParameter annotationParameter) {\n        super(annotationParameter);\n    }\n\n    @Override\n    public Object jjtAccept(ApexParserVisitor visitor, Object data) {\n        return visitor.visit(this, data);\n    }\n\n    public String getName() {\n        if (node.getProperty() != null) {\n            return node.getProperty().getName();\n        }\n        return null;\n    }\n\n    public String getValue() {\n        if (node.getValue() != null) {\n            return node.getValueAsString();\n        }\n        return null;\n    }\n\n    public Boolean getBooleanValue() {\n        return node.getBooleanValue();\n    }\n\n    @Override\n    public String getImage() {\n        return getValue();\n    }\n}\n",
        "diffSourceCodeSet": [
            "public String getValue() {\n        if (node.getValue() != null) {\n            return node.getValueAsString();\n        }\n        return null;\n    }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "@Override\n    public String getImage() {\n        return getValue();\n    }\npublic String getValue() {\n        if (node.getValue() != null) {\n            return node.getValueAsString();\n        }\n        return null;\n    }",
        "diffSourceCode": "-   20:     @Override\n-   21:     public String getImage() {\n-   22:         if (node.getValue() != null) {\n-   23:             return node.getValueAsString();\n+   20: \n+   21:     public String getName() {\n+   22:         if (node.getProperty() != null) {\n+   23:             return node.getProperty().getName();\n    24:         }\n    25:         return null;\n    26:     }\n+   28:     public String getValue() {\n+   29:         if (node.getValue() != null) {\n+   30:             return node.getValueAsString();\n+   31:         }\n+   32:         return null;\n+   33:     }\n+   39:     @Override\n+   40:     public String getImage() {\n+   41:         return getValue();\n+   42:     }\n",
        "uniqueId": "acb30271668581c270c352d85bda4c171b404ce2_20_26_28_33_39_42",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 2,
                "covered": 10
            },
            "BRANCH": {
                "missed": 1,
                "covered": 1
            },
            "LINE": {
                "missed": 1,
                "covered": 2
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpackage getComment(commentOwner JavadocCommentOwner) : FormalComment extracted from public getJavadocComment() : FormalComment in class net.sourceforge.pmd.lang.java.ast.JavadocCommentOwner & moved to class net.sourceforge.pmd.lang.java.ast.CommentAssignmentPass",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JavadocCommentOwner.java",
                "startLine": 14,
                "endLine": 20,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JavadocCommentOwner.java",
                "startLine": 14,
                "endLine": 20,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JavadocCommentOwner.java",
                "startLine": 26,
                "endLine": 28,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Returns the javadoc comment that applies to this declaration. If\n     * there is none, returns null.\n     */\n    default @Nullable FormalComment getJavadocComment() {\n        return getUserMap().get(CommentAssignmentPass.FORMAL_COMMENT_KEY);\n    }",
        "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JavadocCommentOwner.java",
        "isPureRefactoring": true,
        "commitId": "97c08a37ab6e5f0dc0bc2c38d865207b69b7eb2d",
        "packageNameBefore": "net.sourceforge.pmd.lang.java.ast",
        "classNameBefore": "net.sourceforge.pmd.lang.java.ast.JavadocCommentOwner",
        "methodNameBefore": "net.sourceforge.pmd.lang.java.ast.JavadocCommentOwner#getJavadocComment",
        "classSignatureBefore": "public interface JavadocCommentOwner extends JavaNode ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.ast.JavadocCommentOwner#getJavadocComment"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.ast.JavadocCommentOwner"
        ],
        "classSignatureBeforeSet": [
            "public interface JavadocCommentOwner extends JavaNode "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics",
                "description": "All the mappings are matched! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.ast;\n\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\n/**\n * A node that may own a javadoc comment.\n */\npublic interface JavadocCommentOwner extends JavaNode {\n\n    /**\n     * Returns the javadoc comment that applies to this declaration. If\n     * there is none, returns null.\n     */\n    default @Nullable FormalComment getJavadocComment() {\n        return getUserMap().get(CommentAssignmentPass.FORMAL_COMMENT_KEY);\n    }\n\n}\n",
        "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/JavadocCommentOwner.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.ast;\n\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\n/**\n * A node that may own a javadoc comment.\n */\npublic interface JavadocCommentOwner extends JavaNode {\n\n    /**\n     * Returns the javadoc comment that applies to this declaration. If\n     * there is none, returns null.\n     */\n    default @Nullable FormalComment getJavadocComment() {\n        return CommentAssignmentPass.getComment(this);\n    }\n\n}\n",
        "diffSourceCodeSet": [
            ""
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "/**\n     * Returns the javadoc comment that applies to this declaration. If\n     * there is none, returns null.\n     */\n    default @Nullable FormalComment getJavadocComment() {\n        return CommentAssignmentPass.getComment(this);\n    }\n",
        "diffSourceCode": "    14:     /**\n    15:      * Returns the javadoc comment that applies to this declaration. If\n    16:      * there is none, returns null.\n    17:      */\n    18:     default @Nullable FormalComment getJavadocComment() {\n-   19:         return getUserMap().get(CommentAssignmentPass.FORMAL_COMMENT_KEY);\n+   19:         return CommentAssignmentPass.getComment(this);\n    20:     }\n",
        "uniqueId": "97c08a37ab6e5f0dc0bc2c38d865207b69b7eb2d_14_20_26_28_14_20",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 6
            },
            "LINE": {
                "missed": 0,
                "covered": 1
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic reportToLogger(logger Logger) : SemanticErrorReporter extracted from public defaultLogger() : SemanticChecksLogger in class net.sourceforge.pmd.lang.java.internal.JavaAstProcessor & moved to class net.sourceforge.pmd.lang.ast.SemanticErrorReporter",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/internal/JavaAstProcessor.java",
                "startLine": 144,
                "endLine": 160,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/internal/JavaAstProcessor.java",
                "startLine": 142,
                "endLine": 144,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/internal/JavaAstProcessor.java",
                "startLine": 71,
                "endLine": 106,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public static SemanticChecksLogger defaultLogger() {\n        return new SemanticChecksLogger() {\n            private String locPrefix(JavaNode loc) {\n                return \"[\" + loc.getBeginLine() + \",\" + loc.getBeginColumn() + \"] \";\n            }\n\n            @Override\n            public void warning(JavaNode location, String message, Object... args) {\n                DEFAULT_LOG.fine(() -> locPrefix(location) + MessageFormat.format(message, args));\n            }\n\n            @Override\n            public void error(JavaNode location, String message, Object... args) {\n                DEFAULT_LOG.severe(() -> locPrefix(location) + MessageFormat.format(message, args));\n            }\n        };\n    }",
        "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/internal/JavaAstProcessor.java",
        "isPureRefactoring": true,
        "commitId": "da03fafabb2146ca3b2cd3f61484754490dfc9fb",
        "packageNameBefore": "net.sourceforge.pmd.lang.java.internal",
        "classNameBefore": "net.sourceforge.pmd.lang.java.internal.JavaAstProcessor",
        "methodNameBefore": "net.sourceforge.pmd.lang.java.internal.JavaAstProcessor#defaultLogger",
        "classSignatureBefore": "public final class JavaAstProcessor ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.internal.JavaAstProcessor#defaultLogger"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.internal.JavaAstProcessor"
        ],
        "classSignatureBeforeSet": [
            "public final class JavaAstProcessor "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics\nTolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.internal;\n\nimport java.text.MessageFormat;\nimport java.util.IdentityHashMap;\nimport java.util.Map;\nimport java.util.function.Supplier;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport net.sourceforge.pmd.benchmark.TimeTracker;\nimport net.sourceforge.pmd.benchmark.TimedOperation;\nimport net.sourceforge.pmd.benchmark.TimedOperationCategory;\nimport net.sourceforge.pmd.lang.LanguageVersion;\nimport net.sourceforge.pmd.lang.ast.NodeStream;\nimport net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;\nimport net.sourceforge.pmd.lang.java.ast.InternalApiBridge;\nimport net.sourceforge.pmd.lang.java.ast.JavaNode;\nimport net.sourceforge.pmd.lang.java.symbols.JClassSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JTypeDeclSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.SymbolResolver;\nimport net.sourceforge.pmd.lang.java.symbols.internal.UnresolvedClassStore;\nimport net.sourceforge.pmd.lang.java.symbols.internal.ast.SymbolResolutionPass;\nimport net.sourceforge.pmd.lang.java.symbols.table.internal.ReferenceCtx;\nimport net.sourceforge.pmd.lang.java.symbols.table.internal.SemanticChecksLogger;\nimport net.sourceforge.pmd.lang.java.symbols.table.internal.SymbolTableResolver;\nimport net.sourceforge.pmd.lang.java.types.TypeSystem;\nimport net.sourceforge.pmd.lang.java.types.internal.infer.TypeInferenceLogger;\nimport net.sourceforge.pmd.lang.java.types.internal.infer.TypeInferenceLogger.SimpleLogger;\nimport net.sourceforge.pmd.lang.java.types.internal.infer.TypeInferenceLogger.VerboseLogger;\n\n/**\n * Processes the output of the parser before rules get access to the AST.\n * This performs all semantic analyses in layered passes.\n *\n * <p>This is the root context object for file-specific context. Instances\n * do not need to be thread-safe. Global information about eg the classpath\n * is held in a {@link TypeSystem} instance.\n */\npublic final class JavaAstProcessor {\n\n    private static final Logger DEFAULT_LOG = Logger.getLogger(JavaAstProcessor.class.getName());\n\n    private static final Map<ClassLoader, TypeSystem> TYPE_SYSTEMS = new IdentityHashMap<>();\n    private static final Level INFERENCE_LOG_LEVEL;\n\n\n    static {\n        Level level;\n        try {\n            level = Level.parse(System.getenv(\"PMD_DEBUG_LEVEL\"));\n        } catch (IllegalArgumentException | NullPointerException ignored) {\n            level = Level.OFF;\n        }\n        INFERENCE_LOG_LEVEL = level;\n    }\n\n\n    private final TypeInferenceLogger typeInferenceLogger;\n    private final SemanticChecksLogger logger;\n    private final LanguageVersion languageVersion;\n    private final TypeSystem typeSystem;\n\n    private SymbolResolver symResolver;\n\n    private final UnresolvedClassStore unresolvedTypes;\n\n\n    private JavaAstProcessor(TypeSystem typeSystem,\n                             SymbolResolver symResolver,\n                             SemanticChecksLogger logger,\n                             TypeInferenceLogger typeInfLogger,\n                             LanguageVersion languageVersion) {\n\n        this.symResolver = symResolver;\n        this.logger = logger;\n        this.typeInferenceLogger = typeInfLogger;\n        this.languageVersion = languageVersion;\n\n        this.typeSystem = typeSystem;\n        unresolvedTypes = new UnresolvedClassStore(typeSystem);\n    }\n\n    static TypeInferenceLogger defaultTypeInfLogger() {\n        if (INFERENCE_LOG_LEVEL == Level.FINEST) {\n            return new VerboseLogger(System.err);\n        } else if (INFERENCE_LOG_LEVEL == Level.FINE) {\n            return new SimpleLogger(System.err);\n        } else {\n            return TypeInferenceLogger.noop();\n        }\n    }\n\n    public JClassSymbol makeUnresolvedReference(String canonicalName, int typeArity) {\n        return unresolvedTypes.makeUnresolvedReference(canonicalName, typeArity);\n    }\n\n    public JClassSymbol makeUnresolvedReference(JTypeDeclSymbol outer, String simpleName, int typeArity) {\n        if (outer instanceof JClassSymbol) {\n            return unresolvedTypes.makeUnresolvedReference((JClassSymbol) outer, simpleName, typeArity);\n        }\n        return makeUnresolvedReference(\"error.\" + simpleName, typeArity);\n    }\n\n    public SymbolResolver getSymResolver() {\n        return symResolver;\n    }\n\n    public SemanticChecksLogger getLogger() {\n        return logger;\n    }\n\n    public LanguageVersion getLanguageVersion() {\n        return languageVersion;\n    }\n\n    public int getJdkVersion() {\n        return ((JavaLanguageHandler) languageVersion.getLanguageVersionHandler()).getJdkVersion();\n    }\n\n    /**\n     * Performs semantic analysis on the given source file.\n     */\n    public void process(ASTCompilationUnit acu) {\n\n        SymbolResolver knownSyms = bench(\"Symbol resolution\", () -> SymbolResolutionPass.traverse(this, acu));\n\n        // Now symbols are on the relevant nodes\n        this.symResolver = SymbolResolver.layer(knownSyms, this.symResolver);\n\n        InternalApiBridge.initTypeResolver(acu, this, typeInferenceLogger);\n\n        bench(\"2. Symbol table resolution\", () -> SymbolTableResolver.traverse(this, acu));\n        bench(\"3. AST disambiguation\", () -> InternalApiBridge.disambigWithCtx(NodeStream.of(acu), ReferenceCtx.root(this, acu)));\n    }\n\n    public TypeSystem getTypeSystem() {\n        return typeSystem;\n    }\n\n    public static SemanticChecksLogger defaultLogger() {\n        return new SemanticChecksLogger() {\n            private String locPrefix(JavaNode loc) {\n                return \"[\" + loc.getBeginLine() + \",\" + loc.getBeginColumn() + \"] \";\n            }\n\n            @Override\n            public void warning(JavaNode location, String message, Object... args) {\n                DEFAULT_LOG.fine(() -> locPrefix(location) + MessageFormat.format(message, args));\n            }\n\n            @Override\n            public void error(JavaNode location, String message, Object... args) {\n                DEFAULT_LOG.severe(() -> locPrefix(location) + MessageFormat.format(message, args));\n            }\n        };\n    }\n\n    public static JavaAstProcessor create(SymbolResolver symResolver,\n                                          TypeSystem typeSystem,\n                                          LanguageVersion languageVersion,\n                                          SemanticChecksLogger logger) {\n\n        return new JavaAstProcessor(\n            typeSystem,\n            symResolver,\n            logger,\n            defaultTypeInfLogger(),\n            languageVersion\n        );\n    }\n\n    public static JavaAstProcessor create(ClassLoader classLoader,\n                                          LanguageVersion languageVersion,\n                                          SemanticChecksLogger logger,\n                                          TypeInferenceLogger typeInfLogger) {\n\n        TypeSystem typeSystem = TYPE_SYSTEMS.computeIfAbsent(classLoader, TypeSystem::new);\n        return new JavaAstProcessor(\n            typeSystem,\n            typeSystem.bootstrapResolver(),\n            logger,\n            typeInfLogger,\n            languageVersion\n        );\n    }\n\n    public static JavaAstProcessor create(TypeSystem typeSystem,\n                                          LanguageVersion languageVersion,\n                                          SemanticChecksLogger semanticLogger,\n                                          TypeInferenceLogger typeInfLogger) {\n        return new JavaAstProcessor(\n            typeSystem,\n            typeSystem.bootstrapResolver(),\n            semanticLogger,\n            typeInfLogger,\n            languageVersion\n        );\n    }\n\n    public static void bench(String label, Runnable runnable) {\n        try (TimedOperation to = TimeTracker.startOperation(TimedOperationCategory.LANGUAGE_SPECIFIC_PROCESSING, label)) {\n            runnable.run();\n        }\n    }\n\n    public static <T> T bench(String label, Supplier<T> runnable) {\n        try (TimedOperation to = TimeTracker.startOperation(TimedOperationCategory.LANGUAGE_SPECIFIC_PROCESSING, label)) {\n            return runnable.get();\n        }\n    }\n}\n",
        "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/internal/JavaAstProcessor.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.internal;\n\nimport java.util.IdentityHashMap;\nimport java.util.Map;\nimport java.util.function.Supplier;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport net.sourceforge.pmd.benchmark.TimeTracker;\nimport net.sourceforge.pmd.benchmark.TimedOperation;\nimport net.sourceforge.pmd.benchmark.TimedOperationCategory;\nimport net.sourceforge.pmd.lang.LanguageVersion;\nimport net.sourceforge.pmd.lang.ast.NodeStream;\nimport net.sourceforge.pmd.lang.ast.SemanticErrorReporter;\nimport net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;\nimport net.sourceforge.pmd.lang.java.ast.InternalApiBridge;\nimport net.sourceforge.pmd.lang.java.symbols.JClassSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JTypeDeclSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.SymbolResolver;\nimport net.sourceforge.pmd.lang.java.symbols.internal.UnresolvedClassStore;\nimport net.sourceforge.pmd.lang.java.symbols.internal.ast.SymbolResolutionPass;\nimport net.sourceforge.pmd.lang.java.symbols.table.internal.ReferenceCtx;\nimport net.sourceforge.pmd.lang.java.symbols.table.internal.SymbolTableResolver;\nimport net.sourceforge.pmd.lang.java.types.TypeSystem;\nimport net.sourceforge.pmd.lang.java.types.internal.infer.TypeInferenceLogger;\nimport net.sourceforge.pmd.lang.java.types.internal.infer.TypeInferenceLogger.SimpleLogger;\nimport net.sourceforge.pmd.lang.java.types.internal.infer.TypeInferenceLogger.VerboseLogger;\n\n/**\n * Processes the output of the parser before rules get access to the AST.\n * This performs all semantic analyses in layered passes.\n *\n * <p>This is the root context object for file-specific context. Instances\n * do not need to be thread-safe. Global information about eg the classpath\n * is held in a {@link TypeSystem} instance.\n */\npublic final class JavaAstProcessor {\n\n    private static final Logger DEFAULT_LOG = Logger.getLogger(JavaAstProcessor.class.getName());\n\n    private static final Map<ClassLoader, TypeSystem> TYPE_SYSTEMS = new IdentityHashMap<>();\n    private static final Level INFERENCE_LOG_LEVEL;\n\n\n    static {\n        Level level;\n        try {\n            level = Level.parse(System.getenv(\"PMD_DEBUG_LEVEL\"));\n        } catch (IllegalArgumentException | NullPointerException ignored) {\n            level = Level.OFF;\n        }\n        INFERENCE_LOG_LEVEL = level;\n    }\n\n\n    private final TypeInferenceLogger typeInferenceLogger;\n    private final SemanticErrorReporter logger;\n    private final LanguageVersion languageVersion;\n    private final TypeSystem typeSystem;\n\n    private SymbolResolver symResolver;\n\n    private final UnresolvedClassStore unresolvedTypes;\n\n\n    private JavaAstProcessor(TypeSystem typeSystem,\n                             SymbolResolver symResolver,\n                             SemanticErrorReporter logger,\n                             TypeInferenceLogger typeInfLogger,\n                             LanguageVersion languageVersion) {\n\n        this.symResolver = symResolver;\n        this.logger = logger;\n        this.typeInferenceLogger = typeInfLogger;\n        this.languageVersion = languageVersion;\n\n        this.typeSystem = typeSystem;\n        unresolvedTypes = new UnresolvedClassStore(typeSystem);\n    }\n\n    static TypeInferenceLogger defaultTypeInfLogger() {\n        if (INFERENCE_LOG_LEVEL == Level.FINEST) {\n            return new VerboseLogger(System.err);\n        } else if (INFERENCE_LOG_LEVEL == Level.FINE) {\n            return new SimpleLogger(System.err);\n        } else {\n            return TypeInferenceLogger.noop();\n        }\n    }\n\n    public JClassSymbol makeUnresolvedReference(String canonicalName, int typeArity) {\n        return unresolvedTypes.makeUnresolvedReference(canonicalName, typeArity);\n    }\n\n    public JClassSymbol makeUnresolvedReference(JTypeDeclSymbol outer, String simpleName, int typeArity) {\n        if (outer instanceof JClassSymbol) {\n            return unresolvedTypes.makeUnresolvedReference((JClassSymbol) outer, simpleName, typeArity);\n        }\n        return makeUnresolvedReference(\"error.\" + simpleName, typeArity);\n    }\n\n    public SymbolResolver getSymResolver() {\n        return symResolver;\n    }\n\n    public SemanticErrorReporter getLogger() {\n        return logger;\n    }\n\n    public LanguageVersion getLanguageVersion() {\n        return languageVersion;\n    }\n\n    public int getJdkVersion() {\n        return ((JavaLanguageHandler) languageVersion.getLanguageVersionHandler()).getJdkVersion();\n    }\n\n    /**\n     * Performs semantic analysis on the given source file.\n     */\n    public void process(ASTCompilationUnit acu) {\n\n        SymbolResolver knownSyms = bench(\"Symbol resolution\", () -> SymbolResolutionPass.traverse(this, acu));\n\n        // Now symbols are on the relevant nodes\n        this.symResolver = SymbolResolver.layer(knownSyms, this.symResolver);\n\n        InternalApiBridge.initTypeResolver(acu, this, typeInferenceLogger);\n\n        bench(\"2. Symbol table resolution\", () -> SymbolTableResolver.traverse(this, acu));\n        bench(\"3. AST disambiguation\", () -> InternalApiBridge.disambigWithCtx(NodeStream.of(acu), ReferenceCtx.root(this, acu)));\n    }\n\n    public TypeSystem getTypeSystem() {\n        return typeSystem;\n    }\n\n    public static SemanticErrorReporter defaultLogger() {\n        return SemanticErrorReporter.reportToLogger(DEFAULT_LOG);\n    }\n\n    public static JavaAstProcessor create(SymbolResolver symResolver,\n                                          TypeSystem typeSystem,\n                                          LanguageVersion languageVersion,\n                                          SemanticErrorReporter logger) {\n\n        return new JavaAstProcessor(\n            typeSystem,\n            symResolver,\n            logger,\n            defaultTypeInfLogger(),\n            languageVersion\n        );\n    }\n\n    public static JavaAstProcessor create(ClassLoader classLoader,\n                                          LanguageVersion languageVersion,\n                                          SemanticErrorReporter logger,\n                                          TypeInferenceLogger typeInfLogger) {\n\n        TypeSystem typeSystem = TYPE_SYSTEMS.computeIfAbsent(classLoader, TypeSystem::new);\n        return new JavaAstProcessor(\n            typeSystem,\n            typeSystem.bootstrapResolver(),\n            logger,\n            typeInfLogger,\n            languageVersion\n        );\n    }\n\n    public static JavaAstProcessor create(TypeSystem typeSystem,\n                                          LanguageVersion languageVersion,\n                                          SemanticErrorReporter semanticLogger,\n                                          TypeInferenceLogger typeInfLogger) {\n        return new JavaAstProcessor(\n            typeSystem,\n            typeSystem.bootstrapResolver(),\n            semanticLogger,\n            typeInfLogger,\n            languageVersion\n        );\n    }\n\n    public static void bench(String label, Runnable runnable) {\n        try (TimedOperation to = TimeTracker.startOperation(TimedOperationCategory.LANGUAGE_SPECIFIC_PROCESSING, label)) {\n            runnable.run();\n        }\n    }\n\n    public static <T> T bench(String label, Supplier<T> runnable) {\n        try (TimedOperation to = TimeTracker.startOperation(TimedOperationCategory.LANGUAGE_SPECIFIC_PROCESSING, label)) {\n            return runnable.get();\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            "SymbolResolver symResolver,\n                             SemanticErrorReporter logger,\n                             TypeInferenceLogger typeInfLogger,\n                             LanguageVersion languageVersion) {\n\n        this.symResolver = symResolver;\n        this.logger = logger;\n        this.typeInferenceLogger = typeInfLogger;\n        this.languageVersion = languageVersion;\n\n        this.typeSystem = typeSystem;\n        unresolvedTypes = new UnresolvedClassStore(typeSystem);\n    }\n\n    static TypeInferenceLogger defaultTypeInfLogger() {\n        if (INFERENCE_LOG_LEVEL == Level.FINEST) {\n            return new VerboseLogger(System.err);\n        } else if (INFERENCE_LOG_LEVEL == Level.FINE) {\n            return new SimpleLogger(System.err);\n        } else {\n            return TypeInferenceLogger.noop();\n        }\n    }\n\n    public JClassSymbol makeUnresolvedReference(String canonicalName, int typeArity) {\n        return unresolvedTypes.makeUnresolvedReference(canonicalName, typeArity);\n    }\n\n    public JClassSymbol makeUnresolvedReference(JTypeDeclSymbol outer, String simpleName, int typeArity) {\n        if (outer instanceof JClassSymbol) {\n            return unresolvedTypes.makeUnresolvedReference((JClassSymbol) outer, simpleName, typeArity);\n        }\n        return makeUnresolvedReference(\"error.\" + simpleName, typeArity);\n    }\n\n    public SymbolResolver getSymResolver() {"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "public static SemanticErrorReporter defaultLogger() {\n        return SemanticErrorReporter.reportToLogger(DEFAULT_LOG);\n    }\nSymbolResolver symResolver,\n                             SemanticErrorReporter logger,\n                             TypeInferenceLogger typeInfLogger,\n                             LanguageVersion languageVersion) {\n\n        this.symResolver = symResolver;\n        this.logger = logger;\n        this.typeInferenceLogger = typeInfLogger;\n        this.languageVersion = languageVersion;\n\n        this.typeSystem = typeSystem;\n        unresolvedTypes = new UnresolvedClassStore(typeSystem);\n    }\n\n    static TypeInferenceLogger defaultTypeInfLogger() {\n        if (INFERENCE_LOG_LEVEL == Level.FINEST) {\n            return new VerboseLogger(System.err);\n        } else if (INFERENCE_LOG_LEVEL == Level.FINE) {\n            return new SimpleLogger(System.err);\n        } else {\n            return TypeInferenceLogger.noop();\n        }\n    }\n\n    public JClassSymbol makeUnresolvedReference(String canonicalName, int typeArity) {\n        return unresolvedTypes.makeUnresolvedReference(canonicalName, typeArity);\n    }\n\n    public JClassSymbol makeUnresolvedReference(JTypeDeclSymbol outer, String simpleName, int typeArity) {\n        if (outer instanceof JClassSymbol) {\n            return unresolvedTypes.makeUnresolvedReference((JClassSymbol) outer, simpleName, typeArity);\n        }\n        return makeUnresolvedReference(\"error.\" + simpleName, typeArity);\n    }\n\n    public SymbolResolver getSymResolver() {",
        "diffSourceCode": "-   71: \n-   72:     private JavaAstProcessor(TypeSystem typeSystem,\n-   73:                              SymbolResolver symResolver,\n-   74:                              SemanticChecksLogger logger,\n-   75:                              TypeInferenceLogger typeInfLogger,\n-   76:                              LanguageVersion languageVersion) {\n-   77: \n-   78:         this.symResolver = symResolver;\n-   79:         this.logger = logger;\n-   80:         this.typeInferenceLogger = typeInfLogger;\n-   81:         this.languageVersion = languageVersion;\n-   82: \n-   83:         this.typeSystem = typeSystem;\n-   84:         unresolvedTypes = new UnresolvedClassStore(typeSystem);\n-   85:     }\n-   86: \n-   87:     static TypeInferenceLogger defaultTypeInfLogger() {\n-   88:         if (INFERENCE_LOG_LEVEL == Level.FINEST) {\n-   89:             return new VerboseLogger(System.err);\n-   90:         } else if (INFERENCE_LOG_LEVEL == Level.FINE) {\n-   91:             return new SimpleLogger(System.err);\n-   92:         } else {\n-   93:             return TypeInferenceLogger.noop();\n-   94:         }\n-   95:     }\n-   96: \n-   97:     public JClassSymbol makeUnresolvedReference(String canonicalName, int typeArity) {\n-   98:         return unresolvedTypes.makeUnresolvedReference(canonicalName, typeArity);\n-   99:     }\n-  100: \n-  101:     public JClassSymbol makeUnresolvedReference(JTypeDeclSymbol outer, String simpleName, int typeArity) {\n-  102:         if (outer instanceof JClassSymbol) {\n-  103:             return unresolvedTypes.makeUnresolvedReference((JClassSymbol) outer, simpleName, typeArity);\n-  104:         }\n-  105:         return makeUnresolvedReference(\"error.\" + simpleName, typeArity);\n-  106:     }\n-  142:     }\n-  143: \n-  144:     public static SemanticChecksLogger defaultLogger() {\n-  145:         return new SemanticChecksLogger() {\n-  146:             private String locPrefix(JavaNode loc) {\n-  147:                 return \"[\" + loc.getBeginLine() + \",\" + loc.getBeginColumn() + \"] \";\n-  148:             }\n-  149: \n-  150:             @Override\n-  151:             public void warning(JavaNode location, String message, Object... args) {\n-  152:                 DEFAULT_LOG.fine(() -> locPrefix(location) + MessageFormat.format(message, args));\n-  153:             }\n-  154: \n-  155:             @Override\n-  156:             public void error(JavaNode location, String message, Object... args) {\n-  157:                 DEFAULT_LOG.severe(() -> locPrefix(location) + MessageFormat.format(message, args));\n-  158:             }\n-  159:         };\n-  160:     }\n+   71:                              SymbolResolver symResolver,\n+   72:                              SemanticErrorReporter logger,\n+   73:                              TypeInferenceLogger typeInfLogger,\n+   74:                              LanguageVersion languageVersion) {\n+   75: \n+   76:         this.symResolver = symResolver;\n+   77:         this.logger = logger;\n+   78:         this.typeInferenceLogger = typeInfLogger;\n+   79:         this.languageVersion = languageVersion;\n+   80: \n+   81:         this.typeSystem = typeSystem;\n+   82:         unresolvedTypes = new UnresolvedClassStore(typeSystem);\n+   83:     }\n+   84: \n+   85:     static TypeInferenceLogger defaultTypeInfLogger() {\n+   86:         if (INFERENCE_LOG_LEVEL == Level.FINEST) {\n+   87:             return new VerboseLogger(System.err);\n+   88:         } else if (INFERENCE_LOG_LEVEL == Level.FINE) {\n+   89:             return new SimpleLogger(System.err);\n+   90:         } else {\n+   91:             return TypeInferenceLogger.noop();\n+   92:         }\n+   93:     }\n+   94: \n+   95:     public JClassSymbol makeUnresolvedReference(String canonicalName, int typeArity) {\n+   96:         return unresolvedTypes.makeUnresolvedReference(canonicalName, typeArity);\n+   97:     }\n+   98: \n+   99:     public JClassSymbol makeUnresolvedReference(JTypeDeclSymbol outer, String simpleName, int typeArity) {\n+  100:         if (outer instanceof JClassSymbol) {\n+  101:             return unresolvedTypes.makeUnresolvedReference((JClassSymbol) outer, simpleName, typeArity);\n+  102:         }\n+  103:         return makeUnresolvedReference(\"error.\" + simpleName, typeArity);\n+  104:     }\n+  105: \n+  106:     public SymbolResolver getSymResolver() {\n+  142:     public static SemanticErrorReporter defaultLogger() {\n+  143:         return SemanticErrorReporter.reportToLogger(DEFAULT_LOG);\n+  144:     }\n+  145: \n+  146:     public static JavaAstProcessor create(SymbolResolver symResolver,\n+  147:                                           TypeSystem typeSystem,\n+  148:                                           LanguageVersion languageVersion,\n+  149:                                           SemanticErrorReporter logger) {\n+  150: \n+  151:         return new JavaAstProcessor(\n+  152:             typeSystem,\n+  153:             symResolver,\n+  154:             logger,\n+  155:             defaultTypeInfLogger(),\n+  156:             languageVersion\n+  157:         );\n+  158:     }\n+  159: \n+  160:     public static JavaAstProcessor create(ClassLoader classLoader,\n",
        "uniqueId": "da03fafabb2146ca3b2cd3f61484754490dfc9fb_144_160_71_106_142_144",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 4
            },
            "LINE": {
                "missed": 0,
                "covered": 1
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate assertIsA(node TypeNode, type Class<?>, exactly boolean, expectTrue boolean) : void extracted from private assertIsA(node TypeNode, type Class<?>) : void in class net.sourceforge.pmd.lang.java.types.TypeTestUtilTest",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/test/java/net/sourceforge/pmd/lang/java/types/TypeTestUtilTest.java",
                "startLine": 163,
                "endLine": 168,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/test/java/net/sourceforge/pmd/lang/java/types/TypeTestUtilTest.java",
                "startLine": 213,
                "endLine": 215,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/test/java/net/sourceforge/pmd/lang/java/types/TypeTestUtilTest.java",
                "startLine": 236,
                "endLine": 245,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private void assertIsA(TypeNode node, Class<?> type) {\n        Assert.assertTrue(\"TypeTestUtil::isA with class arg: \" + type.getCanonicalName(),\n                          TypeTestUtil.isA(type, node));\n        Assert.assertTrue(\"TypeTestUtil::isA with string arg: \" + type.getCanonicalName(),\n                          TypeTestUtil.isA(type.getCanonicalName(), node));\n    }",
        "filePathBefore": "pmd-java/src/test/java/net/sourceforge/pmd/lang/java/types/TypeTestUtilTest.java",
        "isPureRefactoring": true,
        "commitId": "20930119137620c622b742dda74f24c55f7ab70d",
        "packageNameBefore": "net.sourceforge.pmd.lang.java.types",
        "classNameBefore": "net.sourceforge.pmd.lang.java.types.TypeTestUtilTest",
        "methodNameBefore": "net.sourceforge.pmd.lang.java.types.TypeTestUtilTest#assertIsA",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.java.types.TypeTestUtil#isA\n methodBody: public static boolean isA(/*@NonNull*/ String canonicalName, /*@Nullable*/ TypeNode node) {\nrequireParamNotNull(\"canonicalName\",canonicalName);\nif(node == null){return false;\n}Class<?> nodeType=node.getType();\nif(nodeType == null){return fallbackIsA(node,canonicalName,true);\n}if(nodeType.isAnnotation()){return isAnnotationSubtype(nodeType,canonicalName);\n}final Class<?> clazz=loadClassWithNodeClassloader(node,canonicalName);\nif(clazz != null){if(clazz.getCanonicalName() == null){return false;\n}return clazz.isAssignableFrom(nodeType);\n}{return fallbackIsA(node,canonicalName,true);\n}}",
        "classSignatureBefore": "public class TypeTestUtilTest extends BaseNonParserTest ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.types.TypeTestUtilTest#assertIsA"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.types.TypeTestUtilTest"
        ],
        "classSignatureBeforeSet": [
            "public class TypeTestUtilTest extends BaseNonParserTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.types;\n\nimport java.io.Serializable;\nimport java.lang.annotation.Annotation;\nimport java.util.concurrent.Callable;\n\nimport org.junit.Assert;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.function.ThrowingRunnable;\nimport org.junit.rules.ExpectedException;\n\nimport net.sourceforge.pmd.lang.java.ast.ASTAllocationExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTAnnotationTypeDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTEnumDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTMarkerAnnotation;\nimport net.sourceforge.pmd.lang.java.ast.ASTName;\nimport net.sourceforge.pmd.lang.java.ast.TypeNode;\nimport net.sourceforge.pmd.lang.java.symboltable.BaseNonParserTest;\nimport net.sourceforge.pmd.lang.java.types.testdata.SomeClassWithAnon;\n\npublic class TypeTestUtilTest extends BaseNonParserTest {\n\n    @Rule\n    public final ExpectedException expect = ExpectedException.none();\n\n    @Test\n    public void testIsAFallback() {\n\n        ASTClassOrInterfaceDeclaration klass =\n            java.parse(\"package org; import java.io.Serializable; \"\n                           + \"class FooBar implements Serializable {}\")\n                .getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class);\n\n\n        Assert.assertNull(klass.getType());\n        Assert.assertTrue(TypeTestUtil.isA(\"org.FooBar\", klass));\n        Assert.assertTrue(TypeTestUtil.isA(\"java.io.Serializable\", klass));\n        Assert.assertTrue(TypeTestUtil.isA(Serializable.class, klass));\n    }\n\n\n    @Test\n    public void testIsAFallbackEnum() {\n\n        ASTEnumDeclaration klass =\n            java.parse(\"package org; \"\n                           + \"enum FooBar implements Iterable {}\")\n                .getFirstDescendantOfType(ASTEnumDeclaration.class);\n\n\n        Assert.assertNull(klass.getType());\n        Assert.assertTrue(TypeTestUtil.isA(\"org.FooBar\", klass));\n        assertIsA(klass, Iterable.class);\n        assertIsA(klass, Enum.class);\n        assertIsA(klass, Serializable.class);\n        assertIsA(klass, Object.class);\n    }\n\n    @Test\n    public void testIsAFallbackAnnotation() {\n\n        ASTAnnotationTypeDeclaration klass =\n            java.parse(\"package org; import foo.Stuff;\"\n                           + \"public @interface FooBar {}\")\n                .getFirstDescendantOfType(ASTAnnotationTypeDeclaration.class);\n\n\n        Assert.assertNull(klass.getType());\n        Assert.assertTrue(TypeTestUtil.isA(\"org.FooBar\", klass));\n        assertIsA(klass, Annotation.class);\n        assertIsA(klass, Object.class);\n    }\n\n    @Test\n    public void testAnonClassTypeNPE() {\n        // #2756\n\n        ASTAllocationExpression anon =\n            java.parseClass(SomeClassWithAnon.class)\n                .getFirstDescendantOfType(ASTAllocationExpression.class);\n\n\n        Assert.assertNotNull(\"Type should be resolved\", anon.getType());\n        Assert.assertTrue(\"Anon class\", anon.isAnonymousClass());\n        Assert.assertTrue(\"Anon class\", anon.getType().isAnonymousClass());\n        Assert.assertTrue(\"Should be a Runnable\", TypeTestUtil.isA(Runnable.class, anon));\n\n        // This is not a canonical name, so we give up early\n        Assert.assertFalse(TypeTestUtil.isA(SomeClassWithAnon.class.getName() + \"$1\", anon));\n        Assert.assertFalse(TypeTestUtil.isExactlyA(SomeClassWithAnon.class.getName() + \"$1\", anon));\n\n        // this is the failure case: if the binary name doesn't match, we test the canoname, which was null\n        Assert.assertFalse(TypeTestUtil.isA(Callable.class, anon));\n        Assert.assertFalse(TypeTestUtil.isA(Callable.class.getCanonicalName(), anon));\n        Assert.assertFalse(TypeTestUtil.isExactlyA(Callable.class, anon));\n        Assert.assertFalse(TypeTestUtil.isExactlyA(Callable.class.getCanonicalName(), anon));\n    }\n\n    /**\n     * If we don't have the annotation on the classpath,\n     * we should resolve the full name via the import, if possible\n     * and compare then. Only after that, we should compare the\n     * simple names.\n     */\n    @Test\n    public void testIsAFallbackAnnotationSimpleNameImport() {\n        ASTName annotation = java.parse(\"package org; import foo.Stuff; @Stuff public class FooBar {}\")\n                                 .getFirstDescendantOfType(ASTMarkerAnnotation.class).getFirstChildOfType(ASTName.class);\n\n        Assert.assertNull(annotation.getType());\n        Assert.assertTrue(TypeTestUtil.isA(\"foo.Stuff\", annotation));\n        Assert.assertFalse(TypeTestUtil.isA(\"other.Stuff\", annotation));\n        // if the searched class name is not fully qualified, then the search should still be successful\n        Assert.assertTrue(TypeTestUtil.isA(\"Stuff\", annotation));\n    }\n\n    @Test\n    public void testNullNode() {\n        Assert.assertFalse(TypeTestUtil.isA(String.class, null));\n        Assert.assertFalse(TypeTestUtil.isA(\"java.lang.String\", null));\n        Assert.assertFalse(TypeTestUtil.isExactlyA(String.class, null));\n        Assert.assertFalse(TypeTestUtil.isExactlyA(\"java.lang.String\", null));\n    }\n\n    @Test\n    public void testNullClass() {\n        final ASTName node = java.parse(\"package org; import foo.Stuff; @Stuff public class FooBar {}\")\n                                 .getFirstDescendantOfType(ASTMarkerAnnotation.class).getFirstChildOfType(ASTName.class);\n        Assert.assertNotNull(node);\n\n        Assert.assertThrows(NullPointerException.class, new ThrowingRunnable() {\n            @Override\n            public void run() {\n                TypeTestUtil.isA((String) null, node);\n            }\n        });\n        Assert.assertThrows(NullPointerException.class, new ThrowingRunnable() {\n            @Override\n            public void run() {\n                TypeTestUtil.isA((Class<?>) null, node);\n            }\n        });\n        Assert.assertThrows(NullPointerException.class, new ThrowingRunnable() {\n            @Override\n            public void run() {\n                TypeTestUtil.isExactlyA((Class<?>) null, node);\n            }\n        });\n        Assert.assertThrows(NullPointerException.class, new ThrowingRunnable() {\n            @Override\n            public void run() {\n                TypeTestUtil.isExactlyA((String) null, node);\n            }\n        });\n    }\n\n    private void assertIsA(TypeNode node, Class<?> type) {\n        Assert.assertTrue(\"TypeTestUtil::isA with class arg: \" + type.getCanonicalName(),\n                          TypeTestUtil.isA(type, node));\n        Assert.assertTrue(\"TypeTestUtil::isA with string arg: \" + type.getCanonicalName(),\n                          TypeTestUtil.isA(type.getCanonicalName(), node));\n    }\n\n}\n",
        "filePathAfter": "pmd-java/src/test/java/net/sourceforge/pmd/lang/java/types/TypeTestUtilTest.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.types;\n\nimport java.io.ObjectStreamField;\nimport java.io.Serializable;\nimport java.lang.annotation.Annotation;\nimport java.util.concurrent.Callable;\n\nimport org.junit.Assert;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.function.ThrowingRunnable;\nimport org.junit.rules.ExpectedException;\n\nimport net.sourceforge.pmd.lang.java.ast.ASTAllocationExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTAnnotationTypeDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTEnumDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTMarkerAnnotation;\nimport net.sourceforge.pmd.lang.java.ast.ASTName;\nimport net.sourceforge.pmd.lang.java.ast.ASTType;\nimport net.sourceforge.pmd.lang.java.ast.TypeNode;\nimport net.sourceforge.pmd.lang.java.symboltable.BaseNonParserTest;\nimport net.sourceforge.pmd.lang.java.types.testdata.SomeClassWithAnon;\n\npublic class TypeTestUtilTest extends BaseNonParserTest {\n\n    @Rule\n    public final ExpectedException expect = ExpectedException.none();\n\n    @Test\n    public void testIsAFallback() {\n\n        ASTClassOrInterfaceDeclaration klass =\n            java.parse(\"package org; import java.io.Serializable; \"\n                           + \"class FooBar implements Serializable {}\")\n                .getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class);\n\n\n        Assert.assertNull(klass.getType());\n        Assert.assertTrue(TypeTestUtil.isA(\"org.FooBar\", klass));\n        Assert.assertTrue(TypeTestUtil.isA(\"java.io.Serializable\", klass));\n        Assert.assertTrue(TypeTestUtil.isA(Serializable.class, klass));\n    }\n\n\n    @Test\n    public void testIsAFallbackEnum() {\n\n        ASTEnumDeclaration klass =\n            java.parse(\"package org; \"\n                           + \"enum FooBar implements Iterable {}\")\n                .getFirstDescendantOfType(ASTEnumDeclaration.class);\n\n\n        Assert.assertNull(klass.getType());\n        Assert.assertTrue(TypeTestUtil.isA(\"org.FooBar\", klass));\n        assertIsStrictSubtype(klass, Iterable.class);\n        assertIsStrictSubtype(klass, Enum.class);\n        assertIsStrictSubtype(klass, Serializable.class);\n        assertIsStrictSubtype(klass, Object.class);\n    }\n\n\n    @Test\n    public void testIsAnArrayClass() {\n\n        ASTType arrayT =\n            java.parse(\"import java.io.ObjectStreamField; \"\n                           + \"class Foo { private static final ObjectStreamField[] serialPersistentFields; }\")\n                .getFirstDescendantOfType(ASTType.class);\n\n\n        assertIsExactlyA(arrayT, ObjectStreamField[].class);\n        assertIsStrictSubtype(arrayT, Object[].class);\n        assertIsStrictSubtype(arrayT, Serializable.class);\n        assertIsNot(arrayT, Serializable[].class);\n        assertIsStrictSubtype(arrayT, Object.class);\n    }\n\n    @Test\n    public void testIsAnAnnotationClass() {\n\n        ASTType arrayT =\n            java.parse(\"class Foo { org.junit.Test field; }\")\n                .getFirstDescendantOfType(ASTType.class);\n\n\n        assertIsExactlyA(arrayT, Test.class);\n        assertIsStrictSubtype(arrayT, Annotation.class);\n        assertIsStrictSubtype(arrayT, Object.class);\n    }\n\n    @Test\n    public void testIsAPrimitiveArrayClass() {\n\n        ASTType arrayT =\n            java.parse(\"import java.io.ObjectStreamField; \"\n                           + \"class Foo { private static final int[] serialPersistentFields; }\")\n                .getFirstDescendantOfType(ASTType.class);\n\n\n        assertIsExactlyA(arrayT, int[].class);\n        assertIsNot(arrayT, long[].class);\n        assertIsNot(arrayT, Object[].class);\n\n        assertIsStrictSubtype(arrayT, Serializable.class);\n        assertIsStrictSubtype(arrayT, Object.class);\n    }\n\n\n    @Test\n    public void testIsAFallbackAnnotation() {\n\n        ASTAnnotationTypeDeclaration klass =\n            java.parse(\"package org; import foo.Stuff;\"\n                           + \"public @interface FooBar {}\")\n                .getFirstDescendantOfType(ASTAnnotationTypeDeclaration.class);\n\n\n        Assert.assertNull(klass.getType());\n        Assert.assertTrue(TypeTestUtil.isA(\"org.FooBar\", klass));\n        assertIsA(klass, Annotation.class);\n        assertIsA(klass, Object.class);\n    }\n\n    @Test\n    public void testAnonClassTypeNPE() {\n        // #2756\n\n        ASTAllocationExpression anon =\n            java.parseClass(SomeClassWithAnon.class)\n                .getFirstDescendantOfType(ASTAllocationExpression.class);\n\n\n        Assert.assertNotNull(\"Type should be resolved\", anon.getType());\n        Assert.assertTrue(\"Anon class\", anon.isAnonymousClass());\n        Assert.assertTrue(\"Anon class\", anon.getType().isAnonymousClass());\n        Assert.assertTrue(\"Should be a Runnable\", TypeTestUtil.isA(Runnable.class, anon));\n\n        // This is not a canonical name, so we give up early\n        Assert.assertFalse(TypeTestUtil.isA(SomeClassWithAnon.class.getName() + \"$1\", anon));\n        Assert.assertFalse(TypeTestUtil.isExactlyA(SomeClassWithAnon.class.getName() + \"$1\", anon));\n\n        // this is the failure case: if the binary name doesn't match, we test the canoname, which was null\n        Assert.assertFalse(TypeTestUtil.isA(Callable.class, anon));\n        Assert.assertFalse(TypeTestUtil.isA(Callable.class.getCanonicalName(), anon));\n        Assert.assertFalse(TypeTestUtil.isExactlyA(Callable.class, anon));\n        Assert.assertFalse(TypeTestUtil.isExactlyA(Callable.class.getCanonicalName(), anon));\n    }\n\n    /**\n     * If we don't have the annotation on the classpath,\n     * we should resolve the full name via the import, if possible\n     * and compare then. Only after that, we should compare the\n     * simple names.\n     */\n    @Test\n    public void testIsAFallbackAnnotationSimpleNameImport() {\n        ASTName annotation = java.parse(\"package org; import foo.Stuff; @Stuff public class FooBar {}\")\n                                 .getFirstDescendantOfType(ASTMarkerAnnotation.class).getFirstChildOfType(ASTName.class);\n\n        Assert.assertNull(annotation.getType());\n        Assert.assertTrue(TypeTestUtil.isA(\"foo.Stuff\", annotation));\n        Assert.assertFalse(TypeTestUtil.isA(\"other.Stuff\", annotation));\n        // if the searched class name is not fully qualified, then the search should still be successful\n        Assert.assertTrue(TypeTestUtil.isA(\"Stuff\", annotation));\n    }\n\n    @Test\n    public void testNullNode() {\n        Assert.assertFalse(TypeTestUtil.isA(String.class, null));\n        Assert.assertFalse(TypeTestUtil.isA(\"java.lang.String\", null));\n        Assert.assertFalse(TypeTestUtil.isExactlyA(String.class, null));\n        Assert.assertFalse(TypeTestUtil.isExactlyA(\"java.lang.String\", null));\n    }\n\n    @Test\n    public void testNullClass() {\n        final ASTName node = java.parse(\"package org; import foo.Stuff; @Stuff public class FooBar {}\")\n                                 .getFirstDescendantOfType(ASTMarkerAnnotation.class).getFirstChildOfType(ASTName.class);\n        Assert.assertNotNull(node);\n\n        Assert.assertThrows(NullPointerException.class, new ThrowingRunnable() {\n            @Override\n            public void run() {\n                TypeTestUtil.isA((String) null, node);\n            }\n        });\n        Assert.assertThrows(NullPointerException.class, new ThrowingRunnable() {\n            @Override\n            public void run() {\n                TypeTestUtil.isA((Class<?>) null, node);\n            }\n        });\n        Assert.assertThrows(NullPointerException.class, new ThrowingRunnable() {\n            @Override\n            public void run() {\n                TypeTestUtil.isExactlyA((Class<?>) null, node);\n            }\n        });\n        Assert.assertThrows(NullPointerException.class, new ThrowingRunnable() {\n            @Override\n            public void run() {\n                TypeTestUtil.isExactlyA((String) null, node);\n            }\n        });\n    }\n\n    private void assertIsA(TypeNode node, Class<?> type) {\n        assertIsA(node, type, false, true);\n    }\n\n    private void assertIsExactlyA(TypeNode node, Class<?> type) {\n        assertIsA(node, type, true, true);\n        assertIsA(node, type, false, true);\n    }\n\n    private void assertIsNot(TypeNode node, Class<?> type) {\n        assertIsA(node, type, true, false);\n        assertIsA(node, type, false, false);\n    }\n\n    private void assertIsNotExactly(TypeNode node, Class<?> type) {\n        assertIsA(node, type, true, false);\n    }\n\n    private void assertIsStrictSubtype(TypeNode node, Class<?> type) {\n        assertIsNotExactly(node, type);\n        assertIsA(node, type);\n    }\n\n    private void assertIsA(TypeNode node, Class<?> type, boolean exactly, boolean expectTrue) {\n        Assert.assertEquals(\"TypeTestUtil::isA with class arg: \" + type.getCanonicalName(),\n                            expectTrue,\n                            exactly ? TypeTestUtil.isExactlyA(type, node)\n                                    : TypeTestUtil.isA(type, node));\n        Assert.assertEquals(\"TypeTestUtil::isA with string arg: \" + type.getCanonicalName(),\n                            expectTrue,\n                            exactly ? TypeTestUtil.isExactlyA(type.getCanonicalName(), node)\n                                    : TypeTestUtil.isA(type.getCanonicalName(), node));\n    }\n\n\n}\n",
        "diffSourceCodeSet": [
            "private void assertIsA(TypeNode node, Class<?> type, boolean exactly, boolean expectTrue) {\n        Assert.assertEquals(\"TypeTestUtil::isA with class arg: \" + type.getCanonicalName(),\n                            expectTrue,\n                            exactly ? TypeTestUtil.isExactlyA(type, node)\n                                    : TypeTestUtil.isA(type, node));\n        Assert.assertEquals(\"TypeTestUtil::isA with string arg: \" + type.getCanonicalName(),\n                            expectTrue,\n                            exactly ? TypeTestUtil.isExactlyA(type.getCanonicalName(), node)\n                                    : TypeTestUtil.isA(type.getCanonicalName(), node));\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.java.types.TypeTestUtil#isA\n methodBody: public static boolean isA(/*@NonNull*/ String canonicalName, /*@Nullable*/ TypeNode node) {\nrequireParamNotNull(\"canonicalName\",canonicalName);\nif(node == null){return false;\n}Class<?> nodeType=node.getType();\nif(nodeType == null){return fallbackIsA(node,canonicalName,true);\n}if(nodeType.isAnnotation()){return isAnnotationSubtype(nodeType,canonicalName);\n}final Class<?> clazz=loadClassWithNodeClassloader(node,canonicalName);\nif(clazz != null){if(clazz.getCanonicalName() == null){return false;\n}return clazz.isAssignableFrom(nodeType);\n}{return fallbackIsA(node,canonicalName,true);\n}}"
        ],
        "sourceCodeAfterRefactoring": "private void assertIsA(TypeNode node, Class<?> type) {\n        assertIsA(node, type, false, true);\n    }\nprivate void assertIsA(TypeNode node, Class<?> type, boolean exactly, boolean expectTrue) {\n        Assert.assertEquals(\"TypeTestUtil::isA with class arg: \" + type.getCanonicalName(),\n                            expectTrue,\n                            exactly ? TypeTestUtil.isExactlyA(type, node)\n                                    : TypeTestUtil.isA(type, node));\n        Assert.assertEquals(\"TypeTestUtil::isA with string arg: \" + type.getCanonicalName(),\n                            expectTrue,\n                            exactly ? TypeTestUtil.isExactlyA(type.getCanonicalName(), node)\n                                    : TypeTestUtil.isA(type.getCanonicalName(), node));\n    }",
        "diffSourceCode": "-  163:     private void assertIsA(TypeNode node, Class<?> type) {\n-  164:         Assert.assertTrue(\"TypeTestUtil::isA with class arg: \" + type.getCanonicalName(),\n-  165:                           TypeTestUtil.isA(type, node));\n-  166:         Assert.assertTrue(\"TypeTestUtil::isA with string arg: \" + type.getCanonicalName(),\n-  167:                           TypeTestUtil.isA(type.getCanonicalName(), node));\n-  168:     }\n+  163:         ASTName annotation = java.parse(\"package org; import foo.Stuff; @Stuff public class FooBar {}\")\n+  164:                                  .getFirstDescendantOfType(ASTMarkerAnnotation.class).getFirstChildOfType(ASTName.class);\n+  165: \n+  166:         Assert.assertNull(annotation.getType());\n+  167:         Assert.assertTrue(TypeTestUtil.isA(\"foo.Stuff\", annotation));\n+  168:         Assert.assertFalse(TypeTestUtil.isA(\"other.Stuff\", annotation));\n+  213:     private void assertIsA(TypeNode node, Class<?> type) {\n+  214:         assertIsA(node, type, false, true);\n+  215:     }\n+  236:     private void assertIsA(TypeNode node, Class<?> type, boolean exactly, boolean expectTrue) {\n+  237:         Assert.assertEquals(\"TypeTestUtil::isA with class arg: \" + type.getCanonicalName(),\n+  238:                             expectTrue,\n+  239:                             exactly ? TypeTestUtil.isExactlyA(type, node)\n+  240:                                     : TypeTestUtil.isA(type, node));\n+  241:         Assert.assertEquals(\"TypeTestUtil::isA with string arg: \" + type.getCanonicalName(),\n+  242:                             expectTrue,\n+  243:                             exactly ? TypeTestUtil.isExactlyA(type.getCanonicalName(), node)\n+  244:                                     : TypeTestUtil.isA(type.getCanonicalName(), node));\n+  245:     }\n",
        "uniqueId": "20930119137620c622b742dda74f24c55f7ab70d_163_168_236_245_213_215",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Move And Inline Method",
        "description": "Move And Inline Method\tpublic newRegionByLine(beginLine int, beginColumn int, endLine int, endColumn int) : RegionByLine moved from class net.sourceforge.pmd.document.TextRegion to class net.sourceforge.pmd.document.DocumentImpl & inlined to public createRegion(beginLine int, beginColumn int, endLine int, endColumn int) : RegionByLine",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/document/DocumentImpl.java",
                "startLine": 103,
                "endLine": 107,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/document/DocumentImpl.java",
                "startLine": 114,
                "endLine": 118,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/document/DocumentImpl.java",
                "startLine": 28,
                "endLine": 30,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "positioner = new SourceCodePositioner(source);\n    }",
        "filePathBefore": "pmd-core/src/main/java/net/sourceforge/pmd/document/DocumentImpl.java",
        "isPureRefactoring": true,
        "commitId": "a733da4dcfa19b80f21480040aaf701e72e51bb5",
        "packageNameBefore": "net.sourceforge.pmd.document",
        "classNameBefore": "net.sourceforge.pmd.document.TextRegion",
        "methodNameBefore": "net.sourceforge.pmd.document.TextRegion#newRegionByLine",
        "classSignatureBefore": "public interface TextRegion ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.document.TextRegion#newRegionByLine"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.document.TextRegion"
        ],
        "classSignatureBeforeSet": [
            "public interface TextRegion "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.document;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\n\nimport net.sourceforge.pmd.document.TextRegion.RegionByLine;\nimport net.sourceforge.pmd.document.TextRegion.RegionByOffset;\nimport net.sourceforge.pmd.lang.ast.SourceCodePositioner;\n\n\nclass DocumentImpl implements MutableDocument {\n\n    private ReplaceFunction out;\n    /** The positioner has the original source file. */\n    private SourceCodePositioner positioner;\n    private SortedMap<Integer, Integer> accumulatedOffsets = new TreeMap<>();\n\n\n    public DocumentImpl(final String source, final ReplaceFunction writer) {\n        this.out = writer;\n        positioner = new SourceCodePositioner(source);\n    }\n\n    @Override\n    public void insert(int beginLine, int beginColumn, final String textToInsert) {\n        insert(positioner.offsetFromLineColumn(beginLine, beginColumn), textToInsert);\n    }\n\n    @Override\n    public void insert(int offset, String textToInsert) {\n        replace(createRegion(offset, 0), textToInsert);\n    }\n\n\n    @Override\n    public void delete(final TextRegion region) {\n        replace(region, \"\");\n    }\n\n    @Override\n    public void replace(final TextRegion region, final String textToReplace) {\n        RegionByOffset off = region.toOffset(this);\n\n        RegionByOffset realPos = shiftOffset(off, textToReplace.length() - off.getLength());\n\n        out.replace(realPos, textToReplace);\n    }\n\n    private RegionByOffset shiftOffset(RegionByOffset origCoords, int lenDiff) {\n        ArrayList<Integer> keys = new ArrayList<>(accumulatedOffsets.keySet());\n        int idx = Collections.binarySearch(keys, origCoords.getOffset());\n\n        if (idx < 0) {\n            idx = -(idx + 1);\n        } else {\n            idx++;\n        }\n\n        int shift = 0;\n        for (int i = 0; i < idx; i++) {\n            shift += accumulatedOffsets.get(keys.get(i));\n        }\n\n        RegionByOffset realPos = shift == 0\n                                 ? origCoords\n                                 // don't check it\n                                 : new RegionByOffsetImp(origCoords.getOffset() + shift, origCoords.getLength());\n\n        accumulatedOffsets.compute(origCoords.getOffset(), (k, v) -> {\n            int s = v == null ? lenDiff : v + lenDiff;\n            return s == 0 ? null : s; // delete mapping if shift is 0\n        });\n\n        return realPos;\n    }\n\n    @Override\n    public RegionByLine mapToLine(RegionByOffset region) {\n        int bline = positioner.lineNumberFromOffset(region.getOffset());\n        int bcol = positioner.columnFromOffset(bline, region.getOffset());\n        int eline = positioner.lineNumberFromOffset(region.getOffsetAfterEnding());\n        int ecol = positioner.columnFromOffset(eline, region.getOffsetAfterEnding());\n\n        return createRegion(bline, bcol, eline, ecol);\n    }\n\n    @Override\n    public RegionByOffset mapToOffset(RegionByLine region) {\n        int offset = positioner.offsetFromLineColumn(region.getBeginLine(), region.getBeginColumn());\n        int len = positioner.offsetFromLineColumn(region.getEndLine(), region.getEndColumn())\n            - offset;\n\n        return createRegion(offset, len);\n    }\n\n    @Override\n    public RegionByLine createRegion(int beginLine, int beginColumn, int endLine, int endColumn) {\n        // TODO checks, positioner should return -1\n        return TextRegion.newRegionByLine(beginLine, beginColumn, endLine, endColumn);\n    }\n\n    @Override\n    public RegionByOffset createRegion(int offset, int length) {\n        if (offset < 0 || offset + length > positioner.getSourceCode().length()) {\n            throw new IndexOutOfBoundsException(\n                \"Region (\" + offset + \",+\" + length + \") is not in range of this document\");\n        }\n\n\n        return new RegionByOffsetImp(offset, length);\n    }\n\n    @Override\n    public CharSequence getText() {\n        return positioner.getSourceCode();\n    }\n\n    @Override\n    public CharSequence subSequence(TextRegion region) {\n        RegionByOffset byOffset = region.toOffset(this);\n        return getText().subSequence(byOffset.getOffset(), byOffset.getOffsetAfterEnding());\n    }\n\n    @Override\n    public CharSequence getUncommittedText() {\n        return out.getCurrentText(this);\n    }\n\n    @Override\n    public void close() throws IOException {\n        out = out.commit();\n        positioner = new SourceCodePositioner(out.getCurrentText(this).toString());\n        accumulatedOffsets = new TreeMap<>();\n    }\n\n}\n",
        "filePathAfter": "pmd-core/src/main/java/net/sourceforge/pmd/document/DocumentImpl.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.document;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\n\nimport net.sourceforge.pmd.document.TextRegion.RegionByLine;\nimport net.sourceforge.pmd.document.TextRegion.RegionByOffset;\nimport net.sourceforge.pmd.lang.ast.SourceCodePositioner;\n\n\nclass DocumentImpl implements MutableDocument {\n\n    private ReplaceHandler out;\n    /** The positioner has the original source file. */\n    private SourceCodePositioner positioner;\n    private SortedMap<Integer, Integer> accumulatedOffsets = new TreeMap<>();\n\n\n    DocumentImpl(final String source, final ReplaceHandler writer) {\n        this.out = writer;\n        positioner = new SourceCodePositioner(source);\n    }\n\n    @Override\n    public MutableDocument newMutableDoc(ReplaceHandler out) {\n        return new DocumentImpl(getText().toString(), out);\n    }\n\n    @Override\n    public void insert(int beginLine, int beginColumn, final String textToInsert) {\n        insert(positioner.offsetFromLineColumn(beginLine, beginColumn), textToInsert);\n    }\n\n    @Override\n    public void insert(int offset, String textToInsert) {\n        replace(createRegion(offset, 0), textToInsert);\n    }\n\n\n    @Override\n    public void delete(final TextRegion region) {\n        replace(region, \"\");\n    }\n\n    @Override\n    public void replace(final TextRegion region, final String textToReplace) {\n        RegionByOffset off = region.toOffset(this);\n\n        RegionByOffset realPos = shiftOffset(off, textToReplace.length() - off.getLength());\n\n        out.replace(realPos, textToReplace);\n    }\n\n    private RegionByOffset shiftOffset(RegionByOffset origCoords, int lenDiff) {\n        ArrayList<Integer> keys = new ArrayList<>(accumulatedOffsets.keySet());\n        int idx = Collections.binarySearch(keys, origCoords.getStartOffset());\n\n        if (idx < 0) {\n            // there is no entry exactly for this offset, so that binarySearch\n            // returns the correct insertion index (but inverted)\n            idx = -(idx + 1);\n        } else {\n            // there is an exact entry\n            // since the loop below stops at idx, increment it to take that last entry into account\n            idx++;\n        }\n\n        // compute the shift accumulated by the mutations that have occurred\n        // left of the start index\n        int shift = 0;\n        for (int i = 0; i < idx; i++) {\n            shift += accumulatedOffsets.get(keys.get(i));\n        }\n\n        RegionByOffset realPos = shift == 0\n                                 ? origCoords\n                                 // don't check the bounds\n                                 : new RegionByOffsetImpl(origCoords.getStartOffset() + shift, origCoords.getLength());\n\n        accumulatedOffsets.compute(origCoords.getStartOffset(), (k, v) -> {\n            int s = v == null ? lenDiff : v + lenDiff;\n            return s == 0 ? null : s; // delete mapping if shift is 0\n        });\n\n        return realPos;\n    }\n\n    @Override\n    public RegionByLine mapToLine(RegionByOffset region) {\n        int bline = positioner.lineNumberFromOffset(region.getStartOffset());\n        int bcol = positioner.columnFromOffset(bline, region.getStartOffset());\n        int eline = positioner.lineNumberFromOffset(region.getOffsetAfterEnding());\n        int ecol = positioner.columnFromOffset(eline, region.getOffsetAfterEnding());\n\n        return createRegion(bline, bcol, eline, ecol);\n    }\n\n    @Override\n    public RegionByOffset mapToOffset(RegionByLine region) {\n        int offset = positioner.offsetFromLineColumn(region.getBeginLine(), region.getBeginColumn());\n        int len = positioner.offsetFromLineColumn(region.getEndLine(), region.getEndColumn())\n            - offset;\n\n        return createRegion(offset, len);\n    }\n\n    @Override\n    public RegionByLine createRegion(int beginLine, int beginColumn, int endLine, int endColumn) {\n        // TODO checks, positioner should return -1\n        return new RegionByLineImpl(beginLine, beginColumn, endLine, endColumn);\n    }\n\n    @Override\n    public RegionByOffset createRegion(int offset, int length) {\n        if (offset < 0 || offset + length > positioner.getSourceCode().length()) {\n            throw new IndexOutOfBoundsException(\n                \"Region (\" + offset + \",+\" + length + \") is not in range of this document\");\n        }\n\n\n        return new RegionByOffsetImpl(offset, length);\n    }\n\n    @Override\n    public CharSequence getText() {\n        return positioner.getSourceCode();\n    }\n\n    @Override\n    public CharSequence subSequence(TextRegion region) {\n        RegionByOffset byOffset = region.toOffset(this);\n        return getText().subSequence(byOffset.getStartOffset(), byOffset.getOffsetAfterEnding());\n    }\n\n\n    @Override\n    public CharSequence getUncommittedText() {\n        return out.getCurrentText(this);\n    }\n\n    @Override\n    public void close() throws IOException {\n        out = out.commit();\n        positioner = new SourceCodePositioner(out.getCurrentText(this).toString());\n        accumulatedOffsets = new TreeMap<>();\n    }\n\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "@Override\n    public RegionByLine createRegion(int beginLine, int beginColumn, int endLine, int endColumn) {\n        // TODO checks, positioner should return -1\n        return new RegionByLineImpl(beginLine, beginColumn, endLine, endColumn);\n    }",
        "diffSourceCode": "    28:         positioner = new SourceCodePositioner(source);\n    29:     }\n    30: \n-  103:     @Override\n-  104:     public RegionByLine createRegion(int beginLine, int beginColumn, int endLine, int endColumn) {\n-  105:         // TODO checks, positioner should return -1\n-  106:         return TextRegion.newRegionByLine(beginLine, beginColumn, endLine, endColumn);\n-  107:     }\n-  114:         }\n-  115: \n-  116: \n-  117:         return new RegionByOffsetImp(offset, length);\n+  103:     }\n+  104: \n+  105:     @Override\n+  106:     public RegionByOffset mapToOffset(RegionByLine region) {\n+  107:         int offset = positioner.offsetFromLineColumn(region.getBeginLine(), region.getBeginColumn());\n+  114:     @Override\n+  115:     public RegionByLine createRegion(int beginLine, int beginColumn, int endLine, int endColumn) {\n+  116:         // TODO checks, positioner should return -1\n+  117:         return new RegionByLineImpl(beginLine, beginColumn, endLine, endColumn);\n   118:     }\n",
        "uniqueId": "a733da4dcfa19b80f21480040aaf701e72e51bb5_103_107__114_118_28_30",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 8
            },
            "LINE": {
                "missed": 0,
                "covered": 1
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Move And Inline Method",
        "description": "Move And Inline Method\tpublic reportError(error ProcessingError) : void moved from class net.sourceforge.pmd.RuleContext to class net.sourceforge.pmd.processor.PmdRunnable & inlined to public run() : void",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/processor/PmdRunnable.java",
                "startLine": 63,
                "endLine": 98,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/processor/PmdRunnable.java",
                "startLine": 61,
                "endLine": 95,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/processor/PmdRunnable.java",
                "startLine": 45,
                "endLine": 47,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "PMDConfiguration configuration) {\n        this.dataSource = dataSource;\n        // this is the real, canonical and absolute filename (not shortened)",
        "filePathBefore": "pmd-core/src/main/java/net/sourceforge/pmd/processor/PmdRunnable.java",
        "isPureRefactoring": true,
        "commitId": "0276320abf2c66cae14d2ad24e2b2fb0386943b3",
        "packageNameBefore": "net.sourceforge.pmd",
        "classNameBefore": "net.sourceforge.pmd.RuleContext",
        "methodNameBefore": "net.sourceforge.pmd.RuleContext#reportError",
        "classSignatureBefore": "public final class RuleContext ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.RuleContext#reportError"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.RuleContext"
        ],
        "classSignatureBeforeSet": [
            "public final class RuleContext "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.processor;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Collections;\n\nimport net.sourceforge.pmd.PMDConfiguration;\nimport net.sourceforge.pmd.Report;\nimport net.sourceforge.pmd.RuleContext;\nimport net.sourceforge.pmd.RuleSets;\nimport net.sourceforge.pmd.RuleViolation;\nimport net.sourceforge.pmd.benchmark.TimeTracker;\nimport net.sourceforge.pmd.benchmark.TimedOperation;\nimport net.sourceforge.pmd.benchmark.TimedOperationCategory;\nimport net.sourceforge.pmd.internal.RulesetStageDependencyHelper;\nimport net.sourceforge.pmd.lang.LanguageVersion;\nimport net.sourceforge.pmd.lang.Parser;\nimport net.sourceforge.pmd.lang.Parser.ParserTask;\nimport net.sourceforge.pmd.lang.ast.FileAnalysisException;\nimport net.sourceforge.pmd.lang.ast.RootNode;\nimport net.sourceforge.pmd.lang.ast.SemanticErrorReporter;\nimport net.sourceforge.pmd.reporting.FileAnalysisListener;\nimport net.sourceforge.pmd.reporting.GlobalAnalysisListener;\nimport net.sourceforge.pmd.util.datasource.DataSource;\n\n/**\n * A processing task for a single file.\n */\nabstract class PmdRunnable implements Runnable {\n\n    private final DataSource dataSource;\n    private final File file;\n    private final GlobalAnalysisListener ruleContext;\n\n    private final PMDConfiguration configuration;\n\n    private final RulesetStageDependencyHelper dependencyHelper;\n\n    PmdRunnable(DataSource dataSource,\n                GlobalAnalysisListener ruleContext,\n                PMDConfiguration configuration) {\n        this.dataSource = dataSource;\n        // this is the real, canonical and absolute filename (not shortened)\n        String realFileName = dataSource.getNiceFileName(false, null);\n\n        this.file = new File(realFileName);\n        this.ruleContext = ruleContext;\n        this.configuration = configuration;\n        this.dependencyHelper = new RulesetStageDependencyHelper(configuration);\n    }\n\n    /**\n     * This is only called within the run method (when we are on the actual carrier thread).\n     * That way an implementation that uses a ThreadLocal will see the\n     * correct thread.\n     */\n    protected abstract RuleSets getRulesets();\n\n    @Override\n    public void run() throws FileAnalysisException {\n        TimeTracker.initThread();\n\n        RuleSets ruleSets = getRulesets();\n\n        try (FileAnalysisListener listener = ruleContext.startFileAnalysis(dataSource)) {\n            final RuleContext ruleCtx = RuleContext.create(listener);\n\n            LanguageVersion langVersion = configuration.getLanguageVersionOfFile(file.getPath());\n\n\n            // Coarse check to see if any RuleSet applies to file, will need to do a finer RuleSet specific check later\n            if (ruleSets.applies(file)) {\n                if (configuration.getAnalysisCache().isUpToDate(file)) {\n                    reportCachedRuleViolations(ruleCtx, file);\n                } else {\n                    try {\n                        processSource(ruleCtx, langVersion, ruleSets);\n                    } catch (Exception e) {\n                        configuration.getAnalysisCache().analysisFailed(file);\n\n                        // The listener handles logging if needed,\n                        // it may also rethrow the error, as a FileAnalysisException (which we let through below)\n                        ruleCtx.reportError(new Report.ProcessingError(e, file.getPath()));\n                    }\n                }\n            }\n        } catch (FileAnalysisException e) {\n            throw e; // bubble managed exceptions, they were already reported\n        } catch (Exception e) {\n            throw FileAnalysisException.wrap(file.getPath(), \"Exception while closing listener\", e);\n        }\n\n        TimeTracker.finishThread();\n    }\n\n    private void processSource(RuleContext ruleCtx, LanguageVersion languageVersion, RuleSets ruleSets) throws IOException, FileAnalysisException {\n        String fullSource = DataSource.readToString(dataSource, configuration.getSourceEncoding());\n        String filename = dataSource.getNiceFileName(false, null);\n\n        try {\n            ruleSets.start(ruleCtx);\n            processSource(fullSource, ruleSets, ruleCtx, languageVersion, filename);\n        } finally {\n            ruleSets.end(ruleCtx);\n        }\n\n    }\n\n\n    private void reportCachedRuleViolations(final RuleContext ctx, File file) {\n        for (final RuleViolation rv : configuration.getAnalysisCache().getCachedViolations(file)) {\n            ctx.addViolationNoSuppress(rv);\n        }\n    }\n\n    private RootNode parse(Parser parser, ParserTask task) {\n        try (TimedOperation to = TimeTracker.startOperation(TimedOperationCategory.PARSER)) {\n            return parser.parse(task);\n        }\n    }\n\n\n    private void processSource(String sourceCode,\n                               RuleSets ruleSets,\n                               RuleContext ctx,\n                               LanguageVersion languageVersion,\n                               String filename) throws FileAnalysisException {\n\n        ParserTask task = new ParserTask(\n            languageVersion,\n            filename,\n            sourceCode,\n            SemanticErrorReporter.noop(), // TODO\n            configuration.getSuppressMarker()\n        );\n\n        Parser parser = languageVersion.getLanguageVersionHandler().getParser();\n\n        RootNode rootNode = parse(parser, task);\n\n        dependencyHelper.runLanguageSpecificStages(ruleSets, languageVersion, rootNode);\n\n        ruleSets.apply(Collections.singletonList(rootNode), ctx);\n    }\n\n}\n",
        "filePathAfter": "pmd-core/src/main/java/net/sourceforge/pmd/processor/PmdRunnable.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.processor;\n\nimport java.io.File;\nimport java.io.IOException;\n\nimport net.sourceforge.pmd.PMDConfiguration;\nimport net.sourceforge.pmd.Report;\nimport net.sourceforge.pmd.RuleSets;\nimport net.sourceforge.pmd.RuleViolation;\nimport net.sourceforge.pmd.benchmark.TimeTracker;\nimport net.sourceforge.pmd.benchmark.TimedOperation;\nimport net.sourceforge.pmd.benchmark.TimedOperationCategory;\nimport net.sourceforge.pmd.internal.RulesetStageDependencyHelper;\nimport net.sourceforge.pmd.lang.LanguageVersion;\nimport net.sourceforge.pmd.lang.Parser;\nimport net.sourceforge.pmd.lang.Parser.ParserTask;\nimport net.sourceforge.pmd.lang.ast.FileAnalysisException;\nimport net.sourceforge.pmd.lang.ast.RootNode;\nimport net.sourceforge.pmd.lang.ast.SemanticErrorReporter;\nimport net.sourceforge.pmd.reporting.FileAnalysisListener;\nimport net.sourceforge.pmd.reporting.GlobalAnalysisListener;\nimport net.sourceforge.pmd.util.datasource.DataSource;\n\n/**\n * A processing task for a single file.\n */\nabstract class PmdRunnable implements Runnable {\n\n    private final DataSource dataSource;\n    private final File file;\n    private final GlobalAnalysisListener ruleContext;\n\n    private final PMDConfiguration configuration;\n\n    private final RulesetStageDependencyHelper dependencyHelper;\n\n    PmdRunnable(DataSource dataSource,\n                GlobalAnalysisListener ruleContext,\n                PMDConfiguration configuration) {\n        this.dataSource = dataSource;\n        // this is the real, canonical and absolute filename (not shortened)\n        String realFileName = dataSource.getNiceFileName(false, null);\n\n        this.file = new File(realFileName);\n        this.ruleContext = ruleContext;\n        this.configuration = configuration;\n        this.dependencyHelper = new RulesetStageDependencyHelper(configuration);\n    }\n\n    /**\n     * This is only called within the run method (when we are on the actual carrier thread).\n     * That way an implementation that uses a ThreadLocal will see the\n     * correct thread.\n     */\n    protected abstract RuleSets getRulesets();\n\n    @Override\n    public void run() throws FileAnalysisException {\n        TimeTracker.initThread();\n\n        RuleSets ruleSets = getRulesets();\n\n        try (FileAnalysisListener listener = ruleContext.startFileAnalysis(dataSource)) {\n\n            LanguageVersion langVersion = configuration.getLanguageVersionOfFile(file.getPath());\n\n\n            // Coarse check to see if any RuleSet applies to file, will need to do a finer RuleSet specific check later\n            if (ruleSets.applies(file)) {\n                if (configuration.getAnalysisCache().isUpToDate(file)) {\n                    reportCachedRuleViolations(listener, file);\n                } else {\n                    try {\n                        processSource(listener, langVersion, ruleSets);\n                    } catch (Exception e) {\n                        configuration.getAnalysisCache().analysisFailed(file);\n\n                        // The listener handles logging if needed,\n                        // it may also rethrow the error, as a FileAnalysisException (which we let through below)\n                        listener.onError(new Report.ProcessingError(e, file.getPath()));\n                    }\n                }\n            }\n        } catch (FileAnalysisException e) {\n            throw e; // bubble managed exceptions, they were already reported\n        } catch (Exception e) {\n            throw FileAnalysisException.wrap(file.getPath(), \"Exception while closing listener\", e);\n        }\n\n        TimeTracker.finishThread();\n    }\n\n    private void processSource(FileAnalysisListener listener, LanguageVersion languageVersion, RuleSets ruleSets) throws IOException, FileAnalysisException {\n        String fullSource = DataSource.readToString(dataSource, configuration.getSourceEncoding());\n        String filename = dataSource.getNiceFileName(false, null);\n\n        processSource(fullSource, ruleSets, listener, languageVersion, filename);\n    }\n\n\n    private void reportCachedRuleViolations(final FileAnalysisListener ctx, File file) {\n        for (final RuleViolation rv : configuration.getAnalysisCache().getCachedViolations(file)) {\n            ctx.onRuleViolation(rv);\n        }\n    }\n\n    private RootNode parse(Parser parser, ParserTask task) {\n        try (TimedOperation to = TimeTracker.startOperation(TimedOperationCategory.PARSER)) {\n            return parser.parse(task);\n        }\n    }\n\n\n    private void processSource(String sourceCode,\n                               RuleSets ruleSets,\n                               FileAnalysisListener listener,\n                               LanguageVersion languageVersion,\n                               String filename) throws FileAnalysisException {\n\n        ParserTask task = new ParserTask(\n            languageVersion,\n            filename,\n            sourceCode,\n            SemanticErrorReporter.noop(), // TODO\n            configuration.getSuppressMarker()\n        );\n\n        Parser parser = languageVersion.getLanguageVersionHandler().getParser();\n\n        RootNode rootNode = parse(parser, task);\n\n        dependencyHelper.runLanguageSpecificStages(ruleSets, languageVersion, rootNode);\n\n        ruleSets.apply(rootNode, listener);\n    }\n\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "@Override\n    public void run() throws FileAnalysisException {\n        TimeTracker.initThread();\n\n        RuleSets ruleSets = getRulesets();\n\n        try (FileAnalysisListener listener = ruleContext.startFileAnalysis(dataSource)) {\n\n            LanguageVersion langVersion = configuration.getLanguageVersionOfFile(file.getPath());\n\n\n            // Coarse check to see if any RuleSet applies to file, will need to do a finer RuleSet specific check later\n            if (ruleSets.applies(file)) {\n                if (configuration.getAnalysisCache().isUpToDate(file)) {\n                    reportCachedRuleViolations(listener, file);\n                } else {\n                    try {\n                        processSource(listener, langVersion, ruleSets);\n                    } catch (Exception e) {\n                        configuration.getAnalysisCache().analysisFailed(file);\n\n                        // The listener handles logging if needed,\n                        // it may also rethrow the error, as a FileAnalysisException (which we let through below)\n                        listener.onError(new Report.ProcessingError(e, file.getPath()));\n                    }\n                }\n            }\n        } catch (FileAnalysisException e) {\n            throw e; // bubble managed exceptions, they were already reported\n        } catch (Exception e) {\n            throw FileAnalysisException.wrap(file.getPath(), \"Exception while closing listener\", e);\n        }\n\n        TimeTracker.finishThread();\n    }",
        "diffSourceCode": "-   45:                 PMDConfiguration configuration) {\n-   46:         this.dataSource = dataSource;\n-   47:         // this is the real, canonical and absolute filename (not shortened)\n-   61:     protected abstract RuleSets getRulesets();\n-   62: \n-   63:     @Override\n-   64:     public void run() throws FileAnalysisException {\n-   65:         TimeTracker.initThread();\n+   45:         // this is the real, canonical and absolute filename (not shortened)\n+   46:         String realFileName = dataSource.getNiceFileName(false, null);\n+   47: \n+   61:     @Override\n+   62:     public void run() throws FileAnalysisException {\n+   63:         TimeTracker.initThread();\n+   64: \n+   65:         RuleSets ruleSets = getRulesets();\n    66: \n-   67:         RuleSets ruleSets = getRulesets();\n+   67:         try (FileAnalysisListener listener = ruleContext.startFileAnalysis(dataSource)) {\n    68: \n-   69:         try (FileAnalysisListener listener = ruleContext.startFileAnalysis(dataSource)) {\n-   70:             final RuleContext ruleCtx = RuleContext.create(listener);\n+   69:             LanguageVersion langVersion = configuration.getLanguageVersionOfFile(file.getPath());\n+   70: \n    71: \n-   72:             LanguageVersion langVersion = configuration.getLanguageVersionOfFile(file.getPath());\n-   73: \n-   74: \n-   75:             // Coarse check to see if any RuleSet applies to file, will need to do a finer RuleSet specific check later\n-   76:             if (ruleSets.applies(file)) {\n-   77:                 if (configuration.getAnalysisCache().isUpToDate(file)) {\n-   78:                     reportCachedRuleViolations(ruleCtx, file);\n-   79:                 } else {\n-   80:                     try {\n-   81:                         processSource(ruleCtx, langVersion, ruleSets);\n-   82:                     } catch (Exception e) {\n-   83:                         configuration.getAnalysisCache().analysisFailed(file);\n-   84: \n-   85:                         // The listener handles logging if needed,\n-   86:                         // it may also rethrow the error, as a FileAnalysisException (which we let through below)\n-   87:                         ruleCtx.reportError(new Report.ProcessingError(e, file.getPath()));\n-   88:                     }\n-   89:                 }\n-   90:             }\n-   91:         } catch (FileAnalysisException e) {\n-   92:             throw e; // bubble managed exceptions, they were already reported\n-   93:         } catch (Exception e) {\n-   94:             throw FileAnalysisException.wrap(file.getPath(), \"Exception while closing listener\", e);\n-   95:         }\n+   72:             // Coarse check to see if any RuleSet applies to file, will need to do a finer RuleSet specific check later\n+   73:             if (ruleSets.applies(file)) {\n+   74:                 if (configuration.getAnalysisCache().isUpToDate(file)) {\n+   75:                     reportCachedRuleViolations(listener, file);\n+   76:                 } else {\n+   77:                     try {\n+   78:                         processSource(listener, langVersion, ruleSets);\n+   79:                     } catch (Exception e) {\n+   80:                         configuration.getAnalysisCache().analysisFailed(file);\n+   81: \n+   82:                         // The listener handles logging if needed,\n+   83:                         // it may also rethrow the error, as a FileAnalysisException (which we let through below)\n+   84:                         listener.onError(new Report.ProcessingError(e, file.getPath()));\n+   85:                     }\n+   86:                 }\n+   87:             }\n+   88:         } catch (FileAnalysisException e) {\n+   89:             throw e; // bubble managed exceptions, they were already reported\n+   90:         } catch (Exception e) {\n+   91:             throw FileAnalysisException.wrap(file.getPath(), \"Exception while closing listener\", e);\n+   92:         }\n+   93: \n+   94:         TimeTracker.finishThread();\n+   95:     }\n    96: \n-   97:         TimeTracker.finishThread();\n-   98:     }\n+   97:     private void processSource(FileAnalysisListener listener, LanguageVersion languageVersion, RuleSets ruleSets) throws IOException, FileAnalysisException {\n+   98:         String fullSource = DataSource.readToString(dataSource, configuration.getSourceEncoding());\n",
        "uniqueId": "0276320abf2c66cae14d2ad24e2b2fb0386943b3_63_98__61_95_45_47",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 5
            },
            "LINE": {
                "missed": 0,
                "covered": 2
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Move Method",
        "description": "Move Method\tpublic collectMostSpecific(commonSubtype JTypeMirror) : Collector<JMethodSig,?,List<JMethodSig>> from class net.sourceforge.pmd.lang.java.types.internal.infer.OverloadComparator to public collectMostSpecific(commonSubtype JTypeMirror) : Collector<JMethodSig,?,List<JMethodSig>> from class net.sourceforge.pmd.lang.java.types.TypeOps",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/OverloadComparator.java",
                "startLine": 267,
                "endLine": 287,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeOps.java",
                "startLine": 1724,
                "endLine": 1744,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Returns a collector that can apply to a stream of method signatures,\n     * and that collects them into a set of method, where none override one another.\n     * Do not use this in a parallel stream. Do not use this to collect constructors.\n     * Do not use this if your stream contains methods that have different names.\n     *\n     * @param commonSubtype Site where the signatures are observed. The owner of every method\n     *                      in the stream must be a supertype of this type\n     *\n     * @return A collector\n     */\n    public static Collector<JMethodSig, ?, List<JMethodSig>> collectMostSpecific(JTypeMirror commonSubtype) {\n        return Collector.of(\n            OverloadSet::new,\n            (set, sig) -> set.add(sig, commonSubtype),\n            (left, right) -> {\n                throw new NotImplementedException(\"Cannot use this in a parallel stream\");\n            },\n            OverloadSet::getOverloads\n        );\n    }",
        "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/OverloadComparator.java",
        "isPureRefactoring": true,
        "commitId": "12d40eb6dcc965cc0523c4f2df71cf52a6a290e8",
        "packageNameBefore": "net.sourceforge.pmd.lang.java.types.internal.infer",
        "classNameBefore": "net.sourceforge.pmd.lang.java.types.internal.infer.OverloadComparator",
        "methodNameBefore": "net.sourceforge.pmd.lang.java.types.internal.infer.OverloadComparator#collectMostSpecific",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.java.types.internal.infer.OverloadSet#add\n methodBody: void add(JMethodSig sig, JTypeMirror commonSubtype) {\nif(name == null){name=sig.getName();\n}assert sig.getName().equals(name) : \"Not the right name!\";\nassert !sig.isConstructor() : \"Constructors they cannot override each other\";\nListIterator<JMethodSig> iterator=overloads.listIterator();\nwhile(iterator.hasNext()){JMethodSig existing=iterator.next();\nif(areOverrideEquivalent(existing,sig)){switch(shouldTakePrecedence(existing,sig,commonSubtype))case YES:return;\ncase NO:iterator.remove();\nbreak;\ncase UNKNOWN:break;\ndefault:throw new AssertionError();\n}}overloads.add(sig);\n}\nmethodSignature: net.sourceforge.pmd.lang.java.types.internal.infer.OverloadSet#getOverloads\n methodBody: public List<JMethodSig> getOverloads() {\nreturn Collections.unmodifiableList(overloads);\n}",
        "classSignatureBefore": "public final class OverloadComparator ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.types.internal.infer.OverloadComparator#collectMostSpecific"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.types.internal.infer.OverloadComparator"
        ],
        "classSignatureBeforeSet": [
            "public final class OverloadComparator "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.types.internal.infer;\n\nimport static net.sourceforge.pmd.lang.java.types.TypeOps.areOverrideEquivalent;\nimport static net.sourceforge.pmd.lang.java.types.TypeOps.overrides;\nimport static net.sourceforge.pmd.util.OptionalBool.NO;\nimport static net.sourceforge.pmd.util.OptionalBool.UNKNOWN;\nimport static net.sourceforge.pmd.util.OptionalBool.YES;\nimport static net.sourceforge.pmd.util.OptionalBool.definitely;\n\nimport java.lang.reflect.Modifier;\nimport java.util.List;\nimport java.util.stream.Collector;\n\nimport org.apache.commons.lang3.NotImplementedException;\nimport org.checkerframework.checker.nullness.qual.NonNull;\n\nimport net.sourceforge.pmd.lang.java.symbols.JClassSymbol;\nimport net.sourceforge.pmd.lang.java.types.JClassType;\nimport net.sourceforge.pmd.lang.java.types.JMethodSig;\nimport net.sourceforge.pmd.lang.java.types.JTypeMirror;\nimport net.sourceforge.pmd.lang.java.types.TypeOps;\nimport net.sourceforge.pmd.lang.java.types.internal.infer.ExprMirror.InvocationMirror.MethodCtDecl;\nimport net.sourceforge.pmd.util.OptionalBool;\n\npublic final class OverloadComparator {\n\n    private final Infer infer;\n    private final TypeInferenceLogger log;\n\n\n    OverloadComparator(Infer infer) {\n        this.infer = infer;\n        this.log = infer.getLogger();\n    }\n\n\n    /**\n     * Returns the most specific method of the two methods for the\n     * given invocation expression, given both are applicable to the\n     * site AND given that the currentBest may be shadowing/overriding/hiding\n     * the candidate if they are override-equivalent.\n     *\n     * <p>https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12.2.5\n     */\n    @NonNull MethodCtDecl selectMoreSpecific(MethodCtDecl currentBest, MethodCtDecl candidate, MethodCallSite site, MethodResolutionPhase phase) {\n        if (currentBest.isFailed()) {\n            return candidate;\n        } else if (candidate.isFailed()) {\n            return currentBest;\n        }\n\n        JMethodSig m1 = currentBest.getMethodType().internalApi().adaptedMethod();\n        JMethodSig m2 = candidate.getMethodType().internalApi().adaptedMethod();\n\n        return isMoreSpecific(m1, m2, site, phase)\n               ? currentBest\n               : candidate;\n    }\n\n    private boolean isMoreSpecific(@NonNull JMethodSig m1, @NonNull JMethodSig m2, MethodCallSite site, MethodResolutionPhase phase) {\n\n        boolean m1OverM2 = isMoreSpecificImpl(m1, m2, site, phase);\n        boolean m2OverM1 = isMoreSpecificImpl(m2, m1, site, phase);\n\n        if (m1OverM2 != m2OverM1) {\n            // then one of them is strictly more specific than the other\n            return m1OverM2;\n        } else if (areOverrideEquivalent(m1, m2)) {\n\n            OptionalBool result = shouldTakePrecedence(m1, m2, site.getExpr().getReceiverType());\n            if (result == UNKNOWN) {\n                log.ambiguityError(site, m1, m2);\n                // todo if a third method comes in that is more specific\n                //  than all ambiguous methods, then the ambiguity is lifted\n                return true;\n            } else {\n                return result == YES;\n            }\n        }\n\n        return false;\n    }\n\n    // test only\n\n    /**\n     * Given that m1 and m2 are override-equivalent, should m1 be chosen\n     * over m2 (YES/NO), or should an ambiguity error arise (UNKNOWN). This\n     * handles a few cases about shadowing/overriding/hiding that are not\n     * covered strictly by the definition of \"specificity\".\n     *\n     * <p>If m1 and m2 are equal, returns the first one by convention.\n     */\n    static OptionalBool shouldTakePrecedence(JMethodSig m1, JMethodSig m2, JTypeMirror commonSubtype) {\n        // select\n        // 1. the non-bridge\n        // 2. the one that overrides the other\n        // 3. the non-abstract method\n\n        // Symbols don't reflect bridge methods anymore\n        // if (m1.isBridge() != m2.isBridge()) {\n        //      return definitely(!m1.isBridge());\n        // } else\n        if (overrides(m1, m2, commonSubtype)) {\n            return YES;\n        } else if (overrides(m2, m1, commonSubtype)) {\n            return NO;\n        } else if (m1.isAbstract() ^ m2.isAbstract()) {\n            return definitely(!m1.isAbstract());\n        } else if (m1.isAbstract() && m2.isAbstract()) { // last ditch effort\n            // both are unrelated abstract, inherited into 'site'\n            // their signature would be merged into the site\n            // if exactly one is declared in a class, prefer it\n            // if both are declared in a class, ambiguity error (recall, neither overrides the other)\n            // if both are declared in an interface, select any of them\n            boolean m1InClass = m1.getSymbol().getEnclosingClass().isClass();\n            boolean m2Class = m2.getSymbol().getEnclosingClass().isClass();\n\n            return m1InClass && m2Class ? UNKNOWN : definitely(m1InClass);\n        }\n\n        if (Modifier.isPrivate(m1.getModifiers() | m2.getModifiers())\n            && commonSubtype instanceof JClassType) {\n            // One of them is private, which means, they can't be overridden,\n            // so they failed the above test\n            // Maybe it's shadowing then\n            return shadows(m1, m2, (JClassType) commonSubtype);\n        }\n\n        return UNKNOWN;\n    }\n\n\n    /**\n     * Returns whether m1 shadows m2 in the body of the given site, ie\n     * m1 is declared in a class C1 that encloses the site, and m2 is declared\n     * in a type that strictly encloses C1.\n     *\n     * <p>Assumes m1 and m2 are override-equivalent, and declared in different\n     * classes.\n     */\n    static OptionalBool shadows(JMethodSig m1, JMethodSig m2, JClassType site) {\n        final JClassSymbol c1 = m1.getSymbol().getEnclosingClass();\n        final JClassSymbol c2 = m2.getSymbol().getEnclosingClass();\n\n        // We go outward from the `site`. The height measure is the distance\n        // from the site (ie, the reverted depth of each class)\n\n        int height = 0;\n        int c1Height = -1;\n        int c2Height = -1;\n        JClassSymbol c = site.getSymbol();\n\n        while (c != null) {\n            if (c.equals(c1)) {\n                c1Height = height;\n            }\n            if (c.equals(c2)) {\n                c2Height = height;\n            }\n            c = c.getEnclosingClass();\n            height++;\n        }\n\n        if (c1Height < 0 || c2Height < 0 || c1Height == c2Height) {\n            return UNKNOWN;\n        }\n        return definitely(c1Height < c2Height);\n    }\n\n    private boolean isMoreSpecificImpl(JMethodSig m1, JMethodSig m2, MethodCallSite site, MethodResolutionPhase phase) {\n        return m2.isGeneric() ? isInferredMoreSpecific(m1, m2, site, phase)\n                              : isMoreSpecificNonGeneric(m1, m2, site, phase);\n    }\n\n\n    private boolean isInferredMoreSpecific(JMethodSig m1, JMethodSig m2, MethodCallSite site, MethodResolutionPhase phase) {\n        /* TODO\n             https://docs.oracle.com/javase/specs/jls/se8/html/jls-18.html#jls-18.5.4\n     \n             Test case:\n         */\n        try {\n            return doInfer(m1, m2, site, phase);\n        } catch (ResolutionFailedException e) {\n            return false;\n        }\n    }\n\n    private boolean doInfer(JMethodSig m1, JMethodSig m2, MethodCallSite site, MethodResolutionPhase phase) {\n        InferenceContext ctx = infer.newContextFor(m2);\n\n        // even if m1 is generic, the type parameters of m1 are treated as type variables, not inference variables.\n\n        JMethodSig m2p = ctx.mapToIVars(m2);\n\n        List<ExprMirror> es = site.getExpr().getArgumentExpressions();\n        List<JTypeMirror> m1Formals = m1.getFormalParameters();\n        List<JTypeMirror> m2Formals = m2p.getFormalParameters();\n\n        int k = es.size();\n\n        for (int i = 0; i < k; i++) {\n            JTypeMirror ti = phase.ithFormal(m2Formals, i);\n            JTypeMirror si = phase.ithFormal(m1Formals, i);\n            ExprMirror ei = es.get(i);\n\n            if (ctx.isGround(ti) && !isTypeMoreSpecificForArg(si, ti, ei)) {\n                return true;\n            }\n\n            // Otherwise, if Ti is not a functional interface type, the\n            // constraint formula \u2039Si <: Ti\u203a is generated.\n            JMethodSig fun = TypeOps.findFunctionalInterfaceMethod(ti);\n            if (fun == null) {\n                // not a functional interface\n                infer.checkConvertibleOrDefer(ctx, si, ti, ei, phase, null);\n            }\n\n            // todo special conditions for lambdas/ mrefs\n\n        }\n\n        if (phase.requiresVarargs() && m2Formals.size() == k + 1) {\n            // that is, the invocation has no arguments for the varargs, eg Stream.of()\n            infer.checkConvertibleOrDefer(ctx, phase.ithFormal(m1Formals, k), m2Formals.get(k), site.getExpr(), phase, null);\n        }\n\n        ctx.solve();         // throws ResolutionFailedException\n        ctx.callListeners(); // may throw ResolutionFailedException\n\n        return true;\n    }\n\n    private boolean isMoreSpecificNonGeneric(JMethodSig m1, JMethodSig m2, MethodCallSite site, MethodResolutionPhase phase) {\n        List<JTypeMirror> m1Formals = m1.getFormalParameters();\n        List<JTypeMirror> m2Formals = m2.getFormalParameters();\n        List<ExprMirror> args = site.getExpr().getArgumentExpressions();\n        int k = args.size();\n        for (int i = 0; i < k; i++) {\n            JTypeMirror si = phase.ithFormal(m1Formals, i);\n            JTypeMirror ti = phase.ithFormal(m2Formals, i);\n            if (!isTypeMoreSpecificForArg(si, ti, args.get(i))) {\n                return false;\n            }\n        }\n\n        if (phase.requiresVarargs() && m2Formals.size() == k + 1) {\n            // if the varargs argument has length 0, then the last\n            // formal of m1 must be more specific than the last formal of m2\n            return phase.ithFormal(m1Formals, k).isSubtypeOf(m2Formals.get(k));\n        }\n\n        return true;\n    }\n\n    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n    private boolean isTypeMoreSpecificForArg(JTypeMirror si, JTypeMirror ti, ExprMirror argExpr) {\n        // A type S is more specific than a type T for any expression if S <: T (\u00a74.10).\n        return si.isSubtypeOf(ti, true); // TODO checks for lambdas/method refs are much more complicated\n    }\n\n    /**\n     * Returns a collector that can apply to a stream of method signatures,\n     * and that collects them into a set of method, where none override one another.\n     * Do not use this in a parallel stream. Do not use this to collect constructors.\n     * Do not use this if your stream contains methods that have different names.\n     *\n     * @param commonSubtype Site where the signatures are observed. The owner of every method\n     *                      in the stream must be a supertype of this type\n     *\n     * @return A collector\n     */\n    public static Collector<JMethodSig, ?, List<JMethodSig>> collectMostSpecific(JTypeMirror commonSubtype) {\n        return Collector.of(\n            OverloadSet::new,\n            (set, sig) -> set.add(sig, commonSubtype),\n            (left, right) -> {\n                throw new NotImplementedException(\"Cannot use this in a parallel stream\");\n            },\n            OverloadSet::getOverloads\n        );\n    }\n}\n",
        "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeOps.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.types;\n\nimport static net.sourceforge.pmd.lang.java.types.Substitution.EMPTY;\nimport static net.sourceforge.pmd.lang.java.types.Substitution.mapping;\nimport static net.sourceforge.pmd.lang.java.types.TypeConversion.capture;\nimport static net.sourceforge.pmd.util.OptionalBool.NO;\nimport static net.sourceforge.pmd.util.OptionalBool.UNKNOWN;\nimport static net.sourceforge.pmd.util.OptionalBool.YES;\nimport static net.sourceforge.pmd.util.OptionalBool.definitely;\n\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.stream.Collector;\nimport java.util.stream.Collectors;\n\nimport org.apache.commons.lang3.NotImplementedException;\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport net.sourceforge.pmd.internal.util.IteratorUtil;\nimport net.sourceforge.pmd.lang.java.symbols.JClassSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JExecutableSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.table.coreimpl.CoreResolvers;\nimport net.sourceforge.pmd.lang.java.symbols.table.coreimpl.NameResolver;\nimport net.sourceforge.pmd.lang.java.symbols.table.internal.JavaResolvers;\nimport net.sourceforge.pmd.lang.java.types.JVariableSig.FieldSig;\nimport net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar;\nimport net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar.BoundKind;\nimport net.sourceforge.pmd.util.CollectionUtil;\nimport net.sourceforge.pmd.util.OptionalBool;\n\n/**\n * Common operations on types.\n */\n@SuppressWarnings(\"PMD.CompareObjectsWithEquals\")\npublic final class TypeOps {\n\n    private TypeOps() {\n        // utility class\n    }\n\n\n    // <editor-fold  defaultstate=\"collapsed\" desc=\"Type equality\">\n\n    public static boolean isSameType(JMethodSig t, JMethodSig s) {\n        return t.getDeclaringType().equals(s.getDeclaringType()) && haveSameSignature(t, s);\n    }\n\n    /*\n     * Note that type mirror implementations use this method as their\n     * Object#equals, which means it can't be used here unless it's on\n     * the smaller parts of a type.\n     */\n\n    public static boolean isSameType(JTypeMirror t, JTypeMirror s) {\n        return isSameType(t, s, false);\n    }\n\n    /**\n     * Returns true if t and s are the same type. If 'inInference' is\n     * true, then encountering inference variables produces side effects\n     * on them, adding bounds.\n     */\n    public static boolean isSameType(JTypeMirror t, JTypeMirror s, boolean inInference) {\n        if (t == s) {\n            // also returns true if both t and s are null\n            return true;\n        }\n\n        if (t == null || s == null) {\n            return false;\n        }\n\n        if (!inInference) {\n            return t.acceptVisitor(SameTypeVisitor.PURE, s);\n        }\n\n        // reorder\n        if (t instanceof JInferenceVar) {\n            return t.acceptVisitor(SameTypeVisitor.INFERENCE, s);\n        } else {\n            return s.acceptVisitor(SameTypeVisitor.INFERENCE, t);\n        }\n    }\n\n    public static boolean areSameTypes(List<JTypeMirror> ts, List<JTypeMirror> ss, boolean inInference) {\n        return areSameTypes(ts, ss, EMPTY, inInference);\n    }\n\n    public static boolean areSameTypes(List<JTypeMirror> ts, List<JTypeMirror> ss, Substitution subst) {\n        return areSameTypes(ts, ss, subst, false);\n    }\n\n    public static boolean areSameTypes(List<JTypeMirror> ts, List<JTypeMirror> ss, Substitution subst, boolean inInference) {\n        if (ts.size() != ss.size()) {\n            return false;\n        }\n        for (int i = 0; i < ts.size(); i++) {\n            if (!isSameType(ts.get(i), ss.get(i).subst(subst), inInference)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static boolean allArgsAreUnboundedWildcards(List<JTypeMirror> sargs) {\n        for (JTypeMirror sarg : sargs) {\n            if (!(sarg instanceof JWildcardType) || !((JWildcardType) sarg).isUnbounded()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static class SameTypeVisitor implements JTypeVisitor<Boolean, JTypeMirror> {\n\n        static final SameTypeVisitor INFERENCE = new SameTypeVisitor(true);\n        static final SameTypeVisitor PURE = new SameTypeVisitor(false);\n\n        private final boolean inInference;\n\n        private SameTypeVisitor(boolean inInference) {\n            this.inInference = inInference;\n        }\n\n        @Override\n        public Boolean visit(JTypeMirror t, JTypeMirror s) {\n            // for primitive & sentinel types\n            return t == s;\n        }\n\n        @Override\n        public Boolean visitClass(JClassType t, JTypeMirror s) {\n            if (s instanceof JClassType) {\n                JClassType s2 = (JClassType) s;\n                return t.getSymbol().getBinaryName().equals(s2.getSymbol().getBinaryName())\n                    && t.hasErasedSuperTypes() == s2.hasErasedSuperTypes()\n                    && isSameType(t.getEnclosingType(), s2.getEnclosingType(), inInference)\n                    && areSameTypes(t.getTypeArgs(), s2.getTypeArgs(), inInference);\n            }\n            return false;\n        }\n\n        @Override\n        public Boolean visitTypeVar(JTypeVar t, JTypeMirror s) {\n            return t.equals(s);\n        }\n\n        @Override\n        public Boolean visitWildcard(JWildcardType t, JTypeMirror s) {\n            if (!(s instanceof JWildcardType)) {\n                return false;\n            }\n            JWildcardType s2 = (JWildcardType) s;\n            return s2.isUpperBound() == t.isUpperBound() && isSameType(t.getBound(), s2.getBound(), inInference);\n        }\n\n        @Override\n        public Boolean visitInferenceVar(JInferenceVar t, JTypeMirror s) {\n            if (!inInference) {\n                return t == s;\n            }\n\n            if (s instanceof JPrimitiveType) {\n                return false;\n            }\n\n            if (s instanceof JWildcardType) {\n                JWildcardType s2 = (JWildcardType) s;\n                if (s2.isUpperBound()) {\n                    t.addBound(BoundKind.UPPER, s2.asUpperBound());\n                } else {\n                    t.addBound(BoundKind.LOWER, s2.asLowerBound());\n                }\n                return true;\n            }\n\n            // add an equality bound\n            t.addBound(BoundKind.EQ, s);\n            return true;\n        }\n\n        @Override\n        public Boolean visitIntersection(JIntersectionType t, JTypeMirror s) {\n            if (!(s instanceof JIntersectionType)) {\n                return false;\n            }\n\n            JIntersectionType s2 = (JIntersectionType) s;\n\n            // order is irrelevant\n\n            if (s2.getComponents().size() != t.getComponents().size()) {\n                return false;\n            }\n\n            if (!isSameType(t.getPrimaryBound(), s2.getPrimaryBound(), inInference)) {\n                return false;\n            }\n\n            Map<JTypeMirror, JTypeMirror> tMap = new HashMap<>();\n            for (JTypeMirror ti : t.getInterfaces()) {\n                tMap.put(ti.getErasure(), ti);\n            }\n            for (JTypeMirror si : s2.getInterfaces()) {\n                JTypeMirror siErased = si.getErasure();\n                if (!tMap.containsKey(siErased)) {\n                    return false;\n                }\n                JTypeMirror ti = tMap.remove(siErased);\n                if (!isSameType(ti, si, inInference)) {\n                    return false;\n                }\n            }\n            return tMap.isEmpty();\n        }\n\n        @Override\n        public Boolean visitArray(JArrayType t, JTypeMirror s) {\n            if (s instanceof JArrayType) {\n                return isSameType(t.getComponentType(), ((JArrayType) s).getComponentType(), inInference);\n            }\n            return false;\n        }\n    }\n\n    // </editor-fold>\n\n    // <editor-fold  defaultstate=\"collapsed\" desc=\"Supertype enumeration\">\n\n\n    /**\n     * Returns the set of all supertypes of the given type.\n     *\n     * @see JTypeMirror#getSuperTypeSet()\n     */\n    public static Set<JTypeMirror> getSuperTypeSet(@NonNull JTypeMirror t) {\n        Set<JTypeMirror> result = new LinkedHashSet<>();\n        t.acceptVisitor(SuperTypesVisitor.INSTANCE, result);\n        assert !result.isEmpty() : \"Empty supertype set for \" + t;\n        return result;\n    }\n\n    private static final class SuperTypesVisitor implements JTypeVisitor<Void, Set<JTypeMirror>> {\n\n        static final SuperTypesVisitor INSTANCE = new SuperTypesVisitor();\n\n        @Override\n        public Void visit(JTypeMirror t, Set<JTypeMirror> result) {\n            throw new IllegalStateException(\"Should not be called\");\n        }\n\n        @Override\n        public Void visitTypeVar(JTypeVar t, Set<JTypeMirror> result) {\n            if (result.add(t)) {\n                // prevent infinite loop\n                t.getUpperBound().acceptVisitor(this, result);\n            }\n            return null;\n        }\n\n        @Override\n        public Void visitNullType(JTypeMirror t, Set<JTypeMirror> result) {\n            // too many types\n            throw new IllegalArgumentException(\"The null type has all reference types as supertype\");\n        }\n\n        @Override\n        public Void visitSentinel(JTypeMirror t, Set<JTypeMirror> result) {\n            result.add(t);\n            return null;\n        }\n\n        @Override\n        public Void visitInferenceVar(JInferenceVar t, Set<JTypeMirror> result) {\n            result.add(t);\n            return null;\n        }\n\n        @Override\n        public Void visitWildcard(JWildcardType t, Set<JTypeMirror> result) {\n            t.asUpperBound().acceptVisitor(this, result);\n            // wildcards should be captured and so we should not end up here\n            return null;\n        }\n\n        @Override\n        public Void visitClass(JClassType t, Set<JTypeMirror> result) {\n            result.add(t);\n\n\n            // prefer digging up the superclass first\n            JClassType sup = t.getSuperClass();\n            if (sup != null) {\n                sup.acceptVisitor(this, result);\n            }\n            for (JClassType i : t.getSuperInterfaces()) {\n                visitClass(i, result);\n            }\n            if (t.isInterface() && t.getSuperInterfaces().isEmpty()) {\n                result.add(t.getTypeSystem().OBJECT);\n            }\n            return null;\n        }\n\n        @Override\n        public Void visitIntersection(JIntersectionType t, Set<JTypeMirror> result) {\n            for (JTypeMirror it : t.getComponents()) {\n                it.acceptVisitor(this, result);\n            }\n            return null;\n        }\n\n        @Override\n        public Void visitArray(JArrayType t, Set<JTypeMirror> result) {\n            result.add(t);\n\n            TypeSystem ts = t.getTypeSystem();\n\n            for (JTypeMirror componentSuper : t.getComponentType().getSuperTypeSet()) {\n                result.add(ts.arrayType(componentSuper));\n            }\n            result.add(ts.CLONEABLE);\n            result.add(ts.SERIALIZABLE);\n            result.add(ts.OBJECT);\n\n            return null;\n        }\n\n        @Override\n        public Void visitPrimitive(JPrimitiveType t, Set<JTypeMirror> result) {\n            result.addAll(t.getSuperTypeSet()); // special implementation in JPrimitiveType\n            return null;\n        }\n    }\n\n    // </editor-fold>\n\n    // <editor-fold  defaultstate=\"collapsed\" desc=\"Subtyping\">\n\n    /**\n     * Returns whether if {@code T <: S}, ie T is a subtype of S.\n     *\n     * <p>Note that {@link TypeSystem#ERROR_TYPE} and {@link TypeSystem#UNRESOLVED_TYPE}\n     * are considered subtypes of anything.\n     *\n     * @param t A type T\n     * @param s A type S\n     */\n    public static Subtyping isSubtype(@NonNull JTypeMirror t, @NonNull JTypeMirror s) {\n        if (t == s) {\n            Objects.requireNonNull(t);\n            return Subtyping.YES;\n        } else if (s == t.getTypeSystem().OBJECT) {\n            return Subtyping.definitely(!t.isPrimitive());\n        }\n\n        if (s instanceof JInferenceVar) {\n            // it's possible to add a bound to UNRESOLVED\n            ((JInferenceVar) s).addBound(BoundKind.LOWER, t);\n            return Subtyping.YES;\n        } else if (t == t.getTypeSystem().ERROR_TYPE) {\n            // don't check both, because subtyping must be asymmetric\n            return Subtyping.YES;\n        }\n\n        return capture(t).acceptVisitor(SubtypeVisitor.INSTANCE, s);\n    }\n\n    /**\n     * A result for a subtyping check. The subtyping routines here are\n     * more general than the strict definition of the JLS. For example,\n     * they handle unchecked conversion, and widening conversions between\n     * primitive types.\n     */\n    public enum Subtyping {\n        /** T is not a subtype of S. */\n        NO,\n\n        /**\n         * T is not a subtype of S, but every time T is used in a context\n         * where an S is expected, unchecked conversion converts the T to\n         * an S with a mandated warning. For example the raw type {@code Class}\n         * is convertible to {@code Class<String>} with an unchecked warning.\n         */\n        UNCHECKED_WARNING,\n\n        /**\n         * T is a subtype of S ({@code T <: S}), or one of the following:\n         * <ul>\n         * <li>T and S are primitive types, and T is convertible to S by widening conversion.\n         * For example, {@code int} can be widened to {@code long}.\n         * <li>T is a raw type, which is a subtype of |S|, but S is\n         * parameterized with only unbounded wildcards. This is a special\n         * case of unchecked conversion that produces no warning. For example,\n         * {@code Class<String>} is convertible to {@code Class<?>}.\n         * </ul>\n         *\n         * <p>Note that this ignores any other kind of conversion.\n         */\n        YES;\n\n        public boolean toBoolean(boolean allowUnchecked) {\n            return allowUnchecked ? this != NO\n                                  : this == YES;\n        }\n\n        public boolean evenUnchecked() {\n            return this != NO;\n        }\n\n        /** Preserves the unchecked warning. */\n        Subtyping and(Subtyping b) {\n            if (this == b) {\n                return this;\n            } else if (this == NO || b == NO) {\n                return NO;\n            }\n            return UNCHECKED_WARNING;\n        }\n\n        static Subtyping definitely(boolean b) {\n            return b ? YES : NO;\n        }\n\n        static Subtyping subtypesAll(JTypeMirror t, Iterable<? extends JTypeMirror> supers) {\n            Subtyping result = YES;\n            for (JTypeMirror ui : supers) {\n                Subtyping sub = isSubtype(t, ui);\n                if (sub == NO) {\n                    return NO;\n                }\n                result = result.and(sub);\n            }\n            return result;\n        }\n\n        static Subtyping anySubTypesAny(Iterable<? extends JTypeMirror> us, Iterable<? extends JTypeMirror> vs) {\n            for (JTypeMirror ui : us) {\n                for (JTypeMirror vi : vs) {\n                    Subtyping sub = isSubtype(ui, vi);\n                    if (sub != NO) {\n                        return sub;\n                    }\n                }\n            }\n            return NO;\n        }\n    }\n\n    private static JTypeMirror upperBound(JTypeMirror type) {\n        if (type instanceof JWildcardType) {\n            return upperBound(((JWildcardType) type).asUpperBound());\n        }\n        return type;\n    }\n\n    private static JTypeMirror lowerBound(JTypeMirror type) {\n        if (type instanceof JWildcardType) {\n            return lowerBound(((JWildcardType) type).asLowerBound());\n        }\n        return type;\n    }\n\n    private static JTypeMirror lowerBoundRec(JTypeMirror type) {\n        if (type instanceof JWildcardType) {\n            return lowerBoundRec(((JWildcardType) type).asLowerBound());\n        } else if (type instanceof JTypeVar && ((JTypeVar) type).isCaptured()) {\n            return lowerBoundRec(((JTypeVar) type).getLowerBound());\n        }\n        return type;\n    }\n\n    private static boolean isTypeRange(JTypeMirror s) {\n        return s instanceof JWildcardType\n            || s instanceof JTypeVar && ((JTypeVar) s).isCaptured();\n    }\n\n\n    /**\n     * Returns true if {@code S <= T}, ie \"T contains S\".\n     *\n     * <p>T contains S if:\n     *\n     * <p>{@code L(T) <: L(S) && U(S) <: U(T)}\n     *\n     * <p>This only makes sense for type arguments, it's a component of\n     * subtype checks for parameterized types:\n     *\n     * <p>{@code C<T> <: C<S> if T <= S}\n     *\n     * <p>Defined in JLS\u00a74.5.1 (Type Arguments of Parameterized Types)\n     */\n    public static Subtyping typeArgContains(JTypeMirror t, JTypeMirror s) {\n        // the contains relation can be understood intuitively if we\n        // represent types as ranges on a line:\n\n        // \u22a5 ---------L(T)---L(S)------U(S)-----U(T)---> Object\n        // range of T   [-------------------------]\n        // range of S          [---------]\n\n        // here T contains S because its range is greater\n\n        // since a wildcard is either \"super\" or \"extends\", in reality\n        // either L(T) = \u22a5, or U(T) = Object.\n\n        // meaning when T != S, we only have two scenarios where S <= T:\n\n        //      \u22a5 -------U(S)-----U(T)------> Object   (L(S) = L(T) = \u22a5)\n        //      \u22a5 -------L(T)-----L(S)------> Object   (U(S) = U(T) = Object)\n\n        if (isSameType(t, s, true)) {\n            // T <= T\n            return Subtyping.YES;\n        }\n\n        //        if (t instanceof JWildcardType && s instanceof JTypeVar) {\n        //            if (((JTypeVar) s).isCaptureOf((JWildcardType) t)) {\n        //                return true;\n        //            }\n        //        }\n\n        if (t instanceof JWildcardType) {\n            JWildcardType tw = (JWildcardType) t;\n            if (tw.isUpperBound()) {\n                //  U(S) <: U(T) if T is \"super\" bound (U(T) is top)\n                return isSubtype(upperBound(s), tw.asUpperBound());\n            } else {\n                // L(T) <: L(S) if T is \"extends\" bound (L(T) is bottom)\n                return isSubtype(tw.asLowerBound(), lowerBound(s));\n            }\n        }\n\n        return Subtyping.NO;\n    }\n\n\n    private static final class SubtypeVisitor implements JTypeVisitor<Subtyping, JTypeMirror> {\n\n        static final SubtypeVisitor INSTANCE = new SubtypeVisitor();\n\n        @Override\n        public Subtyping visit(JTypeMirror t, JTypeMirror s) {\n            throw new IllegalStateException(\"Should not be called\");\n        }\n\n        @Override\n        public Subtyping visitTypeVar(JTypeVar t, JTypeMirror s) {\n            if (isTypeRange(s)) {\n                return isSubtype(t, lowerBoundRec(s));\n            }\n            return isSubtype(t.getUpperBound(), s);\n        }\n\n        @Override\n        public Subtyping visitNullType(JTypeMirror t, JTypeMirror s) {\n            return Subtyping.definitely(!s.isPrimitive());\n        }\n\n        @Override\n        public Subtyping visitSentinel(JTypeMirror t, JTypeMirror s) {\n            return Subtyping.YES;\n        }\n\n        @Override\n        public Subtyping visitInferenceVar(JInferenceVar t, JTypeMirror s) {\n            if (s == t.getTypeSystem().NULL_TYPE || s instanceof JPrimitiveType) {\n                return Subtyping.NO;\n            }\n            // here we add a constraint on the variable\n            t.addBound(BoundKind.UPPER, s);\n            return Subtyping.YES;\n        }\n\n        @Override\n        public Subtyping visitWildcard(JWildcardType t, JTypeMirror s) {\n            // wildcards should be captured and so we should not end up here\n            return Subtyping.NO;\n        }\n\n        @Override\n        public Subtyping visitClass(JClassType t, JTypeMirror s) {\n            if (s == t.getTypeSystem().OBJECT) {\n                return Subtyping.YES;\n            }\n\n            if (s instanceof JIntersectionType) {\n                // If S is an intersection, then T must conform to *all* bounds of S\n                // Symmetrically, if T is an intersection, T <: S requires only that\n                // at least one bound of T is a subtype of S.\n                return Subtyping.subtypesAll(t, asList(s));\n            }\n\n            if (isTypeRange(s)) {\n                return isSubtype(t, lowerBoundRec(s));\n            }\n\n            if (!(s instanceof JClassType)) {\n                // note, that this ignores wildcard types,\n                // because they're only compared through\n                // type argument containment.\n                return Subtyping.NO;\n            }\n\n            JClassType cs = (JClassType) s;\n\n            // most specific\n            // if null then not a subtype\n            JClassType superDecl = t.getAsSuper(cs.getSymbol());\n\n            if (superDecl == null) {\n                return Subtyping.NO;\n            } else if (cs.isRaw()) {\n                // a raw type C is a supertype for all the family of parameterized type generated by C<F1, .., Fn>\n                return Subtyping.YES;\n            } else {\n                return typeArgsAreContained(superDecl.getTypeArgs(), cs.getTypeArgs());\n            }\n        }\n\n        /**\n         * Generalises equality to check if for each i, {@code Ti <= Si}.\n         */\n        private Subtyping typeArgsAreContained(List<JTypeMirror> targs, List<JTypeMirror> sargs) {\n            if (targs.isEmpty()) {\n                if (sargs.isEmpty()) {\n                    return Subtyping.YES;\n                }\n                // for some C, S = C<...> and T = C, ie T is raw\n                // T is convertible to S, by unchecked conversion.\n                // If S = D<?, .., ?>, then the conversion produces\n                // no unchecked warning.\n                return allArgsAreUnboundedWildcards(sargs) ? Subtyping.YES\n                                                           : Subtyping.UNCHECKED_WARNING;\n            }\n\n            Subtyping result = Subtyping.YES;\n            for (int i = 0; i < targs.size(); i++) {\n                Subtyping sub = typeArgContains(sargs.get(i), targs.get(i));\n                if (sub == Subtyping.NO) {\n                    return Subtyping.NO;\n                }\n                result = result.and(sub);\n            }\n\n            return result;\n        }\n\n        @Override\n        public Subtyping visitIntersection(JIntersectionType t, JTypeMirror s) {\n            // A & B <: A\n            // A & B <: B\n\n            // But for a class C, `C <: A & B` if `C <: A` and `C <: B`\n\n            // So we can't just say, \"any component of t must subtype s\",\n            // because if s is itself an intersection we have a problem:\n            // Eg let T = S = A & B\n            // T <: S -> A & B <: S\n            //        -> A <: S OR B <: S\n            //        -> A <: A & B OR B <: A & B\n            //        -> false\n\n            // what we mean is, if S is an intersection, then\n            // \"any component of T subtypes any component of S\"\n\n            return Subtyping.anySubTypesAny(t.getComponents(), asList(s));\n        }\n\n        @Override\n        public Subtyping visitArray(JArrayType t, JTypeMirror s) {\n            TypeSystem ts = t.getTypeSystem();\n            if (s == ts.OBJECT || s.equals(ts.CLONEABLE) || s.equals(ts.SERIALIZABLE)) {\n                return Subtyping.YES;\n            }\n\n            if (!(s instanceof JArrayType)) {\n                // not comparable to any other type\n                return Subtyping.NO;\n            }\n\n            JArrayType cs = (JArrayType) s;\n\n            if (t.getComponentType().isPrimitive() || cs.getComponentType().isPrimitive()) {\n                // arrays of primitive types have no sub-/ supertype\n                return Subtyping.definitely(cs.getComponentType() == t.getComponentType());\n            } else {\n                return isSubtype(t.getComponentType(), cs.getComponentType());\n            }\n        }\n\n        @Override\n        public Subtyping visitPrimitive(JPrimitiveType t, JTypeMirror s) {\n            return Subtyping.definitely(t.isSubtypeOf(s, false)); // JPrimitiveType already overrides this\n        }\n    }\n\n    // </editor-fold>\n\n    // <editor-fold  defaultstate=\"collapsed\" desc=\"Substitution\">\n\n    /**\n     * Replace the type variables occurring in the given type to their\n     * image by the given function. Substitutions are not applied\n     * recursively.\n     *\n     * @param type  Type to substitute\n     * @param subst Substitution function, eg a {@link Substitution}\n     */\n    public static JTypeMirror subst(@Nullable JTypeMirror type, Function<? super SubstVar, ? extends @NonNull JTypeMirror> subst) {\n        if (type == null || Substitution.isEmptySubst(subst)) {\n            return type;\n        }\n        return type.subst(subst);\n    }\n\n\n    /** Substitute on a list of types. */\n    public static List<JTypeMirror> subst(List<? extends JTypeMirror> ts, Function<? super SubstVar, ? extends @NonNull JTypeMirror> subst) {\n        return mapPreservingSelf(ts, t -> t.subst(subst));\n    }\n\n    public static List<JClassType> substClasses(List<JClassType> ts, Function<? super SubstVar, ? extends @NonNull JTypeMirror> subst) {\n        return mapPreservingSelf(ts, t -> t.subst(subst));\n    }\n\n    public static List<JTypeVar> substInBoundsOnly(List<JTypeVar> ts, Function<? super SubstVar, ? extends @NonNull JTypeMirror> subst) {\n        return mapPreservingSelf(ts, t -> t.substInBounds(subst));\n    }\n\n    // relies on the fact the original list is unmodifiable or won't be\n    // modified\n    @SuppressWarnings(\"unchecked\")\n    private static @NonNull <T> List<T> mapPreservingSelf(List<? extends T> ts, Function<? super T, ? extends @NonNull T> subst) {\n        // Profiling shows, only 10% of calls to this method need to\n        // create a new list. Substitution in general is a hot spot\n        // of the framework, so optimizing this out is nice\n        List<T> list = null;\n        for (int i = 0, size = ts.size(); i < size; i++) {\n            T it = ts.get(i);\n            T substed = subst.apply(it);\n            if (substed != it) {\n                if (list == null) {\n                    list = Arrays.asList((T[]) ts.toArray()); // NOPMD ClassCastExceptionWithToArray\n                }\n                list.set(i, substed);\n            }\n        }\n\n        // subst relies on the fact that the original list is returned\n        // to avoid new type creation. Thus one cannot use\n        // Collections::unmodifiableList here\n        return list != null ? list : (List<T>) ts;\n    }\n\n    // </editor-fold>\n\n    // <editor-fold  defaultstate=\"collapsed\" desc=\"Projection\">\n\n\n    /**\n     * Returns the upwards projection of the given type, with respect\n     * to the set of capture variables that are found in it. This is\n     * some supertype of T which does not mention those capture variables.\n     * This is used for local variable type inference.\n     *\n     * https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.10.5\n     */\n    public static JTypeMirror projectUpwards(JTypeMirror t) {\n        return t.acceptVisitor(UPWARDS_PROJECTOR, null);\n    }\n\n    private static final JTypeMirror NO_DOWN_PROJECTION = null;\n    private static final ProjectionVisitor UPWARDS_PROJECTOR = new ProjectionVisitor(true) {\n\n        @Override\n        public JTypeMirror visitTypeVar(JTypeVar t, Void v) {\n            if (t.isCaptured()) {\n                return t.getUpperBound().acceptVisitor(UPWARDS_PROJECTOR, null);\n            }\n            return t;\n        }\n\n\n        @Override\n        public JTypeMirror visitWildcard(JWildcardType t, Void v) {\n            JTypeMirror u = t.getBound().acceptVisitor(UPWARDS_PROJECTOR, null);\n            if (u == t.getBound()) {\n                return t;\n            }\n            TypeSystem ts = t.getTypeSystem();\n\n            if (t.isUpperBound()) {\n                return ts.wildcard(true, u);\n            } else {\n                JTypeMirror down = t.getBound().acceptVisitor(DOWNWARDS_PROJECTOR, null);\n                return down == NO_DOWN_PROJECTION ? ts.UNBOUNDED_WILD : ts.wildcard(false, down);\n            }\n        }\n\n\n        @Override\n        public JTypeMirror visitNullType(JTypeMirror t, Void v) {\n            return t;\n        }\n\n    };\n\n\n    private static final ProjectionVisitor DOWNWARDS_PROJECTOR = new ProjectionVisitor(false) {\n\n        @Override\n        public JTypeMirror visitWildcard(JWildcardType t, Void v) {\n            JTypeMirror u = t.getBound().acceptVisitor(UPWARDS_PROJECTOR, null);\n            if (u == t.getBound()) {\n                return t;\n            }\n            TypeSystem ts = t.getTypeSystem();\n\n            if (t.isUpperBound()) {\n                JTypeMirror down = t.getBound().acceptVisitor(DOWNWARDS_PROJECTOR, null);\n                return down == NO_DOWN_PROJECTION ? NO_DOWN_PROJECTION\n                                                  : ts.wildcard(true, down);\n            } else {\n                return ts.wildcard(false, u);\n            }\n        }\n\n\n        @Override\n        public JTypeMirror visitTypeVar(JTypeVar t, Void v) {\n            if (t.isCaptured()) {\n                return t.getLowerBound().acceptVisitor(DOWNWARDS_PROJECTOR, null);\n            }\n            return t;\n        }\n\n        @Override\n        public JTypeMirror visitNullType(JTypeMirror t, Void v) {\n            return NO_DOWN_PROJECTION;\n        }\n    };\n\n    /**\n     * Restricted type variables are:\n     * - Inference vars\n     * - Capture vars\n     *\n     * See\n     *\n     * https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.10.5\n     *\n     *\n     * <p>Here we use {@link #NO_DOWN_PROJECTION} as a sentinel\n     * (downwards projection is a partial function). If a type does not mention\n     * restricted type variables, then the visitor should return the original\n     * type (same reference). This allows testing predicates like\n     * <blockquote>\n     * \"If Ai does not mention any restricted type variable, then Ai' = Ai.\"\n     * </blockquote>\n     */\n    private abstract static class ProjectionVisitor implements JTypeVisitor<JTypeMirror, Void> {\n\n        private final boolean upwards;\n\n        private ProjectionVisitor(boolean upwards) {\n            this.upwards = upwards;\n        }\n\n\n        @Override\n        public abstract JTypeMirror visitNullType(JTypeMirror t, Void v);\n\n\n        @Override\n        public abstract JTypeMirror visitWildcard(JWildcardType t, Void v);\n\n\n        @Override\n        public abstract JTypeMirror visitTypeVar(JTypeVar t, Void v);\n\n\n        @Override\n        public JTypeMirror visit(JTypeMirror t, Void v) {\n            return t;\n        }\n\n        @Override\n        public JTypeMirror visitClass(JClassType t, Void v) {\n            if (t.isParameterizedType()) {\n                List<JTypeMirror> targs = t.getTypeArgs();\n                List<JTypeMirror> newTargs = new ArrayList<>(targs.size());\n                List<JTypeVar> formals = t.getFormalTypeParams();\n                boolean change = false;\n\n                for (int i = 0; i < targs.size(); i++) {\n                    JTypeMirror ai = targs.get(i);\n                    JTypeMirror u = ai.acceptVisitor(this, null);\n                    if (u == ai || ai instanceof JWildcardType) {\n                        // no change, or handled by the visitWildcard\n                        newTargs.add(u);\n                        continue;\n                    } else if (!upwards) {\n                        // If Ai is a type that mentions a restricted type variable, then Ai' is undefined.\n                        return NO_DOWN_PROJECTION;\n                    }\n\n                    change = true;\n\n                    /*\n                        If Ai is a type that mentions a restricted type variable...\n                     */\n                    JTypeMirror bi = formals.get(i).getUpperBound();\n\n                    TypeSystem ts = t.getTypeSystem();\n                    if (u != ts.OBJECT\n                        && (mentionsAny(bi, formals) || !bi.isSubtypeOf(u))) {\n                        newTargs.add(ts.wildcard(true, u));\n                    } else {\n                        JTypeMirror down = ai.acceptVisitor(DOWNWARDS_PROJECTOR, null);\n                        if (down == NO_DOWN_PROJECTION) {\n                            newTargs.add(ts.UNBOUNDED_WILD);\n                        } else {\n                            newTargs.add(ts.wildcard(false, down));\n                        }\n                    }\n                }\n\n                return change ? t.withTypeArguments(newTargs) : t;\n            } else {\n                return t;\n            }\n        }\n\n        @Override\n        public JTypeMirror visitIntersection(JIntersectionType t, Void v) {\n            List<JTypeMirror> comps = new ArrayList<>(t.getComponents());\n            boolean change = false;\n            for (int i = 0; i < comps.size(); i++) {\n                JTypeMirror ci = comps.get(i);\n                JTypeMirror proj = ci.acceptVisitor(this, null);\n                if (proj == NO_DOWN_PROJECTION) {\n                    return proj;\n                } else {\n                    comps.set(i, proj);\n                    if (ci != proj) {\n                        change = true;\n                    }\n                }\n            }\n            return change ? t.getTypeSystem().glb(comps) : t;\n        }\n\n        @Override\n        public JTypeMirror visitArray(JArrayType t, Void v) {\n            JTypeMirror comp2 = t.getComponentType().acceptVisitor(this, null);\n            return comp2 == NO_DOWN_PROJECTION\n                   ? NO_DOWN_PROJECTION\n                   : comp2 == t.getComponentType()\n                     ? t : t.getTypeSystem().arrayType(comp2);\n        }\n\n        @Override\n        public JTypeMirror visitSentinel(JTypeMirror t, Void v) {\n            return t;\n        }\n    }\n\n    // </editor-fold>\n\n    // <editor-fold  defaultstate=\"collapsed\" desc=\"Overriding\">\n\n    /**\n     * Returns true if m1 is return-type substitutable with m2. . The notion of return-type-substitutability\n     * supports covariant returns, that is, the specialization of the return type to a subtype.\n     *\n     * https://docs.oracle.com/javase/specs/jls/se9/html/jls-8.html#jls-8.4.5\n     */\n    public static boolean isReturnTypeSubstitutable(JMethodSig m1, JMethodSig m2) {\n\n        JTypeMirror r1 = m1.getReturnType();\n        JTypeMirror r2 = m2.getReturnType();\n\n        if (r1 == r1.getTypeSystem().NO_TYPE) {\n            return r1 == r2;\n        }\n\n        if (r1.isPrimitive()) {\n            return r1 == r2;\n        }\n\n        JMethodSig m1Prime = adaptForTypeParameters(m1, m2);\n        if (m1Prime != null && isSubtype(m1Prime.getReturnType(), r2) != Subtyping.NO) {\n            return true;\n        }\n\n        if (!haveSameSignature(m1, m2)) {\n            return isSameType(r1, r2.getErasure());\n        }\n\n        return false;\n    }\n\n    /**\n     * Adapt m1 to the type parameters of m2. Returns null if that's not possible.\n     *\n     * https://docs.oracle.com/javase/specs/jls/se9/html/jls-8.html#jls-8.4.4\n     */\n    private static @Nullable JMethodSig adaptForTypeParameters(JMethodSig m1, JMethodSig m2) {\n        if (haveSameTypeParams(m1, m2)) {\n            return m1.subst(mapping(m1.getTypeParameters(), m2.getTypeParameters()));\n        }\n\n        return null;\n    }\n\n    private static boolean haveSameTypeParams(JMethodSig m1, JMethodSig m2) {\n        List<JTypeVar> tp1 = m1.getTypeParameters();\n        List<JTypeVar> tp2 = m2.getTypeParameters();\n        if (tp1.size() != tp2.size()) {\n            return false;\n        }\n\n        if (tp1.isEmpty()) {\n            return true;\n        }\n\n        for (int i = 0; i < tp1.size(); i++) {\n            JTypeVar p1 = tp1.get(i);\n            JTypeVar p2 = tp2.get(i);\n\n            if (!isSameType(p1, subst(p2, mapping(tp2, tp1)))) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Two method signatures m1 and m2 are override-equivalent iff either\n     * m1 is a subsignature of m2 or m2 is a subsignature of m1. This does\n     * not look at the origin of the methods (their declaring class).\n     *\n     * https://docs.oracle.com/javase/specs/jls/se9/html/jls-8.html#jls-8.4.2\n     */\n    public static boolean areOverrideEquivalent(JMethodSig m1, JMethodSig m2) {\n        // This method is a very hot spot as it is used to prune shadowed/overridden/hidden\n        // methods from overload candidates before overload resolution.\n        // Any optimization makes a big impact.\n        if (m1.getArity() != m2.getArity()) {\n            return false; // easy case\n        } else if (m1 == m2) {\n            return true;\n        }\n        // Two methods can only have the same signature if they have the same type parameters\n        // But a generic method is allowed to override a non-generic one, and vice versa\n        // So we first project both methods into a form that has the same number of type parameters\n        boolean m1Gen = m1.isGeneric();\n        boolean m2Gen = m2.isGeneric();\n        if (m1Gen ^ m2Gen) {\n            if (m1Gen) {\n                m1 = m1.getErasure();\n            } else {\n                m2 = m2.getErasure();\n            }\n        }\n        return haveSameSignature(m1, m2);\n    }\n\n    /**\n     * The signature of a method m1 is a subsignature of the signature of a method m2 if either:\n     * - m2 has the same signature as m1, or\n     * - the signature of m1 is the same as the erasure (\u00a74.6) of the signature of m2.\n     */\n    private static boolean isSubSignature(JMethodSig m1, JMethodSig m2) {\n        // prune easy cases\n        if (m1.getArity() != m2.getArity() || !m1.getName().equals(m2.getName())) {\n            return false;\n        }\n        boolean m1Gen = m1.isGeneric();\n        boolean m2Gen = m2.isGeneric();\n        if (m1Gen ^ m2Gen) {\n            if (m1Gen) {\n                return false; // this test is assymetric\n            } else {\n                m2 = m2.getErasure();\n            }\n        }\n        return haveSameSignature(m1, m2);\n    }\n\n    /**\n     * Two methods or constructors, M and N, have the same signature if\n     * they have the same name, the same type parameters (if any) (\u00a78.4.4),\n     * and, after adapting the formal parameter types of N to the the type\n     * parameters of M, the same formal parameter types.\n     *\n     * Thrown exceptions are not part of the signature of a method.\n     */\n    private static boolean haveSameSignature(JMethodSig m1, JMethodSig m2) {\n        if (!m1.getName().equals(m2.getName()) || m1.getArity() != m2.getArity()) {\n            return false;\n        }\n\n        if (!haveSameTypeParams(m1, m2)) {\n            return false;\n        }\n\n        return areSameTypes(m1.getFormalParameters(),\n                            m2.getFormalParameters(),\n                            Substitution.mapping(m2.getTypeParameters(), m1.getTypeParameters()));\n    }\n\n    /**\n     * Returns true if m1 overrides m2, when both are view as members of\n     * class origin. m1 and m2 may be declared in supertypes of origin,\n     * possibly unrelated (default methods), which is why we need that\n     * third parameter. By convention a method overrides itself.\n     *\n     * <p>This method ignores the static modifier. If both methods are\n     * static, then this method tests for <i>hiding</i>. Otherwise, this\n     * method properly tests for overriding. Note that it is an error for\n     * a static method to override an instance method, or the reverse.\n     */\n    public static boolean overrides(JMethodSig m1, JMethodSig m2, JTypeMirror origin) {\n\n        if (m1.isConstructor() || m2.isConstructor()) {\n            return m1.equals(m2); // \"by convention a method overrides itself\"\n        }\n\n        JTypeMirror m1Owner = m1.getDeclaringType();\n        JClassType m2Owner = (JClassType) m2.getDeclaringType();\n\n        if (isOverridableIn(m2, m2Owner.getSymbol(), (JClassSymbol) m1Owner.getSymbol())) {\n            JClassType m2AsM1Supertype = (JClassType) m1Owner.getAsSuper(m2Owner.getSymbol());\n            if (m2AsM1Supertype != null) {\n                JMethodSig m2Prime = m2AsM1Supertype.getDeclaredMethod(m2.getSymbol());\n                assert m2Prime != null;\n                if (isSubSignature(m1, m2Prime)) {\n                    return true;\n                }\n            }\n        }\n\n        // todo that is very weird\n        if (m1.isAbstract()\n            || !m2.isAbstract() && !m2.getSymbol().isDefaultMethod()\n            || !isOverridableIn(m2, m2Owner.getSymbol(), (JClassSymbol) origin.getSymbol())\n            || !(m1Owner instanceof JClassType)) {\n            return false;\n        }\n\n        JTypeMirror m1AsSuper = origin.getAsSuper(((JClassType) m1Owner).getSymbol());\n        JTypeMirror m2AsSuper = origin.getAsSuper(m2Owner.getSymbol());\n        if (m1AsSuper instanceof JClassType && m2AsSuper instanceof JClassType) {\n            m1 = ((JClassType) m1AsSuper).getDeclaredMethod(m1.getSymbol());\n            m2 = ((JClassType) m2AsSuper).getDeclaredMethod(m2.getSymbol());\n            assert m1 != null && m2 != null;\n            return isSubSignature(m1, m2);\n        }\n        return false;\n    }\n\n    /**\n     * Returns true if the given method can be overridden in the origin\n     * class. This only checks access modifiers and not eg whether the\n     * method is final or static. Regardless of whether the method is\n     * final it is overridden - whether this is a compile error or not\n     * is another matter.\n     *\n     * <p>Like {@link #overrides(JMethodSig, JMethodSig, JTypeMirror)},\n     * this does not check the static modifier, and tests for hiding\n     * if the method is static.\n     *\n     * @param m         Method to test\n     * @param declaring Symbol of the declaring type of m\n     * @param origin    Site of the potential override\n     */\n    private static boolean isOverridableIn(JMethodSig m, JClassSymbol declaring, JClassSymbol origin) {\n        final int accessFlags = Modifier.PUBLIC | Modifier.PROTECTED | Modifier.PRIVATE;\n\n        // JLS 8.4.6.1\n        switch (m.getModifiers() & accessFlags) {\n        case Modifier.PUBLIC:\n            return true;\n        case Modifier.PROTECTED:\n            return !origin.isInterface();\n        case 0:\n            // package private\n            return\n                declaring.getPackageName().equals(origin.getPackageName())\n                    && !origin.isInterface();\n        default:\n            // private\n            return false;\n        }\n    }\n\n    // </editor-fold>\n\n    // <editor-fold  defaultstate=\"collapsed\" desc=\"SAM types\">\n\n    /*\n     * Function types of SAM (single-abstract-method) types.\n     *\n     * See https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-9.9\n     */\n\n\n    /**\n     * Returns the non-wildcard parameterization of the given functional\n     * interface type. Returns null if such a parameterization does not\n     * exist.\n     *\n     * <p>This is used to remove wildcards from the type of a functional\n     * interface.\n     *\n     * https://docs.oracle.com/javase/specs/jls/se9/html/jls-9.html#jls-9.9\n     *\n     * @param type A parameterized functional interface type\n     */\n    public static @Nullable JClassType nonWildcardParameterization(@NonNull JClassType type) {\n        TypeSystem ts = type.getTypeSystem();\n\n        List<JTypeMirror> targs = type.getTypeArgs();\n        if (targs.stream().noneMatch(it -> it instanceof JWildcardType)) {\n            return type;\n        }\n\n        List<JTypeVar> tparams = type.getFormalTypeParams();\n        List<JTypeMirror> newArgs = new ArrayList<>();\n\n        for (int i = 0; i < tparams.size(); i++) {\n            JTypeMirror ai = targs.get(i);\n            if (ai instanceof JWildcardType) {\n                JTypeVar pi = tparams.get(i);\n                JTypeMirror bi = pi.getUpperBound();\n                if (mentionsAny(bi, new HashSet<JTypeVar>(tparams))) {\n                    return null;\n                }\n\n                JWildcardType ai2 = (JWildcardType) ai;\n\n                if (ai2.isUnbounded()) {\n                    newArgs.add(bi);\n                } else if (ai2.isUpperBound()) {\n                    newArgs.add(ts.glb(Arrays.asList(ai2.asUpperBound(), bi)));\n                } else { // lower bound\n                    newArgs.add(ai2.asLowerBound());\n                }\n\n            } else {\n                newArgs.add(ai);\n            }\n\n        }\n\n        return type.withTypeArguments(newArgs);\n    }\n\n    /**\n     * Finds the method of the given type that can be overridden as a lambda\n     * expression. That is more complicated than \"the unique abstract method\",\n     * it's actually a function type which can override all abstract methods\n     * of the SAM at once.\n     *\n     * https://docs.oracle.com/javase/specs/jls/se9/html/jls-9.html#jls-9.9\n     *\n     * <p>If the parameter is not mappable to a class type with {@link #asClassType(JTypeMirror)},\n     * or if the functional method does not exist, returns null.\n     */\n    public static @Nullable JMethodSig findFunctionalInterfaceMethod(@Nullable JTypeMirror type) {\n        JClassType candidateSam = asClassType(type);\n        if (candidateSam == null) {\n            return null;\n        }\n\n        if (candidateSam.isParameterizedType()) {\n            return findFunctionTypeImpl(nonWildcardParameterization(candidateSam));\n        } else if (candidateSam.isRaw()) {\n            //  The function type of the raw type of a generic functional\n            //  interface I<...> is the erasure of the function type of the generic functional interface I<...>.\n            JMethodSig fun = findFunctionTypeImpl(candidateSam.getGenericTypeDeclaration());\n            return fun == null ? null : fun.getErasure();\n        } else {\n            return findFunctionTypeImpl(candidateSam);\n        }\n    }\n\n    /**\n     * Returns t if it is a class or interface type. If it is an intersection type,\n     * returns the induced class or interface type. Returns null otherwise, including\n     * if the parameter is null.\n     */\n    public static @Nullable JClassType asClassType(@Nullable JTypeMirror t) {\n        if (t instanceof JClassType) {\n            return (JClassType) t;\n        } else if (t instanceof JIntersectionType) {\n            return ((JIntersectionType) t).getInducedClassType();\n        }\n        return null;\n    }\n\n    private static @Nullable JMethodSig findFunctionTypeImpl(@Nullable JClassType candidateSam) {\n\n        if (candidateSam == null || !candidateSam.isInterface() || candidateSam.getSymbol().isAnnotation()) {\n            return null;\n        }\n\n        Map<String, List<JMethodSig>> relevantMethods = candidateSam.streamMethods(it -> !Modifier.isStatic(it.getModifiers()))\n                                                                    .filter(TypeOps::isNotDeclaredInClassObject)\n                                                                    .collect(Collectors.groupingBy(JMethodSig::getName, collectMostSpecific(candidateSam)));\n\n\n        List<JMethodSig> candidates = new ArrayList<>();\n        for (Entry<String, List<JMethodSig>> entry : relevantMethods.entrySet()) {\n            for (JMethodSig sig : entry.getValue()) {\n                if (sig.isAbstract()) {\n                    candidates.add(sig);\n                }\n            }\n        }\n\n        if (candidates.isEmpty()) {\n            return null;\n        } else if (candidates.size() == 1) {\n            return candidates.get(0);\n        }\n\n        JMethodSig currentBest = null;\n\n        nextCandidate:\n        for (int i = 0; i < candidates.size(); i++) {\n            JMethodSig cand = candidates.get(i);\n\n            for (JMethodSig other : candidates) {\n                if (!isSubSignature(cand, other)\n                    || !isReturnTypeSubstitutable(cand, other)) {\n                    continue nextCandidate;\n                }\n            }\n\n            if (currentBest == null) {\n                currentBest = cand;\n            } else if (cand.getReturnType().isSubtypeOf(currentBest.getReturnType())) {\n                // select the most specific return type\n                currentBest = cand;\n            }\n        }\n\n        return currentBest;\n    }\n\n    private static boolean isNotDeclaredInClassObject(JMethodSig it) {\n        TypeSystem ts = it.getDeclaringType().getTypeSystem();\n        return ts.OBJECT.streamMethods(om -> Modifier.isPublic(om.getModifiers()) && om.getSimpleName().equals(it.getName()))\n                        .noneMatch(om -> haveSameSignature(it, om));\n    }\n\n    // </editor-fold>\n\n    // <editor-fold  defaultstate=\"collapsed\" desc=\"As super\">\n\n    /**\n     * @see JTypeMirror#getAsSuper(JClassSymbol)\n     */\n    public static @Nullable JTypeMirror asSuper(JTypeMirror t, JClassSymbol s) {\n\n        if (!t.isPrimitive() && s.equals(t.getTypeSystem().OBJECT.getSymbol())) {\n            // interface types need to have OBJECT somewhere up their hierarchy\n            return t.getTypeSystem().OBJECT;\n        }\n\n        return t.acceptVisitor(AsSuperVisitor.INSTANCE, s);\n    }\n\n    /**\n     * Return the base type of t or any of its outer types that starts\n     * with the given type.  If none exists, return null.\n     */\n    public static JClassType asOuterSuper(JTypeMirror t, JClassSymbol sym) {\n        if (t instanceof JClassType) {\n            JClassType ct = (JClassType) t;\n            do {\n                JClassType sup = ct.getAsSuper(sym);\n                if (sup != null) {\n                    return sup;\n                }\n                ct = ct.getEnclosingType();\n            } while (ct != null);\n        } else if (t instanceof JTypeVar || t instanceof JArrayType) {\n            return (JClassType) t.getAsSuper(sym);\n        }\n        return null;\n    }\n\n    private static final class AsSuperVisitor implements JTypeVisitor<@Nullable JTypeMirror, JClassSymbol> {\n\n        static final AsSuperVisitor INSTANCE = new AsSuperVisitor();\n\n        /** Parameter is the erasure of the target. */\n\n        @Override\n        public JTypeMirror visit(JTypeMirror t, JClassSymbol target) {\n            return null;\n        }\n\n        @Override\n        public JTypeMirror visitClass(JClassType t, JClassSymbol target) {\n            if (target.equals(t.getSymbol())) {\n                return t;\n            }\n\n            // prefer digging up the superclass first\n            JClassType sup = t.getSuperClass();\n            JClassType res = sup == null ? null : (JClassType) sup.acceptVisitor(this, target);\n            if (res != null) {\n                return res;\n            } else {\n                // then look in interfaces if possible\n                if (target.isInterface()) {\n                    return firstResult(target, t.getSuperInterfaces());\n                }\n            }\n\n            return null;\n        }\n\n        @Override\n        public JTypeMirror visitIntersection(JIntersectionType t, JClassSymbol target) {\n            return firstResult(target, t.getComponents());\n        }\n\n        public @Nullable JTypeMirror firstResult(JClassSymbol target, Iterable<? extends JTypeMirror> components) {\n            for (JTypeMirror ci : components) {\n                @Nullable JTypeMirror sup = ci.acceptVisitor(this, target);\n                if (sup != null) {\n                    return sup;\n                }\n            }\n            return null;\n        }\n\n        @Override\n        public JTypeMirror visitTypeVar(JTypeVar t, JClassSymbol target) {\n            // caution, infinite recursion\n            return t.getUpperBound().acceptVisitor(this, target);\n        }\n\n        @Override\n        public JTypeMirror visitArray(JArrayType t, JClassSymbol target) {\n            // Cloneable, Serializable, Object\n            JTypeMirror decl = t.getTypeSystem().declaration(target);\n            return t.isSubtypeOf(decl) ? decl : null;\n        }\n    }\n\n    // </editor-fold>\n\n    // <editor-fold  defaultstate=\"collapsed\" desc=\"LUB/GLB\">\n\n    /**\n     * Returns a subset S of the parameter, whose components have no\n     * strict supertype in S.\n     *\n     * <pre>{@code\n     * S = { V | V in set, and for all W \u2260 V in set, it is not the case that W <: V }\n     * }</pre>\n     */\n    public static Set<JTypeMirror> mostSpecific(Set<? extends JTypeMirror> set) {\n        LinkedHashSet<JTypeMirror> result = new LinkedHashSet<>(set.size());\n        vLoop:\n        for (JTypeMirror v : set) {\n            for (JTypeMirror w : set) {\n                if (!w.equals(v) && w.isSubtypeOf(v, true)) {\n                    continue vLoop;\n                }\n            }\n            result.add(v);\n        }\n        return result;\n    }\n\n    // </editor-fold>\n\n    /**\n     * Returns the components of t if it is an intersection type,\n     * otherwise returns t.\n     */\n    public static List<JTypeMirror> asList(JTypeMirror t) {\n        if (t instanceof JIntersectionType) {\n            return ((JIntersectionType) t).getComponents();\n        } else {\n            return Collections.singletonList(t);\n        }\n    }\n\n    /** Returns a list with the erasures of the given types, may be unmodifiable. */\n    public static List<JTypeMirror> erase(Collection<? extends JTypeMirror> ts) {\n        return CollectionUtil.map(ts, JTypeMirror::getErasure);\n    }\n\n    // <editor-fold  defaultstate=\"collapsed\" desc=\"Mentions\">\n\n\n    public static boolean mentions(@NonNull JTypeVisitable type, @NonNull JInferenceVar parent) {\n        return type.acceptVisitor(MentionsVisitor.INSTANCE, Collections.singleton(parent));\n    }\n\n    public static boolean mentionsAny(JTypeVisitable t, Collection<? extends SubstVar> vars) {\n        return !vars.isEmpty() && t.acceptVisitor(MentionsVisitor.INSTANCE, vars);\n    }\n\n\n    private static final class MentionsVisitor implements JTypeVisitor<Boolean, Collection<? extends JTypeMirror>> {\n\n        static final MentionsVisitor INSTANCE = new MentionsVisitor();\n\n        @Override\n        public Boolean visit(JTypeMirror t, Collection<? extends JTypeMirror> targets) {\n            return false;\n        }\n\n        @Override\n        public Boolean visitTypeVar(JTypeVar t, Collection<? extends JTypeMirror> targets) {\n            return targets.contains(t);\n        }\n\n        @Override\n        public Boolean visitInferenceVar(JInferenceVar t, Collection<? extends JTypeMirror> targets) {\n            return targets.contains(t);\n        }\n\n        @Override\n        public Boolean visitWildcard(JWildcardType t, Collection<? extends JTypeMirror> targets) {\n            return t.getBound().acceptVisitor(this, targets);\n        }\n\n        @Override\n        public Boolean visitMethodType(JMethodSig t, Collection<? extends JTypeMirror> targets) {\n            if (t.getReturnType().acceptVisitor(this, targets)) {\n                return true;\n            }\n            for (JTypeMirror fi : t.getFormalParameters()) {\n                if (fi.acceptVisitor(this, targets)) {\n                    return true;\n                }\n            }\n            for (JTypeMirror ti : t.getThrownExceptions()) {\n                if (ti.acceptVisitor(this, targets)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        @Override\n        public Boolean visitClass(JClassType t, Collection<? extends JTypeMirror> targets) {\n            JClassType encl = t.getEnclosingType();\n            if (encl != null && encl.acceptVisitor(this, targets)) {\n                return true;\n            }\n\n            for (JTypeMirror typeArg : t.getTypeArgs()) {\n                if (typeArg.acceptVisitor(this, targets)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        @Override\n        public Boolean visitIntersection(JIntersectionType t, Collection<? extends JTypeMirror> targets) {\n            for (JTypeMirror comp : t.getComponents()) {\n                if (comp.acceptVisitor(this, targets)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        @Override\n        public Boolean visitArray(JArrayType t, Collection<? extends JTypeMirror> targets) {\n            return t.getComponentType().acceptVisitor(this, targets);\n        }\n    }\n\n    // </editor-fold>\n\n    // <editor-fold  defaultstate=\"collapsed\" desc=\"Accessibility utils\">\n\n\n    public static Predicate<JMethodSymbol> accessibleMethodFilter(String name, @NonNull JClassSymbol symbol) {\n        return it -> it.getSimpleName().equals(name) && isAccessible(it, symbol);\n    }\n\n    public static Iterable<JMethodSig> lazyFilterAccessible(List<JMethodSig> visible, @NonNull JClassSymbol accessSite) {\n        return () -> IteratorUtil.filter(visible.iterator(), it -> isAccessible(it.getSymbol(), accessSite));\n    }\n\n    public static List<JMethodSig> filterAccessible(List<JMethodSig> visible, @NonNull JClassSymbol accessSite) {\n        return CollectionUtil.mapNotNull(visible, m -> isAccessible(m.getSymbol(), accessSite) ? m : null);\n    }\n\n\n    public static List<JMethodSig> getMethodsOf(JTypeMirror type, String name, boolean staticOnly, @NonNull JClassSymbol enclosing) {\n        return type.streamMethods(\n            it -> (!staticOnly || Modifier.isStatic(it.getModifiers()))\n                && it.getSimpleName().equals(name)\n                && isAccessible(it, enclosing)\n        ).collect(collectMostSpecific(type));\n    }\n\n    private static boolean isAccessible(JExecutableSymbol method, JClassSymbol ctx) {\n        Objects.requireNonNull(ctx, \"Cannot check a null symbol\");\n\n        int mods = method.getModifiers();\n        if (Modifier.isPublic(mods)) {\n            return true;\n        }\n\n        JClassSymbol owner = method.getEnclosingClass();\n\n        if (Modifier.isPrivate(mods)) {\n            return ctx.getNestRoot().equals(owner.getNestRoot());\n        }\n\n        return ctx.getPackageName().equals(owner.getPackageName())\n            // we can exclude interfaces because their members are all public\n            || Modifier.isProtected(mods) && isSubClassOfNoInterface(ctx, owner);\n    }\n\n    private static boolean isSubClassOfNoInterface(JClassSymbol sub, JClassSymbol symbol) {\n        if (symbol.equals(sub)) {\n            return true;\n        }\n\n        JClassSymbol superclass = sub.getSuperclass();\n        return superclass != null && isSubClassOfNoInterface(superclass, symbol);\n    }\n\n    public static NameResolver<FieldSig> getMemberFieldResolver(JTypeMirror c, @NonNull String accessPackageName, @Nullable JClassSymbol access, String name) {\n        if (c instanceof JClassType) {\n            // fast path\n            return JavaResolvers.getMemberFieldResolver((JClassType) c, accessPackageName, access, name);\n        }\n\n        return c.acceptVisitor(GetFieldVisitor.INSTANCE, new FieldSearchParams(accessPackageName, access, name));\n    }\n\n    private static final class FieldSearchParams {\n\n        private final @NonNull String accessPackageName;\n        private final @Nullable JClassSymbol access;\n        private final String name;\n\n        FieldSearchParams(@NonNull String accessPackageName, @Nullable JClassSymbol access, String name) {\n            this.accessPackageName = accessPackageName;\n            this.access = access;\n            this.name = name;\n        }\n    }\n\n    private static final class GetFieldVisitor implements JTypeVisitor<NameResolver<FieldSig>, FieldSearchParams> {\n\n        static final GetFieldVisitor INSTANCE = new GetFieldVisitor();\n\n        @Override\n        public NameResolver<FieldSig> visit(JTypeMirror t, FieldSearchParams fieldSearchParams) {\n            return CoreResolvers.emptyResolver();\n        }\n\n        @Override\n        public NameResolver<FieldSig> visitClass(JClassType t, FieldSearchParams fieldSearchParams) {\n            return JavaResolvers.getMemberFieldResolver(t, fieldSearchParams.accessPackageName, fieldSearchParams.access, fieldSearchParams.name);\n        }\n\n        @Override\n        public NameResolver<FieldSig> visitTypeVar(JTypeVar t, FieldSearchParams fieldSearchParams) {\n            return t.getUpperBound().acceptVisitor(this, fieldSearchParams);\n        }\n\n        @Override\n        public NameResolver<FieldSig> visitIntersection(JIntersectionType t, FieldSearchParams fieldSearchParams) {\n            return NameResolver.composite(\n                CollectionUtil.map(t.getComponents(), c -> c.acceptVisitor(this, fieldSearchParams))\n            );\n        }\n\n        @Override\n        public NameResolver<FieldSig> visitArray(JArrayType t, FieldSearchParams fieldSearchParams) {\n            if (\"length\".equals(fieldSearchParams.name)) {\n                return CoreResolvers.singleton(\"length\", t.getTypeSystem().sigOf(t, t.getSymbol().getDeclaredField(\"length\")));\n            }\n            return CoreResolvers.emptyResolver();\n        }\n    }\n\n    // </editor-fold>\n\n    // <editor-fold  defaultstate=\"collapsed\" desc=\"Specificity utils\">\n\n\n    /**\n     * Returns a collector that can apply to a stream of method signatures,\n     * and that collects them into a set of method, where none override one another.\n     * Do not use this in a parallel stream. Do not use this to collect constructors.\n     * Do not use this if your stream contains methods that have different names.\n     *\n     * @param commonSubtype Site where the signatures are observed. The owner of every method\n     *                      in the stream must be a supertype of this type\n     *\n     * @return A collector\n     */\n    public static Collector<JMethodSig, ?, List<JMethodSig>> collectMostSpecific(JTypeMirror commonSubtype) {\n        return Collector.of(\n            OverloadSet::new,\n            (set, sig) -> set.add(sig, commonSubtype),\n            (left, right) -> {\n                throw new NotImplementedException(\"Cannot use this in a parallel stream\");\n            },\n            OverloadSet::getOverloads\n        );\n    }\n\n\n    /**\n     * Given that m1 and m2 are override-equivalent, should m1 be chosen\n     * over m2 (YES/NO), or should an ambiguity error arise (UNKNOWN). This\n     * handles a few cases about shadowing/overriding/hiding that are not\n     * covered strictly by the definition of \"specificity\".\n     *\n     * <p>If m1 and m2 are equal, returns the first one by convention.\n     */\n    public static OptionalBool shouldTakePrecedence(JMethodSig m1, JMethodSig m2, JTypeMirror commonSubtype) {\n        // select\n        // 1. the non-bridge\n        // 2. the one that overrides the other\n        // 3. the non-abstract method\n\n        // Symbols don't reflect bridge methods anymore\n        // if (m1.isBridge() != m2.isBridge()) {\n        //      return definitely(!m1.isBridge());\n        // } else\n        if (overrides(m1, m2, commonSubtype)) {\n            return YES;\n        } else if (overrides(m2, m1, commonSubtype)) {\n            return NO;\n        } else if (m1.isAbstract() ^ m2.isAbstract()) {\n            return definitely(!m1.isAbstract());\n        } else if (m1.isAbstract() && m2.isAbstract()) { // last ditch effort\n            // both are unrelated abstract, inherited into 'site'\n            // their signature would be merged into the site\n            // if exactly one is declared in a class, prefer it\n            // if both are declared in a class, ambiguity error (recall, neither overrides the other)\n            // if both are declared in an interface, select any of them\n            boolean m1InClass = m1.getSymbol().getEnclosingClass().isClass();\n            boolean m2Class = m2.getSymbol().getEnclosingClass().isClass();\n\n            return m1InClass && m2Class ? UNKNOWN : definitely(m1InClass);\n        }\n\n        if (Modifier.isPrivate(m1.getModifiers() | m2.getModifiers())\n            && commonSubtype instanceof JClassType) {\n            // One of them is private, which means, they can't be overridden,\n            // so they failed the above test\n            // Maybe it's shadowing then\n            return shadows(m1, m2, (JClassType) commonSubtype);\n        }\n\n        return UNKNOWN;\n    }\n\n\n    /**\n     * Returns whether m1 shadows m2 in the body of the given site, ie\n     * m1 is declared in a class C1 that encloses the site, and m2 is declared\n     * in a type that strictly encloses C1.\n     *\n     * <p>Assumes m1 and m2 are override-equivalent, and declared in different\n     * classes.\n     */\n    static OptionalBool shadows(JMethodSig m1, JMethodSig m2, JClassType site) {\n        final JClassSymbol c1 = m1.getSymbol().getEnclosingClass();\n        final JClassSymbol c2 = m2.getSymbol().getEnclosingClass();\n\n        // We go outward from the `site`. The height measure is the distance\n        // from the site (ie, the reverted depth of each class)\n\n        int height = 0;\n        int c1Height = -1;\n        int c2Height = -1;\n        JClassSymbol c = site.getSymbol();\n\n        while (c != null) {\n            if (c.equals(c1)) {\n                c1Height = height;\n            }\n            if (c.equals(c2)) {\n                c2Height = height;\n            }\n            c = c.getEnclosingClass();\n            height++;\n        }\n\n        if (c1Height < 0 || c2Height < 0 || c1Height == c2Height) {\n            return UNKNOWN;\n        }\n        return definitely(c1Height < c2Height);\n    }\n\n\n    // </editor-fold>\n\n    // <editor-fold  defaultstate=\"collapsed\" desc=\"Miscellaneous\">\n\n\n    /**\n     * Returns true if the type is {@link TypeSystem#UNRESOLVED_TYPE},\n     * {@link TypeSystem#ERROR_TYPE}, or its symbol is unresolved.\n     *\n     * @param t Non-null type\n     *\n     * @throws NullPointerException if the parameter is null\n     */\n    public static boolean isUnresolved(@NonNull JTypeMirror t) {\n        TypeSystem ts = t.getTypeSystem();\n        return t == ts.UNRESOLVED_TYPE || t == ts.ERROR_TYPE || t.getSymbol() != null && t.getSymbol().isUnresolved();\n    }\n\n    public static boolean isUnresolvedOrNull(@Nullable JTypeMirror t) {\n        return t == null || isUnresolved(t);\n    }\n\n    // </editor-fold>\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.java.types.internal.infer.OverloadSet#add\n methodBody: void add(JMethodSig sig, JTypeMirror commonSubtype) {\nif(name == null){name=sig.getName();\n}assert sig.getName().equals(name) : \"Not the right name!\";\nassert !sig.isConstructor() : \"Constructors they cannot override each other\";\nListIterator<JMethodSig> iterator=overloads.listIterator();\nwhile(iterator.hasNext()){JMethodSig existing=iterator.next();\nif(areOverrideEquivalent(existing,sig)){switch(shouldTakePrecedence(existing,sig,commonSubtype))case YES:return;\ncase NO:iterator.remove();\nbreak;\ncase UNKNOWN:break;\ndefault:throw new AssertionError();\n}}overloads.add(sig);\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.types.internal.infer.OverloadSet#getOverloads\n methodBody: public List<JMethodSig> getOverloads() {\nreturn Collections.unmodifiableList(overloads);\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Returns a collector that can apply to a stream of method signatures,\n     * and that collects them into a set of method, where none override one another.\n     * Do not use this in a parallel stream. Do not use this to collect constructors.\n     * Do not use this if your stream contains methods that have different names.\n     *\n     * @param commonSubtype Site where the signatures are observed. The owner of every method\n     *                      in the stream must be a supertype of this type\n     *\n     * @return A collector\n     */\n    public static Collector<JMethodSig, ?, List<JMethodSig>> collectMostSpecific(JTypeMirror commonSubtype) {\n        return Collector.of(\n            OverloadSet::new,\n            (set, sig) -> set.add(sig, commonSubtype),\n            (left, right) -> {\n                throw new NotImplementedException(\"Cannot use this in a parallel stream\");\n            },\n            OverloadSet::getOverloads\n        );\n    }",
        "diffSourceCode": "-  267:     /**\n-  268:      * Returns a collector that can apply to a stream of method signatures,\n-  269:      * and that collects them into a set of method, where none override one another.\n-  270:      * Do not use this in a parallel stream. Do not use this to collect constructors.\n-  271:      * Do not use this if your stream contains methods that have different names.\n-  272:      *\n-  273:      * @param commonSubtype Site where the signatures are observed. The owner of every method\n-  274:      *                      in the stream must be a supertype of this type\n-  275:      *\n-  276:      * @return A collector\n-  277:      */\n-  278:     public static Collector<JMethodSig, ?, List<JMethodSig>> collectMostSpecific(JTypeMirror commonSubtype) {\n-  279:         return Collector.of(\n-  280:             OverloadSet::new,\n-  281:             (set, sig) -> set.add(sig, commonSubtype),\n-  282:             (left, right) -> {\n-  283:                 throw new NotImplementedException(\"Cannot use this in a parallel stream\");\n-  284:             },\n-  285:             OverloadSet::getOverloads\n-  286:         );\n-  287:     }\n+  267:         public Void visit(JTypeMirror t, Set<JTypeMirror> result) {\n+  268:             throw new IllegalStateException(\"Should not be called\");\n+  269:         }\n+  270: \n+  271:         @Override\n+  272:         public Void visitTypeVar(JTypeVar t, Set<JTypeMirror> result) {\n+  273:             if (result.add(t)) {\n+  274:                 // prevent infinite loop\n+  275:                 t.getUpperBound().acceptVisitor(this, result);\n+  276:             }\n+  277:             return null;\n+  278:         }\n+  279: \n+  280:         @Override\n+  281:         public Void visitNullType(JTypeMirror t, Set<JTypeMirror> result) {\n+  282:             // too many types\n+  283:             throw new IllegalArgumentException(\"The null type has all reference types as supertype\");\n+  284:         }\n+  285: \n+  286:         @Override\n+  287:         public Void visitSentinel(JTypeMirror t, Set<JTypeMirror> result) {\n+ 1724:     /**\n+ 1725:      * Returns a collector that can apply to a stream of method signatures,\n+ 1726:      * and that collects them into a set of method, where none override one another.\n+ 1727:      * Do not use this in a parallel stream. Do not use this to collect constructors.\n+ 1728:      * Do not use this if your stream contains methods that have different names.\n+ 1729:      *\n+ 1730:      * @param commonSubtype Site where the signatures are observed. The owner of every method\n+ 1731:      *                      in the stream must be a supertype of this type\n+ 1732:      *\n+ 1733:      * @return A collector\n+ 1734:      */\n+ 1735:     public static Collector<JMethodSig, ?, List<JMethodSig>> collectMostSpecific(JTypeMirror commonSubtype) {\n+ 1736:         return Collector.of(\n+ 1737:             OverloadSet::new,\n+ 1738:             (set, sig) -> set.add(sig, commonSubtype),\n+ 1739:             (left, right) -> {\n+ 1740:                 throw new NotImplementedException(\"Cannot use this in a parallel stream\");\n+ 1741:             },\n+ 1742:             OverloadSet::getOverloads\n+ 1743:         );\n+ 1744:     }\n",
        "uniqueId": "12d40eb6dcc965cc0523c4f2df71cf52a6a290e8_267_287__1724_1744",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 9
            },
            "LINE": {
                "missed": 0,
                "covered": 1
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic addBound(kind BoundKind, type JTypeMirror, isSubstitution boolean) : void extracted from public addBound(kind BoundKind, type JTypeMirror) : void in class net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/JInferenceVar.java",
                "startLine": 82,
                "endLine": 130,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/JInferenceVar.java",
                "startLine": 82,
                "endLine": 87,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/JInferenceVar.java",
                "startLine": 89,
                "endLine": 134,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Adds a new bound on this variable.\n     */\n    public void addBound(BoundKind kind, JTypeMirror type) {\n        if (type == this) {\n            // may occur because of transitive propagation\n            // alpha <: alpha is always true and not interesting\n            return;\n        }\n\n        if (type instanceof JInferenceVar && ((JInferenceVar) type).getDelegate() != null) {\n            addBound(kind, ((JInferenceVar) type).getDelegate());\n            return;\n        }\n\n        if (delegate != null) {\n            delegate.addBound(kind, type);\n            return;\n        }\n\n        if (type instanceof JInferenceVar) {\n            JInferenceVar var = (JInferenceVar) type;\n\n            if (kind == BoundKind.EQ\n                // A <: B && B <: A => A = B\n                // this is early propagation\n                || getBounds(kind.complement()).contains(type)) {\n\n                var.merge(this);\n                return;\n            }\n        }\n\n        if (type instanceof JInferenceVar && ((JInferenceVar) type).getDelegate() == this) {\n\n            Set<JTypeMirror> bounds = this.bounds.get(kind);\n            if (bounds == null || bounds.isEmpty()) {\n                return;\n            } else {\n                // maybe it's been added previously\n                bounds.remove(type);\n            }\n            return;\n        }\n\n        if (bounds.computeIfAbsent(kind, k -> new LinkedHashSet<>()).add(type)) {\n            ctx.onBoundAdded(this, kind, type);\n        }\n    }",
        "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/JInferenceVar.java",
        "isPureRefactoring": true,
        "commitId": "a78560c337ee1dc2462357fcc94408928433e235",
        "packageNameBefore": "net.sourceforge.pmd.lang.java.types.internal.infer",
        "classNameBefore": "net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar",
        "methodNameBefore": "net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar#addBound",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.java.types.internal.infer.InferenceContext#onBoundAdded\n methodBody: void onBoundAdded(JInferenceVar ivar, BoundKind kind, JTypeMirror bound) {\nif(ivar.getDelegate() != null){return;\n}if(kind != BoundKind.UPPER || bound != ts.OBJECT){if(parent != null){parent.onBoundAdded(ivar,kind,bound);\nreturn;\n}logger.boundAdded(this,ivar,kind,bound);\nincorporationActions.add(new CheckBound(ivar,kind,bound));\nincorporationActions.add(new PropagateBounds(ivar,kind,bound));\n}}\nmethodSignature: net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar#getBounds\n methodBody: Set<JTypeMirror> getBounds(Set<BoundKind> kinds) {\nSet<JTypeMirror> bounds=new LinkedHashSet<>();\nfor(BoundKind k: kinds){bounds.addAll(getBounds(k));\n}return bounds;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar.BoundKind#complement\n methodBody: public abstract BoundKind complement();\nmethodSignature: net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar#getDelegate\n methodBody: JInferenceVar getDelegate() {\nreturn delegate;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar#addBound\n methodBody: public void addBound(BoundKind kind, JTypeMirror type) {\nif(type == this){return;\n}if(type instanceof JInferenceVar && ((JInferenceVar)type).getDelegate() != null){addBound(kind,((JInferenceVar)type).getDelegate());\nreturn;\n}if(delegate != null){delegate.addBound(kind,type);\nreturn;\n}if(type instanceof JInferenceVar){JInferenceVar var=(JInferenceVar)type;\nif(kind == BoundKind.EQ || getBounds(kind.complement()).contains(type)){var.merge(this);\nreturn;\n}}if(type instanceof JInferenceVar && ((JInferenceVar)type).getDelegate() == this){Set<JTypeMirror> bounds=this.bounds.get(kind);\nif(bounds == null || bounds.isEmpty()){return;\n}{bounds.remove(type);\n}return;\n}if(bounds.computeIfAbsent(kind,k -> new LinkedHashSet<>()).add(type)){ctx.onBoundAdded(this,kind,type);\n}}\nmethodSignature: net.sourceforge.pmd.lang.java.types.internal.infer.InferenceContext#isEmpty\n methodBody: public boolean isEmpty() {\nreturn inferenceVars.isEmpty();\n}\nmethodSignature: net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar#merge\n methodBody: void merge(JInferenceVar candidate) {\nJInferenceVar realDelegate=candidate.getDelegate() != null ? candidate.getDelegate() : candidate;\nif(realDelegate == this){return;\n}this.delegate=realDelegate;\nMap<BoundKind,Set<JTypeMirror>> bounds=this.bounds;\nthis.bounds=Collections.emptyMap();\nfor(BoundKind kind: BoundKind.values()){for(JTypeMirror bound: bounds.getOrDefault(kind,Collections.emptySet())){this.delegate.addBound(kind,bound);\n}}ctx.onIvarMerged(this,this.delegate);\n}",
        "classSignatureBefore": "public final class JInferenceVar implements JTypeMirror, SubstVar ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar#addBound"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar"
        ],
        "classSignatureBeforeSet": [
            "public final class JInferenceVar implements JTypeMirror, SubstVar "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Overlapped refactoring - can be identical by undoing the overlapped refactoring\n- Add Parameter-",
                "description": "Parametrization or Add Parameter on top of the extract method - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\n\npackage net.sourceforge.pmd.lang.java.types.internal.infer;\n\nimport java.util.Collections;\nimport java.util.EnumMap;\nimport java.util.EnumSet;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.function.Function;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport net.sourceforge.pmd.lang.java.symbols.JTypeDeclSymbol;\nimport net.sourceforge.pmd.lang.java.types.JTypeMirror;\nimport net.sourceforge.pmd.lang.java.types.JTypeVar;\nimport net.sourceforge.pmd.lang.java.types.JTypeVisitor;\nimport net.sourceforge.pmd.lang.java.types.SubstVar;\nimport net.sourceforge.pmd.lang.java.types.TypeSystem;\n\n/**\n * Represents an inference variable. Inference variables are just\n * placeholder for types, used during the inference process.\n * After type inference they should have been erased and hence this\n * type is of no importance outside the implementation of this framework.\n */\npublic final class JInferenceVar implements JTypeMirror, SubstVar {\n\n    private static final String[] NAMES = {\n        \"\u03b1\", \"\u03b2\", \"\u03b3\", \"\u03b4\", \"\u03b5\", \"\u03b6\", \"\u03b7\", \"\u03b8\", \"\u03b9\", \"\u03ba\", \"\u03bb\", \"\u03bc\", \"\u03bd\",\n        \"\u03be\", \"\u03bf\", \"\u03c0\", \"\u03c1\", \"\u03c3\", \"\u03c2\", \"\u03c4\", \"\u03c5\", \"\u03c6\", \"\u03c7\", \"\u03c8\", \"\u03c9\",\n    };\n\n    private final InferenceContext ctx;\n    private final JTypeVar tvar;\n    private int id;\n    private Map<BoundKind, Set<JTypeMirror>> bounds = new EnumMap<>(BoundKind.class);\n    private JTypeMirror inst;\n    private JInferenceVar delegate;\n\n    JInferenceVar(InferenceContext ctx, JTypeVar tvar, int id) {\n        this.ctx = ctx;\n        this.tvar = tvar;\n        this.id = id;\n    }\n\n    @Override\n    public String getName() {\n        return toString();\n    }\n\n    @Override\n    public TypeSystem getTypeSystem() {\n        return ctx.ts;\n    }\n\n\n    /**\n     * Returns the bounds of a certain kind that apply to\n     * this variable.\n     */\n    Set<JTypeMirror> getBounds(BoundKind kind) {\n        return bounds.getOrDefault(kind, Collections.emptySet());\n    }\n\n\n    Set<JTypeMirror> getBounds(Set<BoundKind> kinds) {\n        Set<JTypeMirror> bounds = new LinkedHashSet<>();\n        for (BoundKind k : kinds) {\n            bounds.addAll(getBounds(k));\n        }\n        return bounds;\n    }\n\n\n    /**\n     * Adds a new bound on this variable.\n     */\n    public void addBound(BoundKind kind, JTypeMirror type) {\n        if (type == this) {\n            // may occur because of transitive propagation\n            // alpha <: alpha is always true and not interesting\n            return;\n        }\n\n        if (type instanceof JInferenceVar && ((JInferenceVar) type).getDelegate() != null) {\n            addBound(kind, ((JInferenceVar) type).getDelegate());\n            return;\n        }\n\n        if (delegate != null) {\n            delegate.addBound(kind, type);\n            return;\n        }\n\n        if (type instanceof JInferenceVar) {\n            JInferenceVar var = (JInferenceVar) type;\n\n            if (kind == BoundKind.EQ\n                // A <: B && B <: A => A = B\n                // this is early propagation\n                || getBounds(kind.complement()).contains(type)) {\n\n                var.merge(this);\n                return;\n            }\n        }\n\n        if (type instanceof JInferenceVar && ((JInferenceVar) type).getDelegate() == this) {\n\n            Set<JTypeMirror> bounds = this.bounds.get(kind);\n            if (bounds == null || bounds.isEmpty()) {\n                return;\n            } else {\n                // maybe it's been added previously\n                bounds.remove(type);\n            }\n            return;\n        }\n\n        if (bounds.computeIfAbsent(kind, k -> new LinkedHashSet<>()).add(type)) {\n            ctx.onBoundAdded(this, kind, type);\n        }\n    }\n\n    /**\n     * Returns the instantiation of this inference variable if\n     * it has already been determined. Returns null otherwise.\n     */\n    @Nullable\n    JTypeMirror getInst() {\n        return delegate == null ? inst : delegate.getInst();\n    }\n\n\n    void setInst(JTypeMirror inst) {\n        this.inst = inst;\n    }\n\n    /**\n     * Apply a substitution to the bounds of this variable.\n     *\n     * @param substitution The substitution to apply\n     */\n    void substBounds(Function<JTypeMirror, JTypeMirror> substitution) {\n\n        for (Entry<BoundKind, Set<JTypeMirror>> entry : bounds.entrySet()) {\n            BoundKind kind = entry.getKey();\n            Set<JTypeMirror> prevBounds = entry.getValue();\n\n\n            // put the new bounds before updating\n            bounds.put(kind, new LinkedHashSet<>());\n\n            for (JTypeMirror prev : prevBounds) {\n                // add substituted bound\n                addBound(kind, prev.subst(substitution));\n            }\n        }\n    }\n\n    JTypeVar getBaseVar() {\n        return tvar;\n    }\n\n\n    boolean isCaptured() {\n        return tvar.isCaptured();\n    }\n\n    JInferenceVar getDelegate() {\n        return delegate;\n    }\n\n\n    /**\n     * Set this ivar's delegate to the given ivar. This\n     * - copies all bounds of this ivar onto the delegate\n     * - drops all bounds of this ivar\n     * - makes {@link #getInst()} delegate to delegate.getInst()\n     *\n     * <p>The inference engine subsequently only works on the delegate.\n     * Proofs about the delegate are reflected by this ivar.\n     */\n    void merge(JInferenceVar candidate) {\n        JInferenceVar realDelegate = candidate.getDelegate() != null ? candidate.getDelegate() : candidate;\n        if (realDelegate == this) {\n            return;\n        }\n        this.delegate = realDelegate;\n\n        Map<BoundKind, Set<JTypeMirror>> bounds = this.bounds;\n        this.bounds = Collections.emptyMap();\n        for (BoundKind kind : BoundKind.values()) {\n            for (JTypeMirror bound : bounds.getOrDefault(kind, Collections.emptySet())) {\n                this.delegate.addBound(kind, bound);\n            }\n        }\n\n        // TODO remove bounds mentioning this var in the delegate\n\n        ctx.onIvarMerged(this, this.delegate);\n    }\n\n    /**\n     * Returns the symbol of the {@link JInferenceVar#getInst() instantiation},\n     * or null if there's no instantiation or it has no symbol.\n     */\n    @Override\n    public @Nullable JTypeDeclSymbol getSymbol() {\n        return inst != null ? inst.getSymbol() : null;\n    }\n\n\n    @Override\n    public JTypeMirror subst(Function<? super SubstVar, ? extends @NonNull JTypeMirror> subst) {\n        return subst.apply(this);\n    }\n\n    @Override\n    public <T, P> T acceptVisitor(JTypeVisitor<T, P> visitor, P p) {\n        return visitor.visitInferenceVar(this, p);\n    }\n\n\n    @Override\n    public String toString() {\n        return NAMES[id % NAMES.length] + numOfId();\n    }\n\n    private String numOfId() {\n        int n = id / NAMES.length;\n        return n == 0 ? \"\" : \"\" + n;\n    }\n\n\n    public enum BoundKind {\n        UPPER(\" <: \") {\n            @Override\n            public BoundKind complement() {\n                return LOWER;\n            }\n\n            @Override\n            public Set<BoundKind> complementSet(boolean eqIsAll) {\n                return EQ_LOWER;\n            }\n        },\n        EQ(\" = \") {\n            @Override\n            public BoundKind complement() {\n                return this;\n            }\n\n            @Override\n            public Set<BoundKind> complementSet(boolean eqIsAll) {\n                return eqIsAll ? ALL : JUST_EQ;\n            }\n        },\n        LOWER(\" >: \") {\n            @Override\n            public BoundKind complement() {\n                return UPPER;\n            }\n\n            @Override\n            public Set<BoundKind> complementSet(boolean eqIsAll) {\n                return EQ_UPPER;\n            }\n        };\n\n        // These sets are shared because otherwise *literal millions* of enumsets are created, with the same constants\n        static final Set<BoundKind> ALL = EnumSet.allOf(BoundKind.class);\n        static final Set<BoundKind> EQ_LOWER = EnumSet.of(EQ, LOWER);\n        private static final Set<BoundKind> EQ_UPPER = EnumSet.of(EQ, UPPER);\n        private static final Set<BoundKind> JUST_EQ = Collections.singleton(EQ);\n\n        private final String sym;\n\n        BoundKind(String sym) {\n            this.sym = sym;\n        }\n\n        public String format(JTypeMirror ivar, JTypeMirror bound) {\n            return ivar + sym + bound;\n        }\n\n        /**\n         * Returns the complementary bound kind.\n         * <pre>\n         *     complement(LOWER) = UPPER\n         *     complement(UPPER) = LOWER\n         *     complement(EQ) = EQ\n         * </pre>\n         */\n        public abstract BoundKind complement();\n\n\n        /**\n         * Returns the complement of this kind. There's two ways to complement EQ:\n         * - With eqIsAll, this returns all constants.\n         * - Otherwise this returns just EQ.\n         */\n        public abstract Set<BoundKind> complementSet(boolean eqIsAll);\n\n        @Override\n        public String toString() {\n            return sym;\n        }\n    }\n}\n",
        "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/internal/infer/JInferenceVar.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\n\npackage net.sourceforge.pmd.lang.java.types.internal.infer;\n\nimport java.util.Collections;\nimport java.util.EnumMap;\nimport java.util.EnumSet;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.function.Function;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport net.sourceforge.pmd.lang.java.symbols.JTypeDeclSymbol;\nimport net.sourceforge.pmd.lang.java.types.JTypeMirror;\nimport net.sourceforge.pmd.lang.java.types.JTypeVar;\nimport net.sourceforge.pmd.lang.java.types.JTypeVisitor;\nimport net.sourceforge.pmd.lang.java.types.SubstVar;\nimport net.sourceforge.pmd.lang.java.types.TypeSystem;\n\n/**\n * Represents an inference variable. Inference variables are just\n * placeholder for types, used during the inference process.\n * After type inference they should have been erased and hence this\n * type is of no importance outside the implementation of this framework.\n */\npublic final class JInferenceVar implements JTypeMirror, SubstVar {\n\n    private static final String[] NAMES = {\n        \"\u03b1\", \"\u03b2\", \"\u03b3\", \"\u03b4\", \"\u03b5\", \"\u03b6\", \"\u03b7\", \"\u03b8\", \"\u03b9\", \"\u03ba\", \"\u03bb\", \"\u03bc\", \"\u03bd\",\n        \"\u03be\", \"\u03bf\", \"\u03c0\", \"\u03c1\", \"\u03c3\", \"\u03c2\", \"\u03c4\", \"\u03c5\", \"\u03c6\", \"\u03c7\", \"\u03c8\", \"\u03c9\",\n    };\n\n    private final InferenceContext ctx;\n    private final JTypeVar tvar;\n    private int id;\n    private Map<BoundKind, Set<JTypeMirror>> bounds = new EnumMap<>(BoundKind.class);\n    private JTypeMirror inst;\n    private JInferenceVar delegate;\n\n    JInferenceVar(InferenceContext ctx, JTypeVar tvar, int id) {\n        this.ctx = ctx;\n        this.tvar = tvar;\n        this.id = id;\n    }\n\n    @Override\n    public String getName() {\n        return toString();\n    }\n\n    @Override\n    public TypeSystem getTypeSystem() {\n        return ctx.ts;\n    }\n\n\n    /**\n     * Returns the bounds of a certain kind that apply to\n     * this variable.\n     */\n    Set<JTypeMirror> getBounds(BoundKind kind) {\n        return bounds.getOrDefault(kind, Collections.emptySet());\n    }\n\n\n    Set<JTypeMirror> getBounds(Set<BoundKind> kinds) {\n        Set<JTypeMirror> bounds = new LinkedHashSet<>();\n        for (BoundKind k : kinds) {\n            bounds.addAll(getBounds(k));\n        }\n        return bounds;\n    }\n\n\n    /**\n     * Adds a new bound on this variable.\n     */\n    public void addBound(BoundKind kind, JTypeMirror type) {\n        addBound(kind, type, false);\n    }\n\n    public void addBound(BoundKind kind, JTypeMirror type, boolean isSubstitution) {\n        if (type == this) {\n            // may occur because of transitive propagation\n            // alpha <: alpha is always true and not interesting\n            return;\n        }\n\n        if (type instanceof JInferenceVar && ((JInferenceVar) type).getDelegate() != null) {\n            addBound(kind, ((JInferenceVar) type).getDelegate());\n            return;\n        }\n\n        if (delegate != null) {\n            delegate.addBound(kind, type);\n            return;\n        }\n\n        if (type instanceof JInferenceVar) {\n            JInferenceVar var = (JInferenceVar) type;\n\n            if (kind == BoundKind.EQ\n                // A <: B && B <: A => A = B\n                // this is early propagation\n                || getBounds(kind.complement()).contains(type)) {\n\n                var.merge(this);\n                return;\n            }\n        }\n\n        if (type instanceof JInferenceVar && ((JInferenceVar) type).getDelegate() == this) {\n\n            Set<JTypeMirror> bounds = this.bounds.get(kind);\n            if (bounds == null || bounds.isEmpty()) {\n                return;\n            } else {\n                // maybe it's been added previously\n                bounds.remove(type);\n            }\n            return;\n        }\n\n        if (bounds.computeIfAbsent(kind, k -> new LinkedHashSet<>()).add(type)) {\n            ctx.onBoundAdded(this, kind, type, isSubstitution);\n        }\n    }\n\n    /**\n     * Returns the instantiation of this inference variable if\n     * it has already been determined. Returns null otherwise.\n     */\n    @Nullable\n    JTypeMirror getInst() {\n        return delegate == null ? inst : delegate.getInst();\n    }\n\n\n    void setInst(JTypeMirror inst) {\n        this.inst = inst;\n    }\n\n    /**\n     * Apply a substitution to the bounds of this variable.\n     *\n     * @param substitution The substitution to apply\n     */\n    void substBounds(Function<JTypeMirror, JTypeMirror> substitution) {\n\n        for (Entry<BoundKind, Set<JTypeMirror>> entry : bounds.entrySet()) {\n            BoundKind kind = entry.getKey();\n            Set<JTypeMirror> prevBounds = entry.getValue();\n\n\n            // put the new bounds before updating\n            LinkedHashSet<JTypeMirror> newBounds = new LinkedHashSet<>();\n            bounds.put(kind, newBounds);\n\n            for (JTypeMirror prev : prevBounds) {\n                // add substituted bound\n                JTypeMirror newBound = prev.subst(substitution);\n                if (newBound == prev) {\n                    // not actually new, don't call listeners, etc\n                    newBounds.add(prev);\n                } else {\n                    addBound(kind, newBound);\n                }\n            }\n        }\n    }\n\n    JTypeVar getBaseVar() {\n        return tvar;\n    }\n\n\n    boolean isCaptured() {\n        return tvar.isCaptured();\n    }\n\n    JInferenceVar getDelegate() {\n        return delegate;\n    }\n\n\n    /**\n     * Set this ivar's delegate to the given ivar. This\n     * - copies all bounds of this ivar onto the delegate\n     * - drops all bounds of this ivar\n     * - makes {@link #getInst()} delegate to delegate.getInst()\n     *\n     * <p>The inference engine subsequently only works on the delegate.\n     * Proofs about the delegate are reflected by this ivar.\n     */\n    void merge(JInferenceVar candidate) {\n        JInferenceVar realDelegate = candidate.getDelegate() != null ? candidate.getDelegate() : candidate;\n        if (realDelegate == this) {\n            return;\n        }\n        this.delegate = realDelegate;\n\n        Map<BoundKind, Set<JTypeMirror>> bounds = this.bounds;\n        this.bounds = Collections.emptyMap();\n        for (BoundKind kind : BoundKind.values()) {\n            for (JTypeMirror bound : bounds.getOrDefault(kind, Collections.emptySet())) {\n                this.delegate.addBound(kind, bound);\n            }\n        }\n\n        // TODO remove bounds mentioning this var in the delegate\n\n        ctx.onIvarMerged(this, this.delegate);\n    }\n\n    /**\n     * Returns the symbol of the {@link JInferenceVar#getInst() instantiation},\n     * or null if there's no instantiation or it has no symbol.\n     */\n    @Override\n    public @Nullable JTypeDeclSymbol getSymbol() {\n        return inst != null ? inst.getSymbol() : null;\n    }\n\n\n    @Override\n    public JTypeMirror subst(Function<? super SubstVar, ? extends @NonNull JTypeMirror> subst) {\n        return subst.apply(this);\n    }\n\n    @Override\n    public <T, P> T acceptVisitor(JTypeVisitor<T, P> visitor, P p) {\n        return visitor.visitInferenceVar(this, p);\n    }\n\n\n    @Override\n    public String toString() {\n        return NAMES[id % NAMES.length] + numOfId();\n    }\n\n    private String numOfId() {\n        int n = id / NAMES.length;\n        return n == 0 ? \"\" : \"\" + n;\n    }\n\n\n    public enum BoundKind {\n        UPPER(\" <: \") {\n            @Override\n            public BoundKind complement() {\n                return LOWER;\n            }\n\n            @Override\n            public Set<BoundKind> complementSet(boolean eqIsAll) {\n                return EQ_LOWER;\n            }\n        },\n        EQ(\" = \") {\n            @Override\n            public BoundKind complement() {\n                return this;\n            }\n\n            @Override\n            public Set<BoundKind> complementSet(boolean eqIsAll) {\n                return eqIsAll ? ALL : JUST_EQ;\n            }\n        },\n        LOWER(\" >: \") {\n            @Override\n            public BoundKind complement() {\n                return UPPER;\n            }\n\n            @Override\n            public Set<BoundKind> complementSet(boolean eqIsAll) {\n                return EQ_UPPER;\n            }\n        };\n\n        // These sets are shared because otherwise *literal millions* of enumsets are created, with the same constants\n        static final Set<BoundKind> ALL = EnumSet.allOf(BoundKind.class);\n        static final Set<BoundKind> EQ_LOWER = EnumSet.of(EQ, LOWER);\n        private static final Set<BoundKind> EQ_UPPER = EnumSet.of(EQ, UPPER);\n        private static final Set<BoundKind> JUST_EQ = Collections.singleton(EQ);\n\n        private final String sym;\n\n        BoundKind(String sym) {\n            this.sym = sym;\n        }\n\n        public String format(JTypeMirror ivar, JTypeMirror bound) {\n            return ivar + sym + bound;\n        }\n\n        /**\n         * Returns the complementary bound kind.\n         * <pre>\n         *     complement(LOWER) = UPPER\n         *     complement(UPPER) = LOWER\n         *     complement(EQ) = EQ\n         * </pre>\n         */\n        public abstract BoundKind complement();\n\n\n        /**\n         * Returns the complement of this kind. There's two ways to complement EQ:\n         * - With eqIsAll, this returns all constants.\n         * - Otherwise this returns just EQ.\n         */\n        public abstract Set<BoundKind> complementSet(boolean eqIsAll);\n\n        @Override\n        public String toString() {\n            return sym;\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            "public void addBound(BoundKind kind, JTypeMirror type, boolean isSubstitution) {\n        if (type == this) {\n            // may occur because of transitive propagation\n            // alpha <: alpha is always true and not interesting\n            return;\n        }\n\n        if (type instanceof JInferenceVar && ((JInferenceVar) type).getDelegate() != null) {\n            addBound(kind, ((JInferenceVar) type).getDelegate());\n            return;\n        }\n\n        if (delegate != null) {\n            delegate.addBound(kind, type);\n            return;\n        }\n\n        if (type instanceof JInferenceVar) {\n            JInferenceVar var = (JInferenceVar) type;\n\n            if (kind == BoundKind.EQ\n                // A <: B && B <: A => A = B\n                // this is early propagation\n                || getBounds(kind.complement()).contains(type)) {\n\n                var.merge(this);\n                return;\n            }\n        }\n\n        if (type instanceof JInferenceVar && ((JInferenceVar) type).getDelegate() == this) {\n\n            Set<JTypeMirror> bounds = this.bounds.get(kind);\n            if (bounds == null || bounds.isEmpty()) {\n                return;\n            } else {\n                // maybe it's been added previously\n                bounds.remove(type);\n            }\n            return;\n        }\n\n        if (bounds.computeIfAbsent(kind, k -> new LinkedHashSet<>()).add(type)) {\n            ctx.onBoundAdded(this, kind, type, isSubstitution);\n        }\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.java.types.internal.infer.InferenceContext#onBoundAdded\n methodBody: void onBoundAdded(JInferenceVar ivar, BoundKind kind, JTypeMirror bound) {\nif(ivar.getDelegate() != null){return;\n}if(kind != BoundKind.UPPER || bound != ts.OBJECT){if(parent != null){parent.onBoundAdded(ivar,kind,bound);\nreturn;\n}logger.boundAdded(this,ivar,kind,bound);\nincorporationActions.add(new CheckBound(ivar,kind,bound));\nincorporationActions.add(new PropagateBounds(ivar,kind,bound));\n}}",
            "methodSignature: net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar#getBounds\n methodBody: Set<JTypeMirror> getBounds(Set<BoundKind> kinds) {\nSet<JTypeMirror> bounds=new LinkedHashSet<>();\nfor(BoundKind k: kinds){bounds.addAll(getBounds(k));\n}return bounds;\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar.BoundKind#complement\n methodBody: public abstract BoundKind complement();",
            "methodSignature: net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar#getDelegate\n methodBody: JInferenceVar getDelegate() {\nreturn delegate;\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar#addBound\n methodBody: public void addBound(BoundKind kind, JTypeMirror type) {\nif(type == this){return;\n}if(type instanceof JInferenceVar && ((JInferenceVar)type).getDelegate() != null){addBound(kind,((JInferenceVar)type).getDelegate());\nreturn;\n}if(delegate != null){delegate.addBound(kind,type);\nreturn;\n}if(type instanceof JInferenceVar){JInferenceVar var=(JInferenceVar)type;\nif(kind == BoundKind.EQ || getBounds(kind.complement()).contains(type)){var.merge(this);\nreturn;\n}}if(type instanceof JInferenceVar && ((JInferenceVar)type).getDelegate() == this){Set<JTypeMirror> bounds=this.bounds.get(kind);\nif(bounds == null || bounds.isEmpty()){return;\n}{bounds.remove(type);\n}return;\n}if(bounds.computeIfAbsent(kind,k -> new LinkedHashSet<>()).add(type)){ctx.onBoundAdded(this,kind,type);\n}}",
            "methodSignature: net.sourceforge.pmd.lang.java.types.internal.infer.InferenceContext#isEmpty\n methodBody: public boolean isEmpty() {\nreturn inferenceVars.isEmpty();\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar#merge\n methodBody: void merge(JInferenceVar candidate) {\nJInferenceVar realDelegate=candidate.getDelegate() != null ? candidate.getDelegate() : candidate;\nif(realDelegate == this){return;\n}this.delegate=realDelegate;\nMap<BoundKind,Set<JTypeMirror>> bounds=this.bounds;\nthis.bounds=Collections.emptyMap();\nfor(BoundKind kind: BoundKind.values()){for(JTypeMirror bound: bounds.getOrDefault(kind,Collections.emptySet())){this.delegate.addBound(kind,bound);\n}}ctx.onIvarMerged(this,this.delegate);\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Adds a new bound on this variable.\n     */\n    public void addBound(BoundKind kind, JTypeMirror type) {\n        addBound(kind, type, false);\n    }\npublic void addBound(BoundKind kind, JTypeMirror type, boolean isSubstitution) {\n        if (type == this) {\n            // may occur because of transitive propagation\n            // alpha <: alpha is always true and not interesting\n            return;\n        }\n\n        if (type instanceof JInferenceVar && ((JInferenceVar) type).getDelegate() != null) {\n            addBound(kind, ((JInferenceVar) type).getDelegate());\n            return;\n        }\n\n        if (delegate != null) {\n            delegate.addBound(kind, type);\n            return;\n        }\n\n        if (type instanceof JInferenceVar) {\n            JInferenceVar var = (JInferenceVar) type;\n\n            if (kind == BoundKind.EQ\n                // A <: B && B <: A => A = B\n                // this is early propagation\n                || getBounds(kind.complement()).contains(type)) {\n\n                var.merge(this);\n                return;\n            }\n        }\n\n        if (type instanceof JInferenceVar && ((JInferenceVar) type).getDelegate() == this) {\n\n            Set<JTypeMirror> bounds = this.bounds.get(kind);\n            if (bounds == null || bounds.isEmpty()) {\n                return;\n            } else {\n                // maybe it's been added previously\n                bounds.remove(type);\n            }\n            return;\n        }\n\n        if (bounds.computeIfAbsent(kind, k -> new LinkedHashSet<>()).add(type)) {\n            ctx.onBoundAdded(this, kind, type, isSubstitution);\n        }\n    }",
        "diffSourceCode": "    82:     /**\n    83:      * Adds a new bound on this variable.\n    84:      */\n    85:     public void addBound(BoundKind kind, JTypeMirror type) {\n-   86:         if (type == this) {\n-   87:             // may occur because of transitive propagation\n-   88:             // alpha <: alpha is always true and not interesting\n-   89:             return;\n-   90:         }\n-   91: \n-   92:         if (type instanceof JInferenceVar && ((JInferenceVar) type).getDelegate() != null) {\n-   93:             addBound(kind, ((JInferenceVar) type).getDelegate());\n-   94:             return;\n-   95:         }\n-   96: \n-   97:         if (delegate != null) {\n-   98:             delegate.addBound(kind, type);\n-   99:             return;\n-  100:         }\n-  101: \n-  102:         if (type instanceof JInferenceVar) {\n-  103:             JInferenceVar var = (JInferenceVar) type;\n-  104: \n-  105:             if (kind == BoundKind.EQ\n-  106:                 // A <: B && B <: A => A = B\n-  107:                 // this is early propagation\n-  108:                 || getBounds(kind.complement()).contains(type)) {\n-  109: \n-  110:                 var.merge(this);\n-  111:                 return;\n-  112:             }\n-  113:         }\n-  114: \n-  115:         if (type instanceof JInferenceVar && ((JInferenceVar) type).getDelegate() == this) {\n-  116: \n-  117:             Set<JTypeMirror> bounds = this.bounds.get(kind);\n-  118:             if (bounds == null || bounds.isEmpty()) {\n-  119:                 return;\n-  120:             } else {\n-  121:                 // maybe it's been added previously\n-  122:                 bounds.remove(type);\n-  123:             }\n-  124:             return;\n-  125:         }\n-  126: \n-  127:         if (bounds.computeIfAbsent(kind, k -> new LinkedHashSet<>()).add(type)) {\n-  128:             ctx.onBoundAdded(this, kind, type);\n+   86:         addBound(kind, type, false);\n+   87:     }\n+   88: \n+   89:     public void addBound(BoundKind kind, JTypeMirror type, boolean isSubstitution) {\n+   90:         if (type == this) {\n+   91:             // may occur because of transitive propagation\n+   92:             // alpha <: alpha is always true and not interesting\n+   93:             return;\n+   94:         }\n+   95: \n+   96:         if (type instanceof JInferenceVar && ((JInferenceVar) type).getDelegate() != null) {\n+   97:             addBound(kind, ((JInferenceVar) type).getDelegate());\n+   98:             return;\n+   99:         }\n+  100: \n+  101:         if (delegate != null) {\n+  102:             delegate.addBound(kind, type);\n+  103:             return;\n+  104:         }\n+  105: \n+  106:         if (type instanceof JInferenceVar) {\n+  107:             JInferenceVar var = (JInferenceVar) type;\n+  108: \n+  109:             if (kind == BoundKind.EQ\n+  110:                 // A <: B && B <: A => A = B\n+  111:                 // this is early propagation\n+  112:                 || getBounds(kind.complement()).contains(type)) {\n+  113: \n+  114:                 var.merge(this);\n+  115:                 return;\n+  116:             }\n+  117:         }\n+  118: \n+  119:         if (type instanceof JInferenceVar && ((JInferenceVar) type).getDelegate() == this) {\n+  120: \n+  121:             Set<JTypeMirror> bounds = this.bounds.get(kind);\n+  122:             if (bounds == null || bounds.isEmpty()) {\n+  123:                 return;\n+  124:             } else {\n+  125:                 // maybe it's been added previously\n+  126:                 bounds.remove(type);\n+  127:             }\n+  128:             return;\n   129:         }\n-  130:     }\n-  131: \n-  132:     /**\n-  133:      * Returns the instantiation of this inference variable if\n-  134:      * it has already been determined. Returns null otherwise.\n+  130: \n+  131:         if (bounds.computeIfAbsent(kind, k -> new LinkedHashSet<>()).add(type)) {\n+  132:             ctx.onBoundAdded(this, kind, type, isSubstitution);\n+  133:         }\n+  134:     }\n",
        "uniqueId": "a78560c337ee1dc2462357fcc94408928433e235_82_130_89_134_82_87",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 17,
                "covered": 71
            },
            "BRANCH": {
                "missed": 5,
                "covered": 19
            },
            "LINE": {
                "missed": 5,
                "covered": 18
            },
            "COMPLEXITY": {
                "missed": 3,
                "covered": 10
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate checkArrayElement(element JTypeMirror) : void extracted from public arrayType(element JTypeMirror, numDimensions int) : JTypeMirror in class net.sourceforge.pmd.lang.java.types.TypeSystem",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeSystem.java",
                "startLine": 435,
                "endLine": 475,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeSystem.java",
                "startLine": 439,
                "endLine": 472,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeSystem.java",
                "startLine": 491,
                "endLine": 499,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Creates a new array type from an arbitrary element type.\n     *\n     * <pre>{@code\n     * arrayType(T, 0)          = T\n     * arrayType(T, 1)          = T[]\n     * arrayType(T, 3)          = T[][][]\n     * arrayType(T[], 2)        = T[][][]\n     * arrayType(ERROR_TYPE, _) = ERROR_TYPE\n     * }</pre>\n     *\n     * @param element       Element type\n     * @param numDimensions Number of dimensions\n     *\n     * @return A new array type\n     *\n     * @throws IllegalArgumentException If numDimensions is negative\n     * @throws IllegalArgumentException If the element type is a {@link JWildcardType},\n     *                                  the null type, or {@link #NO_TYPE void}.\n     * @throws NullPointerException     If the element type is null\n     */\n    public JTypeMirror arrayType(@NonNull JTypeMirror element, int numDimensions) {\n        AssertionUtil.requireNonNegative(\"numDimensions\", numDimensions);\n        AssertionUtil.requireParamNotNull(\"elementType\", element);\n\n        if (element instanceof JWildcardType\n            || element == NULL_TYPE\n            || element == NO_TYPE) {\n            throw new IllegalArgumentException(\"The type < \" + element + \" > is not a valid array element type \");\n        }\n\n        if (numDimensions == 0 || element == ERROR_TYPE) {\n            return element;\n        }\n\n        JArrayType res = new ArrayTypeImpl(this, element);\n        while (--numDimensions > 0) {\n            res = new ArrayTypeImpl(this, res);\n        }\n        return res;\n    }",
        "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeSystem.java",
        "isPureRefactoring": true,
        "commitId": "a229887f034561d0280131588bad1ad6845e3631",
        "packageNameBefore": "net.sourceforge.pmd.lang.java.types",
        "classNameBefore": "net.sourceforge.pmd.lang.java.types.TypeSystem",
        "methodNameBefore": "net.sourceforge.pmd.lang.java.types.TypeSystem#arrayType",
        "classSignatureBefore": "public final class TypeSystem ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.types.TypeSystem#arrayType"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.types.TypeSystem"
        ],
        "classSignatureBeforeSet": [
            "public final class TypeSystem "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.types;\n\nimport static java.util.Collections.emptyList;\nimport static net.sourceforge.pmd.util.CollectionUtil.immutableSetOf;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.EnumMap;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.function.Function;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.internal.util.AssertionUtil;\nimport net.sourceforge.pmd.lang.java.symbols.JClassSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JExecutableSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JFieldSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JFormalParamSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JLocalVariableSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JTypeDeclSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JTypeParameterSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.SymbolResolver;\nimport net.sourceforge.pmd.lang.java.symbols.internal.SymbolFactory;\nimport net.sourceforge.pmd.lang.java.symbols.internal.asm.AsmSymbolResolver;\nimport net.sourceforge.pmd.lang.java.types.BasePrimitiveSymbol.RealPrimitiveSymbol;\nimport net.sourceforge.pmd.lang.java.types.BasePrimitiveSymbol.VoidSymbol;\nimport net.sourceforge.pmd.lang.java.types.JPrimitiveType.PrimitiveTypeKind;\nimport net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar;\n\n/**\n * Root context object for type analysis. Type systems own a {@link SymbolFactory},\n * which creates and caches symbols. Methods of this class promote symbols\n * to types, and compose types together. {@link TypeOps} and {@link TypeConversion}\n * have some more operations on types.\n *\n * <p>Some special types are presented as constant fields, eg {@link #OBJECT}\n * or {@link #NULL_TYPE}. These are always comparable by reference.\n *\n * <p>The lifetime of a type system is the analysis: it is shared by\n * all compilation units.\n * TODO this is hacked together by comparing the ClassLoader, but this\n *  should be in the language instance\n *\n */\n@SuppressWarnings(\"PMD.CompareObjectsWithEquals\")\npublic final class TypeSystem {\n\n    /** Top type of the reference type system. */\n    public final JClassType OBJECT;\n\n    /**\n     * The bottom type of the reference type system. This is named\n     * the <i>null type</i> in the JLS and is not denotable in Java\n     * programs.\n     *\n     * <p>This implementation uses this as the type of the 'null' literal.\n     */\n    public final JTypeMirror NULL_TYPE = new NullType(this);\n\n\n    // primitives\n    public final JPrimitiveType BOOLEAN;\n    public final JPrimitiveType CHAR;\n    public final JPrimitiveType BYTE;\n    public final JPrimitiveType SHORT;\n    public final JPrimitiveType INT;\n    public final JPrimitiveType LONG;\n    public final JPrimitiveType FLOAT;\n    public final JPrimitiveType DOUBLE;\n\n    /**\n     * The set of all primitive types. See {@link #getPrimitive(PrimitiveTypeKind)}.\n     */\n    public final Set<JPrimitiveType> allPrimitives;\n    private final EnumMap<PrimitiveTypeKind, JPrimitiveType> primitivesByKind;\n\n    /**\n     * A constant to represent the normal absence of a type. The\n     * primitive {@code void.class} represents that type, and this\n     * is the return type of a void method.\n     *\n     * <p>Note that the type of the class literal {@code void.class}\n     * is {@code Class<java.lang.Void>}, not NO_TYPE.\n     */\n    public final JTypeMirror NO_TYPE;\n\n    /**\n     * A constant to represent an unresolved type. This means, that resolution\n     * was attempted but failed and shouldn't be tried again.\n     */\n    public final JTypeMirror UNRESOLVED_TYPE;\n\n    /**\n     * Sentinel value for an unresolved method. This type corresponds to\n     * a method declaration in the type {@link #UNRESOLVED_TYPE},\n     * returning {@link #UNRESOLVED_TYPE}.\n     */\n    // TODO it doesn't need to be declared in UNRESOLVED_TYPE\n    public final JMethodSig UNRESOLVED_METHOD = new UnresolvedMethodSig(this);\n\n    /**\n     * A constant to represent a typing error. This would have been\n     * reported by a compiler.\n     */\n    public final JTypeMirror ERROR_TYPE = new SentinelType(this, \"/*error*/\");\n\n    /*\n     * Common, non-special types.\n     */\n\n    /** The unbounded wildcard, \"?\". */\n    public final JWildcardType UNBOUNDED_WILD;\n\n    // array supertypes\n    public final JClassType CLONEABLE;\n    public final JClassType SERIALIZABLE;\n\n    /**\n     * This is the boxed type of {@code Void.class}, not to be confused with\n     * {@code void.class}, which in this framework is represented by\n     * {@link #NO_TYPE}.\n     */\n    public final JClassType BOXED_VOID;\n\n\n    private final SymbolFactory symbolFactory;\n\n    /** Contains special types, that must be shared to be comparable by reference. */\n    private final Map<JTypeDeclSymbol, JTypeMirror> sharedTypes;\n    // test only\n    final AsmSymbolResolver resolver;\n\n    /**\n     * Builds a new type system. Its public fields will be initialized\n     * with fresh types, unrelated to other types.\n     *\n     * @param bootstrapResourceLoader Classloader used to resolve class files\n     *                                to populate the fields of the new type\n     *                                system\n     */\n    public TypeSystem(ClassLoader bootstrapResourceLoader) {\n        this.resolver = new AsmSymbolResolver(this, bootstrapResourceLoader);\n        this.symbolFactory = new SymbolFactory(this);\n\n        // initialize primitives. their constructor also initializes their box + box erasure\n\n        BOOLEAN = createPrimitive(PrimitiveTypeKind.BOOLEAN, Boolean.class);\n        CHAR = createPrimitive(PrimitiveTypeKind.CHAR, Character.class);\n        BYTE = createPrimitive(PrimitiveTypeKind.BYTE, Byte.class);\n        SHORT = createPrimitive(PrimitiveTypeKind.SHORT, Short.class);\n        INT = createPrimitive(PrimitiveTypeKind.INT, Integer.class);\n        LONG = createPrimitive(PrimitiveTypeKind.LONG, Long.class);\n        FLOAT = createPrimitive(PrimitiveTypeKind.FLOAT, Float.class);\n        DOUBLE = createPrimitive(PrimitiveTypeKind.DOUBLE, Double.class);\n\n        // this relies on the fact that setOf always returns immutable sets\n        BOOLEAN.superTypes = immutableSetOf(BOOLEAN);\n        CHAR.superTypes = immutableSetOf(CHAR, INT, LONG, FLOAT, DOUBLE);\n        BYTE.superTypes = immutableSetOf(BYTE, SHORT, INT, LONG, FLOAT, DOUBLE);\n        SHORT.superTypes = immutableSetOf(SHORT, INT, LONG, FLOAT, DOUBLE);\n        INT.superTypes = immutableSetOf(INT, LONG, FLOAT, DOUBLE);\n        LONG.superTypes = immutableSetOf(LONG, FLOAT, DOUBLE);\n        FLOAT.superTypes = immutableSetOf(FLOAT, DOUBLE);\n        DOUBLE.superTypes = immutableSetOf(DOUBLE);\n\n        this.allPrimitives = immutableSetOf(BOOLEAN, CHAR, BYTE, SHORT, INT, LONG, FLOAT, DOUBLE);\n        this.primitivesByKind = new EnumMap<>(PrimitiveTypeKind.class);\n        primitivesByKind.put(PrimitiveTypeKind.BOOLEAN, BOOLEAN);\n        primitivesByKind.put(PrimitiveTypeKind.CHAR, CHAR);\n        primitivesByKind.put(PrimitiveTypeKind.BYTE, BYTE);\n        primitivesByKind.put(PrimitiveTypeKind.SHORT, SHORT);\n        primitivesByKind.put(PrimitiveTypeKind.INT, INT);\n        primitivesByKind.put(PrimitiveTypeKind.LONG, LONG);\n        primitivesByKind.put(PrimitiveTypeKind.FLOAT, FLOAT);\n        primitivesByKind.put(PrimitiveTypeKind.DOUBLE, DOUBLE);\n\n        JClassSymbol unresolvedTypeSym = symbolFactory.makeUnresolvedReference(\"/*unresolved*/\", 0);\n        UNRESOLVED_TYPE = new SentinelType(this, \"/*unresolved*/\", unresolvedTypeSym);\n\n        JClassSymbol primitiveVoidSym = new VoidSymbol(this);\n        NO_TYPE = new SentinelType(this, \"void\", primitiveVoidSym);\n\n        // reuse instances for common types\n\n        // this map is vital to preserve some of the invariants of\n        // the framework, e.g., that primitive types are never represented\n        // by a ClassType, or that OBJECT is unique\n\n        // this is only appropriate for non-generic types\n\n        Map<JClassSymbol, JTypeMirror> shared = new HashMap<>();\n\n        OBJECT = addSpecial(Object.class, shared);\n        SERIALIZABLE = addSpecial(Serializable.class, shared);\n        CLONEABLE = addSpecial(Cloneable.class, shared);\n        BOXED_VOID = addSpecial(Void.class, shared);\n\n        shared.put(primitiveVoidSym, NO_TYPE);\n        shared.put(unresolvedTypeSym, UNRESOLVED_TYPE);\n\n        for (JPrimitiveType prim : allPrimitives) {\n            // primitives have a special implementation for their box\n            shared.put(prim.getSymbol(), prim);\n            shared.put(prim.box().getSymbol(), prim.box());\n        }\n\n        // make it really untouchable\n        this.sharedTypes = Collections.unmodifiableMap(new HashMap<>(shared));\n\n        UNBOUNDED_WILD = new WildcardTypeImpl(this, true, OBJECT);\n    }\n\n    /**\n     * Returns the symbol factory associated with this type system.\n     * This is internal API, symbols are low-level abstractions that\n     * should not be created manually.\n     */\n    @InternalApi\n    public SymbolFactory symbols() {\n        return symbolFactory;\n    }\n\n    /**\n     * Returns the bootstrap symbol resolver. Concrete analysis passes\n     * may decorate this with different resolvers.\n     */\n    public SymbolResolver bootstrapResolver() {\n        return resolver;\n    }\n\n    // helpers for the constructor, cannot use typeOf, only for trusted types\n\n    private JClassType addSpecial(Class<?> klass, Map<JClassSymbol, JTypeMirror> shared) {\n        JClassSymbol sym = getBootStrapSymbol(klass);\n        JClassType nonErased = new ClassTypeImpl(this, sym, emptyList(), false);\n        shared.put(sym, nonErased);\n        return nonErased;\n    }\n\n    private JClassSymbol getBootStrapSymbol(Class<?> clazz) {\n        AssertionUtil.requireParamNotNull(\"clazz\", clazz);\n        JClassSymbol sym = resolver.resolveClassFromBinaryName(clazz.getName());\n        return Objects.requireNonNull(sym, \"sym\");\n    }\n\n    @NonNull\n    private JPrimitiveType createPrimitive(PrimitiveTypeKind kind, Class<?> box) {\n        return new JPrimitiveType(this, kind, new RealPrimitiveSymbol(this, kind), getBootStrapSymbol(box));\n    }\n\n\n    // type creation routines\n\n    /**\n     * Returns the class symbol for the given reflected class. This asks\n     * the classloader of this type system. Returns null if the parameter\n     * is null, or the class is not available in the analysis classpath.\n     *\n     * @param clazz Class\n     */\n    @Nullable\n    public JClassSymbol getClassSymbol(@Nullable Class<?> clazz) {\n        if (clazz == null) {\n            return null;\n        } else if (clazz.isPrimitive()) {\n            PrimitiveTypeKind kind = PrimitiveTypeKind.fromName(clazz.getName());\n            if (kind == null) { // void\n                return (JClassSymbol) NO_TYPE.getSymbol();\n            }\n            return getPrimitive(kind).getSymbol();\n        } else if (clazz.isArray()) {\n            return symbols().makeArraySymbol(getClassSymbol(clazz.getComponentType()));\n        }\n\n        return resolver.resolveClassFromBinaryName(clazz.getName());\n    }\n\n    /**\n     * Returns a symbol for the binary name. Returns null if the name is\n     * null or the symbol is not found on the classpath. The class must\n     * not be an array.\n     *\n     * @param binaryName Binary name\n     *\n     * @return A symbol, or null\n     *\n     * @throws IllegalArgumentException If the\n     */\n    public @Nullable JClassSymbol getClassSymbol(String binaryName) {\n        if (binaryName == null) {\n            return null;\n        }\n        if (\"void\".equals(binaryName)) {\n            return (JClassSymbol) NO_TYPE.getSymbol();\n        }\n        PrimitiveTypeKind kind = PrimitiveTypeKind.fromName(binaryName);\n        if (kind != null) { // void\n            return getPrimitive(kind).getSymbol();\n        }\n\n        if (!AssertionUtil.isValidJavaPackageName(binaryName)) {\n            throw new IllegalArgumentException(\"Not a binary name '\" + binaryName + \"'\");\n        }\n\n        return resolver.resolveClassFromBinaryName(binaryName);\n    }\n\n    /**\n     * Returns a type mirror for the given symbol. If the symbol declares\n     * type parameters, then the resulting type is raw (differs from the\n     * behaviour of {@link #declaration(JClassSymbol)}), meaning all its\n     * supertypes are erased.\n     *\n     * <p>If the symbol is a {@link JTypeParameterSymbol type parameter},\n     * returns a {@link JTypeVar}.\n     *\n     * <p>If the symbol is a {@link JClassSymbol}, then:\n     * <ul>\n     * <li>If it represents a primitive type, the corresponding {@link JPrimitiveType}\n     * is returned (one of {@link #INT}, {@link #CHAR}, etc.).\n     * <li>If it represents an array type, a new {@link JArrayType} is\n     * returned. Note that the component type will always be erased;\n     * creating a generic array type should instead be done with\n     * {@link #arrayType(JTypeMirror, int)}.\n     * <li>If it represents a class or interface type, a {@link JClassType}\n     * is returned.\n     * <ul>\n     *     <li>If the parameter {@code isErased} is true, and if the\n     *     symbol declares type parameters, then it will be a\n     *     {@linkplain JClassType#isRaw() raw type}. This means,\n     *     which means all its generic supertypes are {@linkplain JClassType#hasErasedSuperTypes() erased}.\n     *     <li>Otherwise, the generic supertypes are preserved. In particular,\n     *     if the symbol declares type parameters itself, then it will\n     *     be a {@linkplain JClassType#isGenericTypeDeclaration() generic type declaration}.\n     * </ul>\n     * If the symbol is a non-static member of another class, then the given\n     * type's {@linkplain JClassType#getEnclosingType() enclosing type} is\n     * created, applying the above rules about erasure recursively. A type\n     * is either completely erased, or completely parameterized.\n     * </li>\n     * </ul>\n     *\n     * @param symbol   Symbol for the type declaration\n     * @param isErased Whether the type should be consider erased, if it\n     *                 represents a class or interface type. This does not\n     *                 erase type variables, or array types for that matter.\n     *\n     * @throws NullPointerException if the symbol is null\n     */\n    public JTypeMirror typeOf(JTypeDeclSymbol symbol, boolean isErased) {\n        Objects.requireNonNull(symbol, \"Argument shouldn't be null\");\n\n        // takes care of primitives, and constants like OBJECT or UNRESOLVED_TYPE\n        JTypeMirror common = specialCache(symbol);\n        if (common != null) {\n            return common;\n        }\n\n        if (symbol instanceof JClassSymbol) {\n            JClassSymbol classSym = (JClassSymbol) symbol;\n            if (classSym.isArray()) {\n                // generic array types are represented by a special\n                // type in the j.l.reflect API, so the component is\n                // also raw\n                // fixme this is wrong:\n                //  var genArr = ts.array(tvar, 1);\n                //  ts.typeOf(genArr.symbol(), false) != genArr\n                JTypeMirror component = rawType(classSym.getArrayComponent());\n                return arrayType(component, 1);\n            } else {\n                return new ClassTypeImpl(this, classSym, emptyList(), !isErased);\n            }\n        } else if (symbol instanceof JTypeParameterSymbol) {\n            return ((JTypeParameterSymbol) symbol).getTypeMirror();\n        }\n        throw new AssertionError(\"Uncategorized type symbol \" + symbol.getClass() + \": \" + symbol);\n    }\n\n    // test only for now\n    JClassType forceErase(JClassType t) {\n        JClassType erasure = t.getErasure();\n        if (erasure == t) {\n            return new ErasedClassType(this, t.getSymbol());\n        }\n        return erasure;\n    }\n\n    /**\n     * Like {@link #typeOf(JTypeDeclSymbol, boolean)}, defaulting the\n     * erased parameter to true. If the symbol is not generic,\n     * the returned symbol is not actually raw.\n     *\n     * @param klass Symbol\n     *\n     * @return An erased class type\n     */\n    public JTypeMirror rawType(JTypeDeclSymbol klass) {\n        return typeOf(klass, true);\n    }\n\n    public JTypeMirror declaration(JClassSymbol klass) {\n        return typeOf(klass, false);\n    }\n\n\n    @NonNull\n    public JTypeMirror parameterise(JClassSymbol klass, List<? extends JTypeMirror> typeArgs) {\n        Objects.requireNonNull(klass, \"Null class symbol\");\n        Objects.requireNonNull(typeArgs, \"Null type arguments, use an empty list!\");\n\n        if (!klass.isUnresolved() && !typeArgs.isEmpty() && klass.getTypeParameterCount() != typeArgs.size()) {\n            throw new IllegalArgumentException(\"Cannot parameterize \" + klass + \" with \" + typeArgs);\n        } else if (typeArgs.isEmpty()) {\n            return rawType(klass);\n        }\n\n        // if the type arguments are mismatched, the constructor will throw\n        return new ClassTypeImpl(this, klass, new ArrayList<>(typeArgs), false);\n    }\n\n\n    /**\n     * Creates a new array type from an arbitrary element type.\n     *\n     * <pre>{@code\n     * arrayType(T, 0)          = T\n     * arrayType(T, 1)          = T[]\n     * arrayType(T, 3)          = T[][][]\n     * arrayType(T[], 2)        = T[][][]\n     * arrayType(ERROR_TYPE, _) = ERROR_TYPE\n     * }</pre>\n     *\n     * @param element       Element type\n     * @param numDimensions Number of dimensions\n     *\n     * @return A new array type\n     *\n     * @throws IllegalArgumentException If numDimensions is negative\n     * @throws IllegalArgumentException If the element type is a {@link JWildcardType},\n     *                                  the null type, or {@link #NO_TYPE void}.\n     * @throws NullPointerException     If the element type is null\n     */\n    public JTypeMirror arrayType(@NonNull JTypeMirror element, int numDimensions) {\n        AssertionUtil.requireNonNegative(\"numDimensions\", numDimensions);\n        AssertionUtil.requireParamNotNull(\"elementType\", element);\n\n        if (element instanceof JWildcardType\n            || element == NULL_TYPE\n            || element == NO_TYPE) {\n            throw new IllegalArgumentException(\"The type < \" + element + \" > is not a valid array element type \");\n        }\n\n        if (numDimensions == 0 || element == ERROR_TYPE) {\n            return element;\n        }\n\n        JArrayType res = new ArrayTypeImpl(this, element);\n        while (--numDimensions > 0) {\n            res = new ArrayTypeImpl(this, res);\n        }\n        return res;\n    }\n\n    public JMethodSig sigOf(JExecutableSymbol methodSym) {\n        return sigOf(methodSym, Substitution.EMPTY);\n    }\n\n    public JMethodSig sigOf(JExecutableSymbol methodSym, Substitution subst) {\n        JClassType klass = (JClassType) declaration(methodSym.getEnclosingClass());\n        return new ClassMethodSigImpl(klass.subst(subst), methodSym);\n    }\n\n    public JVariableSig sigOf(JTypeMirror decl, JFieldSymbol fieldSym) {\n        return JVariableSig.forField(decl, fieldSym);\n    }\n\n    public JVariableSig sigOf(JClassType decl, JLocalVariableSymbol fieldSym) {\n        return JVariableSig.forLocal(decl, fieldSym);\n    }\n\n    public JVariableSig sigOf(JClassType decl, JFormalParamSymbol fieldSym) {\n        return JVariableSig.forLocal(decl, fieldSym);\n    }\n\n    /**\n     * Builds an intersection type for the specified component types.\n     * This does not necessarily return a {@link JIntersectionType}.\n     *\n     * @param types Types to intersect\n     *\n     * @return An intersection type\n     *\n     * @throws NullPointerException     If the collection is null\n     * @throws IllegalArgumentException If the collection is empty\n     */\n    public JTypeMirror intersect(Collection<? extends JTypeMirror> types) {\n        if (types.isEmpty()) {\n            throw new IllegalArgumentException(\"Cannot intersect zero types\");\n        } else if (types.size() == 1) {\n            return types.iterator().next();\n        }\n        return new IntersectionTypeImpl(this, new ArrayList<>(types));\n    }\n\n\n    /**\n     * Builds a wildcard type with a single bound.\n     *\n     * <pre>{@code\n     *\n     * wildcard(true, T)      = ? extends T\n     * wildcard(false, T)     = ? super T\n     * wildcard(true, OBJECT) = ?\n     * wildcard(_, ERROR_TYPE) = ERROR_TYPE\n     *\n     * }</pre>\n     *\n     * @param isUpperBound If true, this is an \"extends\" wildcard, otherwise a \"super\"\n     * @param bound        Bound of the wildcard\n     *\n     * @return A wildcard\n     *\n     * @throws NullPointerException     If the bound is null\n     * @throws IllegalArgumentException If the bound is a primitive type,\n     *                                  or a wildcard type\n     * @throws IllegalArgumentException If the bound is OBJECT and this\n     *                                  is a lower-bounded wildcard (? super Object)\n     */\n    public JTypeMirror wildcard(boolean isUpperBound, @NonNull JTypeMirror bound) {\n        Objects.requireNonNull(bound, \"Argument shouldn't be null\");\n        if (bound == ERROR_TYPE) {\n            return bound;\n        }\n        if (bound.isPrimitive() || bound instanceof JWildcardType) {\n            throw new IllegalArgumentException(\"<\" + bound + \"> cannot be a wildcard bound\");\n        }\n        return isUpperBound && bound == OBJECT ? UNBOUNDED_WILD\n                                               : new WildcardTypeImpl(this, isUpperBound, bound);\n    }\n\n    /**\n     * Maps a type decl symbol to its shared representation. Eg this\n     * maps the symbol for {@code int.class} to {@link #INT}. Only\n     * non-generic types are cached.\n     */\n    private @Nullable JTypeMirror specialCache(JTypeDeclSymbol raw) {\n        return sharedTypes.get(raw);\n    }\n\n\n    /**\n     * Gets the primitive type identified by the given kind.\n     *\n     * @param kind Kind of primitive type\n     *\n     * @return A primitive type\n     *\n     * @throws NullPointerException if kind is null\n     */\n    public @NonNull JPrimitiveType getPrimitive(@NonNull PrimitiveTypeKind kind) {\n        AssertionUtil.requireParamNotNull(\"kind\", kind);\n        return primitivesByKind.get(kind);\n    }\n\n    /**\n     * The least upper bound, or \"lub\", of a set of reference types is\n     * a shared supertype that is more specific than any other shared\n     * supertype (that is, no other shared supertype is a subtype of the\n     * least upper bound).\n     *\n     * @throws IllegalArgumentException If types is empty\n     * @throws NullPointerException     If types is null\n     */\n    public JTypeMirror lub(Collection<? extends JTypeMirror> types) {\n        return Lub.lub(this, types);\n    }\n\n    /**\n     * Returns the greatest lower bound of the given set of types.\n     * This is defined in JLS\u00a75.1.10 (Capture Conversion):\n     *\n     * <blockquote>\n     * glb(V1,...,Vm) = V1 &amp; ... &amp; Vm\n     * glb(V) = V\n     * </blockquote>\n     *\n     * @throws IllegalArgumentException If some component is not a class, array, or wildcard type\n     * @throws IllegalArgumentException If there is more than one minimal class or array type\n     * @throws IllegalArgumentException If types is empty\n     * @throws NullPointerException     If types is null\n     */\n    public JTypeMirror glb(Collection<? extends JTypeMirror> types) {\n        if (types.isEmpty()) {\n            throw new IllegalArgumentException(\"Cannot compute GLB of empty set\");\n        }\n\n\n        ArrayList<JTypeMirror> list = new ArrayList<>(types.size());\n\n        for (JTypeMirror type : types) {\n            // flatten intersections: (A & (B & C)) => (A & B & C)\n            if (type instanceof JIntersectionType) {\n                list.addAll(((JIntersectionType) type).getComponents());\n            } else {\n                list.add(type);\n            }\n        }\n\n\n        JTypeMirror ck = OBJECT; // Ck is a class type\n\n        for (ListIterator<JTypeMirror> iterator = list.listIterator(); iterator.hasNext();) {\n            JTypeMirror ci = iterator.next();\n\n            if (ci.isPrimitive() || ci instanceof JWildcardType || ci instanceof JIntersectionType) {\n                throw new IllegalArgumentException(\"Bad intersection type component: \" + ci + \" in \" + types);\n            }\n\n            if (!isPossiblyAnInterface(ci)) {\n                // either Ci is an array, or Ci is a class\n                // Ci is not unresolved\n\n                if (ci.isSubtypeOf(ck)) {\n                    ck = ci; // Ci is more specific than Ck\n                    iterator.remove(); // remove bound\n                } else if (ck.isSubtypeOf(ci)) {\n                    // then our Ck is already more specific than Ci\n                    iterator.remove();\n                } else {\n                    throw new IllegalArgumentException(\n                        \"Bad intersection, unrelated class types \" + ci + \" and \" + ck + \" in \" + types);\n                }\n            } else if (!(ci instanceof JInferenceVar) && ck.isSubtypeOf(ci)) {\n                // then our Ck is already more specific than Ci\n                iterator.remove();\n            }\n        }\n\n        if (list.isEmpty()) {\n            return ck;\n        }\n\n        if (ck != OBJECT) {\n            // readd ck as first component\n            list.add(0, ck);\n        }\n\n        if (list.size() == 1) {\n            return list.get(0);\n        }\n\n        if (ck instanceof JTypeVar) {\n            return new IntersectionTypeImpl(this, list);\n        }\n\n        // We assume there cannot be an array type here. Why?\n        // In well-formed java programs an array type in a GLB can only occur in the following situation\n        //\n        // class C<T extends B1 & .. & Bn>      // nota: the Bi cannot be array types\n        //\n        // Somewhere: C<? extends Arr[]>\n\n        // And capture would merge the bounds of the wildcard and of the tvar\n        // into Arr[] & B1 & .. & Bn\n        // Now the C<? ...> would only typecheck if Arr[] <: Bi forall i\n        // (Note that this means, that Bi in { Serializable, Cloneable, Object })\n\n        // This means, that the loop above would find Ck = Arr[], and delete all Bi, since Ck <: Bi\n        // So in the end, we would return Arr[] alone, not create an intersection\n        // TODO this is order dependent: Arr[] & Serializable is ok, but Serializable & Arr[] is not\n        //   Possibly use TypeOps::mostSpecific to merge them\n        assert ck instanceof JClassType : \"Weird intersection involving multiple array types? \" + list;\n\n        return new IntersectionTypeImpl.MinimalIntersection(this, (JClassType) ck, list);\n    }\n\n\n    private boolean isPossiblyAnInterface(JTypeMirror ci) {\n        return ci.isInterface()\n            || ci instanceof JInferenceVar\n            || ci.getSymbol() != null && ci.getSymbol().isUnresolved();\n    }\n\n    // package-private\n    JClassType erasedType(JClassSymbol symbol) {\n        JTypeMirror t = specialCache(symbol);\n        if (t != null) {\n            return (JClassType) t.getErasure();\n        } else {\n            return new ErasedClassType(this, symbol);\n        }\n    }\n\n\n    /**\n     * Returns a new type variable for the given symbol. This is only\n     * intended to be used by the implementor of {@link JTypeParameterSymbol}.\n     */\n    public JTypeVar.FreshTypeVar newTypeVar(JTypeParameterSymbol symbol) {\n        return new TypeVarImpl(this, symbol);\n    }\n\n    private static final class NullType implements JTypeMirror {\n        private final TypeSystem ts;\n\n        NullType(TypeSystem ts) {\n            this.ts = ts;\n        }\n\n        @Override\n        public JTypeMirror subst(Function<? super SubstVar, ? extends @NonNull JTypeMirror> subst) {\n            return this;\n        }\n\n        @Override\n        public TypeSystem getTypeSystem() {\n            return ts;\n        }\n\n        @Override\n        public @Nullable JClassSymbol getSymbol() {\n            return null;\n        }\n\n        @Override\n        public <T, P> T acceptVisitor(JTypeVisitor<T, P> visitor, P p) {\n            return visitor.visitNullType(this, p);\n        }\n\n        @Override\n        public String toString() {\n            return \"null\";\n        }\n    }\n}\n",
        "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeSystem.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.types;\n\nimport static java.util.Collections.emptyList;\nimport static net.sourceforge.pmd.util.CollectionUtil.immutableSetOf;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.EnumMap;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.function.Function;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.internal.util.AssertionUtil;\nimport net.sourceforge.pmd.lang.java.symbols.JClassSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JExecutableSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JFieldSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JFormalParamSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JLocalVariableSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JTypeDeclSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JTypeParameterSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.SymbolResolver;\nimport net.sourceforge.pmd.lang.java.symbols.internal.SymbolFactory;\nimport net.sourceforge.pmd.lang.java.symbols.internal.asm.AsmSymbolResolver;\nimport net.sourceforge.pmd.lang.java.types.BasePrimitiveSymbol.RealPrimitiveSymbol;\nimport net.sourceforge.pmd.lang.java.types.BasePrimitiveSymbol.VoidSymbol;\nimport net.sourceforge.pmd.lang.java.types.JPrimitiveType.PrimitiveTypeKind;\nimport net.sourceforge.pmd.lang.java.types.internal.infer.JInferenceVar;\n\n/**\n * Root context object for type analysis. Type systems own a {@link SymbolFactory},\n * which creates and caches symbols. Methods of this class promote symbols\n * to types, and compose types together. {@link TypeOps} and {@link TypeConversion}\n * have some more operations on types.\n *\n * <p>Some special types are presented as constant fields, eg {@link #OBJECT}\n * or {@link #NULL_TYPE}. These are always comparable by reference.\n *\n * <p>The lifetime of a type system is the analysis: it is shared by\n * all compilation units.\n * TODO this is hacked together by comparing the ClassLoader, but this\n *  should be in the language instance\n *\n */\n@SuppressWarnings(\"PMD.CompareObjectsWithEquals\")\npublic final class TypeSystem {\n\n    /** Top type of the reference type system. */\n    public final JClassType OBJECT;\n\n    /**\n     * The bottom type of the reference type system. This is named\n     * the <i>null type</i> in the JLS and is not denotable in Java\n     * programs.\n     *\n     * <p>This implementation uses this as the type of the 'null' literal.\n     */\n    public final JTypeMirror NULL_TYPE = new NullType(this);\n\n\n    // primitives\n    public final JPrimitiveType BOOLEAN;\n    public final JPrimitiveType CHAR;\n    public final JPrimitiveType BYTE;\n    public final JPrimitiveType SHORT;\n    public final JPrimitiveType INT;\n    public final JPrimitiveType LONG;\n    public final JPrimitiveType FLOAT;\n    public final JPrimitiveType DOUBLE;\n\n    /**\n     * The set of all primitive types. See {@link #getPrimitive(PrimitiveTypeKind)}.\n     */\n    public final Set<JPrimitiveType> allPrimitives;\n    private final EnumMap<PrimitiveTypeKind, JPrimitiveType> primitivesByKind;\n\n    /**\n     * A constant to represent the normal absence of a type. The\n     * primitive {@code void.class} represents that type, and this\n     * is the return type of a void method.\n     *\n     * <p>Note that the type of the class literal {@code void.class}\n     * is {@code Class<java.lang.Void>}, not NO_TYPE.\n     */\n    public final JTypeMirror NO_TYPE;\n\n    /**\n     * A constant to represent an unresolved type. This means, that resolution\n     * was attempted but failed and shouldn't be tried again.\n     */\n    public final JTypeMirror UNRESOLVED_TYPE;\n\n    /**\n     * Sentinel value for an unresolved method. This type corresponds to\n     * a method declaration in the type {@link #UNRESOLVED_TYPE},\n     * returning {@link #UNRESOLVED_TYPE}.\n     */\n    // TODO it doesn't need to be declared in UNRESOLVED_TYPE\n    public final JMethodSig UNRESOLVED_METHOD = new UnresolvedMethodSig(this);\n\n    /**\n     * A constant to represent a typing error. This would have been\n     * reported by a compiler.\n     */\n    public final JTypeMirror ERROR_TYPE;\n\n    /*\n     * Common, non-special types.\n     */\n\n    /** The unbounded wildcard, \"?\". */\n    public final JWildcardType UNBOUNDED_WILD;\n\n    // array supertypes\n    public final JClassType CLONEABLE;\n    public final JClassType SERIALIZABLE;\n\n    /**\n     * This is the boxed type of {@code Void.class}, not to be confused with\n     * {@code void.class}, which in this framework is represented by\n     * {@link #NO_TYPE}.\n     */\n    public final JClassType BOXED_VOID;\n\n\n    private final SymbolFactory symbolFactory;\n\n    /** Contains special types, that must be shared to be comparable by reference. */\n    private final Map<JTypeDeclSymbol, JTypeMirror> sharedTypes;\n    // test only\n    final AsmSymbolResolver resolver;\n\n    /**\n     * Builds a new type system. Its public fields will be initialized\n     * with fresh types, unrelated to other types.\n     *\n     * @param bootstrapResourceLoader Classloader used to resolve class files\n     *                                to populate the fields of the new type\n     *                                system\n     */\n    public TypeSystem(ClassLoader bootstrapResourceLoader) {\n        this.resolver = new AsmSymbolResolver(this, bootstrapResourceLoader);\n        this.symbolFactory = new SymbolFactory(this);\n\n        // initialize primitives. their constructor also initializes their box + box erasure\n\n        BOOLEAN = createPrimitive(PrimitiveTypeKind.BOOLEAN, Boolean.class);\n        CHAR = createPrimitive(PrimitiveTypeKind.CHAR, Character.class);\n        BYTE = createPrimitive(PrimitiveTypeKind.BYTE, Byte.class);\n        SHORT = createPrimitive(PrimitiveTypeKind.SHORT, Short.class);\n        INT = createPrimitive(PrimitiveTypeKind.INT, Integer.class);\n        LONG = createPrimitive(PrimitiveTypeKind.LONG, Long.class);\n        FLOAT = createPrimitive(PrimitiveTypeKind.FLOAT, Float.class);\n        DOUBLE = createPrimitive(PrimitiveTypeKind.DOUBLE, Double.class);\n\n        // this relies on the fact that setOf always returns immutable sets\n        BOOLEAN.superTypes = immutableSetOf(BOOLEAN);\n        CHAR.superTypes = immutableSetOf(CHAR, INT, LONG, FLOAT, DOUBLE);\n        BYTE.superTypes = immutableSetOf(BYTE, SHORT, INT, LONG, FLOAT, DOUBLE);\n        SHORT.superTypes = immutableSetOf(SHORT, INT, LONG, FLOAT, DOUBLE);\n        INT.superTypes = immutableSetOf(INT, LONG, FLOAT, DOUBLE);\n        LONG.superTypes = immutableSetOf(LONG, FLOAT, DOUBLE);\n        FLOAT.superTypes = immutableSetOf(FLOAT, DOUBLE);\n        DOUBLE.superTypes = immutableSetOf(DOUBLE);\n\n        this.allPrimitives = immutableSetOf(BOOLEAN, CHAR, BYTE, SHORT, INT, LONG, FLOAT, DOUBLE);\n        this.primitivesByKind = new EnumMap<>(PrimitiveTypeKind.class);\n        primitivesByKind.put(PrimitiveTypeKind.BOOLEAN, BOOLEAN);\n        primitivesByKind.put(PrimitiveTypeKind.CHAR, CHAR);\n        primitivesByKind.put(PrimitiveTypeKind.BYTE, BYTE);\n        primitivesByKind.put(PrimitiveTypeKind.SHORT, SHORT);\n        primitivesByKind.put(PrimitiveTypeKind.INT, INT);\n        primitivesByKind.put(PrimitiveTypeKind.LONG, LONG);\n        primitivesByKind.put(PrimitiveTypeKind.FLOAT, FLOAT);\n        primitivesByKind.put(PrimitiveTypeKind.DOUBLE, DOUBLE);\n\n        JClassSymbol unresolvedTypeSym = symbolFactory.makeUnresolvedReference(\"/*unresolved*/\", 0);\n        UNRESOLVED_TYPE = new SentinelType(this, \"/*unresolved*/\", unresolvedTypeSym);\n\n        JClassSymbol errorTypeSym = symbolFactory.makeUnresolvedReference(\"/*error*/\", 0);\n        ERROR_TYPE = new SentinelType(this, \"/*error*/\", errorTypeSym);\n\n        JClassSymbol primitiveVoidSym = new VoidSymbol(this);\n        NO_TYPE = new SentinelType(this, \"void\", primitiveVoidSym);\n\n        // reuse instances for common types\n\n        // this map is vital to preserve some of the invariants of\n        // the framework, e.g., that primitive types are never represented\n        // by a ClassType, or that OBJECT is unique\n\n        // this is only appropriate for non-generic types\n\n        Map<JClassSymbol, JTypeMirror> shared = new HashMap<>();\n\n        OBJECT = addSpecial(Object.class, shared);\n        SERIALIZABLE = addSpecial(Serializable.class, shared);\n        CLONEABLE = addSpecial(Cloneable.class, shared);\n        BOXED_VOID = addSpecial(Void.class, shared);\n\n        shared.put(primitiveVoidSym, NO_TYPE);\n        shared.put(unresolvedTypeSym, UNRESOLVED_TYPE);\n        shared.put(errorTypeSym, ERROR_TYPE);\n\n        for (JPrimitiveType prim : allPrimitives) {\n            // primitives have a special implementation for their box\n            shared.put(prim.getSymbol(), prim);\n            shared.put(prim.box().getSymbol(), prim.box());\n        }\n\n        // make it really untouchable\n        this.sharedTypes = Collections.unmodifiableMap(new HashMap<>(shared));\n\n        UNBOUNDED_WILD = new WildcardTypeImpl(this, true, OBJECT);\n    }\n\n    /**\n     * Returns the symbol factory associated with this type system.\n     * This is internal API, symbols are low-level abstractions that\n     * should not be created manually.\n     */\n    @InternalApi\n    public SymbolFactory symbols() {\n        return symbolFactory;\n    }\n\n    /**\n     * Returns the bootstrap symbol resolver. Concrete analysis passes\n     * may decorate this with different resolvers.\n     */\n    public SymbolResolver bootstrapResolver() {\n        return resolver;\n    }\n\n    // helpers for the constructor, cannot use typeOf, only for trusted types\n\n    private JClassType addSpecial(Class<?> klass, Map<JClassSymbol, JTypeMirror> shared) {\n        JClassSymbol sym = getBootStrapSymbol(klass);\n        JClassType nonErased = new ClassTypeImpl(this, sym, emptyList(), false);\n        shared.put(sym, nonErased);\n        return nonErased;\n    }\n\n    private JClassSymbol getBootStrapSymbol(Class<?> clazz) {\n        AssertionUtil.requireParamNotNull(\"clazz\", clazz);\n        JClassSymbol sym = resolver.resolveClassFromBinaryName(clazz.getName());\n        return Objects.requireNonNull(sym, \"sym\");\n    }\n\n    @NonNull\n    private JPrimitiveType createPrimitive(PrimitiveTypeKind kind, Class<?> box) {\n        return new JPrimitiveType(this, kind, new RealPrimitiveSymbol(this, kind), getBootStrapSymbol(box));\n    }\n\n\n    // type creation routines\n\n    /**\n     * Returns the class symbol for the given reflected class. This asks\n     * the classloader of this type system. Returns null if the parameter\n     * is null, or the class is not available in the analysis classpath.\n     *\n     * @param clazz Class\n     */\n    @Nullable\n    public JClassSymbol getClassSymbol(@Nullable Class<?> clazz) {\n        if (clazz == null) {\n            return null;\n        } else if (clazz.isPrimitive()) {\n            PrimitiveTypeKind kind = PrimitiveTypeKind.fromName(clazz.getName());\n            if (kind == null) { // void\n                return (JClassSymbol) NO_TYPE.getSymbol();\n            }\n            return getPrimitive(kind).getSymbol();\n        } else if (clazz.isArray()) {\n            return symbols().makeArraySymbol(getClassSymbol(clazz.getComponentType()));\n        }\n\n        return resolver.resolveClassFromBinaryName(clazz.getName());\n    }\n\n    /**\n     * Returns a symbol for the binary name. Returns null if the name is\n     * null or the symbol is not found on the classpath. The class must\n     * not be an array.\n     *\n     * @param binaryName Binary name\n     *\n     * @return A symbol, or null\n     *\n     * @throws IllegalArgumentException If the\n     */\n    public @Nullable JClassSymbol getClassSymbol(String binaryName) {\n        if (binaryName == null) {\n            return null;\n        }\n        if (\"void\".equals(binaryName)) {\n            return (JClassSymbol) NO_TYPE.getSymbol();\n        }\n        PrimitiveTypeKind kind = PrimitiveTypeKind.fromName(binaryName);\n        if (kind != null) { // void\n            return getPrimitive(kind).getSymbol();\n        }\n\n        if (!AssertionUtil.isValidJavaPackageName(binaryName)) {\n            throw new IllegalArgumentException(\"Not a binary name '\" + binaryName + \"'\");\n        }\n\n        return resolver.resolveClassFromBinaryName(binaryName);\n    }\n\n    /**\n     * Returns a type mirror for the given symbol. If the symbol declares\n     * type parameters, then the resulting type is raw (differs from the\n     * behaviour of {@link #declaration(JClassSymbol)}), meaning all its\n     * supertypes are erased.\n     *\n     * <p>If the symbol is a {@link JTypeParameterSymbol type parameter},\n     * returns a {@link JTypeVar}.\n     *\n     * <p>If the symbol is a {@link JClassSymbol}, then:\n     * <ul>\n     * <li>If it represents a primitive type, the corresponding {@link JPrimitiveType}\n     * is returned (one of {@link #INT}, {@link #CHAR}, etc.).\n     * <li>If it represents an array type, a new {@link JArrayType} is\n     * returned. Note that the component type will always be erased;\n     * creating a generic array type should instead be done with\n     * {@link #arrayType(JTypeMirror, int)}.\n     * <li>If it represents a class or interface type, a {@link JClassType}\n     * is returned.\n     * <ul>\n     *     <li>If the parameter {@code isErased} is true, and if the\n     *     symbol declares type parameters, then it will be a\n     *     {@linkplain JClassType#isRaw() raw type}. This means,\n     *     which means all its generic supertypes are {@linkplain JClassType#hasErasedSuperTypes() erased}.\n     *     <li>Otherwise, the generic supertypes are preserved. In particular,\n     *     if the symbol declares type parameters itself, then it will\n     *     be a {@linkplain JClassType#isGenericTypeDeclaration() generic type declaration}.\n     * </ul>\n     * If the symbol is a non-static member of another class, then the given\n     * type's {@linkplain JClassType#getEnclosingType() enclosing type} is\n     * created, applying the above rules about erasure recursively. A type\n     * is either completely erased, or completely parameterized.\n     * </li>\n     * </ul>\n     *\n     * @param symbol   Symbol for the type declaration\n     * @param isErased Whether the type should be consider erased, if it\n     *                 represents a class or interface type. This does not\n     *                 erase type variables, or array types for that matter.\n     *\n     * @throws NullPointerException if the symbol is null\n     */\n    public JTypeMirror typeOf(JTypeDeclSymbol symbol, boolean isErased) {\n        Objects.requireNonNull(symbol, \"Argument shouldn't be null\");\n\n        // takes care of primitives, and constants like OBJECT or UNRESOLVED_TYPE\n        JTypeMirror common = specialCache(symbol);\n        if (common != null) {\n            return common;\n        }\n\n        if (symbol instanceof JClassSymbol) {\n            JClassSymbol classSym = (JClassSymbol) symbol;\n            if (classSym.isArray()) {\n                // generic array types are represented by a special\n                // type in the j.l.reflect API, so the component is\n                // also raw\n                // fixme this is wrong:\n                //  var genArr = ts.array(tvar, 1);\n                //  ts.typeOf(genArr.symbol(), false) != genArr\n                JTypeMirror component = rawType(classSym.getArrayComponent());\n                return arrayType(component);\n            } else {\n                return new ClassTypeImpl(this, classSym, emptyList(), !isErased);\n            }\n        } else if (symbol instanceof JTypeParameterSymbol) {\n            return ((JTypeParameterSymbol) symbol).getTypeMirror();\n        }\n        throw new AssertionError(\"Uncategorized type symbol \" + symbol.getClass() + \": \" + symbol);\n    }\n\n    // test only for now\n    JClassType forceErase(JClassType t) {\n        JClassType erasure = t.getErasure();\n        if (erasure == t) {\n            return new ErasedClassType(this, t.getSymbol());\n        }\n        return erasure;\n    }\n\n    /**\n     * Like {@link #typeOf(JTypeDeclSymbol, boolean)}, defaulting the\n     * erased parameter to true. If the symbol is not generic,\n     * the returned symbol is not actually raw.\n     *\n     * @param klass Symbol\n     *\n     * @return An erased class type\n     */\n    public JTypeMirror rawType(JTypeDeclSymbol klass) {\n        return typeOf(klass, true);\n    }\n\n    public JTypeMirror declaration(JClassSymbol klass) {\n        return typeOf(klass, false);\n    }\n\n\n    @NonNull\n    public JTypeMirror parameterise(JClassSymbol klass, List<? extends JTypeMirror> typeArgs) {\n        Objects.requireNonNull(klass, \"Null class symbol\");\n        Objects.requireNonNull(typeArgs, \"Null type arguments, use an empty list!\");\n\n        if (!klass.isUnresolved() && !typeArgs.isEmpty() && klass.getTypeParameterCount() != typeArgs.size()) {\n            throw new IllegalArgumentException(\"Cannot parameterize \" + klass + \" with \" + typeArgs);\n        } else if (typeArgs.isEmpty()) {\n            return rawType(klass);\n        }\n\n        // if the type arguments are mismatched, the constructor will throw\n        return new ClassTypeImpl(this, klass, new ArrayList<>(typeArgs), false);\n    }\n\n\n    /**\n     * Creates a new array type from an arbitrary element type.\n     *\n     * <pre>{@code\n     * arrayType(T, 0)          = T\n     * arrayType(T, 1)          = T[]\n     * arrayType(T, 3)          = T[][][]\n     * arrayType(T[], 2)        = T[][][]\n     * }</pre>\n     *\n     * @param element       Element type\n     * @param numDimensions Number of dimensions\n     *\n     * @return A new array type\n     *\n     * @throws IllegalArgumentException If numDimensions is negative\n     * @throws IllegalArgumentException If the element type is a {@link JWildcardType},\n     *                                  the null type, or {@link #NO_TYPE void}.\n     * @throws NullPointerException     If the element type is null\n     */\n    public JTypeMirror arrayType(@NonNull JTypeMirror element, int numDimensions) {\n        AssertionUtil.requireNonNegative(\"numDimensions\", numDimensions);\n        checkArrayElement(element); // note we throw even if numDimensions == 0\n\n        if (numDimensions == 0) {\n            return element;\n        }\n\n        JArrayType res = new ArrayTypeImpl(this, element);\n        while (--numDimensions > 0) {\n            res = new ArrayTypeImpl(this, res);\n        }\n        return res;\n    }\n\n    /**\n     * Like {@link #arrayType(JTypeMirror, int)}, with one dimension.\n     *\n     * @param component Component type\n     *\n     * @return An array type\n     *\n     * @throws IllegalArgumentException If the element type is a {@link JWildcardType},\n     *                                  the null type, or {@link #NO_TYPE void}.\n     * @throws NullPointerException     If the element type is null\n     */\n    public JArrayType arrayType(@NonNull JTypeMirror component) {\n        checkArrayElement(component);\n        return new ArrayTypeImpl(this, component);\n    }\n\n\n    private void checkArrayElement(@NonNull JTypeMirror element) {\n        AssertionUtil.requireParamNotNull(\"elementType\", element);\n\n        if (element instanceof JWildcardType\n            || element == NULL_TYPE\n            || element == NO_TYPE) {\n            throw new IllegalArgumentException(\"The type < \" + element + \" > is not a valid array element type\");\n        }\n    }\n\n    public JMethodSig sigOf(JExecutableSymbol methodSym) {\n        return sigOf(methodSym, Substitution.EMPTY);\n    }\n\n    public JMethodSig sigOf(JExecutableSymbol methodSym, Substitution subst) {\n        JClassType klass = (JClassType) declaration(methodSym.getEnclosingClass());\n        return new ClassMethodSigImpl(klass.subst(subst), methodSym);\n    }\n\n    public JVariableSig sigOf(JTypeMirror decl, JFieldSymbol fieldSym) {\n        return JVariableSig.forField(decl, fieldSym);\n    }\n\n    public JVariableSig sigOf(JClassType decl, JLocalVariableSymbol fieldSym) {\n        return JVariableSig.forLocal(decl, fieldSym);\n    }\n\n    public JVariableSig sigOf(JClassType decl, JFormalParamSymbol fieldSym) {\n        return JVariableSig.forLocal(decl, fieldSym);\n    }\n\n    /**\n     * Builds an intersection type for the specified component types.\n     * This does not necessarily return a {@link JIntersectionType}.\n     *\n     * @param types Types to intersect\n     *\n     * @return An intersection type\n     *\n     * @throws NullPointerException     If the collection is null\n     * @throws IllegalArgumentException If the collection is empty\n     */\n    public JTypeMirror intersect(Collection<? extends JTypeMirror> types) {\n        if (types.isEmpty()) {\n            throw new IllegalArgumentException(\"Cannot intersect zero types\");\n        } else if (types.size() == 1) {\n            return types.iterator().next();\n        }\n        return new IntersectionTypeImpl(this, new ArrayList<>(types));\n    }\n\n\n    /**\n     * Builds a wildcard type with a single bound.\n     *\n     * <pre>{@code\n     *\n     * wildcard(true, T)      = ? extends T\n     * wildcard(false, T)     = ? super T\n     * wildcard(true, OBJECT) = ?\n     *\n     * }</pre>\n     *\n     * @param isUpperBound If true, this is an \"extends\" wildcard, otherwise a \"super\"\n     * @param bound        Bound of the wildcard\n     *\n     * @return A wildcard\n     *\n     * @throws NullPointerException     If the bound is null\n     * @throws IllegalArgumentException If the bound is a primitive type,\n     *                                  or a wildcard type\n     * @throws IllegalArgumentException If the bound is OBJECT and this\n     *                                  is a lower-bounded wildcard (? super Object)\n     */\n    public JTypeMirror wildcard(boolean isUpperBound, @NonNull JTypeMirror bound) {\n        Objects.requireNonNull(bound, \"Argument shouldn't be null\");\n        if (bound.isPrimitive() || bound instanceof JWildcardType) {\n            throw new IllegalArgumentException(\"<\" + bound + \"> cannot be a wildcard bound\");\n        }\n        return isUpperBound && bound == OBJECT ? UNBOUNDED_WILD\n                                               : new WildcardTypeImpl(this, isUpperBound, bound);\n    }\n\n    /**\n     * Maps a type decl symbol to its shared representation. Eg this\n     * maps the symbol for {@code int.class} to {@link #INT}. Only\n     * non-generic types are cached.\n     */\n    private @Nullable JTypeMirror specialCache(JTypeDeclSymbol raw) {\n        return sharedTypes.get(raw);\n    }\n\n\n    /**\n     * Gets the primitive type identified by the given kind.\n     *\n     * @param kind Kind of primitive type\n     *\n     * @return A primitive type\n     *\n     * @throws NullPointerException if kind is null\n     */\n    public @NonNull JPrimitiveType getPrimitive(@NonNull PrimitiveTypeKind kind) {\n        AssertionUtil.requireParamNotNull(\"kind\", kind);\n        return primitivesByKind.get(kind);\n    }\n\n    /**\n     * The least upper bound, or \"lub\", of a set of reference types is\n     * a shared supertype that is more specific than any other shared\n     * supertype (that is, no other shared supertype is a subtype of the\n     * least upper bound).\n     *\n     * @throws IllegalArgumentException If types is empty\n     * @throws NullPointerException     If types is null\n     */\n    public JTypeMirror lub(Collection<? extends JTypeMirror> types) {\n        return Lub.lub(this, types);\n    }\n\n    /**\n     * Returns the greatest lower bound of the given set of types.\n     * This is defined in JLS\u00a75.1.10 (Capture Conversion):\n     *\n     * <blockquote>\n     * glb(V1,...,Vm) = V1 &amp; ... &amp; Vm\n     * glb(V) = V\n     * </blockquote>\n     *\n     * @throws IllegalArgumentException If some component is not a class, array, or wildcard type\n     * @throws IllegalArgumentException If there is more than one minimal class or array type\n     * @throws IllegalArgumentException If types is empty\n     * @throws NullPointerException     If types is null\n     */\n    public JTypeMirror glb(Collection<? extends JTypeMirror> types) {\n        if (types.isEmpty()) {\n            throw new IllegalArgumentException(\"Cannot compute GLB of empty set\");\n        }\n\n\n        ArrayList<JTypeMirror> list = new ArrayList<>(types.size());\n\n        for (JTypeMirror type : types) {\n            // flatten intersections: (A & (B & C)) => (A & B & C)\n            if (type instanceof JIntersectionType) {\n                list.addAll(((JIntersectionType) type).getComponents());\n            } else {\n                list.add(type);\n            }\n        }\n\n\n        JTypeMirror ck = OBJECT; // Ck is a class type\n\n        for (ListIterator<JTypeMirror> iterator = list.listIterator(); iterator.hasNext();) {\n            JTypeMirror ci = iterator.next();\n\n            if (ci.isPrimitive() || ci instanceof JWildcardType || ci instanceof JIntersectionType) {\n                throw new IllegalArgumentException(\"Bad intersection type component: \" + ci + \" in \" + types);\n            }\n\n            if (!isPossiblyAnInterface(ci)) {\n                // either Ci is an array, or Ci is a class\n                // Ci is not unresolved\n\n                if (ci.isSubtypeOf(ck)) {\n                    ck = ci; // Ci is more specific than Ck\n                    iterator.remove(); // remove bound\n                } else if (ck.isSubtypeOf(ci)) {\n                    // then our Ck is already more specific than Ci\n                    iterator.remove();\n                } else {\n                    throw new IllegalArgumentException(\n                        \"Bad intersection, unrelated class types \" + ci + \" and \" + ck + \" in \" + types);\n                }\n            } else if (!(ci instanceof JInferenceVar) && ck.isSubtypeOf(ci)) {\n                // then our Ck is already more specific than Ci\n                iterator.remove();\n            }\n        }\n\n        if (list.isEmpty()) {\n            return ck;\n        }\n\n        if (ck != OBJECT) {\n            // readd ck as first component\n            list.add(0, ck);\n        }\n\n        if (list.size() == 1) {\n            return list.get(0);\n        }\n\n        if (ck instanceof JTypeVar) {\n            return new IntersectionTypeImpl(this, list);\n        }\n\n        // We assume there cannot be an array type here. Why?\n        // In well-formed java programs an array type in a GLB can only occur in the following situation\n        //\n        // class C<T extends B1 & .. & Bn>      // nota: the Bi cannot be array types\n        //\n        // Somewhere: C<? extends Arr[]>\n\n        // And capture would merge the bounds of the wildcard and of the tvar\n        // into Arr[] & B1 & .. & Bn\n        // Now the C<? ...> would only typecheck if Arr[] <: Bi forall i\n        // (Note that this means, that Bi in { Serializable, Cloneable, Object })\n\n        // This means, that the loop above would find Ck = Arr[], and delete all Bi, since Ck <: Bi\n        // So in the end, we would return Arr[] alone, not create an intersection\n        // TODO this is order dependent: Arr[] & Serializable is ok, but Serializable & Arr[] is not\n        //   Possibly use TypeOps::mostSpecific to merge them\n        assert ck instanceof JClassType : \"Weird intersection involving multiple array types? \" + list;\n\n        return new IntersectionTypeImpl.MinimalIntersection(this, (JClassType) ck, list);\n    }\n\n\n    private boolean isPossiblyAnInterface(JTypeMirror ci) {\n        return ci.isInterface()\n            || ci instanceof JInferenceVar\n            || ci.getSymbol() != null && ci.getSymbol().isUnresolved();\n    }\n\n    // package-private\n    JClassType erasedType(JClassSymbol symbol) {\n        JTypeMirror t = specialCache(symbol);\n        if (t != null) {\n            return (JClassType) t.getErasure();\n        } else {\n            return new ErasedClassType(this, symbol);\n        }\n    }\n\n\n    /**\n     * Returns a new type variable for the given symbol. This is only\n     * intended to be used by the implementor of {@link JTypeParameterSymbol}.\n     */\n    public JTypeVar.FreshTypeVar newTypeVar(JTypeParameterSymbol symbol) {\n        return new TypeVarImpl(this, symbol);\n    }\n\n    private static final class NullType implements JTypeMirror {\n        private final TypeSystem ts;\n\n        NullType(TypeSystem ts) {\n            this.ts = ts;\n        }\n\n        @Override\n        public JTypeMirror subst(Function<? super SubstVar, ? extends @NonNull JTypeMirror> subst) {\n            return this;\n        }\n\n        @Override\n        public TypeSystem getTypeSystem() {\n            return ts;\n        }\n\n        @Override\n        public @Nullable JClassSymbol getSymbol() {\n            return null;\n        }\n\n        @Override\n        public <T, P> T acceptVisitor(JTypeVisitor<T, P> visitor, P p) {\n            return visitor.visitNullType(this, p);\n        }\n\n        @Override\n        public String toString() {\n            return \"null\";\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            "private void checkArrayElement(@NonNull JTypeMirror element) {\n        AssertionUtil.requireParamNotNull(\"elementType\", element);\n\n        if (element instanceof JWildcardType\n            || element == NULL_TYPE\n            || element == NO_TYPE) {\n            throw new IllegalArgumentException(\"The type < \" + element + \" > is not a valid array element type\");\n        }\n    }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "/**\n     * Creates a new array type from an arbitrary element type.\n     *\n     * <pre>{@code\n     * arrayType(T, 0)          = T\n     * arrayType(T, 1)          = T[]\n     * arrayType(T, 3)          = T[][][]\n     * arrayType(T[], 2)        = T[][][]\n     * }</pre>\n     *\n     * @param element       Element type\n     * @param numDimensions Number of dimensions\n     *\n     * @return A new array type\n     *\n     * @throws IllegalArgumentException If numDimensions is negative\n     * @throws IllegalArgumentException If the element type is a {@link JWildcardType},\n     *                                  the null type, or {@link #NO_TYPE void}.\n     * @throws NullPointerException     If the element type is null\n     */\n    public JTypeMirror arrayType(@NonNull JTypeMirror element, int numDimensions) {\n        AssertionUtil.requireNonNegative(\"numDimensions\", numDimensions);\n        checkArrayElement(element); // note we throw even if numDimensions == 0\n\n        if (numDimensions == 0) {\n            return element;\n        }\n\n        JArrayType res = new ArrayTypeImpl(this, element);\n        while (--numDimensions > 0) {\n            res = new ArrayTypeImpl(this, res);\n        }\n        return res;\n    }\nprivate void checkArrayElement(@NonNull JTypeMirror element) {\n        AssertionUtil.requireParamNotNull(\"elementType\", element);\n\n        if (element instanceof JWildcardType\n            || element == NULL_TYPE\n            || element == NO_TYPE) {\n            throw new IllegalArgumentException(\"The type < \" + element + \" > is not a valid array element type\");\n        }\n    }",
        "diffSourceCode": "-  435:     /**\n-  436:      * Creates a new array type from an arbitrary element type.\n-  437:      *\n-  438:      * <pre>{@code\n-  439:      * arrayType(T, 0)          = T\n-  440:      * arrayType(T, 1)          = T[]\n-  441:      * arrayType(T, 3)          = T[][][]\n-  442:      * arrayType(T[], 2)        = T[][][]\n-  443:      * arrayType(ERROR_TYPE, _) = ERROR_TYPE\n-  444:      * }</pre>\n-  445:      *\n-  446:      * @param element       Element type\n-  447:      * @param numDimensions Number of dimensions\n+  435:         return new ClassTypeImpl(this, klass, new ArrayList<>(typeArgs), false);\n+  436:     }\n+  437: \n+  438: \n+  439:     /**\n+  440:      * Creates a new array type from an arbitrary element type.\n+  441:      *\n+  442:      * <pre>{@code\n+  443:      * arrayType(T, 0)          = T\n+  444:      * arrayType(T, 1)          = T[]\n+  445:      * arrayType(T, 3)          = T[][][]\n+  446:      * arrayType(T[], 2)        = T[][][]\n+  447:      * }</pre>\n   448:      *\n-  449:      * @return A new array type\n-  450:      *\n-  451:      * @throws IllegalArgumentException If numDimensions is negative\n-  452:      * @throws IllegalArgumentException If the element type is a {@link JWildcardType},\n-  453:      *                                  the null type, or {@link #NO_TYPE void}.\n-  454:      * @throws NullPointerException     If the element type is null\n-  455:      */\n-  456:     public JTypeMirror arrayType(@NonNull JTypeMirror element, int numDimensions) {\n-  457:         AssertionUtil.requireNonNegative(\"numDimensions\", numDimensions);\n-  458:         AssertionUtil.requireParamNotNull(\"elementType\", element);\n-  459: \n-  460:         if (element instanceof JWildcardType\n-  461:             || element == NULL_TYPE\n-  462:             || element == NO_TYPE) {\n-  463:             throw new IllegalArgumentException(\"The type < \" + element + \" > is not a valid array element type \");\n-  464:         }\n-  465: \n-  466:         if (numDimensions == 0 || element == ERROR_TYPE) {\n-  467:             return element;\n-  468:         }\n-  469: \n-  470:         JArrayType res = new ArrayTypeImpl(this, element);\n-  471:         while (--numDimensions > 0) {\n-  472:             res = new ArrayTypeImpl(this, res);\n-  473:         }\n-  474:         return res;\n-  475:     }\n-  491:         return JVariableSig.forLocal(decl, fieldSym);\n-  492:     }\n+  449:      * @param element       Element type\n+  450:      * @param numDimensions Number of dimensions\n+  451:      *\n+  452:      * @return A new array type\n+  453:      *\n+  454:      * @throws IllegalArgumentException If numDimensions is negative\n+  455:      * @throws IllegalArgumentException If the element type is a {@link JWildcardType},\n+  456:      *                                  the null type, or {@link #NO_TYPE void}.\n+  457:      * @throws NullPointerException     If the element type is null\n+  458:      */\n+  459:     public JTypeMirror arrayType(@NonNull JTypeMirror element, int numDimensions) {\n+  460:         AssertionUtil.requireNonNegative(\"numDimensions\", numDimensions);\n+  461:         checkArrayElement(element); // note we throw even if numDimensions == 0\n+  462: \n+  463:         if (numDimensions == 0) {\n+  464:             return element;\n+  465:         }\n+  466: \n+  467:         JArrayType res = new ArrayTypeImpl(this, element);\n+  468:         while (--numDimensions > 0) {\n+  469:             res = new ArrayTypeImpl(this, res);\n+  470:         }\n+  471:         return res;\n+  472:     }\n+  473: \n+  474:     /**\n+  475:      * Like {@link #arrayType(JTypeMirror, int)}, with one dimension.\n+  491:     private void checkArrayElement(@NonNull JTypeMirror element) {\n+  492:         AssertionUtil.requireParamNotNull(\"elementType\", element);\n   493: \n-  494:     public JVariableSig sigOf(JClassType decl, JFormalParamSymbol fieldSym) {\n-  495:         return JVariableSig.forLocal(decl, fieldSym);\n-  496:     }\n-  497: \n-  498:     /**\n-  499:      * Builds an intersection type for the specified component types.\n+  494:         if (element instanceof JWildcardType\n+  495:             || element == NULL_TYPE\n+  496:             || element == NO_TYPE) {\n+  497:             throw new IllegalArgumentException(\"The type < \" + element + \" > is not a valid array element type\");\n+  498:         }\n+  499:     }\n",
        "uniqueId": "a229887f034561d0280131588bad1ad6845e3631_435_475_491_499_439_472",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 16,
                "covered": 43
            },
            "BRANCH": {
                "missed": 5,
                "covered": 7
            },
            "LINE": {
                "missed": 2,
                "covered": 8
            },
            "COMPLEXITY": {
                "missed": 5,
                "covered": 2
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Inline Method",
        "description": "Inline Method\tprivate getCalledMethodArgsCount(methodCallArgs JavaNode) : int inlined to private isCaseChangingMethodCall(methodCall JavaNode, methodCallArgs JavaNode) : boolean in class net.sourceforge.pmd.lang.java.rule.errorprone.UnnecessaryCaseChangeRule",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java",
                "startLine": 51,
                "endLine": 55,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java",
                "startLine": 86,
                "endLine": 92,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java",
                "startLine": 113,
                "endLine": 116,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private int getCalledMethodArgsCount(JavaNode methodCallArgs) {\n        ASTArguments args = methodCallArgs.getFirstDescendantOfType(ASTArguments.class);\n        return args != null ? args.size() : -1;\n    }",
        "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java",
        "isPureRefactoring": true,
        "commitId": "eca547b5054814933f87f0718e0432bc2e27e5da",
        "packageNameBefore": "net.sourceforge.pmd.lang.java.rule.errorprone",
        "classNameBefore": "net.sourceforge.pmd.lang.java.rule.errorprone.UnnecessaryCaseChangeRule",
        "methodNameBefore": "net.sourceforge.pmd.lang.java.rule.errorprone.UnnecessaryCaseChangeRule#getCalledMethodArgsCount",
        "classSignatureBefore": "public class UnnecessaryCaseChangeRule extends AbstractJavaRule ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.rule.errorprone.UnnecessaryCaseChangeRule#getCalledMethodArgsCount"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.rule.errorprone.UnnecessaryCaseChangeRule"
        ],
        "classSignatureBeforeSet": [
            "public class UnnecessaryCaseChangeRule extends AbstractJavaRule "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.rule.errorprone;\n\nimport static java.util.Arrays.asList;\n\nimport java.util.List;\n\nimport net.sourceforge.pmd.lang.java.ast.ASTArgumentList;\nimport net.sourceforge.pmd.lang.java.ast.ASTArguments;\nimport net.sourceforge.pmd.lang.java.ast.ASTName;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimarySuffix;\nimport net.sourceforge.pmd.lang.java.ast.JavaNode;\nimport net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;\n\npublic class UnnecessaryCaseChangeRule extends AbstractJavaRule {\n\n    private static final List<String> CASE_CHANGING_METHODS = asList(\"toLowerCase\", \"toUpperCase\");\n    private static final List<String> EQUALITY_METHODS = asList(\"equals\", \"equalsIgnoreCase\");\n\n    @Override\n    public Object visit(ASTPrimaryExpression expr, Object data) {\n        int caseChangingCallIndex = getCaseChangingMethodCallIndex(expr);\n        if (caseChangingCallIndex != -1) {\n            int chainedMethodCallIndex = caseChangingCallIndex + 2;\n            if (hasEqualsMethodCallChainedAtPosition(expr, chainedMethodCallIndex)\n                    || isArgumentOfEqualsMethodCall(expr)) {\n                addViolation(data, expr);\n                return data;\n            }\n        }\n        return super.visit(expr, data);\n    }\n\n    private int getCaseChangingMethodCallIndex(ASTPrimaryExpression expr) {\n        for (int callArgsIndex = 1; callArgsIndex < expr.getNumChildren(); callArgsIndex++) {\n            JavaNode methodCallArgs = expr.getChild(callArgsIndex);\n            int callIndex = callArgsIndex - 1;\n            JavaNode methodCall = expr.getChild(callIndex);\n            if (isCaseChangingMethodCall(methodCall, methodCallArgs)) {\n                return callIndex;\n            }\n        }\n        return -1;\n    }\n\n    private boolean isCaseChangingMethodCall(JavaNode methodCall, JavaNode methodCallArgs) {\n        String methodName = getCalledMethodName(methodCall);\n        int methodArgsCount = getCalledMethodArgsCount(methodCallArgs);\n        return isNameOfCaseChangingMethod(methodName) && methodArgsCount == 0;\n    }\n\n    private String getCalledMethodName(JavaNode methodCall) {\n        if (methodCall instanceof ASTPrimaryPrefix) {\n            ASTName methodName = methodCall.getFirstDescendantOfType(ASTName.class);\n            return methodName != null ? methodName.getImage() : null;\n        }\n        return methodCall.getImage();\n    }\n\n    private boolean isNameOfCaseChangingMethod(String methodName) {\n        if (methodName != null) {\n            for (String caseChangingMethod : CASE_CHANGING_METHODS) {\n                if (methodName.endsWith(caseChangingMethod)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private boolean hasEqualsMethodCallChainedAtPosition(ASTPrimaryExpression expr, int pos) {\n        int argsPos = pos + 1;\n        if (hasNodeAtPosition(expr, argsPos)) {\n            JavaNode chainedMethodCall = expr.getChild(pos);\n            JavaNode chainedMethodCallArgs = expr.getChild(argsPos);\n            return isEqualsMethodCall(chainedMethodCall, chainedMethodCallArgs);\n        }\n        return false;\n    }\n\n    private boolean hasNodeAtPosition(ASTPrimaryExpression expr, int pos) {\n        return pos < expr.getNumChildren();\n    }\n\n    private boolean isArgumentOfEqualsMethodCall(ASTPrimaryExpression expr) {\n        ASTPrimarySuffix parentMethodCallArgs = getParentMethodCallArgsSuffix(expr);\n        if (parentMethodCallArgs != null) {\n            List<JavaNode> parentNodes = parentMethodCallArgs.getParent().findChildrenOfType(JavaNode.class);\n            int parentMethodCallIndex = parentNodes.indexOf(parentMethodCallArgs) - 1;\n            JavaNode parentMethodCall = parentNodes.get(parentMethodCallIndex);\n            return isEqualsMethodCall(parentMethodCall, parentMethodCallArgs);\n        }\n        return false;\n    }\n\n    private ASTPrimarySuffix getParentMethodCallArgsSuffix(ASTPrimaryExpression expr) {\n        JavaNode parent = expr.getParent().getParent(); // ASTArgumentList/ASTExpression/ASTPrimaryExpression\n        return parent instanceof ASTArgumentList\n                ? parent.getFirstParentOfType(ASTPrimarySuffix.class)\n                : null;\n    }\n\n    private boolean isEqualsMethodCall(JavaNode methodCall, JavaNode methodCallArgs) {\n        int methodArgsCount = getCalledMethodArgsCount(methodCallArgs);\n        return EQUALITY_METHODS.contains(methodCall.getImage()) && methodArgsCount == 1;\n    }\n\n    private int getCalledMethodArgsCount(JavaNode methodCallArgs) {\n        ASTArguments args = methodCallArgs.getFirstDescendantOfType(ASTArguments.class);\n        return args != null ? args.size() : -1;\n    }\n}\n",
        "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/UnnecessaryCaseChangeRule.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.rule.errorprone;\n\nimport static java.util.Arrays.asList;\n\nimport java.util.List;\n\nimport net.sourceforge.pmd.lang.java.ast.ASTArguments;\nimport net.sourceforge.pmd.lang.java.ast.ASTName;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;\nimport net.sourceforge.pmd.lang.java.ast.JavaNode;\nimport net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;\n\npublic class UnnecessaryCaseChangeRule extends AbstractJavaRule {\n\n    private static final List<String> CASE_CHANGING_METHODS = asList(\"toLowerCase\", \"toUpperCase\");\n    private static final List<String> EQUALITY_METHODS = asList(\"equals\", \"equalsIgnoreCase\");\n\n    @Override\n    public Object visit(ASTPrimaryExpression expr, Object data) {\n        if (hasUnnecessaryCaseChange(expr)) {\n            addViolation(data, expr);\n        }\n        return super.visit(expr, data);\n    }\n\n    private boolean hasUnnecessaryCaseChange(ASTPrimaryExpression expr) {\n        int equalsMethodCallIndex = getEqualsMethodCallIndex(expr);\n        if (equalsMethodCallIndex != -1) {\n            int equalsMethodCallArgsIndex = equalsMethodCallIndex + 1;\n            ASTPrimaryExpression equalsCallArgs = getMethodCallArgsAtPosition(expr, equalsMethodCallArgsIndex);\n            return anyHasCaseChangingMethodCall(expr, equalsCallArgs);\n        }\n        return false;\n    }\n\n    private int getEqualsMethodCallIndex(ASTPrimaryExpression expr) {\n        for (int callIndex = 0; callIndex < expr.getNumChildren(); callIndex++) {\n            JavaNode methodCall = expr.getChild(callIndex);\n            if (isEqualsMethodCall(methodCall)) {\n                return callIndex;\n            }\n        }\n        return -1;\n    }\n\n    private boolean isEqualsMethodCall(JavaNode methodCall) {\n        return calledMethodHasNameFromList(methodCall, EQUALITY_METHODS);\n    }\n\n    private ASTPrimaryExpression getMethodCallArgsAtPosition(ASTPrimaryExpression expr, int argsPos) {\n        if (hasChildAtPosition(expr, argsPos)) {\n            JavaNode methodCallArgs = expr.getChild(argsPos);\n            return methodCallArgs.getFirstDescendantOfType(ASTPrimaryExpression.class);\n        }\n        return null;\n    }\n\n    private boolean hasChildAtPosition(ASTPrimaryExpression expr, int pos) {\n        return expr.getNumChildren() > pos;\n    }\n\n    private boolean anyHasCaseChangingMethodCall(ASTPrimaryExpression ... exprs) {\n        for (ASTPrimaryExpression expr : exprs) {\n            if (expr != null && hasCaseChangingMethodCall(expr)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean hasCaseChangingMethodCall(ASTPrimaryExpression expr) {\n        for (int callArgsIndex = 1; callArgsIndex < expr.getNumChildren(); callArgsIndex++) {\n            JavaNode methodCall = expr.getChild(callArgsIndex - 1);\n            JavaNode methodCallArgs = expr.getChild(callArgsIndex);\n            if (isCaseChangingMethodCall(methodCall, methodCallArgs)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean isCaseChangingMethodCall(JavaNode methodCall, JavaNode methodCallArgs) {\n        if (calledMethodHasNameFromList(methodCall, CASE_CHANGING_METHODS)) {\n            ASTArguments args = methodCallArgs.getFirstDescendantOfType(ASTArguments.class);\n            return args != null && args.size() == 0;\n        }\n        return false;\n    }\n\n    private boolean calledMethodHasNameFromList(JavaNode methodCall, List<String> nameList) {\n        String methodName = getCalledMethodName(methodCall);\n        if (methodName != null) {\n            for (String nameFromList : nameList) {\n                if (methodName.endsWith(nameFromList)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private String getCalledMethodName(JavaNode methodCall) {\n        String methodName = methodCall.getImage();\n        if (methodName == null) {\n            ASTName name = methodCall.getFirstDescendantOfType(ASTName.class);\n            return name != null ? methodNameFromCallImage(name.getImage()) : null;\n        }\n        return methodName;\n    }\n\n    private String methodNameFromCallImage(String methodCallImage) {\n        if (methodCallImage.contains(\".\")) {\n            String[] callParts = methodCallImage.split(\"\\\\.\");\n            return callParts[1];\n        }\n        return methodCallImage;\n    }\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "private boolean isCaseChangingMethodCall(JavaNode methodCall, JavaNode methodCallArgs) {\n        if (calledMethodHasNameFromList(methodCall, CASE_CHANGING_METHODS)) {\n            ASTArguments args = methodCallArgs.getFirstDescendantOfType(ASTArguments.class);\n            return args != null && args.size() == 0;\n        }\n        return false;\n    }",
        "diffSourceCode": "-   51:     private boolean isCaseChangingMethodCall(JavaNode methodCall, JavaNode methodCallArgs) {\n-   52:         String methodName = getCalledMethodName(methodCall);\n-   53:         int methodArgsCount = getCalledMethodArgsCount(methodCallArgs);\n-   54:         return isNameOfCaseChangingMethod(methodName) && methodArgsCount == 0;\n-   55:     }\n-   86:     private boolean hasNodeAtPosition(ASTPrimaryExpression expr, int pos) {\n-   87:         return pos < expr.getNumChildren();\n-   88:     }\n-   89: \n-   90:     private boolean isArgumentOfEqualsMethodCall(ASTPrimaryExpression expr) {\n-   91:         ASTPrimarySuffix parentMethodCallArgs = getParentMethodCallArgsSuffix(expr);\n-   92:         if (parentMethodCallArgs != null) {\n-  113:     private int getCalledMethodArgsCount(JavaNode methodCallArgs) {\n-  114:         ASTArguments args = methodCallArgs.getFirstDescendantOfType(ASTArguments.class);\n-  115:         return args != null ? args.size() : -1;\n-  116:     }\n+   51:         return calledMethodHasNameFromList(methodCall, EQUALITY_METHODS);\n+   52:     }\n+   53: \n+   54:     private ASTPrimaryExpression getMethodCallArgsAtPosition(ASTPrimaryExpression expr, int argsPos) {\n+   55:         if (hasChildAtPosition(expr, argsPos)) {\n+   86:     private boolean isCaseChangingMethodCall(JavaNode methodCall, JavaNode methodCallArgs) {\n+   87:         if (calledMethodHasNameFromList(methodCall, CASE_CHANGING_METHODS)) {\n+   88:             ASTArguments args = methodCallArgs.getFirstDescendantOfType(ASTArguments.class);\n+   89:             return args != null && args.size() == 0;\n+   90:         }\n+   91:         return false;\n+   92:     }\n+  113:     }\n+  114: \n+  115:     private String methodNameFromCallImage(String methodCallImage) {\n+  116:         if (methodCallImage.contains(\".\")) {\n",
        "uniqueId": "eca547b5054814933f87f0718e0432bc2e27e5da_51_55__86_92_113_116",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 12
            },
            "BRANCH": {
                "missed": 0,
                "covered": 2
            },
            "LINE": {
                "missed": 0,
                "covered": 2
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 2
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic runPMDRules(tempDir Path, sourceDirectory String, ruleset String, formatter String) : ExecutionResult extracted from public runPMDRules(tempDir Path, sourceDirectory String, ruleset String) : ExecutionResult in class net.sourceforge.pmd.it.PMDExecutor",
        "diffLocations": [
            {
                "filePath": "pmd-dist/src/test/java/net/sourceforge/pmd/it/PMDExecutor.java",
                "startLine": 96,
                "endLine": 116,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-dist/src/test/java/net/sourceforge/pmd/it/PMDExecutor.java",
                "startLine": 97,
                "endLine": 108,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-dist/src/test/java/net/sourceforge/pmd/it/PMDExecutor.java",
                "startLine": 110,
                "endLine": 121,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Executes the PMD found in tempDir against the given sourceDirectory path with the given ruleset.\n     *\n     * @param tempDir the directory, to which the binary distribution has been extracted\n     * @param sourceDirectory the source directory, that PMD should analyze\n     * @param ruleset the ruleset, that PMD should execute\n     * @return collected result of the execution\n     * @throws Exception if the execution fails for any reason (executable not found, ...)\n     */\n    public static ExecutionResult runPMDRules(Path tempDir, String sourceDirectory, String ruleset) throws Exception {\n        Path reportFile = Files.createTempFile(\"pmd-it-report\", \"txt\");\n        reportFile.toFile().deleteOnExit();\n\n        if (SystemUtils.IS_OS_WINDOWS) {\n            return runPMDWindows(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n                    FORMAT_FLAG, FORMATTER, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n        } else {\n            return runPMDUnix(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n                    FORMAT_FLAG, FORMATTER, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n        }\n    }",
        "filePathBefore": "pmd-dist/src/test/java/net/sourceforge/pmd/it/PMDExecutor.java",
        "isPureRefactoring": true,
        "commitId": "4cf9f5904ad76f13aecc2210a758168974657eb1",
        "packageNameBefore": "net.sourceforge.pmd.it",
        "classNameBefore": "net.sourceforge.pmd.it.PMDExecutor",
        "methodNameBefore": "net.sourceforge.pmd.it.PMDExecutor#runPMDRules",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.it.PMDExecutor#runPMDWindows\n methodBody: private static ExecutionResult runPMDWindows(Path tempDir, Path reportFile, String ... arguments) throws Exception {\nString cmd=tempDir.resolve(PMD_BIN_PREFIX + PMDVersion.VERSION + \"/bin/pmd.bat\").toAbsolutePath().toString();\nreturn runPMD(cmd,Arrays.asList(arguments),reportFile);\n}\nmethodSignature: net.sourceforge.pmd.it.ExecutionResult#toString\n methodBody: public String toString() {\nStringBuilder sb=new StringBuilder();\nsb.append(\"ExecutionResult:\").append(PMD.EOL).append(\" exit code: \").append(exitCode).append(PMD.EOL).append(\" output:\").append(PMD.EOL).append(output).append(PMD.EOL).append(\" errorOutput:\").append(PMD.EOL).append(errorOutput).append(PMD.EOL).append(\" report:\").append(PMD.EOL).append(report).append(PMD.EOL);\nreturn sb.toString();\n}\nmethodSignature: net.sourceforge.pmd.it.PMDExecutor#runPMDUnix\n methodBody: private static ExecutionResult runPMDUnix(Path tempDir, Path reportFile, String ... arguments) throws Exception {\nString cmd=tempDir.resolve(PMD_BIN_PREFIX + PMDVersion.VERSION + \"/bin/run.sh\").toAbsolutePath().toString();\nList<String> args=new ArrayList<>();\nargs.add(\"pmd\");\nargs.addAll(Arrays.asList(arguments));\nreturn runPMD(cmd,args,reportFile);\n}",
        "classSignatureBefore": "public class PMDExecutor ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.it.PMDExecutor#runPMDRules"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.it.PMDExecutor"
        ],
        "classSignatureBeforeSet": [
            "public class PMDExecutor "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics",
                "description": "All the mappings are matched! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.it;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.SystemUtils;\n\nimport net.sourceforge.pmd.PMDVersion;\n\n/**\n * Executes PMD from command line. Deals with the differences, when PMD is run on Windows or on Linux.\n *\n * @author Andreas Dangel\n */\npublic class PMDExecutor {\n    private static final String PMD_BIN_PREFIX = \"pmd-bin-\";\n    private static final String SOURCE_DIRECTORY_FLAG = \"-d\";\n    private static final String RULESET_FLAG = \"-R\";\n    private static final String FORMAT_FLAG = \"-f\";\n    private static final String FORMATTER = \"text\";\n    private static final String REPORTFILE_FLAG = \"-r\";\n\n    private PMDExecutor() {\n        // this is a helper class only\n    }\n\n    private static ExecutionResult runPMDUnix(Path tempDir, Path reportFile, String ... arguments) throws Exception {\n        String cmd = tempDir.resolve(PMD_BIN_PREFIX + PMDVersion.VERSION + \"/bin/run.sh\").toAbsolutePath().toString();\n        List<String> args = new ArrayList<>();\n        args.add(\"pmd\");\n        args.addAll(Arrays.asList(arguments));\n        return runPMD(cmd, args, reportFile);\n    }\n\n    private static ExecutionResult runPMDWindows(Path tempDir, Path reportFile, String ... arguments) throws Exception {\n        String cmd = tempDir.resolve(PMD_BIN_PREFIX + PMDVersion.VERSION + \"/bin/pmd.bat\").toAbsolutePath().toString();\n        return runPMD(cmd, Arrays.asList(arguments), reportFile);\n    }\n\n    private static ExecutionResult runPMD(String cmd, List<String> arguments, Path reportFile) throws Exception {\n        ProcessBuilder pb = new ProcessBuilder(cmd);\n        pb.command().addAll(arguments);\n        pb.redirectErrorStream(false);\n        final Process process = pb.start();\n        final ExecutionResult.Builder result = new ExecutionResult.Builder();\n\n        Thread outputReader = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                String output;\n                try {\n                    output = IOUtils.toString(process.getInputStream(), StandardCharsets.UTF_8);\n                    result.withOutput(output);\n                } catch (IOException e) {\n                    result.withOutput(\"Exception occurred: \" + e.toString());\n                }\n            }\n        });\n        outputReader.start();\n        Thread errorReader = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                String error;\n                try {\n                    error = IOUtils.toString(process.getErrorStream(), StandardCharsets.UTF_8);\n                    result.withErrorOutput(error);\n                } catch (IOException e) {\n                    result.withErrorOutput(\"Exception occurred: \" + e.toString());\n                }\n            }\n        });\n        errorReader.start();\n\n        int exitCode = process.waitFor();\n        outputReader.join(TimeUnit.MINUTES.toMillis(5));\n        errorReader.join(TimeUnit.MINUTES.toMillis(5));\n\n        String report = null;\n        if (reportFile != null) {\n            report = IOUtils.toString(reportFile.toUri(), StandardCharsets.UTF_8);\n        }\n        return result.withExitCode(exitCode).withReport(report).build();\n    }\n\n    /**\n     * Executes the PMD found in tempDir against the given sourceDirectory path with the given ruleset.\n     *\n     * @param tempDir the directory, to which the binary distribution has been extracted\n     * @param sourceDirectory the source directory, that PMD should analyze\n     * @param ruleset the ruleset, that PMD should execute\n     * @return collected result of the execution\n     * @throws Exception if the execution fails for any reason (executable not found, ...)\n     */\n    public static ExecutionResult runPMDRules(Path tempDir, String sourceDirectory, String ruleset) throws Exception {\n        Path reportFile = Files.createTempFile(\"pmd-it-report\", \"txt\");\n        reportFile.toFile().deleteOnExit();\n\n        if (SystemUtils.IS_OS_WINDOWS) {\n            return runPMDWindows(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n                    FORMAT_FLAG, FORMATTER, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n        } else {\n            return runPMDUnix(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n                    FORMAT_FLAG, FORMATTER, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n        }\n    }\n\n    /**\n     * Executes PMD found in tempDir with the given command line arguments.\n     * @param tempDir the directory, to which the binary distribution has been extracted\n     * @param arguments the arguments to execute PMD with\n     * @return collected result of the execution\n     * @throws Exception if the execution fails for any reason (executable not found, ...)\n     */\n    public static ExecutionResult runPMD(Path tempDir, String ... arguments) throws Exception {\n        if (SystemUtils.IS_OS_WINDOWS) {\n            return runPMDWindows(tempDir, null, arguments);\n        } else {\n            return runPMDUnix(tempDir, null, arguments);\n        }\n    }\n}\n",
        "filePathAfter": "pmd-dist/src/test/java/net/sourceforge/pmd/it/PMDExecutor.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.it;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.SystemUtils;\n\nimport net.sourceforge.pmd.PMDVersion;\n\n/**\n * Executes PMD from command line. Deals with the differences, when PMD is run on Windows or on Linux.\n *\n * @author Andreas Dangel\n */\npublic class PMDExecutor {\n    private static final String PMD_BIN_PREFIX = \"pmd-bin-\";\n    private static final String SOURCE_DIRECTORY_FLAG = \"-d\";\n    private static final String RULESET_FLAG = \"-R\";\n    private static final String FORMAT_FLAG = \"-f\";\n    private static final String FORMATTER = \"text\";\n    private static final String REPORTFILE_FLAG = \"-r\";\n\n    private PMDExecutor() {\n        // this is a helper class only\n    }\n\n    private static ExecutionResult runPMDUnix(Path tempDir, Path reportFile, String ... arguments) throws Exception {\n        String cmd = tempDir.resolve(PMD_BIN_PREFIX + PMDVersion.VERSION + \"/bin/run.sh\").toAbsolutePath().toString();\n        List<String> args = new ArrayList<>();\n        args.add(\"pmd\");\n        args.addAll(Arrays.asList(arguments));\n        return runPMD(cmd, args, reportFile);\n    }\n\n    private static ExecutionResult runPMDWindows(Path tempDir, Path reportFile, String ... arguments) throws Exception {\n        String cmd = tempDir.resolve(PMD_BIN_PREFIX + PMDVersion.VERSION + \"/bin/pmd.bat\").toAbsolutePath().toString();\n        return runPMD(cmd, Arrays.asList(arguments), reportFile);\n    }\n\n    private static ExecutionResult runPMD(String cmd, List<String> arguments, Path reportFile) throws Exception {\n        ProcessBuilder pb = new ProcessBuilder(cmd);\n        pb.command().addAll(arguments);\n        pb.redirectErrorStream(false);\n        final Process process = pb.start();\n        final ExecutionResult.Builder result = new ExecutionResult.Builder();\n\n        Thread outputReader = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                String output;\n                try {\n                    output = IOUtils.toString(process.getInputStream(), StandardCharsets.UTF_8);\n                    result.withOutput(output);\n                } catch (IOException e) {\n                    result.withOutput(\"Exception occurred: \" + e.toString());\n                }\n            }\n        });\n        outputReader.start();\n        Thread errorReader = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                String error;\n                try {\n                    error = IOUtils.toString(process.getErrorStream(), StandardCharsets.UTF_8);\n                    result.withErrorOutput(error);\n                } catch (IOException e) {\n                    result.withErrorOutput(\"Exception occurred: \" + e.toString());\n                }\n            }\n        });\n        errorReader.start();\n\n        int exitCode = process.waitFor();\n        outputReader.join(TimeUnit.MINUTES.toMillis(5));\n        errorReader.join(TimeUnit.MINUTES.toMillis(5));\n\n        String report = null;\n        if (reportFile != null) {\n            report = IOUtils.toString(reportFile.toUri(), StandardCharsets.UTF_8);\n        }\n        return result.withExitCode(exitCode).withReport(report).build();\n    }\n\n    /**\n     * Executes the PMD found in tempDir against the given sourceDirectory path with the given ruleset.\n     *\n     * @param tempDir the directory, to which the binary distribution has been extracted\n     * @param sourceDirectory the source directory, that PMD should analyze\n     * @param ruleset the ruleset, that PMD should execute\n     * @return collected result of the execution\n     * @throws Exception if the execution fails for any reason (executable not found, ...)\n     */\n    public static ExecutionResult runPMDRules(Path tempDir, String sourceDirectory, String ruleset) throws Exception {\n        return runPMDRules(tempDir, sourceDirectory, ruleset, FORMATTER);\n    }\n\n    public static ExecutionResult runPMDRules(Path tempDir, String sourceDirectory, String ruleset, String formatter) throws Exception {\n        Path reportFile = Files.createTempFile(\"pmd-it-report\", \"txt\");\n        reportFile.toFile().deleteOnExit();\n\n        if (SystemUtils.IS_OS_WINDOWS) {\n            return runPMDWindows(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n                    FORMAT_FLAG, formatter, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n        } else {\n            return runPMDUnix(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n                    FORMAT_FLAG, formatter, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n        }\n    }\n\n    /**\n     * Executes PMD found in tempDir with the given command line arguments.\n     * @param tempDir the directory, to which the binary distribution has been extracted\n     * @param arguments the arguments to execute PMD with\n     * @return collected result of the execution\n     * @throws Exception if the execution fails for any reason (executable not found, ...)\n     */\n    public static ExecutionResult runPMD(Path tempDir, String ... arguments) throws Exception {\n        if (SystemUtils.IS_OS_WINDOWS) {\n            return runPMDWindows(tempDir, null, arguments);\n        } else {\n            return runPMDUnix(tempDir, null, arguments);\n        }\n    }\n\n    public static boolean isJava7Test() {\n        return StringUtils.equals(System.getenv(\"JAVA_HOME\"), System.getProperty(\"java7.home\"));\n    }\n}\n",
        "diffSourceCodeSet": [
            "public static ExecutionResult runPMDRules(Path tempDir, String sourceDirectory, String ruleset, String formatter) throws Exception {\n        Path reportFile = Files.createTempFile(\"pmd-it-report\", \"txt\");\n        reportFile.toFile().deleteOnExit();\n\n        if (SystemUtils.IS_OS_WINDOWS) {\n            return runPMDWindows(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n                    FORMAT_FLAG, formatter, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n        } else {\n            return runPMDUnix(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n                    FORMAT_FLAG, formatter, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n        }\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.it.PMDExecutor#runPMDWindows\n methodBody: private static ExecutionResult runPMDWindows(Path tempDir, Path reportFile, String ... arguments) throws Exception {\nString cmd=tempDir.resolve(PMD_BIN_PREFIX + PMDVersion.VERSION + \"/bin/pmd.bat\").toAbsolutePath().toString();\nreturn runPMD(cmd,Arrays.asList(arguments),reportFile);\n}",
            "methodSignature: net.sourceforge.pmd.it.ExecutionResult#toString\n methodBody: public String toString() {\nStringBuilder sb=new StringBuilder();\nsb.append(\"ExecutionResult:\").append(PMD.EOL).append(\" exit code: \").append(exitCode).append(PMD.EOL).append(\" output:\").append(PMD.EOL).append(output).append(PMD.EOL).append(\" errorOutput:\").append(PMD.EOL).append(errorOutput).append(PMD.EOL).append(\" report:\").append(PMD.EOL).append(report).append(PMD.EOL);\nreturn sb.toString();\n}",
            "methodSignature: net.sourceforge.pmd.it.PMDExecutor#runPMDUnix\n methodBody: private static ExecutionResult runPMDUnix(Path tempDir, Path reportFile, String ... arguments) throws Exception {\nString cmd=tempDir.resolve(PMD_BIN_PREFIX + PMDVersion.VERSION + \"/bin/run.sh\").toAbsolutePath().toString();\nList<String> args=new ArrayList<>();\nargs.add(\"pmd\");\nargs.addAll(Arrays.asList(arguments));\nreturn runPMD(cmd,args,reportFile);\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Executes the PMD found in tempDir against the given sourceDirectory path with the given ruleset.\n     *\n     * @param tempDir the directory, to which the binary distribution has been extracted\n     * @param sourceDirectory the source directory, that PMD should analyze\n     * @param ruleset the ruleset, that PMD should execute\n     * @return collected result of the execution\n     * @throws Exception if the execution fails for any reason (executable not found, ...)\n     */\n    public static ExecutionResult runPMDRules(Path tempDir, String sourceDirectory, String ruleset) throws Exception {\n        return runPMDRules(tempDir, sourceDirectory, ruleset, FORMATTER);\n    }\npublic static ExecutionResult runPMDRules(Path tempDir, String sourceDirectory, String ruleset, String formatter) throws Exception {\n        Path reportFile = Files.createTempFile(\"pmd-it-report\", \"txt\");\n        reportFile.toFile().deleteOnExit();\n\n        if (SystemUtils.IS_OS_WINDOWS) {\n            return runPMDWindows(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n                    FORMAT_FLAG, formatter, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n        } else {\n            return runPMDUnix(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n                    FORMAT_FLAG, formatter, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n        }\n    }",
        "diffSourceCode": "-   96:     /**\n-   97:      * Executes the PMD found in tempDir against the given sourceDirectory path with the given ruleset.\n-   98:      *\n-   99:      * @param tempDir the directory, to which the binary distribution has been extracted\n-  100:      * @param sourceDirectory the source directory, that PMD should analyze\n-  101:      * @param ruleset the ruleset, that PMD should execute\n-  102:      * @return collected result of the execution\n-  103:      * @throws Exception if the execution fails for any reason (executable not found, ...)\n-  104:      */\n-  105:     public static ExecutionResult runPMDRules(Path tempDir, String sourceDirectory, String ruleset) throws Exception {\n-  106:         Path reportFile = Files.createTempFile(\"pmd-it-report\", \"txt\");\n-  107:         reportFile.toFile().deleteOnExit();\n-  108: \n-  109:         if (SystemUtils.IS_OS_WINDOWS) {\n-  110:             return runPMDWindows(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n-  111:                     FORMAT_FLAG, FORMATTER, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n-  112:         } else {\n-  113:             return runPMDUnix(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n-  114:                     FORMAT_FLAG, FORMATTER, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n-  115:         }\n-  116:     }\n-  117: \n-  118:     /**\n-  119:      * Executes PMD found in tempDir with the given command line arguments.\n-  120:      * @param tempDir the directory, to which the binary distribution has been extracted\n-  121:      * @param arguments the arguments to execute PMD with\n+   96: \n+   97:     /**\n+   98:      * Executes the PMD found in tempDir against the given sourceDirectory path with the given ruleset.\n+   99:      *\n+  100:      * @param tempDir the directory, to which the binary distribution has been extracted\n+  101:      * @param sourceDirectory the source directory, that PMD should analyze\n+  102:      * @param ruleset the ruleset, that PMD should execute\n+  103:      * @return collected result of the execution\n+  104:      * @throws Exception if the execution fails for any reason (executable not found, ...)\n+  105:      */\n+  106:     public static ExecutionResult runPMDRules(Path tempDir, String sourceDirectory, String ruleset) throws Exception {\n+  107:         return runPMDRules(tempDir, sourceDirectory, ruleset, FORMATTER);\n+  108:     }\n+  109: \n+  110:     public static ExecutionResult runPMDRules(Path tempDir, String sourceDirectory, String ruleset, String formatter) throws Exception {\n+  111:         Path reportFile = Files.createTempFile(\"pmd-it-report\", \"txt\");\n+  112:         reportFile.toFile().deleteOnExit();\n+  113: \n+  114:         if (SystemUtils.IS_OS_WINDOWS) {\n+  115:             return runPMDWindows(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n+  116:                     FORMAT_FLAG, formatter, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n+  117:         } else {\n+  118:             return runPMDUnix(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n+  119:                     FORMAT_FLAG, formatter, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n+  120:         }\n+  121:     }\n",
        "uniqueId": "4cf9f5904ad76f13aecc2210a758168974657eb1_96_116_110_121_97_108",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate isToStringOnStringCall(varDeclaratorId ASTVariableDeclaratorId, qualifier NameOccurrence) : boolean extracted from public visit(node ASTVariableDeclaratorId, data Object) : Object in class net.sourceforge.pmd.lang.java.rule.performance.StringToStringRule",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/StringToStringRule.java",
                "startLine": 19,
                "endLine": 39,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/StringToStringRule.java",
                "startLine": 64,
                "endLine": 75,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/StringToStringRule.java",
                "startLine": 88,
                "endLine": 94,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n    public Object visit(ASTVariableDeclaratorId node, Object data) {\n        if (node.getNameDeclaration() == null\n            || !TypeHelper.isExactlyAny(node.getNameDeclaration(), String.class)\n                && !TypeHelper.isExactlyAny(node.getNameDeclaration(), String[].class)) {\n            return data;\n        }\n        boolean isArray = node.isArray();\n        for (NameOccurrence occ : node.getUsages()) {\n            JavaNameOccurrence jocc = (JavaNameOccurrence) occ;\n            NameOccurrence qualifier = jocc.getNameForWhichThisIsAQualifier();\n            if (qualifier != null) {\n                if (!isArray && isNotAMethodReference(qualifier) && qualifier.getImage().indexOf(\"toString\") != -1) {\n                    addViolation(data, jocc.getLocation());\n                } else if (isArray && isNotAName(qualifier) && \"toString\".equals(qualifier.getImage())) {\n                    addViolation(data, jocc.getLocation());\n                }\n            }\n        }\n        return data;\n    }",
        "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/StringToStringRule.java",
        "isPureRefactoring": true,
        "commitId": "b48da457016e3342151c5987beb10ffa5b73557f",
        "packageNameBefore": "net.sourceforge.pmd.lang.java.rule.performance",
        "classNameBefore": "net.sourceforge.pmd.lang.java.rule.performance.StringToStringRule",
        "methodNameBefore": "net.sourceforge.pmd.lang.java.rule.performance.StringToStringRule#visit",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.java.rule.performance.StringToStringRule#isNotAMethodReference\n methodBody: private boolean isNotAMethodReference(NameOccurrence qualifier) {\nreturn isNotA(qualifier,ASTMethodReference.class);\n}\nmethodSignature: net.sourceforge.pmd.lang.java.rule.performance.StringToStringRule#isNotAName\n methodBody: private boolean isNotAName(NameOccurrence qualifier) {\nreturn isNotA(qualifier,ASTName.class);\n}",
        "classSignatureBefore": "public class StringToStringRule extends AbstractJavaRule ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.rule.performance.StringToStringRule#visit"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.rule.performance.StringToStringRule"
        ],
        "classSignatureBeforeSet": [
            "public class StringToStringRule extends AbstractJavaRule "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics Severe changes",
                "description": "Just an empty block - with non-mapped leaves",
                "mappingState": 3
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.rule.performance;\n\nimport net.sourceforge.pmd.lang.java.ast.ASTMethodReference;\nimport net.sourceforge.pmd.lang.java.ast.ASTName;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;\nimport net.sourceforge.pmd.lang.java.ast.AbstractJavaNode;\nimport net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;\nimport net.sourceforge.pmd.lang.java.symboltable.JavaNameOccurrence;\nimport net.sourceforge.pmd.lang.java.typeresolution.TypeHelper;\nimport net.sourceforge.pmd.lang.symboltable.NameOccurrence;\nimport net.sourceforge.pmd.lang.symboltable.ScopedNode;\n\npublic class StringToStringRule extends AbstractJavaRule {\n\n    @Override\n    public Object visit(ASTVariableDeclaratorId node, Object data) {\n        if (node.getNameDeclaration() == null\n            || !TypeHelper.isExactlyAny(node.getNameDeclaration(), String.class)\n                && !TypeHelper.isExactlyAny(node.getNameDeclaration(), String[].class)) {\n            return data;\n        }\n        boolean isArray = node.isArray();\n        for (NameOccurrence occ : node.getUsages()) {\n            JavaNameOccurrence jocc = (JavaNameOccurrence) occ;\n            NameOccurrence qualifier = jocc.getNameForWhichThisIsAQualifier();\n            if (qualifier != null) {\n                if (!isArray && isNotAMethodReference(qualifier) && qualifier.getImage().indexOf(\"toString\") != -1) {\n                    addViolation(data, jocc.getLocation());\n                } else if (isArray && isNotAName(qualifier) && \"toString\".equals(qualifier.getImage())) {\n                    addViolation(data, jocc.getLocation());\n                }\n            }\n        }\n        return data;\n    }\n\n    private boolean isNotAMethodReference(NameOccurrence qualifier) {\n        return isNotA(qualifier, ASTMethodReference.class);\n    }\n\n    private boolean isNotAName(NameOccurrence qualifier) {\n        return isNotA(qualifier, ASTName.class);\n    }\n\n    private boolean isNotA(NameOccurrence qualifier, Class<? extends AbstractJavaNode> type) {\n        ScopedNode location = qualifier.getLocation();\n        return location == null || !(type.isAssignableFrom(location.getClass()));\n    }\n}\n",
        "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/performance/StringToStringRule.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.rule.performance;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport net.sourceforge.pmd.lang.java.ast.ASTArgumentList;\nimport net.sourceforge.pmd.lang.java.ast.ASTArguments;\nimport net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody;\nimport net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;\nimport net.sourceforge.pmd.lang.java.ast.ASTFormalParameters;\nimport net.sourceforge.pmd.lang.java.ast.ASTLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTMethodReference;\nimport net.sourceforge.pmd.lang.java.ast.ASTName;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimarySuffix;\nimport net.sourceforge.pmd.lang.java.ast.ASTType;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableDeclarator;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;\nimport net.sourceforge.pmd.lang.java.ast.JavaNode;\nimport net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;\nimport net.sourceforge.pmd.lang.java.symboltable.JavaNameOccurrence;\nimport net.sourceforge.pmd.lang.java.symboltable.VariableNameDeclaration;\nimport net.sourceforge.pmd.lang.java.typeresolution.TypeHelper;\nimport net.sourceforge.pmd.lang.symboltable.NameOccurrence;\nimport net.sourceforge.pmd.lang.symboltable.ScopedNode;\n\npublic class StringToStringRule extends AbstractJavaRule {\n\n    private final Map<String, Class<?>> declaredVariables = new HashMap<>();\n    private final Set<ASTMethodDeclaration> methodsReturningString = new HashSet<>();\n\n    @Override\n    public Object visit(ASTVariableDeclarator node, Object data) {\n        declaredVariables.put(node.getName(), node.getType());\n        return super.visit(node, data);\n    }\n\n    @Override\n    public Object visit(ASTClassOrInterfaceBody body, Object data) {\n        List<ASTMethodDeclaration> methodDeclarations = body.findDescendantsOfType(ASTMethodDeclaration.class);\n        for (ASTMethodDeclaration methodDeclaration : methodDeclarations) {\n            if (methodReturnsString(methodDeclaration)) {\n                methodsReturningString.add(methodDeclaration);\n            }\n        }\n        return super.visit(body, data);\n    }\n\n    private boolean methodReturnsString(ASTMethodDeclaration methodDeclaration) {\n        ASTType returnType = methodDeclaration.getResultType().getFirstChildOfType(ASTType.class);\n        return returnType != null && String.class.equals(returnType.getType());\n    }\n\n    @Override\n    public Object visit(ASTVariableDeclaratorId node, Object data) {\n        if (isStringVariableDeclarator(node)) {\n            for (NameOccurrence varUsage : node.getUsages()) {\n                NameOccurrence qualifier = getVarUsageQualifier(varUsage);\n                if (isToStringOnStringCall(node, qualifier)) {\n                    addViolation(data, varUsage.getLocation());\n                }\n            }\n        }\n        return data;\n    }\n\n    private boolean isStringVariableDeclarator(ASTVariableDeclaratorId varDeclaratorId) {\n        VariableNameDeclaration varNameDeclaration = varDeclaratorId.getNameDeclaration();\n        return varNameDeclaration != null\n                && TypeHelper.isExactlyAny(varNameDeclaration, String.class, String[].class);\n    }\n\n    private NameOccurrence getVarUsageQualifier(NameOccurrence varUsage) {\n        JavaNameOccurrence jVarUsage = (JavaNameOccurrence) varUsage;\n        return jVarUsage.getNameForWhichThisIsAQualifier();\n    }\n\n    private boolean isToStringOnStringCall(ASTVariableDeclaratorId varDeclaratorId, NameOccurrence qualifier) {\n        if (qualifier != null) {\n            return isNotAMethodReference(qualifier) && isNotAnArrayField(varDeclaratorId, qualifier)\n                    && isToString(qualifier.getImage());\n        }\n        return false;\n    }\n\n    private boolean isNotAnArrayField(ASTVariableDeclaratorId varDeclaratorId, NameOccurrence qualifier) {\n        return !varDeclaratorId.hasArrayType() || isNotAName(qualifier);\n    }\n\n    private boolean isNotAMethodReference(NameOccurrence qualifier) {\n        return isNotA(qualifier, ASTMethodReference.class);\n    }\n\n    private boolean isNotAName(NameOccurrence qualifier) {\n        return isNotA(qualifier, ASTName.class);\n    }\n\n    private boolean isNotA(NameOccurrence qualifier, Class<? extends JavaNode> type) {\n        ScopedNode location = qualifier.getLocation();\n        return location == null || !type.isAssignableFrom(location.getClass());\n    }\n\n    @Override\n    public Object visit(ASTPrimaryExpression primaryExpr, Object data) {\n        if (callsToStringOnMethodReturningString(primaryExpr)) {\n            addViolation(data, primaryExpr);\n        }\n        return super.visit(primaryExpr, data);\n    }\n\n    private boolean callsToStringOnMethodReturningString(ASTPrimaryExpression primaryExpr) {\n        return doesSrcMethodReturnString(primaryExpr) && hasToStringCall(primaryExpr);\n    }\n\n    private boolean doesSrcMethodReturnString(ASTPrimaryExpression primaryExpr) {\n        String srcMethodName = getSrcMethodName(primaryExpr);\n        ASTArguments srcMethodArgs = primaryExpr.getFirstDescendantOfType(ASTArguments.class);\n        if (srcMethodArgs != null) {\n            for (ASTMethodDeclaration methodReturningString : methodsReturningString) {\n                if (methodReturningString.getName().equals(srcMethodName)\n                        && areArgsValidForMethod(srcMethodArgs, methodReturningString)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private String getSrcMethodName(ASTPrimaryExpression primaryExpr) {\n        ASTPrimaryPrefix primaryPrefix = primaryExpr.getFirstDescendantOfType(ASTPrimaryPrefix.class);\n        if (hasNoModifiers(primaryPrefix)) {\n            ASTName name = primaryPrefix.getFirstDescendantOfType(ASTName.class);\n            return name != null ? name.getImage() : null;\n        }\n        ASTPrimarySuffix primarySuffix = primaryExpr.getFirstDescendantOfType(ASTPrimarySuffix.class);\n        return primarySuffix != null ? primarySuffix.getImage() : null;\n    }\n\n    private boolean hasNoModifiers(ASTPrimaryPrefix primaryPrefix) {\n        return !primaryPrefix.usesThisModifier() && !primaryPrefix.usesSuperModifier();\n    }\n\n    private boolean areArgsValidForMethod(ASTArguments args, ASTMethodDeclaration methodDeclaration) {\n        if (args.size() == methodDeclaration.getArity()) {\n            ASTArgumentList argsList = args.getFirstChildOfType(ASTArgumentList.class);\n            return argsList == null || argsMatchMethodParams(argsList, methodDeclaration);\n        }\n        return false;\n    }\n\n    private boolean argsMatchMethodParams(ASTArgumentList argsList, ASTMethodDeclaration methodDeclaration) {\n        Iterator<? extends JavaNode> argsIterator = argsList.children().iterator();\n        ASTFormalParameters methodParams = methodDeclaration.getFormalParameters();\n        for (ASTFormalParameter methodParam : methodParams) {\n            if (argNotMatchesMethodParam(argsIterator.next(), methodParam)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean argNotMatchesMethodParam(JavaNode arg, ASTFormalParameter methodParam) {\n        return !argMatchesMethodParam(arg, methodParam);\n    }\n\n    private boolean argMatchesMethodParam(JavaNode arg, ASTFormalParameter methodParam) {\n        Class<?> argType = getArgumentType(arg);\n        Class<?> paramType = methodParam.getType();\n        return argType != null && paramType.isAssignableFrom(argType);\n    }\n\n    private Class<?> getArgumentType(JavaNode arg) {\n        ASTLiteral literalArg = arg.getFirstDescendantOfType(ASTLiteral.class);\n        if (literalArg == null) {\n            ASTName varName = arg.getFirstDescendantOfType(ASTName.class);\n            return varName != null ? declaredVariables.get(varName.getImage()) : null;\n        }\n        return literalArg.getType();\n    }\n\n    private boolean hasToStringCall(ASTPrimaryExpression primaryExpr) {\n        List<ASTPrimarySuffix> methodCalls = primaryExpr.findDescendantsOfType(ASTPrimarySuffix.class);\n        for (ASTPrimarySuffix methodCall : methodCalls) {\n            String methodName = methodCall.getImage();\n            if (isToString(methodName)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean isToString(String methodName) {\n        return \"toString\".equals(methodName);\n    }\n}\n",
        "diffSourceCodeSet": [
            "private boolean isToStringOnStringCall(ASTVariableDeclaratorId varDeclaratorId, NameOccurrence qualifier) {\n        if (qualifier != null) {\n            return isNotAMethodReference(qualifier) && isNotAnArrayField(varDeclaratorId, qualifier)\n                    && isToString(qualifier.getImage());\n        }\n        return false;\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.java.rule.performance.StringToStringRule#isNotAMethodReference\n methodBody: private boolean isNotAMethodReference(NameOccurrence qualifier) {\nreturn isNotA(qualifier,ASTMethodReference.class);\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.rule.performance.StringToStringRule#isNotAName\n methodBody: private boolean isNotAName(NameOccurrence qualifier) {\nreturn isNotA(qualifier,ASTName.class);\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n    public Object visit(ASTVariableDeclaratorId node, Object data) {\n        if (isStringVariableDeclarator(node)) {\n            for (NameOccurrence varUsage : node.getUsages()) {\n                NameOccurrence qualifier = getVarUsageQualifier(varUsage);\n                if (isToStringOnStringCall(node, qualifier)) {\n                    addViolation(data, varUsage.getLocation());\n                }\n            }\n        }\n        return data;\n    }\nprivate boolean isToStringOnStringCall(ASTVariableDeclaratorId varDeclaratorId, NameOccurrence qualifier) {\n        if (qualifier != null) {\n            return isNotAMethodReference(qualifier) && isNotAnArrayField(varDeclaratorId, qualifier)\n                    && isToString(qualifier.getImage());\n        }\n        return false;\n    }",
        "diffSourceCode": "-   19:     @Override\n-   20:     public Object visit(ASTVariableDeclaratorId node, Object data) {\n-   21:         if (node.getNameDeclaration() == null\n-   22:             || !TypeHelper.isExactlyAny(node.getNameDeclaration(), String.class)\n-   23:                 && !TypeHelper.isExactlyAny(node.getNameDeclaration(), String[].class)) {\n-   24:             return data;\n-   25:         }\n-   26:         boolean isArray = node.isArray();\n-   27:         for (NameOccurrence occ : node.getUsages()) {\n-   28:             JavaNameOccurrence jocc = (JavaNameOccurrence) occ;\n-   29:             NameOccurrence qualifier = jocc.getNameForWhichThisIsAQualifier();\n-   30:             if (qualifier != null) {\n-   31:                 if (!isArray && isNotAMethodReference(qualifier) && qualifier.getImage().indexOf(\"toString\") != -1) {\n-   32:                     addViolation(data, jocc.getLocation());\n-   33:                 } else if (isArray && isNotAName(qualifier) && \"toString\".equals(qualifier.getImage())) {\n-   34:                     addViolation(data, jocc.getLocation());\n-   35:                 }\n-   36:             }\n-   37:         }\n-   38:         return data;\n-   39:     }\n+   19: import net.sourceforge.pmd.lang.java.ast.ASTLiteral;\n+   20: import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;\n+   21: import net.sourceforge.pmd.lang.java.ast.ASTMethodReference;\n+   22: import net.sourceforge.pmd.lang.java.ast.ASTName;\n+   23: import net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;\n+   24: import net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;\n+   25: import net.sourceforge.pmd.lang.java.ast.ASTPrimarySuffix;\n+   26: import net.sourceforge.pmd.lang.java.ast.ASTType;\n+   27: import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclarator;\n+   28: import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;\n+   29: import net.sourceforge.pmd.lang.java.ast.JavaNode;\n+   30: import net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;\n+   31: import net.sourceforge.pmd.lang.java.symboltable.JavaNameOccurrence;\n+   32: import net.sourceforge.pmd.lang.java.symboltable.VariableNameDeclaration;\n+   33: import net.sourceforge.pmd.lang.java.typeresolution.TypeHelper;\n+   34: import net.sourceforge.pmd.lang.symboltable.NameOccurrence;\n+   35: import net.sourceforge.pmd.lang.symboltable.ScopedNode;\n+   36: \n+   37: public class StringToStringRule extends AbstractJavaRule {\n+   38: \n+   39:     private final Map<String, Class<?>> declaredVariables = new HashMap<>();\n+   64:     @Override\n+   65:     public Object visit(ASTVariableDeclaratorId node, Object data) {\n+   66:         if (isStringVariableDeclarator(node)) {\n+   67:             for (NameOccurrence varUsage : node.getUsages()) {\n+   68:                 NameOccurrence qualifier = getVarUsageQualifier(varUsage);\n+   69:                 if (isToStringOnStringCall(node, qualifier)) {\n+   70:                     addViolation(data, varUsage.getLocation());\n+   71:                 }\n+   72:             }\n+   73:         }\n+   74:         return data;\n+   75:     }\n+   88:     private boolean isToStringOnStringCall(ASTVariableDeclaratorId varDeclaratorId, NameOccurrence qualifier) {\n+   89:         if (qualifier != null) {\n+   90:             return isNotAMethodReference(qualifier) && isNotAnArrayField(varDeclaratorId, qualifier)\n+   91:                     && isToString(qualifier.getImage());\n+   92:         }\n+   93:         return false;\n+   94:     }\n",
        "uniqueId": "b48da457016e3342151c5987beb10ffa5b73557f_19_39_88_94_64_75",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 5,
                "covered": 79
            },
            "BRANCH": {
                "missed": 2,
                "covered": 20
            },
            "LINE": {
                "missed": 1,
                "covered": 14
            },
            "COMPLEXITY": {
                "missed": 2,
                "covered": 10
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic createFactory(languageRegistry LanguageRegistry, classLoader ClassLoader, minimumPriority RulePriority, warnDeprecated boolean, enableCompatibility boolean) : RuleSetFactory extracted from public createFactory(classLoader ClassLoader, minimumPriority RulePriority, warnDeprecated boolean, enableCompatibility boolean) : RuleSetFactory in class net.sourceforge.pmd.RulesetsFactoryUtils",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/RulesetsFactoryUtils.java",
                "startLine": 135,
                "endLine": 155,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/RulesetsFactoryUtils.java",
                "startLine": 125,
                "endLine": 144,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/RulesetsFactoryUtils.java",
                "startLine": 146,
                "endLine": 153,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Returns a ruleset factory which uses the provided {@link ClassLoader}\n     * to resolve resource references.\n     *\n     * @param minimumPriority     Minimum priority for rules to be included\n     * @param warnDeprecated      If true, print warnings when deprecated rules are included\n     * @param enableCompatibility If true, rule references to moved rules are mapped to their\n     *                            new location if they are known\n     * @param classLoader         Class loader to load resources\n     *\n     * @return A ruleset factory\n     *\n     * @see #createFactory(PMDConfiguration)\n     */\n    public static RuleSetFactory createFactory(ClassLoader classLoader,\n                                               RulePriority minimumPriority,\n                                               boolean warnDeprecated,\n                                               boolean enableCompatibility) {\n\n        return new RuleSetFactory(new ResourceLoader(classLoader), minimumPriority, warnDeprecated, enableCompatibility);\n    }",
        "filePathBefore": "pmd-core/src/main/java/net/sourceforge/pmd/RulesetsFactoryUtils.java",
        "isPureRefactoring": true,
        "commitId": "1ce585aafb7ef8afa007f33bf0b8f08550c0160d",
        "packageNameBefore": "net.sourceforge.pmd",
        "classNameBefore": "net.sourceforge.pmd.RulesetsFactoryUtils",
        "methodNameBefore": "net.sourceforge.pmd.RulesetsFactoryUtils#createFactory",
        "classSignatureBefore": "public final class RulesetsFactoryUtils ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.RulesetsFactoryUtils#createFactory"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.RulesetsFactoryUtils"
        ],
        "classSignatureBeforeSet": [
            "public final class RulesetsFactoryUtils "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Overlapped refactoring - can be identical by undoing the overlapped refactoring\n- Add Parameter-",
                "description": "Parametrization or Add Parameter on top of the extract method - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd;\n\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.benchmark.TimeTracker;\nimport net.sourceforge.pmd.benchmark.TimedOperation;\nimport net.sourceforge.pmd.benchmark.TimedOperationCategory;\nimport net.sourceforge.pmd.util.ResourceLoader;\n\npublic final class RulesetsFactoryUtils {\n\n    private static final Logger LOG = Logger.getLogger(RulesetsFactoryUtils.class.getName());\n\n    private RulesetsFactoryUtils() {\n    }\n\n    /**\n     * Creates a new rulesets with the given string. The resulting rulesets will\n     * contain all referenced rulesets.\n     *\n     * @param rulesets\n     *            the string with the rulesets to load\n     * @param factory\n     *            the ruleset factory\n     * @return the rulesets\n     * @throws IllegalArgumentException\n     *             if rulesets is empty (means, no rules have been found) or if\n     *             a ruleset couldn't be found.\n     * @deprecated Internal API\n     */\n    @InternalApi\n    @Deprecated\n    public static RuleSets getRuleSets(String rulesets, RuleSetFactory factory) {\n        RuleSets ruleSets = null;\n        try {\n            ruleSets = factory.createRuleSets(rulesets);\n            printRuleNamesInDebug(ruleSets);\n            if (ruleSets.ruleCount() == 0) {\n                String msg = \"No rules found. Maybe you mispelled a rule name? (\" + rulesets + ')';\n                LOG.log(Level.SEVERE, msg);\n                throw new IllegalArgumentException(msg);\n            }\n        } catch (RuleSetNotFoundException rsnfe) {\n            LOG.log(Level.SEVERE, \"Ruleset not found\", rsnfe);\n            throw new IllegalArgumentException(rsnfe);\n        }\n        return ruleSets;\n    }\n\n    /**\n     * See {@link #getRuleSets(String, RuleSetFactory)}. In addition, the\n     * loading of the rules is benchmarked.\n     *\n     * @param rulesets\n     *            the string with the rulesets to load\n     * @param factory\n     *            the ruleset factory\n     * @return the rulesets\n     * @throws IllegalArgumentException\n     *             if rulesets is empty (means, no rules have been found) or if\n     *             a ruleset couldn't be found.\n     * @deprecated Is internal API\n     */\n    @InternalApi\n    @Deprecated\n    public static RuleSets getRuleSetsWithBenchmark(String rulesets, RuleSetFactory factory) {\n        try (TimedOperation to = TimeTracker.startOperation(TimedOperationCategory.LOAD_RULES)) {\n            return getRuleSets(rulesets, factory);\n        }\n    }\n\n    /**\n     * @deprecated Use {@link #createFactory(PMDConfiguration)} or {@link #createFactory(PMDConfiguration, ClassLoader)}\n     */\n    @InternalApi\n    @Deprecated\n    public static RuleSetFactory getRulesetFactory(final PMDConfiguration configuration,\n                                                   final ResourceLoader resourceLoader) {\n        return new RuleSetFactory(resourceLoader, configuration.getMinimumPriority(), true,\n                                  configuration.isRuleSetFactoryCompatibilityEnabled());\n    }\n\n    /**\n     * Returns a ruleset factory which uses the classloader for PMD\n     * classes to resolve resource references.\n     *\n     * @param configuration PMD configuration, contains info about the\n     *                      factory parameters\n     *\n     * @return A ruleset factory\n     *\n     * @see #createFactory(PMDConfiguration, ClassLoader)\n     */\n    public static RuleSetFactory createFactory(final PMDConfiguration configuration) {\n        return createFactory(configuration, RulesetsFactoryUtils.class.getClassLoader());\n    }\n\n    /**\n     * Returns a ruleset factory with default parameters. It doesn't prune\n     * rules based on priority, and doesn't warn for deprecations.\n     *\n     * @return A ruleset factory\n     *\n     * @see #createFactory(PMDConfiguration, ClassLoader)\n     */\n    public static RuleSetFactory defaultFactory() {\n        return new RuleSetFactory();\n    }\n\n    /**\n     * Returns a ruleset factory which uses the provided {@link ClassLoader}\n     * to resolve resource references. It warns for deprecated rule usages.\n     *\n     * @param configuration PMD configuration, contains info about the\n     *                      factory parameters\n     * @param classLoader   Class loader to load resources\n     *\n     * @return A ruleset factory\n     *\n     * @see #createFactory(PMDConfiguration)\n     */\n    public static RuleSetFactory createFactory(final PMDConfiguration configuration, ClassLoader classLoader) {\n        return createFactory(classLoader,\n                             configuration.getMinimumPriority(),\n                             true,\n                             configuration.isRuleSetFactoryCompatibilityEnabled());\n    }\n\n    /**\n     * Returns a ruleset factory which uses the provided {@link ClassLoader}\n     * to resolve resource references.\n     *\n     * @param minimumPriority     Minimum priority for rules to be included\n     * @param warnDeprecated      If true, print warnings when deprecated rules are included\n     * @param enableCompatibility If true, rule references to moved rules are mapped to their\n     *                            new location if they are known\n     * @param classLoader         Class loader to load resources\n     *\n     * @return A ruleset factory\n     *\n     * @see #createFactory(PMDConfiguration)\n     */\n    public static RuleSetFactory createFactory(ClassLoader classLoader,\n                                               RulePriority minimumPriority,\n                                               boolean warnDeprecated,\n                                               boolean enableCompatibility) {\n\n        return new RuleSetFactory(new ResourceLoader(classLoader), minimumPriority, warnDeprecated, enableCompatibility);\n    }\n\n    /**\n     * Returns a ruleset factory which uses the classloader for PMD\n     * classes to resolve resource references.\n     *\n     * @param minimumPriority     Minimum priority for rules to be included\n     * @param warnDeprecated      If true, print warnings when deprecated rules are included\n     * @param enableCompatibility If true, rule references to moved rules are mapped to their\n     *                            new location if they are known\n     *\n     * @return A ruleset factory\n     *\n     * @see #createFactory(PMDConfiguration)\n     */\n    public static RuleSetFactory createFactory(RulePriority minimumPriority,\n                                               boolean warnDeprecated,\n                                               boolean enableCompatibility) {\n\n        return new RuleSetFactory(new ResourceLoader(), minimumPriority, warnDeprecated, enableCompatibility);\n    }\n\n    /**\n     * If in debug modus, print the names of the rules.\n     *\n     * @param rulesets the RuleSets to print\n     */\n    private static void printRuleNamesInDebug(RuleSets rulesets) {\n        if (LOG.isLoggable(Level.FINER)) {\n            for (Rule r : rulesets.getAllRules()) {\n                LOG.finer(\"Loaded rule \" + r.getName());\n            }\n        }\n    }\n}\n",
        "filePathAfter": "pmd-core/src/main/java/net/sourceforge/pmd/RulesetsFactoryUtils.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd;\n\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.benchmark.TimeTracker;\nimport net.sourceforge.pmd.benchmark.TimedOperation;\nimport net.sourceforge.pmd.benchmark.TimedOperationCategory;\nimport net.sourceforge.pmd.lang.LanguageRegistry;\nimport net.sourceforge.pmd.util.ResourceLoader;\n\npublic final class RulesetsFactoryUtils {\n\n    private static final Logger LOG = Logger.getLogger(RulesetsFactoryUtils.class.getName());\n\n    private RulesetsFactoryUtils() {\n    }\n\n    /**\n     * Creates a new rulesets with the given string. The resulting rulesets will\n     * contain all referenced rulesets.\n     *\n     * @param rulesets\n     *            the string with the rulesets to load\n     * @param factory\n     *            the ruleset factory\n     * @return the rulesets\n     * @throws IllegalArgumentException\n     *             if rulesets is empty (means, no rules have been found) or if\n     *             a ruleset couldn't be found.\n     * @deprecated Internal API\n     */\n    @InternalApi\n    @Deprecated\n    public static RuleSets getRuleSets(String rulesets, RuleSetFactory factory) {\n        RuleSets ruleSets = null;\n        try {\n            ruleSets = factory.createRuleSets(rulesets);\n            printRuleNamesInDebug(ruleSets);\n            if (ruleSets.ruleCount() == 0) {\n                String msg = \"No rules found. Maybe you mispelled a rule name? (\" + rulesets + ')';\n                LOG.log(Level.SEVERE, msg);\n                throw new IllegalArgumentException(msg);\n            }\n        } catch (RuleSetNotFoundException rsnfe) {\n            LOG.log(Level.SEVERE, \"Ruleset not found\", rsnfe);\n            throw new IllegalArgumentException(rsnfe);\n        }\n        return ruleSets;\n    }\n\n    /**\n     * See {@link #getRuleSets(String, RuleSetFactory)}. In addition, the\n     * loading of the rules is benchmarked.\n     *\n     * @param rulesets\n     *            the string with the rulesets to load\n     * @param factory\n     *            the ruleset factory\n     * @return the rulesets\n     * @throws IllegalArgumentException\n     *             if rulesets is empty (means, no rules have been found) or if\n     *             a ruleset couldn't be found.\n     * @deprecated Is internal API\n     */\n    @InternalApi\n    @Deprecated\n    public static RuleSets getRuleSetsWithBenchmark(String rulesets, RuleSetFactory factory) {\n        try (TimedOperation to = TimeTracker.startOperation(TimedOperationCategory.LOAD_RULES)) {\n            return getRuleSets(rulesets, factory);\n        }\n    }\n\n    /**\n     * Returns a ruleset factory which uses the classloader for PMD\n     * classes to resolve resource references.\n     *\n     * @param configuration PMD configuration, contains info about the\n     *                      factory parameters\n     *\n     * @return A ruleset factory\n     *\n     * @see #createFactory(PMDConfiguration, ClassLoader)\n     */\n    public static RuleSetFactory createFactory(final PMDConfiguration configuration) {\n        return createFactory(configuration, RulesetsFactoryUtils.class.getClassLoader());\n    }\n\n    /**\n     * Returns a ruleset factory with default parameters. It doesn't prune\n     * rules based on priority, and doesn't warn for deprecations.\n     *\n     * @return A ruleset factory\n     *\n     * @see #createFactory(PMDConfiguration, ClassLoader)\n     */\n    public static RuleSetFactory defaultFactory() {\n        return createFactory(LanguageRegistry.STATIC, RulePriority.LOW, false, true);\n    }\n\n    /**\n     * Returns a ruleset factory which uses the provided {@link ClassLoader}\n     * to resolve resource references. It warns for deprecated rule usages.\n     *\n     * @param configuration PMD configuration, contains info about the\n     *                      factory parameters\n     * @param classLoader   Class loader to load resources\n     *\n     * @return A ruleset factory\n     *\n     * @see #createFactory(PMDConfiguration)\n     */\n    public static RuleSetFactory createFactory(final PMDConfiguration configuration, ClassLoader classLoader) {\n        return createFactory(classLoader,\n                             configuration.getMinimumPriority(),\n                             true,\n                             configuration.isRuleSetFactoryCompatibilityEnabled());\n    }\n\n    /**\n     * Returns a ruleset factory which uses the provided {@link ClassLoader}\n     * to resolve resource references.\n     *\n     * @param minimumPriority     Minimum priority for rules to be included\n     * @param warnDeprecated      If true, print warnings when deprecated rules are included\n     * @param enableCompatibility If true, rule references to moved rules are mapped to their\n     *                            new location if they are known\n     * @param classLoader         Class loader to load resources\n     *\n     * @return A ruleset factory\n     *\n     * @see #createFactory(PMDConfiguration)\n     */\n    public static RuleSetFactory createFactory(ClassLoader classLoader,\n                                               RulePriority minimumPriority,\n                                               boolean warnDeprecated,\n                                               boolean enableCompatibility) {\n        return createFactory(LanguageRegistry.STATIC, classLoader, minimumPriority, warnDeprecated, enableCompatibility);\n    }\n\n    public static RuleSetFactory createFactory(LanguageRegistry languageRegistry,\n                                               ClassLoader classLoader,\n                                               RulePriority minimumPriority,\n                                               boolean warnDeprecated,\n                                               boolean enableCompatibility) {\n\n        return new RuleSetFactory(languageRegistry, new ResourceLoader(classLoader), minimumPriority, warnDeprecated, enableCompatibility);\n    }\n\n    /**\n     * Returns a ruleset factory which uses the classloader for PMD\n     * classes to resolve resource references.\n     *\n     * @param minimumPriority     Minimum priority for rules to be included\n     * @param warnDeprecated      If true, print warnings when deprecated rules are included\n     * @param enableCompatibility If true, rule references to moved rules are mapped to their\n     *                            new location if they are known\n     *\n     * @return A ruleset factory\n     *\n     * @see #createFactory(PMDConfiguration)\n     */\n    public static RuleSetFactory createFactory(RulePriority minimumPriority,\n                                               boolean warnDeprecated,\n                                               boolean enableCompatibility) {\n\n        return createFactory(LanguageRegistry.STATIC, minimumPriority, warnDeprecated, enableCompatibility);\n    }\n\n    public static RuleSetFactory createFactory(LanguageRegistry languageRegistry,\n                                               RulePriority minimumPriority,\n                                               boolean warnDeprecated,\n                                               boolean enableCompatibility) {\n\n        return createFactory(languageRegistry, RulesetsFactoryUtils.class.getClassLoader(), minimumPriority, warnDeprecated, enableCompatibility);\n    }\n\n    /**\n     * If in debug modus, print the names of the rules.\n     *\n     * @param rulesets the RuleSets to print\n     */\n    private static void printRuleNamesInDebug(RuleSets rulesets) {\n        if (LOG.isLoggable(Level.FINER)) {\n            for (Rule r : rulesets.getAllRules()) {\n                LOG.finer(\"Loaded rule \" + r.getName());\n            }\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            "public static RuleSetFactory createFactory(LanguageRegistry languageRegistry,\n                                               ClassLoader classLoader,\n                                               RulePriority minimumPriority,\n                                               boolean warnDeprecated,\n                                               boolean enableCompatibility) {\n\n        return new RuleSetFactory(languageRegistry, new ResourceLoader(classLoader), minimumPriority, warnDeprecated, enableCompatibility);\n    }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "/**\n     * Returns a ruleset factory which uses the provided {@link ClassLoader}\n     * to resolve resource references.\n     *\n     * @param minimumPriority     Minimum priority for rules to be included\n     * @param warnDeprecated      If true, print warnings when deprecated rules are included\n     * @param enableCompatibility If true, rule references to moved rules are mapped to their\n     *                            new location if they are known\n     * @param classLoader         Class loader to load resources\n     *\n     * @return A ruleset factory\n     *\n     * @see #createFactory(PMDConfiguration)\n     */\n    public static RuleSetFactory createFactory(ClassLoader classLoader,\n                                               RulePriority minimumPriority,\n                                               boolean warnDeprecated,\n                                               boolean enableCompatibility) {\n        return createFactory(LanguageRegistry.STATIC, classLoader, minimumPriority, warnDeprecated, enableCompatibility);\n    }\npublic static RuleSetFactory createFactory(LanguageRegistry languageRegistry,\n                                               ClassLoader classLoader,\n                                               RulePriority minimumPriority,\n                                               boolean warnDeprecated,\n                                               boolean enableCompatibility) {\n\n        return new RuleSetFactory(languageRegistry, new ResourceLoader(classLoader), minimumPriority, warnDeprecated, enableCompatibility);\n    }",
        "diffSourceCode": "-  125:      *\n-  126:      * @see #createFactory(PMDConfiguration)\n-  127:      */\n-  128:     public static RuleSetFactory createFactory(final PMDConfiguration configuration, ClassLoader classLoader) {\n-  129:         return createFactory(classLoader,\n-  130:                              configuration.getMinimumPriority(),\n-  131:                              true,\n-  132:                              configuration.isRuleSetFactoryCompatibilityEnabled());\n-  133:     }\n-  134: \n-  135:     /**\n-  136:      * Returns a ruleset factory which uses the provided {@link ClassLoader}\n-  137:      * to resolve resource references.\n-  138:      *\n-  139:      * @param minimumPriority     Minimum priority for rules to be included\n-  140:      * @param warnDeprecated      If true, print warnings when deprecated rules are included\n-  141:      * @param enableCompatibility If true, rule references to moved rules are mapped to their\n-  142:      *                            new location if they are known\n-  143:      * @param classLoader         Class loader to load resources\n-  144:      *\n-  145:      * @return A ruleset factory\n-  146:      *\n-  147:      * @see #createFactory(PMDConfiguration)\n-  148:      */\n-  149:     public static RuleSetFactory createFactory(ClassLoader classLoader,\n-  150:                                                RulePriority minimumPriority,\n-  151:                                                boolean warnDeprecated,\n-  152:                                                boolean enableCompatibility) {\n-  153: \n-  154:         return new RuleSetFactory(new ResourceLoader(classLoader), minimumPriority, warnDeprecated, enableCompatibility);\n-  155:     }\n+  125:     /**\n+  126:      * Returns a ruleset factory which uses the provided {@link ClassLoader}\n+  127:      * to resolve resource references.\n+  128:      *\n+  129:      * @param minimumPriority     Minimum priority for rules to be included\n+  130:      * @param warnDeprecated      If true, print warnings when deprecated rules are included\n+  131:      * @param enableCompatibility If true, rule references to moved rules are mapped to their\n+  132:      *                            new location if they are known\n+  133:      * @param classLoader         Class loader to load resources\n+  134:      *\n+  135:      * @return A ruleset factory\n+  136:      *\n+  137:      * @see #createFactory(PMDConfiguration)\n+  138:      */\n+  139:     public static RuleSetFactory createFactory(ClassLoader classLoader,\n+  140:                                                RulePriority minimumPriority,\n+  141:                                                boolean warnDeprecated,\n+  142:                                                boolean enableCompatibility) {\n+  143:         return createFactory(LanguageRegistry.STATIC, classLoader, minimumPriority, warnDeprecated, enableCompatibility);\n+  144:     }\n+  145: \n+  146:     public static RuleSetFactory createFactory(LanguageRegistry languageRegistry,\n+  147:                                                ClassLoader classLoader,\n+  148:                                                RulePriority minimumPriority,\n+  149:                                                boolean warnDeprecated,\n+  150:                                                boolean enableCompatibility) {\n+  151: \n+  152:         return new RuleSetFactory(languageRegistry, new ResourceLoader(classLoader), minimumPriority, warnDeprecated, enableCompatibility);\n+  153:     }\n+  154: \n+  155:     /**\n",
        "uniqueId": "1ce585aafb7ef8afa007f33bf0b8f08550c0160d_135_155_146_153_125_144",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 10
            },
            "LINE": {
                "missed": 0,
                "covered": 1
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic defaultFactory() : RuleSetFactory extracted from private loadRuleSet(ruleSetFilename String) : RuleSet in class net.sourceforge.pmd.RuleSetFactoryDuplicatedRuleLoggingTest & moved to class net.sourceforge.pmd.RulesetsFactoryUtils",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/RuleSetFactoryDuplicatedRuleLoggingTest.java",
                "startLine": 77,
                "endLine": 80,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/RuleSetFactoryDuplicatedRuleLoggingTest.java",
                "startLine": 77,
                "endLine": 80,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/RuleSetFactoryDuplicatedRuleLoggingTest.java",
                "startLine": 101,
                "endLine": 111,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private RuleSet loadRuleSet(String ruleSetFilename) throws RuleSetNotFoundException {\n        RuleSetFactory rsf = new RuleSetFactory();\n        return rsf.createRuleSet(\"net/sourceforge/pmd/rulesets/duplicatedRuleLoggingTest/\" + ruleSetFilename);\n    }",
        "filePathBefore": "pmd-core/src/test/java/net/sourceforge/pmd/RuleSetFactoryDuplicatedRuleLoggingTest.java",
        "isPureRefactoring": true,
        "commitId": "05870c98cc05805d6272d12f5080afad3a14e2b6",
        "packageNameBefore": "net.sourceforge.pmd",
        "classNameBefore": "net.sourceforge.pmd.RuleSetFactoryDuplicatedRuleLoggingTest",
        "methodNameBefore": "net.sourceforge.pmd.RuleSetFactoryDuplicatedRuleLoggingTest#loadRuleSet",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.RuleSetFactory#createRuleSet\n methodBody: private RuleSet createRuleSet(RuleSetReferenceId ruleSetReferenceId, boolean withDeprecatedRuleReferences)\n            throws RuleSetNotFoundException {\nreturn parseRuleSetNode(ruleSetReferenceId,withDeprecatedRuleReferences);\n}",
        "classSignatureBefore": "public class RuleSetFactoryDuplicatedRuleLoggingTest ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.RuleSetFactoryDuplicatedRuleLoggingTest#loadRuleSet"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.RuleSetFactoryDuplicatedRuleLoggingTest"
        ],
        "classSignatureBeforeSet": [
            "public class RuleSetFactoryDuplicatedRuleLoggingTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertTrue;\n\nimport org.junit.Test;\nimport org.junit.rules.ExpectedException;\n\nimport net.sourceforge.pmd.junit.JavaUtilLoggingRule;\nimport net.sourceforge.pmd.junit.LocaleRule;\n\npublic class RuleSetFactoryDuplicatedRuleLoggingTest {\n    @org.junit.Rule\n    public ExpectedException ex = ExpectedException.none();\n\n    @org.junit.Rule\n    public LocaleRule localeRule = LocaleRule.en();\n\n    @org.junit.Rule\n    public JavaUtilLoggingRule logging = new JavaUtilLoggingRule(RuleSetFactory.class.getName());\n\n    @Test\n    public void duplicatedRuleReferenceShouldWarn() throws RuleSetNotFoundException {\n        RuleSet ruleset = loadRuleSet(\"duplicatedRuleReference.xml\");\n\n        assertEquals(1, ruleset.getRules().size());\n        Rule mockRule = ruleset.getRuleByName(\"DummyBasicMockRule\");\n        assertNotNull(mockRule);\n        assertEquals(RulePriority.MEDIUM, mockRule.getPriority());\n        assertTrue(logging.getLog().contains(\"The rule DummyBasicMockRule is referenced multiple times in \\\"Custom Rules\\\". \"\n                + \"Only the last rule configuration is used.\"));\n    }\n\n    @Test\n    public void duplicatedRuleReferenceWithOverrideShouldNotWarn() throws RuleSetNotFoundException {\n        RuleSet ruleset = loadRuleSet(\"duplicatedRuleReferenceWithOverride.xml\");\n\n        assertEquals(2, ruleset.getRules().size());\n        Rule mockRule = ruleset.getRuleByName(\"DummyBasicMockRule\");\n        assertNotNull(mockRule);\n        assertEquals(RulePriority.HIGH, mockRule.getPriority());\n        assertNotNull(ruleset.getRuleByName(\"SampleXPathRule\"));\n        assertTrue(logging.getLog().isEmpty());\n    }\n\n    @Test\n    public void duplicatedRuleReferenceWithOverrideBeforeShouldNotWarn() throws RuleSetNotFoundException {\n        RuleSet ruleset = loadRuleSet(\"duplicatedRuleReferenceWithOverrideBefore.xml\");\n\n        assertEquals(2, ruleset.getRules().size());\n        Rule mockRule = ruleset.getRuleByName(\"DummyBasicMockRule\");\n        assertNotNull(mockRule);\n        assertEquals(RulePriority.HIGH, mockRule.getPriority());\n        assertNotNull(ruleset.getRuleByName(\"SampleXPathRule\"));\n        assertTrue(logging.getLog().isEmpty());\n    }\n\n    @Test\n    public void multipleDuplicates() throws RuleSetNotFoundException {\n        RuleSet ruleset = loadRuleSet(\"multipleDuplicates.xml\");\n\n        assertEquals(2, ruleset.getRules().size());\n        Rule mockRule = ruleset.getRuleByName(\"DummyBasicMockRule\");\n        assertNotNull(mockRule);\n        assertEquals(RulePriority.MEDIUM_HIGH, mockRule.getPriority());\n        assertNotNull(ruleset.getRuleByName(\"SampleXPathRule\"));\n        assertTrue(logging.getLog().contains(\"The rule DummyBasicMockRule is referenced multiple times in \\\"Custom Rules\\\". \"\n                + \"Only the last rule configuration is used.\"));\n        assertTrue(logging.getLog().contains(\"The ruleset rulesets/dummy/basic.xml is referenced multiple times in \\\"Custom Rules\\\".\"));\n    }\n\n    private RuleSet loadRuleSet(String ruleSetFilename) throws RuleSetNotFoundException {\n        RuleSetFactory rsf = new RuleSetFactory();\n        return rsf.createRuleSet(\"net/sourceforge/pmd/rulesets/duplicatedRuleLoggingTest/\" + ruleSetFilename);\n    }\n}\n",
        "filePathAfter": "pmd-core/src/test/java/net/sourceforge/pmd/RuleSetFactoryDuplicatedRuleLoggingTest.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertTrue;\n\nimport org.junit.Test;\nimport org.junit.rules.ExpectedException;\n\nimport net.sourceforge.pmd.junit.JavaUtilLoggingRule;\nimport net.sourceforge.pmd.junit.LocaleRule;\n\npublic class RuleSetFactoryDuplicatedRuleLoggingTest {\n    @org.junit.Rule\n    public ExpectedException ex = ExpectedException.none();\n\n    @org.junit.Rule\n    public LocaleRule localeRule = LocaleRule.en();\n\n    @org.junit.Rule\n    public JavaUtilLoggingRule logging = new JavaUtilLoggingRule(RuleSetFactory.class.getName());\n\n    @Test\n    public void duplicatedRuleReferenceShouldWarn() throws RuleSetNotFoundException {\n        RuleSet ruleset = loadRuleSet(\"duplicatedRuleReference.xml\");\n\n        assertEquals(1, ruleset.getRules().size());\n        Rule mockRule = ruleset.getRuleByName(\"DummyBasicMockRule\");\n        assertNotNull(mockRule);\n        assertEquals(RulePriority.MEDIUM, mockRule.getPriority());\n        assertTrue(logging.getLog().contains(\"The rule DummyBasicMockRule is referenced multiple times in \\\"Custom Rules\\\". \"\n                + \"Only the last rule configuration is used.\"));\n    }\n\n    @Test\n    public void duplicatedRuleReferenceWithOverrideShouldNotWarn() throws RuleSetNotFoundException {\n        RuleSet ruleset = loadRuleSet(\"duplicatedRuleReferenceWithOverride.xml\");\n\n        assertEquals(2, ruleset.getRules().size());\n        Rule mockRule = ruleset.getRuleByName(\"DummyBasicMockRule\");\n        assertNotNull(mockRule);\n        assertEquals(RulePriority.HIGH, mockRule.getPriority());\n        assertNotNull(ruleset.getRuleByName(\"SampleXPathRule\"));\n        assertTrue(logging.getLog().isEmpty());\n    }\n\n    @Test\n    public void duplicatedRuleReferenceWithOverrideBeforeShouldNotWarn() throws RuleSetNotFoundException {\n        RuleSet ruleset = loadRuleSet(\"duplicatedRuleReferenceWithOverrideBefore.xml\");\n\n        assertEquals(2, ruleset.getRules().size());\n        Rule mockRule = ruleset.getRuleByName(\"DummyBasicMockRule\");\n        assertNotNull(mockRule);\n        assertEquals(RulePriority.HIGH, mockRule.getPriority());\n        assertNotNull(ruleset.getRuleByName(\"SampleXPathRule\"));\n        assertTrue(logging.getLog().isEmpty());\n    }\n\n    @Test\n    public void multipleDuplicates() throws RuleSetNotFoundException {\n        RuleSet ruleset = loadRuleSet(\"multipleDuplicates.xml\");\n\n        assertEquals(2, ruleset.getRules().size());\n        Rule mockRule = ruleset.getRuleByName(\"DummyBasicMockRule\");\n        assertNotNull(mockRule);\n        assertEquals(RulePriority.MEDIUM_HIGH, mockRule.getPriority());\n        assertNotNull(ruleset.getRuleByName(\"SampleXPathRule\"));\n        assertTrue(logging.getLog().contains(\"The rule DummyBasicMockRule is referenced multiple times in \\\"Custom Rules\\\". \"\n                + \"Only the last rule configuration is used.\"));\n        assertTrue(logging.getLog().contains(\"The ruleset rulesets/dummy/basic.xml is referenced multiple times in \\\"Custom Rules\\\".\"));\n    }\n\n    private RuleSet loadRuleSet(String ruleSetFilename) throws RuleSetNotFoundException {\n        RuleSetFactory rsf = RulesetsFactoryUtils.defaultFactory();\n        return rsf.createRuleSet(\"net/sourceforge/pmd/rulesets/duplicatedRuleLoggingTest/\" + ruleSetFilename);\n    }\n}\n",
        "diffSourceCodeSet": [
            ""
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.RuleSetFactory#createRuleSet\n methodBody: private RuleSet createRuleSet(RuleSetReferenceId ruleSetReferenceId, boolean withDeprecatedRuleReferences)\n            throws RuleSetNotFoundException {\nreturn parseRuleSetNode(ruleSetReferenceId,withDeprecatedRuleReferences);\n}"
        ],
        "sourceCodeAfterRefactoring": "private RuleSet loadRuleSet(String ruleSetFilename) throws RuleSetNotFoundException {\n        RuleSetFactory rsf = RulesetsFactoryUtils.defaultFactory();\n        return rsf.createRuleSet(\"net/sourceforge/pmd/rulesets/duplicatedRuleLoggingTest/\" + ruleSetFilename);\n    }\n",
        "diffSourceCode": "    77:     private RuleSet loadRuleSet(String ruleSetFilename) throws RuleSetNotFoundException {\n-   78:         RuleSetFactory rsf = new RuleSetFactory();\n+   78:         RuleSetFactory rsf = RulesetsFactoryUtils.defaultFactory();\n    79:         return rsf.createRuleSet(\"net/sourceforge/pmd/rulesets/duplicatedRuleLoggingTest/\" + ruleSetFilename);\n    80:     }\n",
        "uniqueId": "05870c98cc05805d6272d12f5080afad3a14e2b6_77_80_101_111_77_80",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic defaultFactory() : RuleSetFactory extracted from public testExclusion() : void in class net.sourceforge.pmd.RuleSetFactoryCompatibilityTest & moved to class net.sourceforge.pmd.RulesetsFactoryUtils",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/RuleSetFactoryCompatibilityTest.java",
                "startLine": 60,
                "endLine": 76,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/RuleSetFactoryCompatibilityTest.java",
                "startLine": 60,
                "endLine": 76,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/RuleSetFactoryCompatibilityTest.java",
                "startLine": 101,
                "endLine": 111,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n    public void testExclusion() throws Exception {\n        final String ruleset = \"<?xml version=\\\"1.0\\\"?>\\n\" + \"\\n\" + \"<ruleset name=\\\"Test\\\"\\n\"\n                + \"    xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                + \"    xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                + \"  <description>Test</description>\\n\" + \"\\n\" + \" <rule ref=\\\"rulesets/dummy/basic.xml\\\">\\n\"\n                + \"   <exclude name=\\\"OldNameOfSampleXPathRule\\\"/>\\n\" + \" </rule>\\n\" + \"</ruleset>\\n\";\n\n        RuleSetFactory factory = new RuleSetFactory();\n        factory.getCompatibilityFilter().addFilterRuleRenamed(\"dummy\", \"basic\", \"OldNameOfSampleXPathRule\",\n                \"SampleXPathRule\");\n\n        RuleSet createdRuleSet = createRulesetFromString(ruleset, factory);\n        Assert.assertNotNull(createdRuleSet.getRuleByName(\"DummyBasicMockRule\"));\n        Assert.assertNull(createdRuleSet.getRuleByName(\"SampleXPathRule\"));\n    }",
        "filePathBefore": "pmd-core/src/test/java/net/sourceforge/pmd/RuleSetFactoryCompatibilityTest.java",
        "isPureRefactoring": true,
        "commitId": "05870c98cc05805d6272d12f5080afad3a14e2b6",
        "packageNameBefore": "net.sourceforge.pmd",
        "classNameBefore": "net.sourceforge.pmd.RuleSetFactoryCompatibilityTest",
        "methodNameBefore": "net.sourceforge.pmd.RuleSetFactoryCompatibilityTest#testExclusion",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.RuleSetFactory#getCompatibilityFilter\n methodBody: RuleSetFactoryCompatibility getCompatibilityFilter() {\nreturn compatibilityFilter;\n}\nmethodSignature: net.sourceforge.pmd.RuleSetFactoryCompatibilityTest#createRulesetFromString\n methodBody: private RuleSet createRulesetFromString(final String ruleset, RuleSetFactory factory)\n            throws RuleSetNotFoundException {\nreturn factory.createRuleSet(new RuleSetReferenceId(null){\n  @Override public InputStream getInputStream(  ResourceLoader resourceLoader) throws RuleSetNotFoundException {\n    return new ByteArrayInputStream(ruleset.getBytes(UTF_8));\n  }\n}\n);\n}",
        "classSignatureBefore": "public class RuleSetFactoryCompatibilityTest ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.RuleSetFactoryCompatibilityTest#testExclusion"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.RuleSetFactoryCompatibilityTest"
        ],
        "classSignatureBeforeSet": [
            "public class RuleSetFactoryCompatibilityTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.nio.charset.Charset;\n\nimport org.apache.commons.io.IOUtils;\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport net.sourceforge.pmd.util.ResourceLoader;\n\npublic class RuleSetFactoryCompatibilityTest {\n    private static final Charset ISO_8859_1 = Charset.forName(\"ISO-8859-1\");\n    private static final Charset UTF_8 = Charset.forName(\"UTF-8\");\n\n    @Test\n    public void testCorrectOldReference() throws Exception {\n        final String ruleset = \"<?xml version=\\\"1.0\\\"?>\\n\" + \"\\n\" + \"<ruleset name=\\\"Test\\\"\\n\"\n                + \"    xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                + \"    xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                + \"  <description>Test</description>\\n\" + \"\\n\"\n                + \" <rule ref=\\\"rulesets/dummy/notexisting.xml/DummyBasicMockRule\\\" />\\n\" + \"</ruleset>\\n\";\n\n        RuleSetFactory factory = new RuleSetFactory();\n        factory.getCompatibilityFilter().addFilterRuleMoved(\"dummy\", \"notexisting\", \"basic\", \"DummyBasicMockRule\");\n\n        RuleSet createdRuleSet = createRulesetFromString(ruleset, factory);\n        Assert.assertNotNull(createdRuleSet.getRuleByName(\"DummyBasicMockRule\"));\n    }\n    \n    @Test\n    public void testCorrectMovedAndRename() throws Exception {\n        final String ruleset = \"<?xml version=\\\"1.0\\\"?>\\n\" + \"\\n\" + \"<ruleset name=\\\"Test\\\"\\n\"\n                + \"    xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                + \"    xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                + \"  <description>Test</description>\\n\" + \"\\n\"\n                + \" <rule ref=\\\"rulesets/dummy/notexisting.xml/OldDummyBasicMockRule\\\" />\\n\" + \"</ruleset>\\n\";\n\n        RuleSetFactoryCompatibility rsfc = new RuleSetFactoryCompatibility();\n        rsfc.addFilterRuleMoved(\"dummy\", \"notexisting\", \"basic\", \"OldDummyBasicMockRule\");\n        rsfc.addFilterRuleRenamed(\"dummy\", \"basic\", \"OldDummyBasicMockRule\", \"NewNameForDummyBasicMockRule\");\n\n        InputStream stream = new ByteArrayInputStream(ruleset.getBytes(ISO_8859_1));\n        Reader filtered = rsfc.filterRuleSetFile(stream);\n        String out = IOUtils.toString(filtered);\n        \n        Assert.assertFalse(out.contains(\"notexisting.xml\"));\n        Assert.assertFalse(out.contains(\"OldDummyBasicMockRule\"));\n        Assert.assertTrue(out.contains(\"<rule ref=\\\"rulesets/dummy/basic.xml/NewNameForDummyBasicMockRule\\\" />\"));\n    }\n\n    @Test\n    public void testExclusion() throws Exception {\n        final String ruleset = \"<?xml version=\\\"1.0\\\"?>\\n\" + \"\\n\" + \"<ruleset name=\\\"Test\\\"\\n\"\n                + \"    xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                + \"    xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                + \"  <description>Test</description>\\n\" + \"\\n\" + \" <rule ref=\\\"rulesets/dummy/basic.xml\\\">\\n\"\n                + \"   <exclude name=\\\"OldNameOfSampleXPathRule\\\"/>\\n\" + \" </rule>\\n\" + \"</ruleset>\\n\";\n\n        RuleSetFactory factory = new RuleSetFactory();\n        factory.getCompatibilityFilter().addFilterRuleRenamed(\"dummy\", \"basic\", \"OldNameOfSampleXPathRule\",\n                \"SampleXPathRule\");\n\n        RuleSet createdRuleSet = createRulesetFromString(ruleset, factory);\n        Assert.assertNotNull(createdRuleSet.getRuleByName(\"DummyBasicMockRule\"));\n        Assert.assertNull(createdRuleSet.getRuleByName(\"SampleXPathRule\"));\n    }\n\n    @Test\n    public void testExclusionRenamedAndMoved() throws Exception {\n        final String ruleset = \"<?xml version=\\\"1.0\\\"?>\\n\" + \"\\n\" + \"<ruleset name=\\\"Test\\\"\\n\"\n                + \"    xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                + \"    xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                + \"  <description>Test</description>\\n\" + \"\\n\"\n                + \" <rule ref=\\\"rulesets/dummy/oldbasic.xml\\\">\\n\"\n                + \"   <exclude name=\\\"OldDummyBasicMockRule\\\"/>\\n\"\n                + \" </rule>\\n\"\n                + \"</ruleset>\\n\";\n\n        RuleSetFactoryCompatibility rsfc = new RuleSetFactoryCompatibility();\n        rsfc.addFilterRuleMovedAndRenamed(\"dummy\", \"oldbasic\", \"OldDummyBasicMockRule\", \"basic\", \"NewNameForDummyBasicMockRule\");\n\n        InputStream stream = new ByteArrayInputStream(ruleset.getBytes(ISO_8859_1));\n        Reader filtered = rsfc.filterRuleSetFile(stream);\n        String out = IOUtils.toString(filtered);\n\n        Assert.assertTrue(out.contains(\"OldDummyBasicMockRule\"));\n    }\n\n    @Test\n    public void testFilter() throws Exception {\n        RuleSetFactoryCompatibility rsfc = new RuleSetFactoryCompatibility();\n        rsfc.addFilterRuleMoved(\"dummy\", \"notexisting\", \"basic\", \"DummyBasicMockRule\");\n        rsfc.addFilterRuleRemoved(\"dummy\", \"basic\", \"DeletedRule\");\n        rsfc.addFilterRuleRenamed(\"dummy\", \"basic\", \"OldNameOfBasicMockRule\", \"NewNameOfBasicMockRule\");\n\n        String in = \"<?xml version=\\\"1.0\\\"?>\\n\" + \"\\n\" + \"<ruleset name=\\\"Test\\\"\\n\"\n                + \"    xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                + \"    xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                + \"  <description>Test</description>\\n\" + \"\\n\"\n                + \" <rule ref=\\\"rulesets/dummy/notexisting.xml/DummyBasicMockRule\\\" />\\n\"\n                + \" <rule ref=\\\"rulesets/dummy/basic.xml/DeletedRule\\\" />\\n\"\n                + \" <rule ref=\\\"rulesets/dummy/basic.xml/OldNameOfBasicMockRule\\\" />\\n\" + \"</ruleset>\\n\";\n        InputStream stream = new ByteArrayInputStream(in.getBytes(ISO_8859_1));\n        Reader filtered = rsfc.filterRuleSetFile(stream);\n        String out = IOUtils.toString(filtered);\n\n        Assert.assertFalse(out.contains(\"notexisting.xml\"));\n        Assert.assertTrue(out.contains(\"<rule ref=\\\"rulesets/dummy/basic.xml/DummyBasicMockRule\\\" />\"));\n\n        Assert.assertFalse(out.contains(\"DeletedRule\"));\n\n        Assert.assertFalse(out.contains(\"OldNameOfBasicMockRule\"));\n        Assert.assertTrue(out.contains(\"<rule ref=\\\"rulesets/dummy/basic.xml/NewNameOfBasicMockRule\\\" />\"));\n    }\n\n    @Test\n    public void testExclusionFilter() throws Exception {\n        RuleSetFactoryCompatibility rsfc = new RuleSetFactoryCompatibility();\n        rsfc.addFilterRuleRenamed(\"dummy\", \"basic\", \"AnotherOldNameOfBasicMockRule\", \"NewNameOfBasicMockRule\");\n\n        String in = \"<?xml version=\\\"1.0\\\"?>\\n\" + \"\\n\" + \"<ruleset name=\\\"Test\\\"\\n\"\n                + \"    xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                + \"    xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                + \"  <description>Test</description>\\n\" + \"\\n\" + \" <rule ref=\\\"rulesets/dummy/basic.xml\\\">\\n\"\n                + \"   <exclude name=\\\"AnotherOldNameOfBasicMockRule\\\"/>\\n\" + \" </rule>\\n\" + \"</ruleset>\\n\";\n        InputStream stream = new ByteArrayInputStream(in.getBytes(ISO_8859_1));\n        Reader filtered = rsfc.filterRuleSetFile(stream);\n        String out = IOUtils.toString(filtered);\n\n        Assert.assertFalse(out.contains(\"OldNameOfBasicMockRule\"));\n        Assert.assertTrue(out.contains(\"<exclude name=\\\"NewNameOfBasicMockRule\\\" />\"));\n    }\n\n    @Test\n    public void testEncoding() {\n        RuleSetFactoryCompatibility rsfc = new RuleSetFactoryCompatibility();\n        String testString;\n\n        testString = \"<?xml version=\\\"1.0\\\" encoding=\\\"ISO-8859-1\\\"?><x></x>\";\n        Assert.assertEquals(\"ISO-8859-1\", rsfc.determineEncoding(testString.getBytes(ISO_8859_1)));\n\n        testString = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><x></x>\";\n        Assert.assertEquals(\"UTF-8\", rsfc.determineEncoding(testString.getBytes(ISO_8859_1)));\n    }\n\n    private RuleSet createRulesetFromString(final String ruleset, RuleSetFactory factory)\n            throws RuleSetNotFoundException {\n        return factory.createRuleSet(new RuleSetReferenceId(null) {\n            @Override\n            public InputStream getInputStream(ResourceLoader resourceLoader) throws RuleSetNotFoundException {\n                return new ByteArrayInputStream(ruleset.getBytes(UTF_8));\n            }\n        });\n    }\n}\n",
        "filePathAfter": "pmd-core/src/test/java/net/sourceforge/pmd/RuleSetFactoryCompatibilityTest.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.nio.charset.Charset;\n\nimport org.apache.commons.io.IOUtils;\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport net.sourceforge.pmd.util.ResourceLoader;\n\npublic class RuleSetFactoryCompatibilityTest {\n    private static final Charset ISO_8859_1 = Charset.forName(\"ISO-8859-1\");\n    private static final Charset UTF_8 = Charset.forName(\"UTF-8\");\n\n    @Test\n    public void testCorrectOldReference() throws Exception {\n        final String ruleset = \"<?xml version=\\\"1.0\\\"?>\\n\" + \"\\n\" + \"<ruleset name=\\\"Test\\\"\\n\"\n                + \"    xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                + \"    xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                + \"  <description>Test</description>\\n\" + \"\\n\"\n                + \" <rule ref=\\\"rulesets/dummy/notexisting.xml/DummyBasicMockRule\\\" />\\n\" + \"</ruleset>\\n\";\n\n        RuleSetFactory factory = RulesetsFactoryUtils.defaultFactory();\n        factory.getCompatibilityFilter().addFilterRuleMoved(\"dummy\", \"notexisting\", \"basic\", \"DummyBasicMockRule\");\n\n        RuleSet createdRuleSet = createRulesetFromString(ruleset, factory);\n        Assert.assertNotNull(createdRuleSet.getRuleByName(\"DummyBasicMockRule\"));\n    }\n    \n    @Test\n    public void testCorrectMovedAndRename() throws Exception {\n        final String ruleset = \"<?xml version=\\\"1.0\\\"?>\\n\" + \"\\n\" + \"<ruleset name=\\\"Test\\\"\\n\"\n                + \"    xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                + \"    xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                + \"  <description>Test</description>\\n\" + \"\\n\"\n                + \" <rule ref=\\\"rulesets/dummy/notexisting.xml/OldDummyBasicMockRule\\\" />\\n\" + \"</ruleset>\\n\";\n\n        RuleSetFactoryCompatibility rsfc = new RuleSetFactoryCompatibility();\n        rsfc.addFilterRuleMoved(\"dummy\", \"notexisting\", \"basic\", \"OldDummyBasicMockRule\");\n        rsfc.addFilterRuleRenamed(\"dummy\", \"basic\", \"OldDummyBasicMockRule\", \"NewNameForDummyBasicMockRule\");\n\n        InputStream stream = new ByteArrayInputStream(ruleset.getBytes(ISO_8859_1));\n        Reader filtered = rsfc.filterRuleSetFile(stream);\n        String out = IOUtils.toString(filtered);\n        \n        Assert.assertFalse(out.contains(\"notexisting.xml\"));\n        Assert.assertFalse(out.contains(\"OldDummyBasicMockRule\"));\n        Assert.assertTrue(out.contains(\"<rule ref=\\\"rulesets/dummy/basic.xml/NewNameForDummyBasicMockRule\\\" />\"));\n    }\n\n    @Test\n    public void testExclusion() throws Exception {\n        final String ruleset = \"<?xml version=\\\"1.0\\\"?>\\n\" + \"\\n\" + \"<ruleset name=\\\"Test\\\"\\n\"\n                + \"    xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                + \"    xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                + \"  <description>Test</description>\\n\" + \"\\n\" + \" <rule ref=\\\"rulesets/dummy/basic.xml\\\">\\n\"\n                + \"   <exclude name=\\\"OldNameOfSampleXPathRule\\\"/>\\n\" + \" </rule>\\n\" + \"</ruleset>\\n\";\n\n        RuleSetFactory factory = RulesetsFactoryUtils.defaultFactory();\n        factory.getCompatibilityFilter().addFilterRuleRenamed(\"dummy\", \"basic\", \"OldNameOfSampleXPathRule\",\n                \"SampleXPathRule\");\n\n        RuleSet createdRuleSet = createRulesetFromString(ruleset, factory);\n        Assert.assertNotNull(createdRuleSet.getRuleByName(\"DummyBasicMockRule\"));\n        Assert.assertNull(createdRuleSet.getRuleByName(\"SampleXPathRule\"));\n    }\n\n    @Test\n    public void testExclusionRenamedAndMoved() throws Exception {\n        final String ruleset = \"<?xml version=\\\"1.0\\\"?>\\n\" + \"\\n\" + \"<ruleset name=\\\"Test\\\"\\n\"\n                + \"    xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                + \"    xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                + \"  <description>Test</description>\\n\" + \"\\n\"\n                + \" <rule ref=\\\"rulesets/dummy/oldbasic.xml\\\">\\n\"\n                + \"   <exclude name=\\\"OldDummyBasicMockRule\\\"/>\\n\"\n                + \" </rule>\\n\"\n                + \"</ruleset>\\n\";\n\n        RuleSetFactoryCompatibility rsfc = new RuleSetFactoryCompatibility();\n        rsfc.addFilterRuleMovedAndRenamed(\"dummy\", \"oldbasic\", \"OldDummyBasicMockRule\", \"basic\", \"NewNameForDummyBasicMockRule\");\n\n        InputStream stream = new ByteArrayInputStream(ruleset.getBytes(ISO_8859_1));\n        Reader filtered = rsfc.filterRuleSetFile(stream);\n        String out = IOUtils.toString(filtered);\n\n        Assert.assertTrue(out.contains(\"OldDummyBasicMockRule\"));\n    }\n\n    @Test\n    public void testFilter() throws Exception {\n        RuleSetFactoryCompatibility rsfc = new RuleSetFactoryCompatibility();\n        rsfc.addFilterRuleMoved(\"dummy\", \"notexisting\", \"basic\", \"DummyBasicMockRule\");\n        rsfc.addFilterRuleRemoved(\"dummy\", \"basic\", \"DeletedRule\");\n        rsfc.addFilterRuleRenamed(\"dummy\", \"basic\", \"OldNameOfBasicMockRule\", \"NewNameOfBasicMockRule\");\n\n        String in = \"<?xml version=\\\"1.0\\\"?>\\n\" + \"\\n\" + \"<ruleset name=\\\"Test\\\"\\n\"\n                + \"    xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                + \"    xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                + \"  <description>Test</description>\\n\" + \"\\n\"\n                + \" <rule ref=\\\"rulesets/dummy/notexisting.xml/DummyBasicMockRule\\\" />\\n\"\n                + \" <rule ref=\\\"rulesets/dummy/basic.xml/DeletedRule\\\" />\\n\"\n                + \" <rule ref=\\\"rulesets/dummy/basic.xml/OldNameOfBasicMockRule\\\" />\\n\" + \"</ruleset>\\n\";\n        InputStream stream = new ByteArrayInputStream(in.getBytes(ISO_8859_1));\n        Reader filtered = rsfc.filterRuleSetFile(stream);\n        String out = IOUtils.toString(filtered);\n\n        Assert.assertFalse(out.contains(\"notexisting.xml\"));\n        Assert.assertTrue(out.contains(\"<rule ref=\\\"rulesets/dummy/basic.xml/DummyBasicMockRule\\\" />\"));\n\n        Assert.assertFalse(out.contains(\"DeletedRule\"));\n\n        Assert.assertFalse(out.contains(\"OldNameOfBasicMockRule\"));\n        Assert.assertTrue(out.contains(\"<rule ref=\\\"rulesets/dummy/basic.xml/NewNameOfBasicMockRule\\\" />\"));\n    }\n\n    @Test\n    public void testExclusionFilter() throws Exception {\n        RuleSetFactoryCompatibility rsfc = new RuleSetFactoryCompatibility();\n        rsfc.addFilterRuleRenamed(\"dummy\", \"basic\", \"AnotherOldNameOfBasicMockRule\", \"NewNameOfBasicMockRule\");\n\n        String in = \"<?xml version=\\\"1.0\\\"?>\\n\" + \"\\n\" + \"<ruleset name=\\\"Test\\\"\\n\"\n                + \"    xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                + \"    xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                + \"  <description>Test</description>\\n\" + \"\\n\" + \" <rule ref=\\\"rulesets/dummy/basic.xml\\\">\\n\"\n                + \"   <exclude name=\\\"AnotherOldNameOfBasicMockRule\\\"/>\\n\" + \" </rule>\\n\" + \"</ruleset>\\n\";\n        InputStream stream = new ByteArrayInputStream(in.getBytes(ISO_8859_1));\n        Reader filtered = rsfc.filterRuleSetFile(stream);\n        String out = IOUtils.toString(filtered);\n\n        Assert.assertFalse(out.contains(\"OldNameOfBasicMockRule\"));\n        Assert.assertTrue(out.contains(\"<exclude name=\\\"NewNameOfBasicMockRule\\\" />\"));\n    }\n\n    @Test\n    public void testEncoding() {\n        RuleSetFactoryCompatibility rsfc = new RuleSetFactoryCompatibility();\n        String testString;\n\n        testString = \"<?xml version=\\\"1.0\\\" encoding=\\\"ISO-8859-1\\\"?><x></x>\";\n        Assert.assertEquals(\"ISO-8859-1\", rsfc.determineEncoding(testString.getBytes(ISO_8859_1)));\n\n        testString = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><x></x>\";\n        Assert.assertEquals(\"UTF-8\", rsfc.determineEncoding(testString.getBytes(ISO_8859_1)));\n    }\n\n    private RuleSet createRulesetFromString(final String ruleset, RuleSetFactory factory)\n            throws RuleSetNotFoundException {\n        return factory.createRuleSet(new RuleSetReferenceId(null) {\n            @Override\n            public InputStream getInputStream(ResourceLoader resourceLoader) throws RuleSetNotFoundException {\n                return new ByteArrayInputStream(ruleset.getBytes(UTF_8));\n            }\n        });\n    }\n}\n",
        "diffSourceCodeSet": [
            "public void testFilter() throws Exception {\n        RuleSetFactoryCompatibility rsfc = new RuleSetFactoryCompatibility();\n        rsfc.addFilterRuleMoved(\"dummy\", \"notexisting\", \"basic\", \"DummyBasicMockRule\");\n        rsfc.addFilterRuleRemoved(\"dummy\", \"basic\", \"DeletedRule\");\n        rsfc.addFilterRuleRenamed(\"dummy\", \"basic\", \"OldNameOfBasicMockRule\", \"NewNameOfBasicMockRule\");\n\n        String in = \"<?xml version=\\\"1.0\\\"?>\\n\" + \"\\n\" + \"<ruleset name=\\\"Test\\\"\\n\"\n                + \"    xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                + \"    xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                + \"  <description>Test</description>\\n\" + \"\\n\""
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.RuleSetFactory#getCompatibilityFilter\n methodBody: RuleSetFactoryCompatibility getCompatibilityFilter() {\nreturn compatibilityFilter;\n}",
            "methodSignature: net.sourceforge.pmd.RuleSetFactoryCompatibilityTest#createRulesetFromString\n methodBody: private RuleSet createRulesetFromString(final String ruleset, RuleSetFactory factory)\n            throws RuleSetNotFoundException {\nreturn factory.createRuleSet(new RuleSetReferenceId(null){\n  @Override public InputStream getInputStream(  ResourceLoader resourceLoader) throws RuleSetNotFoundException {\n    return new ByteArrayInputStream(ruleset.getBytes(UTF_8));\n  }\n}\n);\n}"
        ],
        "sourceCodeAfterRefactoring": "@Test\n    public void testExclusion() throws Exception {\n        final String ruleset = \"<?xml version=\\\"1.0\\\"?>\\n\" + \"\\n\" + \"<ruleset name=\\\"Test\\\"\\n\"\n                + \"    xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                + \"    xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                + \"  <description>Test</description>\\n\" + \"\\n\" + \" <rule ref=\\\"rulesets/dummy/basic.xml\\\">\\n\"\n                + \"   <exclude name=\\\"OldNameOfSampleXPathRule\\\"/>\\n\" + \" </rule>\\n\" + \"</ruleset>\\n\";\n\n        RuleSetFactory factory = RulesetsFactoryUtils.defaultFactory();\n        factory.getCompatibilityFilter().addFilterRuleRenamed(\"dummy\", \"basic\", \"OldNameOfSampleXPathRule\",\n                \"SampleXPathRule\");\n\n        RuleSet createdRuleSet = createRulesetFromString(ruleset, factory);\n        Assert.assertNotNull(createdRuleSet.getRuleByName(\"DummyBasicMockRule\"));\n        Assert.assertNull(createdRuleSet.getRuleByName(\"SampleXPathRule\"));\n    }\npublic void testFilter() throws Exception {\n        RuleSetFactoryCompatibility rsfc = new RuleSetFactoryCompatibility();\n        rsfc.addFilterRuleMoved(\"dummy\", \"notexisting\", \"basic\", \"DummyBasicMockRule\");\n        rsfc.addFilterRuleRemoved(\"dummy\", \"basic\", \"DeletedRule\");\n        rsfc.addFilterRuleRenamed(\"dummy\", \"basic\", \"OldNameOfBasicMockRule\", \"NewNameOfBasicMockRule\");\n\n        String in = \"<?xml version=\\\"1.0\\\"?>\\n\" + \"\\n\" + \"<ruleset name=\\\"Test\\\"\\n\"\n                + \"    xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                + \"    xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                + \"  <description>Test</description>\\n\" + \"\\n\"",
        "diffSourceCode": "    60:     @Test\n    61:     public void testExclusion() throws Exception {\n    62:         final String ruleset = \"<?xml version=\\\"1.0\\\"?>\\n\" + \"\\n\" + \"<ruleset name=\\\"Test\\\"\\n\"\n    63:                 + \"    xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n    64:                 + \"    xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n    65:                 + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n    66:                 + \"  <description>Test</description>\\n\" + \"\\n\" + \" <rule ref=\\\"rulesets/dummy/basic.xml\\\">\\n\"\n    67:                 + \"   <exclude name=\\\"OldNameOfSampleXPathRule\\\"/>\\n\" + \" </rule>\\n\" + \"</ruleset>\\n\";\n    68: \n-   69:         RuleSetFactory factory = new RuleSetFactory();\n+   69:         RuleSetFactory factory = RulesetsFactoryUtils.defaultFactory();\n    70:         factory.getCompatibilityFilter().addFilterRuleRenamed(\"dummy\", \"basic\", \"OldNameOfSampleXPathRule\",\n    71:                 \"SampleXPathRule\");\n    72: \n    73:         RuleSet createdRuleSet = createRulesetFromString(ruleset, factory);\n    74:         Assert.assertNotNull(createdRuleSet.getRuleByName(\"DummyBasicMockRule\"));\n    75:         Assert.assertNull(createdRuleSet.getRuleByName(\"SampleXPathRule\"));\n    76:     }\n   101:     public void testFilter() throws Exception {\n   102:         RuleSetFactoryCompatibility rsfc = new RuleSetFactoryCompatibility();\n   103:         rsfc.addFilterRuleMoved(\"dummy\", \"notexisting\", \"basic\", \"DummyBasicMockRule\");\n   104:         rsfc.addFilterRuleRemoved(\"dummy\", \"basic\", \"DeletedRule\");\n   105:         rsfc.addFilterRuleRenamed(\"dummy\", \"basic\", \"OldNameOfBasicMockRule\", \"NewNameOfBasicMockRule\");\n   106: \n   107:         String in = \"<?xml version=\\\"1.0\\\"?>\\n\" + \"\\n\" + \"<ruleset name=\\\"Test\\\"\\n\"\n   108:                 + \"    xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n   109:                 + \"    xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n   110:                 + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n   111:                 + \"  <description>Test</description>\\n\" + \"\\n\"\n",
        "uniqueId": "05870c98cc05805d6272d12f5080afad3a14e2b6_60_76_101_111_60_76",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic performAnalysisAndCollectReport() : Report extracted from public performAnalysis() : Report in class net.sourceforge.pmd.PmdAnalysis",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/PmdAnalysisBuilder.java",
                "startLine": 153,
                "endLine": 168,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/PmdAnalysis.java",
                "startLine": 153,
                "endLine": 161,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/PmdAnalysis.java",
                "startLine": 163,
                "endLine": 179,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Run PMD with the current state of this instance. This will start\n     * and finish the registered renderers. All files collected in the\n     * {@linkplain #files() file collector} are processed. Returns the\n     * output report.\n     */\n    public Report performAnalysis() {\n        try (FileCollector files = collector) {\n            files.filterLanguages(getApplicableLanguages());\n            List<DataSource> dataSources = FileCollectionUtil.collectorToDataSource(files);\n            startRenderers();\n            Report report = performAnalysisImpl(dataSources);\n            finishRenderers();\n            return report;\n        }\n    }",
        "filePathBefore": "pmd-core/src/main/java/net/sourceforge/pmd/PmdAnalysisBuilder.java",
        "isPureRefactoring": true,
        "commitId": "67b7dde9504ce456e760516af3b733014309fcdf",
        "packageNameBefore": "net.sourceforge.pmd",
        "classNameBefore": "net.sourceforge.pmd.PmdAnalysisBuilder",
        "methodNameBefore": "net.sourceforge.pmd.PmdAnalysisBuilder#performAnalysis",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.PmdAnalysisBuilder#finishRenderers\n methodBody: private void finishRenderers() {\ntry(TimedOperation ignored=TimeTracker.startOperation(TimedOperationCategory.REPORTING))for(Renderer renderer: renderers){tryrenderer.end();\nrenderer.flush();\ncatch(IOException e)logger.errorEx(\"Error while finishing renderer \" + renderer.getName(),e);\n}}\nmethodSignature: net.sourceforge.pmd.PmdAnalysisBuilder#performAnalysisImpl\n methodBody: Report performAnalysisImpl(List<DataSource> sortedFiles) {\ntry(TimedOperation ignored=TimeTracker.startOperation(TimedOperationCategory.FILE_PROCESSING))PMD.encourageToUseIncrementalAnalysis(configuration);\nReport report=new Report();\nreport.addListener(configuration.getAnalysisCache());\nRuleContext ctx=new RuleContext();\nctx.setReport(report);\nnewFileProcessor(configuration).processFiles(new RuleSets(ruleSets),sortedFiles,ctx,renderers);\nconfiguration.getAnalysisCache().persist();\nreturn report;\n}\nmethodSignature: net.sourceforge.pmd.PmdAnalysisBuilder#getApplicableLanguages\n methodBody: private Set<Language> getApplicableLanguages() {\nfinal Set<Language> languages=new HashSet<>();\nfinal LanguageVersionDiscoverer discoverer=configuration.getLanguageVersionDiscoverer();\nfor(RuleSet ruleSet: ruleSets){for(final Rule rule: ruleSet.getRules()){final Language ruleLanguage=rule.getLanguage();\nif(!languages.contains(ruleLanguage)){final LanguageVersion version=discoverer.getDefaultLanguageVersion(ruleLanguage);\nif(RuleSet.applies(rule,version)){languages.add(ruleLanguage);\nlogger.trace(\"Using {0} version ''{1}''\",version.getLanguage().getName(),version.getTerseName());\n}}}}return languages;\n}\nmethodSignature: net.sourceforge.pmd.PmdAnalysisBuilder#startRenderers\n methodBody: private void startRenderers() {\ntry(TimedOperation ignored=TimeTracker.startOperation(TimedOperationCategory.REPORTING))for(Renderer renderer: renderers){tryrenderer.start();\ncatch(IOException e)logger.errorEx(\"Error while starting renderer \" + renderer.getName(),e);\n}}",
        "classSignatureBefore": "public final class PmdAnalysisBuilder implements AutoCloseable ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.PmdAnalysisBuilder#performAnalysis"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.PmdAnalysisBuilder"
        ],
        "classSignatureBeforeSet": [
            "public final class PmdAnalysisBuilder implements AutoCloseable "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.logging.Logger;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.benchmark.TimeTracker;\nimport net.sourceforge.pmd.benchmark.TimedOperation;\nimport net.sourceforge.pmd.benchmark.TimedOperationCategory;\nimport net.sourceforge.pmd.internal.util.FileCollectionUtil;\nimport net.sourceforge.pmd.lang.Language;\nimport net.sourceforge.pmd.lang.LanguageVersion;\nimport net.sourceforge.pmd.lang.LanguageVersionDiscoverer;\nimport net.sourceforge.pmd.processor.AbstractPMDProcessor;\nimport net.sourceforge.pmd.processor.MonoThreadProcessor;\nimport net.sourceforge.pmd.processor.MultiThreadProcessor;\nimport net.sourceforge.pmd.renderers.Renderer;\nimport net.sourceforge.pmd.util.ClasspathClassLoader;\nimport net.sourceforge.pmd.util.IOUtil;\nimport net.sourceforge.pmd.util.datasource.DataSource;\nimport net.sourceforge.pmd.util.document.FileCollector;\nimport net.sourceforge.pmd.util.log.PmdLogger;\nimport net.sourceforge.pmd.util.log.PmdLogger.Level;\nimport net.sourceforge.pmd.util.log.SimplePmdLogger;\n\n/**\n * Main programmatic API of PMD. Create and configure a {@link PMDConfiguration},\n * then use {@link #create(PMDConfiguration)} to obtain an instance.\n * You can perform additional configuration on the instance, eg adding\n * files to process, or additional rulesets and renderers. Then, call\n * {@link #performAnalysis()}. Example:\n * <pre>{@code\n *   PMDConfiguration config = new PMDConfiguration();\n *   config.setDefaultLanguageVersion(LanguageRegistry.findLanguageVersionByTerseName(\"java 11\"));\n *   config.setInputPaths(\"src/main/java\");\n *   config.prependClasspath(\"target/classes\");\n *   config.setMinimumPriority(RulePriority.HIGH);\n *   config.setRuleSets(\"rulesets/java/quickstart.xml\");\n *   config.setReportFormat(\"xml\");\n *\n *   try (PmdAnalysisBuilder pmd = PmdAnalysisBuilder.create(config)) {\n *     pmd.performAnalysis();\n *   }\n * }</pre>\n *\n */\npublic final class PmdAnalysisBuilder implements AutoCloseable {\n\n    private final FileCollector collector;\n    private final List<Renderer> renderers = new ArrayList<>();\n    private final List<RuleSet> ruleSets = new ArrayList<>();\n    private final PMDConfiguration configuration;\n    private final SimplePmdLogger logger = new SimplePmdLogger(Logger.getLogger(\"net.sourceforge.pmd\"));\n\n    /**\n     * Constructs a new instance. The files paths (input files, filelist,\n     * exclude list, etc) given in the configuration are collected into\n     * the file collector ({@link #files()}), but more can be added\n     * programmatically using the file collector.\n     */\n    private PmdAnalysisBuilder(PMDConfiguration config) {\n        this.configuration = config;\n        this.collector = FileCollector.newCollector(\n            config.getLanguageVersionDiscoverer(),\n            logger\n        );\n        final Level logLevel = configuration.isDebug() ? Level.TRACE : Level.INFO;\n        this.logger.setLevel(logLevel);\n    }\n\n    /**\n     * Constructs a new instance from a configuration.\n     *\n     * <ul>\n     * <li> The files paths (input files, filelist,\n     * exclude list, etc) are explored and the files to analyse are\n     * collected into the file collector ({@link #files()}).\n     * More can be added programmatically using the file collector.\n     * <li>The rulesets given in the configuration are loaded ({@link PMDConfiguration#getRuleSets()})\n     * <li>A renderer corresponding to the parameters of the configuration\n     * is created and added (but not started).\n     * </ul>\n     */\n    public static PmdAnalysisBuilder create(PMDConfiguration config) {\n        PmdAnalysisBuilder builder = new PmdAnalysisBuilder(config);\n\n        // note: do not filter files by language\n        // they could be ignored later. The problem is if you call\n        // addRuleSet later, then you could be enabling new languages\n        // So the files should not be pruned in advance\n        FileCollectionUtil.collectFiles(config, builder.files());\n\n        Renderer renderer = config.createRenderer();\n        renderer.setReportFile(config.getReportFile());\n        builder.addRenderer(renderer);\n\n        final RuleSetLoader ruleSetLoader = RuleSetLoader.fromPmdConfig(config);\n        final RuleSets ruleSets = RulesetsFactoryUtils.getRuleSetsWithBenchmark(config.getRuleSets(), ruleSetLoader.toFactory());\n        if (ruleSets != null) {\n            for (RuleSet ruleSet : ruleSets.getAllRuleSets()) {\n                builder.addRuleSet(ruleSet);\n            }\n        }\n\n        return builder;\n    }\n\n    @InternalApi\n    static PmdAnalysisBuilder createWithoutCollectingFiles(PMDConfiguration config) {\n        return new PmdAnalysisBuilder(config);\n    }\n\n    /**\n     * Returns the file collector for the analysed sources.\n     */\n    public FileCollector files() {\n        return collector; // todo user can close collector programmatically\n    }\n\n    /**\n     * Add a new renderer. The given renderer must already be started.\n     *\n     * @throws NullPointerException If the parameter is null\n     */\n    public void addRenderer(Renderer renderer) {\n        this.renderers.add(Objects.requireNonNull(renderer));\n    }\n\n    /**\n     * Add a new ruleset.\n     *\n     * @throws NullPointerException If the parameter is null\n     */\n    public void addRuleSet(RuleSet ruleSet) {\n        this.ruleSets.add(Objects.requireNonNull(ruleSet));\n    }\n\n    public List<RuleSet> getRulesets() {\n        return Collections.unmodifiableList(ruleSets);\n    }\n\n\n    /**\n     * Run PMD with the current state of this instance. This will start\n     * and finish the registered renderers. All files collected in the\n     * {@linkplain #files() file collector} are processed. Returns the\n     * output report.\n     */\n    public Report performAnalysis() {\n        try (FileCollector files = collector) {\n            files.filterLanguages(getApplicableLanguages());\n            List<DataSource> dataSources = FileCollectionUtil.collectorToDataSource(files);\n            startRenderers();\n            Report report = performAnalysisImpl(dataSources);\n            finishRenderers();\n            return report;\n        }\n    }\n\n\n    Report performAnalysisImpl(List<DataSource> sortedFiles) {\n        try (TimedOperation ignored = TimeTracker.startOperation(TimedOperationCategory.FILE_PROCESSING)) {\n            PMD.encourageToUseIncrementalAnalysis(configuration);\n            Report report = new Report();\n            report.addListener(configuration.getAnalysisCache());\n\n            RuleContext ctx = new RuleContext();\n            ctx.setReport(report);\n            newFileProcessor(configuration).processFiles(new RuleSets(ruleSets), sortedFiles, ctx, renderers);\n            configuration.getAnalysisCache().persist();\n            return report;\n        }\n    }\n\n    private void startRenderers() {\n        try (TimedOperation ignored = TimeTracker.startOperation(TimedOperationCategory.REPORTING)) {\n            for (Renderer renderer : renderers) {\n                try {\n                    renderer.start();\n                } catch (IOException e) {\n                    logger.errorEx(\"Error while starting renderer \" + renderer.getName(), e);\n                }\n            }\n        }\n    }\n\n    private void finishRenderers() {\n        try (TimedOperation ignored = TimeTracker.startOperation(TimedOperationCategory.REPORTING)) {\n            for (Renderer renderer : renderers) {\n                try {\n                    renderer.end();\n                    renderer.flush();\n                } catch (IOException e) {\n                    logger.errorEx(\"Error while finishing renderer \" + renderer.getName(), e);\n                }\n            }\n        }\n    }\n\n    private Set<Language> getApplicableLanguages() {\n        final Set<Language> languages = new HashSet<>();\n        final LanguageVersionDiscoverer discoverer = configuration.getLanguageVersionDiscoverer();\n\n        for (RuleSet ruleSet : ruleSets) {\n            for (final Rule rule : ruleSet.getRules()) {\n                final Language ruleLanguage = rule.getLanguage();\n                if (!languages.contains(ruleLanguage)) {\n                    final LanguageVersion version = discoverer.getDefaultLanguageVersion(ruleLanguage);\n                    if (RuleSet.applies(rule, version)) {\n                        languages.add(ruleLanguage);\n                        logger.trace(\"Using {0} version ''{1}''\", version.getLanguage().getName(), version.getTerseName());\n                    }\n                }\n            }\n        }\n        return languages;\n    }\n\n\n    private static AbstractPMDProcessor newFileProcessor(final PMDConfiguration configuration) {\n        return configuration.getThreads() > 0 ? new MultiThreadProcessor(configuration)\n                                              : new MonoThreadProcessor(configuration);\n    }\n\n    public PmdLogger getLog() {\n        return logger;\n    }\n\n    @Override\n    public void close() {\n        collector.close();\n\n        /*\n         * Make sure it's our own classloader before attempting to close it....\n         * Maven + Jacoco provide us with a cloaseable classloader that if closed\n         * will throw a ClassNotFoundException.\n         */\n        if (configuration.getClassLoader() instanceof ClasspathClassLoader) {\n            IOUtil.tryCloseClassLoader(configuration.getClassLoader());\n        }\n    }\n}\n",
        "filePathAfter": "pmd-core/src/main/java/net/sourceforge/pmd/PmdAnalysis.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.logging.Logger;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.benchmark.TimeTracker;\nimport net.sourceforge.pmd.benchmark.TimedOperation;\nimport net.sourceforge.pmd.benchmark.TimedOperationCategory;\nimport net.sourceforge.pmd.internal.util.FileCollectionUtil;\nimport net.sourceforge.pmd.lang.Language;\nimport net.sourceforge.pmd.lang.LanguageVersion;\nimport net.sourceforge.pmd.lang.LanguageVersionDiscoverer;\nimport net.sourceforge.pmd.processor.AbstractPMDProcessor;\nimport net.sourceforge.pmd.processor.MonoThreadProcessor;\nimport net.sourceforge.pmd.processor.MultiThreadProcessor;\nimport net.sourceforge.pmd.renderers.Renderer;\nimport net.sourceforge.pmd.util.ClasspathClassLoader;\nimport net.sourceforge.pmd.util.IOUtil;\nimport net.sourceforge.pmd.util.datasource.DataSource;\nimport net.sourceforge.pmd.util.document.FileCollector;\nimport net.sourceforge.pmd.util.log.PmdLogger;\nimport net.sourceforge.pmd.util.log.PmdLogger.Level;\nimport net.sourceforge.pmd.util.log.SimplePmdLogger;\n\n/**\n * Main programmatic API of PMD. Create and configure a {@link PMDConfiguration},\n * then use {@link #create(PMDConfiguration)} to obtain an instance.\n * You can perform additional configuration on the instance, eg adding\n * files to process, or additional rulesets and renderers. Then, call\n * {@link #performAnalysis()}. Example:\n * <pre>{@code\n *   PMDConfiguration config = new PMDConfiguration();\n *   config.setDefaultLanguageVersion(LanguageRegistry.findLanguageVersionByTerseName(\"java 11\"));\n *   config.setInputPaths(\"src/main/java\");\n *   config.prependClasspath(\"target/classes\");\n *   config.setMinimumPriority(RulePriority.HIGH);\n *   config.setRuleSets(\"rulesets/java/quickstart.xml\");\n *   config.setReportFormat(\"xml\");\n *\n *   try (PmdAnalysis pmd = PmdAnalysis.create(config)) {\n *     pmd.performAnalysis();\n *   }\n * }</pre>\n *\n */\npublic final class PmdAnalysis implements AutoCloseable {\n\n    private final FileCollector collector;\n    private final List<Renderer> renderers = new ArrayList<>();\n    private final List<RuleSet> ruleSets = new ArrayList<>();\n    private final PMDConfiguration configuration;\n    private final SimplePmdLogger logger = new SimplePmdLogger(Logger.getLogger(\"net.sourceforge.pmd\"));\n\n    /**\n     * Constructs a new instance. The files paths (input files, filelist,\n     * exclude list, etc) given in the configuration are collected into\n     * the file collector ({@link #files()}), but more can be added\n     * programmatically using the file collector.\n     */\n    private PmdAnalysis(PMDConfiguration config) {\n        this.configuration = config;\n        this.collector = FileCollector.newCollector(\n            config.getLanguageVersionDiscoverer(),\n            logger\n        );\n        final Level logLevel = configuration.isDebug() ? Level.TRACE : Level.INFO;\n        this.logger.setLevel(logLevel);\n    }\n\n    /**\n     * Constructs a new instance from a configuration.\n     *\n     * <ul>\n     * <li> The files paths (input files, filelist,\n     * exclude list, etc) are explored and the files to analyse are\n     * collected into the file collector ({@link #files()}).\n     * More can be added programmatically using the file collector.\n     * <li>The rulesets given in the configuration are loaded ({@link PMDConfiguration#getRuleSets()})\n     * <li>A renderer corresponding to the parameters of the configuration\n     * is created and added (but not started).\n     * </ul>\n     */\n    public static PmdAnalysis create(PMDConfiguration config) {\n        PmdAnalysis builder = new PmdAnalysis(config);\n\n        // note: do not filter files by language\n        // they could be ignored later. The problem is if you call\n        // addRuleSet later, then you could be enabling new languages\n        // So the files should not be pruned in advance\n        FileCollectionUtil.collectFiles(config, builder.files());\n\n        Renderer renderer = config.createRenderer();\n        renderer.setReportFile(config.getReportFile());\n        builder.addRenderer(renderer);\n\n        final RuleSetLoader ruleSetLoader = RuleSetLoader.fromPmdConfig(config);\n        final RuleSets ruleSets = RulesetsFactoryUtils.getRuleSetsWithBenchmark(config.getRuleSets(), ruleSetLoader.toFactory());\n        if (ruleSets != null) {\n            for (RuleSet ruleSet : ruleSets.getAllRuleSets()) {\n                builder.addRuleSet(ruleSet);\n            }\n        }\n\n        return builder;\n    }\n\n    @InternalApi\n    static PmdAnalysis createWithoutCollectingFiles(PMDConfiguration config) {\n        return new PmdAnalysis(config);\n    }\n\n    /**\n     * Returns the file collector for the analysed sources.\n     */\n    public FileCollector files() {\n        return collector; // todo user can close collector programmatically\n    }\n\n    /**\n     * Add a new renderer. The given renderer must already be started.\n     *\n     * @throws NullPointerException If the parameter is null\n     */\n    public void addRenderer(Renderer renderer) {\n        this.renderers.add(Objects.requireNonNull(renderer));\n    }\n\n    /**\n     * Add a new ruleset.\n     *\n     * @throws NullPointerException If the parameter is null\n     */\n    public void addRuleSet(RuleSet ruleSet) {\n        this.ruleSets.add(Objects.requireNonNull(ruleSet));\n    }\n\n    public List<RuleSet> getRulesets() {\n        return Collections.unmodifiableList(ruleSets);\n    }\n\n\n    /**\n     * Run PMD with the current state of this instance. This will start\n     * and finish the registered renderers. All files collected in the\n     * {@linkplain #files() file collector} are processed. This does not\n     * return a report, for compatibility with PMD 7.\n     */\n    public void performAnalysis() {\n        performAnalysisAndCollectReport();\n    }\n\n    /**\n     * Run PMD with the current state of this instance. This will start\n     * and finish the registered renderers. All files collected in the\n     * {@linkplain #files() file collector} are processed. Returns the\n     * output report.\n     */\n    // TODO PMD 7 @DeprecatedUntil700\n    public Report performAnalysisAndCollectReport() {\n        try (FileCollector files = collector) {\n            files.filterLanguages(getApplicableLanguages());\n            List<DataSource> dataSources = FileCollectionUtil.collectorToDataSource(files);\n            startRenderers();\n            Report report = performAnalysisImpl(dataSources);\n            finishRenderers();\n            return report;\n        }\n    }\n\n\n    Report performAnalysisImpl(List<DataSource> sortedFiles) {\n        try (TimedOperation ignored = TimeTracker.startOperation(TimedOperationCategory.FILE_PROCESSING)) {\n            PMD.encourageToUseIncrementalAnalysis(configuration);\n            Report report = new Report();\n            report.addListener(configuration.getAnalysisCache());\n\n            RuleContext ctx = new RuleContext();\n            ctx.setReport(report);\n            newFileProcessor(configuration).processFiles(new RuleSets(ruleSets), sortedFiles, ctx, renderers);\n            configuration.getAnalysisCache().persist();\n            return report;\n        }\n    }\n\n    private void startRenderers() {\n        try (TimedOperation ignored = TimeTracker.startOperation(TimedOperationCategory.REPORTING)) {\n            for (Renderer renderer : renderers) {\n                try {\n                    renderer.start();\n                } catch (IOException e) {\n                    logger.errorEx(\"Error while starting renderer \" + renderer.getName(), e);\n                }\n            }\n        }\n    }\n\n    private void finishRenderers() {\n        try (TimedOperation ignored = TimeTracker.startOperation(TimedOperationCategory.REPORTING)) {\n            for (Renderer renderer : renderers) {\n                try {\n                    renderer.end();\n                    renderer.flush();\n                } catch (IOException e) {\n                    logger.errorEx(\"Error while finishing renderer \" + renderer.getName(), e);\n                }\n            }\n        }\n    }\n\n    private Set<Language> getApplicableLanguages() {\n        final Set<Language> languages = new HashSet<>();\n        final LanguageVersionDiscoverer discoverer = configuration.getLanguageVersionDiscoverer();\n\n        for (RuleSet ruleSet : ruleSets) {\n            for (final Rule rule : ruleSet.getRules()) {\n                final Language ruleLanguage = rule.getLanguage();\n                if (!languages.contains(ruleLanguage)) {\n                    final LanguageVersion version = discoverer.getDefaultLanguageVersion(ruleLanguage);\n                    if (RuleSet.applies(rule, version)) {\n                        languages.add(ruleLanguage);\n                        logger.trace(\"Using {0} version ''{1}''\", version.getLanguage().getName(), version.getTerseName());\n                    }\n                }\n            }\n        }\n        return languages;\n    }\n\n\n    private static AbstractPMDProcessor newFileProcessor(final PMDConfiguration configuration) {\n        return configuration.getThreads() > 0 ? new MultiThreadProcessor(configuration)\n                                              : new MonoThreadProcessor(configuration);\n    }\n\n    public PmdLogger getLog() {\n        return logger;\n    }\n\n    @Override\n    public void close() {\n        collector.close();\n\n        /*\n         * Make sure it's our own classloader before attempting to close it....\n         * Maven + Jacoco provide us with a cloaseable classloader that if closed\n         * will throw a ClassNotFoundException.\n         */\n        if (configuration.getClassLoader() instanceof ClasspathClassLoader) {\n            IOUtil.tryCloseClassLoader(configuration.getClassLoader());\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * Run PMD with the current state of this instance. This will start\n     * and finish the registered renderers. All files collected in the\n     * {@linkplain #files() file collector} are processed. Returns the\n     * output report.\n     */\n    // TODO PMD 7 @DeprecatedUntil700\n    public Report performAnalysisAndCollectReport() {\n        try (FileCollector files = collector) {\n            files.filterLanguages(getApplicableLanguages());\n            List<DataSource> dataSources = FileCollectionUtil.collectorToDataSource(files);\n            startRenderers();\n            Report report = performAnalysisImpl(dataSources);\n            finishRenderers();\n            return report;\n        }\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.PmdAnalysisBuilder#finishRenderers\n methodBody: private void finishRenderers() {\ntry(TimedOperation ignored=TimeTracker.startOperation(TimedOperationCategory.REPORTING))for(Renderer renderer: renderers){tryrenderer.end();\nrenderer.flush();\ncatch(IOException e)logger.errorEx(\"Error while finishing renderer \" + renderer.getName(),e);\n}}",
            "methodSignature: net.sourceforge.pmd.PmdAnalysisBuilder#performAnalysisImpl\n methodBody: Report performAnalysisImpl(List<DataSource> sortedFiles) {\ntry(TimedOperation ignored=TimeTracker.startOperation(TimedOperationCategory.FILE_PROCESSING))PMD.encourageToUseIncrementalAnalysis(configuration);\nReport report=new Report();\nreport.addListener(configuration.getAnalysisCache());\nRuleContext ctx=new RuleContext();\nctx.setReport(report);\nnewFileProcessor(configuration).processFiles(new RuleSets(ruleSets),sortedFiles,ctx,renderers);\nconfiguration.getAnalysisCache().persist();\nreturn report;\n}",
            "methodSignature: net.sourceforge.pmd.PmdAnalysisBuilder#getApplicableLanguages\n methodBody: private Set<Language> getApplicableLanguages() {\nfinal Set<Language> languages=new HashSet<>();\nfinal LanguageVersionDiscoverer discoverer=configuration.getLanguageVersionDiscoverer();\nfor(RuleSet ruleSet: ruleSets){for(final Rule rule: ruleSet.getRules()){final Language ruleLanguage=rule.getLanguage();\nif(!languages.contains(ruleLanguage)){final LanguageVersion version=discoverer.getDefaultLanguageVersion(ruleLanguage);\nif(RuleSet.applies(rule,version)){languages.add(ruleLanguage);\nlogger.trace(\"Using {0} version ''{1}''\",version.getLanguage().getName(),version.getTerseName());\n}}}}return languages;\n}",
            "methodSignature: net.sourceforge.pmd.PmdAnalysisBuilder#startRenderers\n methodBody: private void startRenderers() {\ntry(TimedOperation ignored=TimeTracker.startOperation(TimedOperationCategory.REPORTING))for(Renderer renderer: renderers){tryrenderer.start();\ncatch(IOException e)logger.errorEx(\"Error while starting renderer \" + renderer.getName(),e);\n}}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Run PMD with the current state of this instance. This will start\n     * and finish the registered renderers. All files collected in the\n     * {@linkplain #files() file collector} are processed. This does not\n     * return a report, for compatibility with PMD 7.\n     */\n    public void performAnalysis() {\n        performAnalysisAndCollectReport();\n    }\n/**\n     * Run PMD with the current state of this instance. This will start\n     * and finish the registered renderers. All files collected in the\n     * {@linkplain #files() file collector} are processed. Returns the\n     * output report.\n     */\n    // TODO PMD 7 @DeprecatedUntil700\n    public Report performAnalysisAndCollectReport() {\n        try (FileCollector files = collector) {\n            files.filterLanguages(getApplicableLanguages());\n            List<DataSource> dataSources = FileCollectionUtil.collectorToDataSource(files);\n            startRenderers();\n            Report report = performAnalysisImpl(dataSources);\n            finishRenderers();\n            return report;\n        }\n    }",
        "diffSourceCode": "   153:     /**\n   154:      * Run PMD with the current state of this instance. This will start\n   155:      * and finish the registered renderers. All files collected in the\n-  156:      * {@linkplain #files() file collector} are processed. Returns the\n-  157:      * output report.\n+  156:      * {@linkplain #files() file collector} are processed. This does not\n+  157:      * return a report, for compatibility with PMD 7.\n   158:      */\n-  159:     public Report performAnalysis() {\n-  160:         try (FileCollector files = collector) {\n-  161:             files.filterLanguages(getApplicableLanguages());\n-  162:             List<DataSource> dataSources = FileCollectionUtil.collectorToDataSource(files);\n-  163:             startRenderers();\n-  164:             Report report = performAnalysisImpl(dataSources);\n-  165:             finishRenderers();\n-  166:             return report;\n-  167:         }\n-  168:     }\n-  169: \n-  170: \n-  171:     Report performAnalysisImpl(List<DataSource> sortedFiles) {\n-  172:         try (TimedOperation ignored = TimeTracker.startOperation(TimedOperationCategory.FILE_PROCESSING)) {\n-  173:             PMD.encourageToUseIncrementalAnalysis(configuration);\n-  174:             Report report = new Report();\n-  175:             report.addListener(configuration.getAnalysisCache());\n-  176: \n-  177:             RuleContext ctx = new RuleContext();\n-  178:             ctx.setReport(report);\n-  179:             newFileProcessor(configuration).processFiles(new RuleSets(ruleSets), sortedFiles, ctx, renderers);\n+  159:     public void performAnalysis() {\n+  160:         performAnalysisAndCollectReport();\n+  161:     }\n+  162: \n+  163:     /**\n+  164:      * Run PMD with the current state of this instance. This will start\n+  165:      * and finish the registered renderers. All files collected in the\n+  166:      * {@linkplain #files() file collector} are processed. Returns the\n+  167:      * output report.\n+  168:      */\n+  169:     // TODO PMD 7 @DeprecatedUntil700\n+  170:     public Report performAnalysisAndCollectReport() {\n+  171:         try (FileCollector files = collector) {\n+  172:             files.filterLanguages(getApplicableLanguages());\n+  173:             List<DataSource> dataSources = FileCollectionUtil.collectorToDataSource(files);\n+  174:             startRenderers();\n+  175:             Report report = performAnalysisImpl(dataSources);\n+  176:             finishRenderers();\n+  177:             return report;\n+  178:         }\n+  179:     }\n",
        "uniqueId": "67b7dde9504ce456e760516af3b733014309fcdf_153_168_163_179_153_161",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 22
            },
            "LINE": {
                "missed": 0,
                "covered": 7
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate assertExecResultImpl(expectedExitCode int, output String, expectedOutput String, expectedReport String) : void extracted from public assertExecutionResult(expectedExitCode int, expectedOutput String, expectedReport String) : void in class net.sourceforge.pmd.it.ExecutionResult",
        "diffLocations": [
            {
                "filePath": "pmd-dist/src/test/java/net/sourceforge/pmd/it/ExecutionResult.java",
                "startLine": 65,
                "endLine": 88,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-dist/src/test/java/net/sourceforge/pmd/it/ExecutionResult.java",
                "startLine": 65,
                "endLine": 76,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-dist/src/test/java/net/sourceforge/pmd/it/ExecutionResult.java",
                "startLine": 102,
                "endLine": 116,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Asserts that the command exited with the expected exit code and that the given expected\n     * output is contained in the actual command output and the given expected report is in the\n     * generated report.\n     *\n     * @param expectedExitCode the exit code, e.g. 0 if no rule violations are expected, or 4 if violations are found\n     * @param expectedOutput the output to search for\n     * @param expectedReport the string to search for tin the report\n     */\n    public void assertExecutionResult(int expectedExitCode, String expectedOutput, String expectedReport) {\n        assertEquals(\"Command exited with wrong code.\\nComplete result:\\n\\n\" + this, expectedExitCode, exitCode);\n        assertNotNull(\"No output found\", output);\n        if (expectedOutput != null && !expectedOutput.isEmpty()) {\n            if (!output.contains(expectedOutput)) {\n                fail(\"Expected output '\" + expectedOutput + \"' not present.\\nComplete result:\\n\\n\" + this);\n            }\n        } else if (expectedOutput != null && expectedOutput.isEmpty()) {\n            assertTrue(\"The output should have been empty.\\nComplete result:\\n\\n\" + this, output.isEmpty());\n        }\n        if (expectedReport != null && !expectedReport.isEmpty()) {\n            assertTrue(\"Expected report '\" + expectedReport + \"'.\\nComplete result:\\n\\n\" + this,\n                    report.contains(expectedReport));\n        }\n    }",
        "filePathBefore": "pmd-dist/src/test/java/net/sourceforge/pmd/it/ExecutionResult.java",
        "isPureRefactoring": true,
        "commitId": "ee1e43a9528382bb586585f89e19e5eea970e916",
        "packageNameBefore": "net.sourceforge.pmd.it",
        "classNameBefore": "net.sourceforge.pmd.it.ExecutionResult",
        "methodNameBefore": "net.sourceforge.pmd.it.ExecutionResult#assertExecutionResult",
        "classSignatureBefore": "public class ExecutionResult ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.it.ExecutionResult#assertExecutionResult"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.it.ExecutionResult"
        ],
        "classSignatureBeforeSet": [
            "public class ExecutionResult "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.it;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\nimport net.sourceforge.pmd.PMD;\n\n/**\n * Collects the result of a command execution in order to verify it.\n *\n * @author Andreas Dangel\n */\npublic class ExecutionResult {\n    private final int exitCode;\n    private final String output;\n    private final String errorOutput;\n    private final String report;\n\n    ExecutionResult(int theExitCode, String theOutput, String theErrorOutput, String theReport) {\n        this.exitCode = theExitCode;\n        this.output = theOutput;\n        this.errorOutput = theErrorOutput;\n        this.report = theReport;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"ExecutionResult:\")\n            .append(PMD.EOL)\n            .append(\" exit code: \").append(exitCode).append(PMD.EOL)\n            .append(\" output:\").append(PMD.EOL).append(output).append(PMD.EOL)\n            .append(\" errorOutput:\").append(PMD.EOL).append(errorOutput).append(PMD.EOL)\n            .append(\" report:\").append(PMD.EOL).append(report).append(PMD.EOL);\n        return sb.toString();\n    }\n\n    /**\n     * Asserts that the command exited with the expected exit code. Any output is ignored.\n     *\n     * @param expectedExitCode the exit code, e.g. 0 if no rule violations are expected, or 4 if violations are found\n     */\n    public void assertExecutionResult(int expectedExitCode) {\n        assertExecutionResult(expectedExitCode, null);\n    }\n\n    /**\n     * Asserts that the command exited with the expected exit code and that the given expected\n     * output is contained in the actual command output.\n     *\n     * @param expectedExitCode the exit code, e.g. 0 if no rule violations are expected, or 4 if violations are found\n     * @param expectedOutput the output to search for\n     */\n    public void assertExecutionResult(int expectedExitCode, String expectedOutput) {\n        assertExecutionResult(expectedExitCode, expectedOutput, null);\n    }\n\n    /**\n     * Asserts that the command exited with the expected exit code and that the given expected\n     * output is contained in the actual command output and the given expected report is in the\n     * generated report.\n     *\n     * @param expectedExitCode the exit code, e.g. 0 if no rule violations are expected, or 4 if violations are found\n     * @param expectedOutput the output to search for\n     * @param expectedReport the string to search for tin the report\n     */\n    public void assertExecutionResult(int expectedExitCode, String expectedOutput, String expectedReport) {\n        assertEquals(\"Command exited with wrong code.\\nComplete result:\\n\\n\" + this, expectedExitCode, exitCode);\n        assertNotNull(\"No output found\", output);\n        if (expectedOutput != null && !expectedOutput.isEmpty()) {\n            if (!output.contains(expectedOutput)) {\n                fail(\"Expected output '\" + expectedOutput + \"' not present.\\nComplete result:\\n\\n\" + this);\n            }\n        } else if (expectedOutput != null && expectedOutput.isEmpty()) {\n            assertTrue(\"The output should have been empty.\\nComplete result:\\n\\n\" + this, output.isEmpty());\n        }\n        if (expectedReport != null && !expectedReport.isEmpty()) {\n            assertTrue(\"Expected report '\" + expectedReport + \"'.\\nComplete result:\\n\\n\" + this,\n                    report.contains(expectedReport));\n        }\n    }\n\n    /**\n     * Asserts that the given error message is not in the error output.\n     * @param errorMessage the error message to search for\n     */\n    public void assertNoError(String errorMessage) {\n        assertFalse(\"Found error message: \" + errorMessage + \".\\nComplete result:\\n\\n\" + this,\n                errorOutput.contains(errorMessage));\n    }\n\n    /**\n     * Asserts that the given error message is not in the report.\n     * @param errorMessage the error message to search for\n     */\n    public void assertNoErrorInReport(String errorMessage) {\n        assertFalse(\"Found error message in report: \" + errorMessage + \".\\nComplete result:\\n\\n\" + this,\n                report.contains(errorMessage));\n    }\n\n    static class Builder {\n        private int exitCode;\n        private String output;\n        private String errorOutput;\n        private String report;\n\n        Builder withExitCode(int exitCode) {\n            this.exitCode = exitCode;\n            return this;\n        }\n\n        Builder withOutput(String output) {\n            this.output = output;\n            return this;\n        }\n\n        Builder withErrorOutput(String errorOutput) {\n            this.errorOutput = errorOutput;\n            return this;\n        }\n\n        Builder withReport(String report) {\n            this.report = report;\n            return this;\n        }\n\n        ExecutionResult build() {\n            return new ExecutionResult(exitCode, output, errorOutput, report);\n        }\n    }\n}\n",
        "filePathAfter": "pmd-dist/src/test/java/net/sourceforge/pmd/it/ExecutionResult.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.it;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\nimport net.sourceforge.pmd.PMD;\n\n/**\n * Collects the result of a command execution in order to verify it.\n *\n * @author Andreas Dangel\n */\npublic class ExecutionResult {\n    private final int exitCode;\n    private final String output;\n    private final String errorOutput;\n    private final String report;\n\n    ExecutionResult(int theExitCode, String theOutput, String theErrorOutput, String theReport) {\n        this.exitCode = theExitCode;\n        this.output = theOutput;\n        this.errorOutput = theErrorOutput;\n        this.report = theReport;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"ExecutionResult:\")\n            .append(PMD.EOL)\n            .append(\" exit code: \").append(exitCode).append(PMD.EOL)\n            .append(\" output:\").append(PMD.EOL).append(output).append(PMD.EOL)\n            .append(\" errorOutput:\").append(PMD.EOL).append(errorOutput).append(PMD.EOL)\n            .append(\" report:\").append(PMD.EOL).append(report).append(PMD.EOL);\n        return sb.toString();\n    }\n\n    /**\n     * Asserts that the command exited with the expected exit code. Any output is ignored.\n     *\n     * @param expectedExitCode the exit code, e.g. 0 if no rule violations are expected, or 4 if violations are found\n     */\n    public void assertExecutionResult(int expectedExitCode) {\n        assertExecutionResult(expectedExitCode, null);\n    }\n\n    /**\n     * Asserts that the command exited with the expected exit code and that the given expected\n     * output is contained in the actual command output.\n     *\n     * @param expectedExitCode the exit code, e.g. 0 if no rule violations are expected, or 4 if violations are found\n     * @param expectedOutput the output to search for\n     */\n    public void assertExecutionResult(int expectedExitCode, String expectedOutput) {\n        assertExecutionResult(expectedExitCode, expectedOutput, null);\n    }\n\n    /**\n     * Asserts that the command exited with the expected exit code and that the given expected\n     * output is contained in the actual command output and the given expected report is in the\n     * generated report.\n     *\n     * @param expectedExitCode the exit code, e.g. 0 if no rule violations are expected, or 4 if violations are found\n     * @param expectedOutput   the output to search for\n     * @param expectedReport   the string to search for tin the report\n     */\n    public void assertExecutionResult(int expectedExitCode, String expectedOutput, String expectedReport) {\n        assertExecResultImpl(expectedExitCode, output, expectedOutput, expectedReport);\n    }\n\n    /**\n     * Asserts that the command exited with the expected exit code and that the given expected\n     * output is contained in the actual command ERROR output, and the given expected report is in the\n     * generated report.\n     *\n     * @param expectedExitCode    the exit code, e.g. 0 if no rule violations are expected, or 4 if violations are found\n     * @param expectedErrorOutput the output to search for in stderr\n     * @param expectedReport      the string to search for tin the report\n     */\n    public void assertExecutionResultErrOutput(int expectedExitCode, String expectedErrorOutput, String expectedReport) {\n        assertExecResultImpl(expectedExitCode, errorOutput, expectedErrorOutput, expectedReport);\n    }\n\n    /**\n     * Asserts that the command exited with the expected exit code and that the given expected\n     * output is contained in the actual command ERROR output.\n     *\n     * @param expectedExitCode    the exit code, e.g. 0 if no rule violations are expected, or 4 if violations are found\n     * @param expectedErrorOutput the output to search for in stderr\n     */\n    public void assertExecutionResultErrOutput(int expectedExitCode, String expectedErrorOutput) {\n        assertExecResultImpl(expectedExitCode, errorOutput, expectedErrorOutput, null);\n    }\n\n    private void assertExecResultImpl(int expectedExitCode, String output, String expectedOutput, String expectedReport) {\n        assertEquals(\"Command exited with wrong code.\\nComplete result:\\n\\n\" + this, expectedExitCode, exitCode);\n        assertNotNull(\"No output found\", output);\n        if (expectedOutput != null && !expectedOutput.isEmpty()) {\n            if (!output.contains(expectedOutput)) {\n                fail(\"Expected output '\" + expectedOutput + \"' not present.\\nComplete result:\\n\\n\" + this);\n            }\n        } else if (expectedOutput != null && expectedOutput.isEmpty()) {\n            assertTrue(\"The output should have been empty.\\nComplete result:\\n\\n\" + this, output.isEmpty());\n        }\n        if (expectedReport != null && !expectedReport.isEmpty()) {\n            assertTrue(\"Expected report '\" + expectedReport + \"'.\\nComplete result:\\n\\n\" + this,\n                       report.contains(expectedReport));\n        }\n    }\n\n    /**\n     * Asserts that the given error message is not in the error output.\n     * @param errorMessage the error message to search for\n     */\n    public void assertNoError(String errorMessage) {\n        assertFalse(\"Found error message: \" + errorMessage + \".\\nComplete result:\\n\\n\" + this,\n                errorOutput.contains(errorMessage));\n    }\n\n    /**\n     * Asserts that the given error message is not in the report.\n     * @param errorMessage the error message to search for\n     */\n    public void assertNoErrorInReport(String errorMessage) {\n        assertFalse(\"Found error message in report: \" + errorMessage + \".\\nComplete result:\\n\\n\" + this,\n                report.contains(errorMessage));\n    }\n\n    static class Builder {\n        private int exitCode;\n        private String output;\n        private String errorOutput;\n        private String report;\n\n        Builder withExitCode(int exitCode) {\n            this.exitCode = exitCode;\n            return this;\n        }\n\n        Builder withOutput(String output) {\n            this.output = output;\n            return this;\n        }\n\n        Builder withErrorOutput(String errorOutput) {\n            this.errorOutput = errorOutput;\n            return this;\n        }\n\n        Builder withReport(String report) {\n            this.report = report;\n            return this;\n        }\n\n        ExecutionResult build() {\n            return new ExecutionResult(exitCode, output, errorOutput, report);\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            "private void assertExecResultImpl(int expectedExitCode, String output, String expectedOutput, String expectedReport) {\n        assertEquals(\"Command exited with wrong code.\\nComplete result:\\n\\n\" + this, expectedExitCode, exitCode);\n        assertNotNull(\"No output found\", output);\n        if (expectedOutput != null && !expectedOutput.isEmpty()) {\n            if (!output.contains(expectedOutput)) {\n                fail(\"Expected output '\" + expectedOutput + \"' not present.\\nComplete result:\\n\\n\" + this);\n            }\n        } else if (expectedOutput != null && expectedOutput.isEmpty()) {\n            assertTrue(\"The output should have been empty.\\nComplete result:\\n\\n\" + this, output.isEmpty());\n        }\n        if (expectedReport != null && !expectedReport.isEmpty()) {\n            assertTrue(\"Expected report '\" + expectedReport + \"'.\\nComplete result:\\n\\n\" + this,\n                       report.contains(expectedReport));\n        }\n    }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "/**\n     * Asserts that the command exited with the expected exit code and that the given expected\n     * output is contained in the actual command output and the given expected report is in the\n     * generated report.\n     *\n     * @param expectedExitCode the exit code, e.g. 0 if no rule violations are expected, or 4 if violations are found\n     * @param expectedOutput   the output to search for\n     * @param expectedReport   the string to search for tin the report\n     */\n    public void assertExecutionResult(int expectedExitCode, String expectedOutput, String expectedReport) {\n        assertExecResultImpl(expectedExitCode, output, expectedOutput, expectedReport);\n    }\nprivate void assertExecResultImpl(int expectedExitCode, String output, String expectedOutput, String expectedReport) {\n        assertEquals(\"Command exited with wrong code.\\nComplete result:\\n\\n\" + this, expectedExitCode, exitCode);\n        assertNotNull(\"No output found\", output);\n        if (expectedOutput != null && !expectedOutput.isEmpty()) {\n            if (!output.contains(expectedOutput)) {\n                fail(\"Expected output '\" + expectedOutput + \"' not present.\\nComplete result:\\n\\n\" + this);\n            }\n        } else if (expectedOutput != null && expectedOutput.isEmpty()) {\n            assertTrue(\"The output should have been empty.\\nComplete result:\\n\\n\" + this, output.isEmpty());\n        }\n        if (expectedReport != null && !expectedReport.isEmpty()) {\n            assertTrue(\"Expected report '\" + expectedReport + \"'.\\nComplete result:\\n\\n\" + this,\n                       report.contains(expectedReport));\n        }\n    }",
        "diffSourceCode": "    65:     /**\n    66:      * Asserts that the command exited with the expected exit code and that the given expected\n    67:      * output is contained in the actual command output and the given expected report is in the\n    68:      * generated report.\n    69:      *\n    70:      * @param expectedExitCode the exit code, e.g. 0 if no rule violations are expected, or 4 if violations are found\n-   71:      * @param expectedOutput the output to search for\n-   72:      * @param expectedReport the string to search for tin the report\n+   71:      * @param expectedOutput   the output to search for\n+   72:      * @param expectedReport   the string to search for tin the report\n    73:      */\n    74:     public void assertExecutionResult(int expectedExitCode, String expectedOutput, String expectedReport) {\n-   75:         assertEquals(\"Command exited with wrong code.\\nComplete result:\\n\\n\" + this, expectedExitCode, exitCode);\n-   76:         assertNotNull(\"No output found\", output);\n-   77:         if (expectedOutput != null && !expectedOutput.isEmpty()) {\n-   78:             if (!output.contains(expectedOutput)) {\n-   79:                 fail(\"Expected output '\" + expectedOutput + \"' not present.\\nComplete result:\\n\\n\" + this);\n-   80:             }\n-   81:         } else if (expectedOutput != null && expectedOutput.isEmpty()) {\n-   82:             assertTrue(\"The output should have been empty.\\nComplete result:\\n\\n\" + this, output.isEmpty());\n-   83:         }\n-   84:         if (expectedReport != null && !expectedReport.isEmpty()) {\n-   85:             assertTrue(\"Expected report '\" + expectedReport + \"'.\\nComplete result:\\n\\n\" + this,\n-   86:                     report.contains(expectedReport));\n-   87:         }\n-   88:     }\n-  102:      */\n-  103:     public void assertNoErrorInReport(String errorMessage) {\n-  104:         assertFalse(\"Found error message in report: \" + errorMessage + \".\\nComplete result:\\n\\n\" + this,\n-  105:                 report.contains(errorMessage));\n-  106:     }\n-  107: \n-  108:     static class Builder {\n-  109:         private int exitCode;\n-  110:         private String output;\n-  111:         private String errorOutput;\n-  112:         private String report;\n-  113: \n-  114:         Builder withExitCode(int exitCode) {\n-  115:             this.exitCode = exitCode;\n-  116:             return this;\n+   75:         assertExecResultImpl(expectedExitCode, output, expectedOutput, expectedReport);\n+   76:     }\n+   77: \n+   78:     /**\n+   79:      * Asserts that the command exited with the expected exit code and that the given expected\n+   80:      * output is contained in the actual command ERROR output, and the given expected report is in the\n+   81:      * generated report.\n+   82:      *\n+   83:      * @param expectedExitCode    the exit code, e.g. 0 if no rule violations are expected, or 4 if violations are found\n+   84:      * @param expectedErrorOutput the output to search for in stderr\n+   85:      * @param expectedReport      the string to search for tin the report\n+   86:      */\n+   87:     public void assertExecutionResultErrOutput(int expectedExitCode, String expectedErrorOutput, String expectedReport) {\n+   88:         assertExecResultImpl(expectedExitCode, errorOutput, expectedErrorOutput, expectedReport);\n+  102:     private void assertExecResultImpl(int expectedExitCode, String output, String expectedOutput, String expectedReport) {\n+  103:         assertEquals(\"Command exited with wrong code.\\nComplete result:\\n\\n\" + this, expectedExitCode, exitCode);\n+  104:         assertNotNull(\"No output found\", output);\n+  105:         if (expectedOutput != null && !expectedOutput.isEmpty()) {\n+  106:             if (!output.contains(expectedOutput)) {\n+  107:                 fail(\"Expected output '\" + expectedOutput + \"' not present.\\nComplete result:\\n\\n\" + this);\n+  108:             }\n+  109:         } else if (expectedOutput != null && expectedOutput.isEmpty()) {\n+  110:             assertTrue(\"The output should have been empty.\\nComplete result:\\n\\n\" + this, output.isEmpty());\n+  111:         }\n+  112:         if (expectedReport != null && !expectedReport.isEmpty()) {\n+  113:             assertTrue(\"Expected report '\" + expectedReport + \"'.\\nComplete result:\\n\\n\" + this,\n+  114:                        report.contains(expectedReport));\n+  115:         }\n+  116:     }\n",
        "uniqueId": "ee1e43a9528382bb586585f89e19e5eea970e916_65_88_102_116_65_76",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Move Method",
        "description": "Move Method\tpackage testViolationCounterOnMulti() : void from class net.sourceforge.pmd.processor.GlobalListenerTest to package testViolationCounterOnMulti() : void from class net.sourceforge.pmd.reporting.GlobalAnalysisListenerTest",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/processor/GlobalListenerTest.java",
                "startLine": 51,
                "endLine": 67,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/reporting/GlobalAnalysisListenerTest.java",
                "startLine": 51,
                "endLine": 67,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n    void testViolationCounterOnMulti() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        config.setThreads(2);\n\n        ViolationCounterListener listener = new GlobalAnalysisListener.ViolationCounterListener();\n\n        MyFooRule mockrule = Mockito.spy(MyFooRule.class);\n        when(mockrule.deepCopy()).thenReturn(mockrule); // the spy cannot track the deep copies\n\n        runPmd(config, listener, mockrule);\n\n        Mockito.verify(mockrule, times(NUM_DATA_SOURCES)).apply(any(), any());\n        assertEquals(2, (int) listener.getResult());\n\n    }",
        "filePathBefore": "pmd-core/src/test/java/net/sourceforge/pmd/processor/GlobalListenerTest.java",
        "isPureRefactoring": true,
        "commitId": "e2866bebf86e86892860dd0e3a01492797fd8ea6",
        "packageNameBefore": "net.sourceforge.pmd.processor",
        "classNameBefore": "net.sourceforge.pmd.processor.GlobalListenerTest",
        "methodNameBefore": "net.sourceforge.pmd.processor.GlobalListenerTest#testViolationCounterOnMulti",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.processor.GlobalListenerTest#runPmd\n methodBody: private void runPmd(PMDConfiguration config, GlobalAnalysisListener listener, Rule rule) {\ntry(PmdAnalysis pmd=PmdAnalysis.create(config))pmd.addRuleSet(RuleSet.forSingleRule(rule));\npmd.files().addSourceFile(\"abc\",\"fname1.dummy\");\npmd.files().addSourceFile(\"abcd\",\"fname2.dummy\");\npmd.files().addSourceFile(\"abcd\",\"fname21.dummy\");\npmd.addListener(listener);\npmd.performAnalysis();\n}\nmethodSignature: net.sourceforge.pmd.processor.GlobalListenerTest#newConfig\n methodBody: private PMDConfiguration newConfig() {\nPMDConfiguration config=new PMDConfiguration();\nconfig.setAnalysisCache(new NoopAnalysisCache());\nconfig.setIgnoreIncrementalAnalysis(true);\nconfig.setThreads(1);\nreturn config;\n}\nmethodSignature: net.sourceforge.pmd.processor.GlobalListenerTest.BrokenRule#apply\n methodBody: public void apply(Node node, RuleContext ctx) {\nthrow new IllegalArgumentException(\"Something happened\");\n}\nmethodSignature: net.sourceforge.pmd.processor.GlobalListenerTest.MyFooRule#apply\n methodBody: public void apply(Node node, RuleContext ctx) {\nif(node.getTextDocument().getDisplayName().contains(\"1\")){ctx.addViolation(node);\n}}",
        "classSignatureBefore": "class GlobalListenerTest ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.processor.GlobalListenerTest#testViolationCounterOnMulti"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.processor.GlobalListenerTest"
        ],
        "classSignatureBeforeSet": [
            "class GlobalListenerTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body",
                "description": "All replacements are variables' type! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.processor;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.spy;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\n\nimport net.sourceforge.pmd.FooRule;\nimport net.sourceforge.pmd.PMDConfiguration;\nimport net.sourceforge.pmd.PmdAnalysis;\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RuleContext;\nimport net.sourceforge.pmd.RuleSet;\nimport net.sourceforge.pmd.cache.AnalysisCache;\nimport net.sourceforge.pmd.cache.NoopAnalysisCache;\nimport net.sourceforge.pmd.lang.ast.FileAnalysisException;\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.reporting.GlobalAnalysisListener;\nimport net.sourceforge.pmd.reporting.GlobalAnalysisListener.ViolationCounterListener;\n\nclass GlobalListenerTest {\n\n    static final int NUM_DATA_SOURCES = 3;\n\n    @Test\n    void testViolationCounter() throws Exception {\n\n        PMDConfiguration config = newConfig();\n\n        ViolationCounterListener listener = new GlobalAnalysisListener.ViolationCounterListener();\n\n        MyFooRule mockrule = Mockito.spy(MyFooRule.class);\n        runPmd(config, listener, mockrule);\n\n        Mockito.verify(mockrule, times(NUM_DATA_SOURCES)).apply(any(), any());\n        assertEquals(2, (int) listener.getResult());\n\n    }\n\n    @Test\n    void testViolationCounterOnMulti() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        config.setThreads(2);\n\n        ViolationCounterListener listener = new GlobalAnalysisListener.ViolationCounterListener();\n\n        MyFooRule mockrule = Mockito.spy(MyFooRule.class);\n        when(mockrule.deepCopy()).thenReturn(mockrule); // the spy cannot track the deep copies\n\n        runPmd(config, listener, mockrule);\n\n        Mockito.verify(mockrule, times(NUM_DATA_SOURCES)).apply(any(), any());\n        assertEquals(2, (int) listener.getResult());\n\n    }\n\n    @Test\n    void testAnalysisCache() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        MyFooRule rule = new MyFooRule();\n        runPmd(config, GlobalAnalysisListener.noop(), rule);\n\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(NUM_DATA_SOURCES)).isUpToDate(any());\n    }\n\n    @Test\n    void testCacheWithFailure() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        BrokenRule rule = new BrokenRule();  // the broken rule throws\n        runPmd(config, GlobalAnalysisListener.noop(), rule);\n\n        // cache methods are called regardless\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(NUM_DATA_SOURCES)).isUpToDate(any());\n    }\n\n    @Test\n    void testCacheWithPropagatedException() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        BrokenRule rule = new BrokenRule();  // the broken rule throws\n        // now the exception should be propagated\n        GlobalAnalysisListener listener = GlobalAnalysisListener.exceptionThrower();\n        FileAnalysisException exception = assertThrows(FileAnalysisException.class, () -> {\n            runPmd(config, listener, rule);\n        });\n\n        assertEquals(\"fname1.dummy\", exception.getFileName());\n\n        // cache methods are called regardless\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(1)).isUpToDate(any());\n    }\n\n    @NonNull\n    private PMDConfiguration newConfig() {\n        PMDConfiguration config = new PMDConfiguration();\n        config.setAnalysisCache(new NoopAnalysisCache());\n        config.setIgnoreIncrementalAnalysis(true);\n        config.setThreads(1);\n        return config;\n    }\n\n    private void runPmd(PMDConfiguration config, GlobalAnalysisListener listener, Rule rule) {\n        try (PmdAnalysis pmd = PmdAnalysis.create(config)) {\n            pmd.addRuleSet(RuleSet.forSingleRule(rule));\n            pmd.files().addSourceFile(\"abc\", \"fname1.dummy\");\n            pmd.files().addSourceFile(\"abcd\", \"fname2.dummy\");\n            pmd.files().addSourceFile(\"abcd\", \"fname21.dummy\");\n            pmd.addListener(listener);\n            pmd.performAnalysis();\n        }\n    }\n\n\n    public static class MyFooRule extends FooRule {\n\n        @Override\n        public void apply(Node node, RuleContext ctx) {\n            if (node.getTextDocument().getDisplayName().contains(\"1\")) {\n                ctx.addViolation(node);\n            }\n        }\n    }\n\n    public static class BrokenRule extends FooRule {\n\n        @Override\n        public void apply(Node node, RuleContext ctx) {\n            throw new IllegalArgumentException(\"Something happened\");\n        }\n    }\n}\n",
        "filePathAfter": "pmd-core/src/test/java/net/sourceforge/pmd/reporting/GlobalAnalysisListenerTest.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.reporting;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.spy;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport java.util.Arrays;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\n\nimport net.sourceforge.pmd.FooRule;\nimport net.sourceforge.pmd.PMDConfiguration;\nimport net.sourceforge.pmd.PmdAnalysis;\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RuleContext;\nimport net.sourceforge.pmd.RuleSet;\nimport net.sourceforge.pmd.cache.AnalysisCache;\nimport net.sourceforge.pmd.cache.NoopAnalysisCache;\nimport net.sourceforge.pmd.lang.ast.FileAnalysisException;\nimport net.sourceforge.pmd.lang.ast.Node;\n\nclass GlobalAnalysisListenerTest {\n\n    static final int NUM_DATA_SOURCES = 3;\n\n    @Test\n    void testViolationCounter() {\n\n        PMDConfiguration config = newConfig();\n\n        GlobalAnalysisListener.ViolationCounterListener listener = new GlobalAnalysisListener.ViolationCounterListener();\n\n        MyFooRule mockrule = Mockito.spy(MyFooRule.class);\n        runPmd(config, listener, mockrule);\n\n        Mockito.verify(mockrule, times(NUM_DATA_SOURCES)).apply(any(), any());\n        assertEquals(2, (int) listener.getResult());\n\n    }\n\n    @Test\n    void testViolationCounterOnMulti() {\n\n        PMDConfiguration config = newConfig();\n        config.setThreads(2);\n\n        GlobalAnalysisListener.ViolationCounterListener listener = new GlobalAnalysisListener.ViolationCounterListener();\n\n        MyFooRule mockrule = Mockito.spy(MyFooRule.class);\n        when(mockrule.deepCopy()).thenReturn(mockrule); // the spy cannot track the deep copies\n\n        runPmd(config, listener, mockrule);\n\n        Mockito.verify(mockrule, times(NUM_DATA_SOURCES)).apply(any(), any());\n        assertEquals(2, (int) listener.getResult());\n\n    }\n\n    @Test\n    void testAnalysisCache() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        MyFooRule rule = new MyFooRule();\n        runPmd(config, GlobalAnalysisListener.noop(), rule);\n\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(NUM_DATA_SOURCES)).isUpToDate(any());\n    }\n\n    @Test\n    void testCacheWithFailure() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        BrokenRule rule = new BrokenRule();  // the broken rule throws\n        runPmd(config, GlobalAnalysisListener.noop(), rule);\n\n        // cache methods are called regardless\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(NUM_DATA_SOURCES)).isUpToDate(any());\n    }\n\n    @Test\n    void testCacheWithPropagatedException() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        BrokenRule rule = new BrokenRule();  // the broken rule throws\n        // now the exception should be propagated\n        GlobalAnalysisListener listener = GlobalAnalysisListener.exceptionThrower();\n        FileAnalysisException exception = assertThrows(FileAnalysisException.class, () -> {\n            runPmd(config, listener, rule);\n        });\n\n        assertEquals(\"fname1.dummy\", exception.getFileName());\n\n        // cache methods are called regardless\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(1)).isUpToDate(any());\n    }\n\n    @Test\n    void teeShouldForwardAllEventsSingleListeners() throws Exception {\n        GlobalAnalysisListener mockListener1 = createMockListener();\n        GlobalAnalysisListener teed = GlobalAnalysisListener.tee(Arrays.asList(mockListener1));\n\n        teed.initializer();\n        teed.startFileAnalysis(null);\n        teed.onConfigError(null);\n        teed.close();\n\n        verifyMethods(mockListener1);\n        Mockito.verifyNoMoreInteractions(mockListener1);\n    }\n\n    @NonNull\n    private PMDConfiguration newConfig() {\n        PMDConfiguration config = new PMDConfiguration();\n        config.setAnalysisCache(new NoopAnalysisCache());\n        config.setIgnoreIncrementalAnalysis(true);\n        config.setThreads(1);\n        return config;\n    }\n\n    private void runPmd(PMDConfiguration config, GlobalAnalysisListener listener, Rule rule) {\n        try (PmdAnalysis pmd = PmdAnalysis.create(config)) {\n            pmd.addRuleSet(RuleSet.forSingleRule(rule));\n            pmd.files().addSourceFile(\"abc\", \"fname1.dummy\");\n            pmd.files().addSourceFile(\"abcd\", \"fname2.dummy\");\n            pmd.files().addSourceFile(\"abcd\", \"fname21.dummy\");\n            pmd.addListener(listener);\n            pmd.performAnalysis();\n        }\n    }\n\n\n    public static class MyFooRule extends FooRule {\n\n        @Override\n        public void apply(Node node, RuleContext ctx) {\n            if (node.getTextDocument().getDisplayName().contains(\"1\")) {\n                ctx.addViolation(node);\n            }\n        }\n    }\n\n    public static class BrokenRule extends FooRule {\n\n        @Override\n        public void apply(Node node, RuleContext ctx) {\n            throw new IllegalArgumentException(\"Something happened\");\n        }\n    }\n\n    @Test\n    void teeShouldForwardAllEventsMultipleListeners() throws Exception {\n        GlobalAnalysisListener mockListener1 = createMockListener();\n        GlobalAnalysisListener mockListener2 = createMockListener();\n        GlobalAnalysisListener teed = GlobalAnalysisListener.tee(Arrays.asList(mockListener1, mockListener2));\n\n        teed.initializer();\n        teed.startFileAnalysis(null);\n        teed.onConfigError(null);\n        teed.close();\n\n        verifyMethods(mockListener1);\n        verifyMethods(mockListener2);\n        Mockito.verifyNoMoreInteractions(mockListener1, mockListener2);\n    }\n\n    private GlobalAnalysisListener createMockListener() {\n        GlobalAnalysisListener mockListener = Mockito.mock(GlobalAnalysisListener.class);\n        Mockito.when(mockListener.initializer()).thenReturn(ListenerInitializer.noop());\n        Mockito.when(mockListener.startFileAnalysis(Mockito.any())).thenReturn(FileAnalysisListener.noop());\n        return mockListener;\n    }\n\n    private void verifyMethods(GlobalAnalysisListener listener) throws Exception {\n        Mockito.verify(listener, Mockito.times(1)).initializer();\n        Mockito.verify(listener, Mockito.times(1)).startFileAnalysis(null);\n        Mockito.verify(listener, Mockito.times(1)).onConfigError(null);\n        Mockito.verify(listener, Mockito.times(1)).close();\n    }\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.processor.GlobalListenerTest#runPmd\n methodBody: private void runPmd(PMDConfiguration config, GlobalAnalysisListener listener, Rule rule) {\ntry(PmdAnalysis pmd=PmdAnalysis.create(config))pmd.addRuleSet(RuleSet.forSingleRule(rule));\npmd.files().addSourceFile(\"abc\",\"fname1.dummy\");\npmd.files().addSourceFile(\"abcd\",\"fname2.dummy\");\npmd.files().addSourceFile(\"abcd\",\"fname21.dummy\");\npmd.addListener(listener);\npmd.performAnalysis();\n}",
            "methodSignature: net.sourceforge.pmd.processor.GlobalListenerTest#newConfig\n methodBody: private PMDConfiguration newConfig() {\nPMDConfiguration config=new PMDConfiguration();\nconfig.setAnalysisCache(new NoopAnalysisCache());\nconfig.setIgnoreIncrementalAnalysis(true);\nconfig.setThreads(1);\nreturn config;\n}",
            "methodSignature: net.sourceforge.pmd.processor.GlobalListenerTest.BrokenRule#apply\n methodBody: public void apply(Node node, RuleContext ctx) {\nthrow new IllegalArgumentException(\"Something happened\");\n}",
            "methodSignature: net.sourceforge.pmd.processor.GlobalListenerTest.MyFooRule#apply\n methodBody: public void apply(Node node, RuleContext ctx) {\nif(node.getTextDocument().getDisplayName().contains(\"1\")){ctx.addViolation(node);\n}}"
        ],
        "sourceCodeAfterRefactoring": "@Test\n    void testViolationCounterOnMulti() {\n\n        PMDConfiguration config = newConfig();\n        config.setThreads(2);\n\n        GlobalAnalysisListener.ViolationCounterListener listener = new GlobalAnalysisListener.ViolationCounterListener();\n\n        MyFooRule mockrule = Mockito.spy(MyFooRule.class);\n        when(mockrule.deepCopy()).thenReturn(mockrule); // the spy cannot track the deep copies\n\n        runPmd(config, listener, mockrule);\n\n        Mockito.verify(mockrule, times(NUM_DATA_SOURCES)).apply(any(), any());\n        assertEquals(2, (int) listener.getResult());\n\n    }",
        "diffSourceCode": "    51:     @Test\n-   52:     void testViolationCounterOnMulti() throws Exception {\n+   52:     void testViolationCounterOnMulti() {\n    53: \n    54:         PMDConfiguration config = newConfig();\n    55:         config.setThreads(2);\n    56: \n-   57:         ViolationCounterListener listener = new GlobalAnalysisListener.ViolationCounterListener();\n+   57:         GlobalAnalysisListener.ViolationCounterListener listener = new GlobalAnalysisListener.ViolationCounterListener();\n    58: \n    59:         MyFooRule mockrule = Mockito.spy(MyFooRule.class);\n    60:         when(mockrule.deepCopy()).thenReturn(mockrule); // the spy cannot track the deep copies\n    61: \n    62:         runPmd(config, listener, mockrule);\n    63: \n    64:         Mockito.verify(mockrule, times(NUM_DATA_SOURCES)).apply(any(), any());\n    65:         assertEquals(2, (int) listener.getResult());\n    66: \n    67:     }\n",
        "uniqueId": "e2866bebf86e86892860dd0e3a01492797fd8ea6_51_67__51_67",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Move Method",
        "description": "Move Method\tpackage testViolationCounter() : void from class net.sourceforge.pmd.processor.GlobalListenerTest to package testViolationCounter() : void from class net.sourceforge.pmd.reporting.GlobalAnalysisListenerTest",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/processor/GlobalListenerTest.java",
                "startLine": 36,
                "endLine": 49,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/reporting/GlobalAnalysisListenerTest.java",
                "startLine": 36,
                "endLine": 49,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n    void testViolationCounter() throws Exception {\n\n        PMDConfiguration config = newConfig();\n\n        ViolationCounterListener listener = new GlobalAnalysisListener.ViolationCounterListener();\n\n        MyFooRule mockrule = Mockito.spy(MyFooRule.class);\n        runPmd(config, listener, mockrule);\n\n        Mockito.verify(mockrule, times(NUM_DATA_SOURCES)).apply(any(), any());\n        assertEquals(2, (int) listener.getResult());\n\n    }",
        "filePathBefore": "pmd-core/src/test/java/net/sourceforge/pmd/processor/GlobalListenerTest.java",
        "isPureRefactoring": true,
        "commitId": "e2866bebf86e86892860dd0e3a01492797fd8ea6",
        "packageNameBefore": "net.sourceforge.pmd.processor",
        "classNameBefore": "net.sourceforge.pmd.processor.GlobalListenerTest",
        "methodNameBefore": "net.sourceforge.pmd.processor.GlobalListenerTest#testViolationCounter",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.processor.GlobalListenerTest#runPmd\n methodBody: private void runPmd(PMDConfiguration config, GlobalAnalysisListener listener, Rule rule) {\ntry(PmdAnalysis pmd=PmdAnalysis.create(config))pmd.addRuleSet(RuleSet.forSingleRule(rule));\npmd.files().addSourceFile(\"abc\",\"fname1.dummy\");\npmd.files().addSourceFile(\"abcd\",\"fname2.dummy\");\npmd.files().addSourceFile(\"abcd\",\"fname21.dummy\");\npmd.addListener(listener);\npmd.performAnalysis();\n}\nmethodSignature: net.sourceforge.pmd.processor.GlobalListenerTest#newConfig\n methodBody: private PMDConfiguration newConfig() {\nPMDConfiguration config=new PMDConfiguration();\nconfig.setAnalysisCache(new NoopAnalysisCache());\nconfig.setIgnoreIncrementalAnalysis(true);\nconfig.setThreads(1);\nreturn config;\n}\nmethodSignature: net.sourceforge.pmd.processor.GlobalListenerTest.BrokenRule#apply\n methodBody: public void apply(Node node, RuleContext ctx) {\nthrow new IllegalArgumentException(\"Something happened\");\n}\nmethodSignature: net.sourceforge.pmd.processor.GlobalListenerTest.MyFooRule#apply\n methodBody: public void apply(Node node, RuleContext ctx) {\nif(node.getTextDocument().getDisplayName().contains(\"1\")){ctx.addViolation(node);\n}}",
        "classSignatureBefore": "class GlobalListenerTest ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.processor.GlobalListenerTest#testViolationCounter"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.processor.GlobalListenerTest"
        ],
        "classSignatureBeforeSet": [
            "class GlobalListenerTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body",
                "description": "All replacements are variables' type! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.processor;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.spy;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\n\nimport net.sourceforge.pmd.FooRule;\nimport net.sourceforge.pmd.PMDConfiguration;\nimport net.sourceforge.pmd.PmdAnalysis;\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RuleContext;\nimport net.sourceforge.pmd.RuleSet;\nimport net.sourceforge.pmd.cache.AnalysisCache;\nimport net.sourceforge.pmd.cache.NoopAnalysisCache;\nimport net.sourceforge.pmd.lang.ast.FileAnalysisException;\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.reporting.GlobalAnalysisListener;\nimport net.sourceforge.pmd.reporting.GlobalAnalysisListener.ViolationCounterListener;\n\nclass GlobalListenerTest {\n\n    static final int NUM_DATA_SOURCES = 3;\n\n    @Test\n    void testViolationCounter() throws Exception {\n\n        PMDConfiguration config = newConfig();\n\n        ViolationCounterListener listener = new GlobalAnalysisListener.ViolationCounterListener();\n\n        MyFooRule mockrule = Mockito.spy(MyFooRule.class);\n        runPmd(config, listener, mockrule);\n\n        Mockito.verify(mockrule, times(NUM_DATA_SOURCES)).apply(any(), any());\n        assertEquals(2, (int) listener.getResult());\n\n    }\n\n    @Test\n    void testViolationCounterOnMulti() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        config.setThreads(2);\n\n        ViolationCounterListener listener = new GlobalAnalysisListener.ViolationCounterListener();\n\n        MyFooRule mockrule = Mockito.spy(MyFooRule.class);\n        when(mockrule.deepCopy()).thenReturn(mockrule); // the spy cannot track the deep copies\n\n        runPmd(config, listener, mockrule);\n\n        Mockito.verify(mockrule, times(NUM_DATA_SOURCES)).apply(any(), any());\n        assertEquals(2, (int) listener.getResult());\n\n    }\n\n    @Test\n    void testAnalysisCache() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        MyFooRule rule = new MyFooRule();\n        runPmd(config, GlobalAnalysisListener.noop(), rule);\n\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(NUM_DATA_SOURCES)).isUpToDate(any());\n    }\n\n    @Test\n    void testCacheWithFailure() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        BrokenRule rule = new BrokenRule();  // the broken rule throws\n        runPmd(config, GlobalAnalysisListener.noop(), rule);\n\n        // cache methods are called regardless\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(NUM_DATA_SOURCES)).isUpToDate(any());\n    }\n\n    @Test\n    void testCacheWithPropagatedException() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        BrokenRule rule = new BrokenRule();  // the broken rule throws\n        // now the exception should be propagated\n        GlobalAnalysisListener listener = GlobalAnalysisListener.exceptionThrower();\n        FileAnalysisException exception = assertThrows(FileAnalysisException.class, () -> {\n            runPmd(config, listener, rule);\n        });\n\n        assertEquals(\"fname1.dummy\", exception.getFileName());\n\n        // cache methods are called regardless\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(1)).isUpToDate(any());\n    }\n\n    @NonNull\n    private PMDConfiguration newConfig() {\n        PMDConfiguration config = new PMDConfiguration();\n        config.setAnalysisCache(new NoopAnalysisCache());\n        config.setIgnoreIncrementalAnalysis(true);\n        config.setThreads(1);\n        return config;\n    }\n\n    private void runPmd(PMDConfiguration config, GlobalAnalysisListener listener, Rule rule) {\n        try (PmdAnalysis pmd = PmdAnalysis.create(config)) {\n            pmd.addRuleSet(RuleSet.forSingleRule(rule));\n            pmd.files().addSourceFile(\"abc\", \"fname1.dummy\");\n            pmd.files().addSourceFile(\"abcd\", \"fname2.dummy\");\n            pmd.files().addSourceFile(\"abcd\", \"fname21.dummy\");\n            pmd.addListener(listener);\n            pmd.performAnalysis();\n        }\n    }\n\n\n    public static class MyFooRule extends FooRule {\n\n        @Override\n        public void apply(Node node, RuleContext ctx) {\n            if (node.getTextDocument().getDisplayName().contains(\"1\")) {\n                ctx.addViolation(node);\n            }\n        }\n    }\n\n    public static class BrokenRule extends FooRule {\n\n        @Override\n        public void apply(Node node, RuleContext ctx) {\n            throw new IllegalArgumentException(\"Something happened\");\n        }\n    }\n}\n",
        "filePathAfter": "pmd-core/src/test/java/net/sourceforge/pmd/reporting/GlobalAnalysisListenerTest.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.reporting;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.spy;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport java.util.Arrays;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\n\nimport net.sourceforge.pmd.FooRule;\nimport net.sourceforge.pmd.PMDConfiguration;\nimport net.sourceforge.pmd.PmdAnalysis;\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RuleContext;\nimport net.sourceforge.pmd.RuleSet;\nimport net.sourceforge.pmd.cache.AnalysisCache;\nimport net.sourceforge.pmd.cache.NoopAnalysisCache;\nimport net.sourceforge.pmd.lang.ast.FileAnalysisException;\nimport net.sourceforge.pmd.lang.ast.Node;\n\nclass GlobalAnalysisListenerTest {\n\n    static final int NUM_DATA_SOURCES = 3;\n\n    @Test\n    void testViolationCounter() {\n\n        PMDConfiguration config = newConfig();\n\n        GlobalAnalysisListener.ViolationCounterListener listener = new GlobalAnalysisListener.ViolationCounterListener();\n\n        MyFooRule mockrule = Mockito.spy(MyFooRule.class);\n        runPmd(config, listener, mockrule);\n\n        Mockito.verify(mockrule, times(NUM_DATA_SOURCES)).apply(any(), any());\n        assertEquals(2, (int) listener.getResult());\n\n    }\n\n    @Test\n    void testViolationCounterOnMulti() {\n\n        PMDConfiguration config = newConfig();\n        config.setThreads(2);\n\n        GlobalAnalysisListener.ViolationCounterListener listener = new GlobalAnalysisListener.ViolationCounterListener();\n\n        MyFooRule mockrule = Mockito.spy(MyFooRule.class);\n        when(mockrule.deepCopy()).thenReturn(mockrule); // the spy cannot track the deep copies\n\n        runPmd(config, listener, mockrule);\n\n        Mockito.verify(mockrule, times(NUM_DATA_SOURCES)).apply(any(), any());\n        assertEquals(2, (int) listener.getResult());\n\n    }\n\n    @Test\n    void testAnalysisCache() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        MyFooRule rule = new MyFooRule();\n        runPmd(config, GlobalAnalysisListener.noop(), rule);\n\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(NUM_DATA_SOURCES)).isUpToDate(any());\n    }\n\n    @Test\n    void testCacheWithFailure() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        BrokenRule rule = new BrokenRule();  // the broken rule throws\n        runPmd(config, GlobalAnalysisListener.noop(), rule);\n\n        // cache methods are called regardless\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(NUM_DATA_SOURCES)).isUpToDate(any());\n    }\n\n    @Test\n    void testCacheWithPropagatedException() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        BrokenRule rule = new BrokenRule();  // the broken rule throws\n        // now the exception should be propagated\n        GlobalAnalysisListener listener = GlobalAnalysisListener.exceptionThrower();\n        FileAnalysisException exception = assertThrows(FileAnalysisException.class, () -> {\n            runPmd(config, listener, rule);\n        });\n\n        assertEquals(\"fname1.dummy\", exception.getFileName());\n\n        // cache methods are called regardless\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(1)).isUpToDate(any());\n    }\n\n    @Test\n    void teeShouldForwardAllEventsSingleListeners() throws Exception {\n        GlobalAnalysisListener mockListener1 = createMockListener();\n        GlobalAnalysisListener teed = GlobalAnalysisListener.tee(Arrays.asList(mockListener1));\n\n        teed.initializer();\n        teed.startFileAnalysis(null);\n        teed.onConfigError(null);\n        teed.close();\n\n        verifyMethods(mockListener1);\n        Mockito.verifyNoMoreInteractions(mockListener1);\n    }\n\n    @NonNull\n    private PMDConfiguration newConfig() {\n        PMDConfiguration config = new PMDConfiguration();\n        config.setAnalysisCache(new NoopAnalysisCache());\n        config.setIgnoreIncrementalAnalysis(true);\n        config.setThreads(1);\n        return config;\n    }\n\n    private void runPmd(PMDConfiguration config, GlobalAnalysisListener listener, Rule rule) {\n        try (PmdAnalysis pmd = PmdAnalysis.create(config)) {\n            pmd.addRuleSet(RuleSet.forSingleRule(rule));\n            pmd.files().addSourceFile(\"abc\", \"fname1.dummy\");\n            pmd.files().addSourceFile(\"abcd\", \"fname2.dummy\");\n            pmd.files().addSourceFile(\"abcd\", \"fname21.dummy\");\n            pmd.addListener(listener);\n            pmd.performAnalysis();\n        }\n    }\n\n\n    public static class MyFooRule extends FooRule {\n\n        @Override\n        public void apply(Node node, RuleContext ctx) {\n            if (node.getTextDocument().getDisplayName().contains(\"1\")) {\n                ctx.addViolation(node);\n            }\n        }\n    }\n\n    public static class BrokenRule extends FooRule {\n\n        @Override\n        public void apply(Node node, RuleContext ctx) {\n            throw new IllegalArgumentException(\"Something happened\");\n        }\n    }\n\n    @Test\n    void teeShouldForwardAllEventsMultipleListeners() throws Exception {\n        GlobalAnalysisListener mockListener1 = createMockListener();\n        GlobalAnalysisListener mockListener2 = createMockListener();\n        GlobalAnalysisListener teed = GlobalAnalysisListener.tee(Arrays.asList(mockListener1, mockListener2));\n\n        teed.initializer();\n        teed.startFileAnalysis(null);\n        teed.onConfigError(null);\n        teed.close();\n\n        verifyMethods(mockListener1);\n        verifyMethods(mockListener2);\n        Mockito.verifyNoMoreInteractions(mockListener1, mockListener2);\n    }\n\n    private GlobalAnalysisListener createMockListener() {\n        GlobalAnalysisListener mockListener = Mockito.mock(GlobalAnalysisListener.class);\n        Mockito.when(mockListener.initializer()).thenReturn(ListenerInitializer.noop());\n        Mockito.when(mockListener.startFileAnalysis(Mockito.any())).thenReturn(FileAnalysisListener.noop());\n        return mockListener;\n    }\n\n    private void verifyMethods(GlobalAnalysisListener listener) throws Exception {\n        Mockito.verify(listener, Mockito.times(1)).initializer();\n        Mockito.verify(listener, Mockito.times(1)).startFileAnalysis(null);\n        Mockito.verify(listener, Mockito.times(1)).onConfigError(null);\n        Mockito.verify(listener, Mockito.times(1)).close();\n    }\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.processor.GlobalListenerTest#runPmd\n methodBody: private void runPmd(PMDConfiguration config, GlobalAnalysisListener listener, Rule rule) {\ntry(PmdAnalysis pmd=PmdAnalysis.create(config))pmd.addRuleSet(RuleSet.forSingleRule(rule));\npmd.files().addSourceFile(\"abc\",\"fname1.dummy\");\npmd.files().addSourceFile(\"abcd\",\"fname2.dummy\");\npmd.files().addSourceFile(\"abcd\",\"fname21.dummy\");\npmd.addListener(listener);\npmd.performAnalysis();\n}",
            "methodSignature: net.sourceforge.pmd.processor.GlobalListenerTest#newConfig\n methodBody: private PMDConfiguration newConfig() {\nPMDConfiguration config=new PMDConfiguration();\nconfig.setAnalysisCache(new NoopAnalysisCache());\nconfig.setIgnoreIncrementalAnalysis(true);\nconfig.setThreads(1);\nreturn config;\n}",
            "methodSignature: net.sourceforge.pmd.processor.GlobalListenerTest.BrokenRule#apply\n methodBody: public void apply(Node node, RuleContext ctx) {\nthrow new IllegalArgumentException(\"Something happened\");\n}",
            "methodSignature: net.sourceforge.pmd.processor.GlobalListenerTest.MyFooRule#apply\n methodBody: public void apply(Node node, RuleContext ctx) {\nif(node.getTextDocument().getDisplayName().contains(\"1\")){ctx.addViolation(node);\n}}"
        ],
        "sourceCodeAfterRefactoring": "@Test\n    void testViolationCounter() {\n\n        PMDConfiguration config = newConfig();\n\n        GlobalAnalysisListener.ViolationCounterListener listener = new GlobalAnalysisListener.ViolationCounterListener();\n\n        MyFooRule mockrule = Mockito.spy(MyFooRule.class);\n        runPmd(config, listener, mockrule);\n\n        Mockito.verify(mockrule, times(NUM_DATA_SOURCES)).apply(any(), any());\n        assertEquals(2, (int) listener.getResult());\n\n    }",
        "diffSourceCode": "    36:     @Test\n-   37:     void testViolationCounter() throws Exception {\n+   37:     void testViolationCounter() {\n    38: \n    39:         PMDConfiguration config = newConfig();\n    40: \n-   41:         ViolationCounterListener listener = new GlobalAnalysisListener.ViolationCounterListener();\n+   41:         GlobalAnalysisListener.ViolationCounterListener listener = new GlobalAnalysisListener.ViolationCounterListener();\n    42: \n    43:         MyFooRule mockrule = Mockito.spy(MyFooRule.class);\n    44:         runPmd(config, listener, mockrule);\n    45: \n    46:         Mockito.verify(mockrule, times(NUM_DATA_SOURCES)).apply(any(), any());\n    47:         assertEquals(2, (int) listener.getResult());\n    48: \n    49:     }\n",
        "uniqueId": "e2866bebf86e86892860dd0e3a01492797fd8ea6_36_49__36_49",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic getLatestVersion() : LanguageVersion extracted from package runAllJavaPmdOnTestResourcesWithLatestJavaVersion() : void in class net.sourceforge.pmd.coverage.PMDCoverageTest & moved to class net.sourceforge.pmd.lang.Language",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/test/java/net/sourceforge/pmd/coverage/PMDCoverageTest.java",
                "startLine": 49,
                "endLine": 55,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/test/java/net/sourceforge/pmd/coverage/PMDCoverageTest.java",
                "startLine": 42,
                "endLine": 47,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/test/java/net/sourceforge/pmd/coverage/PMDCoverageTest.java",
                "startLine": 100,
                "endLine": 109,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n    void runAllJavaPmdOnTestResourcesWithLatestJavaVersion() {\n        List<LanguageVersion> versions = JavaLanguageModule.getInstance().getVersions();\n        LanguageVersion latest = versions.get(versions.size() - 1);\n\n        runPmd(\"-d src/test/resources -f text -R rulesets/internal/all-java.xml -language java -version \" + latest.getVersion());\n    }",
        "filePathBefore": "pmd-java/src/test/java/net/sourceforge/pmd/coverage/PMDCoverageTest.java",
        "isPureRefactoring": true,
        "commitId": "5031c83c880d11f215b2b21919ff3091c6f951bf",
        "packageNameBefore": "net.sourceforge.pmd.coverage",
        "classNameBefore": "net.sourceforge.pmd.coverage.PMDCoverageTest",
        "methodNameBefore": "net.sourceforge.pmd.coverage.PMDCoverageTest#runAllJavaPmdOnTestResourcesWithLatestJavaVersion",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.Language#getVersions\n methodBody: List<LanguageVersion> getVersions();\nmethodSignature: net.sourceforge.pmd.lang.Language#getVersion\n methodBody: default LanguageVersion getVersion(String version) {\nfor(LanguageVersion v: getVersions()){if(v.getVersion().equals(version)){return v;\n}}return null;\n}\nmethodSignature: net.sourceforge.pmd.coverage.PMDCoverageTest#runPmd\n methodBody: private void runPmd(String commandLine) {\nStringBuilder report=new StringBuilder(\"missing report\");\ntryPath f=Files.createTempFile(tempFolder,PMDCoverageTest.class.getSimpleName(),null);\nString[] args=ArrayUtils.addAll(commandLine.split(\"\\\\s\"),\"-reportfile\",f.toAbsolutePath().toString(),\"-threads\",String.valueOf(Runtime.getRuntime().availableProcessors()));\nSystem.err.println(\"Running PMD with: \" + Arrays.toString(args));\nString output=SystemLambda.tapSystemOut(() -> {\n  String errorOutput=SystemLambda.tapSystemErr(() -> {\n    PMD.runPmd(args);\n    report.setLength(0);\n    report.append(IOUtil.readFileToString(f.toFile(),StandardCharsets.UTF_8));\n  }\n);\n  assertEquals(0,StringUtils.countMatches(errorOutput,\"Exception applying rule\"),\"No exceptions expected\");\n  assertFalse(errorOutput.contains(\"Ruleset not found\"),\"Wrong configuration? Ruleset not found\");\n  assertEquals(0,StringUtils.countMatches(errorOutput,\"Use of deprecated attribute\"),\"No usage of deprecated XPath attributes expected\");\n}\n);\nassertEquals(0,output.length(),\"Nothing should be output to stdout\");\nassertEquals(0,StringUtils.countMatches(report,\"Error while processing\"),\"No processing errors expected\");\nassertEquals(0,StringUtils.countMatches(report,\"Error while parsing\"),\"No parsing error expected\");\ncatch(IOException ioe)fail(\"Problem creating temporary file: \" + ioe.getLocalizedMessage());\ncatch(AssertionError ae)System.out.println(\"\\nReport:\\n\");\nSystem.out.println(report);\nthrow ae;\ncatch(Exception e)throw new RuntimeException(e);\n}",
        "classSignatureBefore": "class PMDCoverageTest ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.coverage.PMDCoverageTest#runAllJavaPmdOnTestResourcesWithLatestJavaVersion"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.coverage.PMDCoverageTest"
        ],
        "classSignatureBeforeSet": [
            "class PMDCoverageTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.coverage;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\nimport net.sourceforge.pmd.PMD;\nimport net.sourceforge.pmd.internal.util.IOUtil;\nimport net.sourceforge.pmd.lang.LanguageVersion;\nimport net.sourceforge.pmd.lang.java.JavaLanguageModule;\n\nimport com.github.stefanbirkner.systemlambda.SystemLambda;\n\n// TODO enable test\n@Disabled(\"Test is failing and was excluded on PMD 7 branch\")\nclass PMDCoverageTest {\n\n    @TempDir\n    private Path tempFolder;\n\n    @Test\n    void testPmdOptions() {\n        runPmd(\"-d src/main/java/net/sourceforge/pmd/lang/java/rule/design -f text -R rulesets/internal/all-java.xml -stress -benchmark\");\n    }\n\n\n    @Test\n    void runAllJavaPmdOnSourceTree() {\n        runPmd(\"-d src/main/java -f text -R rulesets/internal/all-java.xml\");\n    }\n\n    @Test\n    void runAllJavaPmdOnTestResourcesWithLatestJavaVersion() {\n        List<LanguageVersion> versions = JavaLanguageModule.getInstance().getVersions();\n        LanguageVersion latest = versions.get(versions.size() - 1);\n\n        runPmd(\"-d src/test/resources -f text -R rulesets/internal/all-java.xml -language java -version \" + latest.getVersion());\n    }\n\n    /**\n     * Run the PMD command line tool, i.e. call PMD.main().\n     *\n     * @param commandLine\n     */\n    private void runPmd(String commandLine) {\n        StringBuilder report = new StringBuilder(\"missing report\");\n\n        try {\n            Path f = Files.createTempFile(tempFolder, PMDCoverageTest.class.getSimpleName(), null);\n            String[] args = ArrayUtils.addAll(\n                commandLine.split(\"\\\\s\"),\n                \"-reportfile\",\n                f.toAbsolutePath().toString(),\n                \"-threads\",\n                String.valueOf(Runtime.getRuntime().availableProcessors())\n            );\n\n            System.err.println(\"Running PMD with: \" + Arrays.toString(args));\n            String output = SystemLambda.tapSystemOut(() -> {\n                String errorOutput = SystemLambda.tapSystemErr(() -> {\n                    PMD.runPmd(args);\n\n                    report.setLength(0);\n                    report.append(IOUtil.readFileToString(f.toFile(), StandardCharsets.UTF_8));\n                });\n                assertEquals(0, StringUtils.countMatches(errorOutput, \"Exception applying rule\"), \"No exceptions expected\");\n                assertFalse(errorOutput.contains(\"Ruleset not found\"), \"Wrong configuration? Ruleset not found\");\n                assertEquals(0, StringUtils.countMatches(errorOutput, \"Use of deprecated attribute\"), \"No usage of deprecated XPath attributes expected\");\n            });\n\n            assertEquals(0, output.length(), \"Nothing should be output to stdout\");\n\n            assertEquals(0, StringUtils.countMatches(report, \"Error while processing\"), \"No processing errors expected\");\n\n            // we might have explicit examples of parsing errors, so these are maybe false positives\n            assertEquals(0, StringUtils.countMatches(report, \"Error while parsing\"), \"No parsing error expected\");\n        } catch (IOException ioe) {\n            fail(\"Problem creating temporary file: \" + ioe.getLocalizedMessage());\n        } catch (AssertionError ae) {\n            System.out.println(\"\\nReport:\\n\");\n            System.out.println(report);\n            throw ae;\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n",
        "filePathAfter": "pmd-java/src/test/java/net/sourceforge/pmd/coverage/PMDCoverageTest.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.coverage;\n\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.containsString;\nimport static org.hamcrest.Matchers.emptyString;\nimport static org.hamcrest.Matchers.is;\nimport static org.hamcrest.Matchers.not;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.function.Consumer;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\nimport net.sourceforge.pmd.PMDConfiguration;\nimport net.sourceforge.pmd.PmdAnalysis;\nimport net.sourceforge.pmd.internal.util.IOUtil;\nimport net.sourceforge.pmd.lang.LanguageVersion;\nimport net.sourceforge.pmd.lang.java.JavaLanguageModule;\n\nimport com.github.stefanbirkner.systemlambda.SystemLambda;\n\nclass PMDCoverageTest {\n\n    @TempDir\n    private Path tempFolder;\n\n    @Test\n    void runAllJavaPmdOnSourceTree() {\n        runPmd(\"src/main/java\", conf -> {});\n    }\n\n    @Test\n    void runAllJavaPmdOnTestResourcesWithLatestJavaVersion() {\n        LanguageVersion latest = JavaLanguageModule.getInstance().getLatestVersion();\n\n        runPmd(\"src/test/resources\", conf -> conf.setDefaultLanguageVersion(latest));\n    }\n\n    /**\n     * Run the PMD command line tool, i.e. call PMD.main().\n     *\n     * @param commandLine\n     */\n    private void runPmd(String inputPath, Consumer<PMDConfiguration> configure) {\n        StringBuilder report = new StringBuilder(\"missing report\");\n\n        try {\n            Path f = Files.createTempFile(tempFolder, PMDCoverageTest.class.getSimpleName(), null);\n\n            String output = SystemLambda.tapSystemOut(() -> {\n                String errorOutput = SystemLambda.tapSystemErr(() -> {\n                    PMDConfiguration conf = new PMDConfiguration();\n                    conf.addInputPath(Paths.get(inputPath));\n                    conf.setReportFile(f);\n                    conf.addRuleSet(\"rulesets/internal/all-java.xml\");\n                    conf.setThreads(Runtime.getRuntime().availableProcessors());\n                    configure.accept(conf);\n\n                    try (PmdAnalysis pmd = PmdAnalysis.create(conf)) {\n                        pmd.performAnalysis();\n                    }\n\n                    report.setLength(0);\n                    report.append(IOUtil.readFileToString(f.toFile(), StandardCharsets.UTF_8));\n                });\n                assertThat(errorOutput, not(containsString(\"Exception applying rule\")));\n                assertThat(errorOutput, not(containsString(\"Ruleset not found\")));\n                assertThat(errorOutput, not(containsString(\"Use of deprecated attribute\")));\n            });\n\n            assertThat(output, is(emptyString()));\n            assertThat(output, not(containsString(\"Error while processing\")));\n            // we might have explicit examples of parsing errors, so these are maybe false positives\n            assertThat(output, not(containsString(\"Error while parsing\")));\n        } catch (IOException ioe) {\n            fail(\"Problem creating temporary file: \" + ioe.getLocalizedMessage());\n        } catch (AssertionError ae) {\n            System.out.println(\"\\nReport:\\n\");\n            System.out.println(report);\n            throw ae;\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            ""
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.Language#getVersions\n methodBody: List<LanguageVersion> getVersions();",
            "methodSignature: net.sourceforge.pmd.lang.Language#getVersion\n methodBody: default LanguageVersion getVersion(String version) {\nfor(LanguageVersion v: getVersions()){if(v.getVersion().equals(version)){return v;\n}}return null;\n}",
            "methodSignature: net.sourceforge.pmd.coverage.PMDCoverageTest#runPmd\n methodBody: private void runPmd(String commandLine) {\nStringBuilder report=new StringBuilder(\"missing report\");\ntryPath f=Files.createTempFile(tempFolder,PMDCoverageTest.class.getSimpleName(),null);\nString[] args=ArrayUtils.addAll(commandLine.split(\"\\\\s\"),\"-reportfile\",f.toAbsolutePath().toString(),\"-threads\",String.valueOf(Runtime.getRuntime().availableProcessors()));\nSystem.err.println(\"Running PMD with: \" + Arrays.toString(args));\nString output=SystemLambda.tapSystemOut(() -> {\n  String errorOutput=SystemLambda.tapSystemErr(() -> {\n    PMD.runPmd(args);\n    report.setLength(0);\n    report.append(IOUtil.readFileToString(f.toFile(),StandardCharsets.UTF_8));\n  }\n);\n  assertEquals(0,StringUtils.countMatches(errorOutput,\"Exception applying rule\"),\"No exceptions expected\");\n  assertFalse(errorOutput.contains(\"Ruleset not found\"),\"Wrong configuration? Ruleset not found\");\n  assertEquals(0,StringUtils.countMatches(errorOutput,\"Use of deprecated attribute\"),\"No usage of deprecated XPath attributes expected\");\n}\n);\nassertEquals(0,output.length(),\"Nothing should be output to stdout\");\nassertEquals(0,StringUtils.countMatches(report,\"Error while processing\"),\"No processing errors expected\");\nassertEquals(0,StringUtils.countMatches(report,\"Error while parsing\"),\"No parsing error expected\");\ncatch(IOException ioe)fail(\"Problem creating temporary file: \" + ioe.getLocalizedMessage());\ncatch(AssertionError ae)System.out.println(\"\\nReport:\\n\");\nSystem.out.println(report);\nthrow ae;\ncatch(Exception e)throw new RuntimeException(e);\n}"
        ],
        "sourceCodeAfterRefactoring": "@Test\n    void runAllJavaPmdOnTestResourcesWithLatestJavaVersion() {\n        LanguageVersion latest = JavaLanguageModule.getInstance().getLatestVersion();\n\n        runPmd(\"src/test/resources\", conf -> conf.setDefaultLanguageVersion(latest));\n    }\n",
        "diffSourceCode": "-   42: \n-   43: \n-   44:     @Test\n-   45:     void runAllJavaPmdOnSourceTree() {\n-   46:         runPmd(\"-d src/main/java -f text -R rulesets/internal/all-java.xml\");\n+   42:     @Test\n+   43:     void runAllJavaPmdOnTestResourcesWithLatestJavaVersion() {\n+   44:         LanguageVersion latest = JavaLanguageModule.getInstance().getLatestVersion();\n+   45: \n+   46:         runPmd(\"src/test/resources\", conf -> conf.setDefaultLanguageVersion(latest));\n    47:     }\n-   49:     @Test\n-   50:     void runAllJavaPmdOnTestResourcesWithLatestJavaVersion() {\n-   51:         List<LanguageVersion> versions = JavaLanguageModule.getInstance().getVersions();\n-   52:         LanguageVersion latest = versions.get(versions.size() - 1);\n-   53: \n-   54:         runPmd(\"-d src/test/resources -f text -R rulesets/internal/all-java.xml -language java -version \" + latest.getVersion());\n-   55:     }\n-  100:         } catch (Exception e) {\n-  101:             throw new RuntimeException(e);\n-  102:         }\n-  103:     }\n-  104: }\n+   49:     /**\n+   50:      * Run the PMD command line tool, i.e. call PMD.main().\n+   51:      *\n+   52:      * @param commandLine\n+   53:      */\n+   54:     private void runPmd(String inputPath, Consumer<PMDConfiguration> configure) {\n+   55:         StringBuilder report = new StringBuilder(\"missing report\");\n",
        "uniqueId": "5031c83c880d11f215b2b21919ff3091c6f951bf_49_55_100_109_42_47",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic parse(code String, filename PathId) : DummyRootNode extracted from public parse(code String, filename String) : DummyRootNode in class net.sourceforge.pmd.DummyParsingHelper",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/DummyParsingHelper.java",
                "startLine": 41,
                "endLine": 48,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/DummyParsingHelper.java",
                "startLine": 41,
                "endLine": 43,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/DummyParsingHelper.java",
                "startLine": 44,
                "endLine": 51,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public DummyRootNode parse(String code, String filename) {\n        LanguageVersion version = DummyLanguageModule.getInstance().getDefaultVersion();\n        ParserTask task = new ParserTask(\n            TextDocument.readOnlyString(code, filename, version),\n            SemanticErrorReporter.noop(),\n            LanguageProcessorRegistry.singleton(dummyProcessor));\n        return (DummyRootNode) dummyProcessor.services().getParser().parse(task);\n    }",
        "filePathBefore": "pmd-core/src/test/java/net/sourceforge/pmd/DummyParsingHelper.java",
        "isPureRefactoring": true,
        "commitId": "2d7e200db172644181ff14e49faf1cd42698a552",
        "packageNameBefore": "net.sourceforge.pmd",
        "classNameBefore": "net.sourceforge.pmd.DummyParsingHelper",
        "methodNameBefore": "net.sourceforge.pmd.DummyParsingHelper#parse",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.reporting.GlobalAnalysisListener#noop\n methodBody: static GlobalAnalysisListener noop() {\nreturn NoopAnalysisListener.INSTANCE;\n}\nmethodSignature: net.sourceforge.pmd.lang.ast.impl.javacc.JjtreeParserAdapter#parse\n methodBody: public final R parse(ParserTask task) throws ParseException {\ntryCharStream charStream=CharStream.create(task.getTextDocument(),tokenBehavior());\ntask=task.withTextDocument(charStream.getTokenDocument().getTextDocument());\nreturn parseImpl(charStream,task);\ncatch(FileAnalysisException tme)throw tme.setFileName(task.getFileDisplayName());\n}\nmethodSignature: net.sourceforge.pmd.lang.impl.PmdRunnable#parse\n methodBody: private RootNode parse(Parser parser, ParserTask task) {\ntry(TimedOperation ignored=TimeTracker.startOperation(TimedOperationCategory.PARSER))return parser.parse(task);\n}\nmethodSignature: net.sourceforge.pmd.lang.ast.Parser#parse\n methodBody: RootNode parse(ParserTask task) throws FileAnalysisException;\nmethodSignature: net.sourceforge.pmd.lang.document.TextDocument#readOnlyString\n methodBody: static TextDocument readOnlyString(@NonNull CharSequence source, @NonNull String filename, @NonNull LanguageVersion lv) {\nTextFile textFile=TextFile.forCharSeq(source,filename,lv);\ntryreturn create(textFile);\ncatch(IOException e)throw new AssertionError(\"String text file should never throw IOException\",e);\n}\nmethodSignature: net.sourceforge.pmd.DummyParsingHelper#parse\n methodBody: public DummyRootNode parse(String code, String filename) {\nLanguageVersion version=DummyLanguageModule.getInstance().getDefaultVersion();\nParserTask task=new ParserTask(TextDocument.readOnlyString(code,filename,version),SemanticErrorReporter.noop(),LanguageProcessorRegistry.singleton(dummyProcessor));\nreturn (DummyRootNode)dummyProcessor.services().getParser().parse(task);\n}\nmethodSignature: net.sourceforge.pmd.lang.apex.ast.ApexParser#parse\n methodBody: public ASTApexFile parse(final ParserTask task) {\ntryfinal Compilation astRoot=CompilerService.INSTANCE.parseApex(task.getTextDocument());\nassert astRoot != null : \"Normally replaced by Compilation.INVALID\";\nfinal ApexTreeBuilder treeBuilder=new ApexTreeBuilder(task,(ApexLanguageProcessor)task.getLanguageProcessor());\nreturn treeBuilder.buildTree(astRoot);\ncatch(ParseException e)throw new ParseException(e).setFileName(task.getFileDisplayName());\n}",
        "classSignatureBefore": "public class DummyParsingHelper implements Extension, BeforeEachCallback, AfterEachCallback ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.DummyParsingHelper#parse"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.DummyParsingHelper"
        ],
        "classSignatureBeforeSet": [
            "public class DummyParsingHelper implements Extension, BeforeEachCallback, AfterEachCallback "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd;\n\nimport java.util.Collections;\n\nimport org.junit.jupiter.api.extension.AfterEachCallback;\nimport org.junit.jupiter.api.extension.BeforeEachCallback;\nimport org.junit.jupiter.api.extension.Extension;\nimport org.junit.jupiter.api.extension.ExtensionContext;\n\nimport net.sourceforge.pmd.lang.DummyLanguageModule;\nimport net.sourceforge.pmd.lang.LanguageProcessor;\nimport net.sourceforge.pmd.lang.LanguageProcessorRegistry;\nimport net.sourceforge.pmd.lang.LanguageRegistry;\nimport net.sourceforge.pmd.lang.LanguageVersion;\nimport net.sourceforge.pmd.lang.ast.DummyNode.DummyRootNode;\nimport net.sourceforge.pmd.lang.ast.Parser.ParserTask;\nimport net.sourceforge.pmd.lang.ast.SemanticErrorReporter;\nimport net.sourceforge.pmd.lang.document.TextDocument;\nimport net.sourceforge.pmd.lang.document.TextFile;\nimport net.sourceforge.pmd.util.log.MessageReporter;\n\n/**\n * @author Cl\u00e9ment Fournier\n */\npublic class DummyParsingHelper implements Extension, BeforeEachCallback, AfterEachCallback {\n\n    private LanguageProcessor dummyProcessor;\n\n    public DummyParsingHelper() {\n\n    }\n\n    public DummyRootNode parse(String code) {\n        return parse(code, TextFile.UNKNOWN_FILENAME);\n    }\n\n    public DummyRootNode parse(String code, String filename) {\n        LanguageVersion version = DummyLanguageModule.getInstance().getDefaultVersion();\n        ParserTask task = new ParserTask(\n            TextDocument.readOnlyString(code, filename, version),\n            SemanticErrorReporter.noop(),\n            LanguageProcessorRegistry.singleton(dummyProcessor));\n        return (DummyRootNode) dummyProcessor.services().getParser().parse(task);\n    }\n\n    @Override\n    public void afterEach(ExtensionContext context) throws Exception {\n        dummyProcessor.close();\n    }\n\n    @Override\n    public void beforeEach(ExtensionContext context) throws Exception {\n        LanguageProcessorRegistry registry = LanguageProcessorRegistry.create(\n            LanguageRegistry.PMD,\n            Collections.emptyMap(),\n            MessageReporter.quiet()\n        );\n        dummyProcessor = registry.getProcessor(DummyLanguageModule.getInstance());\n    }\n}\n",
        "filePathAfter": "pmd-core/src/test/java/net/sourceforge/pmd/DummyParsingHelper.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd;\n\nimport java.util.Collections;\n\nimport org.junit.jupiter.api.extension.AfterEachCallback;\nimport org.junit.jupiter.api.extension.BeforeEachCallback;\nimport org.junit.jupiter.api.extension.Extension;\nimport org.junit.jupiter.api.extension.ExtensionContext;\n\nimport net.sourceforge.pmd.lang.DummyLanguageModule;\nimport net.sourceforge.pmd.lang.LanguageProcessor;\nimport net.sourceforge.pmd.lang.LanguageProcessorRegistry;\nimport net.sourceforge.pmd.lang.LanguageRegistry;\nimport net.sourceforge.pmd.lang.LanguageVersion;\nimport net.sourceforge.pmd.lang.ast.DummyNode.DummyRootNode;\nimport net.sourceforge.pmd.lang.ast.Parser.ParserTask;\nimport net.sourceforge.pmd.lang.ast.SemanticErrorReporter;\nimport net.sourceforge.pmd.lang.document.PathId;\nimport net.sourceforge.pmd.lang.document.TextDocument;\nimport net.sourceforge.pmd.util.log.MessageReporter;\n\n/**\n * @author Cl\u00e9ment Fournier\n */\npublic class DummyParsingHelper implements Extension, BeforeEachCallback, AfterEachCallback {\n\n    private LanguageProcessor dummyProcessor;\n\n    public DummyParsingHelper() {\n\n    }\n\n    public DummyRootNode parse(String code) {\n        return parse(code, PathId.UNKNOWN);\n    }\n\n    public DummyRootNode parse(String code, String filename) {\n        return parse(code, PathId.fromPathLikeString(filename));\n    }\n    public DummyRootNode parse(String code, PathId filename) {\n        LanguageVersion version = DummyLanguageModule.getInstance().getDefaultVersion();\n        ParserTask task = new ParserTask(\n            TextDocument.readOnlyString(code, filename, version),\n            SemanticErrorReporter.noop(),\n            LanguageProcessorRegistry.singleton(dummyProcessor));\n        return (DummyRootNode) dummyProcessor.services().getParser().parse(task);\n    }\n\n    @Override\n    public void afterEach(ExtensionContext context) throws Exception {\n        dummyProcessor.close();\n    }\n\n    @Override\n    public void beforeEach(ExtensionContext context) throws Exception {\n        LanguageProcessorRegistry registry = LanguageProcessorRegistry.create(\n            LanguageRegistry.PMD,\n            Collections.emptyMap(),\n            MessageReporter.quiet()\n        );\n        dummyProcessor = registry.getProcessor(DummyLanguageModule.getInstance());\n    }\n}\n",
        "diffSourceCodeSet": [
            "public DummyRootNode parse(String code, PathId filename) {\n        LanguageVersion version = DummyLanguageModule.getInstance().getDefaultVersion();\n        ParserTask task = new ParserTask(\n            TextDocument.readOnlyString(code, filename, version),\n            SemanticErrorReporter.noop(),\n            LanguageProcessorRegistry.singleton(dummyProcessor));\n        return (DummyRootNode) dummyProcessor.services().getParser().parse(task);\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.reporting.GlobalAnalysisListener#noop\n methodBody: static GlobalAnalysisListener noop() {\nreturn NoopAnalysisListener.INSTANCE;\n}",
            "methodSignature: net.sourceforge.pmd.lang.ast.impl.javacc.JjtreeParserAdapter#parse\n methodBody: public final R parse(ParserTask task) throws ParseException {\ntryCharStream charStream=CharStream.create(task.getTextDocument(),tokenBehavior());\ntask=task.withTextDocument(charStream.getTokenDocument().getTextDocument());\nreturn parseImpl(charStream,task);\ncatch(FileAnalysisException tme)throw tme.setFileName(task.getFileDisplayName());\n}",
            "methodSignature: net.sourceforge.pmd.lang.impl.PmdRunnable#parse\n methodBody: private RootNode parse(Parser parser, ParserTask task) {\ntry(TimedOperation ignored=TimeTracker.startOperation(TimedOperationCategory.PARSER))return parser.parse(task);\n}",
            "methodSignature: net.sourceforge.pmd.lang.ast.Parser#parse\n methodBody: RootNode parse(ParserTask task) throws FileAnalysisException;",
            "methodSignature: net.sourceforge.pmd.lang.document.TextDocument#readOnlyString\n methodBody: static TextDocument readOnlyString(@NonNull CharSequence source, @NonNull String filename, @NonNull LanguageVersion lv) {\nTextFile textFile=TextFile.forCharSeq(source,filename,lv);\ntryreturn create(textFile);\ncatch(IOException e)throw new AssertionError(\"String text file should never throw IOException\",e);\n}",
            "methodSignature: net.sourceforge.pmd.DummyParsingHelper#parse\n methodBody: public DummyRootNode parse(String code, String filename) {\nLanguageVersion version=DummyLanguageModule.getInstance().getDefaultVersion();\nParserTask task=new ParserTask(TextDocument.readOnlyString(code,filename,version),SemanticErrorReporter.noop(),LanguageProcessorRegistry.singleton(dummyProcessor));\nreturn (DummyRootNode)dummyProcessor.services().getParser().parse(task);\n}",
            "methodSignature: net.sourceforge.pmd.lang.apex.ast.ApexParser#parse\n methodBody: public ASTApexFile parse(final ParserTask task) {\ntryfinal Compilation astRoot=CompilerService.INSTANCE.parseApex(task.getTextDocument());\nassert astRoot != null : \"Normally replaced by Compilation.INVALID\";\nfinal ApexTreeBuilder treeBuilder=new ApexTreeBuilder(task,(ApexLanguageProcessor)task.getLanguageProcessor());\nreturn treeBuilder.buildTree(astRoot);\ncatch(ParseException e)throw new ParseException(e).setFileName(task.getFileDisplayName());\n}"
        ],
        "sourceCodeAfterRefactoring": "public DummyRootNode parse(String code, String filename) {\n        return parse(code, PathId.fromPathLikeString(filename));\n    }\npublic DummyRootNode parse(String code, PathId filename) {\n        LanguageVersion version = DummyLanguageModule.getInstance().getDefaultVersion();\n        ParserTask task = new ParserTask(\n            TextDocument.readOnlyString(code, filename, version),\n            SemanticErrorReporter.noop(),\n            LanguageProcessorRegistry.singleton(dummyProcessor));\n        return (DummyRootNode) dummyProcessor.services().getParser().parse(task);\n    }",
        "diffSourceCode": "    41:     public DummyRootNode parse(String code, String filename) {\n-   42:         LanguageVersion version = DummyLanguageModule.getInstance().getDefaultVersion();\n-   43:         ParserTask task = new ParserTask(\n-   44:             TextDocument.readOnlyString(code, filename, version),\n-   45:             SemanticErrorReporter.noop(),\n-   46:             LanguageProcessorRegistry.singleton(dummyProcessor));\n-   47:         return (DummyRootNode) dummyProcessor.services().getParser().parse(task);\n-   48:     }\n-   49: \n-   50:     @Override\n-   51:     public void afterEach(ExtensionContext context) throws Exception {\n+   42:         return parse(code, PathId.fromPathLikeString(filename));\n+   43:     }\n+   44:     public DummyRootNode parse(String code, PathId filename) {\n+   45:         LanguageVersion version = DummyLanguageModule.getInstance().getDefaultVersion();\n+   46:         ParserTask task = new ParserTask(\n+   47:             TextDocument.readOnlyString(code, filename, version),\n+   48:             SemanticErrorReporter.noop(),\n+   49:             LanguageProcessorRegistry.singleton(dummyProcessor));\n+   50:         return (DummyRootNode) dummyProcessor.services().getParser().parse(task);\n+   51:     }\n",
        "uniqueId": "2d7e200db172644181ff14e49faf1cd42698a552_41_48_44_51_41_43",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17
    },
    {
        "type": "Inline Method",
        "description": "Inline Method\tpublic applyIterator(iter Iterator<? extends I>, filtermap Filtermap<? super I,? extends O>) : Iterator<O> inlined to public filterMap(iter Iterator<? extends I>) : Iterator<O> in class net.sourceforge.pmd.lang.ast.internal.Filtermap",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/Filtermap.java",
                "startLine": 45,
                "endLine": 48,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/Filtermap.java",
                "startLine": 45,
                "endLine": 48,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/Filtermap.java",
                "startLine": 50,
                "endLine": 52,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "static <I, O> Iterator<O> applyIterator(Iterator<? extends I> iter, Filtermap<? super I, ? extends O> filtermap) {\n        return IteratorUtil.mapNotNull(iter, filtermap);\n    }",
        "filePathBefore": "pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/Filtermap.java",
        "isPureRefactoring": true,
        "commitId": "8c448f2fd856515e5e36a1f6dd23ebcaddf23282",
        "packageNameBefore": "net.sourceforge.pmd.lang.ast.internal",
        "classNameBefore": "net.sourceforge.pmd.lang.ast.internal.Filtermap",
        "methodNameBefore": "net.sourceforge.pmd.lang.ast.internal.Filtermap#applyIterator",
        "classSignatureBefore": "interface Filtermap<I, O> extends Function<@NonNull I, @Nullable O>, Predicate<@NonNull I> ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.ast.internal.Filtermap#applyIterator"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.ast.internal.Filtermap"
        ],
        "classSignatureBeforeSet": [
            "interface Filtermap<I, O> extends Function<@NonNull I, @Nullable O>, Predicate<@NonNull I> "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.ast.internal;\n\n\nimport java.util.Iterator;\nimport java.util.Objects;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.util.IteratorUtil;\n\n/**\n * Combined filter/map predicate. Cannot accept null values.\n *\n * @param <I> Input type, contravariant\n * @param <O> Output type, covariant\n */\n@FunctionalInterface\ninterface Filtermap<I, O> extends Function<@NonNull I, @Nullable O>, Predicate<@NonNull I> {\n\n\n    Filtermap<Node, Node> NODE_IDENTITY = identityFilter();\n\n\n    /**\n     * Returns a null value if the filter accepts the value. Otherwise\n     * returns the transformed value. MUST return null for null parameter.\n     */\n    @Override\n    @Nullable O apply(@Nullable I i);\n\n\n    @Override\n    default boolean test(@Nullable I i) {\n        return apply(i) != null;\n    }\n\n    /** Filter an iterator. */\n    default Iterator<O> filterMap(Iterator<? extends I> iter) {\n        return applyIterator(iter, this);\n    }\n\n    static <I, O> Iterator<O> applyIterator(Iterator<? extends I> iter, Filtermap<? super I, ? extends O> filtermap) {\n        return IteratorUtil.mapNotNull(iter, filtermap);\n    }\n\n\n    /** Compose a new Filtermap, coalescing null values. */\n    default <R> Filtermap<I, R> thenApply(Function<@NonNull ? super O, @Nullable ? extends R> then) {\n        Objects.requireNonNull(then);\n        return i -> {\n            if (i == null) {\n                return null;\n            }\n            O o = this.apply(i);\n            return o == null ? null : then.apply(o);\n        };\n    }\n\n\n    default <R> Filtermap<I, R> thenCast(Class<? extends R> rClass) {\n        return thenApply(isInstance(rClass));\n    }\n\n\n    default Filtermap<I, O> thenFilter(Predicate<? super O> rClass) {\n        return thenApply(filter(rClass));\n    }\n\n\n    static <I> Filtermap<I, I> identityFilter() {\n        return new Filtermap<I, I>() {\n            @Override\n            public I apply(@Nullable I i) {\n                return i;\n            }\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public <R> Filtermap<I, R> thenApply(Function<@NonNull ? super I, @Nullable ? extends R> then) {\n                return then instanceof Filtermap ? (Filtermap<I, R>) then : Filtermap.super.thenApply(then);\n            }\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public Iterator<I> filterMap(Iterator<? extends I> iter) {\n                return (Iterator<I>) iter;\n            }\n\n            @Override\n            public String toString() {\n                return \"IdentityFilter\";\n            }\n        };\n    }\n\n\n    static <I extends O, O> Filtermap<I, O> filter(Predicate<? super @NonNull I> pred) {\n        return i -> i != null && pred.test(i) ? i : null;\n    }\n\n\n    static <I, O> Filtermap<I, O> isInstance(Class<? extends O> oClass) {\n        if (oClass == Node.class) {\n            return (Filtermap<I, O>) NODE_IDENTITY;\n        }\n\n        return new Filtermap<I, O>() {\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public @Nullable O apply(@Nullable I i) {\n                return oClass.isInstance(i) ? (O) i : null;\n            }\n\n            @Override\n            public String toString() {\n                return \"IsInstance[\" + oClass + \"]\";\n            }\n        };\n    }\n\n}\n",
        "filePathAfter": "pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/Filtermap.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.ast.internal;\n\n\nimport java.util.Iterator;\nimport java.util.Objects;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.util.IteratorUtil;\n\n/**\n * Combined filter/map predicate. Cannot accept null values.\n *\n * @param <I> Input type, contravariant\n * @param <O> Output type, covariant\n */\n@FunctionalInterface\ninterface Filtermap<I, O> extends Function<@NonNull I, @Nullable O>, Predicate<@NonNull I> {\n\n\n    Filtermap<Node, Node> NODE_IDENTITY = identityFilter();\n\n\n    /**\n     * Returns a null value if the filter accepts the value. Otherwise\n     * returns the transformed value. MUST return null for null parameter.\n     */\n    @Override\n    @Nullable O apply(@Nullable I i);\n\n\n    @Override\n    default boolean test(@Nullable I i) {\n        return apply(i) != null;\n    }\n\n    /** Filter an iterator. */\n    default Iterator<O> filterMap(Iterator<? extends I> iter) {\n        return IteratorUtil.mapNotNull(iter, this);\n    }\n\n    /** Compose a new Filtermap, coalescing null values. */\n    default <R> Filtermap<I, R> thenApply(Function<@NonNull ? super O, @Nullable ? extends R> then) {\n        Objects.requireNonNull(then);\n        return i -> {\n            if (i == null) {\n                return null;\n            }\n            O o = this.apply(i);\n            return o == null ? null : then.apply(o);\n        };\n    }\n\n\n    default <R> Filtermap<I, R> thenCast(Class<? extends R> rClass) {\n        return thenApply(isInstance(rClass));\n    }\n\n\n    default Filtermap<I, O> thenFilter(Predicate<? super O> rClass) {\n        return thenApply(filter(rClass));\n    }\n\n\n    static <I> Filtermap<I, I> identityFilter() {\n        return new Filtermap<I, I>() {\n            @Override\n            public I apply(@Nullable I i) {\n                return i;\n            }\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public <R> Filtermap<I, R> thenApply(Function<@NonNull ? super I, @Nullable ? extends R> then) {\n                return then instanceof Filtermap ? (Filtermap<I, R>) then : Filtermap.super.thenApply(then);\n            }\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public Iterator<I> filterMap(Iterator<? extends I> iter) {\n                return (Iterator<I>) iter;\n            }\n\n            @Override\n            public String toString() {\n                return \"IdentityFilter\";\n            }\n        };\n    }\n\n\n    static <I extends O, O> Filtermap<I, O> filter(Predicate<? super @NonNull I> pred) {\n        return i -> i != null && pred.test(i) ? i : null;\n    }\n\n\n    static <I, O> Filtermap<I, O> isInstance(Class<? extends O> oClass) {\n        if (oClass == Node.class) {\n            return (Filtermap<I, O>) NODE_IDENTITY;\n        }\n\n        return new Filtermap<I, O>() {\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public @Nullable O apply(@Nullable I i) {\n                return oClass.isInstance(i) ? (O) i : null;\n            }\n\n            @Override\n            public String toString() {\n                return \"IsInstance[\" + oClass + \"]\";\n            }\n        };\n    }\n\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "/** Filter an iterator. */\n    default Iterator<O> filterMap(Iterator<? extends I> iter) {\n        return IteratorUtil.mapNotNull(iter, this);\n    }",
        "diffSourceCode": "    45:     /** Filter an iterator. */\n    46:     default Iterator<O> filterMap(Iterator<? extends I> iter) {\n-   47:         return applyIterator(iter, this);\n+   47:         return IteratorUtil.mapNotNull(iter, this);\n    48:     }\n-   50:     static <I, O> Iterator<O> applyIterator(Iterator<? extends I> iter, Filtermap<? super I, ? extends O> filtermap) {\n-   51:         return IteratorUtil.mapNotNull(iter, filtermap);\n-   52:     }\n+   50:     /** Compose a new Filtermap, coalescing null values. */\n+   51:     default <R> Filtermap<I, R> thenApply(Function<@NonNull ? super O, @Nullable ? extends R> then) {\n+   52:         Objects.requireNonNull(then);\n",
        "uniqueId": "8c448f2fd856515e5e36a1f6dd23ebcaddf23282_45_48__45_48_50_52",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 4
            },
            "LINE": {
                "missed": 0,
                "covered": 1
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17
    },
    {
        "type": "Inline Method",
        "description": "Inline Method\tpublic closeAndAccumulate(closeable AutoCloseable, pending Exception) : Exception inlined to public closeAll(closeables Collection<? extends AutoCloseable>) : Exception in class net.sourceforge.pmd.internal.util.IOUtil",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/internal/util/IOUtil.java",
                "startLine": 151,
                "endLine": 167,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/internal/util/IOUtil.java",
                "startLine": 151,
                "endLine": 175,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/internal/util/IOUtil.java",
                "startLine": 190,
                "endLine": 206,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Close the given closeable. If it fails with an exception,\n     * either return that one or suppress it (if the parameter\n     * exception is already non-null).\n     */\n    public static @Nullable Exception closeAndAccumulate(AutoCloseable closeable, @Nullable Exception pending) {\n        try {\n            closeable.close();\n        } catch (Exception e) {\n            if (pending == null) {\n                return e;\n            } else {\n                pending.addSuppressed(e);\n            }\n        }\n        return pending;\n    }",
        "filePathBefore": "pmd-core/src/main/java/net/sourceforge/pmd/internal/util/IOUtil.java",
        "isPureRefactoring": true,
        "commitId": "a643c3ce29489c8c4525192d9820137cea9c5b11",
        "packageNameBefore": "net.sourceforge.pmd.internal.util",
        "classNameBefore": "net.sourceforge.pmd.internal.util.IOUtil",
        "methodNameBefore": "net.sourceforge.pmd.internal.util.IOUtil#closeAndAccumulate",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.asm.AsmSymbolResolver#close\n methodBody: public void close() throws Exception {\nclosed=true;\nException e=null;\nfor(ClassStub stub: knownStubs.values()){Closeable closeable=stub.getCloseable();\nif(closeable != null){LOG.trace(\"Closing stream for {}\",stub);\ne=IOUtil.closeAndAccumulate(closeable,e);\n}}knownStubs.clear();\nif(e != null){throw e;\n}}\nmethodSignature: net.sourceforge.pmd.internal.util.IOUtil.fromWriter.WriterOutputStream#close\n methodBody: public void close() throws IOException {\nflush();\ndecodeByteBuffer(true);\nwriter.close();\n}\nmethodSignature: net.sourceforge.pmd.lang.java.types.TypeSystem#close\n methodBody: public void close() throws Exception {\nthis.resolver.close();\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.asm.Loader.FailedLoader#close\n methodBody: public void close() throws IOException {\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.asm.Loader.StreamLoader#close\n methodBody: public void close() throws IOException {\nif(stream != null){stream.close();\n}}\nmethodSignature: net.sourceforge.pmd.lang.java.symbols.internal.ast.MapSymResolver#close\n methodBody: public void close() throws Exception {\n}\nmethodSignature: net.sourceforge.pmd.internal.util.IOUtil.fromReader.ReaderInputStream#close\n methodBody: public void close() throws IOException {\nreader.close();\n}\nmethodSignature: net.sourceforge.pmd.lang.java.internal.JavaLanguageProcessor#close\n methodBody: public void close() throws Exception {\nsuper.close();\nthis.typeSystem.close();\n}",
        "classSignatureBefore": "public final class IOUtil ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.internal.util.IOUtil#closeAndAccumulate"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.internal.util.IOUtil"
        ],
        "classSignatureBeforeSet": [
            "public final class IOUtil "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "",
                "description": "Return statements added",
                "mappingState": 2
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.internal.util;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FilterInputStream;\nimport java.io.FilterOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.CharsetEncoder;\nimport java.nio.charset.CodingErrorAction;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.charset.UnsupportedCharsetException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Objects;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\n/**\n *\n * @author Brian Remedios\n */\npublic final class IOUtil {\n    /**\n     * Unicode BOM character. Replaces commons io ByteOrderMark.\n     */\n    public static final char UTF_BOM = '\\uFEFF';\n    /** Conventional return value for readers. */\n    public static final int EOF = -1;\n    private static final int BUFFER_SIZE = 8192;\n\n    private IOUtil() {\n    }\n\n    /**\n     * Creates a writer that writes to stdout using the system default charset.\n     *\n     * @return a writer, never null\n     *\n     * @see #createWriter(String)\n     * @see #createWriter(Charset, String)\n     */\n    public static Writer createWriter() {\n        return createWriter(null);\n    }\n\n    /**\n     * Gets the current default charset.\n     *\n     * <p>In contrast to {@link Charset#defaultCharset()}, the result is not cached,\n     * so that in unit tests, the charset can be changed.\n     * @return\n     */\n    private static Charset getDefaultCharset() {\n        String csn = AccessController.doPrivileged(new PrivilegedAction<String>() {\n            @Override\n            public String run() {\n                return System.getProperty(\"file.encoding\");\n            }\n        });\n        try {\n            return Charset.forName(csn);\n        } catch (UnsupportedCharsetException e) {\n            return StandardCharsets.UTF_8;\n        }\n    }\n\n    /**\n     * Creates a writer that writes to the given file or to stdout.\n     * The file is created if it does not exist.\n     *\n     * <p>Warning: This writer always uses the system default charset.\n     *\n     * @param reportFile the file name (optional)\n     *\n     * @return the writer, never null\n     */\n    public static Writer createWriter(String reportFile) {\n        return createWriter(getDefaultCharset(), reportFile);\n    }\n\n    /**\n     * Creates a writer that writes to the given file or to stdout.\n     * The file is created if it does not exist.\n     *\n     * <p>Unlike {@link #createWriter(String)}, this method always uses\n     * the given charset. Even for writing to stdout. It never\n     * falls back to the default charset.</p>\n     *\n     * @param charset the charset to be used (required)\n     * @param reportFile the file name (optional)\n     * @return\n     */\n    public static Writer createWriter(Charset charset, String reportFile) {\n        try {\n            if (StringUtils.isBlank(reportFile)) {\n                return new OutputStreamWriter(new FilterOutputStream(System.out) {\n                    @Override\n                    public void close() {\n                        // avoid closing stdout, simply flush\n                        try {\n                            out.flush();\n                        } catch (IOException ignored) {\n                            // Nothing left to do\n                        }\n                    }\n                    \n                    @Override\n                    public void write(byte[] b, int off, int len) throws IOException {\n                        /*\n                         * FilterOutputStream iterates over each byte, asking subclasses to provide more efficient implementations\n                         * It therefore negates any such optimizations that the underlying stream actually may implement.\n                         */\n                        out.write(b, off, len);\n                    }\n                }, charset);\n            }\n            Path path = new File(reportFile).toPath().toAbsolutePath();\n            Files.createDirectories(path.getParent()); // ensure parent dir exists\n            // this will create the file if it doesn't exist\n            return Files.newBufferedWriter(path, charset);\n        } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n\n    public static void tryCloseClassLoader(ClassLoader classLoader) {\n        if (classLoader instanceof Closeable) {\n            closeQuietly((Closeable) classLoader);\n        }\n    }\n\n    /**\n     * Close all closeable resources in order. If any exception occurs,\n     * it is saved and returned. If more than one exception occurs, the\n     * following are accumulated as suppressed exceptions in the first.\n     *\n     * @param closeables Resources to close\n     *\n     * @return An exception, or null if no 'close' routine threw\n     */\n    @SuppressWarnings(\"PMD.CloseResource\") // false-positive\n    public static Exception closeAll(Collection<? extends AutoCloseable> closeables) {\n        Exception composed = null;\n        for (AutoCloseable it : closeables) {\n            composed = closeAndAccumulate(it, composed);\n        }\n        return composed;\n    }\n\n    /**\n     * Ensure that the closeables are closed. In the end, throws the\n     * pending exception if not null, or the exception retuned by {@link #closeAll(Collection)}\n     * if not null. If both are non-null, adds one of them to the suppress\n     * list of the other, and throws that one.\n     */\n    public static void ensureClosed(List<? extends AutoCloseable> toClose,\n                                    @Nullable Exception pendingException) throws Exception {\n        Exception closeException = closeAll(toClose);\n        if (closeException != null) {\n            if (pendingException != null) {\n                closeException.addSuppressed(pendingException);\n                throw closeException;\n            }\n            // else no exception at all\n        } else if (pendingException != null) {\n            throw pendingException;\n        }\n    }\n\n\n    /**\n     * Close the given closeable. If it fails with an exception,\n     * either return that one or suppress it (if the parameter\n     * exception is already non-null).\n     */\n    public static @Nullable Exception closeAndAccumulate(AutoCloseable closeable, @Nullable Exception pending) {\n        try {\n            closeable.close();\n        } catch (Exception e) {\n            if (pending == null) {\n                return e;\n            } else {\n                pending.addSuppressed(e);\n            }\n        }\n        return pending;\n    }\n\n    // The following methods are taken from Apache Commons IO.\n    // The dependency was removed from PMD 6 because it had a security issue,\n    // and upgrading was not possible without upgrading to Java 8.\n    // See https://github.com/pmd/pmd/pull/3968\n    // TODO PMD 7: consider bringing back commons-io and cleaning this class up.\n\n\n    public static void closeQuietly(Closeable closeable) {\n        try {\n            closeable.close();\n        } catch (IOException ignored) {\n            // ignored\n        }\n    }\n\n    public static byte[] toByteArray(InputStream stream) throws IOException {\n        byte[] result = new byte[0];\n        byte[] buffer = new byte[BUFFER_SIZE];\n        int count = stream.read(buffer);\n        while (count > -1) {\n            byte[] newResult = new byte[result.length + count];\n            System.arraycopy(result, 0, newResult, 0, result.length);\n            System.arraycopy(buffer, 0, newResult, result.length, count);\n            result = newResult;\n            count = stream.read(buffer);\n        }\n        return result;\n    }\n\n    public static long skipFully(InputStream stream, long n) throws IOException {\n        if (n < 0) {\n            throw new IllegalArgumentException();\n        }\n\n        long bytesToSkip = n;\n        byte[] buffer = new byte[(int) Math.min(BUFFER_SIZE, bytesToSkip)];\n        while (bytesToSkip > 0) {\n            int count = stream.read(buffer, 0, (int) Math.min(BUFFER_SIZE, bytesToSkip));\n            if (count < 0) {\n                // reached eof\n                break;\n            }\n            bytesToSkip -= count;\n        }\n        return n - bytesToSkip;\n    }\n\n    public static String normalizePath(String path) {\n        Path path1 = Paths.get(path);\n        String normalized = path1.normalize().toString();\n        if (normalized.contains(\".\" + File.separator) || normalized.contains(\"..\" + File.separator) || \"\".equals(normalized)) {\n            return null;\n        }\n        return normalized;\n    }\n\n    public static boolean equalsNormalizedPaths(String path1, String path2) {\n        return Objects.equals(normalizePath(path1), normalizePath(path2));\n    }\n\n    public static String getFilenameExtension(String name) {\n        String filename = Paths.get(name).getFileName().toString();\n        int dot = filename.lastIndexOf('.');\n        if (dot > -1) {\n            return filename.substring(dot + 1);\n        }\n        return \"\";\n    }\n\n    public static String getFilenameBase(String name) {\n        String filename = Paths.get(name).getFileName().toString();\n        int dot = filename.lastIndexOf('.');\n        if (dot > -1) {\n            return filename.substring(0, dot);\n        }\n        return filename;\n    }\n\n    public static void copy(InputStream from, OutputStream to) throws IOException {\n        byte[] buffer = new byte[BUFFER_SIZE];\n        int count = from.read(buffer);\n        while (count > -1) {\n            to.write(buffer, 0, count);\n            count = from.read(buffer);\n        }\n    }\n\n    public static void copy(Reader from, Writer to) throws IOException {\n        char[] buffer = new char[BUFFER_SIZE];\n        int count = from.read(buffer);\n        while (count > -1) {\n            to.write(buffer, 0, count);\n            count = from.read(buffer);\n        }\n    }\n\n    public static String readFileToString(File file) throws IOException {\n        return readFileToString(file, Charset.defaultCharset());\n    }\n\n    public static String readFileToString(File file, Charset charset) throws IOException {\n        byte[] bytes = Files.readAllBytes(file.toPath());\n        return charset.decode(ByteBuffer.wrap(bytes)).toString();\n    }\n\n    public static String readToString(Reader reader) throws IOException {\n        StringBuilder sb = new StringBuilder(BUFFER_SIZE);\n        char[] buffer = new char[BUFFER_SIZE];\n        int count = reader.read(buffer);\n        while (count > -1) {\n            sb.append(buffer, 0, count);\n            count = reader.read(buffer);\n        }\n        return sb.toString();\n    }\n\n    public static String readToString(InputStream stream, Charset charset) throws IOException {\n        byte[] bytes = toByteArray(stream);\n        return charset.decode(ByteBuffer.wrap(bytes)).toString();\n    }\n\n    public static InputStream fromReader(Reader reader) throws IOException {\n        class ReaderInputStream extends InputStream {\n            private final Reader reader;\n            private final CharBuffer charBuffer = CharBuffer.allocate(BUFFER_SIZE);\n            private final ByteBuffer byteBuffer = ByteBuffer.allocate(BUFFER_SIZE);\n            private final CharsetEncoder encoder;\n\n            private boolean eof;\n\n            ReaderInputStream(Reader reader) {\n                this.reader = reader;\n                encoder = Charset.defaultCharset().newEncoder()\n                        .onMalformedInput(CodingErrorAction.REPLACE)\n                        .onUnmappableCharacter(CodingErrorAction.REPLACE);\n                charBuffer.clear();\n                byteBuffer.clear();\n                byteBuffer.flip(); // byte buffer is empty at the beginning, no bytes read yet\n            }\n\n            @Override\n            public int read() throws IOException {\n                if (!byteBuffer.hasRemaining()) {\n                    if (charBuffer.hasRemaining() && !eof) {\n                        int count = reader.read(charBuffer);\n                        eof = count == -1;\n                    }\n                    byteBuffer.clear();\n                    charBuffer.flip();\n                    encoder.encode(charBuffer, byteBuffer, eof);\n                    byteBuffer.flip();\n                    charBuffer.compact();\n                }\n\n                if (byteBuffer.hasRemaining()) {\n                    return byteBuffer.get();\n                }\n\n                return -1;\n            }\n\n            @Override\n            public int available() throws IOException {\n                return byteBuffer.remaining();\n            }\n\n            @Override\n            public void close() throws IOException {\n                reader.close();\n            }\n        }\n\n        return new ReaderInputStream(reader);\n    }\n\n    public static OutputStream fromWriter(Writer writer, String encoding) throws UnsupportedCharsetException {\n        class WriterOutputStream extends OutputStream {\n            private final Writer writer;\n            private final CharsetDecoder decoder;\n            private final ByteBuffer byteBuffer = ByteBuffer.allocate(BUFFER_SIZE);\n            private final CharBuffer charBuffer = CharBuffer.allocate(BUFFER_SIZE);\n\n            WriterOutputStream(Writer writer, String encoding) throws UnsupportedCharsetException {\n                this.writer = writer;\n                Charset charset = Charset.forName(encoding);\n                decoder = charset.newDecoder()\n                        .onMalformedInput(CodingErrorAction.REPLACE)\n                        .onUnmappableCharacter(CodingErrorAction.REPLACE);\n                byteBuffer.clear();\n                charBuffer.clear();\n            }\n\n            @Override\n            public void write(int b) throws IOException {\n                if (!byteBuffer.hasRemaining()) {\n                    decodeByteBuffer(false);\n                }\n                byteBuffer.put((byte) b);\n            }\n\n            @Override\n            public void flush() throws IOException {\n                decodeByteBuffer(false);\n            }\n\n            private void decodeByteBuffer(boolean isClosing) throws IOException {\n                byteBuffer.flip();\n                charBuffer.clear();\n                decoder.decode(byteBuffer, charBuffer, isClosing);\n                writer.write(charBuffer.array(), 0, charBuffer.position());\n                writer.flush();\n                byteBuffer.compact();\n            }\n\n            @Override\n            public void close() throws IOException {\n                flush();\n                decodeByteBuffer(true);\n                writer.close();\n            }\n        }\n\n        return new WriterOutputStream(writer, encoding);\n    }\n\n    /**\n     * <p>\n     * Input stream that skips an optional byte order mark at the beginning\n     * of the stream. Whether the stream had a byte order mark (encoded in either UTF-8,\n     * UTF-16LE or UTF-16BE) can be checked with {@link #hasBom()}. The corresponding\n     * charset can be retrieved with {@link #getBomCharsetName()}.\n     * </p>\n     *\n     * <p>\n     * If the stream didn't had a BOM, then no bytes are skipped.\n     * </p>\n     */\n    public static class BomAwareInputStream extends FilterInputStream {\n\n        private byte[] begin;\n        int beginIndex;\n\n        private String charset;\n\n        public BomAwareInputStream(InputStream in) {\n            super(in);\n            begin = determineBom();\n        }\n\n        private byte[] determineBom() {\n            byte[] bytes = new byte[3];\n            try {\n                int count = in.read(bytes);\n                if (count == 3 && bytes[0] == (byte) 0xef && bytes[1] == (byte) 0xbb && bytes[2] == (byte) 0xbf) {\n                    charset = StandardCharsets.UTF_8.name();\n                    return new byte[0]; // skip all 3 bytes\n                } else if (count >= 2 && bytes[0] == (byte) 0xfe && bytes[1] == (byte) 0xff) {\n                    charset = StandardCharsets.UTF_16BE.name();\n                    return new byte[] { bytes[2] };\n                } else if (count >= 2 && bytes[0] == (byte) 0xff && bytes[1] == (byte) 0xfe) {\n                    charset = StandardCharsets.UTF_16LE.name();\n                    return new byte[] { bytes[2] };\n                } else if (count == 3) {\n                    return bytes;\n                }\n\n                if (count < 0) {\n                    return new byte[0];\n                }\n\n                byte[] read = new byte[count];\n                for (int i = 0; i < count; i++) {\n                    read[i] = bytes[i];\n                }\n                return read;\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        @Override\n        public int read() throws IOException {\n            if (beginIndex < begin.length) {\n                return begin[beginIndex++];\n            }\n            return super.read();\n        }\n\n        @Override\n        public int read(byte[] b, int off, int len) throws IOException {\n            if (beginIndex < begin.length) {\n                int count = 0;\n                for (; count < len && beginIndex < begin.length; beginIndex++) {\n                    b[off + count] = begin[beginIndex];\n                    count++;\n                }\n                return count;\n            }\n            return super.read(b, off, len);\n        }\n\n        public boolean hasBom() {\n            return charset != null;\n        }\n\n        public String getBomCharsetName() {\n            return charset;\n        }\n    }\n}\n",
        "filePathAfter": "pmd-core/src/main/java/net/sourceforge/pmd/internal/util/IOUtil.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.internal.util;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FilterInputStream;\nimport java.io.FilterOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.CharsetEncoder;\nimport java.nio.charset.CodingErrorAction;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.charset.UnsupportedCharsetException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Objects;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\n/**\n *\n * @author Brian Remedios\n */\npublic final class IOUtil {\n    /**\n     * Unicode BOM character. Replaces commons io ByteOrderMark.\n     */\n    public static final char UTF_BOM = '\\uFEFF';\n    /** Conventional return value for readers. */\n    public static final int EOF = -1;\n    private static final int BUFFER_SIZE = 8192;\n\n    private IOUtil() {\n    }\n\n    /**\n     * Creates a writer that writes to stdout using the system default charset.\n     *\n     * @return a writer, never null\n     *\n     * @see #createWriter(String)\n     * @see #createWriter(Charset, String)\n     */\n    public static Writer createWriter() {\n        return createWriter(null);\n    }\n\n    /**\n     * Gets the current default charset.\n     *\n     * <p>In contrast to {@link Charset#defaultCharset()}, the result is not cached,\n     * so that in unit tests, the charset can be changed.\n     * @return\n     */\n    private static Charset getDefaultCharset() {\n        String csn = AccessController.doPrivileged(new PrivilegedAction<String>() {\n            @Override\n            public String run() {\n                return System.getProperty(\"file.encoding\");\n            }\n        });\n        try {\n            return Charset.forName(csn);\n        } catch (UnsupportedCharsetException e) {\n            return StandardCharsets.UTF_8;\n        }\n    }\n\n    /**\n     * Creates a writer that writes to the given file or to stdout.\n     * The file is created if it does not exist.\n     *\n     * <p>Warning: This writer always uses the system default charset.\n     *\n     * @param reportFile the file name (optional)\n     *\n     * @return the writer, never null\n     */\n    public static Writer createWriter(String reportFile) {\n        return createWriter(getDefaultCharset(), reportFile);\n    }\n\n    /**\n     * Creates a writer that writes to the given file or to stdout.\n     * The file is created if it does not exist.\n     *\n     * <p>Unlike {@link #createWriter(String)}, this method always uses\n     * the given charset. Even for writing to stdout. It never\n     * falls back to the default charset.</p>\n     *\n     * @param charset the charset to be used (required)\n     * @param reportFile the file name (optional)\n     * @return\n     */\n    public static Writer createWriter(Charset charset, String reportFile) {\n        try {\n            if (StringUtils.isBlank(reportFile)) {\n                return new OutputStreamWriter(new FilterOutputStream(System.out) {\n                    @Override\n                    public void close() {\n                        // avoid closing stdout, simply flush\n                        try {\n                            out.flush();\n                        } catch (IOException ignored) {\n                            // Nothing left to do\n                        }\n                    }\n                    \n                    @Override\n                    public void write(byte[] b, int off, int len) throws IOException {\n                        /*\n                         * FilterOutputStream iterates over each byte, asking subclasses to provide more efficient implementations\n                         * It therefore negates any such optimizations that the underlying stream actually may implement.\n                         */\n                        out.write(b, off, len);\n                    }\n                }, charset);\n            }\n            Path path = new File(reportFile).toPath().toAbsolutePath();\n            Files.createDirectories(path.getParent()); // ensure parent dir exists\n            // this will create the file if it doesn't exist\n            return Files.newBufferedWriter(path, charset);\n        } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n\n    public static void tryCloseClassLoader(ClassLoader classLoader) {\n        if (classLoader instanceof Closeable) {\n            closeQuietly((Closeable) classLoader);\n        }\n    }\n\n    /**\n     * Close all closeable resources in order. If any exception occurs,\n     * it is saved and returned. If more than one exception occurs, the\n     * following are accumulated as suppressed exceptions in the first.\n     *\n     * @param closeables Resources to close\n     *\n     * @return An exception, or null if no 'close' routine threw\n     */\n    @SuppressWarnings(\"PMD.CloseResource\") // false-positive\n    public static Exception closeAll(Collection<? extends AutoCloseable> closeables) {\n        Exception composed = null;\n        for (AutoCloseable it : closeables) {\n            try {\n                it.close();\n            } catch (Exception e) {\n                if (composed == null) {\n                    composed = e;\n                } else {\n                    composed.addSuppressed(e);\n                }\n            }\n        }\n        return composed;\n    }\n\n    /**\n     * Ensure that the closeables are closed. In the end, throws the\n     * pending exception if not null, or the exception retuned by {@link #closeAll(Collection)}\n     * if not null. If both are non-null, adds one of them to the suppress\n     * list of the other, and throws that one.\n     */\n    public static void ensureClosed(List<? extends AutoCloseable> toClose,\n                                    @Nullable Exception pendingException) throws Exception {\n        Exception closeException = closeAll(toClose);\n        if (closeException != null) {\n            if (pendingException != null) {\n                closeException.addSuppressed(pendingException);\n                throw closeException;\n            }\n            // else no exception at all\n        } else if (pendingException != null) {\n            throw pendingException;\n        }\n    }\n\n\n    // The following methods are taken from Apache Commons IO.\n    // The dependency was removed from PMD 6 because it had a security issue,\n    // and upgrading was not possible without upgrading to Java 8.\n    // See https://github.com/pmd/pmd/pull/3968\n    // TODO PMD 7: consider bringing back commons-io and cleaning this class up.\n\n    public static void closeQuietly(Closeable closeable) {\n        try {\n            closeable.close();\n        } catch (IOException ignored) {\n            // ignored\n        }\n    }\n\n    public static byte[] toByteArray(InputStream stream) throws IOException {\n        byte[] result = new byte[0];\n        byte[] buffer = new byte[BUFFER_SIZE];\n        int count = stream.read(buffer);\n        while (count > -1) {\n            byte[] newResult = new byte[result.length + count];\n            System.arraycopy(result, 0, newResult, 0, result.length);\n            System.arraycopy(buffer, 0, newResult, result.length, count);\n            result = newResult;\n            count = stream.read(buffer);\n        }\n        return result;\n    }\n\n    public static long skipFully(InputStream stream, long n) throws IOException {\n        if (n < 0) {\n            throw new IllegalArgumentException();\n        }\n\n        long bytesToSkip = n;\n        byte[] buffer = new byte[(int) Math.min(BUFFER_SIZE, bytesToSkip)];\n        while (bytesToSkip > 0) {\n            int count = stream.read(buffer, 0, (int) Math.min(BUFFER_SIZE, bytesToSkip));\n            if (count < 0) {\n                // reached eof\n                break;\n            }\n            bytesToSkip -= count;\n        }\n        return n - bytesToSkip;\n    }\n\n    public static String normalizePath(String path) {\n        Path path1 = Paths.get(path);\n        String normalized = path1.normalize().toString();\n        if (normalized.contains(\".\" + File.separator) || normalized.contains(\"..\" + File.separator) || \"\".equals(normalized)) {\n            return null;\n        }\n        return normalized;\n    }\n\n    public static boolean equalsNormalizedPaths(String path1, String path2) {\n        return Objects.equals(normalizePath(path1), normalizePath(path2));\n    }\n\n    public static String getFilenameExtension(String name) {\n        String filename = Paths.get(name).getFileName().toString();\n        int dot = filename.lastIndexOf('.');\n        if (dot > -1) {\n            return filename.substring(dot + 1);\n        }\n        return \"\";\n    }\n\n    public static String getFilenameBase(String name) {\n        String filename = Paths.get(name).getFileName().toString();\n        int dot = filename.lastIndexOf('.');\n        if (dot > -1) {\n            return filename.substring(0, dot);\n        }\n        return filename;\n    }\n\n    public static void copy(InputStream from, OutputStream to) throws IOException {\n        byte[] buffer = new byte[BUFFER_SIZE];\n        int count = from.read(buffer);\n        while (count > -1) {\n            to.write(buffer, 0, count);\n            count = from.read(buffer);\n        }\n    }\n\n    public static void copy(Reader from, Writer to) throws IOException {\n        char[] buffer = new char[BUFFER_SIZE];\n        int count = from.read(buffer);\n        while (count > -1) {\n            to.write(buffer, 0, count);\n            count = from.read(buffer);\n        }\n    }\n\n    public static String readFileToString(File file) throws IOException {\n        return readFileToString(file, Charset.defaultCharset());\n    }\n\n    public static String readFileToString(File file, Charset charset) throws IOException {\n        byte[] bytes = Files.readAllBytes(file.toPath());\n        return charset.decode(ByteBuffer.wrap(bytes)).toString();\n    }\n\n    public static String readToString(Reader reader) throws IOException {\n        StringBuilder sb = new StringBuilder(BUFFER_SIZE);\n        char[] buffer = new char[BUFFER_SIZE];\n        int count = reader.read(buffer);\n        while (count > -1) {\n            sb.append(buffer, 0, count);\n            count = reader.read(buffer);\n        }\n        return sb.toString();\n    }\n\n    public static String readToString(InputStream stream, Charset charset) throws IOException {\n        byte[] bytes = toByteArray(stream);\n        return charset.decode(ByteBuffer.wrap(bytes)).toString();\n    }\n\n    public static InputStream fromReader(Reader reader) throws IOException {\n        class ReaderInputStream extends InputStream {\n            private final Reader reader;\n            private final CharBuffer charBuffer = CharBuffer.allocate(BUFFER_SIZE);\n            private final ByteBuffer byteBuffer = ByteBuffer.allocate(BUFFER_SIZE);\n            private final CharsetEncoder encoder;\n\n            private boolean eof;\n\n            ReaderInputStream(Reader reader) {\n                this.reader = reader;\n                encoder = Charset.defaultCharset().newEncoder()\n                        .onMalformedInput(CodingErrorAction.REPLACE)\n                        .onUnmappableCharacter(CodingErrorAction.REPLACE);\n                charBuffer.clear();\n                byteBuffer.clear();\n                byteBuffer.flip(); // byte buffer is empty at the beginning, no bytes read yet\n            }\n\n            @Override\n            public int read() throws IOException {\n                if (!byteBuffer.hasRemaining()) {\n                    if (charBuffer.hasRemaining() && !eof) {\n                        int count = reader.read(charBuffer);\n                        eof = count == -1;\n                    }\n                    byteBuffer.clear();\n                    charBuffer.flip();\n                    encoder.encode(charBuffer, byteBuffer, eof);\n                    byteBuffer.flip();\n                    charBuffer.compact();\n                }\n\n                if (byteBuffer.hasRemaining()) {\n                    return byteBuffer.get();\n                }\n\n                return -1;\n            }\n\n            @Override\n            public int available() throws IOException {\n                return byteBuffer.remaining();\n            }\n\n            @Override\n            public void close() throws IOException {\n                reader.close();\n            }\n        }\n\n        return new ReaderInputStream(reader);\n    }\n\n    public static OutputStream fromWriter(Writer writer, String encoding) throws UnsupportedCharsetException {\n        class WriterOutputStream extends OutputStream {\n            private final Writer writer;\n            private final CharsetDecoder decoder;\n            private final ByteBuffer byteBuffer = ByteBuffer.allocate(BUFFER_SIZE);\n            private final CharBuffer charBuffer = CharBuffer.allocate(BUFFER_SIZE);\n\n            WriterOutputStream(Writer writer, String encoding) throws UnsupportedCharsetException {\n                this.writer = writer;\n                Charset charset = Charset.forName(encoding);\n                decoder = charset.newDecoder()\n                        .onMalformedInput(CodingErrorAction.REPLACE)\n                        .onUnmappableCharacter(CodingErrorAction.REPLACE);\n                byteBuffer.clear();\n                charBuffer.clear();\n            }\n\n            @Override\n            public void write(int b) throws IOException {\n                if (!byteBuffer.hasRemaining()) {\n                    decodeByteBuffer(false);\n                }\n                byteBuffer.put((byte) b);\n            }\n\n            @Override\n            public void flush() throws IOException {\n                decodeByteBuffer(false);\n            }\n\n            private void decodeByteBuffer(boolean isClosing) throws IOException {\n                byteBuffer.flip();\n                charBuffer.clear();\n                decoder.decode(byteBuffer, charBuffer, isClosing);\n                writer.write(charBuffer.array(), 0, charBuffer.position());\n                writer.flush();\n                byteBuffer.compact();\n            }\n\n            @Override\n            public void close() throws IOException {\n                flush();\n                decodeByteBuffer(true);\n                writer.close();\n            }\n        }\n\n        return new WriterOutputStream(writer, encoding);\n    }\n\n    /**\n     * <p>\n     * Input stream that skips an optional byte order mark at the beginning\n     * of the stream. Whether the stream had a byte order mark (encoded in either UTF-8,\n     * UTF-16LE or UTF-16BE) can be checked with {@link #hasBom()}. The corresponding\n     * charset can be retrieved with {@link #getBomCharsetName()}.\n     * </p>\n     *\n     * <p>\n     * If the stream didn't had a BOM, then no bytes are skipped.\n     * </p>\n     */\n    public static class BomAwareInputStream extends FilterInputStream {\n\n        private byte[] begin;\n        int beginIndex;\n\n        private String charset;\n\n        public BomAwareInputStream(InputStream in) {\n            super(in);\n            begin = determineBom();\n        }\n\n        private byte[] determineBom() {\n            byte[] bytes = new byte[3];\n            try {\n                int count = in.read(bytes);\n                if (count == 3 && bytes[0] == (byte) 0xef && bytes[1] == (byte) 0xbb && bytes[2] == (byte) 0xbf) {\n                    charset = StandardCharsets.UTF_8.name();\n                    return new byte[0]; // skip all 3 bytes\n                } else if (count >= 2 && bytes[0] == (byte) 0xfe && bytes[1] == (byte) 0xff) {\n                    charset = StandardCharsets.UTF_16BE.name();\n                    return new byte[] { bytes[2] };\n                } else if (count >= 2 && bytes[0] == (byte) 0xff && bytes[1] == (byte) 0xfe) {\n                    charset = StandardCharsets.UTF_16LE.name();\n                    return new byte[] { bytes[2] };\n                } else if (count == 3) {\n                    return bytes;\n                }\n\n                if (count < 0) {\n                    return new byte[0];\n                }\n\n                byte[] read = new byte[count];\n                for (int i = 0; i < count; i++) {\n                    read[i] = bytes[i];\n                }\n                return read;\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        @Override\n        public int read() throws IOException {\n            if (beginIndex < begin.length) {\n                return begin[beginIndex++];\n            }\n            return super.read();\n        }\n\n        @Override\n        public int read(byte[] b, int off, int len) throws IOException {\n            if (beginIndex < begin.length) {\n                int count = 0;\n                for (; count < len && beginIndex < begin.length; beginIndex++) {\n                    b[off + count] = begin[beginIndex];\n                    count++;\n                }\n                return count;\n            }\n            return super.read(b, off, len);\n        }\n\n        public boolean hasBom() {\n            return charset != null;\n        }\n\n        public String getBomCharsetName() {\n            return charset;\n        }\n    }\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.asm.AsmSymbolResolver#close\n methodBody: public void close() throws Exception {\nclosed=true;\nException e=null;\nfor(ClassStub stub: knownStubs.values()){Closeable closeable=stub.getCloseable();\nif(closeable != null){LOG.trace(\"Closing stream for {}\",stub);\ne=IOUtil.closeAndAccumulate(closeable,e);\n}}knownStubs.clear();\nif(e != null){throw e;\n}}",
            "methodSignature: net.sourceforge.pmd.internal.util.IOUtil.fromWriter.WriterOutputStream#close\n methodBody: public void close() throws IOException {\nflush();\ndecodeByteBuffer(true);\nwriter.close();\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.types.TypeSystem#close\n methodBody: public void close() throws Exception {\nthis.resolver.close();\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.asm.Loader.FailedLoader#close\n methodBody: public void close() throws IOException {\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.asm.Loader.StreamLoader#close\n methodBody: public void close() throws IOException {\nif(stream != null){stream.close();\n}}",
            "methodSignature: net.sourceforge.pmd.lang.java.symbols.internal.ast.MapSymResolver#close\n methodBody: public void close() throws Exception {\n}",
            "methodSignature: net.sourceforge.pmd.internal.util.IOUtil.fromReader.ReaderInputStream#close\n methodBody: public void close() throws IOException {\nreader.close();\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.internal.JavaLanguageProcessor#close\n methodBody: public void close() throws Exception {\nsuper.close();\nthis.typeSystem.close();\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Close all closeable resources in order. If any exception occurs,\n     * it is saved and returned. If more than one exception occurs, the\n     * following are accumulated as suppressed exceptions in the first.\n     *\n     * @param closeables Resources to close\n     *\n     * @return An exception, or null if no 'close' routine threw\n     */\n    @SuppressWarnings(\"PMD.CloseResource\") // false-positive\n    public static Exception closeAll(Collection<? extends AutoCloseable> closeables) {\n        Exception composed = null;\n        for (AutoCloseable it : closeables) {\n            try {\n                it.close();\n            } catch (Exception e) {\n                if (composed == null) {\n                    composed = e;\n                } else {\n                    composed.addSuppressed(e);\n                }\n            }\n        }\n        return composed;\n    }",
        "diffSourceCode": "   151:     /**\n   152:      * Close all closeable resources in order. If any exception occurs,\n   153:      * it is saved and returned. If more than one exception occurs, the\n   154:      * following are accumulated as suppressed exceptions in the first.\n   155:      *\n   156:      * @param closeables Resources to close\n   157:      *\n   158:      * @return An exception, or null if no 'close' routine threw\n   159:      */\n   160:     @SuppressWarnings(\"PMD.CloseResource\") // false-positive\n   161:     public static Exception closeAll(Collection<? extends AutoCloseable> closeables) {\n   162:         Exception composed = null;\n   163:         for (AutoCloseable it : closeables) {\n-  164:             composed = closeAndAccumulate(it, composed);\n-  165:         }\n-  166:         return composed;\n-  167:     }\n-  168: \n-  169:     /**\n-  170:      * Ensure that the closeables are closed. In the end, throws the\n-  171:      * pending exception if not null, or the exception retuned by {@link #closeAll(Collection)}\n-  172:      * if not null. If both are non-null, adds one of them to the suppress\n-  173:      * list of the other, and throws that one.\n-  174:      */\n-  175:     public static void ensureClosed(List<? extends AutoCloseable> toClose,\n-  190:     /**\n-  191:      * Close the given closeable. If it fails with an exception,\n-  192:      * either return that one or suppress it (if the parameter\n-  193:      * exception is already non-null).\n-  194:      */\n-  195:     public static @Nullable Exception closeAndAccumulate(AutoCloseable closeable, @Nullable Exception pending) {\n-  196:         try {\n-  197:             closeable.close();\n-  198:         } catch (Exception e) {\n-  199:             if (pending == null) {\n-  200:                 return e;\n-  201:             } else {\n-  202:                 pending.addSuppressed(e);\n-  203:             }\n-  204:         }\n-  205:         return pending;\n-  206:     }\n+  164:             try {\n+  165:                 it.close();\n+  166:             } catch (Exception e) {\n+  167:                 if (composed == null) {\n+  168:                     composed = e;\n+  169:                 } else {\n+  170:                     composed.addSuppressed(e);\n+  171:                 }\n+  172:             }\n+  173:         }\n+  174:         return composed;\n+  175:     }\n+  190:             }\n+  191:             // else no exception at all\n+  192:         } else if (pendingException != null) {\n+  193:             throw pendingException;\n+  194:         }\n+  195:     }\n+  196: \n+  197: \n+  198:     // The following methods are taken from Apache Commons IO.\n+  199:     // The dependency was removed from PMD 6 because it had a security issue,\n+  200:     // and upgrading was not possible without upgrading to Java 8.\n+  201:     // See https://github.com/pmd/pmd/pull/3968\n+  202:     // TODO PMD 7: consider bringing back commons-io and cleaning this class up.\n+  203: \n+  204:     public static void closeQuietly(Closeable closeable) {\n+  205:         try {\n+  206:             closeable.close();\n",
        "uniqueId": "a643c3ce29489c8c4525192d9820137cea9c5b11_151_167__151_175_190_206",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 8,
                "covered": 5
            },
            "BRANCH": {
                "missed": 2,
                "covered": 0
            },
            "LINE": {
                "missed": 4,
                "covered": 3
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic reportBrokenRules(report Report, rs RuleSets) : void extracted from protected createRuleSets(factory RuleSetFactory, report Report) : RuleSets in class net.sourceforge.pmd.processor.AbstractPMDProcessor",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/processor/AbstractPMDProcessor.java",
                "startLine": 71,
                "endLine": 90,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/processor/AbstractPMDProcessor.java",
                "startLine": 71,
                "endLine": 85,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/processor/AbstractPMDProcessor.java",
                "startLine": 87,
                "endLine": 92,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Create instances for each rule defined in the ruleset(s) in the\n     * configuration. Please note, that the returned instances <strong>must\n     * not</strong> be used by different threads. Each thread must create its\n     * own copy of the rules.\n     *\n     * @param factory The factory used to create the configured rule sets\n     * @param report The base report on which to report any configuration errors\n     * @return the rules within a rulesets\n     */\n    protected RuleSets createRuleSets(RuleSetFactory factory, Report report) {\n        final RuleSets rs = RulesetsFactoryUtils.getRuleSets(configuration.getRuleSets(), factory);\n\n        final Set<Rule> brokenRules = removeBrokenRules(rs);\n        for (final Rule rule : brokenRules) {\n            report.addConfigError(new Report.ConfigurationError(rule, rule.dysfunctionReason()));\n        }\n\n        return rs;\n    }",
        "filePathBefore": "pmd-core/src/main/java/net/sourceforge/pmd/processor/AbstractPMDProcessor.java",
        "isPureRefactoring": true,
        "commitId": "36e55bc2c1d4ea0a41d39fed0b9178d876b3447f",
        "packageNameBefore": "net.sourceforge.pmd.processor",
        "classNameBefore": "net.sourceforge.pmd.processor.AbstractPMDProcessor",
        "methodNameBefore": "net.sourceforge.pmd.processor.AbstractPMDProcessor#createRuleSets",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.processor.AbstractPMDProcessor#removeBrokenRules\n methodBody: private Set<Rule> removeBrokenRules(final RuleSets ruleSets) {\nfinal Set<Rule> brokenRules=new HashSet<>();\nruleSets.removeDysfunctionalRules(brokenRules);\nfor(final Rule rule: brokenRules){if(LOG.isLoggable(Level.WARNING)){LOG.log(Level.WARNING,\"Removed misconfigured rule: \" + rule.getName() + \"  cause: \" + rule.dysfunctionReason());\n}}return brokenRules;\n}",
        "classSignatureBefore": "public abstract class AbstractPMDProcessor ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.processor.AbstractPMDProcessor#createRuleSets"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.processor.AbstractPMDProcessor"
        ],
        "classSignatureBeforeSet": [
            "public abstract class AbstractPMDProcessor "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.processor;\n\nimport java.io.IOException;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.exception.ContextedRuntimeException;\n\nimport net.sourceforge.pmd.PMDConfiguration;\nimport net.sourceforge.pmd.Report;\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RuleContext;\nimport net.sourceforge.pmd.RuleSetFactory;\nimport net.sourceforge.pmd.RuleSets;\nimport net.sourceforge.pmd.RulesetsFactoryUtils;\nimport net.sourceforge.pmd.SourceCodeProcessor;\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.benchmark.TimeTracker;\nimport net.sourceforge.pmd.benchmark.TimedOperation;\nimport net.sourceforge.pmd.benchmark.TimedOperationCategory;\nimport net.sourceforge.pmd.renderers.Renderer;\nimport net.sourceforge.pmd.util.datasource.DataSource;\n\n/**\n * @author Romain Pelisse &lt;belaran@gmail.com&gt;\n *\n * @deprecated Is internal API\n */\n@Deprecated\n@InternalApi\npublic abstract class AbstractPMDProcessor {\n\n    private static final Logger LOG = Logger.getLogger(AbstractPMDProcessor.class.getName());\n\n    protected final PMDConfiguration configuration;\n\n    public AbstractPMDProcessor(PMDConfiguration configuration) {\n        this.configuration = configuration;\n    }\n\n    public void renderReports(final List<Renderer> renderers, final Report report) {\n\n        try (TimedOperation to = TimeTracker.startOperation(TimedOperationCategory.REPORTING)) {\n            for (Renderer r : renderers) {\n                r.renderFileReport(report);\n            }\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n    }\n\n    /**\n     *\n     * @deprecated this method will be removed. It was once used to determine a short filename\n     * for the file being analyzed, so that shortnames can be reported. But the logic has\n     * been moved to the renderers.\n     */\n    @Deprecated\n    protected String filenameFrom(DataSource dataSource) {\n        return dataSource.getNiceFileName(configuration.isReportShortNames(), configuration.getInputPaths());\n    }\n\n    /**\n     * Create instances for each rule defined in the ruleset(s) in the\n     * configuration. Please note, that the returned instances <strong>must\n     * not</strong> be used by different threads. Each thread must create its\n     * own copy of the rules.\n     *\n     * @param factory The factory used to create the configured rule sets\n     * @param report The base report on which to report any configuration errors\n     * @return the rules within a rulesets\n     */\n    protected RuleSets createRuleSets(RuleSetFactory factory, Report report) {\n        final RuleSets rs = RulesetsFactoryUtils.getRuleSets(configuration.getRuleSets(), factory);\n\n        final Set<Rule> brokenRules = removeBrokenRules(rs);\n        for (final Rule rule : brokenRules) {\n            report.addConfigError(new Report.ConfigurationError(rule, rule.dysfunctionReason()));\n        }\n\n        return rs;\n    }\n\n    /**\n     * Remove and return the misconfigured rules from the rulesets and log them\n     * for good measure.\n     *\n     * @param ruleSets RuleSets to prune of broken rules.\n     * @return Set<Rule>\n     */\n    private Set<Rule> removeBrokenRules(final RuleSets ruleSets) {\n        final Set<Rule> brokenRules = new HashSet<>();\n        ruleSets.removeDysfunctionalRules(brokenRules);\n\n        for (final Rule rule : brokenRules) {\n            if (LOG.isLoggable(Level.WARNING)) {\n                LOG.log(Level.WARNING,\n                        \"Removed misconfigured rule: \" + rule.getName() + \"  cause: \" + rule.dysfunctionReason());\n            }\n        }\n\n        return brokenRules;\n    }\n\n    @SuppressWarnings(\"PMD.CloseResource\")\n    // the data sources must only be closed after the threads are finished\n    // this is done manually without a try-with-resources\n    @Deprecated\n    public void processFiles(RuleSetFactory ruleSetFactory, List<DataSource> files, RuleContext ctx,\n                             List<Renderer> renderers) {\n        try {\n            final RuleSets rs = createRuleSets(ruleSetFactory, ctx.getReport());\n            processFiles(rs, files, ctx, renderers);\n        } finally {\n            // in case we analyzed files within Zip Files/Jars, we need to close them after\n            // the analysis is finished\n            for (DataSource dataSource : files) {\n                IOUtils.closeQuietly(dataSource);\n            }\n        }\n    }\n\n    @SuppressWarnings(\"PMD.CloseResource\")\n    // the data sources must only be closed after the threads are finished\n    // this is done manually without a try-with-resources\n    public void processFiles(RuleSets rs, List<DataSource> files, RuleContext ctx, List<Renderer> renderers) {\n        try {\n            configuration.getAnalysisCache().checkValidity(rs, configuration.getClassLoader());\n            final SourceCodeProcessor processor = new SourceCodeProcessor(configuration);\n\n            for (final DataSource dataSource : files) {\n                // this is the real, canonical and absolute filename (not shortened)\n                String realFileName = dataSource.getNiceFileName(false, null);\n\n                runAnalysis(new PmdRunnable(dataSource, realFileName, renderers, ctx, rs, processor));\n            }\n\n            // render base report first - general errors\n            renderReports(renderers, ctx.getReport());\n\n            // then add analysis results per file\n            collectReports(renderers);\n        } catch (RuntimeException e) {\n            throw new ContextedRuntimeException(e).addContextValue(\"filename\", String.valueOf(ctx.getSourceCodeFile()));\n        } finally {\n            // in case we analyzed files within Zip Files/Jars, we need to close them after\n            // the analysis is finished\n            for (DataSource dataSource : files) {\n                IOUtils.closeQuietly(dataSource);\n            }\n        }\n    }\n\n    protected abstract void runAnalysis(PmdRunnable runnable);\n\n    protected abstract void collectReports(List<Renderer> renderers);\n}\n",
        "filePathAfter": "pmd-core/src/main/java/net/sourceforge/pmd/processor/AbstractPMDProcessor.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.processor;\n\nimport java.io.IOException;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.exception.ContextedRuntimeException;\n\nimport net.sourceforge.pmd.PMDConfiguration;\nimport net.sourceforge.pmd.Report;\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RuleContext;\nimport net.sourceforge.pmd.RuleSetFactory;\nimport net.sourceforge.pmd.RuleSets;\nimport net.sourceforge.pmd.RulesetsFactoryUtils;\nimport net.sourceforge.pmd.SourceCodeProcessor;\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.benchmark.TimeTracker;\nimport net.sourceforge.pmd.benchmark.TimedOperation;\nimport net.sourceforge.pmd.benchmark.TimedOperationCategory;\nimport net.sourceforge.pmd.renderers.Renderer;\nimport net.sourceforge.pmd.util.datasource.DataSource;\n\n/**\n * @author Romain Pelisse &lt;belaran@gmail.com&gt;\n *\n * @deprecated Is internal API\n */\n@Deprecated\n@InternalApi\npublic abstract class AbstractPMDProcessor {\n\n    private static final Logger LOG = Logger.getLogger(AbstractPMDProcessor.class.getName());\n\n    protected final PMDConfiguration configuration;\n\n    public AbstractPMDProcessor(PMDConfiguration configuration) {\n        this.configuration = configuration;\n    }\n\n    public void renderReports(final List<Renderer> renderers, final Report report) {\n\n        try (TimedOperation to = TimeTracker.startOperation(TimedOperationCategory.REPORTING)) {\n            for (Renderer r : renderers) {\n                r.renderFileReport(report);\n            }\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n    }\n\n    /**\n     *\n     * @deprecated this method will be removed. It was once used to determine a short filename\n     * for the file being analyzed, so that shortnames can be reported. But the logic has\n     * been moved to the renderers.\n     */\n    @Deprecated\n    protected String filenameFrom(DataSource dataSource) {\n        return dataSource.getNiceFileName(configuration.isReportShortNames(), configuration.getInputPaths());\n    }\n\n    /**\n     * Create instances for each rule defined in the ruleset(s) in the\n     * configuration. Please note, that the returned instances <strong>must\n     * not</strong> be used by different threads. Each thread must create its\n     * own copy of the rules.\n     *\n     * @param factory The factory used to create the configured rule sets\n     * @param report The base report on which to report any configuration errors\n     * @return the rules within a rulesets\n     */\n    protected RuleSets createRuleSets(RuleSetFactory factory, Report report) {\n        final RuleSets rs = RulesetsFactoryUtils.getRuleSets(configuration.getRuleSets(), factory);\n        reportBrokenRules(report, rs);\n        return rs;\n    }\n\n    public static void reportBrokenRules(Report report, RuleSets rs) {\n        final Set<Rule> brokenRules = removeBrokenRules(rs);\n        for (final Rule rule : brokenRules) {\n            report.addConfigError(new Report.ConfigurationError(rule, rule.dysfunctionReason()));\n        }\n    }\n\n    /**\n     * Remove and return the misconfigured rules from the rulesets and log them\n     * for good measure.\n     *\n     * @param ruleSets RuleSets to prune of broken rules.\n     * @return Set<Rule>\n     */\n    private static Set<Rule> removeBrokenRules(final RuleSets ruleSets) {\n        final Set<Rule> brokenRules = new HashSet<>();\n        ruleSets.removeDysfunctionalRules(brokenRules);\n\n        for (final Rule rule : brokenRules) {\n            if (LOG.isLoggable(Level.WARNING)) {\n                LOG.log(Level.WARNING,\n                        \"Removed misconfigured rule: \" + rule.getName() + \"  cause: \" + rule.dysfunctionReason());\n            }\n        }\n\n        return brokenRules;\n    }\n\n    @SuppressWarnings(\"PMD.CloseResource\")\n    // the data sources must only be closed after the threads are finished\n    // this is done manually without a try-with-resources\n    @Deprecated\n    public void processFiles(RuleSetFactory ruleSetFactory, List<DataSource> files, RuleContext ctx,\n                             List<Renderer> renderers) {\n        try {\n            final RuleSets rs = createRuleSets(ruleSetFactory, ctx.getReport());\n            processFiles(rs, files, ctx, renderers);\n        } finally {\n            // in case we analyzed files within Zip Files/Jars, we need to close them after\n            // the analysis is finished\n            for (DataSource dataSource : files) {\n                IOUtils.closeQuietly(dataSource);\n            }\n        }\n    }\n\n    @SuppressWarnings(\"PMD.CloseResource\")\n    // the data sources must only be closed after the threads are finished\n    // this is done manually without a try-with-resources\n    public void processFiles(RuleSets rulesets, List<DataSource> files, RuleContext ctx, List<Renderer> renderers) {\n        try {\n            reportBrokenRules(ctx.getReport(), rulesets);\n            configuration.getAnalysisCache().checkValidity(rulesets, configuration.getClassLoader());\n            final SourceCodeProcessor processor = new SourceCodeProcessor(configuration);\n\n            for (final DataSource dataSource : files) {\n                // this is the real, canonical and absolute filename (not shortened)\n                String realFileName = dataSource.getNiceFileName(false, null);\n\n                runAnalysis(new PmdRunnable(dataSource, realFileName, renderers, ctx, rulesets, processor));\n            }\n\n            // render base report first - general errors\n            renderReports(renderers, ctx.getReport());\n\n            // then add analysis results per file\n            collectReports(renderers);\n        } catch (RuntimeException e) {\n            throw new ContextedRuntimeException(e).addContextValue(\"filename\", String.valueOf(ctx.getSourceCodeFile()));\n        } finally {\n            // in case we analyzed files within Zip Files/Jars, we need to close them after\n            // the analysis is finished\n            for (DataSource dataSource : files) {\n                IOUtils.closeQuietly(dataSource);\n            }\n        }\n    }\n\n    protected abstract void runAnalysis(PmdRunnable runnable);\n\n    protected abstract void collectReports(List<Renderer> renderers);\n}\n",
        "diffSourceCodeSet": [
            "public static void reportBrokenRules(Report report, RuleSets rs) {\n        final Set<Rule> brokenRules = removeBrokenRules(rs);\n        for (final Rule rule : brokenRules) {\n            report.addConfigError(new Report.ConfigurationError(rule, rule.dysfunctionReason()));\n        }\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.processor.AbstractPMDProcessor#removeBrokenRules\n methodBody: private Set<Rule> removeBrokenRules(final RuleSets ruleSets) {\nfinal Set<Rule> brokenRules=new HashSet<>();\nruleSets.removeDysfunctionalRules(brokenRules);\nfor(final Rule rule: brokenRules){if(LOG.isLoggable(Level.WARNING)){LOG.log(Level.WARNING,\"Removed misconfigured rule: \" + rule.getName() + \"  cause: \" + rule.dysfunctionReason());\n}}return brokenRules;\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Create instances for each rule defined in the ruleset(s) in the\n     * configuration. Please note, that the returned instances <strong>must\n     * not</strong> be used by different threads. Each thread must create its\n     * own copy of the rules.\n     *\n     * @param factory The factory used to create the configured rule sets\n     * @param report The base report on which to report any configuration errors\n     * @return the rules within a rulesets\n     */\n    protected RuleSets createRuleSets(RuleSetFactory factory, Report report) {\n        final RuleSets rs = RulesetsFactoryUtils.getRuleSets(configuration.getRuleSets(), factory);\n        reportBrokenRules(report, rs);\n        return rs;\n    }\npublic static void reportBrokenRules(Report report, RuleSets rs) {\n        final Set<Rule> brokenRules = removeBrokenRules(rs);\n        for (final Rule rule : brokenRules) {\n            report.addConfigError(new Report.ConfigurationError(rule, rule.dysfunctionReason()));\n        }\n    }",
        "diffSourceCode": "    71:     /**\n    72:      * Create instances for each rule defined in the ruleset(s) in the\n    73:      * configuration. Please note, that the returned instances <strong>must\n    74:      * not</strong> be used by different threads. Each thread must create its\n    75:      * own copy of the rules.\n    76:      *\n    77:      * @param factory The factory used to create the configured rule sets\n    78:      * @param report The base report on which to report any configuration errors\n    79:      * @return the rules within a rulesets\n    80:      */\n    81:     protected RuleSets createRuleSets(RuleSetFactory factory, Report report) {\n    82:         final RuleSets rs = RulesetsFactoryUtils.getRuleSets(configuration.getRuleSets(), factory);\n-   83: \n-   84:         final Set<Rule> brokenRules = removeBrokenRules(rs);\n-   85:         for (final Rule rule : brokenRules) {\n-   86:             report.addConfigError(new Report.ConfigurationError(rule, rule.dysfunctionReason()));\n-   87:         }\n-   88: \n-   89:         return rs;\n-   90:     }\n-   91: \n-   92:     /**\n+   83:         reportBrokenRules(report, rs);\n+   84:         return rs;\n+   85:     }\n+   86: \n+   87:     public static void reportBrokenRules(Report report, RuleSets rs) {\n+   88:         final Set<Rule> brokenRules = removeBrokenRules(rs);\n+   89:         for (final Rule rule : brokenRules) {\n+   90:             report.addConfigError(new Report.ConfigurationError(rule, rule.dysfunctionReason()));\n+   91:         }\n+   92:     }\n",
        "uniqueId": "36e55bc2c1d4ea0a41d39fed0b9178d876b3447f_71_90_87_92_71_85",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 31
            },
            "BRANCH": {
                "missed": 0,
                "covered": 2
            },
            "LINE": {
                "missed": 0,
                "covered": 6
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 2
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic runPMDRules(reportFile Path, tempDir Path, sourceDirectory String, ruleset String, formatter String) : ExecutionResult extracted from public runPMDRules(tempDir Path, sourceDirectory String, ruleset String, formatter String) : ExecutionResult in class net.sourceforge.pmd.it.PMDExecutor",
        "diffLocations": [
            {
                "filePath": "pmd-dist/src/test/java/net/sourceforge/pmd/it/PMDExecutor.java",
                "startLine": 110,
                "endLine": 121,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-dist/src/test/java/net/sourceforge/pmd/it/PMDExecutor.java",
                "startLine": 96,
                "endLine": 108,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-dist/src/test/java/net/sourceforge/pmd/it/PMDExecutor.java",
                "startLine": 110,
                "endLine": 118,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public static ExecutionResult runPMDRules(Path tempDir, String sourceDirectory, String ruleset, String formatter) throws Exception {\n        Path reportFile = Files.createTempFile(\"pmd-it-report\", \"txt\");\n        reportFile.toFile().deleteOnExit();\n\n        if (SystemUtils.IS_OS_WINDOWS) {\n            return runPMDWindows(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n                    FORMAT_FLAG, formatter, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n        } else {\n            return runPMDUnix(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n                    FORMAT_FLAG, formatter, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n        }\n    }",
        "filePathBefore": "pmd-dist/src/test/java/net/sourceforge/pmd/it/PMDExecutor.java",
        "isPureRefactoring": true,
        "commitId": "22db2fdebce7b9d300a1be8ac50d078fe01ac0c8",
        "packageNameBefore": "net.sourceforge.pmd.it",
        "classNameBefore": "net.sourceforge.pmd.it.PMDExecutor",
        "methodNameBefore": "net.sourceforge.pmd.it.PMDExecutor#runPMDRules",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.it.PMDExecutor#runPMDWindows\n methodBody: private static ExecutionResult runPMDWindows(Path tempDir, Path reportFile, String ... arguments) throws Exception {\nString cmd=tempDir.resolve(PMD_BIN_PREFIX + PMDVersion.VERSION + \"/bin/pmd.bat\").toAbsolutePath().toString();\nreturn runPMD(cmd,Arrays.asList(arguments),reportFile);\n}\nmethodSignature: net.sourceforge.pmd.it.PMDExecutor#runPMDUnix\n methodBody: private static ExecutionResult runPMDUnix(Path tempDir, Path reportFile, String ... arguments) throws Exception {\nString cmd=tempDir.resolve(PMD_BIN_PREFIX + PMDVersion.VERSION + \"/bin/run.sh\").toAbsolutePath().toString();\nList<String> args=new ArrayList<>();\nargs.add(\"pmd\");\nargs.addAll(Arrays.asList(arguments));\nreturn runPMD(cmd,args,reportFile);\n}",
        "classSignatureBefore": "public class PMDExecutor ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.it.PMDExecutor#runPMDRules"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.it.PMDExecutor"
        ],
        "classSignatureBeforeSet": [
            "public class PMDExecutor "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.it;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.SystemUtils;\n\nimport net.sourceforge.pmd.PMDVersion;\n\n/**\n * Executes PMD from command line. Deals with the differences, when PMD is run on Windows or on Linux.\n *\n * @author Andreas Dangel\n */\npublic class PMDExecutor {\n    private static final String PMD_BIN_PREFIX = \"pmd-bin-\";\n    private static final String SOURCE_DIRECTORY_FLAG = \"-d\";\n    private static final String RULESET_FLAG = \"-R\";\n    private static final String FORMAT_FLAG = \"-f\";\n    private static final String FORMATTER = \"text\";\n    private static final String REPORTFILE_FLAG = \"-r\";\n\n    private PMDExecutor() {\n        // this is a helper class only\n    }\n\n    private static ExecutionResult runPMDUnix(Path tempDir, Path reportFile, String ... arguments) throws Exception {\n        String cmd = tempDir.resolve(PMD_BIN_PREFIX + PMDVersion.VERSION + \"/bin/run.sh\").toAbsolutePath().toString();\n        List<String> args = new ArrayList<>();\n        args.add(\"pmd\");\n        args.addAll(Arrays.asList(arguments));\n        return runPMD(cmd, args, reportFile);\n    }\n\n    private static ExecutionResult runPMDWindows(Path tempDir, Path reportFile, String ... arguments) throws Exception {\n        String cmd = tempDir.resolve(PMD_BIN_PREFIX + PMDVersion.VERSION + \"/bin/pmd.bat\").toAbsolutePath().toString();\n        return runPMD(cmd, Arrays.asList(arguments), reportFile);\n    }\n\n    private static ExecutionResult runPMD(String cmd, List<String> arguments, Path reportFile) throws Exception {\n        ProcessBuilder pb = new ProcessBuilder(cmd);\n        pb.command().addAll(arguments);\n        pb.redirectErrorStream(false);\n        final Process process = pb.start();\n        final ExecutionResult.Builder result = new ExecutionResult.Builder();\n\n        Thread outputReader = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                String output;\n                try {\n                    output = IOUtils.toString(process.getInputStream(), StandardCharsets.UTF_8);\n                    result.withOutput(output);\n                } catch (IOException e) {\n                    result.withOutput(\"Exception occurred: \" + e.toString());\n                }\n            }\n        });\n        outputReader.start();\n        Thread errorReader = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                String error;\n                try {\n                    error = IOUtils.toString(process.getErrorStream(), StandardCharsets.UTF_8);\n                    result.withErrorOutput(error);\n                } catch (IOException e) {\n                    result.withErrorOutput(\"Exception occurred: \" + e.toString());\n                }\n            }\n        });\n        errorReader.start();\n\n        int exitCode = process.waitFor();\n        outputReader.join(TimeUnit.MINUTES.toMillis(5));\n        errorReader.join(TimeUnit.MINUTES.toMillis(5));\n\n        String report = null;\n        if (reportFile != null) {\n            report = IOUtils.toString(reportFile.toUri(), StandardCharsets.UTF_8);\n        }\n        return result.withExitCode(exitCode).withReport(report).build();\n    }\n\n    /**\n     * Executes the PMD found in tempDir against the given sourceDirectory path with the given ruleset.\n     *\n     * @param tempDir the directory, to which the binary distribution has been extracted\n     * @param sourceDirectory the source directory, that PMD should analyze\n     * @param ruleset the ruleset, that PMD should execute\n     * @return collected result of the execution\n     * @throws Exception if the execution fails for any reason (executable not found, ...)\n     */\n    public static ExecutionResult runPMDRules(Path tempDir, String sourceDirectory, String ruleset) throws Exception {\n        return runPMDRules(tempDir, sourceDirectory, ruleset, FORMATTER);\n    }\n\n    public static ExecutionResult runPMDRules(Path tempDir, String sourceDirectory, String ruleset, String formatter) throws Exception {\n        Path reportFile = Files.createTempFile(\"pmd-it-report\", \"txt\");\n        reportFile.toFile().deleteOnExit();\n\n        if (SystemUtils.IS_OS_WINDOWS) {\n            return runPMDWindows(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n                    FORMAT_FLAG, formatter, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n        } else {\n            return runPMDUnix(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n                    FORMAT_FLAG, formatter, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n        }\n    }\n\n    /**\n     * Executes PMD found in tempDir with the given command line arguments.\n     * @param tempDir the directory, to which the binary distribution has been extracted\n     * @param arguments the arguments to execute PMD with\n     * @return collected result of the execution\n     * @throws Exception if the execution fails for any reason (executable not found, ...)\n     */\n    public static ExecutionResult runPMD(Path tempDir, String ... arguments) throws Exception {\n        if (SystemUtils.IS_OS_WINDOWS) {\n            return runPMDWindows(tempDir, null, arguments);\n        } else {\n            return runPMDUnix(tempDir, null, arguments);\n        }\n    }\n\n    public static boolean isJava7Test() {\n        return StringUtils.equals(System.getenv(\"JAVA_HOME\"), System.getProperty(\"java7.home\"));\n    }\n}\n",
        "filePathAfter": "pmd-dist/src/test/java/net/sourceforge/pmd/it/PMDExecutor.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.it;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.SystemUtils;\n\nimport net.sourceforge.pmd.PMDVersion;\n\n/**\n * Executes PMD from command line. Deals with the differences, when PMD is run on Windows or on Linux.\n *\n * @author Andreas Dangel\n */\npublic class PMDExecutor {\n    private static final String PMD_BIN_PREFIX = \"pmd-bin-\";\n    private static final String SOURCE_DIRECTORY_FLAG = \"-d\";\n    private static final String RULESET_FLAG = \"-R\";\n    private static final String FORMAT_FLAG = \"-f\";\n    private static final String FORMATTER = \"text\";\n    private static final String REPORTFILE_FLAG = \"-r\";\n\n    private PMDExecutor() {\n        // this is a helper class only\n    }\n\n    private static ExecutionResult runPMDUnix(Path tempDir, Path reportFile, String ... arguments) throws Exception {\n        String cmd = tempDir.resolve(PMD_BIN_PREFIX + PMDVersion.VERSION + \"/bin/run.sh\").toAbsolutePath().toString();\n        List<String> args = new ArrayList<>();\n        args.add(\"pmd\");\n        args.addAll(Arrays.asList(arguments));\n        return runPMD(cmd, args, reportFile);\n    }\n\n    private static ExecutionResult runPMDWindows(Path tempDir, Path reportFile, String ... arguments) throws Exception {\n        String cmd = tempDir.resolve(PMD_BIN_PREFIX + PMDVersion.VERSION + \"/bin/pmd.bat\").toAbsolutePath().toString();\n        return runPMD(cmd, Arrays.asList(arguments), reportFile);\n    }\n\n    private static ExecutionResult runPMD(String cmd, List<String> arguments, Path reportFile) throws Exception {\n        ProcessBuilder pb = new ProcessBuilder(cmd);\n        pb.command().addAll(arguments);\n        pb.redirectErrorStream(false);\n        final Process process = pb.start();\n        final ExecutionResult.Builder result = new ExecutionResult.Builder();\n\n        Thread outputReader = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                String output;\n                try {\n                    output = IOUtils.toString(process.getInputStream(), StandardCharsets.UTF_8);\n                    result.withOutput(output);\n                } catch (IOException e) {\n                    result.withOutput(\"Exception occurred: \" + e.toString());\n                }\n            }\n        });\n        outputReader.start();\n        Thread errorReader = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                String error;\n                try {\n                    error = IOUtils.toString(process.getErrorStream(), StandardCharsets.UTF_8);\n                    result.withErrorOutput(error);\n                } catch (IOException e) {\n                    result.withErrorOutput(\"Exception occurred: \" + e.toString());\n                }\n            }\n        });\n        errorReader.start();\n\n        int exitCode = process.waitFor();\n        outputReader.join(TimeUnit.MINUTES.toMillis(5));\n        errorReader.join(TimeUnit.MINUTES.toMillis(5));\n\n        String report = null;\n        if (reportFile != null) {\n            report = IOUtils.toString(reportFile.toUri(), StandardCharsets.UTF_8);\n        }\n        return result.withExitCode(exitCode).withReport(report).build();\n    }\n\n    /**\n     * Executes the PMD found in tempDir against the given sourceDirectory path with the given ruleset.\n     *\n     * @param reportFile the file to write the report to\n     * @param tempDir the directory, to which the binary distribution has been extracted\n     * @param sourceDirectory the source directory, that PMD should analyze\n     * @param ruleset the ruleset, that PMD should execute\n     * @return collected result of the execution\n     * @throws Exception if the execution fails for any reason (executable not found, ...)\n     */\n    public static ExecutionResult runPMDRules(Path reportFile, Path tempDir, String sourceDirectory, String ruleset) throws Exception {\n        return runPMDRules(reportFile, tempDir, sourceDirectory, ruleset, FORMATTER);\n    }\n\n    public static ExecutionResult runPMDRules(Path reportFile, Path tempDir, String sourceDirectory, String ruleset, String formatter) throws Exception {\n        if (SystemUtils.IS_OS_WINDOWS) {\n            return runPMDWindows(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n                    FORMAT_FLAG, formatter, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n        } else {\n            return runPMDUnix(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n                    FORMAT_FLAG, formatter, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n        }\n    }\n\n    /**\n     * Executes PMD found in tempDir with the given command line arguments.\n     * @param tempDir the directory, to which the binary distribution has been extracted\n     * @param arguments the arguments to execute PMD with\n     * @return collected result of the execution\n     * @throws Exception if the execution fails for any reason (executable not found, ...)\n     */\n    public static ExecutionResult runPMD(Path tempDir, String ... arguments) throws Exception {\n        if (SystemUtils.IS_OS_WINDOWS) {\n            return runPMDWindows(tempDir, null, arguments);\n        } else {\n            return runPMDUnix(tempDir, null, arguments);\n        }\n    }\n\n    public static boolean isJava7Test() {\n        return StringUtils.equals(System.getenv(\"JAVA_HOME\"), System.getProperty(\"java7.home\"));\n    }\n}\n",
        "diffSourceCodeSet": [
            "public static ExecutionResult runPMDRules(Path reportFile, Path tempDir, String sourceDirectory, String ruleset, String formatter) throws Exception {\n        if (SystemUtils.IS_OS_WINDOWS) {\n            return runPMDWindows(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n                    FORMAT_FLAG, formatter, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n        } else {\n            return runPMDUnix(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n                    FORMAT_FLAG, formatter, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n        }\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.it.PMDExecutor#runPMDWindows\n methodBody: private static ExecutionResult runPMDWindows(Path tempDir, Path reportFile, String ... arguments) throws Exception {\nString cmd=tempDir.resolve(PMD_BIN_PREFIX + PMDVersion.VERSION + \"/bin/pmd.bat\").toAbsolutePath().toString();\nreturn runPMD(cmd,Arrays.asList(arguments),reportFile);\n}",
            "methodSignature: net.sourceforge.pmd.it.PMDExecutor#runPMDUnix\n methodBody: private static ExecutionResult runPMDUnix(Path tempDir, Path reportFile, String ... arguments) throws Exception {\nString cmd=tempDir.resolve(PMD_BIN_PREFIX + PMDVersion.VERSION + \"/bin/run.sh\").toAbsolutePath().toString();\nList<String> args=new ArrayList<>();\nargs.add(\"pmd\");\nargs.addAll(Arrays.asList(arguments));\nreturn runPMD(cmd,args,reportFile);\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Executes the PMD found in tempDir against the given sourceDirectory path with the given ruleset.\n     *\n     * @param reportFile the file to write the report to\n     * @param tempDir the directory, to which the binary distribution has been extracted\n     * @param sourceDirectory the source directory, that PMD should analyze\n     * @param ruleset the ruleset, that PMD should execute\n     * @return collected result of the execution\n     * @throws Exception if the execution fails for any reason (executable not found, ...)\n     */\n    public static ExecutionResult runPMDRules(Path reportFile, Path tempDir, String sourceDirectory, String ruleset) throws Exception {\n        return runPMDRules(reportFile, tempDir, sourceDirectory, ruleset, FORMATTER);\n    }\npublic static ExecutionResult runPMDRules(Path reportFile, Path tempDir, String sourceDirectory, String ruleset, String formatter) throws Exception {\n        if (SystemUtils.IS_OS_WINDOWS) {\n            return runPMDWindows(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n                    FORMAT_FLAG, formatter, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n        } else {\n            return runPMDUnix(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n                    FORMAT_FLAG, formatter, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n        }\n    }",
        "diffSourceCode": "-   96: \n-   97:     /**\n-   98:      * Executes the PMD found in tempDir against the given sourceDirectory path with the given ruleset.\n-   99:      *\n+   96:     /**\n+   97:      * Executes the PMD found in tempDir against the given sourceDirectory path with the given ruleset.\n+   98:      *\n+   99:      * @param reportFile the file to write the report to\n   100:      * @param tempDir the directory, to which the binary distribution has been extracted\n   101:      * @param sourceDirectory the source directory, that PMD should analyze\n   102:      * @param ruleset the ruleset, that PMD should execute\n   103:      * @return collected result of the execution\n   104:      * @throws Exception if the execution fails for any reason (executable not found, ...)\n   105:      */\n-  106:     public static ExecutionResult runPMDRules(Path tempDir, String sourceDirectory, String ruleset) throws Exception {\n-  107:         return runPMDRules(tempDir, sourceDirectory, ruleset, FORMATTER);\n+  106:     public static ExecutionResult runPMDRules(Path reportFile, Path tempDir, String sourceDirectory, String ruleset) throws Exception {\n+  107:         return runPMDRules(reportFile, tempDir, sourceDirectory, ruleset, FORMATTER);\n   108:     }\n-  110:     public static ExecutionResult runPMDRules(Path tempDir, String sourceDirectory, String ruleset, String formatter) throws Exception {\n-  111:         Path reportFile = Files.createTempFile(\"pmd-it-report\", \"txt\");\n-  112:         reportFile.toFile().deleteOnExit();\n-  113: \n-  114:         if (SystemUtils.IS_OS_WINDOWS) {\n-  115:             return runPMDWindows(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n+  110:     public static ExecutionResult runPMDRules(Path reportFile, Path tempDir, String sourceDirectory, String ruleset, String formatter) throws Exception {\n+  111:         if (SystemUtils.IS_OS_WINDOWS) {\n+  112:             return runPMDWindows(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n+  113:                     FORMAT_FLAG, formatter, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n+  114:         } else {\n+  115:             return runPMDUnix(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n   116:                     FORMAT_FLAG, formatter, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n-  117:         } else {\n-  118:             return runPMDUnix(tempDir, reportFile, SOURCE_DIRECTORY_FLAG, sourceDirectory, RULESET_FLAG, ruleset,\n-  119:                     FORMAT_FLAG, formatter, REPORTFILE_FLAG, reportFile.toAbsolutePath().toString());\n-  120:         }\n-  121:     }\n+  117:         }\n+  118:     }\n+  119: \n+  120:     /**\n+  121:      * Executes PMD found in tempDir with the given command line arguments.\n",
        "uniqueId": "22db2fdebce7b9d300a1be8ac50d078fe01ac0c8_110_121_110_118_96_108",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic createWriter(charset Charset, reportFile String) : Writer extracted from public createWriter(reportFile String) : Writer in class net.sourceforge.pmd.util.IOUtil",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/util/IOUtil.java",
                "startLine": 66,
                "endLine": 88,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/util/IOUtil.java",
                "startLine": 66,
                "endLine": 78,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/util/IOUtil.java",
                "startLine": 80,
                "endLine": 104,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Creates a writer that writes to the given file or to stdout.\n     * The file is created if it does not exist.\n     *\n     * <p>Warning: This writer always uses the system default charset.\n     *\n     * @param reportFile the file name (optional)\n     *\n     * @return the writer, never null\n     */\n    public static Writer createWriter(String reportFile) {\n        try {\n            if (StringUtils.isBlank(reportFile)) {\n                return createWriter();\n            }\n            Path path = new File(reportFile).toPath().toAbsolutePath();\n            Files.createDirectories(path.getParent()); // ensure parent dir exists\n            // this will create the file if it doesn't exist\n            return Files.newBufferedWriter(path, getDefaultCharset());\n        } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }",
        "filePathBefore": "pmd-core/src/main/java/net/sourceforge/pmd/util/IOUtil.java",
        "isPureRefactoring": true,
        "commitId": "cd18ba0144cfdc62babedd05ea5950077578a22c",
        "packageNameBefore": "net.sourceforge.pmd.util",
        "classNameBefore": "net.sourceforge.pmd.util.IOUtil",
        "methodNameBefore": "net.sourceforge.pmd.util.IOUtil#createWriter",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.util.IOUtil#createWriter\n methodBody: public static Writer createWriter(String reportFile) {\ntryif(StringUtils.isBlank(reportFile)){return createWriter();\n}Path path=new File(reportFile).toPath().toAbsolutePath();\nFiles.createDirectories(path.getParent());\nreturn Files.newBufferedWriter(path,getDefaultCharset());\ncatch(IOException e)throw new IllegalArgumentException(e);\n}\nmethodSignature: net.sourceforge.pmd.util.IOUtil#getDefaultCharset\n methodBody: private static Charset getDefaultCharset() {\nString csn=AccessController.doPrivileged(new PrivilegedAction<String>(){\n  @Override public String run(){\n    return System.getProperty(\"file.encoding\");\n  }\n}\n);\ntryreturn Charset.forName(csn);\ncatch(UnsupportedCharsetException e)return StandardCharsets.UTF_8;\n}",
        "classSignatureBefore": "public final class IOUtil ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.util.IOUtil#createWriter"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.util.IOUtil"
        ],
        "classSignatureBeforeSet": [
            "public final class IOUtil "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics Severe changes",
                "description": "Return expression has been added within the Extract Method mechanics - with non-mapped leaves",
                "mappingState": 2
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.util;\n\nimport java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.charset.UnsupportedCharsetException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.StringUtils;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\n\n/**\n *\n * @author Brian Remedios\n * @deprecated Is internal API\n */\n@InternalApi\n@Deprecated\npublic final class IOUtil {\n\n    private IOUtil() {\n    }\n\n    public static Writer createWriter() {\n        return new OutputStreamWriter(System.out);\n    }\n\n    /**\n     * Gets the current default charset.\n     *\n     * <p>In contrast to {@link Charset#defaultCharset()}, the result is not cached,\n     * so that in unit tests, the charset can be changed.\n     * @return\n     */\n    private static Charset getDefaultCharset() {\n        String csn = AccessController.doPrivileged(new PrivilegedAction<String>() {\n            @Override\n            public String run() {\n                return System.getProperty(\"file.encoding\");\n            }\n        });\n        try {\n            return Charset.forName(csn);\n        } catch (UnsupportedCharsetException e) {\n            return StandardCharsets.UTF_8;\n        }\n    }\n\n    /**\n     * Creates a writer that writes to the given file or to stdout.\n     * The file is created if it does not exist.\n     *\n     * <p>Warning: This writer always uses the system default charset.\n     *\n     * @param reportFile the file name (optional)\n     *\n     * @return the writer, never null\n     */\n    public static Writer createWriter(String reportFile) {\n        try {\n            if (StringUtils.isBlank(reportFile)) {\n                return createWriter();\n            }\n            Path path = new File(reportFile).toPath().toAbsolutePath();\n            Files.createDirectories(path.getParent()); // ensure parent dir exists\n            // this will create the file if it doesn't exist\n            return Files.newBufferedWriter(path, getDefaultCharset());\n        } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n\n    public static Reader skipBOM(Reader source) {\n        Reader in = new BufferedReader(source);\n        try {\n            in.mark(1);\n            int firstCharacter = in.read();\n            if (firstCharacter != '\\ufeff') {\n                in.reset();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"Error while trying to skip BOM marker\", e);\n        }\n        return in;\n    }\n\n    public static void tryCloseClassLoader(ClassLoader classLoader) {\n        if (classLoader instanceof Closeable) {\n            IOUtils.closeQuietly((Closeable) classLoader);\n        }\n    }\n\n    /**\n     * Close all closeable resources in order. If any exception occurs,\n     * it is saved and returned. If more than one exception occurs, the\n     * following are accumulated as suppressed exceptions in the first.\n     *\n     * @param closeables Resources to close\n     *\n     * @return An exception, or null if no 'close' routine threw\n     */\n    @SuppressWarnings(\"PMD.CloseResource\") // false-positive\n    public static IOException closeAll(Collection<? extends AutoCloseable> closeables) {\n        IOException composed = null;\n        for (AutoCloseable it : closeables) {\n            try {\n                it.close();\n            } catch (Exception e) {\n                if (composed == null) {\n                    composed = new IOException(\"Cannot close resource \" + it, e);\n                } else {\n                    composed.addSuppressed(e);\n                }\n            }\n        }\n        return composed;\n    }\n\n    /**\n     * Ensure that the closeables are closed. In the end, throws the\n     * pending exception if not null, or the exception retuned by {@link #closeAll(Collection)}\n     * if not null. If both are non-null, adds one of them to the suppress\n     * list of the other, and throws that one.\n     */\n    public static void ensureClosed(List<? extends AutoCloseable> toClose,\n                                    Exception pendingException) throws Exception {\n        Exception closeException = closeAll(toClose);\n        if (closeException != null) {\n            if (pendingException != null) {\n                closeException.addSuppressed(pendingException);\n                throw closeException;\n            }\n            // else no exception at all\n        } else if (pendingException != null) {\n            throw pendingException;\n        }\n    }\n\n}\n",
        "filePathAfter": "pmd-core/src/main/java/net/sourceforge/pmd/util/IOUtil.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.util;\n\nimport java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.charset.UnsupportedCharsetException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.StringUtils;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\n\n/**\n *\n * @author Brian Remedios\n * @deprecated Is internal API\n */\n@InternalApi\n@Deprecated\npublic final class IOUtil {\n\n    private IOUtil() {\n    }\n\n    public static Writer createWriter() {\n        return new OutputStreamWriter(System.out);\n    }\n\n    /**\n     * Gets the current default charset.\n     *\n     * <p>In contrast to {@link Charset#defaultCharset()}, the result is not cached,\n     * so that in unit tests, the charset can be changed.\n     * @return\n     */\n    private static Charset getDefaultCharset() {\n        String csn = AccessController.doPrivileged(new PrivilegedAction<String>() {\n            @Override\n            public String run() {\n                return System.getProperty(\"file.encoding\");\n            }\n        });\n        try {\n            return Charset.forName(csn);\n        } catch (UnsupportedCharsetException e) {\n            return StandardCharsets.UTF_8;\n        }\n    }\n\n    /**\n     * Creates a writer that writes to the given file or to stdout.\n     * The file is created if it does not exist.\n     *\n     * <p>Warning: This writer always uses the system default charset.\n     *\n     * @param reportFile the file name (optional)\n     *\n     * @return the writer, never null\n     */\n    public static Writer createWriter(String reportFile) {\n        return createWriter(getDefaultCharset(), reportFile);\n    }\n\n    /**\n     * Creates a writer that writes to the given file or to stdout.\n     * The file is created if it does not exist.\n     *\n     * <p>Unlike {@link #createWriter(String)}, this method always uses\n     * the given charset. Even for writing to stdout. It never\n     * falls back to the default charset.</p>\n     *\n     * @param charset the charset to be used (required)\n     * @param reportFile the file name (optional)\n     * @return\n     */\n    public static Writer createWriter(Charset charset, String reportFile) {\n        try {\n            if (StringUtils.isBlank(reportFile)) {\n                return new OutputStreamWriter(System.out, charset);\n            }\n            Path path = new File(reportFile).toPath().toAbsolutePath();\n            Files.createDirectories(path.getParent()); // ensure parent dir exists\n            // this will create the file if it doesn't exist\n            return Files.newBufferedWriter(path, charset);\n        } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n\n    public static Reader skipBOM(Reader source) {\n        Reader in = new BufferedReader(source);\n        try {\n            in.mark(1);\n            int firstCharacter = in.read();\n            if (firstCharacter != '\\ufeff') {\n                in.reset();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"Error while trying to skip BOM marker\", e);\n        }\n        return in;\n    }\n\n    public static void tryCloseClassLoader(ClassLoader classLoader) {\n        if (classLoader instanceof Closeable) {\n            IOUtils.closeQuietly((Closeable) classLoader);\n        }\n    }\n\n    /**\n     * Close all closeable resources in order. If any exception occurs,\n     * it is saved and returned. If more than one exception occurs, the\n     * following are accumulated as suppressed exceptions in the first.\n     *\n     * @param closeables Resources to close\n     *\n     * @return An exception, or null if no 'close' routine threw\n     */\n    @SuppressWarnings(\"PMD.CloseResource\") // false-positive\n    public static IOException closeAll(Collection<? extends AutoCloseable> closeables) {\n        IOException composed = null;\n        for (AutoCloseable it : closeables) {\n            try {\n                it.close();\n            } catch (Exception e) {\n                if (composed == null) {\n                    composed = new IOException(\"Cannot close resource \" + it, e);\n                } else {\n                    composed.addSuppressed(e);\n                }\n            }\n        }\n        return composed;\n    }\n\n    /**\n     * Ensure that the closeables are closed. In the end, throws the\n     * pending exception if not null, or the exception retuned by {@link #closeAll(Collection)}\n     * if not null. If both are non-null, adds one of them to the suppress\n     * list of the other, and throws that one.\n     */\n    public static void ensureClosed(List<? extends AutoCloseable> toClose,\n                                    Exception pendingException) throws Exception {\n        Exception closeException = closeAll(toClose);\n        if (closeException != null) {\n            if (pendingException != null) {\n                closeException.addSuppressed(pendingException);\n                throw closeException;\n            }\n            // else no exception at all\n        } else if (pendingException != null) {\n            throw pendingException;\n        }\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * Creates a writer that writes to the given file or to stdout.\n     * The file is created if it does not exist.\n     *\n     * <p>Unlike {@link #createWriter(String)}, this method always uses\n     * the given charset. Even for writing to stdout. It never\n     * falls back to the default charset.</p>\n     *\n     * @param charset the charset to be used (required)\n     * @param reportFile the file name (optional)\n     * @return\n     */\n    public static Writer createWriter(Charset charset, String reportFile) {\n        try {\n            if (StringUtils.isBlank(reportFile)) {\n                return new OutputStreamWriter(System.out, charset);\n            }\n            Path path = new File(reportFile).toPath().toAbsolutePath();\n            Files.createDirectories(path.getParent()); // ensure parent dir exists\n            // this will create the file if it doesn't exist\n            return Files.newBufferedWriter(path, charset);\n        } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.util.IOUtil#createWriter\n methodBody: public static Writer createWriter(String reportFile) {\ntryif(StringUtils.isBlank(reportFile)){return createWriter();\n}Path path=new File(reportFile).toPath().toAbsolutePath();\nFiles.createDirectories(path.getParent());\nreturn Files.newBufferedWriter(path,getDefaultCharset());\ncatch(IOException e)throw new IllegalArgumentException(e);\n}",
            "methodSignature: net.sourceforge.pmd.util.IOUtil#getDefaultCharset\n methodBody: private static Charset getDefaultCharset() {\nString csn=AccessController.doPrivileged(new PrivilegedAction<String>(){\n  @Override public String run(){\n    return System.getProperty(\"file.encoding\");\n  }\n}\n);\ntryreturn Charset.forName(csn);\ncatch(UnsupportedCharsetException e)return StandardCharsets.UTF_8;\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Creates a writer that writes to the given file or to stdout.\n     * The file is created if it does not exist.\n     *\n     * <p>Warning: This writer always uses the system default charset.\n     *\n     * @param reportFile the file name (optional)\n     *\n     * @return the writer, never null\n     */\n    public static Writer createWriter(String reportFile) {\n        return createWriter(getDefaultCharset(), reportFile);\n    }\n/**\n     * Creates a writer that writes to the given file or to stdout.\n     * The file is created if it does not exist.\n     *\n     * <p>Unlike {@link #createWriter(String)}, this method always uses\n     * the given charset. Even for writing to stdout. It never\n     * falls back to the default charset.</p>\n     *\n     * @param charset the charset to be used (required)\n     * @param reportFile the file name (optional)\n     * @return\n     */\n    public static Writer createWriter(Charset charset, String reportFile) {\n        try {\n            if (StringUtils.isBlank(reportFile)) {\n                return new OutputStreamWriter(System.out, charset);\n            }\n            Path path = new File(reportFile).toPath().toAbsolutePath();\n            Files.createDirectories(path.getParent()); // ensure parent dir exists\n            // this will create the file if it doesn't exist\n            return Files.newBufferedWriter(path, charset);\n        } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }",
        "diffSourceCode": "    66:     /**\n    67:      * Creates a writer that writes to the given file or to stdout.\n    68:      * The file is created if it does not exist.\n    69:      *\n    70:      * <p>Warning: This writer always uses the system default charset.\n    71:      *\n    72:      * @param reportFile the file name (optional)\n    73:      *\n    74:      * @return the writer, never null\n    75:      */\n    76:     public static Writer createWriter(String reportFile) {\n-   77:         try {\n-   78:             if (StringUtils.isBlank(reportFile)) {\n-   79:                 return createWriter();\n-   80:             }\n-   81:             Path path = new File(reportFile).toPath().toAbsolutePath();\n-   82:             Files.createDirectories(path.getParent()); // ensure parent dir exists\n-   83:             // this will create the file if it doesn't exist\n-   84:             return Files.newBufferedWriter(path, getDefaultCharset());\n-   85:         } catch (IOException e) {\n-   86:             throw new IllegalArgumentException(e);\n-   87:         }\n-   88:     }\n-   89: \n-   90:     public static Reader skipBOM(Reader source) {\n-   91:         Reader in = new BufferedReader(source);\n-   92:         try {\n-   93:             in.mark(1);\n-   94:             int firstCharacter = in.read();\n-   95:             if (firstCharacter != '\\ufeff') {\n-   96:                 in.reset();\n-   97:             }\n-   98:         } catch (IOException e) {\n-   99:             throw new RuntimeException(\"Error while trying to skip BOM marker\", e);\n-  100:         }\n-  101:         return in;\n-  102:     }\n-  103: \n-  104:     public static void tryCloseClassLoader(ClassLoader classLoader) {\n+   77:         return createWriter(getDefaultCharset(), reportFile);\n+   78:     }\n+   79: \n+   80:     /**\n+   81:      * Creates a writer that writes to the given file or to stdout.\n+   82:      * The file is created if it does not exist.\n+   83:      *\n+   84:      * <p>Unlike {@link #createWriter(String)}, this method always uses\n+   85:      * the given charset. Even for writing to stdout. It never\n+   86:      * falls back to the default charset.</p>\n+   87:      *\n+   88:      * @param charset the charset to be used (required)\n+   89:      * @param reportFile the file name (optional)\n+   90:      * @return\n+   91:      */\n+   92:     public static Writer createWriter(Charset charset, String reportFile) {\n+   93:         try {\n+   94:             if (StringUtils.isBlank(reportFile)) {\n+   95:                 return new OutputStreamWriter(System.out, charset);\n+   96:             }\n+   97:             Path path = new File(reportFile).toPath().toAbsolutePath();\n+   98:             Files.createDirectories(path.getParent()); // ensure parent dir exists\n+   99:             // this will create the file if it doesn't exist\n+  100:             return Files.newBufferedWriter(path, charset);\n+  101:         } catch (IOException e) {\n+  102:             throw new IllegalArgumentException(e);\n+  103:         }\n+  104:     }\n",
        "uniqueId": "cd18ba0144cfdc62babedd05ea5950077578a22c_66_88_80_104_66_78",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 8,
                "covered": 22
            },
            "BRANCH": {
                "missed": 1,
                "covered": 1
            },
            "LINE": {
                "missed": 3,
                "covered": 4
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tprivate evaluate(elementNode PmdDocumentWrapper, properties PropertySource) : List<Item> extracted from public evaluate(root RootXmlNode, propertyValues PropertySource) : List<Node> in class net.sourceforge.pmd.lang.xml.rule.SaxonDomXPathQuery & moved to class net.sourceforge.pmd.lang.xml.rule.SaxonDomXPathQuery.XPathExpressionWithProperties",
        "diffLocations": [
            {
                "filePath": "pmd-xml/src/main/java/net/sourceforge/pmd/lang/xml/rule/SaxonDomXPathQuery.java",
                "startLine": 99,
                "endLine": 120,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-xml/src/main/java/net/sourceforge/pmd/lang/xml/rule/SaxonDomXPathQuery.java",
                "startLine": 125,
                "endLine": 147,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-xml/src/main/java/net/sourceforge/pmd/lang/xml/rule/SaxonDomXPathQuery.java",
                "startLine": 220,
                "endLine": 224,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public List<Node> evaluate(RootXmlNode root, PropertySource propertyValues) {\n        DocumentWrapper wrapper = getSaxonDomWrapper(root);\n        XPathDynamicContext dynamicContext = createDynamicContext(wrapper, propertyValues);\n        try {\n            List<Node> result = new ArrayList<>();\n            for (Object item : xpathExpression.evaluate(dynamicContext)) {\n                if (item instanceof NodeWrapper) {\n                    NodeWrapper nodeInfo = (NodeWrapper) item;\n                    Object domNode = nodeInfo.getUnderlyingNode();\n                    if (domNode instanceof org.w3c.dom.Node) {\n                        XmlNode wrapped = root.wrap((org.w3c.dom.Node) domNode);\n                        result.add(wrapped);\n                    }\n                }\n            }\n            return result;\n        } catch (XPathException e) {\n            throw new ContextedRuntimeException(e)\n                .addContextValue(\"XPath\", xpath);\n        }\n\n    }",
        "filePathBefore": "pmd-xml/src/main/java/net/sourceforge/pmd/lang/xml/rule/SaxonDomXPathQuery.java",
        "isPureRefactoring": true,
        "commitId": "00d391261d90afb005aac22dd9e1beaccb13766a",
        "packageNameBefore": "net.sourceforge.pmd.lang.xml.rule",
        "classNameBefore": "net.sourceforge.pmd.lang.xml.rule.SaxonDomXPathQuery",
        "methodNameBefore": "net.sourceforge.pmd.lang.xml.rule.SaxonDomXPathQuery#evaluate",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.xml.rule.SaxonDomXPathQuery#createDynamicContext\n methodBody: private XPathDynamicContext createDynamicContext(final DocumentWrapper elementNode, PropertySource properties) {\nfinal XPathDynamicContext dynamicContext=xpathExpression.createDynamicContext(elementNode);\nfor(final Entry<PropertyDescriptor<?>,XPathVariable> entry: xpathVariables.entrySet()){Object value=properties.getProperty(entry.getKey());\nObjects.requireNonNull(value,\"null property value for \" + entry.getKey());\nfinal ValueRepresentation saxonValue=SaxonXPathRuleQuery.getRepresentation(entry.getKey(),entry.getValue());\ntrydynamicContext.setVariable(entry.getValue(),saxonValue);\ncatch(XPathException e)throw new ContextedRuntimeException(e).addContextValue(\"Variable\",entry.getValue()).addContextValue(\"XPath\",xpath);\n}return dynamicContext;\n}\nmethodSignature: net.sourceforge.pmd.lang.xml.ast.XmlParser.RootXmlNode#wrap\n methodBody: public XmlNode wrap(Node domNode) {\nreturn super.wrap(domNode);\n}\nmethodSignature: net.sourceforge.pmd.lang.xml.rule.SaxonDomXPathQuery#getSaxonDomWrapper\n methodBody: private DocumentWrapper getSaxonDomWrapper(RootXmlNode node) {\nDataMap<DataKey<?,?>> userMap=node.getUserMap();\nif(userMap.isSet(SAXON_DOM_WRAPPER)){return userMap.get(SAXON_DOM_WRAPPER);\n}org.w3c.dom.Node domRoot=node.getNode();\nDocumentWrapper wrapper=new DocumentWrapper(domRoot,domRoot.getBaseURI(),configuration);\nuserMap.set(SAXON_DOM_WRAPPER,wrapper);\nreturn wrapper;\n}\nmethodSignature: net.sourceforge.pmd.lang.xml.rule.SaxonDomXPathQuery#evaluate\n methodBody: public List<Node> evaluate(RootXmlNode root, PropertySource propertyValues) {\nDocumentWrapper wrapper=getSaxonDomWrapper(root);\nXPathDynamicContext dynamicContext=createDynamicContext(wrapper,propertyValues);\ntryList<Node> result=new ArrayList<>();\nfor(Object item: xpathExpression.evaluate(dynamicContext)){if(item instanceof NodeWrapper){NodeWrapper nodeInfo=(NodeWrapper)item;\nObject domNode=nodeInfo.getUnderlyingNode();\nif(domNode instanceof org.w3c.dom.Node){XmlNode wrapped=root.wrap((org.w3c.dom.Node)domNode);\nresult.add(wrapped);\n}}}return result;\ncatch(XPathException e)throw new ContextedRuntimeException(e).addContextValue(\"XPath\",xpath);\n}",
        "classSignatureBefore": "final class SaxonDomXPathQuery ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.xml.rule.SaxonDomXPathQuery#evaluate"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.xml.rule.SaxonDomXPathQuery"
        ],
        "classSignatureBeforeSet": [
            "final class SaxonDomXPathQuery "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics Severe changes",
                "description": "Return expression has been added within the Extract Method mechanics - with non-mapped leaves",
                "mappingState": 2
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.xml.rule;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\n\nimport org.apache.commons.lang3.exception.ContextedRuntimeException;\n\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.rule.xpath.SaxonXPathRuleQuery;\nimport net.sourceforge.pmd.lang.xml.ast.XmlNode;\nimport net.sourceforge.pmd.lang.xml.ast.XmlParser.RootXmlNode;\nimport net.sourceforge.pmd.lang.xpath.Initializer;\nimport net.sourceforge.pmd.properties.PropertyDescriptor;\nimport net.sourceforge.pmd.properties.PropertySource;\nimport net.sourceforge.pmd.util.DataMap;\nimport net.sourceforge.pmd.util.DataMap.DataKey;\nimport net.sourceforge.pmd.util.DataMap.SimpleDataKey;\n\nimport net.sf.saxon.Configuration;\nimport net.sf.saxon.dom.DocumentWrapper;\nimport net.sf.saxon.dom.NodeWrapper;\nimport net.sf.saxon.om.NamePool;\nimport net.sf.saxon.om.NamespaceConstant;\nimport net.sf.saxon.om.ValueRepresentation;\nimport net.sf.saxon.sxpath.IndependentContext;\nimport net.sf.saxon.sxpath.XPathDynamicContext;\nimport net.sf.saxon.sxpath.XPathEvaluator;\nimport net.sf.saxon.sxpath.XPathExpression;\nimport net.sf.saxon.sxpath.XPathStaticContext;\nimport net.sf.saxon.sxpath.XPathVariable;\nimport net.sf.saxon.trans.XPathException;\n\nfinal class SaxonDomXPathQuery {\n\n    private static final NamePool NAME_POOL = new NamePool();\n\n    private static final SimpleDataKey<DocumentWrapper> SAXON_DOM_WRAPPER\n        = DataMap.simpleDataKey(\"pmd.saxon.dom.wrapper\");\n\n    private final String xpath;\n    private final XPathExpression xpathExpression;\n    private final Map<PropertyDescriptor<?>, XPathVariable> xpathVariables;\n\n    private final Configuration configuration;\n\n    public SaxonDomXPathQuery(String xpath, List<PropertyDescriptor<?>> properties) {\n        this.xpath = xpath;\n        final XPathEvaluator xpathEvaluator = new XPathEvaluator();\n        final XPathStaticContext xpathStaticContext = xpathEvaluator.getStaticContext();\n        ((IndependentContext) xpathStaticContext).declareNamespace(\"fn\", NamespaceConstant.FN);\n        configuration = xpathStaticContext.getConfiguration();\n        configuration.setNamePool(NAME_POOL);\n\n        // Register PMD functions\n        Initializer.initialize((IndependentContext) xpathStaticContext);\n\n        this.xpathVariables = makeXPathVariables(properties, xpathStaticContext);\n\n        try {\n            this.xpathExpression = xpathEvaluator.createExpression(xpath);\n        } catch (final XPathException e) {\n            throw new ContextedRuntimeException(e)\n                .addContextValue(\"XPath\", xpath);\n        }\n    }\n\n    private Map<PropertyDescriptor<?>, XPathVariable> makeXPathVariables(List<PropertyDescriptor<?>> accessibleProperties, XPathStaticContext xpathStaticContext) {\n        Map<PropertyDescriptor<?>, XPathVariable> xpathVariables = new HashMap<>();\n        for (final PropertyDescriptor<?> propertyDescriptor : accessibleProperties) {\n            final String name = propertyDescriptor.name();\n            if (!isExcludedProperty(name)) {\n                final XPathVariable xpathVariable = xpathStaticContext.declareVariable(null, name);\n                xpathVariables.put(propertyDescriptor, xpathVariable);\n            }\n        }\n        return Collections.unmodifiableMap(xpathVariables);\n    }\n\n    private boolean isExcludedProperty(String name) {\n        return \"xpath\".equals(name)\n               || \"violationSuppressRegex\".equals(name)\n               || \"violationSuppressXPath\".equals(name);\n    }\n\n    @Override\n    public String toString() {\n        return xpath;\n    }\n\n    public List<Node> evaluate(RootXmlNode root, PropertySource propertyValues) {\n        DocumentWrapper wrapper = getSaxonDomWrapper(root);\n        XPathDynamicContext dynamicContext = createDynamicContext(wrapper, propertyValues);\n        try {\n            List<Node> result = new ArrayList<>();\n            for (Object item : xpathExpression.evaluate(dynamicContext)) {\n                if (item instanceof NodeWrapper) {\n                    NodeWrapper nodeInfo = (NodeWrapper) item;\n                    Object domNode = nodeInfo.getUnderlyingNode();\n                    if (domNode instanceof org.w3c.dom.Node) {\n                        XmlNode wrapped = root.wrap((org.w3c.dom.Node) domNode);\n                        result.add(wrapped);\n                    }\n                }\n            }\n            return result;\n        } catch (XPathException e) {\n            throw new ContextedRuntimeException(e)\n                .addContextValue(\"XPath\", xpath);\n        }\n\n    }\n\n    private DocumentWrapper getSaxonDomWrapper(RootXmlNode node) {\n        DataMap<DataKey<?, ?>> userMap = node.getUserMap();\n        if (userMap.isSet(SAXON_DOM_WRAPPER)) {\n            return userMap.get(SAXON_DOM_WRAPPER);\n        }\n        org.w3c.dom.Node domRoot = node.getNode();\n        DocumentWrapper wrapper = new DocumentWrapper(\n            domRoot, domRoot.getBaseURI(), configuration\n        );\n        userMap.set(SAXON_DOM_WRAPPER, wrapper);\n        return wrapper;\n    }\n\n    private XPathDynamicContext createDynamicContext(final DocumentWrapper elementNode, PropertySource properties) {\n        final XPathDynamicContext dynamicContext = xpathExpression.createDynamicContext(elementNode);\n\n        // Set variable values on the dynamic context\n        for (final Entry<PropertyDescriptor<?>, XPathVariable> entry : xpathVariables.entrySet()) {\n            Object value = properties.getProperty(entry.getKey());\n            Objects.requireNonNull(value, \"null property value for \" + entry.getKey());\n            final ValueRepresentation saxonValue = SaxonXPathRuleQuery.getRepresentation(entry.getKey(), entry.getValue());\n            try {\n                dynamicContext.setVariable(entry.getValue(), saxonValue);\n            } catch (XPathException e) {\n                throw new ContextedRuntimeException(e)\n                    .addContextValue(\"Variable\", entry.getValue())\n                    .addContextValue(\"XPath\", xpath);\n            }\n        }\n        return dynamicContext;\n    }\n\n}\n",
        "filePathAfter": "pmd-xml/src/main/java/net/sourceforge/pmd/lang/xml/rule/SaxonDomXPathQuery.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.xml.rule;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.exception.ContextedRuntimeException;\nimport org.w3c.dom.Document;\n\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.rule.xpath.SaxonXPathRuleQuery;\nimport net.sourceforge.pmd.lang.xml.ast.XmlNode;\nimport net.sourceforge.pmd.lang.xml.ast.XmlParser.RootXmlNode;\nimport net.sourceforge.pmd.lang.xpath.Initializer;\nimport net.sourceforge.pmd.properties.PropertyDescriptor;\nimport net.sourceforge.pmd.properties.PropertySource;\nimport net.sourceforge.pmd.util.DataMap;\nimport net.sourceforge.pmd.util.DataMap.DataKey;\nimport net.sourceforge.pmd.util.DataMap.SimpleDataKey;\n\nimport net.sf.saxon.Configuration;\nimport net.sf.saxon.dom.DocumentWrapper;\nimport net.sf.saxon.dom.NodeWrapper;\nimport net.sf.saxon.om.Axis;\nimport net.sf.saxon.om.AxisIterator;\nimport net.sf.saxon.om.EmptyIterator;\nimport net.sf.saxon.om.Item;\nimport net.sf.saxon.om.NamePool;\nimport net.sf.saxon.om.NamespaceConstant;\nimport net.sf.saxon.om.NodeInfo;\nimport net.sf.saxon.om.SingleNodeIterator;\nimport net.sf.saxon.om.ValueRepresentation;\nimport net.sf.saxon.pattern.NodeTest;\nimport net.sf.saxon.sxpath.IndependentContext;\nimport net.sf.saxon.sxpath.XPathDynamicContext;\nimport net.sf.saxon.sxpath.XPathEvaluator;\nimport net.sf.saxon.sxpath.XPathExpression;\nimport net.sf.saxon.sxpath.XPathStaticContext;\nimport net.sf.saxon.sxpath.XPathVariable;\nimport net.sf.saxon.trans.XPathException;\nimport net.sf.saxon.type.Type;\n\nfinal class SaxonDomXPathQuery {\n\n    private static final NamePool NAME_POOL = new NamePool();\n\n    private static final SimpleDataKey<PmdDocumentWrapper> SAXON_DOM_WRAPPER\n        = DataMap.simpleDataKey(\"pmd.saxon.dom.wrapper\");\n\n    private final String xpath;\n    /** Cached xpath expression for URI of \"\". */\n    private final XPathExpressionWithProperties xpathExpressionDefaultNs;\n\n    /** Cached xpath expression for URI of {@link #lastUri}, overwritten if lastUri changes. */\n    private XPathExpressionWithProperties xpathExpressionLastNs;\n    private String lastUri;\n\n    private final Configuration configuration;\n\n    public SaxonDomXPathQuery(String xpath, List<PropertyDescriptor<?>> properties) {\n        this.xpath = xpath;\n        configuration = new Configuration();\n        configuration.setNamePool(NAME_POOL);\n\n        xpathExpressionDefaultNs = makeXPathExpression(this.xpath, \"\", properties);\n    }\n\n    private XPathExpressionWithProperties makeXPathExpression(String xpath, String defaultUri, List<PropertyDescriptor<?>> properties) {\n        final IndependentContext xpathStaticContext = new IndependentContext(configuration);\n        xpathStaticContext.declareNamespace(\"fn\", NamespaceConstant.FN);\n        xpathStaticContext.setDefaultElementNamespace(defaultUri);\n\n\n        // Register PMD functions\n        Initializer.initialize(xpathStaticContext);\n\n        Map<PropertyDescriptor<?>, XPathVariable> xpathVariables = declareXPathVariables(properties, xpathStaticContext);\n\n        try {\n            final XPathEvaluator xpathEvaluator = new XPathEvaluator(configuration);\n            xpathEvaluator.setStaticContext(xpathStaticContext);\n            XPathExpression expression = xpathEvaluator.createExpression(xpath);\n            return new XPathExpressionWithProperties(\n                expression,\n                xpathVariables\n            );\n        } catch (final XPathException e) {\n            throw new ContextedRuntimeException(e)\n                .addContextValue(\"XPath\", xpath);\n        }\n    }\n\n    private Map<PropertyDescriptor<?>, XPathVariable> declareXPathVariables(List<PropertyDescriptor<?>> accessibleProperties, XPathStaticContext xpathStaticContext) {\n        Map<PropertyDescriptor<?>, XPathVariable> xpathVariables = new HashMap<>();\n        for (final PropertyDescriptor<?> propertyDescriptor : accessibleProperties) {\n            final String name = propertyDescriptor.name();\n            if (!isExcludedProperty(name)) {\n                final XPathVariable xpathVariable = xpathStaticContext.declareVariable(null, name);\n                xpathVariables.put(propertyDescriptor, xpathVariable);\n            }\n        }\n        return Collections.unmodifiableMap(xpathVariables);\n    }\n\n    private boolean isExcludedProperty(String name) {\n        return \"xpath\".equals(name)\n               || \"violationSuppressRegex\".equals(name)\n               || \"violationSuppressXPath\".equals(name);\n    }\n\n    @Override\n    public String toString() {\n        return xpath;\n    }\n\n    public List<Node> evaluate(RootXmlNode root, PropertySource propertyValues) {\n        PmdDocumentWrapper wrapper = getSaxonDomWrapper(root);\n        XPathExpressionWithProperties expression = getCachedXPathExpr(propertyValues, wrapper);\n\n        try {\n            List<Node> result = new ArrayList<>();\n            for (Item item : expression.evaluate(wrapper, propertyValues)) {\n                if (item instanceof NodeWrapper) {\n                    NodeWrapper nodeInfo = (NodeWrapper) item;\n                    Object domNode = nodeInfo.getUnderlyingNode();\n                    if (domNode instanceof org.w3c.dom.Node) {\n                        XmlNode wrapped = root.wrap((org.w3c.dom.Node) domNode);\n                        result.add(wrapped);\n                    }\n                }\n            }\n            return result;\n        } catch (XPathException e) {\n            throw new ContextedRuntimeException(e)\n                .addContextValue(\"XPath\", xpath);\n        }\n\n    }\n\n    private XPathExpressionWithProperties getCachedXPathExpr(PropertySource propertyValues, PmdDocumentWrapper wrapper) {\n        XPathExpressionWithProperties expression;\n        if (StringUtils.isEmpty(wrapper.getURI())) {\n            expression = this.xpathExpressionDefaultNs;\n        } else if (xpathExpressionLastNs != null && Objects.equals(wrapper.getURI(), lastUri)) {\n            expression = xpathExpressionLastNs;\n        } else {\n            expression = makeXPathExpression(this.xpath, wrapper.getURI(), propertyValues.getPropertyDescriptors());\n            xpathExpressionLastNs = expression;\n            lastUri = wrapper.getURI();\n        }\n        return expression;\n    }\n\n    private PmdDocumentWrapper getSaxonDomWrapper(RootXmlNode node) {\n        DataMap<DataKey<?, ?>> userMap = node.getUserMap();\n        if (userMap.isSet(SAXON_DOM_WRAPPER)) {\n            return userMap.get(SAXON_DOM_WRAPPER);\n        }\n        Document domRoot = node.getNode();\n        PmdDocumentWrapper wrapper = new PmdDocumentWrapper(\n            domRoot, domRoot.getBaseURI(), configuration\n        );\n        userMap.set(SAXON_DOM_WRAPPER, wrapper);\n        return wrapper;\n    }\n\n    private static final class PmdDocumentWrapper extends DocumentWrapper {\n\n        private final NodeInfo rootNode;\n\n        public PmdDocumentWrapper(org.w3c.dom.Document doc, String baseURI, Configuration config) {\n            super(doc, baseURI, config);\n            this.rootNode = makeWrapper(doc.getDocumentElement(), this, this, 0);\n        }\n\n        @Override\n        public AxisIterator iterateAxis(byte axisNumber) {\n            if (axisNumber == Axis.CHILD) {\n                return SingleNodeIterator.makeIterator(rootNode);\n            }\n            return super.iterateAxis(axisNumber);\n        }\n\n        @Override\n        public AxisIterator iterateAxis(byte axisNumber, NodeTest nodeTest) {\n            if (axisNumber == Axis.CHILD && nodeTest.getPrimitiveType() == Type.ELEMENT) {\n                // need to override this part\n                return nodeTest.matches(rootNode)\n                       ? SingleNodeIterator.makeIterator(rootNode)\n                       : EmptyIterator.getInstance();\n            }\n            return super.iterateAxis(axisNumber, nodeTest);\n        }\n\n        @Override\n        public String getURI() {\n            return rootNode.getURI();\n        }\n    }\n\n    static final class XPathExpressionWithProperties {\n\n        final XPathExpression expr;\n        final Map<PropertyDescriptor<?>, XPathVariable> xpathVariables;\n\n        XPathExpressionWithProperties(XPathExpression expr, Map<PropertyDescriptor<?>, XPathVariable> xpathVariables) {\n            this.expr = expr;\n            this.xpathVariables = xpathVariables;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        private List<Item> evaluate(final PmdDocumentWrapper elementNode, PropertySource properties) throws XPathException {\n            XPathDynamicContext dynamicContext = createDynamicContext(elementNode, properties);\n            return (List<Item>) expr.evaluate(dynamicContext);\n        }\n\n        private XPathDynamicContext createDynamicContext(final DocumentWrapper elementNode, PropertySource properties) {\n            final XPathDynamicContext dynamicContext = expr.createDynamicContext(elementNode);\n\n            // Set variable values on the dynamic context\n            for (final Entry<PropertyDescriptor<?>, XPathVariable> entry : xpathVariables.entrySet()) {\n                Object value = properties.getProperty(entry.getKey());\n                Objects.requireNonNull(value, \"null property value for \" + entry.getKey());\n                final ValueRepresentation saxonValue = SaxonXPathRuleQuery.getRepresentation(entry.getKey(), entry.getValue());\n                try {\n                    dynamicContext.setVariable(entry.getValue(), saxonValue);\n                } catch (XPathException e) {\n                    throw new ContextedRuntimeException(e)\n                        .addContextValue(\"Variable\", entry.getValue());\n                }\n            }\n            return dynamicContext;\n        }\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "@SuppressWarnings(\"unchecked\")\n        private List<Item> evaluate(final PmdDocumentWrapper elementNode, PropertySource properties) throws XPathException {\n            XPathDynamicContext dynamicContext = createDynamicContext(elementNode, properties);\n            return (List<Item>) expr.evaluate(dynamicContext);\n        }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.xml.rule.SaxonDomXPathQuery#createDynamicContext\n methodBody: private XPathDynamicContext createDynamicContext(final DocumentWrapper elementNode, PropertySource properties) {\nfinal XPathDynamicContext dynamicContext=xpathExpression.createDynamicContext(elementNode);\nfor(final Entry<PropertyDescriptor<?>,XPathVariable> entry: xpathVariables.entrySet()){Object value=properties.getProperty(entry.getKey());\nObjects.requireNonNull(value,\"null property value for \" + entry.getKey());\nfinal ValueRepresentation saxonValue=SaxonXPathRuleQuery.getRepresentation(entry.getKey(),entry.getValue());\ntrydynamicContext.setVariable(entry.getValue(),saxonValue);\ncatch(XPathException e)throw new ContextedRuntimeException(e).addContextValue(\"Variable\",entry.getValue()).addContextValue(\"XPath\",xpath);\n}return dynamicContext;\n}",
            "methodSignature: net.sourceforge.pmd.lang.xml.ast.XmlParser.RootXmlNode#wrap\n methodBody: public XmlNode wrap(Node domNode) {\nreturn super.wrap(domNode);\n}",
            "methodSignature: net.sourceforge.pmd.lang.xml.rule.SaxonDomXPathQuery#getSaxonDomWrapper\n methodBody: private DocumentWrapper getSaxonDomWrapper(RootXmlNode node) {\nDataMap<DataKey<?,?>> userMap=node.getUserMap();\nif(userMap.isSet(SAXON_DOM_WRAPPER)){return userMap.get(SAXON_DOM_WRAPPER);\n}org.w3c.dom.Node domRoot=node.getNode();\nDocumentWrapper wrapper=new DocumentWrapper(domRoot,domRoot.getBaseURI(),configuration);\nuserMap.set(SAXON_DOM_WRAPPER,wrapper);\nreturn wrapper;\n}",
            "methodSignature: net.sourceforge.pmd.lang.xml.rule.SaxonDomXPathQuery#evaluate\n methodBody: public List<Node> evaluate(RootXmlNode root, PropertySource propertyValues) {\nDocumentWrapper wrapper=getSaxonDomWrapper(root);\nXPathDynamicContext dynamicContext=createDynamicContext(wrapper,propertyValues);\ntryList<Node> result=new ArrayList<>();\nfor(Object item: xpathExpression.evaluate(dynamicContext)){if(item instanceof NodeWrapper){NodeWrapper nodeInfo=(NodeWrapper)item;\nObject domNode=nodeInfo.getUnderlyingNode();\nif(domNode instanceof org.w3c.dom.Node){XmlNode wrapped=root.wrap((org.w3c.dom.Node)domNode);\nresult.add(wrapped);\n}}}return result;\ncatch(XPathException e)throw new ContextedRuntimeException(e).addContextValue(\"XPath\",xpath);\n}"
        ],
        "sourceCodeAfterRefactoring": "public List<Node> evaluate(RootXmlNode root, PropertySource propertyValues) {\n        PmdDocumentWrapper wrapper = getSaxonDomWrapper(root);\n        XPathExpressionWithProperties expression = getCachedXPathExpr(propertyValues, wrapper);\n\n        try {\n            List<Node> result = new ArrayList<>();\n            for (Item item : expression.evaluate(wrapper, propertyValues)) {\n                if (item instanceof NodeWrapper) {\n                    NodeWrapper nodeInfo = (NodeWrapper) item;\n                    Object domNode = nodeInfo.getUnderlyingNode();\n                    if (domNode instanceof org.w3c.dom.Node) {\n                        XmlNode wrapped = root.wrap((org.w3c.dom.Node) domNode);\n                        result.add(wrapped);\n                    }\n                }\n            }\n            return result;\n        } catch (XPathException e) {\n            throw new ContextedRuntimeException(e)\n                .addContextValue(\"XPath\", xpath);\n        }\n\n    }\n@SuppressWarnings(\"unchecked\")\n        private List<Item> evaluate(final PmdDocumentWrapper elementNode, PropertySource properties) throws XPathException {\n            XPathDynamicContext dynamicContext = createDynamicContext(elementNode, properties);\n            return (List<Item>) expr.evaluate(dynamicContext);\n        }",
        "diffSourceCode": "-   99:     public List<Node> evaluate(RootXmlNode root, PropertySource propertyValues) {\n-  100:         DocumentWrapper wrapper = getSaxonDomWrapper(root);\n-  101:         XPathDynamicContext dynamicContext = createDynamicContext(wrapper, propertyValues);\n-  102:         try {\n-  103:             List<Node> result = new ArrayList<>();\n-  104:             for (Object item : xpathExpression.evaluate(dynamicContext)) {\n-  105:                 if (item instanceof NodeWrapper) {\n-  106:                     NodeWrapper nodeInfo = (NodeWrapper) item;\n-  107:                     Object domNode = nodeInfo.getUnderlyingNode();\n-  108:                     if (domNode instanceof org.w3c.dom.Node) {\n-  109:                         XmlNode wrapped = root.wrap((org.w3c.dom.Node) domNode);\n-  110:                         result.add(wrapped);\n-  111:                     }\n-  112:                 }\n-  113:             }\n-  114:             return result;\n-  115:         } catch (XPathException e) {\n-  116:             throw new ContextedRuntimeException(e)\n-  117:                 .addContextValue(\"XPath\", xpath);\n-  118:         }\n+   99:         }\n+  100:     }\n+  101: \n+  102:     private Map<PropertyDescriptor<?>, XPathVariable> declareXPathVariables(List<PropertyDescriptor<?>> accessibleProperties, XPathStaticContext xpathStaticContext) {\n+  103:         Map<PropertyDescriptor<?>, XPathVariable> xpathVariables = new HashMap<>();\n+  104:         for (final PropertyDescriptor<?> propertyDescriptor : accessibleProperties) {\n+  105:             final String name = propertyDescriptor.name();\n+  106:             if (!isExcludedProperty(name)) {\n+  107:                 final XPathVariable xpathVariable = xpathStaticContext.declareVariable(null, name);\n+  108:                 xpathVariables.put(propertyDescriptor, xpathVariable);\n+  109:             }\n+  110:         }\n+  111:         return Collections.unmodifiableMap(xpathVariables);\n+  112:     }\n+  113: \n+  114:     private boolean isExcludedProperty(String name) {\n+  115:         return \"xpath\".equals(name)\n+  116:                || \"violationSuppressRegex\".equals(name)\n+  117:                || \"violationSuppressXPath\".equals(name);\n+  118:     }\n   119: \n-  120:     }\n-  125:             return userMap.get(SAXON_DOM_WRAPPER);\n-  126:         }\n-  127:         org.w3c.dom.Node domRoot = node.getNode();\n-  128:         DocumentWrapper wrapper = new DocumentWrapper(\n-  129:             domRoot, domRoot.getBaseURI(), configuration\n-  130:         );\n-  131:         userMap.set(SAXON_DOM_WRAPPER, wrapper);\n-  132:         return wrapper;\n-  133:     }\n-  134: \n-  135:     private XPathDynamicContext createDynamicContext(final DocumentWrapper elementNode, PropertySource properties) {\n-  136:         final XPathDynamicContext dynamicContext = xpathExpression.createDynamicContext(elementNode);\n-  137: \n-  138:         // Set variable values on the dynamic context\n-  139:         for (final Entry<PropertyDescriptor<?>, XPathVariable> entry : xpathVariables.entrySet()) {\n-  140:             Object value = properties.getProperty(entry.getKey());\n-  141:             Objects.requireNonNull(value, \"null property value for \" + entry.getKey());\n-  142:             final ValueRepresentation saxonValue = SaxonXPathRuleQuery.getRepresentation(entry.getKey(), entry.getValue());\n-  143:             try {\n-  144:                 dynamicContext.setVariable(entry.getValue(), saxonValue);\n-  145:             } catch (XPathException e) {\n-  146:                 throw new ContextedRuntimeException(e)\n-  147:                     .addContextValue(\"Variable\", entry.getValue())\n+  120:     @Override\n+  125:     public List<Node> evaluate(RootXmlNode root, PropertySource propertyValues) {\n+  126:         PmdDocumentWrapper wrapper = getSaxonDomWrapper(root);\n+  127:         XPathExpressionWithProperties expression = getCachedXPathExpr(propertyValues, wrapper);\n+  128: \n+  129:         try {\n+  130:             List<Node> result = new ArrayList<>();\n+  131:             for (Item item : expression.evaluate(wrapper, propertyValues)) {\n+  132:                 if (item instanceof NodeWrapper) {\n+  133:                     NodeWrapper nodeInfo = (NodeWrapper) item;\n+  134:                     Object domNode = nodeInfo.getUnderlyingNode();\n+  135:                     if (domNode instanceof org.w3c.dom.Node) {\n+  136:                         XmlNode wrapped = root.wrap((org.w3c.dom.Node) domNode);\n+  137:                         result.add(wrapped);\n+  138:                     }\n+  139:                 }\n+  140:             }\n+  141:             return result;\n+  142:         } catch (XPathException e) {\n+  143:             throw new ContextedRuntimeException(e)\n+  144:                 .addContextValue(\"XPath\", xpath);\n+  145:         }\n+  146: \n+  147:     }\n+  220:         @SuppressWarnings(\"unchecked\")\n+  221:         private List<Item> evaluate(final PmdDocumentWrapper elementNode, PropertySource properties) throws XPathException {\n+  222:             XPathDynamicContext dynamicContext = createDynamicContext(elementNode, properties);\n+  223:             return (List<Item>) expr.evaluate(dynamicContext);\n+  224:         }\n",
        "uniqueId": "00d391261d90afb005aac22dd9e1beaccb13766a_99_120_220_224_125_147",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 10,
                "covered": 49
            },
            "BRANCH": {
                "missed": 2,
                "covered": 4
            },
            "LINE": {
                "missed": 3,
                "covered": 12
            },
            "COMPLEXITY": {
                "missed": 2,
                "covered": 2
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Move Method",
        "description": "Move Method\tpublic isInfixExprWithOperator(e JavaNode, operator BinaryOp) : boolean from class net.sourceforge.pmd.lang.java.ast.BinaryOp to public isInfixExprWithOperator(e JavaNode, operator BinaryOp) : boolean from class net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/BinaryOp.java",
                "startLine": 226,
                "endLine": 235,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/internal/JavaAstUtils.java",
                "startLine": 708,
                "endLine": 717,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Tests if the node is an {@link ASTInfixExpression} with the given operator.\n     */\n    public static boolean isInfixExprWithOperator(@Nullable JavaNode e, BinaryOp operator) {\n        if (e instanceof ASTInfixExpression) {\n            ASTInfixExpression infix = (ASTInfixExpression) e;\n            return operator == infix.getOperator();\n        }\n        return false;\n    }",
        "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/BinaryOp.java",
        "isPureRefactoring": true,
        "commitId": "e3005e279a6ce99b081a34f3c98e618217ebbbf5",
        "packageNameBefore": "net.sourceforge.pmd.lang.java.ast",
        "classNameBefore": "net.sourceforge.pmd.lang.java.ast.BinaryOp",
        "methodNameBefore": "net.sourceforge.pmd.lang.java.ast.BinaryOp#isInfixExprWithOperator",
        "classSignatureBefore": "public enum BinaryOp implements InternalInterfaces.OperatorLike ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.ast.BinaryOp#isInfixExprWithOperator"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.ast.BinaryOp"
        ],
        "classSignatureBeforeSet": [
            "public enum BinaryOp implements InternalInterfaces.OperatorLike "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.ast;\n\nimport java.util.Comparator;\nimport java.util.EnumSet;\nimport java.util.Set;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport net.sourceforge.pmd.util.CollectionUtil;\n\n/**\n * Represents the operator of an {@linkplain ASTInfixExpression infix expression}.\n * Constants are roughly ordered by precedence, except some of them have the same\n * precedence.\n *\n * <p>All of those operators are left-associative.\n *\n * @see UnaryOp\n * @see AssignmentOp\n */\npublic enum BinaryOp implements InternalInterfaces.OperatorLike {\n\n    // shortcut boolean ops\n\n    /** Conditional (shortcut) OR {@code \"||\"} operator. */\n    CONDITIONAL_OR(\"||\"),\n    /** Conditional (shortcut) AND {@code \"&&\"} operator. */\n    CONDITIONAL_AND(\"&&\"),\n\n    // non-shortcut (also bitwise)\n\n    /** OR {@code \"|\"} operator. Either logical or bitwise depending on the type of the operands. */\n    OR(\"|\"),\n    /** XOR {@code \"^\"} operator. Either logical or bitwise depending on the type of the operands. */\n    XOR(\"^\"),\n    /** AND {@code \"&\"} operator. Either logical or bitwise depending on the type of the operands. */\n    AND(\"&\"),\n\n    // equality\n\n    /** Equals {@code \"==\"} operator. */\n    EQ(\"==\"),\n    /** Not-equals {@code \"!=\"} operator. */\n    NE(\"!=\"),\n\n    // relational\n\n    /** Lower-or-equal {@code \"<=\"} operator. */\n    LE(\"<=\"),\n    /** Greater-or-equal {@code \">=\"} operator. */\n    GE(\">=\"),\n    /** Greater-than {@code \">\"} operator. */\n    GT(\">\"),\n    /** Lower-than {@code \"<\"} operator. */\n    LT(\"<\"),\n    /** Type test {@code \"instanceof\"} operator. */\n    INSTANCEOF(\"instanceof\"),\n\n    // shift\n\n    /** Left shift {@code \"<<\"} operator. */\n    LEFT_SHIFT(\"<<\"),\n    /** Right shift {@code \">>\"} operator. */\n    RIGHT_SHIFT(\">>\"),\n    /** Unsigned right shift {@code \">>>\"} operator. */\n    UNSIGNED_RIGHT_SHIFT(\">>>\"),\n\n    // additive\n\n    /** Addition {@code \"+\"} operator, or string concatenation. */\n    ADD(\"+\"),\n    /** Subtraction {@code \"-\"} operator. */\n    SUB(\"-\"),\n\n    // multiplicative\n\n    /** Multiplication {@code \"*\"} operator. */\n    MUL(\"*\"),\n    /** Division {@code \"/\"} operator. */\n    DIV(\"/\"),\n    /** Modulo {@code \"%\"} operator. */\n    MOD(\"%\");\n\n    /** Set of {@code &&} and {@code ||}. Use with {@link #isInfixExprWithOperator(JavaNode, Set)}. */\n    public static final Set<BinaryOp> CONDITIONAL_OPS =\n        CollectionUtil.immutableEnumSet(CONDITIONAL_AND, CONDITIONAL_OR);\n    /** Set of {@code <}, {@code <=}, {@code >=} and {@code >}. Use with {@link #isInfixExprWithOperator(JavaNode, Set)}. */\n    public static final Set<BinaryOp> COMPARISON_OPS = CollectionUtil.immutableEnumSet(LE, GE, GT, LT);\n    /** Set of {@code ==} and {@code !=}. Use with {@link #isInfixExprWithOperator(JavaNode, Set)}. */\n    public static final Set<BinaryOp> EQUALITY_OPS = CollectionUtil.immutableEnumSet(EQ, NE);\n    /** Set of {@code <<}, {@code >>} and {@code >>>}. Use with {@link #isInfixExprWithOperator(JavaNode, Set)}. */\n    public static final Set<BinaryOp> SHIFT_OPS = CollectionUtil.immutableEnumSet(LEFT_SHIFT, RIGHT_SHIFT, UNSIGNED_RIGHT_SHIFT);\n\n    private final String code;\n\n\n    BinaryOp(String code) {\n        this.code = code;\n    }\n\n\n    @Override\n    public String getToken() {\n        return code;\n    }\n\n\n    @Override\n    public String toString() {\n        return this.code;\n    }\n\n    /**\n     * Compare the precedence of this operator with that of the other,\n     * as if with a {@link Comparator}. Returns a positive integer if\n     * this operator has a higher precedence as the argument, zero if\n     * they have the same precedence, etc.\n     *\n     * @throws NullPointerException If the argument is null\n     */\n    public int comparePrecedence(@NonNull BinaryOp other) {\n        // arguments are flipped because precedence class decreases\n        return Integer.compare(other.precedenceClass(), this.precedenceClass());\n    }\n\n    /**\n     * Returns true if this operator has the same relative precedence\n     * as the argument. For example, {@link #ADD} and {@link #SUB} have\n     * the same precedence.\n     *\n     * @throws NullPointerException If the argument is null\n     */\n    public boolean hasSamePrecedenceAs(@NonNull BinaryOp other) {\n        return comparePrecedence(other) == 0;\n    }\n\n\n    /**\n     * Returns the ops with strictly greater precedence than the given op.\n     * This may return an empty set.\n     */\n    public static Set<BinaryOp> opsWithGreaterPrecedence(BinaryOp op) {\n        Set<BinaryOp> range = EnumSet.range(op, MOD);\n        range.remove(op);\n        return range;\n    }\n\n    private int precedenceClass() {\n        switch (this) {\n        case CONDITIONAL_OR:\n            return 9;\n        case CONDITIONAL_AND:\n            return 8;\n        case OR:\n            return 7;\n        case XOR:\n            return 6;\n        case AND:\n            return 5;\n        case EQ:\n        case NE:\n            return 4;\n        case LE:\n        case GE:\n        case GT:\n        case LT:\n        case INSTANCEOF:\n            return 3;\n        case LEFT_SHIFT:\n        case RIGHT_SHIFT:\n        case UNSIGNED_RIGHT_SHIFT:\n            return 2;\n        case ADD:\n        case SUB:\n            return 1;\n        case MUL:\n        case DIV:\n        case MOD:\n            return 0;\n        default:\n            return -1;\n        }\n    }\n\n\n    /**\n     * Complement, for boolean operators. Eg for {@code ==}, return {@code !=},\n     * for {@code <=}, returns {@code >}. Returns null if this is another kind\n     * of operator.\n     */\n    public @Nullable BinaryOp getComplement() {\n        switch (this) {\n        case CONDITIONAL_OR: return CONDITIONAL_AND;\n        case CONDITIONAL_AND: return CONDITIONAL_OR;\n        case OR: return AND;\n        case AND: return OR;\n\n        case EQ: return NE;\n        case NE: return EQ;\n        case LE: return GT;\n        case GE: return LT;\n        case GT: return LE;\n        case LT: return GE;\n\n        default: return null;\n        }\n    }\n\n\n    /**\n     * Tests if the node is an {@link ASTInfixExpression} with one of the given operators.\n     */\n    public static boolean isInfixExprWithOperator(@Nullable JavaNode e, Set<BinaryOp> operators) {\n        if (e instanceof ASTInfixExpression) {\n            ASTInfixExpression infix = (ASTInfixExpression) e;\n            return operators.contains(infix.getOperator());\n        }\n        return false;\n    }\n\n    /**\n     * Tests if the node is an {@link ASTInfixExpression} with the given operator.\n     */\n    public static boolean isInfixExprWithOperator(@Nullable JavaNode e, BinaryOp operator) {\n        if (e instanceof ASTInfixExpression) {\n            ASTInfixExpression infix = (ASTInfixExpression) e;\n            return operator == infix.getOperator();\n        }\n        return false;\n    }\n}\n",
        "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/internal/JavaAstUtils.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.ast.internal;\n\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport net.sourceforge.pmd.lang.ast.GenericToken;\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.ast.NodeStream;\nimport net.sourceforge.pmd.lang.ast.impl.javacc.JavaccToken;\nimport net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTArgumentList;\nimport net.sourceforge.pmd.lang.java.ast.ASTArrayAllocation;\nimport net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr.ASTNamedReferenceExpr;\nimport net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr.AccessType;\nimport net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTBooleanLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTBreakStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTCastExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType;\nimport net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;\nimport net.sourceforge.pmd.lang.java.ast.ASTExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTExpressionStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTFieldAccess;\nimport net.sourceforge.pmd.lang.java.ast.ASTForStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;\nimport net.sourceforge.pmd.lang.java.ast.ASTFormalParameters;\nimport net.sourceforge.pmd.lang.java.ast.ASTInfixExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTLabeledStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTList;\nimport net.sourceforge.pmd.lang.java.ast.ASTLocalVariableDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTLoopStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTMethodCall;\nimport net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTMethodOrConstructorDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTNullLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTNumericLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTSuperExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTSwitchBranch;\nimport net.sourceforge.pmd.lang.java.ast.ASTSwitchStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTThisExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTUnaryExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;\nimport net.sourceforge.pmd.lang.java.ast.AccessNode.Visibility;\nimport net.sourceforge.pmd.lang.java.ast.Annotatable;\nimport net.sourceforge.pmd.lang.java.ast.BinaryOp;\nimport net.sourceforge.pmd.lang.java.ast.JavaNode;\nimport net.sourceforge.pmd.lang.java.ast.JavaTokenKinds;\nimport net.sourceforge.pmd.lang.java.ast.QualifiableExpression;\nimport net.sourceforge.pmd.lang.java.ast.TypeNode;\nimport net.sourceforge.pmd.lang.java.ast.UnaryOp;\nimport net.sourceforge.pmd.lang.java.symbols.JFieldSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.internal.ast.AstLocalVarSym;\nimport net.sourceforge.pmd.lang.java.types.JMethodSig;\nimport net.sourceforge.pmd.lang.java.types.JPrimitiveType.PrimitiveTypeKind;\nimport net.sourceforge.pmd.lang.java.types.JTypeMirror;\nimport net.sourceforge.pmd.lang.java.types.TypeTestUtil;\nimport net.sourceforge.pmd.util.CollectionUtil;\nimport net.sourceforge.pmd.util.OptionalBool;\n\n/**\n *\n */\npublic final class JavaAstUtils {\n\n    private JavaAstUtils() {\n        // utility class\n    }\n\n\n    public static boolean isConditional(JavaNode ifx) {\n        return isInfixExprWithOperator(ifx, BinaryOp.CONDITIONAL_OPS);\n    }\n\n    public static int numAlternatives(ASTSwitchBranch n) {\n        return n.isDefault() ? 1 : n.getLabel().getExprList().count();\n    }\n\n    /**\n     * Returns true if this is a numeric literal with the given int value.\n     * This also considers long literals.\n     */\n    public static boolean isLiteralInt(JavaNode e, int value) {\n        return e instanceof ASTNumericLiteral\n                && ((ASTNumericLiteral) e).isIntegral()\n                && ((ASTNumericLiteral) e).getValueAsInt() == value;\n    }\n\n    /** This is type-aware, so will not pick up on numeric addition. */\n    public static boolean isStringConcatExpr(@Nullable JavaNode e) {\n        if (e instanceof ASTInfixExpression) {\n            ASTInfixExpression infix = (ASTInfixExpression) e;\n            return infix.getOperator() == BinaryOp.ADD && TypeTestUtil.isA(String.class, infix);\n        }\n        return false;\n    }\n\n    /**\n     * If the parameter is an operand of a binary infix expression,\n     * returns the other operand. Otherwise returns null.\n     */\n    public static @Nullable ASTExpression getOtherOperandIfInInfixExpr(@Nullable JavaNode e) {\n        if (e != null && e.getParent() instanceof ASTInfixExpression) {\n            return (ASTExpression) e.getParent().getChild(1 - e.getIndexInParent());\n        }\n        return null;\n    }\n\n    public static @Nullable ASTExpression getOtherOperandIfInAssignmentExpr(@Nullable JavaNode e) {\n        if (e != null && e.getParent() instanceof ASTAssignmentExpression) {\n            return (ASTExpression) e.getParent().getChild(1 - e.getIndexInParent());\n        }\n        return null;\n    }\n\n    /**\n     * Returns true if the node is a {@link ASTMethodDeclaration} that\n     * is a main method.\n     */\n    public static boolean isMainMethod(JavaNode node) {\n        return node instanceof ASTMethodDeclaration\n                && ((ASTMethodDeclaration) node).isMainMethod();\n    }\n\n    public static boolean hasField(ASTAnyTypeDeclaration node, String name) {\n        for (JFieldSymbol f : node.getSymbol().getDeclaredFields()) {\n            String fname = f.getSimpleName();\n            if (fname.startsWith(\"m_\") || fname.startsWith(\"_\")) {\n                fname = fname.substring(fname.indexOf('_') + 1);\n            }\n            if (fname.equalsIgnoreCase(name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns true if the formal parameters of the method or constructor\n     * match the given types exactly. Note that for varargs methods, the\n     * last param must have an array type (but it is not checked to be varargs).\n     * This will return false if we're not sure.\n     *\n     * @param node  Method or ctor\n     * @param types List of types to match (may be empty)\n     *\n     * @throws NullPointerException If any of the classes is null, or the node is null\n     * @see TypeTestUtil#isExactlyA(Class, TypeNode)\n     */\n    public static boolean hasParameters(ASTMethodOrConstructorDeclaration node, Class<?>... types) {\n        ASTFormalParameters formals = node.getFormalParameters();\n        if (formals.size() != types.length) {\n            return false;\n        }\n        for (int i = 0; i < formals.size(); i++) {\n            ASTFormalParameter fi = formals.get(i);\n            if (!TypeTestUtil.isExactlyA(types[i], fi)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns true if the {@code throws} declaration of the method or constructor\n     * matches the given types exactly.\n     *\n     * @param node  Method or ctor\n     * @param types List of exception types to match (may be empty)\n     *\n     * @throws NullPointerException If any of the classes is null, or the node is null\n     * @see TypeTestUtil#isExactlyA(Class, TypeNode)\n     */\n    @SafeVarargs\n    public static boolean hasExceptionList(ASTMethodOrConstructorDeclaration node, Class<? extends Throwable>... types) {\n        @NonNull List<ASTClassOrInterfaceType> formals = ASTList.orEmpty(node.getThrowsList());\n        if (formals.size() != types.length) {\n            return false;\n        }\n        for (int i = 0; i < formals.size(); i++) {\n            ASTClassOrInterfaceType fi = formals.get(i);\n            if (!TypeTestUtil.isExactlyA(types[i], fi)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * True if the variable is never used. Note that the visibility of\n     * the variable must be less than {@link Visibility#V_PRIVATE} for\n     * us to be sure of it.\n     */\n    public static boolean isNeverUsed(ASTVariableDeclaratorId varId) {\n        return CollectionUtil.none(varId.getLocalUsages(), JavaAstUtils::isReadUsage);\n    }\n\n    private static boolean isReadUsage(ASTNamedReferenceExpr expr) {\n        return expr.getAccessType() == AccessType.READ\n            // x++ as a method argument or used in other expression\n            || expr.getParent() instanceof ASTUnaryExpression\n            && !(expr.getParent().getParent() instanceof ASTExpressionStatement);\n    }\n\n    /**\n     * True if the variable is incremented or decremented via a compound\n     * assignment operator, or a unary increment/decrement expression.\n     */\n    public static boolean isVarAccessReadAndWrite(ASTNamedReferenceExpr expr) {\n        return expr.getAccessType() == AccessType.WRITE\n            && (!(expr.getParent() instanceof ASTAssignmentExpression)\n            || ((ASTAssignmentExpression) expr.getParent()).getOperator().isCompound());\n    }\n\n    /**\n     * True if the variable access is a non-compound assignment.\n     */\n    public static boolean isVarAccessStrictlyWrite(ASTNamedReferenceExpr expr) {\n        return expr.getParent() instanceof ASTAssignmentExpression\n            && expr.getIndexInParent() == 0\n            && !((ASTAssignmentExpression) expr.getParent()).getOperator().isCompound();\n    }\n\n    /**\n     * Returns the set of labels on this statement.\n     */\n    public static Set<String> getStatementLabels(ASTStatement node) {\n        if (!(node.getParent() instanceof ASTLabeledStatement)) {\n            return Collections.emptySet();\n        }\n\n        return node.ancestors().takeWhile(it -> it instanceof ASTLabeledStatement)\n                   .toStream()\n                   .map(it -> ((ASTLabeledStatement) it).getLabel())\n                   .collect(Collectors.toSet());\n    }\n\n    public static boolean isAnonymousClassCreation(@Nullable ASTExpression expression) {\n        return expression instanceof ASTConstructorCall\n                && ((ASTConstructorCall) expression).isAnonymousClass();\n    }\n\n    /**\n     * Will cut through argument lists, except those of enum constants\n     * and explicit invocation nodes.\n     */\n    public static @NonNull ASTExpression getTopLevelExpr(ASTExpression expr) {\n        JavaNode last = expr.ancestorsOrSelf()\n                            .takeWhile(it -> it instanceof ASTExpression\n                                || it instanceof ASTArgumentList && it.getParent() instanceof ASTExpression)\n                            .last();\n        return (ASTExpression) Objects.requireNonNull(last);\n    }\n\n    /**\n     * Returns the variable IDS corresponding to variables declared in\n     * the init clause of the loop.\n     */\n    public static NodeStream<ASTVariableDeclaratorId> getLoopVariables(ASTForStatement loop) {\n        return NodeStream.of(loop.getInit())\n                         .filterIs(ASTLocalVariableDeclaration.class)\n                         .flatMap(ASTLocalVariableDeclaration::getVarIds);\n    }\n\n    /**\n     * Whether one expression is the boolean negation of the other. Many\n     * forms are not yet supported. This method is symmetric so only needs\n     * to be called once.\n     */\n    public static boolean areComplements(ASTExpression e1, ASTExpression e2) {\n        if (isBooleanNegation(e1)) {\n            return areEqual(unaryOperand(e1), e2);\n        } else if (isBooleanNegation(e2)) {\n            return areEqual(e1, unaryOperand(e2));\n        } else if (e1 instanceof ASTInfixExpression && e2 instanceof ASTInfixExpression) {\n            ASTInfixExpression ifx1 = (ASTInfixExpression) e1;\n            ASTInfixExpression ifx2 = (ASTInfixExpression) e2;\n            if (ifx1.getOperator().getComplement() != ifx2.getOperator()) {\n                return false;\n            }\n            if (ifx1.getOperator().hasSamePrecedenceAs(BinaryOp.EQ)) {\n                // NOT(a == b, a != b)\n                // NOT(a == b, b != a)\n                return areEqual(ifx1.getLeftOperand(), ifx2.getLeftOperand())\n                    && areEqual(ifx1.getRightOperand(), ifx2.getRightOperand())\n                    || areEqual(ifx2.getLeftOperand(), ifx1.getLeftOperand())\n                    && areEqual(ifx2.getRightOperand(), ifx1.getRightOperand());\n            }\n            // todo we could continue with de Morgan and such\n        }\n        return false;\n    }\n\n    private static boolean areEqual(ASTExpression e1, ASTExpression e2) {\n        return tokenEquals(e1, e2);\n    }\n\n    /**\n     * Returns true if both nodes have exactly the same tokens.\n     *\n     * @param node First node\n     * @param that Other node\n     */\n    public static boolean tokenEquals(JavaNode node, JavaNode that) {\n        return tokenEquals(node, that, null);\n    }\n\n    /**\n     * Returns true if both nodes have the same tokens, modulo some renaming\n     * function. The renaming function maps unqualified variables and type\n     * identifiers of the first node to the other. This should be used\n     * in nodes living in the same lexical scope, so that unqualified\n     * names mean the same thing.\n     *\n     * @param node       First node\n     * @param other      Other node\n     * @param varRenamer A renaming function. If null, no renaming is applied.\n     *                   Must not return null, if no renaming occurs, returns its argument.\n     */\n    public static boolean tokenEquals(@NonNull JavaNode node,\n                                      @NonNull JavaNode other,\n                                      @Nullable Function<String, @NonNull String> varRenamer) {\n        // Since type and variable names obscure one another,\n        // it's ok to use a single renaming function.\n\n        Iterator<JavaccToken> thisIt = GenericToken.range(node.getFirstToken(), node.getLastToken());\n        Iterator<JavaccToken> thatIt = GenericToken.range(other.getFirstToken(), other.getLastToken());\n        int lastKind = 0;\n        while (thisIt.hasNext()) {\n            if (!thatIt.hasNext()) {\n                return false;\n            }\n            JavaccToken o1 = thisIt.next();\n            JavaccToken o2 = thatIt.next();\n            if (o1.kind != o2.kind) {\n                return false;\n            }\n\n            String mappedImage = o1.getImage();\n            if (varRenamer != null\n                && o1.kind == JavaTokenKinds.IDENTIFIER\n                && lastKind != JavaTokenKinds.DOT\n                && lastKind != JavaTokenKinds.METHOD_REF\n                //method name\n                && o1.getNext() != null && o1.getNext().kind != JavaTokenKinds.LPAREN) {\n                mappedImage = varRenamer.apply(mappedImage);\n            }\n\n            if (!o2.getImage().equals(mappedImage)) {\n                return false;\n            }\n\n            lastKind = o1.kind;\n        }\n        return !thatIt.hasNext();\n    }\n\n    public static boolean isNullLiteral(ASTExpression node) {\n        return node instanceof ASTNullLiteral;\n    }\n\n    /** Returns true if the node is a boolean literal with any value. */\n    public static boolean isBooleanLiteral(JavaNode e) {\n        return e instanceof ASTBooleanLiteral;\n    }\n\n    /** Returns true if the node is a boolean literal with the given constant value. */\n    public static boolean isBooleanLiteral(JavaNode e, boolean value) {\n        return e instanceof ASTBooleanLiteral && ((ASTBooleanLiteral) e).isTrue() == value;\n    }\n\n    public static boolean isBooleanNegation(JavaNode e) {\n        return e instanceof ASTUnaryExpression && ((ASTUnaryExpression) e).getOperator() == UnaryOp.NEGATION;\n    }\n\n    /**\n     * If the argument is a unary expression, returns its operand, otherwise\n     * returns null.\n     */\n    public static @Nullable ASTExpression unaryOperand(@Nullable ASTExpression e) {\n        return e instanceof ASTUnaryExpression ? ((ASTUnaryExpression) e).getOperand()\n                                               : null;\n    }\n\n    /**\n     * Whether the expression is an access to a field of this instance,\n     * not inherited, qualified or not ({@code this.field} or just {@code field}).\n     */\n    public static boolean isThisFieldAccess(ASTExpression e) {\n        if (!(e instanceof ASTNamedReferenceExpr)) {\n            return false;\n        }\n        JVariableSymbol sym = ((ASTNamedReferenceExpr) e).getReferencedSym();\n        return sym instanceof JFieldSymbol\n                && !((JFieldSymbol) sym).isStatic()\n                // not inherited\n                && ((JFieldSymbol) sym).getEnclosingClass().equals(e.getEnclosingType().getSymbol())\n                // correct syntactic form\n                && (e instanceof ASTVariableAccess || isSyntacticThisFieldAccess(e));\n    }\n\n    /**\n     * Whether the expression is a {@code this.field}, with no outer\n     * instance qualifier ({@code Outer.this.field}). The field symbol\n     * is not checked to resolve to a field declared in this class (it\n     * may be inherited)\n     */\n    public static boolean isSyntacticThisFieldAccess(ASTExpression e) {\n        if (e instanceof ASTFieldAccess) {\n            ASTExpression qualifier = ((ASTFieldAccess) e).getQualifier();\n            if (qualifier instanceof ASTThisExpression) {\n                // unqualified this\n                return ((ASTThisExpression) qualifier).getQualifier() == null;\n            }\n        }\n        return false;\n    }\n\n    public static boolean hasAnyAnnotation(Annotatable node, Collection<String> qualifiedNames) {\n        return qualifiedNames.stream().anyMatch(node::isAnnotationPresent);\n    }\n\n    /**\n     * Returns true if the expression is the default field value for\n     * the given type.\n     */\n    public static boolean isDefaultValue(JTypeMirror type, ASTExpression expr) {\n        if (type.isPrimitive()) {\n            if (type.isPrimitive(PrimitiveTypeKind.BOOLEAN)) {\n                return expr instanceof ASTBooleanLiteral && !((ASTBooleanLiteral) expr).isTrue();\n            } else {\n                Object constValue = expr.getConstValue();\n                return constValue instanceof Number && ((Number) constValue).doubleValue() == 0d\n                    || constValue instanceof Character && constValue.equals('\\u0000');\n            }\n        } else {\n            return expr instanceof ASTNullLiteral;\n        }\n    }\n\n    /**\n     * Returns true if the expression is a {@link ASTNamedReferenceExpr}\n     * that references the symbol.\n     */\n    public static boolean isReferenceToVar(@Nullable ASTExpression expression, @NonNull JVariableSymbol symbol) {\n        return expression instanceof ASTNamedReferenceExpr\n            && symbol.equals(((ASTNamedReferenceExpr) expression).getReferencedSym());\n    }\n\n    public static boolean isUnqualifiedThis(ASTExpression e) {\n        return e instanceof ASTThisExpression && ((ASTThisExpression) e).getQualifier() == null;\n    }\n\n    public static boolean isUnqualifiedSuper(ASTExpression e) {\n        return e instanceof ASTSuperExpression && ((ASTSuperExpression) e).getQualifier() == null;\n    }\n\n    public static boolean isUnqualifiedThisOrSuper(ASTExpression e) {\n        return isUnqualifiedSuper(e) || isUnqualifiedThis(e);\n    }\n\n    /**\n     * Returns true if the expression is a {@link ASTNamedReferenceExpr}\n     * that references any of the symbol in the set.\n     */\n    public static boolean isReferenceToVar(@Nullable ASTExpression expression, @NonNull Set<? extends JVariableSymbol> symbols) {\n        return expression instanceof ASTNamedReferenceExpr\n            && symbols.contains(((ASTNamedReferenceExpr) expression).getReferencedSym());\n    }\n\n    /**\n     * Returns true if both expressions refer to the same variable.\n     * A \"variable\" here can also means a field path, eg, {@code this.field.a}.\n     * This method unifies {@code this.field} and {@code field} if possible,\n     * and also considers {@code this}.\n     *\n     * <p>Note that while this is more useful than just checking whether\n     * both expressions access the same symbol, it still does not mean that\n     * they both access the same <i>value</i>. The actual value is data-flow\n     * dependent.\n     */\n    public static boolean isReferenceToSameVar(ASTExpression e1, ASTExpression e2) {\n        if (e1 instanceof ASTNamedReferenceExpr && e2 instanceof ASTNamedReferenceExpr) {\n            if (OptionalBool.YES != referenceSameSymbol((ASTNamedReferenceExpr) e1, (ASTNamedReferenceExpr) e2)) {\n                return false;\n            }\n\n            if (e1.getClass() != e2.getClass()) {\n                // unify `this.f` and `f`\n                // note, we already know that the symbol is the same so there's no scoping problem\n                return isSyntacticThisFieldAccess(e1) || isSyntacticThisFieldAccess(e2);\n            } else if (e1 instanceof ASTFieldAccess && e2 instanceof ASTFieldAccess) {\n                return isReferenceToSameVar(((ASTFieldAccess) e1).getQualifier(),\n                                            ((ASTFieldAccess) e2).getQualifier());\n            }\n            return e1 instanceof ASTVariableAccess && e2 instanceof ASTVariableAccess;\n        } else if (e1 instanceof ASTThisExpression || e2 instanceof ASTThisExpression) {\n            return e1.getClass() == e2.getClass();\n        }\n        return false;\n    }\n\n    private static OptionalBool referenceSameSymbol(ASTNamedReferenceExpr e1, ASTNamedReferenceExpr e2) {\n        if (!e1.getName().equals(e2.getName())) {\n            return OptionalBool.NO;\n        }\n        JVariableSymbol ref1 = e1.getReferencedSym();\n        JVariableSymbol ref2 = e2.getReferencedSym();\n        if (ref1 == null || ref2 == null) {\n            return OptionalBool.UNKNOWN;\n        }\n        return OptionalBool.definitely(ref1.equals(ref2));\n    }\n\n    /**\n     * Returns true if the expression is a reference to a local variable.\n     */\n    public static boolean isReferenceToLocal(ASTExpression expr) {\n        return expr instanceof ASTVariableAccess\n                && ((ASTVariableAccess) expr).getReferencedSym() instanceof AstLocalVarSym;\n    }\n\n    /**\n     * Returns true if the expression has the form `field`, or `this.field`,\n     * where `field` is a field declared in the enclosing class. Considers\n     * inherited fields. Assumes we're not in a static context.\n     */\n    public static boolean isRefToFieldOfThisInstance(ASTExpression usage) {\n        if (!(usage instanceof ASTNamedReferenceExpr)) {\n            return false;\n        }\n        JVariableSymbol symbol = ((ASTNamedReferenceExpr) usage).getReferencedSym();\n        if (!(symbol instanceof JFieldSymbol)) {\n            return false;\n        }\n\n        if (usage instanceof ASTVariableAccess) {\n            return !Modifier.isStatic(((JFieldSymbol) symbol).getModifiers());\n        } else if (usage instanceof ASTFieldAccess) {\n            return isUnqualifiedThisOrSuper(((ASTFieldAccess) usage).getQualifier());\n        }\n        return false;\n    }\n\n    /**\n     * Returns true if the expression is a reference to a field declared\n     * in this class (not a superclass), on any instance (not just `this`).\n     */\n    public static boolean isRefToFieldOfThisClass(ASTExpression usage) {\n        if (!(usage instanceof ASTNamedReferenceExpr)) {\n            return false;\n        }\n        JVariableSymbol symbol = ((ASTNamedReferenceExpr) usage).getReferencedSym();\n        if (!(symbol instanceof JFieldSymbol)) {\n            return false;\n        }\n\n        if (usage instanceof ASTVariableAccess) {\n            return !Modifier.isStatic(((JFieldSymbol) symbol).getModifiers());\n        } else if (usage instanceof ASTFieldAccess) {\n            return Objects.equals(((JFieldSymbol) symbol).getEnclosingClass(),\n                                  usage.getEnclosingType().getSymbol());\n        }\n        return false;\n    }\n\n    public static boolean isCallOnThisInstance(ASTMethodCall call) {\n        // syntactic approach.\n        if (call.getQualifier() != null) {\n            return isUnqualifiedThisOrSuper(call.getQualifier());\n        }\n\n        // unqualified call\n        JMethodSig mtype = call.getMethodType();\n        return !mtype.getSymbol().isUnresolved()\n            && mtype.getSymbol().getEnclosingClass().equals(call.getEnclosingType().getSymbol());\n    }\n\n    public static ASTClassOrInterfaceType getThisOrSuperQualifier(ASTExpression expr) {\n        if (expr instanceof ASTThisExpression) {\n            return ((ASTThisExpression) expr).getQualifier();\n        } else if (expr instanceof ASTSuperExpression) {\n            return ((ASTSuperExpression) expr).getQualifier();\n        }\n        return null;\n    }\n\n    public static ASTClassOrInterfaceType isUnqual(ASTExpression expr) {\n        if (expr instanceof ASTThisExpression) {\n            return ((ASTThisExpression) expr).getQualifier();\n        } else if (expr instanceof ASTSuperExpression) {\n            return ((ASTSuperExpression) expr).getQualifier();\n        }\n        return null;\n    }\n\n    public static boolean isThisOrSuper(ASTExpression expr) {\n        return expr instanceof ASTThisExpression || expr instanceof ASTSuperExpression;\n    }\n\n    /**\n     * Return a node stream containing all the operands of an addition expression.\n     * For instance, {@code a+b+c} will be parsed as a tree with two levels.\n     * This method will return a flat node stream containing {@code a, b, c}.\n     *\n     * @param e An expression, if it is not a string concatenation expression,\n     *          then returns an empty node stream.\n     */\n    public static NodeStream<ASTExpression> flattenOperands(ASTExpression e) {\n        List<ASTExpression> result = new ArrayList<>();\n        flattenOperandsRec(e, result);\n        return NodeStream.fromIterable(result);\n    }\n\n    private static void flattenOperandsRec(ASTExpression e, List<ASTExpression> result) {\n        if (isStringConcatExpr(e)) {\n            ASTInfixExpression infix = (ASTInfixExpression) e;\n            flattenOperandsRec(infix.getLeftOperand(), result);\n            flattenOperandsRec(infix.getRightOperand(), result);\n        } else {\n            result.add(e);\n        }\n    }\n\n    /**\n     * Returns true if the node is the last child of its parent (or is the root node).\n     */\n    public static boolean isLastChild(Node it) {\n        Node parent = it.getParent();\n        return parent == null || it.getIndexInParent() == parent.getNumChildren() - 1;\n    }\n\n    /**\n     * Returns a node stream of enclosing expressions in the same call chain.\n     * For instance in {@code a.b().c().d()}, called on {@code a}, this will\n     * yield {@code a.b()}, and {@code a.b().c()}.\n     */\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public static NodeStream<QualifiableExpression> followingCallChain(ASTExpression expr) {\n        return (NodeStream) expr.ancestors().takeWhile(it -> it instanceof QualifiableExpression);\n    }\n\n    public static ASTExpression peelCasts(@Nullable ASTExpression expr) {\n        while (expr instanceof ASTCastExpression) {\n            expr = ((ASTCastExpression) expr).getOperand();\n        }\n        return expr;\n    }\n\n    public static boolean isArrayInitializer(ASTExpression expr) {\n        return expr instanceof ASTArrayAllocation && ((ASTArrayAllocation) expr).getArrayInitializer() != null;\n    }\n\n    public static boolean isCloneMethod(ASTMethodDeclaration node) {\n        // this is enough as in valid code, this signature overrides Object#clone\n        // and the other things like visibility are checked by the compiler\n        return \"clone\".equals(node.getName())\n            && node.getArity() == 0\n            && !node.isStatic();\n    }\n\n    public static boolean isArrayLengthFieldAccess(ASTExpression node) {\n        if (node instanceof ASTFieldAccess) {\n            ASTFieldAccess field = (ASTFieldAccess) node;\n            return \"length\".equals(field.getName())\n                && field.getQualifier().getTypeMirror().isArray();\n        }\n        return false;\n    }\n\n    /**\n     * @see ASTBreakStatement#getTarget()\n     */\n    public static boolean mayBeBreakTarget(JavaNode it) {\n        return it instanceof ASTLoopStatement\n            || it instanceof ASTSwitchStatement\n            || it instanceof ASTLabeledStatement;\n    }\n\n    /**\n     * Tests if the node is an {@link ASTInfixExpression} with one of the given operators.\n     */\n    public static boolean isInfixExprWithOperator(@Nullable JavaNode e, Set<BinaryOp> operators) {\n        if (e instanceof ASTInfixExpression) {\n            ASTInfixExpression infix = (ASTInfixExpression) e;\n            return operators.contains(infix.getOperator());\n        }\n        return false;\n    }\n\n    /**\n     * Tests if the node is an {@link ASTInfixExpression} with the given operator.\n     */\n    public static boolean isInfixExprWithOperator(@Nullable JavaNode e, BinaryOp operator) {\n        if (e instanceof ASTInfixExpression) {\n            ASTInfixExpression infix = (ASTInfixExpression) e;\n            return operator == infix.getOperator();\n        }\n        return false;\n    }\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "/**\n     * Tests if the node is an {@link ASTInfixExpression} with the given operator.\n     */\n    public static boolean isInfixExprWithOperator(@Nullable JavaNode e, BinaryOp operator) {\n        if (e instanceof ASTInfixExpression) {\n            ASTInfixExpression infix = (ASTInfixExpression) e;\n            return operator == infix.getOperator();\n        }\n        return false;\n    }",
        "diffSourceCode": "-  226:     /**\n-  227:      * Tests if the node is an {@link ASTInfixExpression} with the given operator.\n-  228:      */\n-  229:     public static boolean isInfixExprWithOperator(@Nullable JavaNode e, BinaryOp operator) {\n-  230:         if (e instanceof ASTInfixExpression) {\n-  231:             ASTInfixExpression infix = (ASTInfixExpression) e;\n-  232:             return operator == infix.getOperator();\n-  233:         }\n-  234:         return false;\n-  235:     }\n+  226:     public static boolean isVarAccessReadAndWrite(ASTNamedReferenceExpr expr) {\n+  227:         return expr.getAccessType() == AccessType.WRITE\n+  228:             && (!(expr.getParent() instanceof ASTAssignmentExpression)\n+  229:             || ((ASTAssignmentExpression) expr.getParent()).getOperator().isCompound());\n+  230:     }\n+  231: \n+  232:     /**\n+  233:      * True if the variable access is a non-compound assignment.\n+  234:      */\n+  235:     public static boolean isVarAccessStrictlyWrite(ASTNamedReferenceExpr expr) {\n+  708:     /**\n+  709:      * Tests if the node is an {@link ASTInfixExpression} with the given operator.\n+  710:      */\n+  711:     public static boolean isInfixExprWithOperator(@Nullable JavaNode e, BinaryOp operator) {\n+  712:         if (e instanceof ASTInfixExpression) {\n+  713:             ASTInfixExpression infix = (ASTInfixExpression) e;\n+  714:             return operator == infix.getOperator();\n+  715:         }\n+  716:         return false;\n+  717:     }\n",
        "uniqueId": "e3005e279a6ce99b081a34f3c98e618217ebbbf5_226_235__708_717",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 16
            },
            "BRANCH": {
                "missed": 0,
                "covered": 4
            },
            "LINE": {
                "missed": 0,
                "covered": 4
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 3
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic toRenderer(project Project, inputPaths List<String>) : Renderer extracted from private doTask() : void in class net.sourceforge.pmd.ant.internal.PMDTaskImpl & moved to class net.sourceforge.pmd.ant.Formatter",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/ant/internal/PMDTaskImpl.java",
                "startLine": 100,
                "endLine": 215,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/ant/internal/PMDTaskImpl.java",
                "startLine": 94,
                "endLine": 149,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/ant/internal/PMDTaskImpl.java",
                "startLine": 237,
                "endLine": 243,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private void doTask() {\n        setupClassLoader();\n\n        // Setup RuleSetFactory and validate RuleSets\n        RuleSetLoader rulesetLoader = RuleSetLoader.fromPmdConfig(configuration)\n                                                   .loadResourcesWith(setupResourceLoader());\n\n        // This is just used to validate and display rules. Each thread will create its own ruleset\n        String ruleSetString = configuration.getRuleSets();\n        if (StringUtils.isNotBlank(ruleSetString)) {\n            // Substitute env variables/properties\n            configuration.setRuleSets(project.replaceProperties(ruleSetString));\n        }\n\n        final RuleSets ruleSets = RulesetsFactoryUtils.getRuleSets(configuration.getRuleSets(), rulesetLoader.toFactory());\n        List<RuleSet> rulesetList = Arrays.asList(ruleSets.getAllRuleSets());\n        logRulesUsed(ruleSets);\n\n        if (configuration.getSuppressMarker() != null) {\n            project.log(\"Setting suppress marker to be \" + configuration.getSuppressMarker(), Project.MSG_VERBOSE);\n        }\n\n        // Start the Formatters\n        for (Formatter formatter : formatters) {\n            project.log(\"Sending a report to \" + formatter, Project.MSG_VERBOSE);\n            formatter.start(project.getBaseDir().toString());\n        }\n\n        // log(\"Setting Language Version \" + languageVersion.getShortName(),\n        // Project.MSG_VERBOSE);\n\n        // TODO Do we really need all this in a loop over each FileSet? Seems\n        // like a lot of redundancy\n        Report errorReport = new Report();\n        int problemCount = 0;\n        final String separator = System.getProperty(\"file.separator\");\n\n        for (FileSet fs : filesets) {\n            List<DataSource> files = new LinkedList<>();\n            DirectoryScanner ds = fs.getDirectoryScanner(project);\n            String[] srcFiles = ds.getIncludedFiles();\n            for (String srcFile : srcFiles) {\n                File file = new File(ds.getBasedir() + separator + srcFile);\n                files.add(new FileDataSource(file));\n            }\n\n            final String commonInputPath = ds.getBasedir().getPath();\n            configuration.setInputPaths(commonInputPath);\n            final List<String> reportShortNamesPaths = new ArrayList<>();\n            if (configuration.isReportShortNames()) {\n                reportShortNamesPaths.add(commonInputPath);\n            }\n\n            Renderer logRenderer = new AbstractRenderer(\"log\", \"Logging renderer\") {\n                @Override\n                public void start() {\n                    // Nothing to do\n                }\n\n                @Override\n                public void startFileAnalysis(DataSource dataSource) {\n                    project.log(\"Processing file \" + dataSource.getNiceFileName(false, commonInputPath),\n                            Project.MSG_VERBOSE);\n                }\n\n                @Override\n                public void renderFileReport(Report r) {\n                    // Nothing to do\n                }\n\n                @Override\n                public void end() {\n                    // Nothing to do\n                }\n\n                @Override\n                public String defaultFileExtension() {\n                    return null;\n                } // not relevant\n            };\n            List<Renderer> renderers = new ArrayList<>(formatters.size() + 1);\n            renderers.add(logRenderer);\n            for (Formatter formatter : formatters) {\n                Renderer renderer = formatter.getRenderer();\n                renderer.setUseShortNames(reportShortNamesPaths);\n                renderers.add(renderer);\n            }\n            try {\n                Report report = PMD.processFiles(configuration, rulesetList, files, renderers);\n                problemCount += report.getViolations().size();\n            } catch (ContextedRuntimeException e) {\n                if (e.getFirstContextValue(\"filename\") instanceof String) {\n                    handleError((String) e.getFirstContextValue(\"filename\"), errorReport, e);\n                } else {\n                    handleError(\"(unknown file)\", errorReport, e);\n                }\n            } catch (RuntimeException pmde) {\n                handleError(\"(unknown file)\", errorReport, pmde);\n            }\n        }\n\n        project.log(problemCount + \" problems found\", Project.MSG_VERBOSE);\n\n        for (Formatter formatter : formatters) {\n            formatter.end(errorReport);\n        }\n\n        if (failuresPropertyName != null && problemCount > 0) {\n            project.setProperty(failuresPropertyName, String.valueOf(problemCount));\n            project.log(\"Setting property \" + failuresPropertyName + \" to \" + problemCount, Project.MSG_VERBOSE);\n        }\n\n        if (failOnRuleViolation && problemCount > maxRuleViolations) {\n            throw new BuildException(\"Stopping build since PMD found \" + problemCount + \" rule violations in the code\");\n        }\n    }",
        "filePathBefore": "pmd-core/src/main/java/net/sourceforge/pmd/ant/internal/PMDTaskImpl.java",
        "isPureRefactoring": true,
        "commitId": "5dc2774c0a53810717358cc850b69c6e7fe0a463",
        "packageNameBefore": "net.sourceforge.pmd.ant.internal",
        "classNameBefore": "net.sourceforge.pmd.ant.internal.PMDTaskImpl",
        "methodNameBefore": "net.sourceforge.pmd.ant.internal.PMDTaskImpl#doTask",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.RuleSetLoader#fromPmdConfig\n methodBody: public static RuleSetLoader fromPmdConfig(PMDConfiguration configuration) {\nreturn new RuleSetLoader().filterAbovePriority(configuration.getMinimumPriority()).enableCompatibility(configuration.isRuleSetFactoryCompatibilityEnabled());\n}\nmethodSignature: net.sourceforge.pmd.ant.internal.PMDTaskImpl#handleError\n methodBody: private void handleError(String filename, Report errorReport, RuntimeException pmde) {\npmde.printStackTrace();\nproject.log(pmde.toString(),Project.MSG_VERBOSE);\nThrowable cause=pmde.getCause();\nif(cause != null){try(StringWriter strWriter=new StringWriter(); PrintWriter printWriter=new PrintWriter(strWriter))cause.printStackTrace(printWriter);\nproject.log(strWriter.toString(),Project.MSG_VERBOSE);\ncatch(IOException e)project.log(\"Error while closing stream\",e,Project.MSG_ERR);\nif(StringUtils.isNotBlank(cause.getMessage())){project.log(cause.getMessage(),Project.MSG_VERBOSE);\n}}if(failOnError){throw new BuildException(pmde);\n}errorReport.addError(new Report.ProcessingError(pmde,filename));\n}\nmethodSignature: net.sourceforge.pmd.ant.Formatter#toString\n methodBody: public String toString() {\nreturn \"file = \" + toFile + \"; renderer = \" + type;\n}\nmethodSignature: net.sourceforge.pmd.ant.internal.PMDTaskImpl#setupResourceLoader\n methodBody: private ClassLoader setupResourceLoader() {\nif(classpath == null){classpath=new Path(project);\n}classpath.add(new Path(null,project.getBaseDir().toString()));\nproject.log(\"Using the AntClassLoader: \" + classpath,Project.MSG_VERBOSE);\nfinal boolean parentFirst=true;\nreturn new AntClassLoader(Thread.currentThread().getContextClassLoader(),project,classpath,parentFirst);\n}\nmethodSignature: net.sourceforge.pmd.ant.internal.PMDTaskImpl#logRulesUsed\n methodBody: private void logRulesUsed(RuleSets rules) {\nproject.log(\"Using these rulesets: \" + configuration.getRuleSets(),Project.MSG_VERBOSE);\nRuleSet[] ruleSets=rules.getAllRuleSets();\nfor(RuleSet ruleSet: ruleSets){for(Rule rule: ruleSet.getRules()){project.log(\"Using rule \" + rule.getName(),Project.MSG_VERBOSE);\n}}}\nmethodSignature: net.sourceforge.pmd.ant.Formatter#getRenderer\n methodBody: public Renderer getRenderer() {\nreturn renderer;\n}\nmethodSignature: net.sourceforge.pmd.ant.internal.PMDTaskImpl#setupClassLoader\n methodBody: private void setupClassLoader() {\ntryif(auxClasspath != null){project.log(\"Using auxclasspath: \" + auxClasspath,Project.MSG_VERBOSE);\nconfiguration.prependAuxClasspath(auxClasspath.toString());\n}catch(IllegalArgumentException ioe)throw new BuildException(ioe.getMessage(),ioe);\n}\nmethodSignature: net.sourceforge.pmd.RuleSetLoader#toFactory\n methodBody: public RuleSetFactory toFactory() {\nreturn new RuleSetFactory(this.resourceLoader,this.minimumPriority,this.warnDeprecated,this.enableCompatibility,this.includeDeprecatedRuleReferences);\n}\nmethodSignature: net.sourceforge.pmd.RuleSetLoader#loadResourcesWith\n methodBody: RuleSetLoader loadResourcesWith(ResourceLoader loader) {\nthis.resourceLoader=loader;\nreturn this;\n}\nmethodSignature: net.sourceforge.pmd.ant.Formatter#start\n methodBody: public void start(String baseDir) {\nProperties properties=createProperties();\nCharset charset;\n{String s=(String)properties.get(\"encoding\");\nif(null == s){if(toConsole){s=getConsoleEncoding();\nif(null == s){s=System.getProperty(\"file.encoding\");\n}}if(null == s){charset=StandardCharsets.UTF_8;\n}{charset=Charset.forName(s);\n}final Parameter parameter=new Parameter();\nparameter.setName(\"encoding\");\nparameter.setValue(charset.name());\nparameters.add(parameter);\n}{charset=Charset.forName(s);\n}}tryif(toConsole){writer=new BufferedWriter(new OutputStreamWriter(System.out,charset));\n}if(toFile != null){writer=getToFileWriter(baseDir,toFile,charset);\n}renderer=createRenderer();\nrenderer.setWriter(writer);\nrenderer.start();\ncatch(IOException ioe)throw new BuildException(ioe.getMessage(),ioe);\n}\nmethodSignature: net.sourceforge.pmd.ant.Formatter#end\n methodBody: public void end(Report errorReport) {\ntryrenderer.renderFileReport(errorReport);\nrenderer.end();\nif(toConsole){writer.flush();\n}{writer.close();\n}catch(IOException ioe)throw new BuildException(ioe.getMessage(),ioe);\n}",
        "classSignatureBefore": "public class PMDTaskImpl ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.ant.internal.PMDTaskImpl#doTask"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.ant.internal.PMDTaskImpl"
        ],
        "classSignatureBeforeSet": [
            "public class PMDTaskImpl "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics\n",
                "description": "Argument replaced with return expression - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.ant.internal;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.exception.ContextedRuntimeException;\nimport org.apache.tools.ant.AntClassLoader;\nimport org.apache.tools.ant.BuildException;\nimport org.apache.tools.ant.DirectoryScanner;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.types.FileSet;\nimport org.apache.tools.ant.types.Path;\n\nimport net.sourceforge.pmd.PMD;\nimport net.sourceforge.pmd.PMDConfiguration;\nimport net.sourceforge.pmd.Report;\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RulePriority;\nimport net.sourceforge.pmd.RuleSet;\nimport net.sourceforge.pmd.RuleSetLoader;\nimport net.sourceforge.pmd.RuleSets;\nimport net.sourceforge.pmd.RulesetsFactoryUtils;\nimport net.sourceforge.pmd.ant.Formatter;\nimport net.sourceforge.pmd.ant.PMDTask;\nimport net.sourceforge.pmd.ant.SourceLanguage;\nimport net.sourceforge.pmd.lang.LanguageRegistry;\nimport net.sourceforge.pmd.lang.LanguageVersion;\nimport net.sourceforge.pmd.renderers.AbstractRenderer;\nimport net.sourceforge.pmd.renderers.Renderer;\nimport net.sourceforge.pmd.util.ClasspathClassLoader;\nimport net.sourceforge.pmd.util.IOUtil;\nimport net.sourceforge.pmd.util.datasource.DataSource;\nimport net.sourceforge.pmd.util.datasource.FileDataSource;\nimport net.sourceforge.pmd.util.log.AntLogHandler;\nimport net.sourceforge.pmd.util.log.ScopedLogHandlersManager;\n\npublic class PMDTaskImpl {\n\n    private Path classpath;\n    private Path auxClasspath;\n    private final List<Formatter> formatters = new ArrayList<>();\n    private final List<FileSet> filesets = new ArrayList<>();\n    private final PMDConfiguration configuration = new PMDConfiguration();\n    private boolean failOnError;\n    private boolean failOnRuleViolation;\n    private int maxRuleViolations = 0;\n    private String failuresPropertyName;\n    private Project project;\n\n    public PMDTaskImpl(PMDTask task) {\n        configuration.setReportShortNames(task.isShortFilenames());\n        configuration.setSuppressMarker(task.getSuppressMarker());\n        this.failOnError = task.isFailOnError();\n        this.failOnRuleViolation = task.isFailOnRuleViolation();\n        this.maxRuleViolations = task.getMaxRuleViolations();\n        if (this.maxRuleViolations > 0) {\n            this.failOnRuleViolation = true;\n        }\n        configuration.setRuleSets(task.getRulesetFiles());\n        configuration.setRuleSetFactoryCompatibilityEnabled(!task.isNoRuleSetCompatibility());\n        if (task.getEncoding() != null) {\n            configuration.setSourceEncoding(task.getEncoding());\n        }\n        configuration.setThreads(task.getThreads());\n        this.failuresPropertyName = task.getFailuresPropertyName();\n        configuration.setMinimumPriority(RulePriority.valueOf(task.getMinimumPriority()));\n        configuration.setAnalysisCacheLocation(task.getCacheLocation());\n        configuration.setIgnoreIncrementalAnalysis(task.isNoCache());\n\n        SourceLanguage version = task.getSourceLanguage();\n        if (version != null) {\n            LanguageVersion languageVersion = LanguageRegistry\n                    .findLanguageVersionByTerseName(version.getName() + ' ' + version.getVersion());\n            if (languageVersion == null) {\n                throw new BuildException(\"The following language is not supported:\" + version + '.');\n            }\n            configuration.setDefaultLanguageVersion(languageVersion);\n        }\n\n        classpath = task.getClasspath();\n        auxClasspath = task.getAuxClasspath();\n\n        filesets.addAll(task.getFilesets());\n        formatters.addAll(task.getFormatters());\n\n        project = task.getProject();\n    }\n\n    private void doTask() {\n        setupClassLoader();\n\n        // Setup RuleSetFactory and validate RuleSets\n        RuleSetLoader rulesetLoader = RuleSetLoader.fromPmdConfig(configuration)\n                                                   .loadResourcesWith(setupResourceLoader());\n\n        // This is just used to validate and display rules. Each thread will create its own ruleset\n        String ruleSetString = configuration.getRuleSets();\n        if (StringUtils.isNotBlank(ruleSetString)) {\n            // Substitute env variables/properties\n            configuration.setRuleSets(project.replaceProperties(ruleSetString));\n        }\n\n        final RuleSets ruleSets = RulesetsFactoryUtils.getRuleSets(configuration.getRuleSets(), rulesetLoader.toFactory());\n        List<RuleSet> rulesetList = Arrays.asList(ruleSets.getAllRuleSets());\n        logRulesUsed(ruleSets);\n\n        if (configuration.getSuppressMarker() != null) {\n            project.log(\"Setting suppress marker to be \" + configuration.getSuppressMarker(), Project.MSG_VERBOSE);\n        }\n\n        // Start the Formatters\n        for (Formatter formatter : formatters) {\n            project.log(\"Sending a report to \" + formatter, Project.MSG_VERBOSE);\n            formatter.start(project.getBaseDir().toString());\n        }\n\n        // log(\"Setting Language Version \" + languageVersion.getShortName(),\n        // Project.MSG_VERBOSE);\n\n        // TODO Do we really need all this in a loop over each FileSet? Seems\n        // like a lot of redundancy\n        Report errorReport = new Report();\n        int problemCount = 0;\n        final String separator = System.getProperty(\"file.separator\");\n\n        for (FileSet fs : filesets) {\n            List<DataSource> files = new LinkedList<>();\n            DirectoryScanner ds = fs.getDirectoryScanner(project);\n            String[] srcFiles = ds.getIncludedFiles();\n            for (String srcFile : srcFiles) {\n                File file = new File(ds.getBasedir() + separator + srcFile);\n                files.add(new FileDataSource(file));\n            }\n\n            final String commonInputPath = ds.getBasedir().getPath();\n            configuration.setInputPaths(commonInputPath);\n            final List<String> reportShortNamesPaths = new ArrayList<>();\n            if (configuration.isReportShortNames()) {\n                reportShortNamesPaths.add(commonInputPath);\n            }\n\n            Renderer logRenderer = new AbstractRenderer(\"log\", \"Logging renderer\") {\n                @Override\n                public void start() {\n                    // Nothing to do\n                }\n\n                @Override\n                public void startFileAnalysis(DataSource dataSource) {\n                    project.log(\"Processing file \" + dataSource.getNiceFileName(false, commonInputPath),\n                            Project.MSG_VERBOSE);\n                }\n\n                @Override\n                public void renderFileReport(Report r) {\n                    // Nothing to do\n                }\n\n                @Override\n                public void end() {\n                    // Nothing to do\n                }\n\n                @Override\n                public String defaultFileExtension() {\n                    return null;\n                } // not relevant\n            };\n            List<Renderer> renderers = new ArrayList<>(formatters.size() + 1);\n            renderers.add(logRenderer);\n            for (Formatter formatter : formatters) {\n                Renderer renderer = formatter.getRenderer();\n                renderer.setUseShortNames(reportShortNamesPaths);\n                renderers.add(renderer);\n            }\n            try {\n                Report report = PMD.processFiles(configuration, rulesetList, files, renderers);\n                problemCount += report.getViolations().size();\n            } catch (ContextedRuntimeException e) {\n                if (e.getFirstContextValue(\"filename\") instanceof String) {\n                    handleError((String) e.getFirstContextValue(\"filename\"), errorReport, e);\n                } else {\n                    handleError(\"(unknown file)\", errorReport, e);\n                }\n            } catch (RuntimeException pmde) {\n                handleError(\"(unknown file)\", errorReport, pmde);\n            }\n        }\n\n        project.log(problemCount + \" problems found\", Project.MSG_VERBOSE);\n\n        for (Formatter formatter : formatters) {\n            formatter.end(errorReport);\n        }\n\n        if (failuresPropertyName != null && problemCount > 0) {\n            project.setProperty(failuresPropertyName, String.valueOf(problemCount));\n            project.log(\"Setting property \" + failuresPropertyName + \" to \" + problemCount, Project.MSG_VERBOSE);\n        }\n\n        if (failOnRuleViolation && problemCount > maxRuleViolations) {\n            throw new BuildException(\"Stopping build since PMD found \" + problemCount + \" rule violations in the code\");\n        }\n    }\n\n    private ClassLoader setupResourceLoader() {\n        if (classpath == null) {\n            classpath = new Path(project);\n        }\n\n        /*\n         * 'basedir' is added to the path to make sure that relative paths such\n         * as \"<ruleset>resources/custom_ruleset.xml</ruleset>\" still work when\n         * ant is invoked from a different directory using \"-f\"\n         */\n        classpath.add(new Path(null, project.getBaseDir().toString()));\n\n        project.log(\"Using the AntClassLoader: \" + classpath, Project.MSG_VERBOSE);\n        // must be true, otherwise you'll get ClassCastExceptions as classes\n        // are loaded twice\n        // and exist in multiple class loaders\n        final boolean parentFirst = true;\n        return new AntClassLoader(Thread.currentThread().getContextClassLoader(),\n                                  project, classpath, parentFirst);\n    }\n\n    private void handleError(String filename, Report errorReport, RuntimeException pmde) {\n\n        pmde.printStackTrace();\n        project.log(pmde.toString(), Project.MSG_VERBOSE);\n\n        Throwable cause = pmde.getCause();\n\n        if (cause != null) {\n            try (StringWriter strWriter = new StringWriter();\n                 PrintWriter printWriter = new PrintWriter(strWriter)) {\n                cause.printStackTrace(printWriter);\n                project.log(strWriter.toString(), Project.MSG_VERBOSE);\n            } catch (IOException e) {\n                project.log(\"Error while closing stream\", e, Project.MSG_ERR);\n            }\n            if (StringUtils.isNotBlank(cause.getMessage())) {\n                project.log(cause.getMessage(), Project.MSG_VERBOSE);\n            }\n        }\n\n        if (failOnError) {\n            throw new BuildException(pmde);\n        }\n        errorReport.addError(new Report.ProcessingError(pmde, filename));\n    }\n\n    private void setupClassLoader() {\n        try {\n            if (auxClasspath != null) {\n                project.log(\"Using auxclasspath: \" + auxClasspath, Project.MSG_VERBOSE);\n                configuration.prependAuxClasspath(auxClasspath.toString());\n            }\n        } catch (IllegalArgumentException ioe) {\n            throw new BuildException(ioe.getMessage(), ioe);\n        }\n    }\n\n    public void execute() throws BuildException {\n        final AntLogHandler antLogHandler = new AntLogHandler(project);\n        final ScopedLogHandlersManager logManager = new ScopedLogHandlersManager(antLogHandler.getAntLogLevel(), antLogHandler);\n        try {\n            doTask();\n        } catch (BuildException e) {\n            throw e;\n        } catch (Exception other) {\n            throw new BuildException(other);\n        } finally {\n            logManager.close();\n            // only close the classloader, if it is ours. Otherwise we end up with class not found\n            // exceptions\n            if (configuration.getClassLoader() instanceof ClasspathClassLoader) {\n                IOUtil.tryCloseClassLoader(configuration.getClassLoader());\n            }\n        }\n    }\n\n    private void logRulesUsed(RuleSets rules) {\n        project.log(\"Using these rulesets: \" + configuration.getRuleSets(), Project.MSG_VERBOSE);\n\n        RuleSet[] ruleSets = rules.getAllRuleSets();\n        for (RuleSet ruleSet : ruleSets) {\n            for (Rule rule : ruleSet.getRules()) {\n                project.log(\"Using rule \" + rule.getName(), Project.MSG_VERBOSE);\n            }\n        }\n    }\n}\n",
        "filePathAfter": "pmd-core/src/main/java/net/sourceforge/pmd/ant/internal/PMDTaskImpl.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.ant.internal;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.tools.ant.AntClassLoader;\nimport org.apache.tools.ant.BuildException;\nimport org.apache.tools.ant.DirectoryScanner;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.types.FileSet;\nimport org.apache.tools.ant.types.Path;\n\nimport net.sourceforge.pmd.PMDConfiguration;\nimport net.sourceforge.pmd.PmdAnalysis;\nimport net.sourceforge.pmd.Report;\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RulePriority;\nimport net.sourceforge.pmd.RuleSet;\nimport net.sourceforge.pmd.RuleSetLoader;\nimport net.sourceforge.pmd.RuleSets;\nimport net.sourceforge.pmd.ant.Formatter;\nimport net.sourceforge.pmd.ant.PMDTask;\nimport net.sourceforge.pmd.ant.SourceLanguage;\nimport net.sourceforge.pmd.lang.LanguageRegistry;\nimport net.sourceforge.pmd.lang.LanguageVersion;\nimport net.sourceforge.pmd.renderers.AbstractRenderer;\nimport net.sourceforge.pmd.util.ClasspathClassLoader;\nimport net.sourceforge.pmd.util.IOUtil;\nimport net.sourceforge.pmd.util.datasource.DataSource;\nimport net.sourceforge.pmd.util.log.AntLogHandler;\nimport net.sourceforge.pmd.util.log.ScopedLogHandlersManager;\n\npublic class PMDTaskImpl {\n\n    private Path classpath;\n    private Path auxClasspath;\n    private final List<Formatter> formatters = new ArrayList<>();\n    private final List<FileSet> filesets = new ArrayList<>();\n    private final PMDConfiguration configuration = new PMDConfiguration();\n    private boolean failOnError;\n    private boolean failOnRuleViolation;\n    private int maxRuleViolations = 0;\n    private String failuresPropertyName;\n    private Project project;\n\n    public PMDTaskImpl(PMDTask task) {\n        configuration.setReportShortNames(task.isShortFilenames());\n        configuration.setSuppressMarker(task.getSuppressMarker());\n        this.failOnError = task.isFailOnError();\n        this.failOnRuleViolation = task.isFailOnRuleViolation();\n        this.maxRuleViolations = task.getMaxRuleViolations();\n        if (this.maxRuleViolations > 0) {\n            this.failOnRuleViolation = true;\n        }\n        configuration.setRuleSets(task.getRulesetFiles());\n        configuration.setRuleSetFactoryCompatibilityEnabled(!task.isNoRuleSetCompatibility());\n        if (task.getEncoding() != null) {\n            configuration.setSourceEncoding(task.getEncoding());\n        }\n        configuration.setThreads(task.getThreads());\n        this.failuresPropertyName = task.getFailuresPropertyName();\n        configuration.setMinimumPriority(RulePriority.valueOf(task.getMinimumPriority()));\n        configuration.setAnalysisCacheLocation(task.getCacheLocation());\n        configuration.setIgnoreIncrementalAnalysis(task.isNoCache());\n\n        SourceLanguage version = task.getSourceLanguage();\n        if (version != null) {\n            LanguageVersion languageVersion = LanguageRegistry\n                    .findLanguageVersionByTerseName(version.getName() + ' ' + version.getVersion());\n            if (languageVersion == null) {\n                throw new BuildException(\"The following language is not supported:\" + version + '.');\n            }\n            configuration.setDefaultLanguageVersion(languageVersion);\n        }\n\n        classpath = task.getClasspath();\n        auxClasspath = task.getAuxClasspath();\n\n        filesets.addAll(task.getFilesets());\n        formatters.addAll(task.getFormatters());\n\n        project = task.getProject();\n    }\n\n    private void doTask() {\n        setupClassLoader();\n\n        if (configuration.getSuppressMarker() != null) {\n            project.log(\"Setting suppress marker to be \" + configuration.getSuppressMarker(), Project.MSG_VERBOSE);\n        }\n\n\n        @SuppressWarnings(\"PMD.CloseResource\") final List<String> reportShortNamesPaths = new ArrayList<>();\n        List<String> fullInputPath = new ArrayList<>();\n\n        List<String> ruleSetPaths = expandRuleSetPaths();\n        // don't let PmdAnalysis.create create rulesets itself.\n        configuration.setRuleSets(Collections.<String>emptyList());\n\n        Report report;\n        try (PmdAnalysis pmd = PmdAnalysis.create(configuration)) {\n            RuleSetLoader rulesetLoader =\n                pmd.newRuleSetLoader().loadResourcesWith(setupResourceLoader());\n            pmd.addRuleSets(rulesetLoader.loadRuleSetsWithoutException(ruleSetPaths));\n\n            for (FileSet fileset : filesets) {\n                DirectoryScanner ds = fileset.getDirectoryScanner(project);\n                for (String srcFile : ds.getIncludedFiles()) {\n                    pmd.files().addFile(ds.getBasedir().toPath().resolve(srcFile));\n                }\n\n                final String commonInputPath = ds.getBasedir().getPath();\n                fullInputPath.add(commonInputPath);\n                if (configuration.isReportShortNames()) {\n                    reportShortNamesPaths.add(commonInputPath);\n                }\n            }\n\n            for (Formatter formatter : formatters) {\n                project.log(\"Sending a report to \" + formatter, Project.MSG_VERBOSE);\n                pmd.addRenderer(formatter.toRenderer(project, reportShortNamesPaths));\n            }\n\n            pmd.addRenderer(getLogRenderer(StringUtils.join(fullInputPath, \",\")));\n\n            report = pmd.performAnalysisAndCollectReport();\n        }\n\n        int problemCount = report.getViolations().size();\n        project.log(problemCount + \" problems found\", Project.MSG_VERBOSE);\n\n        if (failuresPropertyName != null && problemCount > 0) {\n            project.setProperty(failuresPropertyName, String.valueOf(problemCount));\n            project.log(\"Setting property \" + failuresPropertyName + \" to \" + problemCount, Project.MSG_VERBOSE);\n        }\n\n        if (failOnRuleViolation && problemCount > maxRuleViolations) {\n            throw new BuildException(\"Stopping build since PMD found \" + problemCount + \" rule violations in the code\");\n        }\n    }\n\n    private List<String> expandRuleSetPaths() {\n        List<String> paths = new ArrayList<>(configuration.getRuleSetPaths());\n        for (int i = 0; i < paths.size(); i++) {\n            paths.set(i, project.replaceProperties(paths.get(i)));\n        }\n        return paths;\n    }\n\n    private AbstractRenderer getLogRenderer(final String commonInputPath) {\n        return new AbstractRenderer(\"log\", \"Logging renderer\") {\n            @Override\n            public void start() {\n                // Nothing to do\n            }\n\n            @Override\n            public void startFileAnalysis(DataSource dataSource) {\n                project.log(\"Processing file \" + dataSource.getNiceFileName(false, commonInputPath),\n                            Project.MSG_VERBOSE);\n            }\n\n            @Override\n            public void renderFileReport(Report r) {\n                // Nothing to do\n            }\n\n            @Override\n            public void end() {\n                // Nothing to do\n            }\n\n            @Override\n            public void flush() {\n                // Nothing to do\n            }\n\n            @Override\n            public String defaultFileExtension() {\n                return null;\n            } // not relevant\n        };\n    }\n\n    private ClassLoader setupResourceLoader() {\n        if (classpath == null) {\n            classpath = new Path(project);\n        }\n\n        /*\n         * 'basedir' is added to the path to make sure that relative paths such\n         * as \"<ruleset>resources/custom_ruleset.xml</ruleset>\" still work when\n         * ant is invoked from a different directory using \"-f\"\n         */\n        classpath.add(new Path(null, project.getBaseDir().toString()));\n\n        project.log(\"Using the AntClassLoader: \" + classpath, Project.MSG_VERBOSE);\n        // must be true, otherwise you'll get ClassCastExceptions as classes\n        // are loaded twice\n        // and exist in multiple class loaders\n        final boolean parentFirst = true;\n        return new AntClassLoader(Thread.currentThread().getContextClassLoader(),\n                                  project, classpath, parentFirst);\n    }\n\n    private void handleError(String filename, Report errorReport, RuntimeException pmde) {\n\n        pmde.printStackTrace();\n        project.log(pmde.toString(), Project.MSG_VERBOSE);\n\n        Throwable cause = pmde.getCause();\n\n        if (cause != null) {\n            try (StringWriter strWriter = new StringWriter();\n                 PrintWriter printWriter = new PrintWriter(strWriter)) {\n                cause.printStackTrace(printWriter);\n                project.log(strWriter.toString(), Project.MSG_VERBOSE);\n            } catch (IOException e) {\n                project.log(\"Error while closing stream\", e, Project.MSG_ERR);\n            }\n            if (StringUtils.isNotBlank(cause.getMessage())) {\n                project.log(cause.getMessage(), Project.MSG_VERBOSE);\n            }\n        }\n\n        if (failOnError) {\n            throw new BuildException(pmde);\n        }\n        errorReport.addError(new Report.ProcessingError(pmde, filename));\n    }\n\n    private void setupClassLoader() {\n        try {\n            if (auxClasspath != null) {\n                project.log(\"Using auxclasspath: \" + auxClasspath, Project.MSG_VERBOSE);\n                configuration.prependAuxClasspath(auxClasspath.toString());\n            }\n        } catch (IllegalArgumentException ioe) {\n            throw new BuildException(ioe.getMessage(), ioe);\n        }\n    }\n\n    public void execute() throws BuildException {\n        final AntLogHandler antLogHandler = new AntLogHandler(project);\n        final ScopedLogHandlersManager logManager = new ScopedLogHandlersManager(antLogHandler.getAntLogLevel(), antLogHandler);\n        try {\n            doTask();\n        } catch (BuildException e) {\n            throw e;\n        } catch (Exception other) {\n            throw new BuildException(other);\n        } finally {\n            logManager.close();\n            // only close the classloader, if it is ours. Otherwise we end up with class not found\n            // exceptions\n            if (configuration.getClassLoader() instanceof ClasspathClassLoader) {\n                IOUtil.tryCloseClassLoader(configuration.getClassLoader());\n            }\n        }\n    }\n\n    private void logRulesUsed(RuleSets rules) {\n        project.log(\"Using these rulesets: \" + configuration.getRuleSets(), Project.MSG_VERBOSE);\n\n        RuleSet[] ruleSets = rules.getAllRuleSets();\n        for (RuleSet ruleSet : ruleSets) {\n            for (Rule rule : ruleSet.getRules()) {\n                project.log(\"Using rule \" + rule.getName(), Project.MSG_VERBOSE);\n            }\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            "}\n        errorReport.addError(new Report.ProcessingError(pmde, filename));\n    }\n\n    private void setupClassLoader() {\n        try {\n            if (auxClasspath != null) {"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.RuleSetLoader#fromPmdConfig\n methodBody: public static RuleSetLoader fromPmdConfig(PMDConfiguration configuration) {\nreturn new RuleSetLoader().filterAbovePriority(configuration.getMinimumPriority()).enableCompatibility(configuration.isRuleSetFactoryCompatibilityEnabled());\n}",
            "methodSignature: net.sourceforge.pmd.ant.internal.PMDTaskImpl#handleError\n methodBody: private void handleError(String filename, Report errorReport, RuntimeException pmde) {\npmde.printStackTrace();\nproject.log(pmde.toString(),Project.MSG_VERBOSE);\nThrowable cause=pmde.getCause();\nif(cause != null){try(StringWriter strWriter=new StringWriter(); PrintWriter printWriter=new PrintWriter(strWriter))cause.printStackTrace(printWriter);\nproject.log(strWriter.toString(),Project.MSG_VERBOSE);\ncatch(IOException e)project.log(\"Error while closing stream\",e,Project.MSG_ERR);\nif(StringUtils.isNotBlank(cause.getMessage())){project.log(cause.getMessage(),Project.MSG_VERBOSE);\n}}if(failOnError){throw new BuildException(pmde);\n}errorReport.addError(new Report.ProcessingError(pmde,filename));\n}",
            "methodSignature: net.sourceforge.pmd.ant.Formatter#toString\n methodBody: public String toString() {\nreturn \"file = \" + toFile + \"; renderer = \" + type;\n}",
            "methodSignature: net.sourceforge.pmd.ant.internal.PMDTaskImpl#setupResourceLoader\n methodBody: private ClassLoader setupResourceLoader() {\nif(classpath == null){classpath=new Path(project);\n}classpath.add(new Path(null,project.getBaseDir().toString()));\nproject.log(\"Using the AntClassLoader: \" + classpath,Project.MSG_VERBOSE);\nfinal boolean parentFirst=true;\nreturn new AntClassLoader(Thread.currentThread().getContextClassLoader(),project,classpath,parentFirst);\n}",
            "methodSignature: net.sourceforge.pmd.ant.internal.PMDTaskImpl#logRulesUsed\n methodBody: private void logRulesUsed(RuleSets rules) {\nproject.log(\"Using these rulesets: \" + configuration.getRuleSets(),Project.MSG_VERBOSE);\nRuleSet[] ruleSets=rules.getAllRuleSets();\nfor(RuleSet ruleSet: ruleSets){for(Rule rule: ruleSet.getRules()){project.log(\"Using rule \" + rule.getName(),Project.MSG_VERBOSE);\n}}}",
            "methodSignature: net.sourceforge.pmd.ant.Formatter#getRenderer\n methodBody: public Renderer getRenderer() {\nreturn renderer;\n}",
            "methodSignature: net.sourceforge.pmd.ant.internal.PMDTaskImpl#setupClassLoader\n methodBody: private void setupClassLoader() {\ntryif(auxClasspath != null){project.log(\"Using auxclasspath: \" + auxClasspath,Project.MSG_VERBOSE);\nconfiguration.prependAuxClasspath(auxClasspath.toString());\n}catch(IllegalArgumentException ioe)throw new BuildException(ioe.getMessage(),ioe);\n}",
            "methodSignature: net.sourceforge.pmd.RuleSetLoader#toFactory\n methodBody: public RuleSetFactory toFactory() {\nreturn new RuleSetFactory(this.resourceLoader,this.minimumPriority,this.warnDeprecated,this.enableCompatibility,this.includeDeprecatedRuleReferences);\n}",
            "methodSignature: net.sourceforge.pmd.RuleSetLoader#loadResourcesWith\n methodBody: RuleSetLoader loadResourcesWith(ResourceLoader loader) {\nthis.resourceLoader=loader;\nreturn this;\n}",
            "methodSignature: net.sourceforge.pmd.ant.Formatter#start\n methodBody: public void start(String baseDir) {\nProperties properties=createProperties();\nCharset charset;\n{String s=(String)properties.get(\"encoding\");\nif(null == s){if(toConsole){s=getConsoleEncoding();\nif(null == s){s=System.getProperty(\"file.encoding\");\n}}if(null == s){charset=StandardCharsets.UTF_8;\n}{charset=Charset.forName(s);\n}final Parameter parameter=new Parameter();\nparameter.setName(\"encoding\");\nparameter.setValue(charset.name());\nparameters.add(parameter);\n}{charset=Charset.forName(s);\n}}tryif(toConsole){writer=new BufferedWriter(new OutputStreamWriter(System.out,charset));\n}if(toFile != null){writer=getToFileWriter(baseDir,toFile,charset);\n}renderer=createRenderer();\nrenderer.setWriter(writer);\nrenderer.start();\ncatch(IOException ioe)throw new BuildException(ioe.getMessage(),ioe);\n}",
            "methodSignature: net.sourceforge.pmd.ant.Formatter#end\n methodBody: public void end(Report errorReport) {\ntryrenderer.renderFileReport(errorReport);\nrenderer.end();\nif(toConsole){writer.flush();\n}{writer.close();\n}catch(IOException ioe)throw new BuildException(ioe.getMessage(),ioe);\n}"
        ],
        "sourceCodeAfterRefactoring": "private void doTask() {\n        setupClassLoader();\n\n        if (configuration.getSuppressMarker() != null) {\n            project.log(\"Setting suppress marker to be \" + configuration.getSuppressMarker(), Project.MSG_VERBOSE);\n        }\n\n\n        @SuppressWarnings(\"PMD.CloseResource\") final List<String> reportShortNamesPaths = new ArrayList<>();\n        List<String> fullInputPath = new ArrayList<>();\n\n        List<String> ruleSetPaths = expandRuleSetPaths();\n        // don't let PmdAnalysis.create create rulesets itself.\n        configuration.setRuleSets(Collections.<String>emptyList());\n\n        Report report;\n        try (PmdAnalysis pmd = PmdAnalysis.create(configuration)) {\n            RuleSetLoader rulesetLoader =\n                pmd.newRuleSetLoader().loadResourcesWith(setupResourceLoader());\n            pmd.addRuleSets(rulesetLoader.loadRuleSetsWithoutException(ruleSetPaths));\n\n            for (FileSet fileset : filesets) {\n                DirectoryScanner ds = fileset.getDirectoryScanner(project);\n                for (String srcFile : ds.getIncludedFiles()) {\n                    pmd.files().addFile(ds.getBasedir().toPath().resolve(srcFile));\n                }\n\n                final String commonInputPath = ds.getBasedir().getPath();\n                fullInputPath.add(commonInputPath);\n                if (configuration.isReportShortNames()) {\n                    reportShortNamesPaths.add(commonInputPath);\n                }\n            }\n\n            for (Formatter formatter : formatters) {\n                project.log(\"Sending a report to \" + formatter, Project.MSG_VERBOSE);\n                pmd.addRenderer(formatter.toRenderer(project, reportShortNamesPaths));\n            }\n\n            pmd.addRenderer(getLogRenderer(StringUtils.join(fullInputPath, \",\")));\n\n            report = pmd.performAnalysisAndCollectReport();\n        }\n\n        int problemCount = report.getViolations().size();\n        project.log(problemCount + \" problems found\", Project.MSG_VERBOSE);\n\n        if (failuresPropertyName != null && problemCount > 0) {\n            project.setProperty(failuresPropertyName, String.valueOf(problemCount));\n            project.log(\"Setting property \" + failuresPropertyName + \" to \" + problemCount, Project.MSG_VERBOSE);\n        }\n\n        if (failOnRuleViolation && problemCount > maxRuleViolations) {\n            throw new BuildException(\"Stopping build since PMD found \" + problemCount + \" rule violations in the code\");\n        }\n    }\n}\n        errorReport.addError(new Report.ProcessingError(pmde, filename));\n    }\n\n    private void setupClassLoader() {\n        try {\n            if (auxClasspath != null) {",
        "diffSourceCode": "-   94:         filesets.addAll(task.getFilesets());\n-   95:         formatters.addAll(task.getFormatters());\n+   94:     private void doTask() {\n+   95:         setupClassLoader();\n    96: \n-   97:         project = task.getProject();\n-   98:     }\n-   99: \n-  100:     private void doTask() {\n-  101:         setupClassLoader();\n-  102: \n-  103:         // Setup RuleSetFactory and validate RuleSets\n-  104:         RuleSetLoader rulesetLoader = RuleSetLoader.fromPmdConfig(configuration)\n-  105:                                                    .loadResourcesWith(setupResourceLoader());\n-  106: \n-  107:         // This is just used to validate and display rules. Each thread will create its own ruleset\n-  108:         String ruleSetString = configuration.getRuleSets();\n-  109:         if (StringUtils.isNotBlank(ruleSetString)) {\n-  110:             // Substitute env variables/properties\n-  111:             configuration.setRuleSets(project.replaceProperties(ruleSetString));\n-  112:         }\n-  113: \n-  114:         final RuleSets ruleSets = RulesetsFactoryUtils.getRuleSets(configuration.getRuleSets(), rulesetLoader.toFactory());\n-  115:         List<RuleSet> rulesetList = Arrays.asList(ruleSets.getAllRuleSets());\n-  116:         logRulesUsed(ruleSets);\n-  117: \n-  118:         if (configuration.getSuppressMarker() != null) {\n-  119:             project.log(\"Setting suppress marker to be \" + configuration.getSuppressMarker(), Project.MSG_VERBOSE);\n-  120:         }\n-  121: \n-  122:         // Start the Formatters\n-  123:         for (Formatter formatter : formatters) {\n-  124:             project.log(\"Sending a report to \" + formatter, Project.MSG_VERBOSE);\n-  125:             formatter.start(project.getBaseDir().toString());\n-  126:         }\n+   97:         if (configuration.getSuppressMarker() != null) {\n+   98:             project.log(\"Setting suppress marker to be \" + configuration.getSuppressMarker(), Project.MSG_VERBOSE);\n+   99:         }\n+  100: \n+  101: \n+  102:         @SuppressWarnings(\"PMD.CloseResource\") final List<String> reportShortNamesPaths = new ArrayList<>();\n+  103:         List<String> fullInputPath = new ArrayList<>();\n+  104: \n+  105:         List<String> ruleSetPaths = expandRuleSetPaths();\n+  106:         // don't let PmdAnalysis.create create rulesets itself.\n+  107:         configuration.setRuleSets(Collections.<String>emptyList());\n+  108: \n+  109:         Report report;\n+  110:         try (PmdAnalysis pmd = PmdAnalysis.create(configuration)) {\n+  111:             RuleSetLoader rulesetLoader =\n+  112:                 pmd.newRuleSetLoader().loadResourcesWith(setupResourceLoader());\n+  113:             pmd.addRuleSets(rulesetLoader.loadRuleSetsWithoutException(ruleSetPaths));\n+  114: \n+  115:             for (FileSet fileset : filesets) {\n+  116:                 DirectoryScanner ds = fileset.getDirectoryScanner(project);\n+  117:                 for (String srcFile : ds.getIncludedFiles()) {\n+  118:                     pmd.files().addFile(ds.getBasedir().toPath().resolve(srcFile));\n+  119:                 }\n+  120: \n+  121:                 final String commonInputPath = ds.getBasedir().getPath();\n+  122:                 fullInputPath.add(commonInputPath);\n+  123:                 if (configuration.isReportShortNames()) {\n+  124:                     reportShortNamesPaths.add(commonInputPath);\n+  125:                 }\n+  126:             }\n   127: \n-  128:         // log(\"Setting Language Version \" + languageVersion.getShortName(),\n-  129:         // Project.MSG_VERBOSE);\n-  130: \n-  131:         // TODO Do we really need all this in a loop over each FileSet? Seems\n-  132:         // like a lot of redundancy\n-  133:         Report errorReport = new Report();\n-  134:         int problemCount = 0;\n-  135:         final String separator = System.getProperty(\"file.separator\");\n-  136: \n-  137:         for (FileSet fs : filesets) {\n-  138:             List<DataSource> files = new LinkedList<>();\n-  139:             DirectoryScanner ds = fs.getDirectoryScanner(project);\n-  140:             String[] srcFiles = ds.getIncludedFiles();\n-  141:             for (String srcFile : srcFiles) {\n-  142:                 File file = new File(ds.getBasedir() + separator + srcFile);\n-  143:                 files.add(new FileDataSource(file));\n-  144:             }\n+  128:             for (Formatter formatter : formatters) {\n+  129:                 project.log(\"Sending a report to \" + formatter, Project.MSG_VERBOSE);\n+  130:                 pmd.addRenderer(formatter.toRenderer(project, reportShortNamesPaths));\n+  131:             }\n+  132: \n+  133:             pmd.addRenderer(getLogRenderer(StringUtils.join(fullInputPath, \",\")));\n+  134: \n+  135:             report = pmd.performAnalysisAndCollectReport();\n+  136:         }\n+  137: \n+  138:         int problemCount = report.getViolations().size();\n+  139:         project.log(problemCount + \" problems found\", Project.MSG_VERBOSE);\n+  140: \n+  141:         if (failuresPropertyName != null && problemCount > 0) {\n+  142:             project.setProperty(failuresPropertyName, String.valueOf(problemCount));\n+  143:             project.log(\"Setting property \" + failuresPropertyName + \" to \" + problemCount, Project.MSG_VERBOSE);\n+  144:         }\n   145: \n-  146:             final String commonInputPath = ds.getBasedir().getPath();\n-  147:             configuration.setInputPaths(commonInputPath);\n-  148:             final List<String> reportShortNamesPaths = new ArrayList<>();\n-  149:             if (configuration.isReportShortNames()) {\n-  150:                 reportShortNamesPaths.add(commonInputPath);\n-  151:             }\n-  152: \n-  153:             Renderer logRenderer = new AbstractRenderer(\"log\", \"Logging renderer\") {\n-  154:                 @Override\n-  155:                 public void start() {\n-  156:                     // Nothing to do\n-  157:                 }\n+  146:         if (failOnRuleViolation && problemCount > maxRuleViolations) {\n+  147:             throw new BuildException(\"Stopping build since PMD found \" + problemCount + \" rule violations in the code\");\n+  148:         }\n+  149:     }\n+  150: \n+  151:     private List<String> expandRuleSetPaths() {\n+  152:         List<String> paths = new ArrayList<>(configuration.getRuleSetPaths());\n+  153:         for (int i = 0; i < paths.size(); i++) {\n+  154:             paths.set(i, project.replaceProperties(paths.get(i)));\n+  155:         }\n+  156:         return paths;\n+  157:     }\n   158: \n-  159:                 @Override\n-  160:                 public void startFileAnalysis(DataSource dataSource) {\n-  161:                     project.log(\"Processing file \" + dataSource.getNiceFileName(false, commonInputPath),\n-  162:                             Project.MSG_VERBOSE);\n-  163:                 }\n-  164: \n-  165:                 @Override\n-  166:                 public void renderFileReport(Report r) {\n-  167:                     // Nothing to do\n-  168:                 }\n-  169: \n-  170:                 @Override\n-  171:                 public void end() {\n-  172:                     // Nothing to do\n-  173:                 }\n-  174: \n-  175:                 @Override\n-  176:                 public String defaultFileExtension() {\n-  177:                     return null;\n-  178:                 } // not relevant\n-  179:             };\n-  180:             List<Renderer> renderers = new ArrayList<>(formatters.size() + 1);\n-  181:             renderers.add(logRenderer);\n-  182:             for (Formatter formatter : formatters) {\n-  183:                 Renderer renderer = formatter.getRenderer();\n-  184:                 renderer.setUseShortNames(reportShortNamesPaths);\n-  185:                 renderers.add(renderer);\n-  186:             }\n-  187:             try {\n-  188:                 Report report = PMD.processFiles(configuration, rulesetList, files, renderers);\n-  189:                 problemCount += report.getViolations().size();\n-  190:             } catch (ContextedRuntimeException e) {\n-  191:                 if (e.getFirstContextValue(\"filename\") instanceof String) {\n-  192:                     handleError((String) e.getFirstContextValue(\"filename\"), errorReport, e);\n-  193:                 } else {\n-  194:                     handleError(\"(unknown file)\", errorReport, e);\n-  195:                 }\n-  196:             } catch (RuntimeException pmde) {\n-  197:                 handleError(\"(unknown file)\", errorReport, pmde);\n-  198:             }\n-  199:         }\n-  200: \n-  201:         project.log(problemCount + \" problems found\", Project.MSG_VERBOSE);\n-  202: \n-  203:         for (Formatter formatter : formatters) {\n-  204:             formatter.end(errorReport);\n-  205:         }\n-  206: \n-  207:         if (failuresPropertyName != null && problemCount > 0) {\n-  208:             project.setProperty(failuresPropertyName, String.valueOf(problemCount));\n-  209:             project.log(\"Setting property \" + failuresPropertyName + \" to \" + problemCount, Project.MSG_VERBOSE);\n-  210:         }\n-  211: \n-  212:         if (failOnRuleViolation && problemCount > maxRuleViolations) {\n-  213:             throw new BuildException(\"Stopping build since PMD found \" + problemCount + \" rule violations in the code\");\n-  214:         }\n-  215:     }\n-  237: \n-  238:     private void handleError(String filename, Report errorReport, RuntimeException pmde) {\n-  239: \n-  240:         pmde.printStackTrace();\n-  241:         project.log(pmde.toString(), Project.MSG_VERBOSE);\n-  242: \n-  243:         Throwable cause = pmde.getCause();\n+  159:     private AbstractRenderer getLogRenderer(final String commonInputPath) {\n+  160:         return new AbstractRenderer(\"log\", \"Logging renderer\") {\n+  161:             @Override\n+  162:             public void start() {\n+  163:                 // Nothing to do\n+  164:             }\n+  165: \n+  166:             @Override\n+  167:             public void startFileAnalysis(DataSource dataSource) {\n+  168:                 project.log(\"Processing file \" + dataSource.getNiceFileName(false, commonInputPath),\n+  169:                             Project.MSG_VERBOSE);\n+  170:             }\n+  171: \n+  172:             @Override\n+  173:             public void renderFileReport(Report r) {\n+  174:                 // Nothing to do\n+  175:             }\n+  176: \n+  177:             @Override\n+  178:             public void end() {\n+  179:                 // Nothing to do\n+  180:             }\n+  181: \n+  182:             @Override\n+  183:             public void flush() {\n+  184:                 // Nothing to do\n+  185:             }\n+  186: \n+  187:             @Override\n+  188:             public String defaultFileExtension() {\n+  189:                 return null;\n+  190:             } // not relevant\n+  191:         };\n+  192:     }\n+  193: \n+  194:     private ClassLoader setupResourceLoader() {\n+  195:         if (classpath == null) {\n+  196:             classpath = new Path(project);\n+  197:         }\n+  198: \n+  199:         /*\n+  200:          * 'basedir' is added to the path to make sure that relative paths such\n+  201:          * as \"<ruleset>resources/custom_ruleset.xml</ruleset>\" still work when\n+  202:          * ant is invoked from a different directory using \"-f\"\n+  203:          */\n+  204:         classpath.add(new Path(null, project.getBaseDir().toString()));\n+  205: \n+  206:         project.log(\"Using the AntClassLoader: \" + classpath, Project.MSG_VERBOSE);\n+  207:         // must be true, otherwise you'll get ClassCastExceptions as classes\n+  208:         // are loaded twice\n+  209:         // and exist in multiple class loaders\n+  210:         final boolean parentFirst = true;\n+  211:         return new AntClassLoader(Thread.currentThread().getContextClassLoader(),\n+  212:                                   project, classpath, parentFirst);\n+  213:     }\n+  214: \n+  215:     private void handleError(String filename, Report errorReport, RuntimeException pmde) {\n+  237:         }\n+  238:         errorReport.addError(new Report.ProcessingError(pmde, filename));\n+  239:     }\n+  240: \n+  241:     private void setupClassLoader() {\n+  242:         try {\n+  243:             if (auxClasspath != null) {\n",
        "uniqueId": "5dc2774c0a53810717358cc850b69c6e7fe0a463_100_215_237_243_94_149",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 53,
                "covered": 138
            },
            "BRANCH": {
                "missed": 11,
                "covered": 9
            },
            "LINE": {
                "missed": 4,
                "covered": 26
            },
            "COMPLEXITY": {
                "missed": 8,
                "covered": 3
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate getLogRenderer(commonInputPath String) : AbstractRenderer extracted from private doTask() : void in class net.sourceforge.pmd.ant.internal.PMDTaskImpl",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/ant/internal/PMDTaskImpl.java",
                "startLine": 100,
                "endLine": 215,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/ant/internal/PMDTaskImpl.java",
                "startLine": 94,
                "endLine": 149,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/ant/internal/PMDTaskImpl.java",
                "startLine": 159,
                "endLine": 192,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private void doTask() {\n        setupClassLoader();\n\n        // Setup RuleSetFactory and validate RuleSets\n        RuleSetLoader rulesetLoader = RuleSetLoader.fromPmdConfig(configuration)\n                                                   .loadResourcesWith(setupResourceLoader());\n\n        // This is just used to validate and display rules. Each thread will create its own ruleset\n        String ruleSetString = configuration.getRuleSets();\n        if (StringUtils.isNotBlank(ruleSetString)) {\n            // Substitute env variables/properties\n            configuration.setRuleSets(project.replaceProperties(ruleSetString));\n        }\n\n        final RuleSets ruleSets = RulesetsFactoryUtils.getRuleSets(configuration.getRuleSets(), rulesetLoader.toFactory());\n        List<RuleSet> rulesetList = Arrays.asList(ruleSets.getAllRuleSets());\n        logRulesUsed(ruleSets);\n\n        if (configuration.getSuppressMarker() != null) {\n            project.log(\"Setting suppress marker to be \" + configuration.getSuppressMarker(), Project.MSG_VERBOSE);\n        }\n\n        // Start the Formatters\n        for (Formatter formatter : formatters) {\n            project.log(\"Sending a report to \" + formatter, Project.MSG_VERBOSE);\n            formatter.start(project.getBaseDir().toString());\n        }\n\n        // log(\"Setting Language Version \" + languageVersion.getShortName(),\n        // Project.MSG_VERBOSE);\n\n        // TODO Do we really need all this in a loop over each FileSet? Seems\n        // like a lot of redundancy\n        Report errorReport = new Report();\n        int problemCount = 0;\n        final String separator = System.getProperty(\"file.separator\");\n\n        for (FileSet fs : filesets) {\n            List<DataSource> files = new LinkedList<>();\n            DirectoryScanner ds = fs.getDirectoryScanner(project);\n            String[] srcFiles = ds.getIncludedFiles();\n            for (String srcFile : srcFiles) {\n                File file = new File(ds.getBasedir() + separator + srcFile);\n                files.add(new FileDataSource(file));\n            }\n\n            final String commonInputPath = ds.getBasedir().getPath();\n            configuration.setInputPaths(commonInputPath);\n            final List<String> reportShortNamesPaths = new ArrayList<>();\n            if (configuration.isReportShortNames()) {\n                reportShortNamesPaths.add(commonInputPath);\n            }\n\n            Renderer logRenderer = new AbstractRenderer(\"log\", \"Logging renderer\") {\n                @Override\n                public void start() {\n                    // Nothing to do\n                }\n\n                @Override\n                public void startFileAnalysis(DataSource dataSource) {\n                    project.log(\"Processing file \" + dataSource.getNiceFileName(false, commonInputPath),\n                            Project.MSG_VERBOSE);\n                }\n\n                @Override\n                public void renderFileReport(Report r) {\n                    // Nothing to do\n                }\n\n                @Override\n                public void end() {\n                    // Nothing to do\n                }\n\n                @Override\n                public String defaultFileExtension() {\n                    return null;\n                } // not relevant\n            };\n            List<Renderer> renderers = new ArrayList<>(formatters.size() + 1);\n            renderers.add(logRenderer);\n            for (Formatter formatter : formatters) {\n                Renderer renderer = formatter.getRenderer();\n                renderer.setUseShortNames(reportShortNamesPaths);\n                renderers.add(renderer);\n            }\n            try {\n                Report report = PMD.processFiles(configuration, rulesetList, files, renderers);\n                problemCount += report.getViolations().size();\n            } catch (ContextedRuntimeException e) {\n                if (e.getFirstContextValue(\"filename\") instanceof String) {\n                    handleError((String) e.getFirstContextValue(\"filename\"), errorReport, e);\n                } else {\n                    handleError(\"(unknown file)\", errorReport, e);\n                }\n            } catch (RuntimeException pmde) {\n                handleError(\"(unknown file)\", errorReport, pmde);\n            }\n        }\n\n        project.log(problemCount + \" problems found\", Project.MSG_VERBOSE);\n\n        for (Formatter formatter : formatters) {\n            formatter.end(errorReport);\n        }\n\n        if (failuresPropertyName != null && problemCount > 0) {\n            project.setProperty(failuresPropertyName, String.valueOf(problemCount));\n            project.log(\"Setting property \" + failuresPropertyName + \" to \" + problemCount, Project.MSG_VERBOSE);\n        }\n\n        if (failOnRuleViolation && problemCount > maxRuleViolations) {\n            throw new BuildException(\"Stopping build since PMD found \" + problemCount + \" rule violations in the code\");\n        }\n    }",
        "filePathBefore": "pmd-core/src/main/java/net/sourceforge/pmd/ant/internal/PMDTaskImpl.java",
        "isPureRefactoring": true,
        "commitId": "5dc2774c0a53810717358cc850b69c6e7fe0a463",
        "packageNameBefore": "net.sourceforge.pmd.ant.internal",
        "classNameBefore": "net.sourceforge.pmd.ant.internal.PMDTaskImpl",
        "methodNameBefore": "net.sourceforge.pmd.ant.internal.PMDTaskImpl#doTask",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.RuleSetLoader#fromPmdConfig\n methodBody: public static RuleSetLoader fromPmdConfig(PMDConfiguration configuration) {\nreturn new RuleSetLoader().filterAbovePriority(configuration.getMinimumPriority()).enableCompatibility(configuration.isRuleSetFactoryCompatibilityEnabled());\n}\nmethodSignature: net.sourceforge.pmd.ant.internal.PMDTaskImpl#handleError\n methodBody: private void handleError(String filename, Report errorReport, RuntimeException pmde) {\npmde.printStackTrace();\nproject.log(pmde.toString(),Project.MSG_VERBOSE);\nThrowable cause=pmde.getCause();\nif(cause != null){try(StringWriter strWriter=new StringWriter(); PrintWriter printWriter=new PrintWriter(strWriter))cause.printStackTrace(printWriter);\nproject.log(strWriter.toString(),Project.MSG_VERBOSE);\ncatch(IOException e)project.log(\"Error while closing stream\",e,Project.MSG_ERR);\nif(StringUtils.isNotBlank(cause.getMessage())){project.log(cause.getMessage(),Project.MSG_VERBOSE);\n}}if(failOnError){throw new BuildException(pmde);\n}errorReport.addError(new Report.ProcessingError(pmde,filename));\n}\nmethodSignature: net.sourceforge.pmd.ant.Formatter#toString\n methodBody: public String toString() {\nreturn \"file = \" + toFile + \"; renderer = \" + type;\n}\nmethodSignature: net.sourceforge.pmd.ant.internal.PMDTaskImpl#setupResourceLoader\n methodBody: private ClassLoader setupResourceLoader() {\nif(classpath == null){classpath=new Path(project);\n}classpath.add(new Path(null,project.getBaseDir().toString()));\nproject.log(\"Using the AntClassLoader: \" + classpath,Project.MSG_VERBOSE);\nfinal boolean parentFirst=true;\nreturn new AntClassLoader(Thread.currentThread().getContextClassLoader(),project,classpath,parentFirst);\n}\nmethodSignature: net.sourceforge.pmd.ant.internal.PMDTaskImpl#logRulesUsed\n methodBody: private void logRulesUsed(RuleSets rules) {\nproject.log(\"Using these rulesets: \" + configuration.getRuleSets(),Project.MSG_VERBOSE);\nRuleSet[] ruleSets=rules.getAllRuleSets();\nfor(RuleSet ruleSet: ruleSets){for(Rule rule: ruleSet.getRules()){project.log(\"Using rule \" + rule.getName(),Project.MSG_VERBOSE);\n}}}\nmethodSignature: net.sourceforge.pmd.ant.Formatter#getRenderer\n methodBody: public Renderer getRenderer() {\nreturn renderer;\n}\nmethodSignature: net.sourceforge.pmd.ant.internal.PMDTaskImpl#setupClassLoader\n methodBody: private void setupClassLoader() {\ntryif(auxClasspath != null){project.log(\"Using auxclasspath: \" + auxClasspath,Project.MSG_VERBOSE);\nconfiguration.prependAuxClasspath(auxClasspath.toString());\n}catch(IllegalArgumentException ioe)throw new BuildException(ioe.getMessage(),ioe);\n}\nmethodSignature: net.sourceforge.pmd.RuleSetLoader#toFactory\n methodBody: public RuleSetFactory toFactory() {\nreturn new RuleSetFactory(this.resourceLoader,this.minimumPriority,this.warnDeprecated,this.enableCompatibility,this.includeDeprecatedRuleReferences);\n}\nmethodSignature: net.sourceforge.pmd.RuleSetLoader#loadResourcesWith\n methodBody: RuleSetLoader loadResourcesWith(ResourceLoader loader) {\nthis.resourceLoader=loader;\nreturn this;\n}\nmethodSignature: net.sourceforge.pmd.ant.Formatter#start\n methodBody: public void start(String baseDir) {\nProperties properties=createProperties();\nCharset charset;\n{String s=(String)properties.get(\"encoding\");\nif(null == s){if(toConsole){s=getConsoleEncoding();\nif(null == s){s=System.getProperty(\"file.encoding\");\n}}if(null == s){charset=StandardCharsets.UTF_8;\n}{charset=Charset.forName(s);\n}final Parameter parameter=new Parameter();\nparameter.setName(\"encoding\");\nparameter.setValue(charset.name());\nparameters.add(parameter);\n}{charset=Charset.forName(s);\n}}tryif(toConsole){writer=new BufferedWriter(new OutputStreamWriter(System.out,charset));\n}if(toFile != null){writer=getToFileWriter(baseDir,toFile,charset);\n}renderer=createRenderer();\nrenderer.setWriter(writer);\nrenderer.start();\ncatch(IOException ioe)throw new BuildException(ioe.getMessage(),ioe);\n}\nmethodSignature: net.sourceforge.pmd.ant.Formatter#end\n methodBody: public void end(Report errorReport) {\ntryrenderer.renderFileReport(errorReport);\nrenderer.end();\nif(toConsole){writer.flush();\n}{writer.close();\n}catch(IOException ioe)throw new BuildException(ioe.getMessage(),ioe);\n}",
        "classSignatureBefore": "public class PMDTaskImpl ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.ant.internal.PMDTaskImpl#doTask"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.ant.internal.PMDTaskImpl"
        ],
        "classSignatureBeforeSet": [
            "public class PMDTaskImpl "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics",
                "description": "All the mappings are matched! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.ant.internal;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.exception.ContextedRuntimeException;\nimport org.apache.tools.ant.AntClassLoader;\nimport org.apache.tools.ant.BuildException;\nimport org.apache.tools.ant.DirectoryScanner;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.types.FileSet;\nimport org.apache.tools.ant.types.Path;\n\nimport net.sourceforge.pmd.PMD;\nimport net.sourceforge.pmd.PMDConfiguration;\nimport net.sourceforge.pmd.Report;\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RulePriority;\nimport net.sourceforge.pmd.RuleSet;\nimport net.sourceforge.pmd.RuleSetLoader;\nimport net.sourceforge.pmd.RuleSets;\nimport net.sourceforge.pmd.RulesetsFactoryUtils;\nimport net.sourceforge.pmd.ant.Formatter;\nimport net.sourceforge.pmd.ant.PMDTask;\nimport net.sourceforge.pmd.ant.SourceLanguage;\nimport net.sourceforge.pmd.lang.LanguageRegistry;\nimport net.sourceforge.pmd.lang.LanguageVersion;\nimport net.sourceforge.pmd.renderers.AbstractRenderer;\nimport net.sourceforge.pmd.renderers.Renderer;\nimport net.sourceforge.pmd.util.ClasspathClassLoader;\nimport net.sourceforge.pmd.util.IOUtil;\nimport net.sourceforge.pmd.util.datasource.DataSource;\nimport net.sourceforge.pmd.util.datasource.FileDataSource;\nimport net.sourceforge.pmd.util.log.AntLogHandler;\nimport net.sourceforge.pmd.util.log.ScopedLogHandlersManager;\n\npublic class PMDTaskImpl {\n\n    private Path classpath;\n    private Path auxClasspath;\n    private final List<Formatter> formatters = new ArrayList<>();\n    private final List<FileSet> filesets = new ArrayList<>();\n    private final PMDConfiguration configuration = new PMDConfiguration();\n    private boolean failOnError;\n    private boolean failOnRuleViolation;\n    private int maxRuleViolations = 0;\n    private String failuresPropertyName;\n    private Project project;\n\n    public PMDTaskImpl(PMDTask task) {\n        configuration.setReportShortNames(task.isShortFilenames());\n        configuration.setSuppressMarker(task.getSuppressMarker());\n        this.failOnError = task.isFailOnError();\n        this.failOnRuleViolation = task.isFailOnRuleViolation();\n        this.maxRuleViolations = task.getMaxRuleViolations();\n        if (this.maxRuleViolations > 0) {\n            this.failOnRuleViolation = true;\n        }\n        configuration.setRuleSets(task.getRulesetFiles());\n        configuration.setRuleSetFactoryCompatibilityEnabled(!task.isNoRuleSetCompatibility());\n        if (task.getEncoding() != null) {\n            configuration.setSourceEncoding(task.getEncoding());\n        }\n        configuration.setThreads(task.getThreads());\n        this.failuresPropertyName = task.getFailuresPropertyName();\n        configuration.setMinimumPriority(RulePriority.valueOf(task.getMinimumPriority()));\n        configuration.setAnalysisCacheLocation(task.getCacheLocation());\n        configuration.setIgnoreIncrementalAnalysis(task.isNoCache());\n\n        SourceLanguage version = task.getSourceLanguage();\n        if (version != null) {\n            LanguageVersion languageVersion = LanguageRegistry\n                    .findLanguageVersionByTerseName(version.getName() + ' ' + version.getVersion());\n            if (languageVersion == null) {\n                throw new BuildException(\"The following language is not supported:\" + version + '.');\n            }\n            configuration.setDefaultLanguageVersion(languageVersion);\n        }\n\n        classpath = task.getClasspath();\n        auxClasspath = task.getAuxClasspath();\n\n        filesets.addAll(task.getFilesets());\n        formatters.addAll(task.getFormatters());\n\n        project = task.getProject();\n    }\n\n    private void doTask() {\n        setupClassLoader();\n\n        // Setup RuleSetFactory and validate RuleSets\n        RuleSetLoader rulesetLoader = RuleSetLoader.fromPmdConfig(configuration)\n                                                   .loadResourcesWith(setupResourceLoader());\n\n        // This is just used to validate and display rules. Each thread will create its own ruleset\n        String ruleSetString = configuration.getRuleSets();\n        if (StringUtils.isNotBlank(ruleSetString)) {\n            // Substitute env variables/properties\n            configuration.setRuleSets(project.replaceProperties(ruleSetString));\n        }\n\n        final RuleSets ruleSets = RulesetsFactoryUtils.getRuleSets(configuration.getRuleSets(), rulesetLoader.toFactory());\n        List<RuleSet> rulesetList = Arrays.asList(ruleSets.getAllRuleSets());\n        logRulesUsed(ruleSets);\n\n        if (configuration.getSuppressMarker() != null) {\n            project.log(\"Setting suppress marker to be \" + configuration.getSuppressMarker(), Project.MSG_VERBOSE);\n        }\n\n        // Start the Formatters\n        for (Formatter formatter : formatters) {\n            project.log(\"Sending a report to \" + formatter, Project.MSG_VERBOSE);\n            formatter.start(project.getBaseDir().toString());\n        }\n\n        // log(\"Setting Language Version \" + languageVersion.getShortName(),\n        // Project.MSG_VERBOSE);\n\n        // TODO Do we really need all this in a loop over each FileSet? Seems\n        // like a lot of redundancy\n        Report errorReport = new Report();\n        int problemCount = 0;\n        final String separator = System.getProperty(\"file.separator\");\n\n        for (FileSet fs : filesets) {\n            List<DataSource> files = new LinkedList<>();\n            DirectoryScanner ds = fs.getDirectoryScanner(project);\n            String[] srcFiles = ds.getIncludedFiles();\n            for (String srcFile : srcFiles) {\n                File file = new File(ds.getBasedir() + separator + srcFile);\n                files.add(new FileDataSource(file));\n            }\n\n            final String commonInputPath = ds.getBasedir().getPath();\n            configuration.setInputPaths(commonInputPath);\n            final List<String> reportShortNamesPaths = new ArrayList<>();\n            if (configuration.isReportShortNames()) {\n                reportShortNamesPaths.add(commonInputPath);\n            }\n\n            Renderer logRenderer = new AbstractRenderer(\"log\", \"Logging renderer\") {\n                @Override\n                public void start() {\n                    // Nothing to do\n                }\n\n                @Override\n                public void startFileAnalysis(DataSource dataSource) {\n                    project.log(\"Processing file \" + dataSource.getNiceFileName(false, commonInputPath),\n                            Project.MSG_VERBOSE);\n                }\n\n                @Override\n                public void renderFileReport(Report r) {\n                    // Nothing to do\n                }\n\n                @Override\n                public void end() {\n                    // Nothing to do\n                }\n\n                @Override\n                public String defaultFileExtension() {\n                    return null;\n                } // not relevant\n            };\n            List<Renderer> renderers = new ArrayList<>(formatters.size() + 1);\n            renderers.add(logRenderer);\n            for (Formatter formatter : formatters) {\n                Renderer renderer = formatter.getRenderer();\n                renderer.setUseShortNames(reportShortNamesPaths);\n                renderers.add(renderer);\n            }\n            try {\n                Report report = PMD.processFiles(configuration, rulesetList, files, renderers);\n                problemCount += report.getViolations().size();\n            } catch (ContextedRuntimeException e) {\n                if (e.getFirstContextValue(\"filename\") instanceof String) {\n                    handleError((String) e.getFirstContextValue(\"filename\"), errorReport, e);\n                } else {\n                    handleError(\"(unknown file)\", errorReport, e);\n                }\n            } catch (RuntimeException pmde) {\n                handleError(\"(unknown file)\", errorReport, pmde);\n            }\n        }\n\n        project.log(problemCount + \" problems found\", Project.MSG_VERBOSE);\n\n        for (Formatter formatter : formatters) {\n            formatter.end(errorReport);\n        }\n\n        if (failuresPropertyName != null && problemCount > 0) {\n            project.setProperty(failuresPropertyName, String.valueOf(problemCount));\n            project.log(\"Setting property \" + failuresPropertyName + \" to \" + problemCount, Project.MSG_VERBOSE);\n        }\n\n        if (failOnRuleViolation && problemCount > maxRuleViolations) {\n            throw new BuildException(\"Stopping build since PMD found \" + problemCount + \" rule violations in the code\");\n        }\n    }\n\n    private ClassLoader setupResourceLoader() {\n        if (classpath == null) {\n            classpath = new Path(project);\n        }\n\n        /*\n         * 'basedir' is added to the path to make sure that relative paths such\n         * as \"<ruleset>resources/custom_ruleset.xml</ruleset>\" still work when\n         * ant is invoked from a different directory using \"-f\"\n         */\n        classpath.add(new Path(null, project.getBaseDir().toString()));\n\n        project.log(\"Using the AntClassLoader: \" + classpath, Project.MSG_VERBOSE);\n        // must be true, otherwise you'll get ClassCastExceptions as classes\n        // are loaded twice\n        // and exist in multiple class loaders\n        final boolean parentFirst = true;\n        return new AntClassLoader(Thread.currentThread().getContextClassLoader(),\n                                  project, classpath, parentFirst);\n    }\n\n    private void handleError(String filename, Report errorReport, RuntimeException pmde) {\n\n        pmde.printStackTrace();\n        project.log(pmde.toString(), Project.MSG_VERBOSE);\n\n        Throwable cause = pmde.getCause();\n\n        if (cause != null) {\n            try (StringWriter strWriter = new StringWriter();\n                 PrintWriter printWriter = new PrintWriter(strWriter)) {\n                cause.printStackTrace(printWriter);\n                project.log(strWriter.toString(), Project.MSG_VERBOSE);\n            } catch (IOException e) {\n                project.log(\"Error while closing stream\", e, Project.MSG_ERR);\n            }\n            if (StringUtils.isNotBlank(cause.getMessage())) {\n                project.log(cause.getMessage(), Project.MSG_VERBOSE);\n            }\n        }\n\n        if (failOnError) {\n            throw new BuildException(pmde);\n        }\n        errorReport.addError(new Report.ProcessingError(pmde, filename));\n    }\n\n    private void setupClassLoader() {\n        try {\n            if (auxClasspath != null) {\n                project.log(\"Using auxclasspath: \" + auxClasspath, Project.MSG_VERBOSE);\n                configuration.prependAuxClasspath(auxClasspath.toString());\n            }\n        } catch (IllegalArgumentException ioe) {\n            throw new BuildException(ioe.getMessage(), ioe);\n        }\n    }\n\n    public void execute() throws BuildException {\n        final AntLogHandler antLogHandler = new AntLogHandler(project);\n        final ScopedLogHandlersManager logManager = new ScopedLogHandlersManager(antLogHandler.getAntLogLevel(), antLogHandler);\n        try {\n            doTask();\n        } catch (BuildException e) {\n            throw e;\n        } catch (Exception other) {\n            throw new BuildException(other);\n        } finally {\n            logManager.close();\n            // only close the classloader, if it is ours. Otherwise we end up with class not found\n            // exceptions\n            if (configuration.getClassLoader() instanceof ClasspathClassLoader) {\n                IOUtil.tryCloseClassLoader(configuration.getClassLoader());\n            }\n        }\n    }\n\n    private void logRulesUsed(RuleSets rules) {\n        project.log(\"Using these rulesets: \" + configuration.getRuleSets(), Project.MSG_VERBOSE);\n\n        RuleSet[] ruleSets = rules.getAllRuleSets();\n        for (RuleSet ruleSet : ruleSets) {\n            for (Rule rule : ruleSet.getRules()) {\n                project.log(\"Using rule \" + rule.getName(), Project.MSG_VERBOSE);\n            }\n        }\n    }\n}\n",
        "filePathAfter": "pmd-core/src/main/java/net/sourceforge/pmd/ant/internal/PMDTaskImpl.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.ant.internal;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.tools.ant.AntClassLoader;\nimport org.apache.tools.ant.BuildException;\nimport org.apache.tools.ant.DirectoryScanner;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.types.FileSet;\nimport org.apache.tools.ant.types.Path;\n\nimport net.sourceforge.pmd.PMDConfiguration;\nimport net.sourceforge.pmd.PmdAnalysis;\nimport net.sourceforge.pmd.Report;\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RulePriority;\nimport net.sourceforge.pmd.RuleSet;\nimport net.sourceforge.pmd.RuleSetLoader;\nimport net.sourceforge.pmd.RuleSets;\nimport net.sourceforge.pmd.ant.Formatter;\nimport net.sourceforge.pmd.ant.PMDTask;\nimport net.sourceforge.pmd.ant.SourceLanguage;\nimport net.sourceforge.pmd.lang.LanguageRegistry;\nimport net.sourceforge.pmd.lang.LanguageVersion;\nimport net.sourceforge.pmd.renderers.AbstractRenderer;\nimport net.sourceforge.pmd.util.ClasspathClassLoader;\nimport net.sourceforge.pmd.util.IOUtil;\nimport net.sourceforge.pmd.util.datasource.DataSource;\nimport net.sourceforge.pmd.util.log.AntLogHandler;\nimport net.sourceforge.pmd.util.log.ScopedLogHandlersManager;\n\npublic class PMDTaskImpl {\n\n    private Path classpath;\n    private Path auxClasspath;\n    private final List<Formatter> formatters = new ArrayList<>();\n    private final List<FileSet> filesets = new ArrayList<>();\n    private final PMDConfiguration configuration = new PMDConfiguration();\n    private boolean failOnError;\n    private boolean failOnRuleViolation;\n    private int maxRuleViolations = 0;\n    private String failuresPropertyName;\n    private Project project;\n\n    public PMDTaskImpl(PMDTask task) {\n        configuration.setReportShortNames(task.isShortFilenames());\n        configuration.setSuppressMarker(task.getSuppressMarker());\n        this.failOnError = task.isFailOnError();\n        this.failOnRuleViolation = task.isFailOnRuleViolation();\n        this.maxRuleViolations = task.getMaxRuleViolations();\n        if (this.maxRuleViolations > 0) {\n            this.failOnRuleViolation = true;\n        }\n        configuration.setRuleSets(task.getRulesetFiles());\n        configuration.setRuleSetFactoryCompatibilityEnabled(!task.isNoRuleSetCompatibility());\n        if (task.getEncoding() != null) {\n            configuration.setSourceEncoding(task.getEncoding());\n        }\n        configuration.setThreads(task.getThreads());\n        this.failuresPropertyName = task.getFailuresPropertyName();\n        configuration.setMinimumPriority(RulePriority.valueOf(task.getMinimumPriority()));\n        configuration.setAnalysisCacheLocation(task.getCacheLocation());\n        configuration.setIgnoreIncrementalAnalysis(task.isNoCache());\n\n        SourceLanguage version = task.getSourceLanguage();\n        if (version != null) {\n            LanguageVersion languageVersion = LanguageRegistry\n                    .findLanguageVersionByTerseName(version.getName() + ' ' + version.getVersion());\n            if (languageVersion == null) {\n                throw new BuildException(\"The following language is not supported:\" + version + '.');\n            }\n            configuration.setDefaultLanguageVersion(languageVersion);\n        }\n\n        classpath = task.getClasspath();\n        auxClasspath = task.getAuxClasspath();\n\n        filesets.addAll(task.getFilesets());\n        formatters.addAll(task.getFormatters());\n\n        project = task.getProject();\n    }\n\n    private void doTask() {\n        setupClassLoader();\n\n        if (configuration.getSuppressMarker() != null) {\n            project.log(\"Setting suppress marker to be \" + configuration.getSuppressMarker(), Project.MSG_VERBOSE);\n        }\n\n\n        @SuppressWarnings(\"PMD.CloseResource\") final List<String> reportShortNamesPaths = new ArrayList<>();\n        List<String> fullInputPath = new ArrayList<>();\n\n        List<String> ruleSetPaths = expandRuleSetPaths();\n        // don't let PmdAnalysis.create create rulesets itself.\n        configuration.setRuleSets(Collections.<String>emptyList());\n\n        Report report;\n        try (PmdAnalysis pmd = PmdAnalysis.create(configuration)) {\n            RuleSetLoader rulesetLoader =\n                pmd.newRuleSetLoader().loadResourcesWith(setupResourceLoader());\n            pmd.addRuleSets(rulesetLoader.loadRuleSetsWithoutException(ruleSetPaths));\n\n            for (FileSet fileset : filesets) {\n                DirectoryScanner ds = fileset.getDirectoryScanner(project);\n                for (String srcFile : ds.getIncludedFiles()) {\n                    pmd.files().addFile(ds.getBasedir().toPath().resolve(srcFile));\n                }\n\n                final String commonInputPath = ds.getBasedir().getPath();\n                fullInputPath.add(commonInputPath);\n                if (configuration.isReportShortNames()) {\n                    reportShortNamesPaths.add(commonInputPath);\n                }\n            }\n\n            for (Formatter formatter : formatters) {\n                project.log(\"Sending a report to \" + formatter, Project.MSG_VERBOSE);\n                pmd.addRenderer(formatter.toRenderer(project, reportShortNamesPaths));\n            }\n\n            pmd.addRenderer(getLogRenderer(StringUtils.join(fullInputPath, \",\")));\n\n            report = pmd.performAnalysisAndCollectReport();\n        }\n\n        int problemCount = report.getViolations().size();\n        project.log(problemCount + \" problems found\", Project.MSG_VERBOSE);\n\n        if (failuresPropertyName != null && problemCount > 0) {\n            project.setProperty(failuresPropertyName, String.valueOf(problemCount));\n            project.log(\"Setting property \" + failuresPropertyName + \" to \" + problemCount, Project.MSG_VERBOSE);\n        }\n\n        if (failOnRuleViolation && problemCount > maxRuleViolations) {\n            throw new BuildException(\"Stopping build since PMD found \" + problemCount + \" rule violations in the code\");\n        }\n    }\n\n    private List<String> expandRuleSetPaths() {\n        List<String> paths = new ArrayList<>(configuration.getRuleSetPaths());\n        for (int i = 0; i < paths.size(); i++) {\n            paths.set(i, project.replaceProperties(paths.get(i)));\n        }\n        return paths;\n    }\n\n    private AbstractRenderer getLogRenderer(final String commonInputPath) {\n        return new AbstractRenderer(\"log\", \"Logging renderer\") {\n            @Override\n            public void start() {\n                // Nothing to do\n            }\n\n            @Override\n            public void startFileAnalysis(DataSource dataSource) {\n                project.log(\"Processing file \" + dataSource.getNiceFileName(false, commonInputPath),\n                            Project.MSG_VERBOSE);\n            }\n\n            @Override\n            public void renderFileReport(Report r) {\n                // Nothing to do\n            }\n\n            @Override\n            public void end() {\n                // Nothing to do\n            }\n\n            @Override\n            public void flush() {\n                // Nothing to do\n            }\n\n            @Override\n            public String defaultFileExtension() {\n                return null;\n            } // not relevant\n        };\n    }\n\n    private ClassLoader setupResourceLoader() {\n        if (classpath == null) {\n            classpath = new Path(project);\n        }\n\n        /*\n         * 'basedir' is added to the path to make sure that relative paths such\n         * as \"<ruleset>resources/custom_ruleset.xml</ruleset>\" still work when\n         * ant is invoked from a different directory using \"-f\"\n         */\n        classpath.add(new Path(null, project.getBaseDir().toString()));\n\n        project.log(\"Using the AntClassLoader: \" + classpath, Project.MSG_VERBOSE);\n        // must be true, otherwise you'll get ClassCastExceptions as classes\n        // are loaded twice\n        // and exist in multiple class loaders\n        final boolean parentFirst = true;\n        return new AntClassLoader(Thread.currentThread().getContextClassLoader(),\n                                  project, classpath, parentFirst);\n    }\n\n    private void handleError(String filename, Report errorReport, RuntimeException pmde) {\n\n        pmde.printStackTrace();\n        project.log(pmde.toString(), Project.MSG_VERBOSE);\n\n        Throwable cause = pmde.getCause();\n\n        if (cause != null) {\n            try (StringWriter strWriter = new StringWriter();\n                 PrintWriter printWriter = new PrintWriter(strWriter)) {\n                cause.printStackTrace(printWriter);\n                project.log(strWriter.toString(), Project.MSG_VERBOSE);\n            } catch (IOException e) {\n                project.log(\"Error while closing stream\", e, Project.MSG_ERR);\n            }\n            if (StringUtils.isNotBlank(cause.getMessage())) {\n                project.log(cause.getMessage(), Project.MSG_VERBOSE);\n            }\n        }\n\n        if (failOnError) {\n            throw new BuildException(pmde);\n        }\n        errorReport.addError(new Report.ProcessingError(pmde, filename));\n    }\n\n    private void setupClassLoader() {\n        try {\n            if (auxClasspath != null) {\n                project.log(\"Using auxclasspath: \" + auxClasspath, Project.MSG_VERBOSE);\n                configuration.prependAuxClasspath(auxClasspath.toString());\n            }\n        } catch (IllegalArgumentException ioe) {\n            throw new BuildException(ioe.getMessage(), ioe);\n        }\n    }\n\n    public void execute() throws BuildException {\n        final AntLogHandler antLogHandler = new AntLogHandler(project);\n        final ScopedLogHandlersManager logManager = new ScopedLogHandlersManager(antLogHandler.getAntLogLevel(), antLogHandler);\n        try {\n            doTask();\n        } catch (BuildException e) {\n            throw e;\n        } catch (Exception other) {\n            throw new BuildException(other);\n        } finally {\n            logManager.close();\n            // only close the classloader, if it is ours. Otherwise we end up with class not found\n            // exceptions\n            if (configuration.getClassLoader() instanceof ClasspathClassLoader) {\n                IOUtil.tryCloseClassLoader(configuration.getClassLoader());\n            }\n        }\n    }\n\n    private void logRulesUsed(RuleSets rules) {\n        project.log(\"Using these rulesets: \" + configuration.getRuleSets(), Project.MSG_VERBOSE);\n\n        RuleSet[] ruleSets = rules.getAllRuleSets();\n        for (RuleSet ruleSet : ruleSets) {\n            for (Rule rule : ruleSet.getRules()) {\n                project.log(\"Using rule \" + rule.getName(), Project.MSG_VERBOSE);\n            }\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            "private AbstractRenderer getLogRenderer(final String commonInputPath) {\n        return new AbstractRenderer(\"log\", \"Logging renderer\") {\n            @Override\n            public void start() {\n                // Nothing to do\n            }\n\n            @Override\n            public void startFileAnalysis(DataSource dataSource) {\n                project.log(\"Processing file \" + dataSource.getNiceFileName(false, commonInputPath),\n                            Project.MSG_VERBOSE);\n            }\n\n            @Override\n            public void renderFileReport(Report r) {\n                // Nothing to do\n            }\n\n            @Override\n            public void end() {\n                // Nothing to do\n            }\n\n            @Override\n            public void flush() {\n                // Nothing to do\n            }\n\n            @Override\n            public String defaultFileExtension() {\n                return null;\n            } // not relevant\n        };\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.RuleSetLoader#fromPmdConfig\n methodBody: public static RuleSetLoader fromPmdConfig(PMDConfiguration configuration) {\nreturn new RuleSetLoader().filterAbovePriority(configuration.getMinimumPriority()).enableCompatibility(configuration.isRuleSetFactoryCompatibilityEnabled());\n}",
            "methodSignature: net.sourceforge.pmd.ant.internal.PMDTaskImpl#handleError\n methodBody: private void handleError(String filename, Report errorReport, RuntimeException pmde) {\npmde.printStackTrace();\nproject.log(pmde.toString(),Project.MSG_VERBOSE);\nThrowable cause=pmde.getCause();\nif(cause != null){try(StringWriter strWriter=new StringWriter(); PrintWriter printWriter=new PrintWriter(strWriter))cause.printStackTrace(printWriter);\nproject.log(strWriter.toString(),Project.MSG_VERBOSE);\ncatch(IOException e)project.log(\"Error while closing stream\",e,Project.MSG_ERR);\nif(StringUtils.isNotBlank(cause.getMessage())){project.log(cause.getMessage(),Project.MSG_VERBOSE);\n}}if(failOnError){throw new BuildException(pmde);\n}errorReport.addError(new Report.ProcessingError(pmde,filename));\n}",
            "methodSignature: net.sourceforge.pmd.ant.Formatter#toString\n methodBody: public String toString() {\nreturn \"file = \" + toFile + \"; renderer = \" + type;\n}",
            "methodSignature: net.sourceforge.pmd.ant.internal.PMDTaskImpl#setupResourceLoader\n methodBody: private ClassLoader setupResourceLoader() {\nif(classpath == null){classpath=new Path(project);\n}classpath.add(new Path(null,project.getBaseDir().toString()));\nproject.log(\"Using the AntClassLoader: \" + classpath,Project.MSG_VERBOSE);\nfinal boolean parentFirst=true;\nreturn new AntClassLoader(Thread.currentThread().getContextClassLoader(),project,classpath,parentFirst);\n}",
            "methodSignature: net.sourceforge.pmd.ant.internal.PMDTaskImpl#logRulesUsed\n methodBody: private void logRulesUsed(RuleSets rules) {\nproject.log(\"Using these rulesets: \" + configuration.getRuleSets(),Project.MSG_VERBOSE);\nRuleSet[] ruleSets=rules.getAllRuleSets();\nfor(RuleSet ruleSet: ruleSets){for(Rule rule: ruleSet.getRules()){project.log(\"Using rule \" + rule.getName(),Project.MSG_VERBOSE);\n}}}",
            "methodSignature: net.sourceforge.pmd.ant.Formatter#getRenderer\n methodBody: public Renderer getRenderer() {\nreturn renderer;\n}",
            "methodSignature: net.sourceforge.pmd.ant.internal.PMDTaskImpl#setupClassLoader\n methodBody: private void setupClassLoader() {\ntryif(auxClasspath != null){project.log(\"Using auxclasspath: \" + auxClasspath,Project.MSG_VERBOSE);\nconfiguration.prependAuxClasspath(auxClasspath.toString());\n}catch(IllegalArgumentException ioe)throw new BuildException(ioe.getMessage(),ioe);\n}",
            "methodSignature: net.sourceforge.pmd.RuleSetLoader#toFactory\n methodBody: public RuleSetFactory toFactory() {\nreturn new RuleSetFactory(this.resourceLoader,this.minimumPriority,this.warnDeprecated,this.enableCompatibility,this.includeDeprecatedRuleReferences);\n}",
            "methodSignature: net.sourceforge.pmd.RuleSetLoader#loadResourcesWith\n methodBody: RuleSetLoader loadResourcesWith(ResourceLoader loader) {\nthis.resourceLoader=loader;\nreturn this;\n}",
            "methodSignature: net.sourceforge.pmd.ant.Formatter#start\n methodBody: public void start(String baseDir) {\nProperties properties=createProperties();\nCharset charset;\n{String s=(String)properties.get(\"encoding\");\nif(null == s){if(toConsole){s=getConsoleEncoding();\nif(null == s){s=System.getProperty(\"file.encoding\");\n}}if(null == s){charset=StandardCharsets.UTF_8;\n}{charset=Charset.forName(s);\n}final Parameter parameter=new Parameter();\nparameter.setName(\"encoding\");\nparameter.setValue(charset.name());\nparameters.add(parameter);\n}{charset=Charset.forName(s);\n}}tryif(toConsole){writer=new BufferedWriter(new OutputStreamWriter(System.out,charset));\n}if(toFile != null){writer=getToFileWriter(baseDir,toFile,charset);\n}renderer=createRenderer();\nrenderer.setWriter(writer);\nrenderer.start();\ncatch(IOException ioe)throw new BuildException(ioe.getMessage(),ioe);\n}",
            "methodSignature: net.sourceforge.pmd.ant.Formatter#end\n methodBody: public void end(Report errorReport) {\ntryrenderer.renderFileReport(errorReport);\nrenderer.end();\nif(toConsole){writer.flush();\n}{writer.close();\n}catch(IOException ioe)throw new BuildException(ioe.getMessage(),ioe);\n}"
        ],
        "sourceCodeAfterRefactoring": "private void doTask() {\n        setupClassLoader();\n\n        if (configuration.getSuppressMarker() != null) {\n            project.log(\"Setting suppress marker to be \" + configuration.getSuppressMarker(), Project.MSG_VERBOSE);\n        }\n\n\n        @SuppressWarnings(\"PMD.CloseResource\") final List<String> reportShortNamesPaths = new ArrayList<>();\n        List<String> fullInputPath = new ArrayList<>();\n\n        List<String> ruleSetPaths = expandRuleSetPaths();\n        // don't let PmdAnalysis.create create rulesets itself.\n        configuration.setRuleSets(Collections.<String>emptyList());\n\n        Report report;\n        try (PmdAnalysis pmd = PmdAnalysis.create(configuration)) {\n            RuleSetLoader rulesetLoader =\n                pmd.newRuleSetLoader().loadResourcesWith(setupResourceLoader());\n            pmd.addRuleSets(rulesetLoader.loadRuleSetsWithoutException(ruleSetPaths));\n\n            for (FileSet fileset : filesets) {\n                DirectoryScanner ds = fileset.getDirectoryScanner(project);\n                for (String srcFile : ds.getIncludedFiles()) {\n                    pmd.files().addFile(ds.getBasedir().toPath().resolve(srcFile));\n                }\n\n                final String commonInputPath = ds.getBasedir().getPath();\n                fullInputPath.add(commonInputPath);\n                if (configuration.isReportShortNames()) {\n                    reportShortNamesPaths.add(commonInputPath);\n                }\n            }\n\n            for (Formatter formatter : formatters) {\n                project.log(\"Sending a report to \" + formatter, Project.MSG_VERBOSE);\n                pmd.addRenderer(formatter.toRenderer(project, reportShortNamesPaths));\n            }\n\n            pmd.addRenderer(getLogRenderer(StringUtils.join(fullInputPath, \",\")));\n\n            report = pmd.performAnalysisAndCollectReport();\n        }\n\n        int problemCount = report.getViolations().size();\n        project.log(problemCount + \" problems found\", Project.MSG_VERBOSE);\n\n        if (failuresPropertyName != null && problemCount > 0) {\n            project.setProperty(failuresPropertyName, String.valueOf(problemCount));\n            project.log(\"Setting property \" + failuresPropertyName + \" to \" + problemCount, Project.MSG_VERBOSE);\n        }\n\n        if (failOnRuleViolation && problemCount > maxRuleViolations) {\n            throw new BuildException(\"Stopping build since PMD found \" + problemCount + \" rule violations in the code\");\n        }\n    }\nprivate AbstractRenderer getLogRenderer(final String commonInputPath) {\n        return new AbstractRenderer(\"log\", \"Logging renderer\") {\n            @Override\n            public void start() {\n                // Nothing to do\n            }\n\n            @Override\n            public void startFileAnalysis(DataSource dataSource) {\n                project.log(\"Processing file \" + dataSource.getNiceFileName(false, commonInputPath),\n                            Project.MSG_VERBOSE);\n            }\n\n            @Override\n            public void renderFileReport(Report r) {\n                // Nothing to do\n            }\n\n            @Override\n            public void end() {\n                // Nothing to do\n            }\n\n            @Override\n            public void flush() {\n                // Nothing to do\n            }\n\n            @Override\n            public String defaultFileExtension() {\n                return null;\n            } // not relevant\n        };\n    }",
        "diffSourceCode": "-   94:         filesets.addAll(task.getFilesets());\n-   95:         formatters.addAll(task.getFormatters());\n+   94:     private void doTask() {\n+   95:         setupClassLoader();\n    96: \n-   97:         project = task.getProject();\n-   98:     }\n-   99: \n-  100:     private void doTask() {\n-  101:         setupClassLoader();\n-  102: \n-  103:         // Setup RuleSetFactory and validate RuleSets\n-  104:         RuleSetLoader rulesetLoader = RuleSetLoader.fromPmdConfig(configuration)\n-  105:                                                    .loadResourcesWith(setupResourceLoader());\n-  106: \n-  107:         // This is just used to validate and display rules. Each thread will create its own ruleset\n-  108:         String ruleSetString = configuration.getRuleSets();\n-  109:         if (StringUtils.isNotBlank(ruleSetString)) {\n-  110:             // Substitute env variables/properties\n-  111:             configuration.setRuleSets(project.replaceProperties(ruleSetString));\n-  112:         }\n-  113: \n-  114:         final RuleSets ruleSets = RulesetsFactoryUtils.getRuleSets(configuration.getRuleSets(), rulesetLoader.toFactory());\n-  115:         List<RuleSet> rulesetList = Arrays.asList(ruleSets.getAllRuleSets());\n-  116:         logRulesUsed(ruleSets);\n-  117: \n-  118:         if (configuration.getSuppressMarker() != null) {\n-  119:             project.log(\"Setting suppress marker to be \" + configuration.getSuppressMarker(), Project.MSG_VERBOSE);\n-  120:         }\n-  121: \n-  122:         // Start the Formatters\n-  123:         for (Formatter formatter : formatters) {\n-  124:             project.log(\"Sending a report to \" + formatter, Project.MSG_VERBOSE);\n-  125:             formatter.start(project.getBaseDir().toString());\n-  126:         }\n+   97:         if (configuration.getSuppressMarker() != null) {\n+   98:             project.log(\"Setting suppress marker to be \" + configuration.getSuppressMarker(), Project.MSG_VERBOSE);\n+   99:         }\n+  100: \n+  101: \n+  102:         @SuppressWarnings(\"PMD.CloseResource\") final List<String> reportShortNamesPaths = new ArrayList<>();\n+  103:         List<String> fullInputPath = new ArrayList<>();\n+  104: \n+  105:         List<String> ruleSetPaths = expandRuleSetPaths();\n+  106:         // don't let PmdAnalysis.create create rulesets itself.\n+  107:         configuration.setRuleSets(Collections.<String>emptyList());\n+  108: \n+  109:         Report report;\n+  110:         try (PmdAnalysis pmd = PmdAnalysis.create(configuration)) {\n+  111:             RuleSetLoader rulesetLoader =\n+  112:                 pmd.newRuleSetLoader().loadResourcesWith(setupResourceLoader());\n+  113:             pmd.addRuleSets(rulesetLoader.loadRuleSetsWithoutException(ruleSetPaths));\n+  114: \n+  115:             for (FileSet fileset : filesets) {\n+  116:                 DirectoryScanner ds = fileset.getDirectoryScanner(project);\n+  117:                 for (String srcFile : ds.getIncludedFiles()) {\n+  118:                     pmd.files().addFile(ds.getBasedir().toPath().resolve(srcFile));\n+  119:                 }\n+  120: \n+  121:                 final String commonInputPath = ds.getBasedir().getPath();\n+  122:                 fullInputPath.add(commonInputPath);\n+  123:                 if (configuration.isReportShortNames()) {\n+  124:                     reportShortNamesPaths.add(commonInputPath);\n+  125:                 }\n+  126:             }\n   127: \n-  128:         // log(\"Setting Language Version \" + languageVersion.getShortName(),\n-  129:         // Project.MSG_VERBOSE);\n-  130: \n-  131:         // TODO Do we really need all this in a loop over each FileSet? Seems\n-  132:         // like a lot of redundancy\n-  133:         Report errorReport = new Report();\n-  134:         int problemCount = 0;\n-  135:         final String separator = System.getProperty(\"file.separator\");\n-  136: \n-  137:         for (FileSet fs : filesets) {\n-  138:             List<DataSource> files = new LinkedList<>();\n-  139:             DirectoryScanner ds = fs.getDirectoryScanner(project);\n-  140:             String[] srcFiles = ds.getIncludedFiles();\n-  141:             for (String srcFile : srcFiles) {\n-  142:                 File file = new File(ds.getBasedir() + separator + srcFile);\n-  143:                 files.add(new FileDataSource(file));\n-  144:             }\n+  128:             for (Formatter formatter : formatters) {\n+  129:                 project.log(\"Sending a report to \" + formatter, Project.MSG_VERBOSE);\n+  130:                 pmd.addRenderer(formatter.toRenderer(project, reportShortNamesPaths));\n+  131:             }\n+  132: \n+  133:             pmd.addRenderer(getLogRenderer(StringUtils.join(fullInputPath, \",\")));\n+  134: \n+  135:             report = pmd.performAnalysisAndCollectReport();\n+  136:         }\n+  137: \n+  138:         int problemCount = report.getViolations().size();\n+  139:         project.log(problemCount + \" problems found\", Project.MSG_VERBOSE);\n+  140: \n+  141:         if (failuresPropertyName != null && problemCount > 0) {\n+  142:             project.setProperty(failuresPropertyName, String.valueOf(problemCount));\n+  143:             project.log(\"Setting property \" + failuresPropertyName + \" to \" + problemCount, Project.MSG_VERBOSE);\n+  144:         }\n   145: \n-  146:             final String commonInputPath = ds.getBasedir().getPath();\n-  147:             configuration.setInputPaths(commonInputPath);\n-  148:             final List<String> reportShortNamesPaths = new ArrayList<>();\n-  149:             if (configuration.isReportShortNames()) {\n-  150:                 reportShortNamesPaths.add(commonInputPath);\n-  151:             }\n-  152: \n-  153:             Renderer logRenderer = new AbstractRenderer(\"log\", \"Logging renderer\") {\n-  154:                 @Override\n-  155:                 public void start() {\n-  156:                     // Nothing to do\n-  157:                 }\n+  146:         if (failOnRuleViolation && problemCount > maxRuleViolations) {\n+  147:             throw new BuildException(\"Stopping build since PMD found \" + problemCount + \" rule violations in the code\");\n+  148:         }\n+  149:     }\n+  150: \n+  151:     private List<String> expandRuleSetPaths() {\n+  152:         List<String> paths = new ArrayList<>(configuration.getRuleSetPaths());\n+  153:         for (int i = 0; i < paths.size(); i++) {\n+  154:             paths.set(i, project.replaceProperties(paths.get(i)));\n+  155:         }\n+  156:         return paths;\n+  157:     }\n   158: \n-  159:                 @Override\n-  160:                 public void startFileAnalysis(DataSource dataSource) {\n-  161:                     project.log(\"Processing file \" + dataSource.getNiceFileName(false, commonInputPath),\n-  162:                             Project.MSG_VERBOSE);\n-  163:                 }\n-  164: \n-  165:                 @Override\n-  166:                 public void renderFileReport(Report r) {\n-  167:                     // Nothing to do\n-  168:                 }\n-  169: \n-  170:                 @Override\n-  171:                 public void end() {\n-  172:                     // Nothing to do\n-  173:                 }\n-  174: \n-  175:                 @Override\n-  176:                 public String defaultFileExtension() {\n-  177:                     return null;\n-  178:                 } // not relevant\n-  179:             };\n-  180:             List<Renderer> renderers = new ArrayList<>(formatters.size() + 1);\n-  181:             renderers.add(logRenderer);\n-  182:             for (Formatter formatter : formatters) {\n-  183:                 Renderer renderer = formatter.getRenderer();\n-  184:                 renderer.setUseShortNames(reportShortNamesPaths);\n-  185:                 renderers.add(renderer);\n-  186:             }\n-  187:             try {\n-  188:                 Report report = PMD.processFiles(configuration, rulesetList, files, renderers);\n-  189:                 problemCount += report.getViolations().size();\n-  190:             } catch (ContextedRuntimeException e) {\n-  191:                 if (e.getFirstContextValue(\"filename\") instanceof String) {\n-  192:                     handleError((String) e.getFirstContextValue(\"filename\"), errorReport, e);\n-  193:                 } else {\n-  194:                     handleError(\"(unknown file)\", errorReport, e);\n-  195:                 }\n-  196:             } catch (RuntimeException pmde) {\n-  197:                 handleError(\"(unknown file)\", errorReport, pmde);\n-  198:             }\n-  199:         }\n-  200: \n-  201:         project.log(problemCount + \" problems found\", Project.MSG_VERBOSE);\n-  202: \n-  203:         for (Formatter formatter : formatters) {\n-  204:             formatter.end(errorReport);\n-  205:         }\n-  206: \n-  207:         if (failuresPropertyName != null && problemCount > 0) {\n-  208:             project.setProperty(failuresPropertyName, String.valueOf(problemCount));\n-  209:             project.log(\"Setting property \" + failuresPropertyName + \" to \" + problemCount, Project.MSG_VERBOSE);\n-  210:         }\n-  211: \n-  212:         if (failOnRuleViolation && problemCount > maxRuleViolations) {\n-  213:             throw new BuildException(\"Stopping build since PMD found \" + problemCount + \" rule violations in the code\");\n-  214:         }\n-  215:     }\n+  159:     private AbstractRenderer getLogRenderer(final String commonInputPath) {\n+  160:         return new AbstractRenderer(\"log\", \"Logging renderer\") {\n+  161:             @Override\n+  162:             public void start() {\n+  163:                 // Nothing to do\n+  164:             }\n+  165: \n+  166:             @Override\n+  167:             public void startFileAnalysis(DataSource dataSource) {\n+  168:                 project.log(\"Processing file \" + dataSource.getNiceFileName(false, commonInputPath),\n+  169:                             Project.MSG_VERBOSE);\n+  170:             }\n+  171: \n+  172:             @Override\n+  173:             public void renderFileReport(Report r) {\n+  174:                 // Nothing to do\n+  175:             }\n+  176: \n+  177:             @Override\n+  178:             public void end() {\n+  179:                 // Nothing to do\n+  180:             }\n+  181: \n+  182:             @Override\n+  183:             public void flush() {\n+  184:                 // Nothing to do\n+  185:             }\n+  186: \n+  187:             @Override\n+  188:             public String defaultFileExtension() {\n+  189:                 return null;\n+  190:             } // not relevant\n+  191:         };\n+  192:     }\n+  193: \n+  194:     private ClassLoader setupResourceLoader() {\n+  195:         if (classpath == null) {\n+  196:             classpath = new Path(project);\n+  197:         }\n+  198: \n+  199:         /*\n+  200:          * 'basedir' is added to the path to make sure that relative paths such\n+  201:          * as \"<ruleset>resources/custom_ruleset.xml</ruleset>\" still work when\n+  202:          * ant is invoked from a different directory using \"-f\"\n+  203:          */\n+  204:         classpath.add(new Path(null, project.getBaseDir().toString()));\n+  205: \n+  206:         project.log(\"Using the AntClassLoader: \" + classpath, Project.MSG_VERBOSE);\n+  207:         // must be true, otherwise you'll get ClassCastExceptions as classes\n+  208:         // are loaded twice\n+  209:         // and exist in multiple class loaders\n+  210:         final boolean parentFirst = true;\n+  211:         return new AntClassLoader(Thread.currentThread().getContextClassLoader(),\n+  212:                                   project, classpath, parentFirst);\n+  213:     }\n+  214: \n+  215:     private void handleError(String filename, Report errorReport, RuntimeException pmde) {\n",
        "uniqueId": "5dc2774c0a53810717358cc850b69c6e7fe0a463_100_215_159_192_94_149",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 53,
                "covered": 128
            },
            "BRANCH": {
                "missed": 10,
                "covered": 8
            },
            "LINE": {
                "missed": 4,
                "covered": 24
            },
            "COMPLEXITY": {
                "missed": 7,
                "covered": 3
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Move Method",
        "description": "Move Method\tpublic isCloneMethod(node ASTMethodDeclaration) : boolean from class net.sourceforge.pmd.lang.java.rule.internal.JavaAstUtil to public isCloneMethod(node ASTMethodDeclaration) : boolean from class net.sourceforge.pmd.lang.java.rule.internal.JavaRuleUtil",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/internal/JavaAstUtil.java",
                "startLine": 655,
                "endLine": 661,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/internal/JavaRuleUtil.java",
                "startLine": 994,
                "endLine": 1000,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public static boolean isCloneMethod(ASTMethodDeclaration node) {\n        // this is enough as in valid code, this signature overrides Object#clone\n        // and the other things like visibility are checked by the compiler\n        return \"clone\".equals(node.getName())\n            && node.getArity() == 0\n            && !node.isStatic();\n    }",
        "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/internal/JavaAstUtil.java",
        "isPureRefactoring": true,
        "commitId": "9cae6e08c6191721a9938a70810777082b7b5d66",
        "packageNameBefore": "net.sourceforge.pmd.lang.java.rule.internal",
        "classNameBefore": "net.sourceforge.pmd.lang.java.rule.internal.JavaAstUtil",
        "methodNameBefore": "net.sourceforge.pmd.lang.java.rule.internal.JavaAstUtil#isCloneMethod",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.java.rule.internal.DataflowPass.AssignmentEntry#equals\n methodBody: public boolean equals(Object o) {\nif(this == o){return true;\n}if(o == null || getClass() != o.getClass()){return false;\n}AssignmentEntry that=(AssignmentEntry)o;\nreturn Objects.equals(var,that.var) && Objects.equals(rhs,that.rhs);\n}",
        "classSignatureBefore": "public final class JavaAstUtil ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.rule.internal.JavaAstUtil#isCloneMethod"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.rule.internal.JavaAstUtil"
        ],
        "classSignatureBeforeSet": [
            "public final class JavaAstUtil "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.rule.internal;\n\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport net.sourceforge.pmd.lang.ast.GenericToken;\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.ast.NodeStream;\nimport net.sourceforge.pmd.lang.ast.impl.javacc.JavaccToken;\nimport net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTArgumentList;\nimport net.sourceforge.pmd.lang.java.ast.ASTArrayAllocation;\nimport net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr.ASTNamedReferenceExpr;\nimport net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr.AccessType;\nimport net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTBooleanLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTCastExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType;\nimport net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;\nimport net.sourceforge.pmd.lang.java.ast.ASTExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTFieldAccess;\nimport net.sourceforge.pmd.lang.java.ast.ASTForStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;\nimport net.sourceforge.pmd.lang.java.ast.ASTFormalParameters;\nimport net.sourceforge.pmd.lang.java.ast.ASTInfixExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTLabeledStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTList;\nimport net.sourceforge.pmd.lang.java.ast.ASTLocalVariableDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTMethodOrConstructorDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTNullLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTNumericLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTSuperExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTThisExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTUnaryExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;\nimport net.sourceforge.pmd.lang.java.ast.Annotatable;\nimport net.sourceforge.pmd.lang.java.ast.BinaryOp;\nimport net.sourceforge.pmd.lang.java.ast.JavaNode;\nimport net.sourceforge.pmd.lang.java.ast.JavaTokenKinds;\nimport net.sourceforge.pmd.lang.java.ast.QualifiableExpression;\nimport net.sourceforge.pmd.lang.java.ast.TypeNode;\nimport net.sourceforge.pmd.lang.java.ast.UnaryOp;\nimport net.sourceforge.pmd.lang.java.symbols.JFieldSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.internal.ast.AstLocalVarSym;\nimport net.sourceforge.pmd.lang.java.types.JPrimitiveType.PrimitiveTypeKind;\nimport net.sourceforge.pmd.lang.java.types.JTypeMirror;\nimport net.sourceforge.pmd.lang.java.types.TypeTestUtil;\nimport net.sourceforge.pmd.util.OptionalBool;\n\n/**\n * Utilities shared between rules.\n */\npublic final class JavaAstUtil {\n\n\n    private JavaAstUtil() {\n        // utility class\n    }\n\n    /**\n     * Return true if the given expression is enclosed in a zero check.\n     * The expression must evaluate to a natural number (ie >= 0), so that\n     * {@code e < 1} actually means {@code e == 0}.\n     *\n     * @param e Expression\n     */\n    public static boolean isZeroChecked(ASTExpression e) {\n        JavaNode parent = e.getParent();\n        if (parent instanceof ASTInfixExpression) {\n            BinaryOp op = ((ASTInfixExpression) parent).getOperator();\n            int checkLiteralAtIdx = 1 - e.getIndexInParent();\n            JavaNode comparand = parent.getChild(checkLiteralAtIdx);\n            int expectedValue;\n            if (op == BinaryOp.NE || op == BinaryOp.EQ) {\n                // e == 0, e != 0, symmetric\n                expectedValue = 0;\n            } else if (op == BinaryOp.LT || op == BinaryOp.GE) {\n                // e < 1\n                // 0 < e\n                // e >= 1     (e != 0)\n                // 1 >= e     (e == 0 || e == 1)\n                // 0 >= e     (e == 0)\n                // e >= 0     (true)\n                expectedValue = checkLiteralAtIdx;\n            } else if (op == BinaryOp.GT || op == BinaryOp.LE) {\n                // 1 > e\n                // e > 0\n\n                // 1 <= e     (e != 0)\n                // e <= 1     (e == 0 || e == 1)\n                // e <= 0     (e == 0)\n                // 0 <= e     (true)\n                expectedValue = 1 - checkLiteralAtIdx;\n            } else {\n                return false;\n            }\n\n            return isLiteralInt(comparand, expectedValue);\n        }\n        return false;\n    }\n\n    /**\n     * Returns true if this is a numeric literal with the given int value.\n     * This also considers long literals.\n     */\n    public static boolean isLiteralInt(JavaNode e, int value) {\n        return e instanceof ASTNumericLiteral\n                && ((ASTNumericLiteral) e).isIntegral()\n                && ((ASTNumericLiteral) e).getValueAsInt() == value;\n    }\n\n    /** This is type-aware, so will not pick up on numeric addition. */\n    public static boolean isStringConcatExpr(@Nullable JavaNode e) {\n        if (e instanceof ASTInfixExpression) {\n            ASTInfixExpression infix = (ASTInfixExpression) e;\n            return infix.getOperator() == BinaryOp.ADD && TypeTestUtil.isA(String.class, infix);\n        }\n        return false;\n    }\n\n    /**\n     * If the parameter is an operand of a binary infix expression,\n     * returns the other operand. Otherwise returns null.\n     */\n    public static @Nullable ASTExpression getOtherOperandIfInInfixExpr(@Nullable JavaNode e) {\n        if (e != null && e.getParent() instanceof ASTInfixExpression) {\n            return (ASTExpression) e.getParent().getChild(1 - e.getIndexInParent());\n        }\n        return null;\n    }\n\n    public static @Nullable ASTExpression getOtherOperandIfInAssignmentExpr(@Nullable JavaNode e) {\n        if (e != null && e.getParent() instanceof ASTAssignmentExpression) {\n            return (ASTExpression) e.getParent().getChild(1 - e.getIndexInParent());\n        }\n        return null;\n    }\n\n    /**\n     * Returns true if the node is a {@link ASTMethodDeclaration} that\n     * is a main method.\n     */\n    public static boolean isMainMethod(JavaNode node) {\n        return node instanceof ASTMethodDeclaration\n                && ((ASTMethodDeclaration) node).isMainMethod();\n    }\n\n\n\n    static boolean hasField(ASTAnyTypeDeclaration node, String name) {\n        for (JFieldSymbol f : node.getSymbol().getDeclaredFields()) {\n            String fname = f.getSimpleName();\n            if (fname.startsWith(\"m_\") || fname.startsWith(\"_\")) {\n                fname = fname.substring(fname.indexOf('_') + 1);\n            }\n            if (fname.equalsIgnoreCase(name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns true if the formal parameters of the method or constructor\n     * match the given types exactly. Note that for varargs methods, the\n     * last param must have an array type (but it is not checked to be varargs).\n     * This will return false if we're not sure.\n     *\n     * @param node  Method or ctor\n     * @param types List of types to match (may be empty)\n     *\n     * @throws NullPointerException If any of the classes is null, or the node is null\n     * @see TypeTestUtil#isExactlyA(Class, TypeNode)\n     */\n    public static boolean hasParameters(ASTMethodOrConstructorDeclaration node, Class<?>... types) {\n        ASTFormalParameters formals = node.getFormalParameters();\n        if (formals.size() != types.length) {\n            return false;\n        }\n        for (int i = 0; i < formals.size(); i++) {\n            ASTFormalParameter fi = formals.get(i);\n            if (!TypeTestUtil.isExactlyA(types[i], fi)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns true if the {@code throws} declaration of the method or constructor\n     * matches the given types exactly.\n     *\n     * @param node  Method or ctor\n     * @param types List of exception types to match (may be empty)\n     *\n     * @throws NullPointerException If any of the classes is null, or the node is null\n     * @see TypeTestUtil#isExactlyA(Class, TypeNode)\n     */\n    @SafeVarargs\n    public static boolean hasExceptionList(ASTMethodOrConstructorDeclaration node, Class<? extends Throwable>... types) {\n        @NonNull List<ASTClassOrInterfaceType> formals = ASTList.orEmpty(node.getThrowsList());\n        if (formals.size() != types.length) {\n            return false;\n        }\n        for (int i = 0; i < formals.size(); i++) {\n            ASTClassOrInterfaceType fi = formals.get(i);\n            if (!TypeTestUtil.isExactlyA(types[i], fi)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * True if the variable is incremented or decremented via a compound\n     * assignment operator, or a unary increment/decrement expression.\n     */\n    public static boolean isVarAccessReadAndWrite(ASTNamedReferenceExpr expr) {\n        return expr.getAccessType() == AccessType.WRITE\n            && (!(expr.getParent() instanceof ASTAssignmentExpression)\n            || ((ASTAssignmentExpression) expr.getParent()).getOperator().isCompound());\n    }\n\n    /**\n     * True if the variable access is a non-compound assignment.\n     */\n    public static boolean isVarAccessStrictlyWrite(ASTNamedReferenceExpr expr) {\n        return expr.getParent() instanceof ASTAssignmentExpression\n            && expr.getIndexInParent() == 0\n            && !((ASTAssignmentExpression) expr.getParent()).getOperator().isCompound();\n    }\n\n    /**\n     * Returns the set of labels on this statement.\n     */\n    public static Set<String> getStatementLabels(ASTStatement node) {\n        if (!(node.getParent() instanceof ASTLabeledStatement)) {\n            return Collections.emptySet();\n        }\n\n        return node.ancestors().takeWhile(it -> it instanceof ASTLabeledStatement)\n                   .toStream()\n                   .map(it -> ((ASTLabeledStatement) it).getLabel())\n                   .collect(Collectors.toSet());\n    }\n\n    public static boolean isAnonymousClassCreation(@Nullable ASTExpression expression) {\n        return expression instanceof ASTConstructorCall\n                && ((ASTConstructorCall) expression).isAnonymousClass();\n    }\n\n    /**\n     * Will cut through argument lists, except those of enum constants\n     * and explicit invocation nodes.\n     */\n    public static @NonNull ASTExpression getTopLevelExpr(ASTExpression expr) {\n        return (ASTExpression) expr.ancestorsOrSelf()\n                                   .takeWhile(it -> it instanceof ASTExpression\n                                       || it instanceof ASTArgumentList && it.getParent() instanceof ASTExpression)\n                                   .last();\n    }\n\n    /**\n     * Returns the variable IDS corresponding to variables declared in\n     * the init clause of the loop.\n     */\n    public static NodeStream<ASTVariableDeclaratorId> getLoopVariables(ASTForStatement loop) {\n        return NodeStream.of(loop.getInit())\n                         .filterIs(ASTLocalVariableDeclaration.class)\n                         .flatMap(ASTLocalVariableDeclaration::getVarIds);\n    }\n\n    /**\n     * Whether one expression is the boolean negation of the other. Many\n     * forms are not yet supported. This method is symmetric so only needs\n     * to be called once.\n     */\n    public static boolean areComplements(ASTExpression e1, ASTExpression e2) {\n        if (isBooleanNegation(e1)) {\n            return areEqual(unaryOperand(e1), e2);\n        } else if (isBooleanNegation(e2)) {\n            return areEqual(e1, unaryOperand(e2));\n        } else if (e1 instanceof ASTInfixExpression && e2 instanceof ASTInfixExpression) {\n            ASTInfixExpression ifx1 = (ASTInfixExpression) e1;\n            ASTInfixExpression ifx2 = (ASTInfixExpression) e2;\n            if (ifx1.getOperator().getComplement() != ifx2.getOperator()) {\n                return false;\n            }\n            if (ifx1.getOperator().hasSamePrecedenceAs(BinaryOp.EQ)) {\n                // NOT(a == b, a != b)\n                // NOT(a == b, b != a)\n                return areEqual(ifx1.getLeftOperand(), ifx2.getLeftOperand())\n                    && areEqual(ifx1.getRightOperand(), ifx2.getRightOperand())\n                    || areEqual(ifx2.getLeftOperand(), ifx1.getLeftOperand())\n                    && areEqual(ifx2.getRightOperand(), ifx1.getRightOperand());\n            }\n            // todo we could continue with de Morgan and such\n        }\n        return false;\n    }\n\n    private static boolean areEqual(ASTExpression e1, ASTExpression e2) {\n        return tokenEquals(e1, e2);\n    }\n\n    /**\n     * Returns true if both nodes have exactly the same tokens.\n     *\n     * @param node First node\n     * @param that Other node\n     */\n    public static boolean tokenEquals(JavaNode node, JavaNode that) {\n        return tokenEquals(node, that, null);\n    }\n\n    /**\n     * Returns true if both nodes have the same tokens, modulo some renaming\n     * function. The renaming function maps unqualified variables and type\n     * identifiers of the first node to the other. This should be used\n     * in nodes living in the same lexical scope, so that unqualified\n     * names mean the same thing.\n     *\n     * @param node       First node\n     * @param other      Other node\n     * @param varRenamer A renaming function. If null, no renaming is applied.\n     *                   Must not return null, if no renaming occurs, returns its argument.\n     */\n    public static boolean tokenEquals(@NonNull JavaNode node,\n                                      @NonNull JavaNode other,\n                                      @Nullable Function<String, @NonNull String> varRenamer) {\n        // Since type and variable names obscure one another,\n        // it's ok to use a single renaming function.\n\n        Iterator<JavaccToken> thisIt = GenericToken.range(node.getFirstToken(), node.getLastToken());\n        Iterator<JavaccToken> thatIt = GenericToken.range(other.getFirstToken(), other.getLastToken());\n        int lastKind = 0;\n        while (thisIt.hasNext()) {\n            if (!thatIt.hasNext()) {\n                return false;\n            }\n            JavaccToken o1 = thisIt.next();\n            JavaccToken o2 = thatIt.next();\n            if (o1.kind != o2.kind) {\n                return false;\n            }\n\n            String mappedImage = o1.getImage();\n            if (varRenamer != null\n                && o1.kind == JavaTokenKinds.IDENTIFIER\n                && lastKind != JavaTokenKinds.DOT\n                && lastKind != JavaTokenKinds.METHOD_REF\n                //method name\n                && o1.getNext() != null && o1.getNext().kind != JavaTokenKinds.LPAREN) {\n                mappedImage = varRenamer.apply(mappedImage);\n            }\n\n            if (!o2.getImage().equals(mappedImage)) {\n                return false;\n            }\n\n            lastKind = o1.kind;\n        }\n        return !thatIt.hasNext();\n    }\n\n    public static boolean isNullLiteral(ASTExpression node) {\n        return node instanceof ASTNullLiteral;\n    }\n\n    /** Returns true if the node is a boolean literal with any value. */\n    public static boolean isBooleanLiteral(JavaNode e) {\n        return e instanceof ASTBooleanLiteral;\n    }\n\n    /** Returns true if the node is a boolean literal with the given constant value. */\n    public static boolean isBooleanLiteral(JavaNode e, boolean value) {\n        return e instanceof ASTBooleanLiteral && ((ASTBooleanLiteral) e).isTrue() == value;\n    }\n\n    public static boolean isBooleanNegation(JavaNode e) {\n        return e instanceof ASTUnaryExpression && ((ASTUnaryExpression) e).getOperator() == UnaryOp.NEGATION;\n    }\n\n    /**\n     * If the argument is a unary expression, returns its operand, otherwise\n     * returns null.\n     */\n    public static @Nullable ASTExpression unaryOperand(@Nullable ASTExpression e) {\n        return e instanceof ASTUnaryExpression ? ((ASTUnaryExpression) e).getOperand()\n                                               : null;\n    }\n\n    /**\n     * Whether the expression is an access to a field of this instance,\n     * not inherited, qualified or not ({@code this.field} or just {@code field}).\n     */\n    public static boolean isThisFieldAccess(ASTExpression e) {\n        if (!(e instanceof ASTNamedReferenceExpr)) {\n            return false;\n        }\n        JVariableSymbol sym = ((ASTNamedReferenceExpr) e).getReferencedSym();\n        return sym instanceof JFieldSymbol\n                && !((JFieldSymbol) sym).isStatic()\n                // not inherited\n                && ((JFieldSymbol) sym).getEnclosingClass().equals(e.getEnclosingType().getSymbol())\n                // correct syntactic form\n                && (e instanceof ASTVariableAccess || isSyntacticThisFieldAccess(e));\n    }\n\n    /**\n     * Whether the expression is a {@code this.field}, with no outer\n     * instance qualifier ({@code Outer.this.field}). The field symbol\n     * is not checked to resolve to a field declared in this class (it\n     * may be inherited)\n     */\n    public static boolean isSyntacticThisFieldAccess(ASTExpression e) {\n        if (e instanceof ASTFieldAccess) {\n            ASTExpression qualifier = ((ASTFieldAccess) e).getQualifier();\n            if (qualifier instanceof ASTThisExpression) {\n                // unqualified this\n                return ((ASTThisExpression) qualifier).getQualifier() == null;\n            }\n        }\n        return false;\n    }\n\n    public static boolean hasAnyAnnotation(Annotatable node, Collection<String> qualifiedNames) {\n        return qualifiedNames.stream().anyMatch(node::isAnnotationPresent);\n    }\n\n    /**\n     * Returns true if the expression is the default field value for\n     * the given type.\n     */\n    public static boolean isDefaultValue(JTypeMirror type, ASTExpression expr) {\n        if (type.isPrimitive()) {\n            if (type.isPrimitive(PrimitiveTypeKind.BOOLEAN)) {\n                return expr instanceof ASTBooleanLiteral && !((ASTBooleanLiteral) expr).isTrue();\n            } else {\n                Object constValue = expr.getConstValue();\n                return constValue instanceof Number && ((Number) constValue).doubleValue() == 0d\n                    || constValue instanceof Character && constValue.equals('\\u0000');\n            }\n        } else {\n            return expr instanceof ASTNullLiteral;\n        }\n    }\n\n    /**\n     * Returns true if the expression is a {@link ASTNamedReferenceExpr}\n     * that references the symbol.\n     */\n    public static boolean isReferenceToVar(@Nullable ASTExpression expression, @NonNull JVariableSymbol symbol) {\n        return expression instanceof ASTNamedReferenceExpr\n                && symbol.equals(((ASTNamedReferenceExpr) expression).getReferencedSym());\n    }\n\n    public static boolean isUnqualifiedThis(ASTExpression e) {\n        return e instanceof ASTThisExpression && ((ASTThisExpression) e).getQualifier() == null;\n    }\n\n    public static boolean isUnqualifiedSuper(ASTExpression e) {\n        return e instanceof ASTSuperExpression && ((ASTSuperExpression) e).getQualifier() == null;\n    }\n\n    /**\n     * Returns true if the expression is a {@link ASTNamedReferenceExpr}\n     * that references any of the symbol in the set.\n     */\n    public static boolean isReferenceToVar(@Nullable ASTExpression expression, @NonNull Set<? extends JVariableSymbol> symbols) {\n        return expression instanceof ASTNamedReferenceExpr\n                && symbols.contains(((ASTNamedReferenceExpr) expression).getReferencedSym());\n    }\n\n    /**\n     * Returns true if both expressions refer to the same variable.\n     * A \"variable\" here can also means a field path, eg, {@code this.field.a}.\n     * This method unifies {@code this.field} and {@code field} if possible,\n     * and also considers {@code this}.\n     *\n     * <p>Note that while this is more useful than just checking whether\n     * both expressions access the same symbol, it still does not mean that\n     * they both access the same <i>value</i>. The actual value is data-flow\n     * dependent.\n     */\n    public static boolean isReferenceToSameVar(ASTExpression e1, ASTExpression e2) {\n        if (e1 instanceof ASTNamedReferenceExpr && e2 instanceof ASTNamedReferenceExpr) {\n            if (OptionalBool.YES != referenceSameSymbol((ASTNamedReferenceExpr) e1, (ASTNamedReferenceExpr) e2)) {\n                return false;\n            }\n\n            if (e1.getClass() != e2.getClass()) {\n                // unify `this.f` and `f`\n                // note, we already know that the symbol is the same so there's no scoping problem\n                return isSyntacticThisFieldAccess(e1) || isSyntacticThisFieldAccess(e2);\n            } else if (e1 instanceof ASTFieldAccess && e2 instanceof ASTFieldAccess) {\n                return isReferenceToSameVar(((ASTFieldAccess) e1).getQualifier(),\n                                            ((ASTFieldAccess) e2).getQualifier());\n            }\n            return e1 instanceof ASTVariableAccess && e2 instanceof ASTVariableAccess;\n        } else if (e1 instanceof ASTThisExpression || e2 instanceof ASTThisExpression) {\n            return e1.getClass() == e2.getClass();\n        }\n        return false;\n    }\n\n    private static OptionalBool referenceSameSymbol(ASTNamedReferenceExpr e1, ASTNamedReferenceExpr e2) {\n        if (!e1.getName().equals(e2.getName())) {\n            return OptionalBool.NO;\n        }\n        JVariableSymbol ref1 = e1.getReferencedSym();\n        JVariableSymbol ref2 = e2.getReferencedSym();\n        if (ref1 == null || ref2 == null) {\n            return OptionalBool.UNKNOWN;\n        }\n        return OptionalBool.definitely(ref1.equals(ref2));\n    }\n\n    /**\n     * Returns true if the expression is a reference to a local variable.\n     */\n    public static boolean isReferenceToLocal(ASTExpression expr) {\n        return expr instanceof ASTVariableAccess\n                && ((ASTVariableAccess) expr).getReferencedSym() instanceof AstLocalVarSym;\n    }\n\n    /**\n     * Returns true if the expression has the form `field`, or `this.field`,\n     * where `field` is a field declared in the enclosing class.\n     * Assumes we're not in a static context.\n     * todo this should probs consider super.field and superclass\n     */\n    public static boolean isRefToFieldOfThisInstance(ASTExpression usage) {\n        if (!(usage instanceof ASTNamedReferenceExpr)) {\n            return false;\n        }\n        JVariableSymbol symbol = ((ASTNamedReferenceExpr) usage).getReferencedSym();\n        if (!(symbol instanceof JFieldSymbol)\n            || !((JFieldSymbol) symbol).getEnclosingClass().equals(usage.getEnclosingType().getSymbol())\n            || Modifier.isStatic(((JFieldSymbol) symbol).getModifiers())) {\n            return false;\n        }\n\n        if (usage instanceof ASTVariableAccess) {\n            return true;\n        } else if (usage instanceof ASTFieldAccess) {\n            ASTExpression qualifier = ((ASTFieldAccess) usage).getQualifier();\n            return qualifier instanceof ASTThisExpression\n                || qualifier instanceof ASTSuperExpression;\n        }\n        return false;\n    }\n\n    /**\n     * Return a node stream containing all the operands of an addition expression.\n     * For instance, {@code a+b+c} will be parsed as a tree with two levels.\n     * This method will return a flat node stream containing {@code a, b, c}.\n     *\n     * @param e An expression, if it is not a string concatenation expression,\n     *          then returns an empty node stream.\n     */\n    public static NodeStream<ASTExpression> flattenOperands(ASTExpression e) {\n        List<ASTExpression> result = new ArrayList<>();\n        flattenOperandsRec(e, result);\n        return NodeStream.fromIterable(result);\n    }\n\n    private static void flattenOperandsRec(ASTExpression e, List<ASTExpression> result) {\n        if (isStringConcatExpression(e)) {\n            ASTInfixExpression infix = (ASTInfixExpression) e;\n            flattenOperandsRec(infix.getLeftOperand(), result);\n            flattenOperandsRec(infix.getRightOperand(), result);\n        } else {\n            result.add(e);\n        }\n    }\n\n    private static boolean isStringConcatExpression(ASTExpression e) {\n        return BinaryOp.isInfixExprWithOperator(e, BinaryOp.ADD) && TypeTestUtil.isA(String.class, e);\n    }\n\n    /**\n     * Returns true if the node is the last child of its parent (or is the root node).\n     */\n    public static boolean isLastChild(Node it) {\n        Node parent = it.getParent();\n        return parent == null || it.getIndexInParent() == parent.getNumChildren() - 1;\n    }\n\n    /**\n     * Returns a node stream of enclosing expressions in the same call chain.\n     * For instance in {@code a.b().c().d()}, called on {@code a}, this will\n     * yield {@code a.b()}, and {@code a.b().c()}.\n     */\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public static NodeStream<QualifiableExpression> followingCallChain(ASTExpression expr) {\n        return (NodeStream) expr.ancestors().takeWhile(it -> it instanceof QualifiableExpression);\n    }\n\n    public static ASTExpression peelCasts(@Nullable ASTExpression expr) {\n        while (expr instanceof ASTCastExpression) {\n            expr = ((ASTCastExpression) expr).getOperand();\n        }\n        return expr;\n    }\n\n    public static @Nullable ASTVariableDeclaratorId getReferencedNode(ASTNamedReferenceExpr expr) {\n        JVariableSymbol referencedSym = expr.getReferencedSym();\n        return referencedSym == null ? null : referencedSym.tryGetNode();\n    }\n\n    /**\n     * Returns true if the expression is a null check on the given variable.\n     */\n    public static boolean isNullCheck(ASTExpression expr, JVariableSymbol var) {\n        return isNullCheck(expr, StablePathMatcher.matching(var));\n    }\n\n    public static boolean isNullCheck(ASTExpression expr, StablePathMatcher matcher) {\n        if (expr instanceof ASTInfixExpression) {\n            ASTInfixExpression condition = (ASTInfixExpression) expr;\n            if (condition.getOperator().hasSamePrecedenceAs(BinaryOp.EQ)) {\n                ASTNullLiteral nullLit = condition.firstChild(ASTNullLiteral.class);\n                if (nullLit != null) {\n                    return matcher.matches(getOtherOperandIfInInfixExpr(nullLit));\n                }\n            }\n        }\n        return false;\n    }\n\n    public static boolean isArrayInitializer(ASTExpression expr) {\n        return expr instanceof ASTArrayAllocation && ((ASTArrayAllocation) expr).getArrayInitializer() != null;\n    }\n\n    public static boolean isCloneMethod(ASTMethodDeclaration node) {\n        // this is enough as in valid code, this signature overrides Object#clone\n        // and the other things like visibility are checked by the compiler\n        return \"clone\".equals(node.getName())\n            && node.getArity() == 0\n            && !node.isStatic();\n    }\n}\n",
        "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/internal/JavaRuleUtil.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.rule.internal;\n\nimport static net.sourceforge.pmd.lang.java.types.JPrimitiveType.PrimitiveTypeKind.LONG;\nimport static net.sourceforge.pmd.util.CollectionUtil.immutableSetOf;\n\nimport java.io.InvalidObjectException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectStreamField;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport net.sourceforge.pmd.lang.ast.GenericToken;\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.ast.NodeStream;\nimport net.sourceforge.pmd.lang.ast.impl.javacc.JavaccToken;\nimport net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTArgumentList;\nimport net.sourceforge.pmd.lang.java.ast.ASTArrayAccess;\nimport net.sourceforge.pmd.lang.java.ast.ASTArrayAllocation;\nimport net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr;\nimport net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr.ASTNamedReferenceExpr;\nimport net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr.AccessType;\nimport net.sourceforge.pmd.lang.java.ast.ASTAssignmentExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTBodyDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTBooleanLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTCastExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType;\nimport net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;\nimport net.sourceforge.pmd.lang.java.ast.ASTExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTExpressionStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTFieldAccess;\nimport net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTForStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;\nimport net.sourceforge.pmd.lang.java.ast.ASTFormalParameters;\nimport net.sourceforge.pmd.lang.java.ast.ASTInfixExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTInitializer;\nimport net.sourceforge.pmd.lang.java.ast.ASTLabeledStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTList;\nimport net.sourceforge.pmd.lang.java.ast.ASTLocalVariableDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTMethodCall;\nimport net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTMethodOrConstructorDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTNullLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTNumericLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTSuperExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTThisExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTThrowStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTUnaryExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;\nimport net.sourceforge.pmd.lang.java.ast.AccessNode;\nimport net.sourceforge.pmd.lang.java.ast.AccessNode.Visibility;\nimport net.sourceforge.pmd.lang.java.ast.Annotatable;\nimport net.sourceforge.pmd.lang.java.ast.BinaryOp;\nimport net.sourceforge.pmd.lang.java.ast.JModifier;\nimport net.sourceforge.pmd.lang.java.ast.JavaNode;\nimport net.sourceforge.pmd.lang.java.ast.JavaTokenKinds;\nimport net.sourceforge.pmd.lang.java.ast.QualifiableExpression;\nimport net.sourceforge.pmd.lang.java.ast.TypeNode;\nimport net.sourceforge.pmd.lang.java.ast.UnaryOp;\nimport net.sourceforge.pmd.lang.java.symbols.JFieldSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.JVariableSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.internal.ast.AstLocalVarSym;\nimport net.sourceforge.pmd.lang.java.types.InvocationMatcher;\nimport net.sourceforge.pmd.lang.java.types.InvocationMatcher.CompoundInvocationMatcher;\nimport net.sourceforge.pmd.lang.java.types.JPrimitiveType.PrimitiveTypeKind;\nimport net.sourceforge.pmd.lang.java.types.JTypeMirror;\nimport net.sourceforge.pmd.lang.java.types.TypeTestUtil;\nimport net.sourceforge.pmd.util.CollectionUtil;\nimport net.sourceforge.pmd.util.OptionalBool;\n\n/**\n * Utilities shared between rules.\n */\npublic final class JavaRuleUtil {\n\n    // this is a hacky way to do it, but let's see where this goes\n    private static final CompoundInvocationMatcher KNOWN_PURE_METHODS = InvocationMatcher.parseAll(\n        \"_#toString()\",\n        \"_#hashCode()\",\n        \"_#equals(java.lang.Object)\",\n        \"java.lang.String#_(_*)\",\n        // actually not all of them, probs only stream of some type\n        // arg which doesn't implement Closeable...\n        \"java.util.stream.Stream#_(_*)\",\n        \"java.util.Collection#size()\",\n        \"java.util.List#get(int)\",\n        \"java.util.Map#get(_)\",\n        \"java.lang.Iterable#iterator()\",\n        \"java.lang.Comparable#compareTo(_)\"\n    );\n\n    public static final Set<String> LOMBOK_ANNOTATIONS = immutableSetOf(\n        \"lombok.Data\",\n        \"lombok.Getter\",\n        \"lombok.Setter\",\n        \"lombok.Value\",\n        \"lombok.RequiredArgsConstructor\",\n        \"lombok.AllArgsConstructor\",\n        \"lombok.NoArgsConstructor\",\n        \"lombok.Builder\",\n        \"lombok.EqualsAndHashCode\",\n        \"lombok.experimental.Delegate\"\n    );\n\n    private JavaRuleUtil() {\n        // utility class\n    }\n\n\n    /**\n     * Return true if the given expression is enclosed in a zero check.\n     * The expression must evaluate to a natural number (ie >= 0), so that\n     * {@code e < 1} actually means {@code e == 0}.\n     *\n     * @param e Expression\n     */\n    public static boolean isZeroChecked(ASTExpression e) {\n        JavaNode parent = e.getParent();\n        if (parent instanceof ASTInfixExpression) {\n            BinaryOp op = ((ASTInfixExpression) parent).getOperator();\n            int checkLiteralAtIdx = 1 - e.getIndexInParent();\n            JavaNode comparand = parent.getChild(checkLiteralAtIdx);\n            int expectedValue;\n            if (op == BinaryOp.NE || op == BinaryOp.EQ) {\n                // e == 0, e != 0, symmetric\n                expectedValue = 0;\n            } else if (op == BinaryOp.LT || op == BinaryOp.GE) {\n                // e < 1\n                // 0 < e\n                // e >= 1     (e != 0)\n                // 1 >= e     (e == 0 || e == 1)\n                // 0 >= e     (e == 0)\n                // e >= 0     (true)\n                expectedValue = checkLiteralAtIdx;\n            } else if (op == BinaryOp.GT || op == BinaryOp.LE) {\n                // 1 > e\n                // e > 0\n\n                // 1 <= e     (e != 0)\n                // e <= 1     (e == 0 || e == 1)\n                // e <= 0     (e == 0)\n                // 0 <= e     (true)\n                expectedValue = 1 - checkLiteralAtIdx;\n            } else {\n                return false;\n            }\n\n            return isLiteralInt(comparand, expectedValue);\n        }\n        return false;\n    }\n\n\n    /**\n     * Returns true if this is a numeric literal with the given int value.\n     * This also considers long literals.\n     */\n    public static boolean isLiteralInt(JavaNode e, int value) {\n        return e instanceof ASTNumericLiteral\n                && ((ASTNumericLiteral) e).isIntegral()\n                && ((ASTNumericLiteral) e).getValueAsInt() == value;\n    }\n\n    /** This is type-aware, so will not pick up on numeric addition. */\n    public static boolean isStringConcatExpr(@Nullable JavaNode e) {\n        if (e instanceof ASTInfixExpression) {\n            ASTInfixExpression infix = (ASTInfixExpression) e;\n            return infix.getOperator() == BinaryOp.ADD && TypeTestUtil.isA(String.class, infix);\n        }\n        return false;\n    }\n\n    /**\n     * If the parameter is an operand of a binary infix expression,\n     * returns the other operand. Otherwise returns null.\n     */\n    public static @Nullable ASTExpression getOtherOperandIfInInfixExpr(@Nullable JavaNode e) {\n        if (e != null && e.getParent() instanceof ASTInfixExpression) {\n            return (ASTExpression) e.getParent().getChild(1 - e.getIndexInParent());\n        }\n        return null;\n    }\n\n    public static @Nullable ASTExpression getOtherOperandIfInAssignmentExpr(@Nullable JavaNode e) {\n        if (e != null && e.getParent() instanceof ASTAssignmentExpression) {\n            return (ASTExpression) e.getParent().getChild(1 - e.getIndexInParent());\n        }\n        return null;\n    }\n\n    /**\n     * Returns true if the expression is a stringbuilder (or stringbuffer)\n     * append call, or a constructor call for one of these classes.\n     *\n     * <p>If it is a constructor call, returns false if this is a call to\n     * the constructor with a capacity parameter.\n     */\n    public static boolean isStringBuilderCtorOrAppend(@Nullable ASTExpression e) {\n        if (e instanceof ASTMethodCall) {\n            ASTMethodCall call = (ASTMethodCall) e;\n            if (\"append\".equals(call.getMethodName())) {\n                ASTExpression qual = ((ASTMethodCall) e).getQualifier();\n                return qual != null && isStringBufferOrBuilder(qual);\n            }\n        } else if (e instanceof ASTConstructorCall) {\n            return isStringBufferOrBuilder(((ASTConstructorCall) e).getTypeNode());\n        }\n        return false;\n    }\n\n    private static boolean isStringBufferOrBuilder(TypeNode node) {\n        return TypeTestUtil.isExactlyA(StringBuilder.class, node)\n            || TypeTestUtil.isExactlyA(StringBuffer.class, node);\n    }\n\n    /**\n     * Returns true if the node is a {@link ASTMethodDeclaration} that\n     * is a main method.\n     */\n    public static boolean isMainMethod(JavaNode node) {\n        return node instanceof ASTMethodDeclaration\n                && ((ASTMethodDeclaration) node).isMainMethod();\n    }\n\n    /**\n     * Returns true if the node is a utility class, according to this\n     * custom definition.\n     */\n    public static boolean isUtilityClass(ASTAnyTypeDeclaration node) {\n        if (!node.isRegularClass()) {\n            return false;\n        }\n\n        ASTClassOrInterfaceDeclaration classNode = (ASTClassOrInterfaceDeclaration) node;\n\n        // A class with a superclass or interfaces should not be considered\n        if (classNode.getSuperClassTypeNode() != null\n            || !classNode.getSuperInterfaceTypeNodes().isEmpty()) {\n            return false;\n        }\n\n        // A class without declarations shouldn't be reported\n        boolean hasAny = false;\n\n        for (ASTBodyDeclaration declNode : classNode.getDeclarations()) {\n            if (declNode instanceof ASTFieldDeclaration\n                || declNode instanceof ASTMethodDeclaration) {\n\n                hasAny = isNonPrivate(declNode) && !isMainMethod(declNode);\n                if (!((AccessNode) declNode).hasModifiers(JModifier.STATIC)) {\n                    return false;\n                }\n\n            } else if (declNode instanceof ASTInitializer) {\n                if (!((ASTInitializer) declNode).isStatic()) {\n                    return false;\n                }\n            }\n        }\n\n        return hasAny;\n    }\n\n    private static boolean isNonPrivate(ASTBodyDeclaration decl) {\n        return ((AccessNode) decl).getVisibility() != Visibility.V_PRIVATE;\n    }\n\n    /**\n     * Whether the name may be ignored by unused rules like UnusedAssignment.\n     */\n    public static boolean isExplicitUnusedVarName(String name) {\n        return name.startsWith(\"ignored\")\n            || name.startsWith(\"unused\")\n            || \"_\".equals(name); // before java 9 it's ok\n    }\n\n    /**\n     * Returns true if the string has the given word as a strict prefix.\n     * There needs to be a camelcase word boundary after the prefix.\n     *\n     * <code>\n     * startsWithCamelCaseWord(\"getter\", \"get\") == false\n     * startsWithCamelCaseWord(\"get\", \"get\")    == false\n     * startsWithCamelCaseWord(\"getX\", \"get\")   == true\n     * </code>\n     *\n     * @param camelCaseString A string\n     * @param prefixWord      A prefix\n     */\n    public static boolean startsWithCamelCaseWord(String camelCaseString, String prefixWord) {\n        return camelCaseString.startsWith(prefixWord)\n            && camelCaseString.length() > prefixWord.length()\n            && Character.isUpperCase(camelCaseString.charAt(prefixWord.length()));\n    }\n\n\n    /**\n     * Returns true if the string has the given word as a word, not at the start.\n     * There needs to be a camelcase word boundary after the prefix.\n     *\n     * <code>\n     * containsCamelCaseWord(\"isABoolean\", \"Bool\") == false\n     * containsCamelCaseWord(\"isABoolean\", \"A\")    == true\n     * containsCamelCaseWord(\"isABoolean\", \"is\")   == error (not capitalized)\n     * </code>\n     *\n     * @param camelCaseString A string\n     * @param capitalizedWord A word, non-empty, capitalized\n     *\n     * @throws AssertionError If the word is empty or not capitalized\n     */\n    public static boolean containsCamelCaseWord(String camelCaseString, String capitalizedWord) {\n        assert capitalizedWord.length() > 0 && Character.isUpperCase(capitalizedWord.charAt(0))\n            : \"Not a capitalized string \\\"\" + capitalizedWord + \"\\\"\";\n\n        int index = camelCaseString.indexOf(capitalizedWord);\n        if (index >= 0 && camelCaseString.length() > index + capitalizedWord.length()) {\n            return Character.isUpperCase(camelCaseString.charAt(index + capitalizedWord.length()));\n        }\n        return index >= 0 && camelCaseString.length() == index + capitalizedWord.length();\n    }\n\n    public static boolean isGetterOrSetterCall(ASTMethodCall call) {\n        return isGetterCall(call) || isSetterCall(call);\n    }\n\n    private static boolean isSetterCall(ASTMethodCall call) {\n        return call.getArguments().size() > 0 && startsWithCamelCaseWord(call.getMethodName(), \"set\");\n    }\n\n    public static boolean isGetterCall(ASTMethodCall call) {\n        return call.getArguments().size() == 0\n            && (startsWithCamelCaseWord(call.getMethodName(), \"get\")\n            || startsWithCamelCaseWord(call.getMethodName(), \"is\"));\n    }\n\n\n    public static boolean isGetterOrSetter(ASTMethodDeclaration node) {\n        return isGetter(node) || isSetter(node);\n    }\n\n    /** Attempts to determine if the method is a getter. */\n    private static boolean isGetter(ASTMethodDeclaration node) {\n\n        if (node.getArity() != 0 || node.isVoid()) {\n            return false;\n        }\n\n        ASTAnyTypeDeclaration enclosing = node.getEnclosingType();\n        if (startsWithCamelCaseWord(node.getName(), \"get\")) {\n            return hasField(enclosing, node.getName().substring(3));\n        } else if (startsWithCamelCaseWord(node.getName(), \"is\")\n                && TypeTestUtil.isA(boolean.class, node.getResultTypeNode())) {\n            return hasField(enclosing, node.getName().substring(2));\n        }\n\n        return hasField(enclosing, node.getName());\n    }\n\n    /** Attempts to determine if the method is a setter. */\n    private static boolean isSetter(ASTMethodDeclaration node) {\n\n        if (node.getArity() != 1 || !node.isVoid()) {\n            return false;\n        }\n\n        ASTAnyTypeDeclaration enclosing = node.getEnclosingType();\n\n        if (startsWithCamelCaseWord(node.getName(), \"set\")) {\n            return hasField(enclosing, node.getName().substring(3));\n        }\n\n        return hasField(enclosing, node.getName());\n    }\n\n    private static boolean hasField(ASTAnyTypeDeclaration node, String name) {\n        for (JFieldSymbol f : node.getSymbol().getDeclaredFields()) {\n            String fname = f.getSimpleName();\n            if (fname.startsWith(\"m_\") || fname.startsWith(\"_\")) {\n                fname = fname.substring(fname.indexOf('_') + 1);\n            }\n            if (fname.equalsIgnoreCase(name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns true if the formal parameters of the method or constructor\n     * match the given types exactly. Note that for varargs methods, the\n     * last param must have an array type (but it is not checked to be varargs).\n     * This will return false if we're not sure.\n     *\n     * @param node  Method or ctor\n     * @param types List of types to match (may be empty)\n     *\n     * @throws NullPointerException If any of the classes is null, or the node is null\n     * @see TypeTestUtil#isExactlyA(Class, TypeNode)\n     */\n    public static boolean hasParameters(ASTMethodOrConstructorDeclaration node, Class<?>... types) {\n        ASTFormalParameters formals = node.getFormalParameters();\n        if (formals.size() != types.length) {\n            return false;\n        }\n        for (int i = 0; i < formals.size(); i++) {\n            ASTFormalParameter fi = formals.get(i);\n            if (!TypeTestUtil.isExactlyA(types[i], fi)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns true if the {@code throws} declaration of the method or constructor\n     * matches the given types exactly.\n     *\n     * @param node  Method or ctor\n     * @param types List of exception types to match (may be empty)\n     *\n     * @throws NullPointerException If any of the classes is null, or the node is null\n     * @see TypeTestUtil#isExactlyA(Class, TypeNode)\n     */\n    @SafeVarargs\n    public static boolean hasExceptionList(ASTMethodOrConstructorDeclaration node, Class<? extends Throwable>... types) {\n        @NonNull List<ASTClassOrInterfaceType> formals = ASTList.orEmpty(node.getThrowsList());\n        if (formals.size() != types.length) {\n            return false;\n        }\n        for (int i = 0; i < formals.size(); i++) {\n            ASTClassOrInterfaceType fi = formals.get(i);\n            if (!TypeTestUtil.isExactlyA(types[i], fi)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * True if the variable is never used. Note that the visibility of\n     * the variable must be less than {@link Visibility#V_PRIVATE} for\n     * us to be sure of it.\n     */\n    public static boolean isNeverUsed(ASTVariableDeclaratorId varId) {\n        return CollectionUtil.none(varId.getLocalUsages(), JavaRuleUtil::isReadUsage);\n    }\n\n    private static boolean isReadUsage(ASTNamedReferenceExpr expr) {\n        return expr.getAccessType() == AccessType.READ\n            // x++ as a method argument or used in other expression\n            || expr.getParent() instanceof ASTUnaryExpression\n            && !(expr.getParent().getParent() instanceof ASTExpressionStatement);\n    }\n\n    /**\n     * True if the variable is incremented or decremented via a compound\n     * assignment operator, or a unary increment/decrement expression.\n     */\n    public static boolean isVarAccessReadAndWrite(ASTNamedReferenceExpr expr) {\n        return expr.getAccessType() == AccessType.WRITE\n            && (!(expr.getParent() instanceof ASTAssignmentExpression)\n            || ((ASTAssignmentExpression) expr.getParent()).getOperator().isCompound());\n    }\n\n    /**\n     * True if the variable access is a non-compound assignment.\n     */\n    public static boolean isVarAccessStrictlyWrite(ASTNamedReferenceExpr expr) {\n        return expr.getParent() instanceof ASTAssignmentExpression\n            && expr.getIndexInParent() == 0\n            && !((ASTAssignmentExpression) expr.getParent()).getOperator().isCompound();\n    }\n\n    /**\n     * Returns the set of labels on this statement.\n     */\n    public static Set<String> getStatementLabels(ASTStatement node) {\n        if (!(node.getParent() instanceof ASTLabeledStatement)) {\n            return Collections.emptySet();\n        }\n\n        return node.ancestors().takeWhile(it -> it instanceof ASTLabeledStatement)\n                   .toStream()\n                   .map(it -> ((ASTLabeledStatement) it).getLabel())\n                   .collect(Collectors.toSet());\n    }\n\n    public static boolean isAnonymousClassCreation(@Nullable ASTExpression expression) {\n        return expression instanceof ASTConstructorCall\n                && ((ASTConstructorCall) expression).isAnonymousClass();\n    }\n\n    /**\n     * Will cut through argument lists, except those of enum constants\n     * and explicit invocation nodes.\n     */\n    public static @NonNull ASTExpression getTopLevelExpr(ASTExpression expr) {\n        return (ASTExpression) expr.ancestorsOrSelf()\n                                   .takeWhile(it -> it instanceof ASTExpression\n                                       || it instanceof ASTArgumentList && it.getParent() instanceof ASTExpression)\n                                   .last();\n    }\n\n    /**\n     * Returns the variable IDS corresponding to variables declared in\n     * the init clause of the loop.\n     */\n    public static NodeStream<ASTVariableDeclaratorId> getLoopVariables(ASTForStatement loop) {\n        return NodeStream.of(loop.getInit())\n                         .filterIs(ASTLocalVariableDeclaration.class)\n                         .flatMap(ASTLocalVariableDeclaration::getVarIds);\n    }\n\n    // TODO at least UnusedPrivateMethod has some serialization-related logic.\n\n    /**\n     * Whether some variable declared by the given node is a serialPersistentFields\n     * (serialization-specific field).\n     */\n    public static boolean isSerialPersistentFields(final ASTFieldDeclaration field) {\n        return field.hasModifiers(JModifier.FINAL, JModifier.STATIC, JModifier.PRIVATE)\n            && field.getVarIds().any(it -> \"serialPersistentFields\".equals(it.getName()) && TypeTestUtil.isA(ObjectStreamField[].class, it));\n    }\n\n    /**\n     * Whether some variable declared by the given node is a serialVersionUID\n     * (serialization-specific field).\n     */\n    public static boolean isSerialVersionUID(ASTFieldDeclaration field) {\n        return field.hasModifiers(JModifier.FINAL, JModifier.STATIC)\n            && field.getVarIds().any(it -> \"serialVersionUID\".equals(it.getName()) && it.getTypeMirror().isPrimitive(LONG));\n    }\n\n    /**\n     * True if the method is a {@code readObject} method defined for serialization.\n     */\n    public static boolean isSerializationReadObject(ASTMethodDeclaration node) {\n        return node.getVisibility() == Visibility.V_PRIVATE\n            && \"readObject\".equals(node.getName())\n            && hasExceptionList(node, InvalidObjectException.class)\n            && hasParameters(node, ObjectInputStream.class);\n    }\n\n    /**\n     * Whether one expression is the boolean negation of the other. Many\n     * forms are not yet supported. This method is symmetric so only needs\n     * to be called once.\n     */\n    public static boolean areComplements(ASTExpression e1, ASTExpression e2) {\n        if (isBooleanNegation(e1)) {\n            return areEqual(unaryOperand(e1), e2);\n        } else if (isBooleanNegation(e2)) {\n            return areEqual(e1, unaryOperand(e2));\n        } else if (e1 instanceof ASTInfixExpression && e2 instanceof ASTInfixExpression) {\n            ASTInfixExpression ifx1 = (ASTInfixExpression) e1;\n            ASTInfixExpression ifx2 = (ASTInfixExpression) e2;\n            if (ifx1.getOperator().getComplement() != ifx2.getOperator()) {\n                return false;\n            }\n            if (ifx1.getOperator().hasSamePrecedenceAs(BinaryOp.EQ)) {\n                // NOT(a == b, a != b)\n                // NOT(a == b, b != a)\n                return areEqual(ifx1.getLeftOperand(), ifx2.getLeftOperand())\n                    && areEqual(ifx1.getRightOperand(), ifx2.getRightOperand())\n                    || areEqual(ifx2.getLeftOperand(), ifx1.getLeftOperand())\n                    && areEqual(ifx2.getRightOperand(), ifx1.getRightOperand());\n            }\n            // todo we could continue with de Morgan and such\n        }\n        return false;\n    }\n\n    private static boolean areEqual(ASTExpression e1, ASTExpression e2) {\n        return tokenEquals(e1, e2);\n    }\n\n    /**\n     * Returns true if both nodes have exactly the same tokens.\n     *\n     * @param node First node\n     * @param that Other node\n     */\n    public static boolean tokenEquals(JavaNode node, JavaNode that) {\n        return tokenEquals(node, that, null);\n    }\n\n    /**\n     * Returns true if both nodes have the same tokens, modulo some renaming\n     * function. The renaming function maps unqualified variables and type\n     * identifiers of the first node to the other. This should be used\n     * in nodes living in the same lexical scope, so that unqualified\n     * names mean the same thing.\n     *\n     * @param node       First node\n     * @param other      Other node\n     * @param varRenamer A renaming function. If null, no renaming is applied.\n     *                   Must not return null, if no renaming occurs, returns its argument.\n     */\n    public static boolean tokenEquals(@NonNull JavaNode node,\n                                      @NonNull JavaNode other,\n                                      @Nullable Function<String, @NonNull String> varRenamer) {\n        // Since type and variable names obscure one another,\n        // it's ok to use a single renaming function.\n\n        Iterator<JavaccToken> thisIt = GenericToken.range(node.getFirstToken(), node.getLastToken());\n        Iterator<JavaccToken> thatIt = GenericToken.range(other.getFirstToken(), other.getLastToken());\n        int lastKind = 0;\n        while (thisIt.hasNext()) {\n            if (!thatIt.hasNext()) {\n                return false;\n            }\n            JavaccToken o1 = thisIt.next();\n            JavaccToken o2 = thatIt.next();\n            if (o1.kind != o2.kind) {\n                return false;\n            }\n\n            String mappedImage = o1.getImage();\n            if (varRenamer != null\n                && o1.kind == JavaTokenKinds.IDENTIFIER\n                && lastKind != JavaTokenKinds.DOT\n                && lastKind != JavaTokenKinds.METHOD_REF\n                //method name\n                && o1.getNext() != null && o1.getNext().kind != JavaTokenKinds.LPAREN) {\n                mappedImage = varRenamer.apply(mappedImage);\n            }\n\n            if (!o2.getImage().equals(mappedImage)) {\n                return false;\n            }\n\n            lastKind = o1.kind;\n        }\n        return !thatIt.hasNext();\n    }\n\n    public static boolean isNullLiteral(ASTExpression node) {\n        return node instanceof ASTNullLiteral;\n    }\n\n\n    /** Returns true if the node is a boolean literal with any value. */\n    public static boolean isBooleanLiteral(JavaNode e) {\n        return e instanceof ASTBooleanLiteral;\n    }\n\n    /** Returns true if the node is a boolean literal with the given constant value. */\n    public static boolean isBooleanLiteral(JavaNode e, boolean value) {\n        return e instanceof ASTBooleanLiteral && ((ASTBooleanLiteral) e).isTrue() == value;\n    }\n\n    public static boolean isBooleanNegation(JavaNode e) {\n        return e instanceof ASTUnaryExpression && ((ASTUnaryExpression) e).getOperator() == UnaryOp.NEGATION;\n    }\n\n    /**\n     * If the argument is a unary expression, returns its operand, otherwise\n     * returns null.\n     */\n    public static @Nullable ASTExpression unaryOperand(@Nullable ASTExpression e) {\n        return e instanceof ASTUnaryExpression ? ((ASTUnaryExpression) e).getOperand()\n                                               : null;\n    }\n\n\n    /**\n     * Whether the expression is an access to a field of this instance,\n     * not inherited, qualified or not ({@code this.field} or just {@code field}).\n     */\n    public static boolean isThisFieldAccess(ASTExpression e) {\n        if (!(e instanceof ASTNamedReferenceExpr)) {\n            return false;\n        }\n        JVariableSymbol sym = ((ASTNamedReferenceExpr) e).getReferencedSym();\n        return sym instanceof JFieldSymbol\n                && !((JFieldSymbol) sym).isStatic()\n                // not inherited\n                && ((JFieldSymbol) sym).getEnclosingClass().equals(e.getEnclosingType().getSymbol())\n                // correct syntactic form\n                && (e instanceof ASTVariableAccess || isSyntacticThisFieldAccess(e));\n    }\n\n    /**\n     * Whether the expression is a {@code this.field}, with no outer\n     * instance qualifier ({@code Outer.this.field}). The field symbol\n     * is not checked to resolve to a field declared in this class (it\n     * may be inherited)\n     */\n    public static boolean isSyntacticThisFieldAccess(ASTExpression e) {\n        if (e instanceof ASTFieldAccess) {\n            ASTExpression qualifier = ((ASTFieldAccess) e).getQualifier();\n            if (qualifier instanceof ASTThisExpression) {\n                // unqualified this\n                return ((ASTThisExpression) qualifier).getQualifier() == null;\n            }\n        }\n        return false;\n    }\n\n    public static boolean hasAnyAnnotation(Annotatable node, Collection<String> qualifiedNames) {\n        return qualifiedNames.stream().anyMatch(node::isAnnotationPresent);\n    }\n\n\n    /**\n     * Returns true if the expression is the default field value for\n     * the given type.\n     */\n    public static boolean isDefaultValue(JTypeMirror type, ASTExpression expr) {\n        if (type.isPrimitive()) {\n            if (type.isPrimitive(PrimitiveTypeKind.BOOLEAN)) {\n                return expr instanceof ASTBooleanLiteral && !((ASTBooleanLiteral) expr).isTrue();\n            } else {\n                Object constValue = expr.getConstValue();\n                return constValue instanceof Number && ((Number) constValue).doubleValue() == 0d\n                    || constValue instanceof Character && constValue.equals('\\u0000');\n            }\n        } else {\n            return expr instanceof ASTNullLiteral;\n        }\n    }\n\n    /**\n     * Returns true if the expression is a {@link ASTNamedReferenceExpr}\n     * that references the symbol.\n     */\n    public static boolean isReferenceToVar(@Nullable ASTExpression expression, @NonNull JVariableSymbol symbol) {\n        return expression instanceof ASTNamedReferenceExpr\n                && symbol.equals(((ASTNamedReferenceExpr) expression).getReferencedSym());\n    }\n\n    public static boolean isUnqualifiedThis(ASTExpression e) {\n        return e instanceof ASTThisExpression && ((ASTThisExpression) e).getQualifier() == null;\n    }\n\n    public static boolean isUnqualifiedSuper(ASTExpression e) {\n        return e instanceof ASTSuperExpression && ((ASTSuperExpression) e).getQualifier() == null;\n    }\n\n    /**\n     * Returns true if the expression is a {@link ASTNamedReferenceExpr}\n     * that references any of the symbol in the set.\n     */\n    public static boolean isReferenceToVar(@Nullable ASTExpression expression, @NonNull Set<? extends JVariableSymbol> symbols) {\n        return expression instanceof ASTNamedReferenceExpr\n                && symbols.contains(((ASTNamedReferenceExpr) expression).getReferencedSym());\n    }\n\n    /**\n     * Returns true if both expressions refer to the same variable.\n     * A \"variable\" here can also means a field path, eg, {@code this.field.a}.\n     * This method unifies {@code this.field} and {@code field} if possible,\n     * and also considers {@code this}.\n     *\n     * <p>Note that while this is more useful than just checking whether\n     * both expressions access the same symbol, it still does not mean that\n     * they both access the same <i>value</i>. The actual value is data-flow\n     * dependent.\n     */\n    public static boolean isReferenceToSameVar(ASTExpression e1, ASTExpression e2) {\n        if (e1 instanceof ASTNamedReferenceExpr && e2 instanceof ASTNamedReferenceExpr) {\n            if (OptionalBool.YES != referenceSameSymbol((ASTNamedReferenceExpr) e1, (ASTNamedReferenceExpr) e2)) {\n                return false;\n            }\n\n            if (e1.getClass() != e2.getClass()) {\n                // unify `this.f` and `f`\n                // note, we already know that the symbol is the same so there's no scoping problem\n                return isSyntacticThisFieldAccess(e1) || isSyntacticThisFieldAccess(e2);\n            } else if (e1 instanceof ASTFieldAccess && e2 instanceof ASTFieldAccess) {\n                return isReferenceToSameVar(((ASTFieldAccess) e1).getQualifier(),\n                                            ((ASTFieldAccess) e2).getQualifier());\n            }\n            return e1 instanceof ASTVariableAccess && e2 instanceof ASTVariableAccess;\n        } else if (e1 instanceof ASTThisExpression || e2 instanceof ASTThisExpression) {\n            return e1.getClass() == e2.getClass();\n        }\n        return false;\n    }\n\n    private static OptionalBool referenceSameSymbol(ASTNamedReferenceExpr e1, ASTNamedReferenceExpr e2) {\n        if (!e1.getName().equals(e2.getName())) {\n            return OptionalBool.NO;\n        }\n        JVariableSymbol ref1 = e1.getReferencedSym();\n        JVariableSymbol ref2 = e2.getReferencedSym();\n        if (ref1 == null || ref2 == null) {\n            return OptionalBool.UNKNOWN;\n        }\n        return OptionalBool.definitely(ref1.equals(ref2));\n    }\n\n    /**\n     * Returns true if the expression is a reference to a local variable.\n     */\n    public static boolean isReferenceToLocal(ASTExpression expr) {\n        return expr instanceof ASTVariableAccess\n                && ((ASTVariableAccess) expr).getReferencedSym() instanceof AstLocalVarSym;\n    }\n\n    /**\n     * Returns true if the expression has the form `field`, or `this.field`,\n     * where `field` is a field declared in the enclosing class.\n     * Assumes we're not in a static context.\n     * todo this should probs consider super.field and superclass\n     */\n    public static boolean isRefToFieldOfThisInstance(ASTExpression usage) {\n        if (!(usage instanceof ASTNamedReferenceExpr)) {\n            return false;\n        }\n        JVariableSymbol symbol = ((ASTNamedReferenceExpr) usage).getReferencedSym();\n        if (!(symbol instanceof JFieldSymbol)\n            || !((JFieldSymbol) symbol).getEnclosingClass().equals(usage.getEnclosingType().getSymbol())\n            || Modifier.isStatic(((JFieldSymbol) symbol).getModifiers())) {\n            return false;\n        }\n\n        if (usage instanceof ASTVariableAccess) {\n            return true;\n        } else if (usage instanceof ASTFieldAccess) {\n            ASTExpression qualifier = ((ASTFieldAccess) usage).getQualifier();\n            return qualifier instanceof ASTThisExpression\n                || qualifier instanceof ASTSuperExpression;\n        }\n        return false;\n    }\n\n    /**\n     * Return a node stream containing all the operands of an addition expression.\n     * For instance, {@code a+b+c} will be parsed as a tree with two levels.\n     * This method will return a flat node stream containing {@code a, b, c}.\n     *\n     * @param e An expression, if it is not a string concatenation expression,\n     *          then returns an empty node stream.\n     */\n    public static NodeStream<ASTExpression> flattenOperands(ASTExpression e) {\n        List<ASTExpression> result = new ArrayList<>();\n        flattenOperandsRec(e, result);\n        return NodeStream.fromIterable(result);\n    }\n\n    private static void flattenOperandsRec(ASTExpression e, List<ASTExpression> result) {\n        if (isStringConcatExpression(e)) {\n            ASTInfixExpression infix = (ASTInfixExpression) e;\n            flattenOperandsRec(infix.getLeftOperand(), result);\n            flattenOperandsRec(infix.getRightOperand(), result);\n        } else {\n            result.add(e);\n        }\n    }\n\n    private static boolean isStringConcatExpression(ASTExpression e) {\n        return BinaryOp.isInfixExprWithOperator(e, BinaryOp.ADD) && TypeTestUtil.isA(String.class, e);\n    }\n\n    /**\n     * Returns true if the node is the last child of its parent (or is the root node).\n     */\n    public static boolean isLastChild(Node it) {\n        Node parent = it.getParent();\n        return parent == null || it.getIndexInParent() == parent.getNumChildren() - 1;\n    }\n\n\n    /**\n     * Whether the node or one of its descendants is an expression with\n     * side effects. Conservatively, any method call is a potential side-effect,\n     * as well as assignments to fields or array elements. We could relax\n     * this assumption with (much) more data-flow logic, including a memory model.\n     *\n     * <p>By default assignments to locals are not counted as side-effects,\n     * unless the lhs is in the given set of symbols.\n     *\n     * @param node             A node\n     * @param localVarsToTrack Local variables to track\n     */\n    public static boolean hasSideEffect(@Nullable JavaNode node, Set<? extends JVariableSymbol> localVarsToTrack) {\n        return node != null && node.descendantsOrSelf()\n                                   .filterIs(ASTExpression.class)\n                                   .any(e -> hasSideEffectNonRecursive(e, localVarsToTrack));\n    }\n\n    /**\n     * Returns true if the expression has side effects we don't track.\n     * Does not recurse into sub-expressions.\n     */\n    private static boolean hasSideEffectNonRecursive(ASTExpression e, Set<? extends JVariableSymbol> localVarsToTrack) {\n        if (e instanceof ASTAssignmentExpression) {\n            ASTAssignableExpr lhs = ((ASTAssignmentExpression) e).getLeftOperand();\n            return isNonLocalLhs(lhs) || isReferenceToVar(lhs, localVarsToTrack);\n        } else if (e instanceof ASTUnaryExpression) {\n            ASTUnaryExpression unary = (ASTUnaryExpression) e;\n            ASTExpression lhs = unary.getOperand();\n            return !unary.getOperator().isPure()\n                && (isNonLocalLhs(lhs) || isReferenceToVar(lhs, localVarsToTrack));\n        }\n\n        // when there are throw statements,\n        // then this side effect can never be observed in containing code,\n        // because control flow jumps out of the method\n        return e.ancestors(ASTThrowStatement.class).isEmpty()\n                && (e instanceof ASTMethodCall && !isPure((ASTMethodCall) e)\n                        || e instanceof ASTConstructorCall);\n    }\n\n    private static boolean isNonLocalLhs(ASTExpression lhs) {\n        return lhs instanceof ASTArrayAccess || !isReferenceToLocal(lhs);\n    }\n\n    /**\n     * Whether the invocation has no side-effects. Very conservative.\n     */\n    private static boolean isPure(ASTMethodCall call) {\n        return isGetterCall(call) || KNOWN_PURE_METHODS.anyMatch(call);\n    }\n\n    /**\n     * Returns a node stream of enclosing expressions in the same call chain.\n     * For instance in {@code a.b().c().d()}, called on {@code a}, this will\n     * yield {@code a.b()}, and {@code a.b().c()}.\n     */\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public static NodeStream<QualifiableExpression> followingCallChain(ASTExpression expr) {\n        return (NodeStream) expr.ancestors().takeWhile(it -> it instanceof QualifiableExpression);\n    }\n\n    public static ASTExpression peelCasts(@Nullable ASTExpression expr) {\n        while (expr instanceof ASTCastExpression) {\n            expr = ((ASTCastExpression) expr).getOperand();\n        }\n        return expr;\n    }\n\n    public static @Nullable ASTVariableDeclaratorId getReferencedNode(ASTNamedReferenceExpr expr) {\n        JVariableSymbol referencedSym = expr.getReferencedSym();\n        return referencedSym == null ? null : referencedSym.tryGetNode();\n    }\n\n    /**\n     * Checks whether the given node is annotated with any lombok annotation.\n     * The node should be annotateable.\n     *\n     * @param node\n     *            the Annotatable node to check\n     * @return <code>true</code> if a lombok annotation has been found\n     */\n    public static boolean hasLombokAnnotation(Annotatable node) {\n        return LOMBOK_ANNOTATIONS.stream().anyMatch(node::isAnnotationPresent);\n    }\n\n    /**\n     * Returns true if the expression is a null check on the given variable.\n     */\n    public static boolean isNullCheck(ASTExpression expr, JVariableSymbol var) {\n        return isNullCheck(expr, StablePathMatcher.matching(var));\n    }\n\n    public static boolean isNullCheck(ASTExpression expr, StablePathMatcher matcher) {\n        if (expr instanceof ASTInfixExpression) {\n            ASTInfixExpression condition = (ASTInfixExpression) expr;\n            if (condition.getOperator().hasSamePrecedenceAs(BinaryOp.EQ)) {\n                ASTNullLiteral nullLit = condition.firstChild(ASTNullLiteral.class);\n                if (nullLit != null) {\n                    return matcher.matches(getOtherOperandIfInInfixExpr(nullLit));\n                }\n            }\n        }\n        return false;\n    }\n\n    public static boolean isArrayInitializer(ASTExpression expr) {\n        return expr instanceof ASTArrayAllocation && ((ASTArrayAllocation) expr).getArrayInitializer() != null;\n    }\n\n    public static boolean isCloneMethod(ASTMethodDeclaration node) {\n        // this is enough as in valid code, this signature overrides Object#clone\n        // and the other things like visibility are checked by the compiler\n        return \"clone\".equals(node.getName())\n            && node.getArity() == 0\n            && !node.isStatic();\n    }\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.java.rule.internal.DataflowPass.AssignmentEntry#equals\n methodBody: public boolean equals(Object o) {\nif(this == o){return true;\n}if(o == null || getClass() != o.getClass()){return false;\n}AssignmentEntry that=(AssignmentEntry)o;\nreturn Objects.equals(var,that.var) && Objects.equals(rhs,that.rhs);\n}"
        ],
        "sourceCodeAfterRefactoring": "public static boolean isCloneMethod(ASTMethodDeclaration node) {\n        // this is enough as in valid code, this signature overrides Object#clone\n        // and the other things like visibility are checked by the compiler\n        return \"clone\".equals(node.getName())\n            && node.getArity() == 0\n            && !node.isStatic();\n    }",
        "diffSourceCode": "-  655:     public static boolean isCloneMethod(ASTMethodDeclaration node) {\n-  656:         // this is enough as in valid code, this signature overrides Object#clone\n-  657:         // and the other things like visibility are checked by the compiler\n-  658:         return \"clone\".equals(node.getName())\n-  659:             && node.getArity() == 0\n-  660:             && !node.isStatic();\n-  661:     }\n+  655: \n+  656:     public static boolean isNullLiteral(ASTExpression node) {\n+  657:         return node instanceof ASTNullLiteral;\n+  658:     }\n+  659: \n+  660: \n+  661:     /** Returns true if the node is a boolean literal with any value. */\n+  994:     public static boolean isCloneMethod(ASTMethodDeclaration node) {\n+  995:         // this is enough as in valid code, this signature overrides Object#clone\n+  996:         // and the other things like visibility are checked by the compiler\n+  997:         return \"clone\".equals(node.getName())\n+  998:             && node.getArity() == 0\n+  999:             && !node.isStatic();\n+ 1000:     }\n",
        "uniqueId": "9cae6e08c6191721a9938a70810777082b7b5d66_655_661__994_1000",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 15
            },
            "BRANCH": {
                "missed": 1,
                "covered": 5
            },
            "LINE": {
                "missed": 0,
                "covered": 3
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 3
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tprivate determineLogLevel() : String extracted from public reconfigureLoggingForAnt(antProject Project) : Level in class net.sourceforge.pmd.ant.internal.Slf4jSimpleConfigurationForAnt & moved to class net.sourceforge.pmd.ant.internal.Slf4jSimpleConfigurationForAnt.SimpleLoggerToAntBridge",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/ant/internal/Slf4jSimpleConfigurationForAnt.java",
                "startLine": 48,
                "endLine": 110,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/ant/internal/Slf4jSimpleConfigurationForAnt.java",
                "startLine": 36,
                "endLine": 59,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/ant/internal/Slf4jSimpleConfigurationForAnt.java",
                "startLine": 94,
                "endLine": 102,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@SuppressWarnings(\"PMD.CloseResource\")\n    public static Level reconfigureLoggingForAnt(Project antProject) {\n        PrintStream original = System.err;\n        try {\n            PrintStream interceptedStream = new PrintStream(original) {\n                private StringBuilder buffer = new StringBuilder(100);\n\n                @Override\n                public void println(String x) {\n                    buffer.append(x).append(System.lineSeparator());\n                }\n\n                @Override\n                public void flush() {\n                    String logLevel = determineLogLevel();\n                    int antLogLevel = ANT_LOG_LEVELS.getOrDefault(logLevel, Project.MSG_INFO);\n                    antProject.log(buffer.toString(), antLogLevel);\n                    buffer.setLength(0);\n                }\n\n                private String determineLogLevel() {\n                    int firstSpace = buffer.indexOf(\" \");\n                    if (firstSpace != -1) {\n                        String level = buffer.substring(0, firstSpace);\n                        buffer.delete(0, firstSpace + 1);\n                        return level;\n                    }\n                    return DEFAULT_LEVEL.name();\n                }\n            };\n            System.setErr(interceptedStream);\n\n            Level level = getAntLogLevel(antProject);\n            System.setProperty(\"org.slf4j.simpleLogger.defaultLogLevel\", level.toString());\n            System.setProperty(\"org.slf4j.simpleLogger.showDateTime\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.showThreadName\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.showThreadId\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.levelInBrackets\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.cacheOutputStream\", \"true\");\n            System.setProperty(\"org.slf4j.simpleLogger.logFile\", \"System.err\");\n\n            // Call SimpleLogger.init() by reflection.\n            // Alternatively: move the CLI related classes into an own module, add\n            // slf4j-simple as a compile dependency and create a PmdSlf4jSimpleFriend class in\n            // the package org.slf4j.simple to gain access to this package-private init method.\n            ILoggerFactory loggerFactory = LoggerFactory.getILoggerFactory();\n            Class<? extends ILoggerFactory> loggerFactoryClass = loggerFactory.getClass();\n            try {\n                Class<?> simpleLoggerClass = loggerFactoryClass.getClassLoader().loadClass(\"org.slf4j.simple.SimpleLogger\");\n                Method initMethod = simpleLoggerClass.getDeclaredMethod(\"init\");\n                initMethod.setAccessible(true);\n                initMethod.invoke(null);\n            } catch (ReflectiveOperationException ex) {\n                original.println(\"Error while initializing logging: \" + ex);\n            }\n\n            LoggerFactoryFriend.reset();\n\n            return level;\n        } finally {\n            System.setErr(original);\n        }\n    }",
        "filePathBefore": "pmd-core/src/main/java/net/sourceforge/pmd/ant/internal/Slf4jSimpleConfigurationForAnt.java",
        "isPureRefactoring": true,
        "commitId": "cfbb14c91c24b1a50cf4b41cd855fd780375a14f",
        "packageNameBefore": "net.sourceforge.pmd.ant.internal",
        "classNameBefore": "net.sourceforge.pmd.ant.internal.Slf4jSimpleConfigurationForAnt",
        "methodNameBefore": "net.sourceforge.pmd.ant.internal.Slf4jSimpleConfigurationForAnt#reconfigureLoggingForAnt",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.ant.internal.Slf4jSimpleConfigurationForAnt#getAntLogLevel\n methodBody: private static Level getAntLogLevel(Project project) {\nfor(final BuildListener l: project.getBuildListeners()){Field declaredField=null;\ntryif(l instanceof DefaultLogger){declaredField=DefaultLogger.class.getDeclaredField(\"msgOutputLevel\");\n}if(l instanceof XmlLogger){declaredField=XmlLogger.class.getDeclaredField(\"msgOutputLevel\");\n}if(l instanceof RecorderEntry){declaredField=RecorderEntry.class.getDeclaredField(\"loglevel\");\n}if(\"org.gradle.api.internal.project.ant.AntLoggingAdapter\".equals(l.getClass().getName())){return determineGradleLogLevel(project,l);\n}{trydeclaredField=l.getClass().getDeclaredField(\"logLevel\");\nif(declaredField.getType() != Integer.class && declaredField.getType() != int.class){declaredField=null;\nproject.log(\"Unsupported build listener: \" + l.getClass(),Project.MSG_DEBUG);\n}catch(final NoSuchFieldException e)project.log(\"Unsupported build listener: \" + l.getClass(),Project.MSG_DEBUG);\n}if(declaredField != null){declaredField.setAccessible(true);\nreturn LOG_LEVELS[declaredField.getInt(l)];\n}catch(final ReflectiveOperationException ignored)}project.log(\"Could not determine ant log level, no supported build listeners found. \" + \"Log level is set to \" + DEFAULT_LEVEL,Project.MSG_WARN);\nreturn DEFAULT_LEVEL;\n}",
        "classSignatureBefore": "public final class Slf4jSimpleConfigurationForAnt ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.ant.internal.Slf4jSimpleConfigurationForAnt#reconfigureLoggingForAnt"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.ant.internal.Slf4jSimpleConfigurationForAnt"
        ],
        "classSignatureBeforeSet": [
            "public final class Slf4jSimpleConfigurationForAnt "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.ant.internal;\n\nimport java.io.PrintStream;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.tools.ant.BuildListener;\nimport org.apache.tools.ant.DefaultLogger;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.XmlLogger;\nimport org.apache.tools.ant.taskdefs.RecorderEntry;\nimport org.slf4j.ILoggerFactory;\nimport org.slf4j.LoggerFactory;\nimport org.slf4j.LoggerFactoryFriend;\nimport org.slf4j.event.Level;\n\npublic final class Slf4jSimpleConfigurationForAnt {\n    private Slf4jSimpleConfigurationForAnt() { }\n\n    private static final Level DEFAULT_LEVEL = Level.INFO;\n\n    // Maps from ant's Project.MSG_* to org.slf4j.event.Level\n    private static final Level[] LOG_LEVELS = {\n        Level.ERROR,   // Project.MSG_ERR=0\n        Level.WARN,    // Project.MSG_WARN=1\n        Level.INFO,    // Project.MSG_INFO=2\n        Level.DEBUG,   // Project.MSG_VERBOSE=3\n        Level.TRACE,   // Project.MSG_DEBUG=4\n    };\n\n    private static final Map<String, Integer> ANT_LOG_LEVELS;\n\n    static {\n        ANT_LOG_LEVELS = new HashMap<>();\n        ANT_LOG_LEVELS.put(Level.ERROR.name(), Project.MSG_ERR);\n        ANT_LOG_LEVELS.put(Level.WARN.name(), Project.MSG_WARN);\n        ANT_LOG_LEVELS.put(Level.INFO.name(), Project.MSG_INFO);\n        ANT_LOG_LEVELS.put(Level.DEBUG.name(), Project.MSG_VERBOSE);\n        ANT_LOG_LEVELS.put(Level.TRACE.name(), Project.MSG_DEBUG);\n    }\n\n    @SuppressWarnings(\"PMD.CloseResource\")\n    public static Level reconfigureLoggingForAnt(Project antProject) {\n        PrintStream original = System.err;\n        try {\n            PrintStream interceptedStream = new PrintStream(original) {\n                private StringBuilder buffer = new StringBuilder(100);\n\n                @Override\n                public void println(String x) {\n                    buffer.append(x).append(System.lineSeparator());\n                }\n\n                @Override\n                public void flush() {\n                    String logLevel = determineLogLevel();\n                    int antLogLevel = ANT_LOG_LEVELS.getOrDefault(logLevel, Project.MSG_INFO);\n                    antProject.log(buffer.toString(), antLogLevel);\n                    buffer.setLength(0);\n                }\n\n                private String determineLogLevel() {\n                    int firstSpace = buffer.indexOf(\" \");\n                    if (firstSpace != -1) {\n                        String level = buffer.substring(0, firstSpace);\n                        buffer.delete(0, firstSpace + 1);\n                        return level;\n                    }\n                    return DEFAULT_LEVEL.name();\n                }\n            };\n            System.setErr(interceptedStream);\n\n            Level level = getAntLogLevel(antProject);\n            System.setProperty(\"org.slf4j.simpleLogger.defaultLogLevel\", level.toString());\n            System.setProperty(\"org.slf4j.simpleLogger.showDateTime\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.showThreadName\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.showThreadId\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.levelInBrackets\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.cacheOutputStream\", \"true\");\n            System.setProperty(\"org.slf4j.simpleLogger.logFile\", \"System.err\");\n\n            // Call SimpleLogger.init() by reflection.\n            // Alternatively: move the CLI related classes into an own module, add\n            // slf4j-simple as a compile dependency and create a PmdSlf4jSimpleFriend class in\n            // the package org.slf4j.simple to gain access to this package-private init method.\n            ILoggerFactory loggerFactory = LoggerFactory.getILoggerFactory();\n            Class<? extends ILoggerFactory> loggerFactoryClass = loggerFactory.getClass();\n            try {\n                Class<?> simpleLoggerClass = loggerFactoryClass.getClassLoader().loadClass(\"org.slf4j.simple.SimpleLogger\");\n                Method initMethod = simpleLoggerClass.getDeclaredMethod(\"init\");\n                initMethod.setAccessible(true);\n                initMethod.invoke(null);\n            } catch (ReflectiveOperationException ex) {\n                original.println(\"Error while initializing logging: \" + ex);\n            }\n\n            LoggerFactoryFriend.reset();\n\n            return level;\n        } finally {\n            System.setErr(original);\n        }\n    }\n\n    @SuppressWarnings(\"PMD.AvoidAccessibilityAlteration\")\n    private static Level getAntLogLevel(Project project) {\n        for (final BuildListener l : project.getBuildListeners()) {\n            Field declaredField = null;\n            try {\n                if (l instanceof DefaultLogger) {\n                    declaredField = DefaultLogger.class.getDeclaredField(\"msgOutputLevel\");\n                } else if (l instanceof XmlLogger) {\n                    declaredField = XmlLogger.class.getDeclaredField(\"msgOutputLevel\");\n                } else if (l instanceof RecorderEntry) {\n                    declaredField = RecorderEntry.class.getDeclaredField(\"loglevel\");\n                } else if (\"org.gradle.api.internal.project.ant.AntLoggingAdapter\".equals(l.getClass().getName())) {\n                    return determineGradleLogLevel(project, l);\n                } else {\n                    try {\n                        declaredField = l.getClass().getDeclaredField(\"logLevel\");\n                        if (declaredField.getType() != Integer.class && declaredField.getType() != int.class) {\n                            declaredField = null;\n                            project.log(\"Unsupported build listener: \" + l.getClass(), Project.MSG_DEBUG);\n                        }\n                    } catch (final NoSuchFieldException e) {\n                        project.log(\"Unsupported build listener: \" + l.getClass(), Project.MSG_DEBUG);\n                    }\n                }\n\n                if (declaredField != null) {\n                    declaredField.setAccessible(true);\n                    return LOG_LEVELS[declaredField.getInt(l)];\n                }\n\n            } catch (final ReflectiveOperationException ignored) {\n                // Just ignore it\n            }\n        }\n\n        project.log(\"Could not determine ant log level, no supported build listeners found. \"\n                + \"Log level is set to \" + DEFAULT_LEVEL, Project.MSG_WARN);\n\n        return DEFAULT_LEVEL;\n    }\n\n    @SuppressWarnings(\"PMD.AvoidAccessibilityAlteration\")\n    private static Level determineGradleLogLevel(Project project, BuildListener l) {\n        try {\n            project.log(\"Detected gradle AntLoggingAdapter\", Project.MSG_DEBUG);\n            Field loggerField = l.getClass().getDeclaredField(\"logger\");\n            loggerField.setAccessible(true);\n            // org.gradle.internal.logging.slf4j.OutputEventListenerBackedLogger\n            Object logger = loggerField.get(l);\n\n            Class<?> gradleLogLevel = l.getClass().getClassLoader().loadClass(\"org.gradle.api.logging.LogLevel\");\n\n            Method isLevelAtMostMethod = logger.getClass().getDeclaredMethod(\"isLevelAtMost\", gradleLogLevel);\n            isLevelAtMostMethod.setAccessible(true);\n\n            Object[] logLevels = gradleLogLevel.getEnumConstants();\n            // the log levels in gradle are declared in the order DEBUG, INFO, LIFECYCLE, WARN, QUIET, ERROR\n            Level[] mapping = new Level[] {\n                Level.TRACE,   // DEBUG\n                Level.DEBUG,   // INFO\n                Level.INFO,     // LIFECYCLE\n                Level.WARN,  // WARN\n                Level.ERROR,   // QUIET\n                Level.ERROR,   // ERROR\n            };\n\n            for (int i = 0; i < Math.min(logLevels.length, mapping.length); i++) {\n                boolean enabled = (boolean) isLevelAtMostMethod.invoke(logger, logLevels[i]);\n                if (enabled) {\n                    project.log(\"Current log level: \" + logLevels[i] + \" -> \" + mapping[i], Project.MSG_DEBUG);\n                    return mapping[i];\n                }\n            }\n        } catch (ReflectiveOperationException ignored) {\n            // ignored\n        }\n        project.log(\"Could not determine log level, falling back to default: \" + DEFAULT_LEVEL, Project.MSG_WARN);\n        return DEFAULT_LEVEL;\n    }\n\n}\n",
        "filePathAfter": "pmd-core/src/main/java/net/sourceforge/pmd/ant/internal/Slf4jSimpleConfigurationForAnt.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.ant.internal;\n\nimport java.io.PrintStream;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.tools.ant.BuildListener;\nimport org.apache.tools.ant.DefaultLogger;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.XmlLogger;\nimport org.apache.tools.ant.taskdefs.RecorderEntry;\nimport org.slf4j.event.Level;\n\nimport net.sourceforge.pmd.internal.Slf4jSimpleConfiguration;\n\npublic final class Slf4jSimpleConfigurationForAnt {\n    private Slf4jSimpleConfigurationForAnt() { }\n\n    private static final Level DEFAULT_LEVEL = Level.INFO;\n\n    // Maps from ant's Project.MSG_* to org.slf4j.event.Level\n    private static final Level[] LOG_LEVELS = {\n        Level.ERROR,   // Project.MSG_ERR=0\n        Level.WARN,    // Project.MSG_WARN=1\n        Level.INFO,    // Project.MSG_INFO=2\n        Level.DEBUG,   // Project.MSG_VERBOSE=3\n        Level.TRACE,   // Project.MSG_DEBUG=4\n    };\n\n    @SuppressWarnings(\"PMD.CloseResource\")\n    public static Level reconfigureLoggingForAnt(Project antProject) {\n        PrintStream original = System.err;\n        try {\n            System.setErr(new SimpleLoggerToAntBridge(antProject, original));\n\n            // configuring the format so that the log level appears at the beginning of the printed line\n            System.setProperty(\"org.slf4j.simpleLogger.showDateTime\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.showThreadName\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.showThreadId\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.levelInBrackets\", \"false\");\n\n            // using cacheOutputStream so that we can restore System.err after SimpleLogger has been initialized\n            System.setProperty(\"org.slf4j.simpleLogger.cacheOutputStream\", \"true\");\n            System.setProperty(\"org.slf4j.simpleLogger.logFile\", \"System.err\");\n\n            Level level = getAntLogLevel(antProject);\n            Slf4jSimpleConfiguration.reconfigureDefaultLogLevel(level);\n\n            return level;\n        } finally {\n            System.setErr(original);\n        }\n    }\n\n    private static final class SimpleLoggerToAntBridge extends PrintStream {\n        private static final Map<String, Integer> ANT_LOG_LEVELS;\n\n        static {\n            ANT_LOG_LEVELS = new HashMap<>();\n            ANT_LOG_LEVELS.put(Level.ERROR.name(), Project.MSG_ERR);\n            ANT_LOG_LEVELS.put(Level.WARN.name(), Project.MSG_WARN);\n            ANT_LOG_LEVELS.put(Level.INFO.name(), Project.MSG_INFO);\n            ANT_LOG_LEVELS.put(Level.DEBUG.name(), Project.MSG_VERBOSE);\n            ANT_LOG_LEVELS.put(Level.TRACE.name(), Project.MSG_DEBUG);\n        }\n\n        private final StringBuilder buffer = new StringBuilder(100);\n        private final Project antProject;\n\n        SimpleLoggerToAntBridge(Project antProject, PrintStream original) {\n            super(original);\n            this.antProject = antProject;\n        }\n\n        @Override\n        public void println(String x) {\n            buffer.append(x).append(System.lineSeparator());\n        }\n\n        @Override\n        public void flush() {\n            String logLevel = determineLogLevel();\n            int antLogLevel = ANT_LOG_LEVELS.getOrDefault(logLevel, Project.MSG_INFO);\n            antProject.log(buffer.toString(), antLogLevel);\n            buffer.setLength(0);\n        }\n\n        private String determineLogLevel() {\n            int firstSpace = buffer.indexOf(\" \");\n            if (firstSpace != -1) {\n                String level = buffer.substring(0, firstSpace);\n                buffer.delete(0, firstSpace + 1);\n                return level;\n            }\n            return DEFAULT_LEVEL.name();\n        }\n    }\n\n    @SuppressWarnings(\"PMD.AvoidAccessibilityAlteration\")\n    private static Level getAntLogLevel(Project project) {\n        for (final BuildListener l : project.getBuildListeners()) {\n            Field declaredField = null;\n            try {\n                if (l instanceof DefaultLogger) {\n                    declaredField = DefaultLogger.class.getDeclaredField(\"msgOutputLevel\");\n                } else if (l instanceof XmlLogger) {\n                    declaredField = XmlLogger.class.getDeclaredField(\"msgOutputLevel\");\n                } else if (l instanceof RecorderEntry) {\n                    declaredField = RecorderEntry.class.getDeclaredField(\"loglevel\");\n                } else if (\"org.gradle.api.internal.project.ant.AntLoggingAdapter\".equals(l.getClass().getName())) {\n                    return determineGradleLogLevel(project, l);\n                } else {\n                    try {\n                        declaredField = l.getClass().getDeclaredField(\"logLevel\");\n                        if (declaredField.getType() != Integer.class && declaredField.getType() != int.class) {\n                            declaredField = null;\n                            project.log(\"Unsupported build listener: \" + l.getClass(), Project.MSG_DEBUG);\n                        }\n                    } catch (final NoSuchFieldException e) {\n                        project.log(\"Unsupported build listener: \" + l.getClass(), Project.MSG_DEBUG);\n                    }\n                }\n\n                if (declaredField != null) {\n                    declaredField.setAccessible(true);\n                    return LOG_LEVELS[declaredField.getInt(l)];\n                }\n\n            } catch (final ReflectiveOperationException ignored) {\n                // Just ignore it\n            }\n        }\n\n        project.log(\"Could not determine ant log level, no supported build listeners found. \"\n                + \"Log level is set to \" + DEFAULT_LEVEL, Project.MSG_WARN);\n\n        return DEFAULT_LEVEL;\n    }\n\n    @SuppressWarnings(\"PMD.AvoidAccessibilityAlteration\")\n    private static Level determineGradleLogLevel(Project project, BuildListener l) {\n        try {\n            project.log(\"Detected gradle AntLoggingAdapter\", Project.MSG_DEBUG);\n            Field loggerField = l.getClass().getDeclaredField(\"logger\");\n            loggerField.setAccessible(true);\n            // org.gradle.internal.logging.slf4j.OutputEventListenerBackedLogger\n            Object logger = loggerField.get(l);\n\n            Class<?> gradleLogLevel = l.getClass().getClassLoader().loadClass(\"org.gradle.api.logging.LogLevel\");\n\n            Method isLevelAtMostMethod = logger.getClass().getDeclaredMethod(\"isLevelAtMost\", gradleLogLevel);\n            isLevelAtMostMethod.setAccessible(true);\n\n            Object[] logLevels = gradleLogLevel.getEnumConstants();\n            // the log levels in gradle are declared in the order DEBUG, INFO, LIFECYCLE, WARN, QUIET, ERROR\n            Level[] mapping = new Level[] {\n                Level.TRACE,   // DEBUG\n                Level.DEBUG,   // INFO\n                Level.INFO,     // LIFECYCLE\n                Level.WARN,  // WARN\n                Level.ERROR,   // QUIET\n                Level.ERROR,   // ERROR\n            };\n\n            for (int i = 0; i < Math.min(logLevels.length, mapping.length); i++) {\n                boolean enabled = (boolean) isLevelAtMostMethod.invoke(logger, logLevels[i]);\n                if (enabled) {\n                    project.log(\"Current log level: \" + logLevels[i] + \" -> \" + mapping[i], Project.MSG_DEBUG);\n                    return mapping[i];\n                }\n            }\n        } catch (ReflectiveOperationException ignored) {\n            // ignored\n        }\n        project.log(\"Could not determine log level, falling back to default: \" + DEFAULT_LEVEL, Project.MSG_WARN);\n        return DEFAULT_LEVEL;\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "private String determineLogLevel() {\n            int firstSpace = buffer.indexOf(\" \");\n            if (firstSpace != -1) {\n                String level = buffer.substring(0, firstSpace);\n                buffer.delete(0, firstSpace + 1);\n                return level;\n            }\n            return DEFAULT_LEVEL.name();\n        }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.ant.internal.Slf4jSimpleConfigurationForAnt#getAntLogLevel\n methodBody: private static Level getAntLogLevel(Project project) {\nfor(final BuildListener l: project.getBuildListeners()){Field declaredField=null;\ntryif(l instanceof DefaultLogger){declaredField=DefaultLogger.class.getDeclaredField(\"msgOutputLevel\");\n}if(l instanceof XmlLogger){declaredField=XmlLogger.class.getDeclaredField(\"msgOutputLevel\");\n}if(l instanceof RecorderEntry){declaredField=RecorderEntry.class.getDeclaredField(\"loglevel\");\n}if(\"org.gradle.api.internal.project.ant.AntLoggingAdapter\".equals(l.getClass().getName())){return determineGradleLogLevel(project,l);\n}{trydeclaredField=l.getClass().getDeclaredField(\"logLevel\");\nif(declaredField.getType() != Integer.class && declaredField.getType() != int.class){declaredField=null;\nproject.log(\"Unsupported build listener: \" + l.getClass(),Project.MSG_DEBUG);\n}catch(final NoSuchFieldException e)project.log(\"Unsupported build listener: \" + l.getClass(),Project.MSG_DEBUG);\n}if(declaredField != null){declaredField.setAccessible(true);\nreturn LOG_LEVELS[declaredField.getInt(l)];\n}catch(final ReflectiveOperationException ignored)}project.log(\"Could not determine ant log level, no supported build listeners found. \" + \"Log level is set to \" + DEFAULT_LEVEL,Project.MSG_WARN);\nreturn DEFAULT_LEVEL;\n}"
        ],
        "sourceCodeAfterRefactoring": "@SuppressWarnings(\"PMD.CloseResource\")\n    public static Level reconfigureLoggingForAnt(Project antProject) {\n        PrintStream original = System.err;\n        try {\n            System.setErr(new SimpleLoggerToAntBridge(antProject, original));\n\n            // configuring the format so that the log level appears at the beginning of the printed line\n            System.setProperty(\"org.slf4j.simpleLogger.showDateTime\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.showThreadName\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.showThreadId\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.levelInBrackets\", \"false\");\n\n            // using cacheOutputStream so that we can restore System.err after SimpleLogger has been initialized\n            System.setProperty(\"org.slf4j.simpleLogger.cacheOutputStream\", \"true\");\n            System.setProperty(\"org.slf4j.simpleLogger.logFile\", \"System.err\");\n\n            Level level = getAntLogLevel(antProject);\n            Slf4jSimpleConfiguration.reconfigureDefaultLogLevel(level);\n\n            return level;\n        } finally {\n            System.setErr(original);\n        }\n    }\nprivate String determineLogLevel() {\n            int firstSpace = buffer.indexOf(\" \");\n            if (firstSpace != -1) {\n                String level = buffer.substring(0, firstSpace);\n                buffer.delete(0, firstSpace + 1);\n                return level;\n            }\n            return DEFAULT_LEVEL.name();\n        }",
        "diffSourceCode": "-   36: \n-   37:     private static final Map<String, Integer> ANT_LOG_LEVELS;\n-   38: \n-   39:     static {\n-   40:         ANT_LOG_LEVELS = new HashMap<>();\n-   41:         ANT_LOG_LEVELS.put(Level.ERROR.name(), Project.MSG_ERR);\n-   42:         ANT_LOG_LEVELS.put(Level.WARN.name(), Project.MSG_WARN);\n-   43:         ANT_LOG_LEVELS.put(Level.INFO.name(), Project.MSG_INFO);\n-   44:         ANT_LOG_LEVELS.put(Level.DEBUG.name(), Project.MSG_VERBOSE);\n-   45:         ANT_LOG_LEVELS.put(Level.TRACE.name(), Project.MSG_DEBUG);\n-   46:     }\n+   36:     @SuppressWarnings(\"PMD.CloseResource\")\n+   37:     public static Level reconfigureLoggingForAnt(Project antProject) {\n+   38:         PrintStream original = System.err;\n+   39:         try {\n+   40:             System.setErr(new SimpleLoggerToAntBridge(antProject, original));\n+   41: \n+   42:             // configuring the format so that the log level appears at the beginning of the printed line\n+   43:             System.setProperty(\"org.slf4j.simpleLogger.showDateTime\", \"false\");\n+   44:             System.setProperty(\"org.slf4j.simpleLogger.showThreadName\", \"false\");\n+   45:             System.setProperty(\"org.slf4j.simpleLogger.showThreadId\", \"false\");\n+   46:             System.setProperty(\"org.slf4j.simpleLogger.levelInBrackets\", \"false\");\n    47: \n-   48:     @SuppressWarnings(\"PMD.CloseResource\")\n-   49:     public static Level reconfigureLoggingForAnt(Project antProject) {\n-   50:         PrintStream original = System.err;\n-   51:         try {\n-   52:             PrintStream interceptedStream = new PrintStream(original) {\n-   53:                 private StringBuilder buffer = new StringBuilder(100);\n+   48:             // using cacheOutputStream so that we can restore System.err after SimpleLogger has been initialized\n+   49:             System.setProperty(\"org.slf4j.simpleLogger.cacheOutputStream\", \"true\");\n+   50:             System.setProperty(\"org.slf4j.simpleLogger.logFile\", \"System.err\");\n+   51: \n+   52:             Level level = getAntLogLevel(antProject);\n+   53:             Slf4jSimpleConfiguration.reconfigureDefaultLogLevel(level);\n    54: \n-   55:                 @Override\n-   56:                 public void println(String x) {\n-   57:                     buffer.append(x).append(System.lineSeparator());\n-   58:                 }\n-   59: \n-   60:                 @Override\n-   61:                 public void flush() {\n-   62:                     String logLevel = determineLogLevel();\n-   63:                     int antLogLevel = ANT_LOG_LEVELS.getOrDefault(logLevel, Project.MSG_INFO);\n-   64:                     antProject.log(buffer.toString(), antLogLevel);\n-   65:                     buffer.setLength(0);\n-   66:                 }\n-   67: \n-   68:                 private String determineLogLevel() {\n-   69:                     int firstSpace = buffer.indexOf(\" \");\n-   70:                     if (firstSpace != -1) {\n-   71:                         String level = buffer.substring(0, firstSpace);\n-   72:                         buffer.delete(0, firstSpace + 1);\n-   73:                         return level;\n-   74:                     }\n-   75:                     return DEFAULT_LEVEL.name();\n-   76:                 }\n-   77:             };\n-   78:             System.setErr(interceptedStream);\n-   79: \n-   80:             Level level = getAntLogLevel(antProject);\n-   81:             System.setProperty(\"org.slf4j.simpleLogger.defaultLogLevel\", level.toString());\n-   82:             System.setProperty(\"org.slf4j.simpleLogger.showDateTime\", \"false\");\n-   83:             System.setProperty(\"org.slf4j.simpleLogger.showThreadName\", \"false\");\n-   84:             System.setProperty(\"org.slf4j.simpleLogger.showThreadId\", \"false\");\n-   85:             System.setProperty(\"org.slf4j.simpleLogger.levelInBrackets\", \"false\");\n-   86:             System.setProperty(\"org.slf4j.simpleLogger.cacheOutputStream\", \"true\");\n-   87:             System.setProperty(\"org.slf4j.simpleLogger.logFile\", \"System.err\");\n-   88: \n-   89:             // Call SimpleLogger.init() by reflection.\n-   90:             // Alternatively: move the CLI related classes into an own module, add\n-   91:             // slf4j-simple as a compile dependency and create a PmdSlf4jSimpleFriend class in\n-   92:             // the package org.slf4j.simple to gain access to this package-private init method.\n-   93:             ILoggerFactory loggerFactory = LoggerFactory.getILoggerFactory();\n-   94:             Class<? extends ILoggerFactory> loggerFactoryClass = loggerFactory.getClass();\n-   95:             try {\n-   96:                 Class<?> simpleLoggerClass = loggerFactoryClass.getClassLoader().loadClass(\"org.slf4j.simple.SimpleLogger\");\n-   97:                 Method initMethod = simpleLoggerClass.getDeclaredMethod(\"init\");\n-   98:                 initMethod.setAccessible(true);\n-   99:                 initMethod.invoke(null);\n-  100:             } catch (ReflectiveOperationException ex) {\n-  101:                 original.println(\"Error while initializing logging: \" + ex);\n-  102:             }\n-  103: \n-  104:             LoggerFactoryFriend.reset();\n-  105: \n-  106:             return level;\n-  107:         } finally {\n-  108:             System.setErr(original);\n-  109:         }\n-  110:     }\n+   55:             return level;\n+   56:         } finally {\n+   57:             System.setErr(original);\n+   58:         }\n+   59:     }\n+   60: \n+   61:     private static final class SimpleLoggerToAntBridge extends PrintStream {\n+   62:         private static final Map<String, Integer> ANT_LOG_LEVELS;\n+   63: \n+   64:         static {\n+   65:             ANT_LOG_LEVELS = new HashMap<>();\n+   66:             ANT_LOG_LEVELS.put(Level.ERROR.name(), Project.MSG_ERR);\n+   67:             ANT_LOG_LEVELS.put(Level.WARN.name(), Project.MSG_WARN);\n+   68:             ANT_LOG_LEVELS.put(Level.INFO.name(), Project.MSG_INFO);\n+   69:             ANT_LOG_LEVELS.put(Level.DEBUG.name(), Project.MSG_VERBOSE);\n+   70:             ANT_LOG_LEVELS.put(Level.TRACE.name(), Project.MSG_DEBUG);\n+   71:         }\n+   72: \n+   73:         private final StringBuilder buffer = new StringBuilder(100);\n+   74:         private final Project antProject;\n+   75: \n+   76:         SimpleLoggerToAntBridge(Project antProject, PrintStream original) {\n+   77:             super(original);\n+   78:             this.antProject = antProject;\n+   79:         }\n+   80: \n+   81:         @Override\n+   82:         public void println(String x) {\n+   83:             buffer.append(x).append(System.lineSeparator());\n+   84:         }\n+   85: \n+   86:         @Override\n+   87:         public void flush() {\n+   88:             String logLevel = determineLogLevel();\n+   89:             int antLogLevel = ANT_LOG_LEVELS.getOrDefault(logLevel, Project.MSG_INFO);\n+   90:             antProject.log(buffer.toString(), antLogLevel);\n+   91:             buffer.setLength(0);\n+   92:         }\n+   93: \n+   94:         private String determineLogLevel() {\n+   95:             int firstSpace = buffer.indexOf(\" \");\n+   96:             if (firstSpace != -1) {\n+   97:                 String level = buffer.substring(0, firstSpace);\n+   98:                 buffer.delete(0, firstSpace + 1);\n+   99:                 return level;\n+  100:             }\n+  101:             return DEFAULT_LEVEL.name();\n+  102:         }\n+  103:     }\n+  104: \n+  105:     @SuppressWarnings(\"PMD.AvoidAccessibilityAlteration\")\n+  106:     private static Level getAntLogLevel(Project project) {\n+  107:         for (final BuildListener l : project.getBuildListeners()) {\n+  108:             Field declaredField = null;\n+  109:             try {\n+  110:                 if (l instanceof DefaultLogger) {\n",
        "uniqueId": "cfbb14c91c24b1a50cf4b41cd855fd780375a14f_48_110_94_102_36_59",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 2,
                "covered": 45
            },
            "BRANCH": {
                "missed": 1,
                "covered": 1
            },
            "LINE": {
                "missed": 1,
                "covered": 13
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic flush() : void extracted from public reconfigureLoggingForAnt(antProject Project) : Level in class net.sourceforge.pmd.ant.internal.Slf4jSimpleConfigurationForAnt & moved to class net.sourceforge.pmd.ant.internal.Slf4jSimpleConfigurationForAnt.SimpleLoggerToAntBridge",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/ant/internal/Slf4jSimpleConfigurationForAnt.java",
                "startLine": 48,
                "endLine": 110,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/ant/internal/Slf4jSimpleConfigurationForAnt.java",
                "startLine": 36,
                "endLine": 59,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/ant/internal/Slf4jSimpleConfigurationForAnt.java",
                "startLine": 86,
                "endLine": 92,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@SuppressWarnings(\"PMD.CloseResource\")\n    public static Level reconfigureLoggingForAnt(Project antProject) {\n        PrintStream original = System.err;\n        try {\n            PrintStream interceptedStream = new PrintStream(original) {\n                private StringBuilder buffer = new StringBuilder(100);\n\n                @Override\n                public void println(String x) {\n                    buffer.append(x).append(System.lineSeparator());\n                }\n\n                @Override\n                public void flush() {\n                    String logLevel = determineLogLevel();\n                    int antLogLevel = ANT_LOG_LEVELS.getOrDefault(logLevel, Project.MSG_INFO);\n                    antProject.log(buffer.toString(), antLogLevel);\n                    buffer.setLength(0);\n                }\n\n                private String determineLogLevel() {\n                    int firstSpace = buffer.indexOf(\" \");\n                    if (firstSpace != -1) {\n                        String level = buffer.substring(0, firstSpace);\n                        buffer.delete(0, firstSpace + 1);\n                        return level;\n                    }\n                    return DEFAULT_LEVEL.name();\n                }\n            };\n            System.setErr(interceptedStream);\n\n            Level level = getAntLogLevel(antProject);\n            System.setProperty(\"org.slf4j.simpleLogger.defaultLogLevel\", level.toString());\n            System.setProperty(\"org.slf4j.simpleLogger.showDateTime\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.showThreadName\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.showThreadId\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.levelInBrackets\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.cacheOutputStream\", \"true\");\n            System.setProperty(\"org.slf4j.simpleLogger.logFile\", \"System.err\");\n\n            // Call SimpleLogger.init() by reflection.\n            // Alternatively: move the CLI related classes into an own module, add\n            // slf4j-simple as a compile dependency and create a PmdSlf4jSimpleFriend class in\n            // the package org.slf4j.simple to gain access to this package-private init method.\n            ILoggerFactory loggerFactory = LoggerFactory.getILoggerFactory();\n            Class<? extends ILoggerFactory> loggerFactoryClass = loggerFactory.getClass();\n            try {\n                Class<?> simpleLoggerClass = loggerFactoryClass.getClassLoader().loadClass(\"org.slf4j.simple.SimpleLogger\");\n                Method initMethod = simpleLoggerClass.getDeclaredMethod(\"init\");\n                initMethod.setAccessible(true);\n                initMethod.invoke(null);\n            } catch (ReflectiveOperationException ex) {\n                original.println(\"Error while initializing logging: \" + ex);\n            }\n\n            LoggerFactoryFriend.reset();\n\n            return level;\n        } finally {\n            System.setErr(original);\n        }\n    }",
        "filePathBefore": "pmd-core/src/main/java/net/sourceforge/pmd/ant/internal/Slf4jSimpleConfigurationForAnt.java",
        "isPureRefactoring": true,
        "commitId": "cfbb14c91c24b1a50cf4b41cd855fd780375a14f",
        "packageNameBefore": "net.sourceforge.pmd.ant.internal",
        "classNameBefore": "net.sourceforge.pmd.ant.internal.Slf4jSimpleConfigurationForAnt",
        "methodNameBefore": "net.sourceforge.pmd.ant.internal.Slf4jSimpleConfigurationForAnt#reconfigureLoggingForAnt",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.ant.internal.Slf4jSimpleConfigurationForAnt#getAntLogLevel\n methodBody: private static Level getAntLogLevel(Project project) {\nfor(final BuildListener l: project.getBuildListeners()){Field declaredField=null;\ntryif(l instanceof DefaultLogger){declaredField=DefaultLogger.class.getDeclaredField(\"msgOutputLevel\");\n}if(l instanceof XmlLogger){declaredField=XmlLogger.class.getDeclaredField(\"msgOutputLevel\");\n}if(l instanceof RecorderEntry){declaredField=RecorderEntry.class.getDeclaredField(\"loglevel\");\n}if(\"org.gradle.api.internal.project.ant.AntLoggingAdapter\".equals(l.getClass().getName())){return determineGradleLogLevel(project,l);\n}{trydeclaredField=l.getClass().getDeclaredField(\"logLevel\");\nif(declaredField.getType() != Integer.class && declaredField.getType() != int.class){declaredField=null;\nproject.log(\"Unsupported build listener: \" + l.getClass(),Project.MSG_DEBUG);\n}catch(final NoSuchFieldException e)project.log(\"Unsupported build listener: \" + l.getClass(),Project.MSG_DEBUG);\n}if(declaredField != null){declaredField.setAccessible(true);\nreturn LOG_LEVELS[declaredField.getInt(l)];\n}catch(final ReflectiveOperationException ignored)}project.log(\"Could not determine ant log level, no supported build listeners found. \" + \"Log level is set to \" + DEFAULT_LEVEL,Project.MSG_WARN);\nreturn DEFAULT_LEVEL;\n}",
        "classSignatureBefore": "public final class Slf4jSimpleConfigurationForAnt ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.ant.internal.Slf4jSimpleConfigurationForAnt#reconfigureLoggingForAnt"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.ant.internal.Slf4jSimpleConfigurationForAnt"
        ],
        "classSignatureBeforeSet": [
            "public final class Slf4jSimpleConfigurationForAnt "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.ant.internal;\n\nimport java.io.PrintStream;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.tools.ant.BuildListener;\nimport org.apache.tools.ant.DefaultLogger;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.XmlLogger;\nimport org.apache.tools.ant.taskdefs.RecorderEntry;\nimport org.slf4j.ILoggerFactory;\nimport org.slf4j.LoggerFactory;\nimport org.slf4j.LoggerFactoryFriend;\nimport org.slf4j.event.Level;\n\npublic final class Slf4jSimpleConfigurationForAnt {\n    private Slf4jSimpleConfigurationForAnt() { }\n\n    private static final Level DEFAULT_LEVEL = Level.INFO;\n\n    // Maps from ant's Project.MSG_* to org.slf4j.event.Level\n    private static final Level[] LOG_LEVELS = {\n        Level.ERROR,   // Project.MSG_ERR=0\n        Level.WARN,    // Project.MSG_WARN=1\n        Level.INFO,    // Project.MSG_INFO=2\n        Level.DEBUG,   // Project.MSG_VERBOSE=3\n        Level.TRACE,   // Project.MSG_DEBUG=4\n    };\n\n    private static final Map<String, Integer> ANT_LOG_LEVELS;\n\n    static {\n        ANT_LOG_LEVELS = new HashMap<>();\n        ANT_LOG_LEVELS.put(Level.ERROR.name(), Project.MSG_ERR);\n        ANT_LOG_LEVELS.put(Level.WARN.name(), Project.MSG_WARN);\n        ANT_LOG_LEVELS.put(Level.INFO.name(), Project.MSG_INFO);\n        ANT_LOG_LEVELS.put(Level.DEBUG.name(), Project.MSG_VERBOSE);\n        ANT_LOG_LEVELS.put(Level.TRACE.name(), Project.MSG_DEBUG);\n    }\n\n    @SuppressWarnings(\"PMD.CloseResource\")\n    public static Level reconfigureLoggingForAnt(Project antProject) {\n        PrintStream original = System.err;\n        try {\n            PrintStream interceptedStream = new PrintStream(original) {\n                private StringBuilder buffer = new StringBuilder(100);\n\n                @Override\n                public void println(String x) {\n                    buffer.append(x).append(System.lineSeparator());\n                }\n\n                @Override\n                public void flush() {\n                    String logLevel = determineLogLevel();\n                    int antLogLevel = ANT_LOG_LEVELS.getOrDefault(logLevel, Project.MSG_INFO);\n                    antProject.log(buffer.toString(), antLogLevel);\n                    buffer.setLength(0);\n                }\n\n                private String determineLogLevel() {\n                    int firstSpace = buffer.indexOf(\" \");\n                    if (firstSpace != -1) {\n                        String level = buffer.substring(0, firstSpace);\n                        buffer.delete(0, firstSpace + 1);\n                        return level;\n                    }\n                    return DEFAULT_LEVEL.name();\n                }\n            };\n            System.setErr(interceptedStream);\n\n            Level level = getAntLogLevel(antProject);\n            System.setProperty(\"org.slf4j.simpleLogger.defaultLogLevel\", level.toString());\n            System.setProperty(\"org.slf4j.simpleLogger.showDateTime\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.showThreadName\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.showThreadId\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.levelInBrackets\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.cacheOutputStream\", \"true\");\n            System.setProperty(\"org.slf4j.simpleLogger.logFile\", \"System.err\");\n\n            // Call SimpleLogger.init() by reflection.\n            // Alternatively: move the CLI related classes into an own module, add\n            // slf4j-simple as a compile dependency and create a PmdSlf4jSimpleFriend class in\n            // the package org.slf4j.simple to gain access to this package-private init method.\n            ILoggerFactory loggerFactory = LoggerFactory.getILoggerFactory();\n            Class<? extends ILoggerFactory> loggerFactoryClass = loggerFactory.getClass();\n            try {\n                Class<?> simpleLoggerClass = loggerFactoryClass.getClassLoader().loadClass(\"org.slf4j.simple.SimpleLogger\");\n                Method initMethod = simpleLoggerClass.getDeclaredMethod(\"init\");\n                initMethod.setAccessible(true);\n                initMethod.invoke(null);\n            } catch (ReflectiveOperationException ex) {\n                original.println(\"Error while initializing logging: \" + ex);\n            }\n\n            LoggerFactoryFriend.reset();\n\n            return level;\n        } finally {\n            System.setErr(original);\n        }\n    }\n\n    @SuppressWarnings(\"PMD.AvoidAccessibilityAlteration\")\n    private static Level getAntLogLevel(Project project) {\n        for (final BuildListener l : project.getBuildListeners()) {\n            Field declaredField = null;\n            try {\n                if (l instanceof DefaultLogger) {\n                    declaredField = DefaultLogger.class.getDeclaredField(\"msgOutputLevel\");\n                } else if (l instanceof XmlLogger) {\n                    declaredField = XmlLogger.class.getDeclaredField(\"msgOutputLevel\");\n                } else if (l instanceof RecorderEntry) {\n                    declaredField = RecorderEntry.class.getDeclaredField(\"loglevel\");\n                } else if (\"org.gradle.api.internal.project.ant.AntLoggingAdapter\".equals(l.getClass().getName())) {\n                    return determineGradleLogLevel(project, l);\n                } else {\n                    try {\n                        declaredField = l.getClass().getDeclaredField(\"logLevel\");\n                        if (declaredField.getType() != Integer.class && declaredField.getType() != int.class) {\n                            declaredField = null;\n                            project.log(\"Unsupported build listener: \" + l.getClass(), Project.MSG_DEBUG);\n                        }\n                    } catch (final NoSuchFieldException e) {\n                        project.log(\"Unsupported build listener: \" + l.getClass(), Project.MSG_DEBUG);\n                    }\n                }\n\n                if (declaredField != null) {\n                    declaredField.setAccessible(true);\n                    return LOG_LEVELS[declaredField.getInt(l)];\n                }\n\n            } catch (final ReflectiveOperationException ignored) {\n                // Just ignore it\n            }\n        }\n\n        project.log(\"Could not determine ant log level, no supported build listeners found. \"\n                + \"Log level is set to \" + DEFAULT_LEVEL, Project.MSG_WARN);\n\n        return DEFAULT_LEVEL;\n    }\n\n    @SuppressWarnings(\"PMD.AvoidAccessibilityAlteration\")\n    private static Level determineGradleLogLevel(Project project, BuildListener l) {\n        try {\n            project.log(\"Detected gradle AntLoggingAdapter\", Project.MSG_DEBUG);\n            Field loggerField = l.getClass().getDeclaredField(\"logger\");\n            loggerField.setAccessible(true);\n            // org.gradle.internal.logging.slf4j.OutputEventListenerBackedLogger\n            Object logger = loggerField.get(l);\n\n            Class<?> gradleLogLevel = l.getClass().getClassLoader().loadClass(\"org.gradle.api.logging.LogLevel\");\n\n            Method isLevelAtMostMethod = logger.getClass().getDeclaredMethod(\"isLevelAtMost\", gradleLogLevel);\n            isLevelAtMostMethod.setAccessible(true);\n\n            Object[] logLevels = gradleLogLevel.getEnumConstants();\n            // the log levels in gradle are declared in the order DEBUG, INFO, LIFECYCLE, WARN, QUIET, ERROR\n            Level[] mapping = new Level[] {\n                Level.TRACE,   // DEBUG\n                Level.DEBUG,   // INFO\n                Level.INFO,     // LIFECYCLE\n                Level.WARN,  // WARN\n                Level.ERROR,   // QUIET\n                Level.ERROR,   // ERROR\n            };\n\n            for (int i = 0; i < Math.min(logLevels.length, mapping.length); i++) {\n                boolean enabled = (boolean) isLevelAtMostMethod.invoke(logger, logLevels[i]);\n                if (enabled) {\n                    project.log(\"Current log level: \" + logLevels[i] + \" -> \" + mapping[i], Project.MSG_DEBUG);\n                    return mapping[i];\n                }\n            }\n        } catch (ReflectiveOperationException ignored) {\n            // ignored\n        }\n        project.log(\"Could not determine log level, falling back to default: \" + DEFAULT_LEVEL, Project.MSG_WARN);\n        return DEFAULT_LEVEL;\n    }\n\n}\n",
        "filePathAfter": "pmd-core/src/main/java/net/sourceforge/pmd/ant/internal/Slf4jSimpleConfigurationForAnt.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.ant.internal;\n\nimport java.io.PrintStream;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.tools.ant.BuildListener;\nimport org.apache.tools.ant.DefaultLogger;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.XmlLogger;\nimport org.apache.tools.ant.taskdefs.RecorderEntry;\nimport org.slf4j.event.Level;\n\nimport net.sourceforge.pmd.internal.Slf4jSimpleConfiguration;\n\npublic final class Slf4jSimpleConfigurationForAnt {\n    private Slf4jSimpleConfigurationForAnt() { }\n\n    private static final Level DEFAULT_LEVEL = Level.INFO;\n\n    // Maps from ant's Project.MSG_* to org.slf4j.event.Level\n    private static final Level[] LOG_LEVELS = {\n        Level.ERROR,   // Project.MSG_ERR=0\n        Level.WARN,    // Project.MSG_WARN=1\n        Level.INFO,    // Project.MSG_INFO=2\n        Level.DEBUG,   // Project.MSG_VERBOSE=3\n        Level.TRACE,   // Project.MSG_DEBUG=4\n    };\n\n    @SuppressWarnings(\"PMD.CloseResource\")\n    public static Level reconfigureLoggingForAnt(Project antProject) {\n        PrintStream original = System.err;\n        try {\n            System.setErr(new SimpleLoggerToAntBridge(antProject, original));\n\n            // configuring the format so that the log level appears at the beginning of the printed line\n            System.setProperty(\"org.slf4j.simpleLogger.showDateTime\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.showThreadName\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.showThreadId\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.levelInBrackets\", \"false\");\n\n            // using cacheOutputStream so that we can restore System.err after SimpleLogger has been initialized\n            System.setProperty(\"org.slf4j.simpleLogger.cacheOutputStream\", \"true\");\n            System.setProperty(\"org.slf4j.simpleLogger.logFile\", \"System.err\");\n\n            Level level = getAntLogLevel(antProject);\n            Slf4jSimpleConfiguration.reconfigureDefaultLogLevel(level);\n\n            return level;\n        } finally {\n            System.setErr(original);\n        }\n    }\n\n    private static final class SimpleLoggerToAntBridge extends PrintStream {\n        private static final Map<String, Integer> ANT_LOG_LEVELS;\n\n        static {\n            ANT_LOG_LEVELS = new HashMap<>();\n            ANT_LOG_LEVELS.put(Level.ERROR.name(), Project.MSG_ERR);\n            ANT_LOG_LEVELS.put(Level.WARN.name(), Project.MSG_WARN);\n            ANT_LOG_LEVELS.put(Level.INFO.name(), Project.MSG_INFO);\n            ANT_LOG_LEVELS.put(Level.DEBUG.name(), Project.MSG_VERBOSE);\n            ANT_LOG_LEVELS.put(Level.TRACE.name(), Project.MSG_DEBUG);\n        }\n\n        private final StringBuilder buffer = new StringBuilder(100);\n        private final Project antProject;\n\n        SimpleLoggerToAntBridge(Project antProject, PrintStream original) {\n            super(original);\n            this.antProject = antProject;\n        }\n\n        @Override\n        public void println(String x) {\n            buffer.append(x).append(System.lineSeparator());\n        }\n\n        @Override\n        public void flush() {\n            String logLevel = determineLogLevel();\n            int antLogLevel = ANT_LOG_LEVELS.getOrDefault(logLevel, Project.MSG_INFO);\n            antProject.log(buffer.toString(), antLogLevel);\n            buffer.setLength(0);\n        }\n\n        private String determineLogLevel() {\n            int firstSpace = buffer.indexOf(\" \");\n            if (firstSpace != -1) {\n                String level = buffer.substring(0, firstSpace);\n                buffer.delete(0, firstSpace + 1);\n                return level;\n            }\n            return DEFAULT_LEVEL.name();\n        }\n    }\n\n    @SuppressWarnings(\"PMD.AvoidAccessibilityAlteration\")\n    private static Level getAntLogLevel(Project project) {\n        for (final BuildListener l : project.getBuildListeners()) {\n            Field declaredField = null;\n            try {\n                if (l instanceof DefaultLogger) {\n                    declaredField = DefaultLogger.class.getDeclaredField(\"msgOutputLevel\");\n                } else if (l instanceof XmlLogger) {\n                    declaredField = XmlLogger.class.getDeclaredField(\"msgOutputLevel\");\n                } else if (l instanceof RecorderEntry) {\n                    declaredField = RecorderEntry.class.getDeclaredField(\"loglevel\");\n                } else if (\"org.gradle.api.internal.project.ant.AntLoggingAdapter\".equals(l.getClass().getName())) {\n                    return determineGradleLogLevel(project, l);\n                } else {\n                    try {\n                        declaredField = l.getClass().getDeclaredField(\"logLevel\");\n                        if (declaredField.getType() != Integer.class && declaredField.getType() != int.class) {\n                            declaredField = null;\n                            project.log(\"Unsupported build listener: \" + l.getClass(), Project.MSG_DEBUG);\n                        }\n                    } catch (final NoSuchFieldException e) {\n                        project.log(\"Unsupported build listener: \" + l.getClass(), Project.MSG_DEBUG);\n                    }\n                }\n\n                if (declaredField != null) {\n                    declaredField.setAccessible(true);\n                    return LOG_LEVELS[declaredField.getInt(l)];\n                }\n\n            } catch (final ReflectiveOperationException ignored) {\n                // Just ignore it\n            }\n        }\n\n        project.log(\"Could not determine ant log level, no supported build listeners found. \"\n                + \"Log level is set to \" + DEFAULT_LEVEL, Project.MSG_WARN);\n\n        return DEFAULT_LEVEL;\n    }\n\n    @SuppressWarnings(\"PMD.AvoidAccessibilityAlteration\")\n    private static Level determineGradleLogLevel(Project project, BuildListener l) {\n        try {\n            project.log(\"Detected gradle AntLoggingAdapter\", Project.MSG_DEBUG);\n            Field loggerField = l.getClass().getDeclaredField(\"logger\");\n            loggerField.setAccessible(true);\n            // org.gradle.internal.logging.slf4j.OutputEventListenerBackedLogger\n            Object logger = loggerField.get(l);\n\n            Class<?> gradleLogLevel = l.getClass().getClassLoader().loadClass(\"org.gradle.api.logging.LogLevel\");\n\n            Method isLevelAtMostMethod = logger.getClass().getDeclaredMethod(\"isLevelAtMost\", gradleLogLevel);\n            isLevelAtMostMethod.setAccessible(true);\n\n            Object[] logLevels = gradleLogLevel.getEnumConstants();\n            // the log levels in gradle are declared in the order DEBUG, INFO, LIFECYCLE, WARN, QUIET, ERROR\n            Level[] mapping = new Level[] {\n                Level.TRACE,   // DEBUG\n                Level.DEBUG,   // INFO\n                Level.INFO,     // LIFECYCLE\n                Level.WARN,  // WARN\n                Level.ERROR,   // QUIET\n                Level.ERROR,   // ERROR\n            };\n\n            for (int i = 0; i < Math.min(logLevels.length, mapping.length); i++) {\n                boolean enabled = (boolean) isLevelAtMostMethod.invoke(logger, logLevels[i]);\n                if (enabled) {\n                    project.log(\"Current log level: \" + logLevels[i] + \" -> \" + mapping[i], Project.MSG_DEBUG);\n                    return mapping[i];\n                }\n            }\n        } catch (ReflectiveOperationException ignored) {\n            // ignored\n        }\n        project.log(\"Could not determine log level, falling back to default: \" + DEFAULT_LEVEL, Project.MSG_WARN);\n        return DEFAULT_LEVEL;\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "@Override\n        public void flush() {\n            String logLevel = determineLogLevel();\n            int antLogLevel = ANT_LOG_LEVELS.getOrDefault(logLevel, Project.MSG_INFO);\n            antProject.log(buffer.toString(), antLogLevel);\n            buffer.setLength(0);\n        }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.ant.internal.Slf4jSimpleConfigurationForAnt#getAntLogLevel\n methodBody: private static Level getAntLogLevel(Project project) {\nfor(final BuildListener l: project.getBuildListeners()){Field declaredField=null;\ntryif(l instanceof DefaultLogger){declaredField=DefaultLogger.class.getDeclaredField(\"msgOutputLevel\");\n}if(l instanceof XmlLogger){declaredField=XmlLogger.class.getDeclaredField(\"msgOutputLevel\");\n}if(l instanceof RecorderEntry){declaredField=RecorderEntry.class.getDeclaredField(\"loglevel\");\n}if(\"org.gradle.api.internal.project.ant.AntLoggingAdapter\".equals(l.getClass().getName())){return determineGradleLogLevel(project,l);\n}{trydeclaredField=l.getClass().getDeclaredField(\"logLevel\");\nif(declaredField.getType() != Integer.class && declaredField.getType() != int.class){declaredField=null;\nproject.log(\"Unsupported build listener: \" + l.getClass(),Project.MSG_DEBUG);\n}catch(final NoSuchFieldException e)project.log(\"Unsupported build listener: \" + l.getClass(),Project.MSG_DEBUG);\n}if(declaredField != null){declaredField.setAccessible(true);\nreturn LOG_LEVELS[declaredField.getInt(l)];\n}catch(final ReflectiveOperationException ignored)}project.log(\"Could not determine ant log level, no supported build listeners found. \" + \"Log level is set to \" + DEFAULT_LEVEL,Project.MSG_WARN);\nreturn DEFAULT_LEVEL;\n}"
        ],
        "sourceCodeAfterRefactoring": "@SuppressWarnings(\"PMD.CloseResource\")\n    public static Level reconfigureLoggingForAnt(Project antProject) {\n        PrintStream original = System.err;\n        try {\n            System.setErr(new SimpleLoggerToAntBridge(antProject, original));\n\n            // configuring the format so that the log level appears at the beginning of the printed line\n            System.setProperty(\"org.slf4j.simpleLogger.showDateTime\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.showThreadName\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.showThreadId\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.levelInBrackets\", \"false\");\n\n            // using cacheOutputStream so that we can restore System.err after SimpleLogger has been initialized\n            System.setProperty(\"org.slf4j.simpleLogger.cacheOutputStream\", \"true\");\n            System.setProperty(\"org.slf4j.simpleLogger.logFile\", \"System.err\");\n\n            Level level = getAntLogLevel(antProject);\n            Slf4jSimpleConfiguration.reconfigureDefaultLogLevel(level);\n\n            return level;\n        } finally {\n            System.setErr(original);\n        }\n    }\n@Override\n        public void flush() {\n            String logLevel = determineLogLevel();\n            int antLogLevel = ANT_LOG_LEVELS.getOrDefault(logLevel, Project.MSG_INFO);\n            antProject.log(buffer.toString(), antLogLevel);\n            buffer.setLength(0);\n        }",
        "diffSourceCode": "-   36: \n-   37:     private static final Map<String, Integer> ANT_LOG_LEVELS;\n-   38: \n-   39:     static {\n-   40:         ANT_LOG_LEVELS = new HashMap<>();\n-   41:         ANT_LOG_LEVELS.put(Level.ERROR.name(), Project.MSG_ERR);\n-   42:         ANT_LOG_LEVELS.put(Level.WARN.name(), Project.MSG_WARN);\n-   43:         ANT_LOG_LEVELS.put(Level.INFO.name(), Project.MSG_INFO);\n-   44:         ANT_LOG_LEVELS.put(Level.DEBUG.name(), Project.MSG_VERBOSE);\n-   45:         ANT_LOG_LEVELS.put(Level.TRACE.name(), Project.MSG_DEBUG);\n-   46:     }\n+   36:     @SuppressWarnings(\"PMD.CloseResource\")\n+   37:     public static Level reconfigureLoggingForAnt(Project antProject) {\n+   38:         PrintStream original = System.err;\n+   39:         try {\n+   40:             System.setErr(new SimpleLoggerToAntBridge(antProject, original));\n+   41: \n+   42:             // configuring the format so that the log level appears at the beginning of the printed line\n+   43:             System.setProperty(\"org.slf4j.simpleLogger.showDateTime\", \"false\");\n+   44:             System.setProperty(\"org.slf4j.simpleLogger.showThreadName\", \"false\");\n+   45:             System.setProperty(\"org.slf4j.simpleLogger.showThreadId\", \"false\");\n+   46:             System.setProperty(\"org.slf4j.simpleLogger.levelInBrackets\", \"false\");\n    47: \n-   48:     @SuppressWarnings(\"PMD.CloseResource\")\n-   49:     public static Level reconfigureLoggingForAnt(Project antProject) {\n-   50:         PrintStream original = System.err;\n-   51:         try {\n-   52:             PrintStream interceptedStream = new PrintStream(original) {\n-   53:                 private StringBuilder buffer = new StringBuilder(100);\n+   48:             // using cacheOutputStream so that we can restore System.err after SimpleLogger has been initialized\n+   49:             System.setProperty(\"org.slf4j.simpleLogger.cacheOutputStream\", \"true\");\n+   50:             System.setProperty(\"org.slf4j.simpleLogger.logFile\", \"System.err\");\n+   51: \n+   52:             Level level = getAntLogLevel(antProject);\n+   53:             Slf4jSimpleConfiguration.reconfigureDefaultLogLevel(level);\n    54: \n-   55:                 @Override\n-   56:                 public void println(String x) {\n-   57:                     buffer.append(x).append(System.lineSeparator());\n-   58:                 }\n-   59: \n-   60:                 @Override\n-   61:                 public void flush() {\n-   62:                     String logLevel = determineLogLevel();\n-   63:                     int antLogLevel = ANT_LOG_LEVELS.getOrDefault(logLevel, Project.MSG_INFO);\n-   64:                     antProject.log(buffer.toString(), antLogLevel);\n-   65:                     buffer.setLength(0);\n-   66:                 }\n-   67: \n-   68:                 private String determineLogLevel() {\n-   69:                     int firstSpace = buffer.indexOf(\" \");\n-   70:                     if (firstSpace != -1) {\n-   71:                         String level = buffer.substring(0, firstSpace);\n-   72:                         buffer.delete(0, firstSpace + 1);\n-   73:                         return level;\n-   74:                     }\n-   75:                     return DEFAULT_LEVEL.name();\n-   76:                 }\n-   77:             };\n-   78:             System.setErr(interceptedStream);\n-   79: \n-   80:             Level level = getAntLogLevel(antProject);\n-   81:             System.setProperty(\"org.slf4j.simpleLogger.defaultLogLevel\", level.toString());\n-   82:             System.setProperty(\"org.slf4j.simpleLogger.showDateTime\", \"false\");\n-   83:             System.setProperty(\"org.slf4j.simpleLogger.showThreadName\", \"false\");\n-   84:             System.setProperty(\"org.slf4j.simpleLogger.showThreadId\", \"false\");\n-   85:             System.setProperty(\"org.slf4j.simpleLogger.levelInBrackets\", \"false\");\n-   86:             System.setProperty(\"org.slf4j.simpleLogger.cacheOutputStream\", \"true\");\n-   87:             System.setProperty(\"org.slf4j.simpleLogger.logFile\", \"System.err\");\n-   88: \n-   89:             // Call SimpleLogger.init() by reflection.\n-   90:             // Alternatively: move the CLI related classes into an own module, add\n-   91:             // slf4j-simple as a compile dependency and create a PmdSlf4jSimpleFriend class in\n-   92:             // the package org.slf4j.simple to gain access to this package-private init method.\n-   93:             ILoggerFactory loggerFactory = LoggerFactory.getILoggerFactory();\n-   94:             Class<? extends ILoggerFactory> loggerFactoryClass = loggerFactory.getClass();\n-   95:             try {\n-   96:                 Class<?> simpleLoggerClass = loggerFactoryClass.getClassLoader().loadClass(\"org.slf4j.simple.SimpleLogger\");\n-   97:                 Method initMethod = simpleLoggerClass.getDeclaredMethod(\"init\");\n-   98:                 initMethod.setAccessible(true);\n-   99:                 initMethod.invoke(null);\n-  100:             } catch (ReflectiveOperationException ex) {\n-  101:                 original.println(\"Error while initializing logging: \" + ex);\n-  102:             }\n-  103: \n-  104:             LoggerFactoryFriend.reset();\n-  105: \n-  106:             return level;\n-  107:         } finally {\n-  108:             System.setErr(original);\n-  109:         }\n-  110:     }\n+   55:             return level;\n+   56:         } finally {\n+   57:             System.setErr(original);\n+   58:         }\n+   59:     }\n+   60: \n+   61:     private static final class SimpleLoggerToAntBridge extends PrintStream {\n+   62:         private static final Map<String, Integer> ANT_LOG_LEVELS;\n+   63: \n+   64:         static {\n+   65:             ANT_LOG_LEVELS = new HashMap<>();\n+   66:             ANT_LOG_LEVELS.put(Level.ERROR.name(), Project.MSG_ERR);\n+   67:             ANT_LOG_LEVELS.put(Level.WARN.name(), Project.MSG_WARN);\n+   68:             ANT_LOG_LEVELS.put(Level.INFO.name(), Project.MSG_INFO);\n+   69:             ANT_LOG_LEVELS.put(Level.DEBUG.name(), Project.MSG_VERBOSE);\n+   70:             ANT_LOG_LEVELS.put(Level.TRACE.name(), Project.MSG_DEBUG);\n+   71:         }\n+   72: \n+   73:         private final StringBuilder buffer = new StringBuilder(100);\n+   74:         private final Project antProject;\n+   75: \n+   76:         SimpleLoggerToAntBridge(Project antProject, PrintStream original) {\n+   77:             super(original);\n+   78:             this.antProject = antProject;\n+   79:         }\n+   80: \n+   81:         @Override\n+   82:         public void println(String x) {\n+   83:             buffer.append(x).append(System.lineSeparator());\n+   84:         }\n+   85: \n+   86:         @Override\n+   87:         public void flush() {\n+   88:             String logLevel = determineLogLevel();\n+   89:             int antLogLevel = ANT_LOG_LEVELS.getOrDefault(logLevel, Project.MSG_INFO);\n+   90:             antProject.log(buffer.toString(), antLogLevel);\n+   91:             buffer.setLength(0);\n+   92:         }\n+   93: \n+   94:         private String determineLogLevel() {\n+   95:             int firstSpace = buffer.indexOf(\" \");\n+   96:             if (firstSpace != -1) {\n+   97:                 String level = buffer.substring(0, firstSpace);\n+   98:                 buffer.delete(0, firstSpace + 1);\n+   99:                 return level;\n+  100:             }\n+  101:             return DEFAULT_LEVEL.name();\n+  102:         }\n+  103:     }\n+  104: \n+  105:     @SuppressWarnings(\"PMD.AvoidAccessibilityAlteration\")\n+  106:     private static Level getAntLogLevel(Project project) {\n+  107:         for (final BuildListener l : project.getBuildListeners()) {\n+  108:             Field declaredField = null;\n+  109:             try {\n+  110:                 if (l instanceof DefaultLogger) {\n",
        "uniqueId": "cfbb14c91c24b1a50cf4b41cd855fd780375a14f_48_110_86_92_36_59",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 2,
                "covered": 45
            },
            "BRANCH": {
                "missed": 1,
                "covered": 1
            },
            "LINE": {
                "missed": 1,
                "covered": 13
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic println(x String) : void extracted from public reconfigureLoggingForAnt(antProject Project) : Level in class net.sourceforge.pmd.ant.internal.Slf4jSimpleConfigurationForAnt & moved to class net.sourceforge.pmd.ant.internal.Slf4jSimpleConfigurationForAnt.SimpleLoggerToAntBridge",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/ant/internal/Slf4jSimpleConfigurationForAnt.java",
                "startLine": 48,
                "endLine": 110,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/ant/internal/Slf4jSimpleConfigurationForAnt.java",
                "startLine": 36,
                "endLine": 59,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/ant/internal/Slf4jSimpleConfigurationForAnt.java",
                "startLine": 81,
                "endLine": 84,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@SuppressWarnings(\"PMD.CloseResource\")\n    public static Level reconfigureLoggingForAnt(Project antProject) {\n        PrintStream original = System.err;\n        try {\n            PrintStream interceptedStream = new PrintStream(original) {\n                private StringBuilder buffer = new StringBuilder(100);\n\n                @Override\n                public void println(String x) {\n                    buffer.append(x).append(System.lineSeparator());\n                }\n\n                @Override\n                public void flush() {\n                    String logLevel = determineLogLevel();\n                    int antLogLevel = ANT_LOG_LEVELS.getOrDefault(logLevel, Project.MSG_INFO);\n                    antProject.log(buffer.toString(), antLogLevel);\n                    buffer.setLength(0);\n                }\n\n                private String determineLogLevel() {\n                    int firstSpace = buffer.indexOf(\" \");\n                    if (firstSpace != -1) {\n                        String level = buffer.substring(0, firstSpace);\n                        buffer.delete(0, firstSpace + 1);\n                        return level;\n                    }\n                    return DEFAULT_LEVEL.name();\n                }\n            };\n            System.setErr(interceptedStream);\n\n            Level level = getAntLogLevel(antProject);\n            System.setProperty(\"org.slf4j.simpleLogger.defaultLogLevel\", level.toString());\n            System.setProperty(\"org.slf4j.simpleLogger.showDateTime\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.showThreadName\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.showThreadId\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.levelInBrackets\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.cacheOutputStream\", \"true\");\n            System.setProperty(\"org.slf4j.simpleLogger.logFile\", \"System.err\");\n\n            // Call SimpleLogger.init() by reflection.\n            // Alternatively: move the CLI related classes into an own module, add\n            // slf4j-simple as a compile dependency and create a PmdSlf4jSimpleFriend class in\n            // the package org.slf4j.simple to gain access to this package-private init method.\n            ILoggerFactory loggerFactory = LoggerFactory.getILoggerFactory();\n            Class<? extends ILoggerFactory> loggerFactoryClass = loggerFactory.getClass();\n            try {\n                Class<?> simpleLoggerClass = loggerFactoryClass.getClassLoader().loadClass(\"org.slf4j.simple.SimpleLogger\");\n                Method initMethod = simpleLoggerClass.getDeclaredMethod(\"init\");\n                initMethod.setAccessible(true);\n                initMethod.invoke(null);\n            } catch (ReflectiveOperationException ex) {\n                original.println(\"Error while initializing logging: \" + ex);\n            }\n\n            LoggerFactoryFriend.reset();\n\n            return level;\n        } finally {\n            System.setErr(original);\n        }\n    }",
        "filePathBefore": "pmd-core/src/main/java/net/sourceforge/pmd/ant/internal/Slf4jSimpleConfigurationForAnt.java",
        "isPureRefactoring": true,
        "commitId": "cfbb14c91c24b1a50cf4b41cd855fd780375a14f",
        "packageNameBefore": "net.sourceforge.pmd.ant.internal",
        "classNameBefore": "net.sourceforge.pmd.ant.internal.Slf4jSimpleConfigurationForAnt",
        "methodNameBefore": "net.sourceforge.pmd.ant.internal.Slf4jSimpleConfigurationForAnt#reconfigureLoggingForAnt",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.ant.internal.Slf4jSimpleConfigurationForAnt#getAntLogLevel\n methodBody: private static Level getAntLogLevel(Project project) {\nfor(final BuildListener l: project.getBuildListeners()){Field declaredField=null;\ntryif(l instanceof DefaultLogger){declaredField=DefaultLogger.class.getDeclaredField(\"msgOutputLevel\");\n}if(l instanceof XmlLogger){declaredField=XmlLogger.class.getDeclaredField(\"msgOutputLevel\");\n}if(l instanceof RecorderEntry){declaredField=RecorderEntry.class.getDeclaredField(\"loglevel\");\n}if(\"org.gradle.api.internal.project.ant.AntLoggingAdapter\".equals(l.getClass().getName())){return determineGradleLogLevel(project,l);\n}{trydeclaredField=l.getClass().getDeclaredField(\"logLevel\");\nif(declaredField.getType() != Integer.class && declaredField.getType() != int.class){declaredField=null;\nproject.log(\"Unsupported build listener: \" + l.getClass(),Project.MSG_DEBUG);\n}catch(final NoSuchFieldException e)project.log(\"Unsupported build listener: \" + l.getClass(),Project.MSG_DEBUG);\n}if(declaredField != null){declaredField.setAccessible(true);\nreturn LOG_LEVELS[declaredField.getInt(l)];\n}catch(final ReflectiveOperationException ignored)}project.log(\"Could not determine ant log level, no supported build listeners found. \" + \"Log level is set to \" + DEFAULT_LEVEL,Project.MSG_WARN);\nreturn DEFAULT_LEVEL;\n}",
        "classSignatureBefore": "public final class Slf4jSimpleConfigurationForAnt ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.ant.internal.Slf4jSimpleConfigurationForAnt#reconfigureLoggingForAnt"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.ant.internal.Slf4jSimpleConfigurationForAnt"
        ],
        "classSignatureBeforeSet": [
            "public final class Slf4jSimpleConfigurationForAnt "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.ant.internal;\n\nimport java.io.PrintStream;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.tools.ant.BuildListener;\nimport org.apache.tools.ant.DefaultLogger;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.XmlLogger;\nimport org.apache.tools.ant.taskdefs.RecorderEntry;\nimport org.slf4j.ILoggerFactory;\nimport org.slf4j.LoggerFactory;\nimport org.slf4j.LoggerFactoryFriend;\nimport org.slf4j.event.Level;\n\npublic final class Slf4jSimpleConfigurationForAnt {\n    private Slf4jSimpleConfigurationForAnt() { }\n\n    private static final Level DEFAULT_LEVEL = Level.INFO;\n\n    // Maps from ant's Project.MSG_* to org.slf4j.event.Level\n    private static final Level[] LOG_LEVELS = {\n        Level.ERROR,   // Project.MSG_ERR=0\n        Level.WARN,    // Project.MSG_WARN=1\n        Level.INFO,    // Project.MSG_INFO=2\n        Level.DEBUG,   // Project.MSG_VERBOSE=3\n        Level.TRACE,   // Project.MSG_DEBUG=4\n    };\n\n    private static final Map<String, Integer> ANT_LOG_LEVELS;\n\n    static {\n        ANT_LOG_LEVELS = new HashMap<>();\n        ANT_LOG_LEVELS.put(Level.ERROR.name(), Project.MSG_ERR);\n        ANT_LOG_LEVELS.put(Level.WARN.name(), Project.MSG_WARN);\n        ANT_LOG_LEVELS.put(Level.INFO.name(), Project.MSG_INFO);\n        ANT_LOG_LEVELS.put(Level.DEBUG.name(), Project.MSG_VERBOSE);\n        ANT_LOG_LEVELS.put(Level.TRACE.name(), Project.MSG_DEBUG);\n    }\n\n    @SuppressWarnings(\"PMD.CloseResource\")\n    public static Level reconfigureLoggingForAnt(Project antProject) {\n        PrintStream original = System.err;\n        try {\n            PrintStream interceptedStream = new PrintStream(original) {\n                private StringBuilder buffer = new StringBuilder(100);\n\n                @Override\n                public void println(String x) {\n                    buffer.append(x).append(System.lineSeparator());\n                }\n\n                @Override\n                public void flush() {\n                    String logLevel = determineLogLevel();\n                    int antLogLevel = ANT_LOG_LEVELS.getOrDefault(logLevel, Project.MSG_INFO);\n                    antProject.log(buffer.toString(), antLogLevel);\n                    buffer.setLength(0);\n                }\n\n                private String determineLogLevel() {\n                    int firstSpace = buffer.indexOf(\" \");\n                    if (firstSpace != -1) {\n                        String level = buffer.substring(0, firstSpace);\n                        buffer.delete(0, firstSpace + 1);\n                        return level;\n                    }\n                    return DEFAULT_LEVEL.name();\n                }\n            };\n            System.setErr(interceptedStream);\n\n            Level level = getAntLogLevel(antProject);\n            System.setProperty(\"org.slf4j.simpleLogger.defaultLogLevel\", level.toString());\n            System.setProperty(\"org.slf4j.simpleLogger.showDateTime\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.showThreadName\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.showThreadId\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.levelInBrackets\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.cacheOutputStream\", \"true\");\n            System.setProperty(\"org.slf4j.simpleLogger.logFile\", \"System.err\");\n\n            // Call SimpleLogger.init() by reflection.\n            // Alternatively: move the CLI related classes into an own module, add\n            // slf4j-simple as a compile dependency and create a PmdSlf4jSimpleFriend class in\n            // the package org.slf4j.simple to gain access to this package-private init method.\n            ILoggerFactory loggerFactory = LoggerFactory.getILoggerFactory();\n            Class<? extends ILoggerFactory> loggerFactoryClass = loggerFactory.getClass();\n            try {\n                Class<?> simpleLoggerClass = loggerFactoryClass.getClassLoader().loadClass(\"org.slf4j.simple.SimpleLogger\");\n                Method initMethod = simpleLoggerClass.getDeclaredMethod(\"init\");\n                initMethod.setAccessible(true);\n                initMethod.invoke(null);\n            } catch (ReflectiveOperationException ex) {\n                original.println(\"Error while initializing logging: \" + ex);\n            }\n\n            LoggerFactoryFriend.reset();\n\n            return level;\n        } finally {\n            System.setErr(original);\n        }\n    }\n\n    @SuppressWarnings(\"PMD.AvoidAccessibilityAlteration\")\n    private static Level getAntLogLevel(Project project) {\n        for (final BuildListener l : project.getBuildListeners()) {\n            Field declaredField = null;\n            try {\n                if (l instanceof DefaultLogger) {\n                    declaredField = DefaultLogger.class.getDeclaredField(\"msgOutputLevel\");\n                } else if (l instanceof XmlLogger) {\n                    declaredField = XmlLogger.class.getDeclaredField(\"msgOutputLevel\");\n                } else if (l instanceof RecorderEntry) {\n                    declaredField = RecorderEntry.class.getDeclaredField(\"loglevel\");\n                } else if (\"org.gradle.api.internal.project.ant.AntLoggingAdapter\".equals(l.getClass().getName())) {\n                    return determineGradleLogLevel(project, l);\n                } else {\n                    try {\n                        declaredField = l.getClass().getDeclaredField(\"logLevel\");\n                        if (declaredField.getType() != Integer.class && declaredField.getType() != int.class) {\n                            declaredField = null;\n                            project.log(\"Unsupported build listener: \" + l.getClass(), Project.MSG_DEBUG);\n                        }\n                    } catch (final NoSuchFieldException e) {\n                        project.log(\"Unsupported build listener: \" + l.getClass(), Project.MSG_DEBUG);\n                    }\n                }\n\n                if (declaredField != null) {\n                    declaredField.setAccessible(true);\n                    return LOG_LEVELS[declaredField.getInt(l)];\n                }\n\n            } catch (final ReflectiveOperationException ignored) {\n                // Just ignore it\n            }\n        }\n\n        project.log(\"Could not determine ant log level, no supported build listeners found. \"\n                + \"Log level is set to \" + DEFAULT_LEVEL, Project.MSG_WARN);\n\n        return DEFAULT_LEVEL;\n    }\n\n    @SuppressWarnings(\"PMD.AvoidAccessibilityAlteration\")\n    private static Level determineGradleLogLevel(Project project, BuildListener l) {\n        try {\n            project.log(\"Detected gradle AntLoggingAdapter\", Project.MSG_DEBUG);\n            Field loggerField = l.getClass().getDeclaredField(\"logger\");\n            loggerField.setAccessible(true);\n            // org.gradle.internal.logging.slf4j.OutputEventListenerBackedLogger\n            Object logger = loggerField.get(l);\n\n            Class<?> gradleLogLevel = l.getClass().getClassLoader().loadClass(\"org.gradle.api.logging.LogLevel\");\n\n            Method isLevelAtMostMethod = logger.getClass().getDeclaredMethod(\"isLevelAtMost\", gradleLogLevel);\n            isLevelAtMostMethod.setAccessible(true);\n\n            Object[] logLevels = gradleLogLevel.getEnumConstants();\n            // the log levels in gradle are declared in the order DEBUG, INFO, LIFECYCLE, WARN, QUIET, ERROR\n            Level[] mapping = new Level[] {\n                Level.TRACE,   // DEBUG\n                Level.DEBUG,   // INFO\n                Level.INFO,     // LIFECYCLE\n                Level.WARN,  // WARN\n                Level.ERROR,   // QUIET\n                Level.ERROR,   // ERROR\n            };\n\n            for (int i = 0; i < Math.min(logLevels.length, mapping.length); i++) {\n                boolean enabled = (boolean) isLevelAtMostMethod.invoke(logger, logLevels[i]);\n                if (enabled) {\n                    project.log(\"Current log level: \" + logLevels[i] + \" -> \" + mapping[i], Project.MSG_DEBUG);\n                    return mapping[i];\n                }\n            }\n        } catch (ReflectiveOperationException ignored) {\n            // ignored\n        }\n        project.log(\"Could not determine log level, falling back to default: \" + DEFAULT_LEVEL, Project.MSG_WARN);\n        return DEFAULT_LEVEL;\n    }\n\n}\n",
        "filePathAfter": "pmd-core/src/main/java/net/sourceforge/pmd/ant/internal/Slf4jSimpleConfigurationForAnt.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.ant.internal;\n\nimport java.io.PrintStream;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.tools.ant.BuildListener;\nimport org.apache.tools.ant.DefaultLogger;\nimport org.apache.tools.ant.Project;\nimport org.apache.tools.ant.XmlLogger;\nimport org.apache.tools.ant.taskdefs.RecorderEntry;\nimport org.slf4j.event.Level;\n\nimport net.sourceforge.pmd.internal.Slf4jSimpleConfiguration;\n\npublic final class Slf4jSimpleConfigurationForAnt {\n    private Slf4jSimpleConfigurationForAnt() { }\n\n    private static final Level DEFAULT_LEVEL = Level.INFO;\n\n    // Maps from ant's Project.MSG_* to org.slf4j.event.Level\n    private static final Level[] LOG_LEVELS = {\n        Level.ERROR,   // Project.MSG_ERR=0\n        Level.WARN,    // Project.MSG_WARN=1\n        Level.INFO,    // Project.MSG_INFO=2\n        Level.DEBUG,   // Project.MSG_VERBOSE=3\n        Level.TRACE,   // Project.MSG_DEBUG=4\n    };\n\n    @SuppressWarnings(\"PMD.CloseResource\")\n    public static Level reconfigureLoggingForAnt(Project antProject) {\n        PrintStream original = System.err;\n        try {\n            System.setErr(new SimpleLoggerToAntBridge(antProject, original));\n\n            // configuring the format so that the log level appears at the beginning of the printed line\n            System.setProperty(\"org.slf4j.simpleLogger.showDateTime\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.showThreadName\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.showThreadId\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.levelInBrackets\", \"false\");\n\n            // using cacheOutputStream so that we can restore System.err after SimpleLogger has been initialized\n            System.setProperty(\"org.slf4j.simpleLogger.cacheOutputStream\", \"true\");\n            System.setProperty(\"org.slf4j.simpleLogger.logFile\", \"System.err\");\n\n            Level level = getAntLogLevel(antProject);\n            Slf4jSimpleConfiguration.reconfigureDefaultLogLevel(level);\n\n            return level;\n        } finally {\n            System.setErr(original);\n        }\n    }\n\n    private static final class SimpleLoggerToAntBridge extends PrintStream {\n        private static final Map<String, Integer> ANT_LOG_LEVELS;\n\n        static {\n            ANT_LOG_LEVELS = new HashMap<>();\n            ANT_LOG_LEVELS.put(Level.ERROR.name(), Project.MSG_ERR);\n            ANT_LOG_LEVELS.put(Level.WARN.name(), Project.MSG_WARN);\n            ANT_LOG_LEVELS.put(Level.INFO.name(), Project.MSG_INFO);\n            ANT_LOG_LEVELS.put(Level.DEBUG.name(), Project.MSG_VERBOSE);\n            ANT_LOG_LEVELS.put(Level.TRACE.name(), Project.MSG_DEBUG);\n        }\n\n        private final StringBuilder buffer = new StringBuilder(100);\n        private final Project antProject;\n\n        SimpleLoggerToAntBridge(Project antProject, PrintStream original) {\n            super(original);\n            this.antProject = antProject;\n        }\n\n        @Override\n        public void println(String x) {\n            buffer.append(x).append(System.lineSeparator());\n        }\n\n        @Override\n        public void flush() {\n            String logLevel = determineLogLevel();\n            int antLogLevel = ANT_LOG_LEVELS.getOrDefault(logLevel, Project.MSG_INFO);\n            antProject.log(buffer.toString(), antLogLevel);\n            buffer.setLength(0);\n        }\n\n        private String determineLogLevel() {\n            int firstSpace = buffer.indexOf(\" \");\n            if (firstSpace != -1) {\n                String level = buffer.substring(0, firstSpace);\n                buffer.delete(0, firstSpace + 1);\n                return level;\n            }\n            return DEFAULT_LEVEL.name();\n        }\n    }\n\n    @SuppressWarnings(\"PMD.AvoidAccessibilityAlteration\")\n    private static Level getAntLogLevel(Project project) {\n        for (final BuildListener l : project.getBuildListeners()) {\n            Field declaredField = null;\n            try {\n                if (l instanceof DefaultLogger) {\n                    declaredField = DefaultLogger.class.getDeclaredField(\"msgOutputLevel\");\n                } else if (l instanceof XmlLogger) {\n                    declaredField = XmlLogger.class.getDeclaredField(\"msgOutputLevel\");\n                } else if (l instanceof RecorderEntry) {\n                    declaredField = RecorderEntry.class.getDeclaredField(\"loglevel\");\n                } else if (\"org.gradle.api.internal.project.ant.AntLoggingAdapter\".equals(l.getClass().getName())) {\n                    return determineGradleLogLevel(project, l);\n                } else {\n                    try {\n                        declaredField = l.getClass().getDeclaredField(\"logLevel\");\n                        if (declaredField.getType() != Integer.class && declaredField.getType() != int.class) {\n                            declaredField = null;\n                            project.log(\"Unsupported build listener: \" + l.getClass(), Project.MSG_DEBUG);\n                        }\n                    } catch (final NoSuchFieldException e) {\n                        project.log(\"Unsupported build listener: \" + l.getClass(), Project.MSG_DEBUG);\n                    }\n                }\n\n                if (declaredField != null) {\n                    declaredField.setAccessible(true);\n                    return LOG_LEVELS[declaredField.getInt(l)];\n                }\n\n            } catch (final ReflectiveOperationException ignored) {\n                // Just ignore it\n            }\n        }\n\n        project.log(\"Could not determine ant log level, no supported build listeners found. \"\n                + \"Log level is set to \" + DEFAULT_LEVEL, Project.MSG_WARN);\n\n        return DEFAULT_LEVEL;\n    }\n\n    @SuppressWarnings(\"PMD.AvoidAccessibilityAlteration\")\n    private static Level determineGradleLogLevel(Project project, BuildListener l) {\n        try {\n            project.log(\"Detected gradle AntLoggingAdapter\", Project.MSG_DEBUG);\n            Field loggerField = l.getClass().getDeclaredField(\"logger\");\n            loggerField.setAccessible(true);\n            // org.gradle.internal.logging.slf4j.OutputEventListenerBackedLogger\n            Object logger = loggerField.get(l);\n\n            Class<?> gradleLogLevel = l.getClass().getClassLoader().loadClass(\"org.gradle.api.logging.LogLevel\");\n\n            Method isLevelAtMostMethod = logger.getClass().getDeclaredMethod(\"isLevelAtMost\", gradleLogLevel);\n            isLevelAtMostMethod.setAccessible(true);\n\n            Object[] logLevels = gradleLogLevel.getEnumConstants();\n            // the log levels in gradle are declared in the order DEBUG, INFO, LIFECYCLE, WARN, QUIET, ERROR\n            Level[] mapping = new Level[] {\n                Level.TRACE,   // DEBUG\n                Level.DEBUG,   // INFO\n                Level.INFO,     // LIFECYCLE\n                Level.WARN,  // WARN\n                Level.ERROR,   // QUIET\n                Level.ERROR,   // ERROR\n            };\n\n            for (int i = 0; i < Math.min(logLevels.length, mapping.length); i++) {\n                boolean enabled = (boolean) isLevelAtMostMethod.invoke(logger, logLevels[i]);\n                if (enabled) {\n                    project.log(\"Current log level: \" + logLevels[i] + \" -> \" + mapping[i], Project.MSG_DEBUG);\n                    return mapping[i];\n                }\n            }\n        } catch (ReflectiveOperationException ignored) {\n            // ignored\n        }\n        project.log(\"Could not determine log level, falling back to default: \" + DEFAULT_LEVEL, Project.MSG_WARN);\n        return DEFAULT_LEVEL;\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "@Override\n        public void println(String x) {\n            buffer.append(x).append(System.lineSeparator());\n        }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.ant.internal.Slf4jSimpleConfigurationForAnt#getAntLogLevel\n methodBody: private static Level getAntLogLevel(Project project) {\nfor(final BuildListener l: project.getBuildListeners()){Field declaredField=null;\ntryif(l instanceof DefaultLogger){declaredField=DefaultLogger.class.getDeclaredField(\"msgOutputLevel\");\n}if(l instanceof XmlLogger){declaredField=XmlLogger.class.getDeclaredField(\"msgOutputLevel\");\n}if(l instanceof RecorderEntry){declaredField=RecorderEntry.class.getDeclaredField(\"loglevel\");\n}if(\"org.gradle.api.internal.project.ant.AntLoggingAdapter\".equals(l.getClass().getName())){return determineGradleLogLevel(project,l);\n}{trydeclaredField=l.getClass().getDeclaredField(\"logLevel\");\nif(declaredField.getType() != Integer.class && declaredField.getType() != int.class){declaredField=null;\nproject.log(\"Unsupported build listener: \" + l.getClass(),Project.MSG_DEBUG);\n}catch(final NoSuchFieldException e)project.log(\"Unsupported build listener: \" + l.getClass(),Project.MSG_DEBUG);\n}if(declaredField != null){declaredField.setAccessible(true);\nreturn LOG_LEVELS[declaredField.getInt(l)];\n}catch(final ReflectiveOperationException ignored)}project.log(\"Could not determine ant log level, no supported build listeners found. \" + \"Log level is set to \" + DEFAULT_LEVEL,Project.MSG_WARN);\nreturn DEFAULT_LEVEL;\n}"
        ],
        "sourceCodeAfterRefactoring": "@SuppressWarnings(\"PMD.CloseResource\")\n    public static Level reconfigureLoggingForAnt(Project antProject) {\n        PrintStream original = System.err;\n        try {\n            System.setErr(new SimpleLoggerToAntBridge(antProject, original));\n\n            // configuring the format so that the log level appears at the beginning of the printed line\n            System.setProperty(\"org.slf4j.simpleLogger.showDateTime\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.showThreadName\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.showThreadId\", \"false\");\n            System.setProperty(\"org.slf4j.simpleLogger.levelInBrackets\", \"false\");\n\n            // using cacheOutputStream so that we can restore System.err after SimpleLogger has been initialized\n            System.setProperty(\"org.slf4j.simpleLogger.cacheOutputStream\", \"true\");\n            System.setProperty(\"org.slf4j.simpleLogger.logFile\", \"System.err\");\n\n            Level level = getAntLogLevel(antProject);\n            Slf4jSimpleConfiguration.reconfigureDefaultLogLevel(level);\n\n            return level;\n        } finally {\n            System.setErr(original);\n        }\n    }\n@Override\n        public void println(String x) {\n            buffer.append(x).append(System.lineSeparator());\n        }",
        "diffSourceCode": "-   36: \n-   37:     private static final Map<String, Integer> ANT_LOG_LEVELS;\n-   38: \n-   39:     static {\n-   40:         ANT_LOG_LEVELS = new HashMap<>();\n-   41:         ANT_LOG_LEVELS.put(Level.ERROR.name(), Project.MSG_ERR);\n-   42:         ANT_LOG_LEVELS.put(Level.WARN.name(), Project.MSG_WARN);\n-   43:         ANT_LOG_LEVELS.put(Level.INFO.name(), Project.MSG_INFO);\n-   44:         ANT_LOG_LEVELS.put(Level.DEBUG.name(), Project.MSG_VERBOSE);\n-   45:         ANT_LOG_LEVELS.put(Level.TRACE.name(), Project.MSG_DEBUG);\n-   46:     }\n+   36:     @SuppressWarnings(\"PMD.CloseResource\")\n+   37:     public static Level reconfigureLoggingForAnt(Project antProject) {\n+   38:         PrintStream original = System.err;\n+   39:         try {\n+   40:             System.setErr(new SimpleLoggerToAntBridge(antProject, original));\n+   41: \n+   42:             // configuring the format so that the log level appears at the beginning of the printed line\n+   43:             System.setProperty(\"org.slf4j.simpleLogger.showDateTime\", \"false\");\n+   44:             System.setProperty(\"org.slf4j.simpleLogger.showThreadName\", \"false\");\n+   45:             System.setProperty(\"org.slf4j.simpleLogger.showThreadId\", \"false\");\n+   46:             System.setProperty(\"org.slf4j.simpleLogger.levelInBrackets\", \"false\");\n    47: \n-   48:     @SuppressWarnings(\"PMD.CloseResource\")\n-   49:     public static Level reconfigureLoggingForAnt(Project antProject) {\n-   50:         PrintStream original = System.err;\n-   51:         try {\n-   52:             PrintStream interceptedStream = new PrintStream(original) {\n-   53:                 private StringBuilder buffer = new StringBuilder(100);\n+   48:             // using cacheOutputStream so that we can restore System.err after SimpleLogger has been initialized\n+   49:             System.setProperty(\"org.slf4j.simpleLogger.cacheOutputStream\", \"true\");\n+   50:             System.setProperty(\"org.slf4j.simpleLogger.logFile\", \"System.err\");\n+   51: \n+   52:             Level level = getAntLogLevel(antProject);\n+   53:             Slf4jSimpleConfiguration.reconfigureDefaultLogLevel(level);\n    54: \n-   55:                 @Override\n-   56:                 public void println(String x) {\n-   57:                     buffer.append(x).append(System.lineSeparator());\n-   58:                 }\n-   59: \n-   60:                 @Override\n-   61:                 public void flush() {\n-   62:                     String logLevel = determineLogLevel();\n-   63:                     int antLogLevel = ANT_LOG_LEVELS.getOrDefault(logLevel, Project.MSG_INFO);\n-   64:                     antProject.log(buffer.toString(), antLogLevel);\n-   65:                     buffer.setLength(0);\n-   66:                 }\n-   67: \n-   68:                 private String determineLogLevel() {\n-   69:                     int firstSpace = buffer.indexOf(\" \");\n-   70:                     if (firstSpace != -1) {\n-   71:                         String level = buffer.substring(0, firstSpace);\n-   72:                         buffer.delete(0, firstSpace + 1);\n-   73:                         return level;\n-   74:                     }\n-   75:                     return DEFAULT_LEVEL.name();\n-   76:                 }\n-   77:             };\n-   78:             System.setErr(interceptedStream);\n-   79: \n-   80:             Level level = getAntLogLevel(antProject);\n-   81:             System.setProperty(\"org.slf4j.simpleLogger.defaultLogLevel\", level.toString());\n-   82:             System.setProperty(\"org.slf4j.simpleLogger.showDateTime\", \"false\");\n-   83:             System.setProperty(\"org.slf4j.simpleLogger.showThreadName\", \"false\");\n-   84:             System.setProperty(\"org.slf4j.simpleLogger.showThreadId\", \"false\");\n-   85:             System.setProperty(\"org.slf4j.simpleLogger.levelInBrackets\", \"false\");\n-   86:             System.setProperty(\"org.slf4j.simpleLogger.cacheOutputStream\", \"true\");\n-   87:             System.setProperty(\"org.slf4j.simpleLogger.logFile\", \"System.err\");\n-   88: \n-   89:             // Call SimpleLogger.init() by reflection.\n-   90:             // Alternatively: move the CLI related classes into an own module, add\n-   91:             // slf4j-simple as a compile dependency and create a PmdSlf4jSimpleFriend class in\n-   92:             // the package org.slf4j.simple to gain access to this package-private init method.\n-   93:             ILoggerFactory loggerFactory = LoggerFactory.getILoggerFactory();\n-   94:             Class<? extends ILoggerFactory> loggerFactoryClass = loggerFactory.getClass();\n-   95:             try {\n-   96:                 Class<?> simpleLoggerClass = loggerFactoryClass.getClassLoader().loadClass(\"org.slf4j.simple.SimpleLogger\");\n-   97:                 Method initMethod = simpleLoggerClass.getDeclaredMethod(\"init\");\n-   98:                 initMethod.setAccessible(true);\n-   99:                 initMethod.invoke(null);\n-  100:             } catch (ReflectiveOperationException ex) {\n-  101:                 original.println(\"Error while initializing logging: \" + ex);\n-  102:             }\n-  103: \n-  104:             LoggerFactoryFriend.reset();\n-  105: \n-  106:             return level;\n-  107:         } finally {\n-  108:             System.setErr(original);\n-  109:         }\n-  110:     }\n+   55:             return level;\n+   56:         } finally {\n+   57:             System.setErr(original);\n+   58:         }\n+   59:     }\n+   60: \n+   61:     private static final class SimpleLoggerToAntBridge extends PrintStream {\n+   62:         private static final Map<String, Integer> ANT_LOG_LEVELS;\n+   63: \n+   64:         static {\n+   65:             ANT_LOG_LEVELS = new HashMap<>();\n+   66:             ANT_LOG_LEVELS.put(Level.ERROR.name(), Project.MSG_ERR);\n+   67:             ANT_LOG_LEVELS.put(Level.WARN.name(), Project.MSG_WARN);\n+   68:             ANT_LOG_LEVELS.put(Level.INFO.name(), Project.MSG_INFO);\n+   69:             ANT_LOG_LEVELS.put(Level.DEBUG.name(), Project.MSG_VERBOSE);\n+   70:             ANT_LOG_LEVELS.put(Level.TRACE.name(), Project.MSG_DEBUG);\n+   71:         }\n+   72: \n+   73:         private final StringBuilder buffer = new StringBuilder(100);\n+   74:         private final Project antProject;\n+   75: \n+   76:         SimpleLoggerToAntBridge(Project antProject, PrintStream original) {\n+   77:             super(original);\n+   78:             this.antProject = antProject;\n+   79:         }\n+   80: \n+   81:         @Override\n+   82:         public void println(String x) {\n+   83:             buffer.append(x).append(System.lineSeparator());\n+   84:         }\n+   85: \n+   86:         @Override\n+   87:         public void flush() {\n+   88:             String logLevel = determineLogLevel();\n+   89:             int antLogLevel = ANT_LOG_LEVELS.getOrDefault(logLevel, Project.MSG_INFO);\n+   90:             antProject.log(buffer.toString(), antLogLevel);\n+   91:             buffer.setLength(0);\n+   92:         }\n+   93: \n+   94:         private String determineLogLevel() {\n+   95:             int firstSpace = buffer.indexOf(\" \");\n+   96:             if (firstSpace != -1) {\n+   97:                 String level = buffer.substring(0, firstSpace);\n+   98:                 buffer.delete(0, firstSpace + 1);\n+   99:                 return level;\n+  100:             }\n+  101:             return DEFAULT_LEVEL.name();\n+  102:         }\n+  103:     }\n+  104: \n+  105:     @SuppressWarnings(\"PMD.AvoidAccessibilityAlteration\")\n+  106:     private static Level getAntLogLevel(Project project) {\n+  107:         for (final BuildListener l : project.getBuildListeners()) {\n+  108:             Field declaredField = null;\n+  109:             try {\n+  110:                 if (l instanceof DefaultLogger) {\n",
        "uniqueId": "cfbb14c91c24b1a50cf4b41cd855fd780375a14f_48_110_81_84_36_59",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 2,
                "covered": 45
            },
            "BRANCH": {
                "missed": 1,
                "covered": 1
            },
            "LINE": {
                "missed": 1,
                "covered": 13
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Move Method",
        "description": "Move Method\tprivate runPmd(config PMDConfiguration, listener GlobalAnalysisListener, rule Rule) : void from class net.sourceforge.pmd.processor.GlobalListenerTest to private runPmd(config PMDConfiguration, listener GlobalAnalysisListener, rule Rule) : void from class net.sourceforge.pmd.reporting.GlobalAnalysisListenerTest",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/processor/GlobalListenerTest.java",
                "startLine": 131,
                "endLine": 140,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/reporting/GlobalAnalysisListenerTest.java",
                "startLine": 145,
                "endLine": 154,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private void runPmd(PMDConfiguration config, GlobalAnalysisListener listener, Rule rule) {\n        try (PmdAnalysis pmd = PmdAnalysis.create(config)) {\n            pmd.addRuleSet(RuleSet.forSingleRule(rule));\n            pmd.files().addSourceFile(\"abc\", \"fname1.dummy\");\n            pmd.files().addSourceFile(\"abcd\", \"fname2.dummy\");\n            pmd.files().addSourceFile(\"abcd\", \"fname21.dummy\");\n            pmd.addListener(listener);\n            pmd.performAnalysis();\n        }\n    }",
        "filePathBefore": "pmd-core/src/test/java/net/sourceforge/pmd/processor/GlobalListenerTest.java",
        "isPureRefactoring": true,
        "commitId": "e2866bebf86e86892860dd0e3a01492797fd8ea6",
        "packageNameBefore": "net.sourceforge.pmd.processor",
        "classNameBefore": "net.sourceforge.pmd.processor.GlobalListenerTest",
        "methodNameBefore": "net.sourceforge.pmd.processor.GlobalListenerTest#runPmd",
        "classSignatureBefore": "class GlobalListenerTest ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.processor.GlobalListenerTest#runPmd"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.processor.GlobalListenerTest"
        ],
        "classSignatureBeforeSet": [
            "class GlobalListenerTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.processor;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.spy;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\n\nimport net.sourceforge.pmd.FooRule;\nimport net.sourceforge.pmd.PMDConfiguration;\nimport net.sourceforge.pmd.PmdAnalysis;\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RuleContext;\nimport net.sourceforge.pmd.RuleSet;\nimport net.sourceforge.pmd.cache.AnalysisCache;\nimport net.sourceforge.pmd.cache.NoopAnalysisCache;\nimport net.sourceforge.pmd.lang.ast.FileAnalysisException;\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.reporting.GlobalAnalysisListener;\nimport net.sourceforge.pmd.reporting.GlobalAnalysisListener.ViolationCounterListener;\n\nclass GlobalListenerTest {\n\n    static final int NUM_DATA_SOURCES = 3;\n\n    @Test\n    void testViolationCounter() throws Exception {\n\n        PMDConfiguration config = newConfig();\n\n        ViolationCounterListener listener = new GlobalAnalysisListener.ViolationCounterListener();\n\n        MyFooRule mockrule = Mockito.spy(MyFooRule.class);\n        runPmd(config, listener, mockrule);\n\n        Mockito.verify(mockrule, times(NUM_DATA_SOURCES)).apply(any(), any());\n        assertEquals(2, (int) listener.getResult());\n\n    }\n\n    @Test\n    void testViolationCounterOnMulti() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        config.setThreads(2);\n\n        ViolationCounterListener listener = new GlobalAnalysisListener.ViolationCounterListener();\n\n        MyFooRule mockrule = Mockito.spy(MyFooRule.class);\n        when(mockrule.deepCopy()).thenReturn(mockrule); // the spy cannot track the deep copies\n\n        runPmd(config, listener, mockrule);\n\n        Mockito.verify(mockrule, times(NUM_DATA_SOURCES)).apply(any(), any());\n        assertEquals(2, (int) listener.getResult());\n\n    }\n\n    @Test\n    void testAnalysisCache() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        MyFooRule rule = new MyFooRule();\n        runPmd(config, GlobalAnalysisListener.noop(), rule);\n\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(NUM_DATA_SOURCES)).isUpToDate(any());\n    }\n\n    @Test\n    void testCacheWithFailure() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        BrokenRule rule = new BrokenRule();  // the broken rule throws\n        runPmd(config, GlobalAnalysisListener.noop(), rule);\n\n        // cache methods are called regardless\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(NUM_DATA_SOURCES)).isUpToDate(any());\n    }\n\n    @Test\n    void testCacheWithPropagatedException() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        BrokenRule rule = new BrokenRule();  // the broken rule throws\n        // now the exception should be propagated\n        GlobalAnalysisListener listener = GlobalAnalysisListener.exceptionThrower();\n        FileAnalysisException exception = assertThrows(FileAnalysisException.class, () -> {\n            runPmd(config, listener, rule);\n        });\n\n        assertEquals(\"fname1.dummy\", exception.getFileName());\n\n        // cache methods are called regardless\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(1)).isUpToDate(any());\n    }\n\n    @NonNull\n    private PMDConfiguration newConfig() {\n        PMDConfiguration config = new PMDConfiguration();\n        config.setAnalysisCache(new NoopAnalysisCache());\n        config.setIgnoreIncrementalAnalysis(true);\n        config.setThreads(1);\n        return config;\n    }\n\n    private void runPmd(PMDConfiguration config, GlobalAnalysisListener listener, Rule rule) {\n        try (PmdAnalysis pmd = PmdAnalysis.create(config)) {\n            pmd.addRuleSet(RuleSet.forSingleRule(rule));\n            pmd.files().addSourceFile(\"abc\", \"fname1.dummy\");\n            pmd.files().addSourceFile(\"abcd\", \"fname2.dummy\");\n            pmd.files().addSourceFile(\"abcd\", \"fname21.dummy\");\n            pmd.addListener(listener);\n            pmd.performAnalysis();\n        }\n    }\n\n\n    public static class MyFooRule extends FooRule {\n\n        @Override\n        public void apply(Node node, RuleContext ctx) {\n            if (node.getTextDocument().getDisplayName().contains(\"1\")) {\n                ctx.addViolation(node);\n            }\n        }\n    }\n\n    public static class BrokenRule extends FooRule {\n\n        @Override\n        public void apply(Node node, RuleContext ctx) {\n            throw new IllegalArgumentException(\"Something happened\");\n        }\n    }\n}\n",
        "filePathAfter": "pmd-core/src/test/java/net/sourceforge/pmd/reporting/GlobalAnalysisListenerTest.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.reporting;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.spy;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport java.util.Arrays;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\n\nimport net.sourceforge.pmd.FooRule;\nimport net.sourceforge.pmd.PMDConfiguration;\nimport net.sourceforge.pmd.PmdAnalysis;\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RuleContext;\nimport net.sourceforge.pmd.RuleSet;\nimport net.sourceforge.pmd.cache.AnalysisCache;\nimport net.sourceforge.pmd.cache.NoopAnalysisCache;\nimport net.sourceforge.pmd.lang.ast.FileAnalysisException;\nimport net.sourceforge.pmd.lang.ast.Node;\n\nclass GlobalAnalysisListenerTest {\n\n    static final int NUM_DATA_SOURCES = 3;\n\n    @Test\n    void testViolationCounter() {\n\n        PMDConfiguration config = newConfig();\n\n        GlobalAnalysisListener.ViolationCounterListener listener = new GlobalAnalysisListener.ViolationCounterListener();\n\n        MyFooRule mockrule = Mockito.spy(MyFooRule.class);\n        runPmd(config, listener, mockrule);\n\n        Mockito.verify(mockrule, times(NUM_DATA_SOURCES)).apply(any(), any());\n        assertEquals(2, (int) listener.getResult());\n\n    }\n\n    @Test\n    void testViolationCounterOnMulti() {\n\n        PMDConfiguration config = newConfig();\n        config.setThreads(2);\n\n        GlobalAnalysisListener.ViolationCounterListener listener = new GlobalAnalysisListener.ViolationCounterListener();\n\n        MyFooRule mockrule = Mockito.spy(MyFooRule.class);\n        when(mockrule.deepCopy()).thenReturn(mockrule); // the spy cannot track the deep copies\n\n        runPmd(config, listener, mockrule);\n\n        Mockito.verify(mockrule, times(NUM_DATA_SOURCES)).apply(any(), any());\n        assertEquals(2, (int) listener.getResult());\n\n    }\n\n    @Test\n    void testAnalysisCache() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        MyFooRule rule = new MyFooRule();\n        runPmd(config, GlobalAnalysisListener.noop(), rule);\n\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(NUM_DATA_SOURCES)).isUpToDate(any());\n    }\n\n    @Test\n    void testCacheWithFailure() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        BrokenRule rule = new BrokenRule();  // the broken rule throws\n        runPmd(config, GlobalAnalysisListener.noop(), rule);\n\n        // cache methods are called regardless\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(NUM_DATA_SOURCES)).isUpToDate(any());\n    }\n\n    @Test\n    void testCacheWithPropagatedException() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        BrokenRule rule = new BrokenRule();  // the broken rule throws\n        // now the exception should be propagated\n        GlobalAnalysisListener listener = GlobalAnalysisListener.exceptionThrower();\n        FileAnalysisException exception = assertThrows(FileAnalysisException.class, () -> {\n            runPmd(config, listener, rule);\n        });\n\n        assertEquals(\"fname1.dummy\", exception.getFileName());\n\n        // cache methods are called regardless\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(1)).isUpToDate(any());\n    }\n\n    @Test\n    void teeShouldForwardAllEventsSingleListeners() throws Exception {\n        GlobalAnalysisListener mockListener1 = createMockListener();\n        GlobalAnalysisListener teed = GlobalAnalysisListener.tee(Arrays.asList(mockListener1));\n\n        teed.initializer();\n        teed.startFileAnalysis(null);\n        teed.onConfigError(null);\n        teed.close();\n\n        verifyMethods(mockListener1);\n        Mockito.verifyNoMoreInteractions(mockListener1);\n    }\n\n    @NonNull\n    private PMDConfiguration newConfig() {\n        PMDConfiguration config = new PMDConfiguration();\n        config.setAnalysisCache(new NoopAnalysisCache());\n        config.setIgnoreIncrementalAnalysis(true);\n        config.setThreads(1);\n        return config;\n    }\n\n    private void runPmd(PMDConfiguration config, GlobalAnalysisListener listener, Rule rule) {\n        try (PmdAnalysis pmd = PmdAnalysis.create(config)) {\n            pmd.addRuleSet(RuleSet.forSingleRule(rule));\n            pmd.files().addSourceFile(\"abc\", \"fname1.dummy\");\n            pmd.files().addSourceFile(\"abcd\", \"fname2.dummy\");\n            pmd.files().addSourceFile(\"abcd\", \"fname21.dummy\");\n            pmd.addListener(listener);\n            pmd.performAnalysis();\n        }\n    }\n\n\n    public static class MyFooRule extends FooRule {\n\n        @Override\n        public void apply(Node node, RuleContext ctx) {\n            if (node.getTextDocument().getDisplayName().contains(\"1\")) {\n                ctx.addViolation(node);\n            }\n        }\n    }\n\n    public static class BrokenRule extends FooRule {\n\n        @Override\n        public void apply(Node node, RuleContext ctx) {\n            throw new IllegalArgumentException(\"Something happened\");\n        }\n    }\n\n    @Test\n    void teeShouldForwardAllEventsMultipleListeners() throws Exception {\n        GlobalAnalysisListener mockListener1 = createMockListener();\n        GlobalAnalysisListener mockListener2 = createMockListener();\n        GlobalAnalysisListener teed = GlobalAnalysisListener.tee(Arrays.asList(mockListener1, mockListener2));\n\n        teed.initializer();\n        teed.startFileAnalysis(null);\n        teed.onConfigError(null);\n        teed.close();\n\n        verifyMethods(mockListener1);\n        verifyMethods(mockListener2);\n        Mockito.verifyNoMoreInteractions(mockListener1, mockListener2);\n    }\n\n    private GlobalAnalysisListener createMockListener() {\n        GlobalAnalysisListener mockListener = Mockito.mock(GlobalAnalysisListener.class);\n        Mockito.when(mockListener.initializer()).thenReturn(ListenerInitializer.noop());\n        Mockito.when(mockListener.startFileAnalysis(Mockito.any())).thenReturn(FileAnalysisListener.noop());\n        return mockListener;\n    }\n\n    private void verifyMethods(GlobalAnalysisListener listener) throws Exception {\n        Mockito.verify(listener, Mockito.times(1)).initializer();\n        Mockito.verify(listener, Mockito.times(1)).startFileAnalysis(null);\n        Mockito.verify(listener, Mockito.times(1)).onConfigError(null);\n        Mockito.verify(listener, Mockito.times(1)).close();\n    }\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "private void runPmd(PMDConfiguration config, GlobalAnalysisListener listener, Rule rule) {\n        try (PmdAnalysis pmd = PmdAnalysis.create(config)) {\n            pmd.addRuleSet(RuleSet.forSingleRule(rule));\n            pmd.files().addSourceFile(\"abc\", \"fname1.dummy\");\n            pmd.files().addSourceFile(\"abcd\", \"fname2.dummy\");\n            pmd.files().addSourceFile(\"abcd\", \"fname21.dummy\");\n            pmd.addListener(listener);\n            pmd.performAnalysis();\n        }\n    }",
        "diffSourceCode": "-  131:     private void runPmd(PMDConfiguration config, GlobalAnalysisListener listener, Rule rule) {\n-  132:         try (PmdAnalysis pmd = PmdAnalysis.create(config)) {\n-  133:             pmd.addRuleSet(RuleSet.forSingleRule(rule));\n-  134:             pmd.files().addSourceFile(\"abc\", \"fname1.dummy\");\n-  135:             pmd.files().addSourceFile(\"abcd\", \"fname2.dummy\");\n-  136:             pmd.files().addSourceFile(\"abcd\", \"fname21.dummy\");\n-  137:             pmd.addListener(listener);\n-  138:             pmd.performAnalysis();\n-  139:         }\n-  140:     }\n-  145:         @Override\n-  146:         public void apply(Node node, RuleContext ctx) {\n-  147:             if (node.getTextDocument().getDisplayName().contains(\"1\")) {\n-  148:                 ctx.addViolation(node);\n-  149:             }\n-  150:         }\n-  151:     }\n-  152: \n-  153:     public static class BrokenRule extends FooRule {\n-  154: \n+  131: \n+  132:         verifyMethods(mockListener1);\n+  133:         Mockito.verifyNoMoreInteractions(mockListener1);\n+  134:     }\n+  135: \n+  136:     @NonNull\n+  137:     private PMDConfiguration newConfig() {\n+  138:         PMDConfiguration config = new PMDConfiguration();\n+  139:         config.setAnalysisCache(new NoopAnalysisCache());\n+  140:         config.setIgnoreIncrementalAnalysis(true);\n+  145:     private void runPmd(PMDConfiguration config, GlobalAnalysisListener listener, Rule rule) {\n+  146:         try (PmdAnalysis pmd = PmdAnalysis.create(config)) {\n+  147:             pmd.addRuleSet(RuleSet.forSingleRule(rule));\n+  148:             pmd.files().addSourceFile(\"abc\", \"fname1.dummy\");\n+  149:             pmd.files().addSourceFile(\"abcd\", \"fname2.dummy\");\n+  150:             pmd.files().addSourceFile(\"abcd\", \"fname21.dummy\");\n+  151:             pmd.addListener(listener);\n+  152:             pmd.performAnalysis();\n+  153:         }\n+  154:     }\n",
        "uniqueId": "e2866bebf86e86892860dd0e3a01492797fd8ea6_131_140__145_154",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17
    },
    {
        "type": "Move Method",
        "description": "Move Method\tprivate newConfig() : PMDConfiguration from class net.sourceforge.pmd.processor.GlobalListenerTest to private newConfig() : PMDConfiguration from class net.sourceforge.pmd.reporting.GlobalAnalysisListenerTest",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/processor/GlobalListenerTest.java",
                "startLine": 122,
                "endLine": 129,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/reporting/GlobalAnalysisListenerTest.java",
                "startLine": 136,
                "endLine": 143,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@NonNull\n    private PMDConfiguration newConfig() {\n        PMDConfiguration config = new PMDConfiguration();\n        config.setAnalysisCache(new NoopAnalysisCache());\n        config.setIgnoreIncrementalAnalysis(true);\n        config.setThreads(1);\n        return config;\n    }",
        "filePathBefore": "pmd-core/src/test/java/net/sourceforge/pmd/processor/GlobalListenerTest.java",
        "isPureRefactoring": true,
        "commitId": "e2866bebf86e86892860dd0e3a01492797fd8ea6",
        "packageNameBefore": "net.sourceforge.pmd.processor",
        "classNameBefore": "net.sourceforge.pmd.processor.GlobalListenerTest",
        "methodNameBefore": "net.sourceforge.pmd.processor.GlobalListenerTest#newConfig",
        "classSignatureBefore": "class GlobalListenerTest ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.processor.GlobalListenerTest#newConfig"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.processor.GlobalListenerTest"
        ],
        "classSignatureBeforeSet": [
            "class GlobalListenerTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.processor;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.spy;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\n\nimport net.sourceforge.pmd.FooRule;\nimport net.sourceforge.pmd.PMDConfiguration;\nimport net.sourceforge.pmd.PmdAnalysis;\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RuleContext;\nimport net.sourceforge.pmd.RuleSet;\nimport net.sourceforge.pmd.cache.AnalysisCache;\nimport net.sourceforge.pmd.cache.NoopAnalysisCache;\nimport net.sourceforge.pmd.lang.ast.FileAnalysisException;\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.reporting.GlobalAnalysisListener;\nimport net.sourceforge.pmd.reporting.GlobalAnalysisListener.ViolationCounterListener;\n\nclass GlobalListenerTest {\n\n    static final int NUM_DATA_SOURCES = 3;\n\n    @Test\n    void testViolationCounter() throws Exception {\n\n        PMDConfiguration config = newConfig();\n\n        ViolationCounterListener listener = new GlobalAnalysisListener.ViolationCounterListener();\n\n        MyFooRule mockrule = Mockito.spy(MyFooRule.class);\n        runPmd(config, listener, mockrule);\n\n        Mockito.verify(mockrule, times(NUM_DATA_SOURCES)).apply(any(), any());\n        assertEquals(2, (int) listener.getResult());\n\n    }\n\n    @Test\n    void testViolationCounterOnMulti() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        config.setThreads(2);\n\n        ViolationCounterListener listener = new GlobalAnalysisListener.ViolationCounterListener();\n\n        MyFooRule mockrule = Mockito.spy(MyFooRule.class);\n        when(mockrule.deepCopy()).thenReturn(mockrule); // the spy cannot track the deep copies\n\n        runPmd(config, listener, mockrule);\n\n        Mockito.verify(mockrule, times(NUM_DATA_SOURCES)).apply(any(), any());\n        assertEquals(2, (int) listener.getResult());\n\n    }\n\n    @Test\n    void testAnalysisCache() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        MyFooRule rule = new MyFooRule();\n        runPmd(config, GlobalAnalysisListener.noop(), rule);\n\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(NUM_DATA_SOURCES)).isUpToDate(any());\n    }\n\n    @Test\n    void testCacheWithFailure() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        BrokenRule rule = new BrokenRule();  // the broken rule throws\n        runPmd(config, GlobalAnalysisListener.noop(), rule);\n\n        // cache methods are called regardless\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(NUM_DATA_SOURCES)).isUpToDate(any());\n    }\n\n    @Test\n    void testCacheWithPropagatedException() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        BrokenRule rule = new BrokenRule();  // the broken rule throws\n        // now the exception should be propagated\n        GlobalAnalysisListener listener = GlobalAnalysisListener.exceptionThrower();\n        FileAnalysisException exception = assertThrows(FileAnalysisException.class, () -> {\n            runPmd(config, listener, rule);\n        });\n\n        assertEquals(\"fname1.dummy\", exception.getFileName());\n\n        // cache methods are called regardless\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(1)).isUpToDate(any());\n    }\n\n    @NonNull\n    private PMDConfiguration newConfig() {\n        PMDConfiguration config = new PMDConfiguration();\n        config.setAnalysisCache(new NoopAnalysisCache());\n        config.setIgnoreIncrementalAnalysis(true);\n        config.setThreads(1);\n        return config;\n    }\n\n    private void runPmd(PMDConfiguration config, GlobalAnalysisListener listener, Rule rule) {\n        try (PmdAnalysis pmd = PmdAnalysis.create(config)) {\n            pmd.addRuleSet(RuleSet.forSingleRule(rule));\n            pmd.files().addSourceFile(\"abc\", \"fname1.dummy\");\n            pmd.files().addSourceFile(\"abcd\", \"fname2.dummy\");\n            pmd.files().addSourceFile(\"abcd\", \"fname21.dummy\");\n            pmd.addListener(listener);\n            pmd.performAnalysis();\n        }\n    }\n\n\n    public static class MyFooRule extends FooRule {\n\n        @Override\n        public void apply(Node node, RuleContext ctx) {\n            if (node.getTextDocument().getDisplayName().contains(\"1\")) {\n                ctx.addViolation(node);\n            }\n        }\n    }\n\n    public static class BrokenRule extends FooRule {\n\n        @Override\n        public void apply(Node node, RuleContext ctx) {\n            throw new IllegalArgumentException(\"Something happened\");\n        }\n    }\n}\n",
        "filePathAfter": "pmd-core/src/test/java/net/sourceforge/pmd/reporting/GlobalAnalysisListenerTest.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.reporting;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.spy;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport java.util.Arrays;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\n\nimport net.sourceforge.pmd.FooRule;\nimport net.sourceforge.pmd.PMDConfiguration;\nimport net.sourceforge.pmd.PmdAnalysis;\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RuleContext;\nimport net.sourceforge.pmd.RuleSet;\nimport net.sourceforge.pmd.cache.AnalysisCache;\nimport net.sourceforge.pmd.cache.NoopAnalysisCache;\nimport net.sourceforge.pmd.lang.ast.FileAnalysisException;\nimport net.sourceforge.pmd.lang.ast.Node;\n\nclass GlobalAnalysisListenerTest {\n\n    static final int NUM_DATA_SOURCES = 3;\n\n    @Test\n    void testViolationCounter() {\n\n        PMDConfiguration config = newConfig();\n\n        GlobalAnalysisListener.ViolationCounterListener listener = new GlobalAnalysisListener.ViolationCounterListener();\n\n        MyFooRule mockrule = Mockito.spy(MyFooRule.class);\n        runPmd(config, listener, mockrule);\n\n        Mockito.verify(mockrule, times(NUM_DATA_SOURCES)).apply(any(), any());\n        assertEquals(2, (int) listener.getResult());\n\n    }\n\n    @Test\n    void testViolationCounterOnMulti() {\n\n        PMDConfiguration config = newConfig();\n        config.setThreads(2);\n\n        GlobalAnalysisListener.ViolationCounterListener listener = new GlobalAnalysisListener.ViolationCounterListener();\n\n        MyFooRule mockrule = Mockito.spy(MyFooRule.class);\n        when(mockrule.deepCopy()).thenReturn(mockrule); // the spy cannot track the deep copies\n\n        runPmd(config, listener, mockrule);\n\n        Mockito.verify(mockrule, times(NUM_DATA_SOURCES)).apply(any(), any());\n        assertEquals(2, (int) listener.getResult());\n\n    }\n\n    @Test\n    void testAnalysisCache() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        MyFooRule rule = new MyFooRule();\n        runPmd(config, GlobalAnalysisListener.noop(), rule);\n\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(NUM_DATA_SOURCES)).isUpToDate(any());\n    }\n\n    @Test\n    void testCacheWithFailure() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        BrokenRule rule = new BrokenRule();  // the broken rule throws\n        runPmd(config, GlobalAnalysisListener.noop(), rule);\n\n        // cache methods are called regardless\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(NUM_DATA_SOURCES)).isUpToDate(any());\n    }\n\n    @Test\n    void testCacheWithPropagatedException() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        BrokenRule rule = new BrokenRule();  // the broken rule throws\n        // now the exception should be propagated\n        GlobalAnalysisListener listener = GlobalAnalysisListener.exceptionThrower();\n        FileAnalysisException exception = assertThrows(FileAnalysisException.class, () -> {\n            runPmd(config, listener, rule);\n        });\n\n        assertEquals(\"fname1.dummy\", exception.getFileName());\n\n        // cache methods are called regardless\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(1)).isUpToDate(any());\n    }\n\n    @Test\n    void teeShouldForwardAllEventsSingleListeners() throws Exception {\n        GlobalAnalysisListener mockListener1 = createMockListener();\n        GlobalAnalysisListener teed = GlobalAnalysisListener.tee(Arrays.asList(mockListener1));\n\n        teed.initializer();\n        teed.startFileAnalysis(null);\n        teed.onConfigError(null);\n        teed.close();\n\n        verifyMethods(mockListener1);\n        Mockito.verifyNoMoreInteractions(mockListener1);\n    }\n\n    @NonNull\n    private PMDConfiguration newConfig() {\n        PMDConfiguration config = new PMDConfiguration();\n        config.setAnalysisCache(new NoopAnalysisCache());\n        config.setIgnoreIncrementalAnalysis(true);\n        config.setThreads(1);\n        return config;\n    }\n\n    private void runPmd(PMDConfiguration config, GlobalAnalysisListener listener, Rule rule) {\n        try (PmdAnalysis pmd = PmdAnalysis.create(config)) {\n            pmd.addRuleSet(RuleSet.forSingleRule(rule));\n            pmd.files().addSourceFile(\"abc\", \"fname1.dummy\");\n            pmd.files().addSourceFile(\"abcd\", \"fname2.dummy\");\n            pmd.files().addSourceFile(\"abcd\", \"fname21.dummy\");\n            pmd.addListener(listener);\n            pmd.performAnalysis();\n        }\n    }\n\n\n    public static class MyFooRule extends FooRule {\n\n        @Override\n        public void apply(Node node, RuleContext ctx) {\n            if (node.getTextDocument().getDisplayName().contains(\"1\")) {\n                ctx.addViolation(node);\n            }\n        }\n    }\n\n    public static class BrokenRule extends FooRule {\n\n        @Override\n        public void apply(Node node, RuleContext ctx) {\n            throw new IllegalArgumentException(\"Something happened\");\n        }\n    }\n\n    @Test\n    void teeShouldForwardAllEventsMultipleListeners() throws Exception {\n        GlobalAnalysisListener mockListener1 = createMockListener();\n        GlobalAnalysisListener mockListener2 = createMockListener();\n        GlobalAnalysisListener teed = GlobalAnalysisListener.tee(Arrays.asList(mockListener1, mockListener2));\n\n        teed.initializer();\n        teed.startFileAnalysis(null);\n        teed.onConfigError(null);\n        teed.close();\n\n        verifyMethods(mockListener1);\n        verifyMethods(mockListener2);\n        Mockito.verifyNoMoreInteractions(mockListener1, mockListener2);\n    }\n\n    private GlobalAnalysisListener createMockListener() {\n        GlobalAnalysisListener mockListener = Mockito.mock(GlobalAnalysisListener.class);\n        Mockito.when(mockListener.initializer()).thenReturn(ListenerInitializer.noop());\n        Mockito.when(mockListener.startFileAnalysis(Mockito.any())).thenReturn(FileAnalysisListener.noop());\n        return mockListener;\n    }\n\n    private void verifyMethods(GlobalAnalysisListener listener) throws Exception {\n        Mockito.verify(listener, Mockito.times(1)).initializer();\n        Mockito.verify(listener, Mockito.times(1)).startFileAnalysis(null);\n        Mockito.verify(listener, Mockito.times(1)).onConfigError(null);\n        Mockito.verify(listener, Mockito.times(1)).close();\n    }\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "@NonNull\n    private PMDConfiguration newConfig() {\n        PMDConfiguration config = new PMDConfiguration();\n        config.setAnalysisCache(new NoopAnalysisCache());\n        config.setIgnoreIncrementalAnalysis(true);\n        config.setThreads(1);\n        return config;\n    }",
        "diffSourceCode": "-  122:     @NonNull\n-  123:     private PMDConfiguration newConfig() {\n-  124:         PMDConfiguration config = new PMDConfiguration();\n-  125:         config.setAnalysisCache(new NoopAnalysisCache());\n-  126:         config.setIgnoreIncrementalAnalysis(true);\n-  127:         config.setThreads(1);\n-  128:         return config;\n-  129:     }\n-  136:             pmd.files().addSourceFile(\"abcd\", \"fname21.dummy\");\n-  137:             pmd.addListener(listener);\n-  138:             pmd.performAnalysis();\n-  139:         }\n-  140:     }\n-  141: \n-  142: \n-  143:     public static class MyFooRule extends FooRule {\n+  122:     @Test\n+  123:     void teeShouldForwardAllEventsSingleListeners() throws Exception {\n+  124:         GlobalAnalysisListener mockListener1 = createMockListener();\n+  125:         GlobalAnalysisListener teed = GlobalAnalysisListener.tee(Arrays.asList(mockListener1));\n+  126: \n+  127:         teed.initializer();\n+  128:         teed.startFileAnalysis(null);\n+  129:         teed.onConfigError(null);\n+  136:     @NonNull\n+  137:     private PMDConfiguration newConfig() {\n+  138:         PMDConfiguration config = new PMDConfiguration();\n+  139:         config.setAnalysisCache(new NoopAnalysisCache());\n+  140:         config.setIgnoreIncrementalAnalysis(true);\n+  141:         config.setThreads(1);\n+  142:         return config;\n+  143:     }\n",
        "uniqueId": "e2866bebf86e86892860dd0e3a01492797fd8ea6_122_129__136_143",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Move Method",
        "description": "Move Method\tpackage testCacheWithPropagatedException() : void from class net.sourceforge.pmd.processor.GlobalListenerTest to package testCacheWithPropagatedException() : void from class net.sourceforge.pmd.reporting.GlobalAnalysisListenerTest",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/processor/GlobalListenerTest.java",
                "startLine": 100,
                "endLine": 120,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/reporting/GlobalAnalysisListenerTest.java",
                "startLine": 100,
                "endLine": 120,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n    void testCacheWithPropagatedException() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        BrokenRule rule = new BrokenRule();  // the broken rule throws\n        // now the exception should be propagated\n        GlobalAnalysisListener listener = GlobalAnalysisListener.exceptionThrower();\n        FileAnalysisException exception = assertThrows(FileAnalysisException.class, () -> {\n            runPmd(config, listener, rule);\n        });\n\n        assertEquals(\"fname1.dummy\", exception.getFileName());\n\n        // cache methods are called regardless\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(1)).isUpToDate(any());\n    }",
        "filePathBefore": "pmd-core/src/test/java/net/sourceforge/pmd/processor/GlobalListenerTest.java",
        "isPureRefactoring": true,
        "commitId": "e2866bebf86e86892860dd0e3a01492797fd8ea6",
        "packageNameBefore": "net.sourceforge.pmd.processor",
        "classNameBefore": "net.sourceforge.pmd.processor.GlobalListenerTest",
        "methodNameBefore": "net.sourceforge.pmd.processor.GlobalListenerTest#testCacheWithPropagatedException",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.processor.GlobalListenerTest#runPmd\n methodBody: private void runPmd(PMDConfiguration config, GlobalAnalysisListener listener, Rule rule) {\ntry(PmdAnalysis pmd=PmdAnalysis.create(config))pmd.addRuleSet(RuleSet.forSingleRule(rule));\npmd.files().addSourceFile(\"abc\",\"fname1.dummy\");\npmd.files().addSourceFile(\"abcd\",\"fname2.dummy\");\npmd.files().addSourceFile(\"abcd\",\"fname21.dummy\");\npmd.addListener(listener);\npmd.performAnalysis();\n}\nmethodSignature: net.sourceforge.pmd.processor.GlobalListenerTest#newConfig\n methodBody: private PMDConfiguration newConfig() {\nPMDConfiguration config=new PMDConfiguration();\nconfig.setAnalysisCache(new NoopAnalysisCache());\nconfig.setIgnoreIncrementalAnalysis(true);\nconfig.setThreads(1);\nreturn config;\n}",
        "classSignatureBefore": "class GlobalListenerTest ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.processor.GlobalListenerTest#testCacheWithPropagatedException"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.processor.GlobalListenerTest"
        ],
        "classSignatureBeforeSet": [
            "class GlobalListenerTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.processor;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.spy;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\n\nimport net.sourceforge.pmd.FooRule;\nimport net.sourceforge.pmd.PMDConfiguration;\nimport net.sourceforge.pmd.PmdAnalysis;\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RuleContext;\nimport net.sourceforge.pmd.RuleSet;\nimport net.sourceforge.pmd.cache.AnalysisCache;\nimport net.sourceforge.pmd.cache.NoopAnalysisCache;\nimport net.sourceforge.pmd.lang.ast.FileAnalysisException;\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.reporting.GlobalAnalysisListener;\nimport net.sourceforge.pmd.reporting.GlobalAnalysisListener.ViolationCounterListener;\n\nclass GlobalListenerTest {\n\n    static final int NUM_DATA_SOURCES = 3;\n\n    @Test\n    void testViolationCounter() throws Exception {\n\n        PMDConfiguration config = newConfig();\n\n        ViolationCounterListener listener = new GlobalAnalysisListener.ViolationCounterListener();\n\n        MyFooRule mockrule = Mockito.spy(MyFooRule.class);\n        runPmd(config, listener, mockrule);\n\n        Mockito.verify(mockrule, times(NUM_DATA_SOURCES)).apply(any(), any());\n        assertEquals(2, (int) listener.getResult());\n\n    }\n\n    @Test\n    void testViolationCounterOnMulti() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        config.setThreads(2);\n\n        ViolationCounterListener listener = new GlobalAnalysisListener.ViolationCounterListener();\n\n        MyFooRule mockrule = Mockito.spy(MyFooRule.class);\n        when(mockrule.deepCopy()).thenReturn(mockrule); // the spy cannot track the deep copies\n\n        runPmd(config, listener, mockrule);\n\n        Mockito.verify(mockrule, times(NUM_DATA_SOURCES)).apply(any(), any());\n        assertEquals(2, (int) listener.getResult());\n\n    }\n\n    @Test\n    void testAnalysisCache() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        MyFooRule rule = new MyFooRule();\n        runPmd(config, GlobalAnalysisListener.noop(), rule);\n\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(NUM_DATA_SOURCES)).isUpToDate(any());\n    }\n\n    @Test\n    void testCacheWithFailure() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        BrokenRule rule = new BrokenRule();  // the broken rule throws\n        runPmd(config, GlobalAnalysisListener.noop(), rule);\n\n        // cache methods are called regardless\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(NUM_DATA_SOURCES)).isUpToDate(any());\n    }\n\n    @Test\n    void testCacheWithPropagatedException() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        BrokenRule rule = new BrokenRule();  // the broken rule throws\n        // now the exception should be propagated\n        GlobalAnalysisListener listener = GlobalAnalysisListener.exceptionThrower();\n        FileAnalysisException exception = assertThrows(FileAnalysisException.class, () -> {\n            runPmd(config, listener, rule);\n        });\n\n        assertEquals(\"fname1.dummy\", exception.getFileName());\n\n        // cache methods are called regardless\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(1)).isUpToDate(any());\n    }\n\n    @NonNull\n    private PMDConfiguration newConfig() {\n        PMDConfiguration config = new PMDConfiguration();\n        config.setAnalysisCache(new NoopAnalysisCache());\n        config.setIgnoreIncrementalAnalysis(true);\n        config.setThreads(1);\n        return config;\n    }\n\n    private void runPmd(PMDConfiguration config, GlobalAnalysisListener listener, Rule rule) {\n        try (PmdAnalysis pmd = PmdAnalysis.create(config)) {\n            pmd.addRuleSet(RuleSet.forSingleRule(rule));\n            pmd.files().addSourceFile(\"abc\", \"fname1.dummy\");\n            pmd.files().addSourceFile(\"abcd\", \"fname2.dummy\");\n            pmd.files().addSourceFile(\"abcd\", \"fname21.dummy\");\n            pmd.addListener(listener);\n            pmd.performAnalysis();\n        }\n    }\n\n\n    public static class MyFooRule extends FooRule {\n\n        @Override\n        public void apply(Node node, RuleContext ctx) {\n            if (node.getTextDocument().getDisplayName().contains(\"1\")) {\n                ctx.addViolation(node);\n            }\n        }\n    }\n\n    public static class BrokenRule extends FooRule {\n\n        @Override\n        public void apply(Node node, RuleContext ctx) {\n            throw new IllegalArgumentException(\"Something happened\");\n        }\n    }\n}\n",
        "filePathAfter": "pmd-core/src/test/java/net/sourceforge/pmd/reporting/GlobalAnalysisListenerTest.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.reporting;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.spy;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport java.util.Arrays;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\n\nimport net.sourceforge.pmd.FooRule;\nimport net.sourceforge.pmd.PMDConfiguration;\nimport net.sourceforge.pmd.PmdAnalysis;\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RuleContext;\nimport net.sourceforge.pmd.RuleSet;\nimport net.sourceforge.pmd.cache.AnalysisCache;\nimport net.sourceforge.pmd.cache.NoopAnalysisCache;\nimport net.sourceforge.pmd.lang.ast.FileAnalysisException;\nimport net.sourceforge.pmd.lang.ast.Node;\n\nclass GlobalAnalysisListenerTest {\n\n    static final int NUM_DATA_SOURCES = 3;\n\n    @Test\n    void testViolationCounter() {\n\n        PMDConfiguration config = newConfig();\n\n        GlobalAnalysisListener.ViolationCounterListener listener = new GlobalAnalysisListener.ViolationCounterListener();\n\n        MyFooRule mockrule = Mockito.spy(MyFooRule.class);\n        runPmd(config, listener, mockrule);\n\n        Mockito.verify(mockrule, times(NUM_DATA_SOURCES)).apply(any(), any());\n        assertEquals(2, (int) listener.getResult());\n\n    }\n\n    @Test\n    void testViolationCounterOnMulti() {\n\n        PMDConfiguration config = newConfig();\n        config.setThreads(2);\n\n        GlobalAnalysisListener.ViolationCounterListener listener = new GlobalAnalysisListener.ViolationCounterListener();\n\n        MyFooRule mockrule = Mockito.spy(MyFooRule.class);\n        when(mockrule.deepCopy()).thenReturn(mockrule); // the spy cannot track the deep copies\n\n        runPmd(config, listener, mockrule);\n\n        Mockito.verify(mockrule, times(NUM_DATA_SOURCES)).apply(any(), any());\n        assertEquals(2, (int) listener.getResult());\n\n    }\n\n    @Test\n    void testAnalysisCache() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        MyFooRule rule = new MyFooRule();\n        runPmd(config, GlobalAnalysisListener.noop(), rule);\n\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(NUM_DATA_SOURCES)).isUpToDate(any());\n    }\n\n    @Test\n    void testCacheWithFailure() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        BrokenRule rule = new BrokenRule();  // the broken rule throws\n        runPmd(config, GlobalAnalysisListener.noop(), rule);\n\n        // cache methods are called regardless\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(NUM_DATA_SOURCES)).isUpToDate(any());\n    }\n\n    @Test\n    void testCacheWithPropagatedException() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        BrokenRule rule = new BrokenRule();  // the broken rule throws\n        // now the exception should be propagated\n        GlobalAnalysisListener listener = GlobalAnalysisListener.exceptionThrower();\n        FileAnalysisException exception = assertThrows(FileAnalysisException.class, () -> {\n            runPmd(config, listener, rule);\n        });\n\n        assertEquals(\"fname1.dummy\", exception.getFileName());\n\n        // cache methods are called regardless\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(1)).isUpToDate(any());\n    }\n\n    @Test\n    void teeShouldForwardAllEventsSingleListeners() throws Exception {\n        GlobalAnalysisListener mockListener1 = createMockListener();\n        GlobalAnalysisListener teed = GlobalAnalysisListener.tee(Arrays.asList(mockListener1));\n\n        teed.initializer();\n        teed.startFileAnalysis(null);\n        teed.onConfigError(null);\n        teed.close();\n\n        verifyMethods(mockListener1);\n        Mockito.verifyNoMoreInteractions(mockListener1);\n    }\n\n    @NonNull\n    private PMDConfiguration newConfig() {\n        PMDConfiguration config = new PMDConfiguration();\n        config.setAnalysisCache(new NoopAnalysisCache());\n        config.setIgnoreIncrementalAnalysis(true);\n        config.setThreads(1);\n        return config;\n    }\n\n    private void runPmd(PMDConfiguration config, GlobalAnalysisListener listener, Rule rule) {\n        try (PmdAnalysis pmd = PmdAnalysis.create(config)) {\n            pmd.addRuleSet(RuleSet.forSingleRule(rule));\n            pmd.files().addSourceFile(\"abc\", \"fname1.dummy\");\n            pmd.files().addSourceFile(\"abcd\", \"fname2.dummy\");\n            pmd.files().addSourceFile(\"abcd\", \"fname21.dummy\");\n            pmd.addListener(listener);\n            pmd.performAnalysis();\n        }\n    }\n\n\n    public static class MyFooRule extends FooRule {\n\n        @Override\n        public void apply(Node node, RuleContext ctx) {\n            if (node.getTextDocument().getDisplayName().contains(\"1\")) {\n                ctx.addViolation(node);\n            }\n        }\n    }\n\n    public static class BrokenRule extends FooRule {\n\n        @Override\n        public void apply(Node node, RuleContext ctx) {\n            throw new IllegalArgumentException(\"Something happened\");\n        }\n    }\n\n    @Test\n    void teeShouldForwardAllEventsMultipleListeners() throws Exception {\n        GlobalAnalysisListener mockListener1 = createMockListener();\n        GlobalAnalysisListener mockListener2 = createMockListener();\n        GlobalAnalysisListener teed = GlobalAnalysisListener.tee(Arrays.asList(mockListener1, mockListener2));\n\n        teed.initializer();\n        teed.startFileAnalysis(null);\n        teed.onConfigError(null);\n        teed.close();\n\n        verifyMethods(mockListener1);\n        verifyMethods(mockListener2);\n        Mockito.verifyNoMoreInteractions(mockListener1, mockListener2);\n    }\n\n    private GlobalAnalysisListener createMockListener() {\n        GlobalAnalysisListener mockListener = Mockito.mock(GlobalAnalysisListener.class);\n        Mockito.when(mockListener.initializer()).thenReturn(ListenerInitializer.noop());\n        Mockito.when(mockListener.startFileAnalysis(Mockito.any())).thenReturn(FileAnalysisListener.noop());\n        return mockListener;\n    }\n\n    private void verifyMethods(GlobalAnalysisListener listener) throws Exception {\n        Mockito.verify(listener, Mockito.times(1)).initializer();\n        Mockito.verify(listener, Mockito.times(1)).startFileAnalysis(null);\n        Mockito.verify(listener, Mockito.times(1)).onConfigError(null);\n        Mockito.verify(listener, Mockito.times(1)).close();\n    }\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.processor.GlobalListenerTest#runPmd\n methodBody: private void runPmd(PMDConfiguration config, GlobalAnalysisListener listener, Rule rule) {\ntry(PmdAnalysis pmd=PmdAnalysis.create(config))pmd.addRuleSet(RuleSet.forSingleRule(rule));\npmd.files().addSourceFile(\"abc\",\"fname1.dummy\");\npmd.files().addSourceFile(\"abcd\",\"fname2.dummy\");\npmd.files().addSourceFile(\"abcd\",\"fname21.dummy\");\npmd.addListener(listener);\npmd.performAnalysis();\n}",
            "methodSignature: net.sourceforge.pmd.processor.GlobalListenerTest#newConfig\n methodBody: private PMDConfiguration newConfig() {\nPMDConfiguration config=new PMDConfiguration();\nconfig.setAnalysisCache(new NoopAnalysisCache());\nconfig.setIgnoreIncrementalAnalysis(true);\nconfig.setThreads(1);\nreturn config;\n}"
        ],
        "sourceCodeAfterRefactoring": "@Test\n    void testCacheWithPropagatedException() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        BrokenRule rule = new BrokenRule();  // the broken rule throws\n        // now the exception should be propagated\n        GlobalAnalysisListener listener = GlobalAnalysisListener.exceptionThrower();\n        FileAnalysisException exception = assertThrows(FileAnalysisException.class, () -> {\n            runPmd(config, listener, rule);\n        });\n\n        assertEquals(\"fname1.dummy\", exception.getFileName());\n\n        // cache methods are called regardless\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(1)).isUpToDate(any());\n    }",
        "diffSourceCode": "   100:     @Test\n   101:     void testCacheWithPropagatedException() throws Exception {\n   102: \n   103:         PMDConfiguration config = newConfig();\n   104:         AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n   105:         config.setAnalysisCache(mockCache);\n   106: \n   107:         BrokenRule rule = new BrokenRule();  // the broken rule throws\n   108:         // now the exception should be propagated\n   109:         GlobalAnalysisListener listener = GlobalAnalysisListener.exceptionThrower();\n   110:         FileAnalysisException exception = assertThrows(FileAnalysisException.class, () -> {\n   111:             runPmd(config, listener, rule);\n   112:         });\n   113: \n   114:         assertEquals(\"fname1.dummy\", exception.getFileName());\n   115: \n   116:         // cache methods are called regardless\n   117:         verify(mockCache).checkValidity(any(), any());\n   118:         verify(mockCache, times(1)).persist();\n   119:         verify(mockCache, times(1)).isUpToDate(any());\n   120:     }\n",
        "uniqueId": "e2866bebf86e86892860dd0e3a01492797fd8ea6_100_120__100_120",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Move Method",
        "description": "Move Method\tpackage testCacheWithFailure() : void from class net.sourceforge.pmd.processor.GlobalListenerTest to package testCacheWithFailure() : void from class net.sourceforge.pmd.reporting.GlobalAnalysisListenerTest",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/processor/GlobalListenerTest.java",
                "startLine": 84,
                "endLine": 98,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/reporting/GlobalAnalysisListenerTest.java",
                "startLine": 84,
                "endLine": 98,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n    void testCacheWithFailure() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        BrokenRule rule = new BrokenRule();  // the broken rule throws\n        runPmd(config, GlobalAnalysisListener.noop(), rule);\n\n        // cache methods are called regardless\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(NUM_DATA_SOURCES)).isUpToDate(any());\n    }",
        "filePathBefore": "pmd-core/src/test/java/net/sourceforge/pmd/processor/GlobalListenerTest.java",
        "isPureRefactoring": true,
        "commitId": "e2866bebf86e86892860dd0e3a01492797fd8ea6",
        "packageNameBefore": "net.sourceforge.pmd.processor",
        "classNameBefore": "net.sourceforge.pmd.processor.GlobalListenerTest",
        "methodNameBefore": "net.sourceforge.pmd.processor.GlobalListenerTest#testCacheWithFailure",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.processor.GlobalListenerTest#runPmd\n methodBody: private void runPmd(PMDConfiguration config, GlobalAnalysisListener listener, Rule rule) {\ntry(PmdAnalysis pmd=PmdAnalysis.create(config))pmd.addRuleSet(RuleSet.forSingleRule(rule));\npmd.files().addSourceFile(\"abc\",\"fname1.dummy\");\npmd.files().addSourceFile(\"abcd\",\"fname2.dummy\");\npmd.files().addSourceFile(\"abcd\",\"fname21.dummy\");\npmd.addListener(listener);\npmd.performAnalysis();\n}\nmethodSignature: net.sourceforge.pmd.processor.GlobalListenerTest#newConfig\n methodBody: private PMDConfiguration newConfig() {\nPMDConfiguration config=new PMDConfiguration();\nconfig.setAnalysisCache(new NoopAnalysisCache());\nconfig.setIgnoreIncrementalAnalysis(true);\nconfig.setThreads(1);\nreturn config;\n}",
        "classSignatureBefore": "class GlobalListenerTest ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.processor.GlobalListenerTest#testCacheWithFailure"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.processor.GlobalListenerTest"
        ],
        "classSignatureBeforeSet": [
            "class GlobalListenerTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.processor;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.spy;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\n\nimport net.sourceforge.pmd.FooRule;\nimport net.sourceforge.pmd.PMDConfiguration;\nimport net.sourceforge.pmd.PmdAnalysis;\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RuleContext;\nimport net.sourceforge.pmd.RuleSet;\nimport net.sourceforge.pmd.cache.AnalysisCache;\nimport net.sourceforge.pmd.cache.NoopAnalysisCache;\nimport net.sourceforge.pmd.lang.ast.FileAnalysisException;\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.reporting.GlobalAnalysisListener;\nimport net.sourceforge.pmd.reporting.GlobalAnalysisListener.ViolationCounterListener;\n\nclass GlobalListenerTest {\n\n    static final int NUM_DATA_SOURCES = 3;\n\n    @Test\n    void testViolationCounter() throws Exception {\n\n        PMDConfiguration config = newConfig();\n\n        ViolationCounterListener listener = new GlobalAnalysisListener.ViolationCounterListener();\n\n        MyFooRule mockrule = Mockito.spy(MyFooRule.class);\n        runPmd(config, listener, mockrule);\n\n        Mockito.verify(mockrule, times(NUM_DATA_SOURCES)).apply(any(), any());\n        assertEquals(2, (int) listener.getResult());\n\n    }\n\n    @Test\n    void testViolationCounterOnMulti() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        config.setThreads(2);\n\n        ViolationCounterListener listener = new GlobalAnalysisListener.ViolationCounterListener();\n\n        MyFooRule mockrule = Mockito.spy(MyFooRule.class);\n        when(mockrule.deepCopy()).thenReturn(mockrule); // the spy cannot track the deep copies\n\n        runPmd(config, listener, mockrule);\n\n        Mockito.verify(mockrule, times(NUM_DATA_SOURCES)).apply(any(), any());\n        assertEquals(2, (int) listener.getResult());\n\n    }\n\n    @Test\n    void testAnalysisCache() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        MyFooRule rule = new MyFooRule();\n        runPmd(config, GlobalAnalysisListener.noop(), rule);\n\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(NUM_DATA_SOURCES)).isUpToDate(any());\n    }\n\n    @Test\n    void testCacheWithFailure() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        BrokenRule rule = new BrokenRule();  // the broken rule throws\n        runPmd(config, GlobalAnalysisListener.noop(), rule);\n\n        // cache methods are called regardless\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(NUM_DATA_SOURCES)).isUpToDate(any());\n    }\n\n    @Test\n    void testCacheWithPropagatedException() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        BrokenRule rule = new BrokenRule();  // the broken rule throws\n        // now the exception should be propagated\n        GlobalAnalysisListener listener = GlobalAnalysisListener.exceptionThrower();\n        FileAnalysisException exception = assertThrows(FileAnalysisException.class, () -> {\n            runPmd(config, listener, rule);\n        });\n\n        assertEquals(\"fname1.dummy\", exception.getFileName());\n\n        // cache methods are called regardless\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(1)).isUpToDate(any());\n    }\n\n    @NonNull\n    private PMDConfiguration newConfig() {\n        PMDConfiguration config = new PMDConfiguration();\n        config.setAnalysisCache(new NoopAnalysisCache());\n        config.setIgnoreIncrementalAnalysis(true);\n        config.setThreads(1);\n        return config;\n    }\n\n    private void runPmd(PMDConfiguration config, GlobalAnalysisListener listener, Rule rule) {\n        try (PmdAnalysis pmd = PmdAnalysis.create(config)) {\n            pmd.addRuleSet(RuleSet.forSingleRule(rule));\n            pmd.files().addSourceFile(\"abc\", \"fname1.dummy\");\n            pmd.files().addSourceFile(\"abcd\", \"fname2.dummy\");\n            pmd.files().addSourceFile(\"abcd\", \"fname21.dummy\");\n            pmd.addListener(listener);\n            pmd.performAnalysis();\n        }\n    }\n\n\n    public static class MyFooRule extends FooRule {\n\n        @Override\n        public void apply(Node node, RuleContext ctx) {\n            if (node.getTextDocument().getDisplayName().contains(\"1\")) {\n                ctx.addViolation(node);\n            }\n        }\n    }\n\n    public static class BrokenRule extends FooRule {\n\n        @Override\n        public void apply(Node node, RuleContext ctx) {\n            throw new IllegalArgumentException(\"Something happened\");\n        }\n    }\n}\n",
        "filePathAfter": "pmd-core/src/test/java/net/sourceforge/pmd/reporting/GlobalAnalysisListenerTest.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.reporting;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.spy;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport java.util.Arrays;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\n\nimport net.sourceforge.pmd.FooRule;\nimport net.sourceforge.pmd.PMDConfiguration;\nimport net.sourceforge.pmd.PmdAnalysis;\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RuleContext;\nimport net.sourceforge.pmd.RuleSet;\nimport net.sourceforge.pmd.cache.AnalysisCache;\nimport net.sourceforge.pmd.cache.NoopAnalysisCache;\nimport net.sourceforge.pmd.lang.ast.FileAnalysisException;\nimport net.sourceforge.pmd.lang.ast.Node;\n\nclass GlobalAnalysisListenerTest {\n\n    static final int NUM_DATA_SOURCES = 3;\n\n    @Test\n    void testViolationCounter() {\n\n        PMDConfiguration config = newConfig();\n\n        GlobalAnalysisListener.ViolationCounterListener listener = new GlobalAnalysisListener.ViolationCounterListener();\n\n        MyFooRule mockrule = Mockito.spy(MyFooRule.class);\n        runPmd(config, listener, mockrule);\n\n        Mockito.verify(mockrule, times(NUM_DATA_SOURCES)).apply(any(), any());\n        assertEquals(2, (int) listener.getResult());\n\n    }\n\n    @Test\n    void testViolationCounterOnMulti() {\n\n        PMDConfiguration config = newConfig();\n        config.setThreads(2);\n\n        GlobalAnalysisListener.ViolationCounterListener listener = new GlobalAnalysisListener.ViolationCounterListener();\n\n        MyFooRule mockrule = Mockito.spy(MyFooRule.class);\n        when(mockrule.deepCopy()).thenReturn(mockrule); // the spy cannot track the deep copies\n\n        runPmd(config, listener, mockrule);\n\n        Mockito.verify(mockrule, times(NUM_DATA_SOURCES)).apply(any(), any());\n        assertEquals(2, (int) listener.getResult());\n\n    }\n\n    @Test\n    void testAnalysisCache() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        MyFooRule rule = new MyFooRule();\n        runPmd(config, GlobalAnalysisListener.noop(), rule);\n\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(NUM_DATA_SOURCES)).isUpToDate(any());\n    }\n\n    @Test\n    void testCacheWithFailure() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        BrokenRule rule = new BrokenRule();  // the broken rule throws\n        runPmd(config, GlobalAnalysisListener.noop(), rule);\n\n        // cache methods are called regardless\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(NUM_DATA_SOURCES)).isUpToDate(any());\n    }\n\n    @Test\n    void testCacheWithPropagatedException() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        BrokenRule rule = new BrokenRule();  // the broken rule throws\n        // now the exception should be propagated\n        GlobalAnalysisListener listener = GlobalAnalysisListener.exceptionThrower();\n        FileAnalysisException exception = assertThrows(FileAnalysisException.class, () -> {\n            runPmd(config, listener, rule);\n        });\n\n        assertEquals(\"fname1.dummy\", exception.getFileName());\n\n        // cache methods are called regardless\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(1)).isUpToDate(any());\n    }\n\n    @Test\n    void teeShouldForwardAllEventsSingleListeners() throws Exception {\n        GlobalAnalysisListener mockListener1 = createMockListener();\n        GlobalAnalysisListener teed = GlobalAnalysisListener.tee(Arrays.asList(mockListener1));\n\n        teed.initializer();\n        teed.startFileAnalysis(null);\n        teed.onConfigError(null);\n        teed.close();\n\n        verifyMethods(mockListener1);\n        Mockito.verifyNoMoreInteractions(mockListener1);\n    }\n\n    @NonNull\n    private PMDConfiguration newConfig() {\n        PMDConfiguration config = new PMDConfiguration();\n        config.setAnalysisCache(new NoopAnalysisCache());\n        config.setIgnoreIncrementalAnalysis(true);\n        config.setThreads(1);\n        return config;\n    }\n\n    private void runPmd(PMDConfiguration config, GlobalAnalysisListener listener, Rule rule) {\n        try (PmdAnalysis pmd = PmdAnalysis.create(config)) {\n            pmd.addRuleSet(RuleSet.forSingleRule(rule));\n            pmd.files().addSourceFile(\"abc\", \"fname1.dummy\");\n            pmd.files().addSourceFile(\"abcd\", \"fname2.dummy\");\n            pmd.files().addSourceFile(\"abcd\", \"fname21.dummy\");\n            pmd.addListener(listener);\n            pmd.performAnalysis();\n        }\n    }\n\n\n    public static class MyFooRule extends FooRule {\n\n        @Override\n        public void apply(Node node, RuleContext ctx) {\n            if (node.getTextDocument().getDisplayName().contains(\"1\")) {\n                ctx.addViolation(node);\n            }\n        }\n    }\n\n    public static class BrokenRule extends FooRule {\n\n        @Override\n        public void apply(Node node, RuleContext ctx) {\n            throw new IllegalArgumentException(\"Something happened\");\n        }\n    }\n\n    @Test\n    void teeShouldForwardAllEventsMultipleListeners() throws Exception {\n        GlobalAnalysisListener mockListener1 = createMockListener();\n        GlobalAnalysisListener mockListener2 = createMockListener();\n        GlobalAnalysisListener teed = GlobalAnalysisListener.tee(Arrays.asList(mockListener1, mockListener2));\n\n        teed.initializer();\n        teed.startFileAnalysis(null);\n        teed.onConfigError(null);\n        teed.close();\n\n        verifyMethods(mockListener1);\n        verifyMethods(mockListener2);\n        Mockito.verifyNoMoreInteractions(mockListener1, mockListener2);\n    }\n\n    private GlobalAnalysisListener createMockListener() {\n        GlobalAnalysisListener mockListener = Mockito.mock(GlobalAnalysisListener.class);\n        Mockito.when(mockListener.initializer()).thenReturn(ListenerInitializer.noop());\n        Mockito.when(mockListener.startFileAnalysis(Mockito.any())).thenReturn(FileAnalysisListener.noop());\n        return mockListener;\n    }\n\n    private void verifyMethods(GlobalAnalysisListener listener) throws Exception {\n        Mockito.verify(listener, Mockito.times(1)).initializer();\n        Mockito.verify(listener, Mockito.times(1)).startFileAnalysis(null);\n        Mockito.verify(listener, Mockito.times(1)).onConfigError(null);\n        Mockito.verify(listener, Mockito.times(1)).close();\n    }\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.processor.GlobalListenerTest#runPmd\n methodBody: private void runPmd(PMDConfiguration config, GlobalAnalysisListener listener, Rule rule) {\ntry(PmdAnalysis pmd=PmdAnalysis.create(config))pmd.addRuleSet(RuleSet.forSingleRule(rule));\npmd.files().addSourceFile(\"abc\",\"fname1.dummy\");\npmd.files().addSourceFile(\"abcd\",\"fname2.dummy\");\npmd.files().addSourceFile(\"abcd\",\"fname21.dummy\");\npmd.addListener(listener);\npmd.performAnalysis();\n}",
            "methodSignature: net.sourceforge.pmd.processor.GlobalListenerTest#newConfig\n methodBody: private PMDConfiguration newConfig() {\nPMDConfiguration config=new PMDConfiguration();\nconfig.setAnalysisCache(new NoopAnalysisCache());\nconfig.setIgnoreIncrementalAnalysis(true);\nconfig.setThreads(1);\nreturn config;\n}"
        ],
        "sourceCodeAfterRefactoring": "@Test\n    void testCacheWithFailure() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        BrokenRule rule = new BrokenRule();  // the broken rule throws\n        runPmd(config, GlobalAnalysisListener.noop(), rule);\n\n        // cache methods are called regardless\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(NUM_DATA_SOURCES)).isUpToDate(any());\n    }",
        "diffSourceCode": "    84:     @Test\n    85:     void testCacheWithFailure() throws Exception {\n    86: \n    87:         PMDConfiguration config = newConfig();\n    88:         AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n    89:         config.setAnalysisCache(mockCache);\n    90: \n    91:         BrokenRule rule = new BrokenRule();  // the broken rule throws\n    92:         runPmd(config, GlobalAnalysisListener.noop(), rule);\n    93: \n    94:         // cache methods are called regardless\n    95:         verify(mockCache).checkValidity(any(), any());\n    96:         verify(mockCache, times(1)).persist();\n    97:         verify(mockCache, times(NUM_DATA_SOURCES)).isUpToDate(any());\n    98:     }\n",
        "uniqueId": "e2866bebf86e86892860dd0e3a01492797fd8ea6_84_98__84_98",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Move Method",
        "description": "Move Method\tpackage testAnalysisCache() : void from class net.sourceforge.pmd.processor.GlobalListenerTest to package testAnalysisCache() : void from class net.sourceforge.pmd.reporting.GlobalAnalysisListenerTest",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/processor/GlobalListenerTest.java",
                "startLine": 69,
                "endLine": 82,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/reporting/GlobalAnalysisListenerTest.java",
                "startLine": 69,
                "endLine": 82,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n    void testAnalysisCache() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        MyFooRule rule = new MyFooRule();\n        runPmd(config, GlobalAnalysisListener.noop(), rule);\n\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(NUM_DATA_SOURCES)).isUpToDate(any());\n    }",
        "filePathBefore": "pmd-core/src/test/java/net/sourceforge/pmd/processor/GlobalListenerTest.java",
        "isPureRefactoring": true,
        "commitId": "e2866bebf86e86892860dd0e3a01492797fd8ea6",
        "packageNameBefore": "net.sourceforge.pmd.processor",
        "classNameBefore": "net.sourceforge.pmd.processor.GlobalListenerTest",
        "methodNameBefore": "net.sourceforge.pmd.processor.GlobalListenerTest#testAnalysisCache",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.processor.GlobalListenerTest#runPmd\n methodBody: private void runPmd(PMDConfiguration config, GlobalAnalysisListener listener, Rule rule) {\ntry(PmdAnalysis pmd=PmdAnalysis.create(config))pmd.addRuleSet(RuleSet.forSingleRule(rule));\npmd.files().addSourceFile(\"abc\",\"fname1.dummy\");\npmd.files().addSourceFile(\"abcd\",\"fname2.dummy\");\npmd.files().addSourceFile(\"abcd\",\"fname21.dummy\");\npmd.addListener(listener);\npmd.performAnalysis();\n}\nmethodSignature: net.sourceforge.pmd.processor.GlobalListenerTest#newConfig\n methodBody: private PMDConfiguration newConfig() {\nPMDConfiguration config=new PMDConfiguration();\nconfig.setAnalysisCache(new NoopAnalysisCache());\nconfig.setIgnoreIncrementalAnalysis(true);\nconfig.setThreads(1);\nreturn config;\n}",
        "classSignatureBefore": "class GlobalListenerTest ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.processor.GlobalListenerTest#testAnalysisCache"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.processor.GlobalListenerTest"
        ],
        "classSignatureBeforeSet": [
            "class GlobalListenerTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.processor;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.spy;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\n\nimport net.sourceforge.pmd.FooRule;\nimport net.sourceforge.pmd.PMDConfiguration;\nimport net.sourceforge.pmd.PmdAnalysis;\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RuleContext;\nimport net.sourceforge.pmd.RuleSet;\nimport net.sourceforge.pmd.cache.AnalysisCache;\nimport net.sourceforge.pmd.cache.NoopAnalysisCache;\nimport net.sourceforge.pmd.lang.ast.FileAnalysisException;\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.reporting.GlobalAnalysisListener;\nimport net.sourceforge.pmd.reporting.GlobalAnalysisListener.ViolationCounterListener;\n\nclass GlobalListenerTest {\n\n    static final int NUM_DATA_SOURCES = 3;\n\n    @Test\n    void testViolationCounter() throws Exception {\n\n        PMDConfiguration config = newConfig();\n\n        ViolationCounterListener listener = new GlobalAnalysisListener.ViolationCounterListener();\n\n        MyFooRule mockrule = Mockito.spy(MyFooRule.class);\n        runPmd(config, listener, mockrule);\n\n        Mockito.verify(mockrule, times(NUM_DATA_SOURCES)).apply(any(), any());\n        assertEquals(2, (int) listener.getResult());\n\n    }\n\n    @Test\n    void testViolationCounterOnMulti() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        config.setThreads(2);\n\n        ViolationCounterListener listener = new GlobalAnalysisListener.ViolationCounterListener();\n\n        MyFooRule mockrule = Mockito.spy(MyFooRule.class);\n        when(mockrule.deepCopy()).thenReturn(mockrule); // the spy cannot track the deep copies\n\n        runPmd(config, listener, mockrule);\n\n        Mockito.verify(mockrule, times(NUM_DATA_SOURCES)).apply(any(), any());\n        assertEquals(2, (int) listener.getResult());\n\n    }\n\n    @Test\n    void testAnalysisCache() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        MyFooRule rule = new MyFooRule();\n        runPmd(config, GlobalAnalysisListener.noop(), rule);\n\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(NUM_DATA_SOURCES)).isUpToDate(any());\n    }\n\n    @Test\n    void testCacheWithFailure() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        BrokenRule rule = new BrokenRule();  // the broken rule throws\n        runPmd(config, GlobalAnalysisListener.noop(), rule);\n\n        // cache methods are called regardless\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(NUM_DATA_SOURCES)).isUpToDate(any());\n    }\n\n    @Test\n    void testCacheWithPropagatedException() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        BrokenRule rule = new BrokenRule();  // the broken rule throws\n        // now the exception should be propagated\n        GlobalAnalysisListener listener = GlobalAnalysisListener.exceptionThrower();\n        FileAnalysisException exception = assertThrows(FileAnalysisException.class, () -> {\n            runPmd(config, listener, rule);\n        });\n\n        assertEquals(\"fname1.dummy\", exception.getFileName());\n\n        // cache methods are called regardless\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(1)).isUpToDate(any());\n    }\n\n    @NonNull\n    private PMDConfiguration newConfig() {\n        PMDConfiguration config = new PMDConfiguration();\n        config.setAnalysisCache(new NoopAnalysisCache());\n        config.setIgnoreIncrementalAnalysis(true);\n        config.setThreads(1);\n        return config;\n    }\n\n    private void runPmd(PMDConfiguration config, GlobalAnalysisListener listener, Rule rule) {\n        try (PmdAnalysis pmd = PmdAnalysis.create(config)) {\n            pmd.addRuleSet(RuleSet.forSingleRule(rule));\n            pmd.files().addSourceFile(\"abc\", \"fname1.dummy\");\n            pmd.files().addSourceFile(\"abcd\", \"fname2.dummy\");\n            pmd.files().addSourceFile(\"abcd\", \"fname21.dummy\");\n            pmd.addListener(listener);\n            pmd.performAnalysis();\n        }\n    }\n\n\n    public static class MyFooRule extends FooRule {\n\n        @Override\n        public void apply(Node node, RuleContext ctx) {\n            if (node.getTextDocument().getDisplayName().contains(\"1\")) {\n                ctx.addViolation(node);\n            }\n        }\n    }\n\n    public static class BrokenRule extends FooRule {\n\n        @Override\n        public void apply(Node node, RuleContext ctx) {\n            throw new IllegalArgumentException(\"Something happened\");\n        }\n    }\n}\n",
        "filePathAfter": "pmd-core/src/test/java/net/sourceforge/pmd/reporting/GlobalAnalysisListenerTest.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.reporting;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.spy;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport java.util.Arrays;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\n\nimport net.sourceforge.pmd.FooRule;\nimport net.sourceforge.pmd.PMDConfiguration;\nimport net.sourceforge.pmd.PmdAnalysis;\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RuleContext;\nimport net.sourceforge.pmd.RuleSet;\nimport net.sourceforge.pmd.cache.AnalysisCache;\nimport net.sourceforge.pmd.cache.NoopAnalysisCache;\nimport net.sourceforge.pmd.lang.ast.FileAnalysisException;\nimport net.sourceforge.pmd.lang.ast.Node;\n\nclass GlobalAnalysisListenerTest {\n\n    static final int NUM_DATA_SOURCES = 3;\n\n    @Test\n    void testViolationCounter() {\n\n        PMDConfiguration config = newConfig();\n\n        GlobalAnalysisListener.ViolationCounterListener listener = new GlobalAnalysisListener.ViolationCounterListener();\n\n        MyFooRule mockrule = Mockito.spy(MyFooRule.class);\n        runPmd(config, listener, mockrule);\n\n        Mockito.verify(mockrule, times(NUM_DATA_SOURCES)).apply(any(), any());\n        assertEquals(2, (int) listener.getResult());\n\n    }\n\n    @Test\n    void testViolationCounterOnMulti() {\n\n        PMDConfiguration config = newConfig();\n        config.setThreads(2);\n\n        GlobalAnalysisListener.ViolationCounterListener listener = new GlobalAnalysisListener.ViolationCounterListener();\n\n        MyFooRule mockrule = Mockito.spy(MyFooRule.class);\n        when(mockrule.deepCopy()).thenReturn(mockrule); // the spy cannot track the deep copies\n\n        runPmd(config, listener, mockrule);\n\n        Mockito.verify(mockrule, times(NUM_DATA_SOURCES)).apply(any(), any());\n        assertEquals(2, (int) listener.getResult());\n\n    }\n\n    @Test\n    void testAnalysisCache() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        MyFooRule rule = new MyFooRule();\n        runPmd(config, GlobalAnalysisListener.noop(), rule);\n\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(NUM_DATA_SOURCES)).isUpToDate(any());\n    }\n\n    @Test\n    void testCacheWithFailure() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        BrokenRule rule = new BrokenRule();  // the broken rule throws\n        runPmd(config, GlobalAnalysisListener.noop(), rule);\n\n        // cache methods are called regardless\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(NUM_DATA_SOURCES)).isUpToDate(any());\n    }\n\n    @Test\n    void testCacheWithPropagatedException() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        BrokenRule rule = new BrokenRule();  // the broken rule throws\n        // now the exception should be propagated\n        GlobalAnalysisListener listener = GlobalAnalysisListener.exceptionThrower();\n        FileAnalysisException exception = assertThrows(FileAnalysisException.class, () -> {\n            runPmd(config, listener, rule);\n        });\n\n        assertEquals(\"fname1.dummy\", exception.getFileName());\n\n        // cache methods are called regardless\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(1)).isUpToDate(any());\n    }\n\n    @Test\n    void teeShouldForwardAllEventsSingleListeners() throws Exception {\n        GlobalAnalysisListener mockListener1 = createMockListener();\n        GlobalAnalysisListener teed = GlobalAnalysisListener.tee(Arrays.asList(mockListener1));\n\n        teed.initializer();\n        teed.startFileAnalysis(null);\n        teed.onConfigError(null);\n        teed.close();\n\n        verifyMethods(mockListener1);\n        Mockito.verifyNoMoreInteractions(mockListener1);\n    }\n\n    @NonNull\n    private PMDConfiguration newConfig() {\n        PMDConfiguration config = new PMDConfiguration();\n        config.setAnalysisCache(new NoopAnalysisCache());\n        config.setIgnoreIncrementalAnalysis(true);\n        config.setThreads(1);\n        return config;\n    }\n\n    private void runPmd(PMDConfiguration config, GlobalAnalysisListener listener, Rule rule) {\n        try (PmdAnalysis pmd = PmdAnalysis.create(config)) {\n            pmd.addRuleSet(RuleSet.forSingleRule(rule));\n            pmd.files().addSourceFile(\"abc\", \"fname1.dummy\");\n            pmd.files().addSourceFile(\"abcd\", \"fname2.dummy\");\n            pmd.files().addSourceFile(\"abcd\", \"fname21.dummy\");\n            pmd.addListener(listener);\n            pmd.performAnalysis();\n        }\n    }\n\n\n    public static class MyFooRule extends FooRule {\n\n        @Override\n        public void apply(Node node, RuleContext ctx) {\n            if (node.getTextDocument().getDisplayName().contains(\"1\")) {\n                ctx.addViolation(node);\n            }\n        }\n    }\n\n    public static class BrokenRule extends FooRule {\n\n        @Override\n        public void apply(Node node, RuleContext ctx) {\n            throw new IllegalArgumentException(\"Something happened\");\n        }\n    }\n\n    @Test\n    void teeShouldForwardAllEventsMultipleListeners() throws Exception {\n        GlobalAnalysisListener mockListener1 = createMockListener();\n        GlobalAnalysisListener mockListener2 = createMockListener();\n        GlobalAnalysisListener teed = GlobalAnalysisListener.tee(Arrays.asList(mockListener1, mockListener2));\n\n        teed.initializer();\n        teed.startFileAnalysis(null);\n        teed.onConfigError(null);\n        teed.close();\n\n        verifyMethods(mockListener1);\n        verifyMethods(mockListener2);\n        Mockito.verifyNoMoreInteractions(mockListener1, mockListener2);\n    }\n\n    private GlobalAnalysisListener createMockListener() {\n        GlobalAnalysisListener mockListener = Mockito.mock(GlobalAnalysisListener.class);\n        Mockito.when(mockListener.initializer()).thenReturn(ListenerInitializer.noop());\n        Mockito.when(mockListener.startFileAnalysis(Mockito.any())).thenReturn(FileAnalysisListener.noop());\n        return mockListener;\n    }\n\n    private void verifyMethods(GlobalAnalysisListener listener) throws Exception {\n        Mockito.verify(listener, Mockito.times(1)).initializer();\n        Mockito.verify(listener, Mockito.times(1)).startFileAnalysis(null);\n        Mockito.verify(listener, Mockito.times(1)).onConfigError(null);\n        Mockito.verify(listener, Mockito.times(1)).close();\n    }\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.processor.GlobalListenerTest#runPmd\n methodBody: private void runPmd(PMDConfiguration config, GlobalAnalysisListener listener, Rule rule) {\ntry(PmdAnalysis pmd=PmdAnalysis.create(config))pmd.addRuleSet(RuleSet.forSingleRule(rule));\npmd.files().addSourceFile(\"abc\",\"fname1.dummy\");\npmd.files().addSourceFile(\"abcd\",\"fname2.dummy\");\npmd.files().addSourceFile(\"abcd\",\"fname21.dummy\");\npmd.addListener(listener);\npmd.performAnalysis();\n}",
            "methodSignature: net.sourceforge.pmd.processor.GlobalListenerTest#newConfig\n methodBody: private PMDConfiguration newConfig() {\nPMDConfiguration config=new PMDConfiguration();\nconfig.setAnalysisCache(new NoopAnalysisCache());\nconfig.setIgnoreIncrementalAnalysis(true);\nconfig.setThreads(1);\nreturn config;\n}"
        ],
        "sourceCodeAfterRefactoring": "@Test\n    void testAnalysisCache() throws Exception {\n\n        PMDConfiguration config = newConfig();\n        AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n        config.setAnalysisCache(mockCache);\n\n        MyFooRule rule = new MyFooRule();\n        runPmd(config, GlobalAnalysisListener.noop(), rule);\n\n        verify(mockCache).checkValidity(any(), any());\n        verify(mockCache, times(1)).persist();\n        verify(mockCache, times(NUM_DATA_SOURCES)).isUpToDate(any());\n    }",
        "diffSourceCode": "    69:     @Test\n    70:     void testAnalysisCache() throws Exception {\n    71: \n    72:         PMDConfiguration config = newConfig();\n    73:         AnalysisCache mockCache = spy(NoopAnalysisCache.class);\n    74:         config.setAnalysisCache(mockCache);\n    75: \n    76:         MyFooRule rule = new MyFooRule();\n    77:         runPmd(config, GlobalAnalysisListener.noop(), rule);\n    78: \n    79:         verify(mockCache).checkValidity(any(), any());\n    80:         verify(mockCache, times(1)).persist();\n    81:         verify(mockCache, times(NUM_DATA_SOURCES)).isUpToDate(any());\n    82:     }\n",
        "uniqueId": "e2866bebf86e86892860dd0e3a01492797fd8ea6_69_82__69_82",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate parseAndTypeResolveForClass15(clazz Class<?>) : ASTCompilationUnit extracted from public testUnaryNumericOperators() : void in class net.sourceforge.pmd.typeresolution.ClassTypeResolverTest",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/test/java/net/sourceforge/pmd/typeresolution/ClassTypeResolverTest.java",
                "startLine": 431,
                "endLine": 451,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/test/java/net/sourceforge/pmd/typeresolution/ClassTypeResolverTest.java",
                "startLine": 431,
                "endLine": 451,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/test/java/net/sourceforge/pmd/typeresolution/ClassTypeResolverTest.java",
                "startLine": 501,
                "endLine": 503,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n    @SuppressWarnings(\"unchecked\")\n    public void testUnaryNumericOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(Operators.class);\n        List<TypeNode> expressions = new ArrayList<TypeNode>();\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//Expression\"));\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//PostfixExpression\"));\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//PreIncrementExpression\"));\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//PreDecrementExpression\"));\n        int index = 0;\n\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }",
        "filePathBefore": "pmd-java/src/test/java/net/sourceforge/pmd/typeresolution/ClassTypeResolverTest.java",
        "isPureRefactoring": true,
        "commitId": "18f393da3c8dc4aa426b27307baf55c3f700e6f1",
        "packageNameBefore": "net.sourceforge.pmd.typeresolution",
        "classNameBefore": "net.sourceforge.pmd.typeresolution.ClassTypeResolverTest",
        "methodNameBefore": "net.sourceforge.pmd.typeresolution.ClassTypeResolverTest#testUnaryNumericOperators",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.typeresolution.ClassTypeResolverTest#parseAndTypeResolveForClass\n methodBody: private ASTCompilationUnit parseAndTypeResolveForClass(Class<?> clazz) {\nString sourceFile=clazz.getName().replace('.','/') + \".java\";\nInputStream is=ClassTypeResolverTest.class.getClassLoader().getResourceAsStream(sourceFile);\nif(is == null){throw new IllegalArgumentException(\"Unable to find source file \" + sourceFile + \" for \" + clazz);\n}LanguageVersionHandler languageVersionHandler=LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion(\"1.5\").getLanguageVersionHandler();\nASTCompilationUnit acu=(ASTCompilationUnit)languageVersionHandler.getParser(languageVersionHandler.getDefaultParserOptions()).parse(null,new InputStreamReader(is));\nlanguageVersionHandler.getSymbolFacade().start(acu);\nlanguageVersionHandler.getTypeResolutionFacade(ClassTypeResolverTest.class.getClassLoader()).start(acu);\nreturn acu;\n}",
        "classSignatureBefore": "public class ClassTypeResolverTest ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.typeresolution.ClassTypeResolverTest#testUnaryNumericOperators"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.typeresolution.ClassTypeResolverTest"
        ],
        "classSignatureBeforeSet": [
            "public class ClassTypeResolverTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics\nOverlapped refactoring - can be identical by undoing the overlapped refactoring\n- Add Parameter-",
                "description": "Parametrization or Add Parameter on top of the extract method (relax mode) - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\npackage net.sourceforge.pmd.typeresolution;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNull;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.jaxen.JaxenException;\nimport org.junit.Test;\nimport net.sourceforge.pmd.lang.LanguageRegistry;\nimport net.sourceforge.pmd.lang.LanguageVersionHandler;\nimport net.sourceforge.pmd.lang.java.JavaLanguageModule;\nimport net.sourceforge.pmd.lang.java.ast.ASTAllocationExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTBooleanLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType;\nimport net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;\nimport net.sourceforge.pmd.lang.java.ast.ASTExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;\nimport net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTName;\nimport net.sourceforge.pmd.lang.java.ast.ASTNullLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTReferenceType;\nimport net.sourceforge.pmd.lang.java.ast.ASTStatementExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTType;\nimport net.sourceforge.pmd.lang.java.ast.ASTTypeDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableDeclarator;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;\nimport net.sourceforge.pmd.lang.java.ast.TypeNode;\nimport net.sourceforge.pmd.lang.java.typeresolution.ClassTypeResolver;\nimport net.sourceforge.pmd.typeresolution.testdata.AnonymousInnerClass;\nimport net.sourceforge.pmd.typeresolution.testdata.ArrayListFound;\nimport net.sourceforge.pmd.typeresolution.testdata.DefaultJavaLangImport;\nimport net.sourceforge.pmd.typeresolution.testdata.EnumWithAnonymousInnerClass;\nimport net.sourceforge.pmd.typeresolution.testdata.ExtraTopLevelClass;\nimport net.sourceforge.pmd.typeresolution.testdata.InnerClass;\nimport net.sourceforge.pmd.typeresolution.testdata.Literals;\nimport net.sourceforge.pmd.typeresolution.testdata.Operators;\nimport net.sourceforge.pmd.typeresolution.testdata.Promotion;\n\n\npublic class ClassTypeResolverTest {\n\n    @Test\n    public void testClassNameExists() {\n        ClassTypeResolver classTypeResolver = new ClassTypeResolver();\n        assertEquals(true, classTypeResolver.classNameExists(\"java.lang.System\"));\n        assertEquals(false, classTypeResolver.classNameExists(\"im.sure.that.this.does.not.Exist\"));\n        assertEquals(true, classTypeResolver.classNameExists(\"java.awt.List\"));\n    }\n\n    @Test\n    public void acceptanceTest() {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(ArrayListFound.class);\n        assertEquals(ArrayListFound.class, acu.getFirstDescendantOfType(ASTTypeDeclaration.class).getType());\n        assertEquals(ArrayListFound.class, acu.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());\n        ASTImportDeclaration id = acu.getFirstDescendantOfType(ASTImportDeclaration.class);\n        assertEquals(\"java.util\", id.getPackage().getName());\n        assertEquals(ArrayList.class, id.getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTClassOrInterfaceType.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTReferenceType.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTType.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTVariableDeclaratorId.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTVariableDeclarator.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTFieldDeclaration.class).getType());\n\n        acu = parseAndTypeResolveForClass(DefaultJavaLangImport.class);\n        assertEquals(String.class, acu.getFirstDescendantOfType(ASTClassOrInterfaceType.class).getType());\n        assertEquals(Override.class, acu.findDescendantsOfType(ASTName.class).get(1).getType());\n    }\n\n    /**\n     * See bug #1138 Anonymous inner class in enum causes NPE\n     */\n    @Test\n    public void testEnumAnonymousInnerClass() {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(EnumWithAnonymousInnerClass.class);\n        Class<?> inner = acu.getFirstDescendantOfType(ASTAllocationExpression.class)\n                .getFirstDescendantOfType(ASTClassOrInterfaceType.class).getType();\n        assertEquals(\"net.sourceforge.pmd.typeresolution.testdata.EnumWithAnonymousInnerClass$1\",\n                inner.getName());\n    }\n\n    @Test\n    public void testExtraTopLevelClass() throws ClassNotFoundException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(ExtraTopLevelClass.class);\n        Class<?> theExtraTopLevelClass = Class.forName(\"net.sourceforge.pmd.typeresolution.testdata.TheExtraTopLevelClass\");\n        // First class\n        ASTTypeDeclaration typeDeclaration = (ASTTypeDeclaration) acu.jjtGetChild(1);\n        assertEquals(ExtraTopLevelClass.class, typeDeclaration.getType());\n        assertEquals(ExtraTopLevelClass.class,\n                typeDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());\n        // Second class\n        typeDeclaration = (ASTTypeDeclaration) acu.jjtGetChild(2);\n        assertEquals(theExtraTopLevelClass, typeDeclaration.getType());\n        assertEquals(theExtraTopLevelClass,\n                typeDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());\n    }\n\n    @Test\n    public void testInnerClass() throws ClassNotFoundException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(InnerClass.class);\n        Class<?> theInnerClass = Class.forName(\"net.sourceforge.pmd.typeresolution.testdata.InnerClass$TheInnerClass\");\n        // Outer class\n        ASTTypeDeclaration typeDeclaration = acu.getFirstDescendantOfType(ASTTypeDeclaration.class);\n        assertEquals(InnerClass.class, typeDeclaration.getType());\n        ASTClassOrInterfaceDeclaration outerClassDeclaration = typeDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class);\n        assertEquals(InnerClass.class, outerClassDeclaration.getType());\n        // Inner class\n        assertEquals(theInnerClass,\n                outerClassDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());\n        // Method parameter as inner class\n        ASTFormalParameter formalParameter = typeDeclaration.getFirstDescendantOfType(ASTFormalParameter.class);\n        assertEquals(theInnerClass, formalParameter.getTypeNode().getType());\n    }\n\n    @Test\n    public void testAnonymousInnerClass() throws ClassNotFoundException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(AnonymousInnerClass.class);\n        Class<?> theAnonymousInnerClass = Class.forName(\"net.sourceforge.pmd.typeresolution.testdata.AnonymousInnerClass$1\");\n        // Outer class\n        ASTTypeDeclaration typeDeclaration = acu.getFirstDescendantOfType(ASTTypeDeclaration.class);\n        assertEquals(AnonymousInnerClass.class, typeDeclaration.getType());\n        ASTClassOrInterfaceDeclaration outerClassDeclaration = typeDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class);\n        assertEquals(AnonymousInnerClass.class, outerClassDeclaration.getType());\n        // Anonymous Inner class\n        assertEquals(theAnonymousInnerClass,\n                outerClassDeclaration.getFirstDescendantOfType(ASTAllocationExpression.class).getType());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testLiterals() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(Literals.class);\n        List<ASTLiteral> literals = acu.findChildNodesWithXPath(\"//Literal\");\n        int index = 0;\n\n        // String s = \"s\";\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(String.class, literals.get(index++).getType());\n\n        // boolean boolean1 = false;\n        assertEquals(Boolean.TYPE, literals.get(index).getFirstDescendantOfType(ASTBooleanLiteral.class).getType());\n        assertEquals(Boolean.TYPE, literals.get(index++).getType());\n\n        // boolean boolean2 = true;\n        assertEquals(Boolean.TYPE, literals.get(index).getFirstDescendantOfType(ASTBooleanLiteral.class).getType());\n        assertEquals(Boolean.TYPE, literals.get(index++).getType());\n\n        // Object obj = null;\n        assertNull(literals.get(index).getFirstDescendantOfType(ASTNullLiteral.class).getType());\n        assertNull(literals.get(index++).getType());\n\n        // byte byte1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // byte byte2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // byte byte3 = -007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // short short1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // short short2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // short short3 = -007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // char char1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // char char2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // char char3 = 007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // char char4 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // int int1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // int int2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // int int3 = -007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // int int4 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // long long1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // long long2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // long long3 = -007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // long long4 = 0L;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Long.TYPE, literals.get(index++).getType());\n\n        // long long5 = 0x0Fl;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Long.TYPE, literals.get(index++).getType());\n\n        // long long6 = -007L;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Long.TYPE, literals.get(index++).getType());\n\n        // long long7 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // float float1 = 0.0f;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Float.TYPE, literals.get(index++).getType());\n\n        // float float2 = -10e+01f;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Float.TYPE, literals.get(index++).getType());\n\n        // float float3 = 0x08.08p3f;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Float.TYPE, literals.get(index++).getType());\n\n        // float float4 = 0xFF;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // float float5 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // double double1 = 0.0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Double.TYPE, literals.get(index++).getType());\n\n        // double double2 = -10e+01;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Double.TYPE, literals.get(index++).getType());\n\n        // double double3 = 0x08.08p3;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Double.TYPE, literals.get(index++).getType());\n\n        // double double4 = 0xFF;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // double double5 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All literals not tested\", index, literals.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testUnaryNumericPromotion() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(Promotion.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericPromotion']]//Expression[UnaryExpression]\");\n        int index = 0;\n\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBinaryNumericPromotion() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(Promotion.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'binaryNumericPromotion']]//Expression[AdditiveExpression]\");\n        int index = 0;\n\n        // LHS = byte\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = short\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = char\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = int\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = long\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = float\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = double\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBinaryStringPromotion() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(Promotion.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'binaryStringPromotion']]//Expression\");\n        int index = 0;\n\n        assertEquals(String.class, expressions.get(index++).getType());\n        assertEquals(String.class, expressions.get(index++).getType());\n        assertEquals(String.class, expressions.get(index++).getType());\n        assertEquals(String.class, expressions.get(index++).getType());\n        assertEquals(String.class, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testUnaryLogicalOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(Operators.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryLogicalOperators']]//Expression\");\n        int index = 0;\n\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBinaryLogicalOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(Operators.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'binaryLogicalOperators']]//Expression\");\n        int index = 0;\n\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testUnaryNumericOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(Operators.class);\n        List<TypeNode> expressions = new ArrayList<TypeNode>();\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//Expression\"));\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//PostfixExpression\"));\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//PreIncrementExpression\"));\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//PreDecrementExpression\"));\n        int index = 0;\n\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBinaryNumericOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(Operators.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'binaryNumericOperators']]//Expression\");\n        int index = 0;\n\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testAssignmentOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(Operators.class);\n        List<ASTStatementExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'assignmentOperators']]//StatementExpression\");\n        int index = 0;\n\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    public static junit.framework.Test suite() {\n        return new junit.framework.JUnit4TestAdapter(ClassTypeResolverTest.class);\n    }\n\n    // Note: If you're using Eclipse or some other IDE to run this test, you _must_ have the regress folder in\n    // the classpath.  Normally the IDE doesn't put source directories themselves directly in the classpath, only\n    // the output directories are in the classpath.\n    private ASTCompilationUnit parseAndTypeResolveForClass(Class<?> clazz) {\n        String sourceFile = clazz.getName().replace('.', '/') + \".java\";\n        InputStream is = ClassTypeResolverTest.class.getClassLoader().getResourceAsStream(sourceFile);\n        if (is == null) {\n            throw new IllegalArgumentException(\"Unable to find source file \" + sourceFile + \" for \" + clazz);\n        }\n        LanguageVersionHandler languageVersionHandler = LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion(\"1.5\").getLanguageVersionHandler();\n        ASTCompilationUnit acu = (ASTCompilationUnit) languageVersionHandler.getParser(languageVersionHandler.getDefaultParserOptions()).parse(null, new InputStreamReader(is));\n        languageVersionHandler.getSymbolFacade().start(acu);\n        languageVersionHandler.getTypeResolutionFacade(ClassTypeResolverTest.class.getClassLoader()).start(acu);\n        return acu;\n    }\n}\n",
        "filePathAfter": "pmd-java/src/test/java/net/sourceforge/pmd/typeresolution/ClassTypeResolverTest.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\npackage net.sourceforge.pmd.typeresolution;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNull;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.jaxen.JaxenException;\nimport org.junit.Test;\nimport net.sourceforge.pmd.lang.LanguageRegistry;\nimport net.sourceforge.pmd.lang.LanguageVersionHandler;\nimport net.sourceforge.pmd.lang.java.JavaLanguageModule;\nimport net.sourceforge.pmd.lang.java.ast.ASTAllocationExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTBooleanLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType;\nimport net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;\nimport net.sourceforge.pmd.lang.java.ast.ASTExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;\nimport net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTName;\nimport net.sourceforge.pmd.lang.java.ast.ASTNullLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTReferenceType;\nimport net.sourceforge.pmd.lang.java.ast.ASTStatementExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTType;\nimport net.sourceforge.pmd.lang.java.ast.ASTTypeDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableDeclarator;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;\nimport net.sourceforge.pmd.lang.java.ast.TypeNode;\nimport net.sourceforge.pmd.lang.java.typeresolution.ClassTypeResolver;\nimport net.sourceforge.pmd.typeresolution.testdata.AnonymousInnerClass;\nimport net.sourceforge.pmd.typeresolution.testdata.ArrayListFound;\nimport net.sourceforge.pmd.typeresolution.testdata.DefaultJavaLangImport;\nimport net.sourceforge.pmd.typeresolution.testdata.EnumWithAnonymousInnerClass;\nimport net.sourceforge.pmd.typeresolution.testdata.ExtraTopLevelClass;\nimport net.sourceforge.pmd.typeresolution.testdata.InnerClass;\nimport net.sourceforge.pmd.typeresolution.testdata.Literals;\nimport net.sourceforge.pmd.typeresolution.testdata.Operators;\nimport net.sourceforge.pmd.typeresolution.testdata.Promotion;\n\n\npublic class ClassTypeResolverTest {\n\n    @Test\n    public void testClassNameExists() {\n        ClassTypeResolver classTypeResolver = new ClassTypeResolver();\n        assertEquals(true, classTypeResolver.classNameExists(\"java.lang.System\"));\n        assertEquals(false, classTypeResolver.classNameExists(\"im.sure.that.this.does.not.Exist\"));\n        assertEquals(true, classTypeResolver.classNameExists(\"java.awt.List\"));\n    }\n\n    @Test\n    public void acceptanceTest() {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(ArrayListFound.class);\n        assertEquals(ArrayListFound.class, acu.getFirstDescendantOfType(ASTTypeDeclaration.class).getType());\n        assertEquals(ArrayListFound.class, acu.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());\n        ASTImportDeclaration id = acu.getFirstDescendantOfType(ASTImportDeclaration.class);\n        assertEquals(\"java.util\", id.getPackage().getName());\n        assertEquals(ArrayList.class, id.getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTClassOrInterfaceType.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTReferenceType.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTType.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTVariableDeclaratorId.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTVariableDeclarator.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTFieldDeclaration.class).getType());\n\n        acu = parseAndTypeResolveForClass15(DefaultJavaLangImport.class);\n        assertEquals(String.class, acu.getFirstDescendantOfType(ASTClassOrInterfaceType.class).getType());\n        assertEquals(Override.class, acu.findDescendantsOfType(ASTName.class).get(1).getType());\n    }\n\n    /**\n     * See bug #1138 Anonymous inner class in enum causes NPE\n     */\n    @Test\n    public void testEnumAnonymousInnerClass() {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(EnumWithAnonymousInnerClass.class);\n        Class<?> inner = acu.getFirstDescendantOfType(ASTAllocationExpression.class)\n                .getFirstDescendantOfType(ASTClassOrInterfaceType.class).getType();\n        assertEquals(\"net.sourceforge.pmd.typeresolution.testdata.EnumWithAnonymousInnerClass$1\",\n                inner.getName());\n    }\n\n    @Test\n    public void testExtraTopLevelClass() throws ClassNotFoundException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(ExtraTopLevelClass.class);\n        Class<?> theExtraTopLevelClass = Class.forName(\"net.sourceforge.pmd.typeresolution.testdata.TheExtraTopLevelClass\");\n        // First class\n        ASTTypeDeclaration typeDeclaration = (ASTTypeDeclaration) acu.jjtGetChild(1);\n        assertEquals(ExtraTopLevelClass.class, typeDeclaration.getType());\n        assertEquals(ExtraTopLevelClass.class,\n                typeDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());\n        // Second class\n        typeDeclaration = (ASTTypeDeclaration) acu.jjtGetChild(2);\n        assertEquals(theExtraTopLevelClass, typeDeclaration.getType());\n        assertEquals(theExtraTopLevelClass,\n                typeDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());\n    }\n\n    @Test\n    public void testInnerClass() throws ClassNotFoundException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(InnerClass.class);\n        Class<?> theInnerClass = Class.forName(\"net.sourceforge.pmd.typeresolution.testdata.InnerClass$TheInnerClass\");\n        // Outer class\n        ASTTypeDeclaration typeDeclaration = acu.getFirstDescendantOfType(ASTTypeDeclaration.class);\n        assertEquals(InnerClass.class, typeDeclaration.getType());\n        ASTClassOrInterfaceDeclaration outerClassDeclaration = typeDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class);\n        assertEquals(InnerClass.class, outerClassDeclaration.getType());\n        // Inner class\n        assertEquals(theInnerClass,\n                outerClassDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());\n        // Method parameter as inner class\n        ASTFormalParameter formalParameter = typeDeclaration.getFirstDescendantOfType(ASTFormalParameter.class);\n        assertEquals(theInnerClass, formalParameter.getTypeNode().getType());\n    }\n\n    @Test\n    public void testAnonymousInnerClass() throws ClassNotFoundException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(AnonymousInnerClass.class);\n        Class<?> theAnonymousInnerClass = Class.forName(\"net.sourceforge.pmd.typeresolution.testdata.AnonymousInnerClass$1\");\n        // Outer class\n        ASTTypeDeclaration typeDeclaration = acu.getFirstDescendantOfType(ASTTypeDeclaration.class);\n        assertEquals(AnonymousInnerClass.class, typeDeclaration.getType());\n        ASTClassOrInterfaceDeclaration outerClassDeclaration = typeDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class);\n        assertEquals(AnonymousInnerClass.class, outerClassDeclaration.getType());\n        // Anonymous Inner class\n        assertEquals(theAnonymousInnerClass,\n                outerClassDeclaration.getFirstDescendantOfType(ASTAllocationExpression.class).getType());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testLiterals() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Literals.class);\n        List<ASTLiteral> literals = acu.findChildNodesWithXPath(\"//Literal\");\n        int index = 0;\n\n        // String s = \"s\";\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(String.class, literals.get(index++).getType());\n\n        // boolean boolean1 = false;\n        assertEquals(Boolean.TYPE, literals.get(index).getFirstDescendantOfType(ASTBooleanLiteral.class).getType());\n        assertEquals(Boolean.TYPE, literals.get(index++).getType());\n\n        // boolean boolean2 = true;\n        assertEquals(Boolean.TYPE, literals.get(index).getFirstDescendantOfType(ASTBooleanLiteral.class).getType());\n        assertEquals(Boolean.TYPE, literals.get(index++).getType());\n\n        // Object obj = null;\n        assertNull(literals.get(index).getFirstDescendantOfType(ASTNullLiteral.class).getType());\n        assertNull(literals.get(index++).getType());\n\n        // byte byte1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // byte byte2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // byte byte3 = -007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // short short1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // short short2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // short short3 = -007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // char char1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // char char2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // char char3 = 007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // char char4 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // int int1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // int int2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // int int3 = -007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // int int4 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // long long1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // long long2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // long long3 = -007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // long long4 = 0L;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Long.TYPE, literals.get(index++).getType());\n\n        // long long5 = 0x0Fl;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Long.TYPE, literals.get(index++).getType());\n\n        // long long6 = -007L;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Long.TYPE, literals.get(index++).getType());\n\n        // long long7 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // float float1 = 0.0f;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Float.TYPE, literals.get(index++).getType());\n\n        // float float2 = -10e+01f;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Float.TYPE, literals.get(index++).getType());\n\n        // float float3 = 0x08.08p3f;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Float.TYPE, literals.get(index++).getType());\n\n        // float float4 = 0xFF;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // float float5 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // double double1 = 0.0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Double.TYPE, literals.get(index++).getType());\n\n        // double double2 = -10e+01;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Double.TYPE, literals.get(index++).getType());\n\n        // double double3 = 0x08.08p3;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Double.TYPE, literals.get(index++).getType());\n\n        // double double4 = 0xFF;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // double double5 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All literals not tested\", index, literals.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testUnaryNumericPromotion() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Promotion.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericPromotion']]//Expression[UnaryExpression]\");\n        int index = 0;\n\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBinaryNumericPromotion() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Promotion.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'binaryNumericPromotion']]//Expression[AdditiveExpression]\");\n        int index = 0;\n\n        // LHS = byte\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = short\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = char\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = int\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = long\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = float\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = double\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBinaryStringPromotion() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Promotion.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'binaryStringPromotion']]//Expression\");\n        int index = 0;\n\n        assertEquals(String.class, expressions.get(index++).getType());\n        assertEquals(String.class, expressions.get(index++).getType());\n        assertEquals(String.class, expressions.get(index++).getType());\n        assertEquals(String.class, expressions.get(index++).getType());\n        assertEquals(String.class, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testUnaryLogicalOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Operators.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryLogicalOperators']]//Expression\");\n        int index = 0;\n\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBinaryLogicalOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Operators.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'binaryLogicalOperators']]//Expression\");\n        int index = 0;\n\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testUnaryNumericOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Operators.class);\n        List<TypeNode> expressions = new ArrayList<TypeNode>();\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//Expression\"));\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//PostfixExpression\"));\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//PreIncrementExpression\"));\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//PreDecrementExpression\"));\n        int index = 0;\n\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBinaryNumericOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Operators.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'binaryNumericOperators']]//Expression\");\n        int index = 0;\n\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testAssignmentOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Operators.class);\n        List<ASTStatementExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'assignmentOperators']]//StatementExpression\");\n        int index = 0;\n\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    public static junit.framework.Test suite() {\n        return new junit.framework.JUnit4TestAdapter(ClassTypeResolverTest.class);\n    }\n\n    private ASTCompilationUnit parseAndTypeResolveForClass15(Class<?> clazz) {\n        return parseAndTypeResolveForClass(clazz, \"1.5\");\n    }\n\n    // Note: If you're using Eclipse or some other IDE to run this test, you _must_ have the regress folder in\n    // the classpath.  Normally the IDE doesn't put source directories themselves directly in the classpath, only\n    // the output directories are in the classpath.\n    private ASTCompilationUnit parseAndTypeResolveForClass(Class<?> clazz, String version) {\n        String sourceFile = clazz.getName().replace('.', '/') + \".java\";\n        InputStream is = ClassTypeResolverTest.class.getClassLoader().getResourceAsStream(sourceFile);\n        if (is == null) {\n            throw new IllegalArgumentException(\"Unable to find source file \" + sourceFile + \" for \" + clazz);\n        }\n        LanguageVersionHandler languageVersionHandler = LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion(version).getLanguageVersionHandler();\n        ASTCompilationUnit acu = (ASTCompilationUnit) languageVersionHandler.getParser(languageVersionHandler.getDefaultParserOptions()).parse(null, new InputStreamReader(is));\n        languageVersionHandler.getSymbolFacade().start(acu);\n        languageVersionHandler.getTypeResolutionFacade(ClassTypeResolverTest.class.getClassLoader()).start(acu);\n        return acu;\n    }\n}\n",
        "diffSourceCodeSet": [
            "private ASTCompilationUnit parseAndTypeResolveForClass15(Class<?> clazz) {\n        return parseAndTypeResolveForClass(clazz, \"1.5\");\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.typeresolution.ClassTypeResolverTest#parseAndTypeResolveForClass\n methodBody: private ASTCompilationUnit parseAndTypeResolveForClass(Class<?> clazz) {\nString sourceFile=clazz.getName().replace('.','/') + \".java\";\nInputStream is=ClassTypeResolverTest.class.getClassLoader().getResourceAsStream(sourceFile);\nif(is == null){throw new IllegalArgumentException(\"Unable to find source file \" + sourceFile + \" for \" + clazz);\n}LanguageVersionHandler languageVersionHandler=LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion(\"1.5\").getLanguageVersionHandler();\nASTCompilationUnit acu=(ASTCompilationUnit)languageVersionHandler.getParser(languageVersionHandler.getDefaultParserOptions()).parse(null,new InputStreamReader(is));\nlanguageVersionHandler.getSymbolFacade().start(acu);\nlanguageVersionHandler.getTypeResolutionFacade(ClassTypeResolverTest.class.getClassLoader()).start(acu);\nreturn acu;\n}"
        ],
        "sourceCodeAfterRefactoring": "@Test\n    @SuppressWarnings(\"unchecked\")\n    public void testUnaryNumericOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Operators.class);\n        List<TypeNode> expressions = new ArrayList<TypeNode>();\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//Expression\"));\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//PostfixExpression\"));\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//PreIncrementExpression\"));\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//PreDecrementExpression\"));\n        int index = 0;\n\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\nprivate ASTCompilationUnit parseAndTypeResolveForClass15(Class<?> clazz) {\n        return parseAndTypeResolveForClass(clazz, \"1.5\");\n    }",
        "diffSourceCode": "   431:     @Test\n   432:     @SuppressWarnings(\"unchecked\")\n   433:     public void testUnaryNumericOperators() throws JaxenException {\n-  434:         ASTCompilationUnit acu = parseAndTypeResolveForClass(Operators.class);\n+  434:         ASTCompilationUnit acu = parseAndTypeResolveForClass15(Operators.class);\n   435:         List<TypeNode> expressions = new ArrayList<TypeNode>();\n   436:         expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//Expression\"));\n   437:         expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//PostfixExpression\"));\n   438:         expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//PreIncrementExpression\"));\n   439:         expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//PreDecrementExpression\"));\n   440:         int index = 0;\n   441: \n   442:         assertEquals(Integer.TYPE, expressions.get(index++).getType());\n   443:         assertEquals(Integer.TYPE, expressions.get(index++).getType());\n   444:         assertEquals(Double.TYPE, expressions.get(index++).getType());\n   445:         assertEquals(Double.TYPE, expressions.get(index++).getType());\n   446:         assertEquals(Double.TYPE, expressions.get(index++).getType());\n   447:         assertEquals(Double.TYPE, expressions.get(index++).getType());\n   448: \n   449:         // Make sure we got them all.\n   450:         assertEquals(\"All expressions not tested\", index, expressions.size());\n   451:     }\n-  501:     // Note: If you're using Eclipse or some other IDE to run this test, you _must_ have the regress folder in\n-  502:     // the classpath.  Normally the IDE doesn't put source directories themselves directly in the classpath, only\n-  503:     // the output directories are in the classpath.\n+  501:     private ASTCompilationUnit parseAndTypeResolveForClass15(Class<?> clazz) {\n+  502:         return parseAndTypeResolveForClass(clazz, \"1.5\");\n+  503:     }\n",
        "uniqueId": "18f393da3c8dc4aa426b27307baf55c3f700e6f1_431_451_501_503_431_451",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 1.8,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate parseAndTypeResolveForClass15(clazz Class<?>) : ASTCompilationUnit extracted from public testUnaryLogicalOperators() : void in class net.sourceforge.pmd.typeresolution.ClassTypeResolverTest",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/test/java/net/sourceforge/pmd/typeresolution/ClassTypeResolverTest.java",
                "startLine": 392,
                "endLine": 404,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/test/java/net/sourceforge/pmd/typeresolution/ClassTypeResolverTest.java",
                "startLine": 392,
                "endLine": 404,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/test/java/net/sourceforge/pmd/typeresolution/ClassTypeResolverTest.java",
                "startLine": 501,
                "endLine": 503,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n    @SuppressWarnings(\"unchecked\")\n    public void testUnaryLogicalOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(Operators.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryLogicalOperators']]//Expression\");\n        int index = 0;\n\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }",
        "filePathBefore": "pmd-java/src/test/java/net/sourceforge/pmd/typeresolution/ClassTypeResolverTest.java",
        "isPureRefactoring": true,
        "commitId": "18f393da3c8dc4aa426b27307baf55c3f700e6f1",
        "packageNameBefore": "net.sourceforge.pmd.typeresolution",
        "classNameBefore": "net.sourceforge.pmd.typeresolution.ClassTypeResolverTest",
        "methodNameBefore": "net.sourceforge.pmd.typeresolution.ClassTypeResolverTest#testUnaryLogicalOperators",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.typeresolution.ClassTypeResolverTest#parseAndTypeResolveForClass\n methodBody: private ASTCompilationUnit parseAndTypeResolveForClass(Class<?> clazz) {\nString sourceFile=clazz.getName().replace('.','/') + \".java\";\nInputStream is=ClassTypeResolverTest.class.getClassLoader().getResourceAsStream(sourceFile);\nif(is == null){throw new IllegalArgumentException(\"Unable to find source file \" + sourceFile + \" for \" + clazz);\n}LanguageVersionHandler languageVersionHandler=LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion(\"1.5\").getLanguageVersionHandler();\nASTCompilationUnit acu=(ASTCompilationUnit)languageVersionHandler.getParser(languageVersionHandler.getDefaultParserOptions()).parse(null,new InputStreamReader(is));\nlanguageVersionHandler.getSymbolFacade().start(acu);\nlanguageVersionHandler.getTypeResolutionFacade(ClassTypeResolverTest.class.getClassLoader()).start(acu);\nreturn acu;\n}",
        "classSignatureBefore": "public class ClassTypeResolverTest ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.typeresolution.ClassTypeResolverTest#testUnaryLogicalOperators"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.typeresolution.ClassTypeResolverTest"
        ],
        "classSignatureBeforeSet": [
            "public class ClassTypeResolverTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics\nOverlapped refactoring - can be identical by undoing the overlapped refactoring\n- Add Parameter-",
                "description": "Parametrization or Add Parameter on top of the extract method (relax mode) - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\npackage net.sourceforge.pmd.typeresolution;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNull;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.jaxen.JaxenException;\nimport org.junit.Test;\nimport net.sourceforge.pmd.lang.LanguageRegistry;\nimport net.sourceforge.pmd.lang.LanguageVersionHandler;\nimport net.sourceforge.pmd.lang.java.JavaLanguageModule;\nimport net.sourceforge.pmd.lang.java.ast.ASTAllocationExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTBooleanLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType;\nimport net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;\nimport net.sourceforge.pmd.lang.java.ast.ASTExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;\nimport net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTName;\nimport net.sourceforge.pmd.lang.java.ast.ASTNullLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTReferenceType;\nimport net.sourceforge.pmd.lang.java.ast.ASTStatementExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTType;\nimport net.sourceforge.pmd.lang.java.ast.ASTTypeDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableDeclarator;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;\nimport net.sourceforge.pmd.lang.java.ast.TypeNode;\nimport net.sourceforge.pmd.lang.java.typeresolution.ClassTypeResolver;\nimport net.sourceforge.pmd.typeresolution.testdata.AnonymousInnerClass;\nimport net.sourceforge.pmd.typeresolution.testdata.ArrayListFound;\nimport net.sourceforge.pmd.typeresolution.testdata.DefaultJavaLangImport;\nimport net.sourceforge.pmd.typeresolution.testdata.EnumWithAnonymousInnerClass;\nimport net.sourceforge.pmd.typeresolution.testdata.ExtraTopLevelClass;\nimport net.sourceforge.pmd.typeresolution.testdata.InnerClass;\nimport net.sourceforge.pmd.typeresolution.testdata.Literals;\nimport net.sourceforge.pmd.typeresolution.testdata.Operators;\nimport net.sourceforge.pmd.typeresolution.testdata.Promotion;\n\n\npublic class ClassTypeResolverTest {\n\n    @Test\n    public void testClassNameExists() {\n        ClassTypeResolver classTypeResolver = new ClassTypeResolver();\n        assertEquals(true, classTypeResolver.classNameExists(\"java.lang.System\"));\n        assertEquals(false, classTypeResolver.classNameExists(\"im.sure.that.this.does.not.Exist\"));\n        assertEquals(true, classTypeResolver.classNameExists(\"java.awt.List\"));\n    }\n\n    @Test\n    public void acceptanceTest() {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(ArrayListFound.class);\n        assertEquals(ArrayListFound.class, acu.getFirstDescendantOfType(ASTTypeDeclaration.class).getType());\n        assertEquals(ArrayListFound.class, acu.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());\n        ASTImportDeclaration id = acu.getFirstDescendantOfType(ASTImportDeclaration.class);\n        assertEquals(\"java.util\", id.getPackage().getName());\n        assertEquals(ArrayList.class, id.getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTClassOrInterfaceType.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTReferenceType.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTType.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTVariableDeclaratorId.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTVariableDeclarator.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTFieldDeclaration.class).getType());\n\n        acu = parseAndTypeResolveForClass(DefaultJavaLangImport.class);\n        assertEquals(String.class, acu.getFirstDescendantOfType(ASTClassOrInterfaceType.class).getType());\n        assertEquals(Override.class, acu.findDescendantsOfType(ASTName.class).get(1).getType());\n    }\n\n    /**\n     * See bug #1138 Anonymous inner class in enum causes NPE\n     */\n    @Test\n    public void testEnumAnonymousInnerClass() {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(EnumWithAnonymousInnerClass.class);\n        Class<?> inner = acu.getFirstDescendantOfType(ASTAllocationExpression.class)\n                .getFirstDescendantOfType(ASTClassOrInterfaceType.class).getType();\n        assertEquals(\"net.sourceforge.pmd.typeresolution.testdata.EnumWithAnonymousInnerClass$1\",\n                inner.getName());\n    }\n\n    @Test\n    public void testExtraTopLevelClass() throws ClassNotFoundException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(ExtraTopLevelClass.class);\n        Class<?> theExtraTopLevelClass = Class.forName(\"net.sourceforge.pmd.typeresolution.testdata.TheExtraTopLevelClass\");\n        // First class\n        ASTTypeDeclaration typeDeclaration = (ASTTypeDeclaration) acu.jjtGetChild(1);\n        assertEquals(ExtraTopLevelClass.class, typeDeclaration.getType());\n        assertEquals(ExtraTopLevelClass.class,\n                typeDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());\n        // Second class\n        typeDeclaration = (ASTTypeDeclaration) acu.jjtGetChild(2);\n        assertEquals(theExtraTopLevelClass, typeDeclaration.getType());\n        assertEquals(theExtraTopLevelClass,\n                typeDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());\n    }\n\n    @Test\n    public void testInnerClass() throws ClassNotFoundException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(InnerClass.class);\n        Class<?> theInnerClass = Class.forName(\"net.sourceforge.pmd.typeresolution.testdata.InnerClass$TheInnerClass\");\n        // Outer class\n        ASTTypeDeclaration typeDeclaration = acu.getFirstDescendantOfType(ASTTypeDeclaration.class);\n        assertEquals(InnerClass.class, typeDeclaration.getType());\n        ASTClassOrInterfaceDeclaration outerClassDeclaration = typeDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class);\n        assertEquals(InnerClass.class, outerClassDeclaration.getType());\n        // Inner class\n        assertEquals(theInnerClass,\n                outerClassDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());\n        // Method parameter as inner class\n        ASTFormalParameter formalParameter = typeDeclaration.getFirstDescendantOfType(ASTFormalParameter.class);\n        assertEquals(theInnerClass, formalParameter.getTypeNode().getType());\n    }\n\n    @Test\n    public void testAnonymousInnerClass() throws ClassNotFoundException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(AnonymousInnerClass.class);\n        Class<?> theAnonymousInnerClass = Class.forName(\"net.sourceforge.pmd.typeresolution.testdata.AnonymousInnerClass$1\");\n        // Outer class\n        ASTTypeDeclaration typeDeclaration = acu.getFirstDescendantOfType(ASTTypeDeclaration.class);\n        assertEquals(AnonymousInnerClass.class, typeDeclaration.getType());\n        ASTClassOrInterfaceDeclaration outerClassDeclaration = typeDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class);\n        assertEquals(AnonymousInnerClass.class, outerClassDeclaration.getType());\n        // Anonymous Inner class\n        assertEquals(theAnonymousInnerClass,\n                outerClassDeclaration.getFirstDescendantOfType(ASTAllocationExpression.class).getType());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testLiterals() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(Literals.class);\n        List<ASTLiteral> literals = acu.findChildNodesWithXPath(\"//Literal\");\n        int index = 0;\n\n        // String s = \"s\";\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(String.class, literals.get(index++).getType());\n\n        // boolean boolean1 = false;\n        assertEquals(Boolean.TYPE, literals.get(index).getFirstDescendantOfType(ASTBooleanLiteral.class).getType());\n        assertEquals(Boolean.TYPE, literals.get(index++).getType());\n\n        // boolean boolean2 = true;\n        assertEquals(Boolean.TYPE, literals.get(index).getFirstDescendantOfType(ASTBooleanLiteral.class).getType());\n        assertEquals(Boolean.TYPE, literals.get(index++).getType());\n\n        // Object obj = null;\n        assertNull(literals.get(index).getFirstDescendantOfType(ASTNullLiteral.class).getType());\n        assertNull(literals.get(index++).getType());\n\n        // byte byte1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // byte byte2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // byte byte3 = -007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // short short1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // short short2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // short short3 = -007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // char char1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // char char2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // char char3 = 007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // char char4 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // int int1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // int int2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // int int3 = -007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // int int4 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // long long1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // long long2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // long long3 = -007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // long long4 = 0L;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Long.TYPE, literals.get(index++).getType());\n\n        // long long5 = 0x0Fl;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Long.TYPE, literals.get(index++).getType());\n\n        // long long6 = -007L;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Long.TYPE, literals.get(index++).getType());\n\n        // long long7 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // float float1 = 0.0f;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Float.TYPE, literals.get(index++).getType());\n\n        // float float2 = -10e+01f;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Float.TYPE, literals.get(index++).getType());\n\n        // float float3 = 0x08.08p3f;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Float.TYPE, literals.get(index++).getType());\n\n        // float float4 = 0xFF;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // float float5 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // double double1 = 0.0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Double.TYPE, literals.get(index++).getType());\n\n        // double double2 = -10e+01;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Double.TYPE, literals.get(index++).getType());\n\n        // double double3 = 0x08.08p3;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Double.TYPE, literals.get(index++).getType());\n\n        // double double4 = 0xFF;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // double double5 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All literals not tested\", index, literals.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testUnaryNumericPromotion() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(Promotion.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericPromotion']]//Expression[UnaryExpression]\");\n        int index = 0;\n\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBinaryNumericPromotion() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(Promotion.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'binaryNumericPromotion']]//Expression[AdditiveExpression]\");\n        int index = 0;\n\n        // LHS = byte\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = short\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = char\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = int\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = long\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = float\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = double\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBinaryStringPromotion() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(Promotion.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'binaryStringPromotion']]//Expression\");\n        int index = 0;\n\n        assertEquals(String.class, expressions.get(index++).getType());\n        assertEquals(String.class, expressions.get(index++).getType());\n        assertEquals(String.class, expressions.get(index++).getType());\n        assertEquals(String.class, expressions.get(index++).getType());\n        assertEquals(String.class, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testUnaryLogicalOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(Operators.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryLogicalOperators']]//Expression\");\n        int index = 0;\n\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBinaryLogicalOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(Operators.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'binaryLogicalOperators']]//Expression\");\n        int index = 0;\n\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testUnaryNumericOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(Operators.class);\n        List<TypeNode> expressions = new ArrayList<TypeNode>();\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//Expression\"));\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//PostfixExpression\"));\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//PreIncrementExpression\"));\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//PreDecrementExpression\"));\n        int index = 0;\n\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBinaryNumericOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(Operators.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'binaryNumericOperators']]//Expression\");\n        int index = 0;\n\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testAssignmentOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(Operators.class);\n        List<ASTStatementExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'assignmentOperators']]//StatementExpression\");\n        int index = 0;\n\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    public static junit.framework.Test suite() {\n        return new junit.framework.JUnit4TestAdapter(ClassTypeResolverTest.class);\n    }\n\n    // Note: If you're using Eclipse or some other IDE to run this test, you _must_ have the regress folder in\n    // the classpath.  Normally the IDE doesn't put source directories themselves directly in the classpath, only\n    // the output directories are in the classpath.\n    private ASTCompilationUnit parseAndTypeResolveForClass(Class<?> clazz) {\n        String sourceFile = clazz.getName().replace('.', '/') + \".java\";\n        InputStream is = ClassTypeResolverTest.class.getClassLoader().getResourceAsStream(sourceFile);\n        if (is == null) {\n            throw new IllegalArgumentException(\"Unable to find source file \" + sourceFile + \" for \" + clazz);\n        }\n        LanguageVersionHandler languageVersionHandler = LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion(\"1.5\").getLanguageVersionHandler();\n        ASTCompilationUnit acu = (ASTCompilationUnit) languageVersionHandler.getParser(languageVersionHandler.getDefaultParserOptions()).parse(null, new InputStreamReader(is));\n        languageVersionHandler.getSymbolFacade().start(acu);\n        languageVersionHandler.getTypeResolutionFacade(ClassTypeResolverTest.class.getClassLoader()).start(acu);\n        return acu;\n    }\n}\n",
        "filePathAfter": "pmd-java/src/test/java/net/sourceforge/pmd/typeresolution/ClassTypeResolverTest.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\npackage net.sourceforge.pmd.typeresolution;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNull;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.jaxen.JaxenException;\nimport org.junit.Test;\nimport net.sourceforge.pmd.lang.LanguageRegistry;\nimport net.sourceforge.pmd.lang.LanguageVersionHandler;\nimport net.sourceforge.pmd.lang.java.JavaLanguageModule;\nimport net.sourceforge.pmd.lang.java.ast.ASTAllocationExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTBooleanLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType;\nimport net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;\nimport net.sourceforge.pmd.lang.java.ast.ASTExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;\nimport net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTName;\nimport net.sourceforge.pmd.lang.java.ast.ASTNullLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTReferenceType;\nimport net.sourceforge.pmd.lang.java.ast.ASTStatementExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTType;\nimport net.sourceforge.pmd.lang.java.ast.ASTTypeDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableDeclarator;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;\nimport net.sourceforge.pmd.lang.java.ast.TypeNode;\nimport net.sourceforge.pmd.lang.java.typeresolution.ClassTypeResolver;\nimport net.sourceforge.pmd.typeresolution.testdata.AnonymousInnerClass;\nimport net.sourceforge.pmd.typeresolution.testdata.ArrayListFound;\nimport net.sourceforge.pmd.typeresolution.testdata.DefaultJavaLangImport;\nimport net.sourceforge.pmd.typeresolution.testdata.EnumWithAnonymousInnerClass;\nimport net.sourceforge.pmd.typeresolution.testdata.ExtraTopLevelClass;\nimport net.sourceforge.pmd.typeresolution.testdata.InnerClass;\nimport net.sourceforge.pmd.typeresolution.testdata.Literals;\nimport net.sourceforge.pmd.typeresolution.testdata.Operators;\nimport net.sourceforge.pmd.typeresolution.testdata.Promotion;\n\n\npublic class ClassTypeResolverTest {\n\n    @Test\n    public void testClassNameExists() {\n        ClassTypeResolver classTypeResolver = new ClassTypeResolver();\n        assertEquals(true, classTypeResolver.classNameExists(\"java.lang.System\"));\n        assertEquals(false, classTypeResolver.classNameExists(\"im.sure.that.this.does.not.Exist\"));\n        assertEquals(true, classTypeResolver.classNameExists(\"java.awt.List\"));\n    }\n\n    @Test\n    public void acceptanceTest() {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(ArrayListFound.class);\n        assertEquals(ArrayListFound.class, acu.getFirstDescendantOfType(ASTTypeDeclaration.class).getType());\n        assertEquals(ArrayListFound.class, acu.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());\n        ASTImportDeclaration id = acu.getFirstDescendantOfType(ASTImportDeclaration.class);\n        assertEquals(\"java.util\", id.getPackage().getName());\n        assertEquals(ArrayList.class, id.getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTClassOrInterfaceType.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTReferenceType.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTType.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTVariableDeclaratorId.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTVariableDeclarator.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTFieldDeclaration.class).getType());\n\n        acu = parseAndTypeResolveForClass15(DefaultJavaLangImport.class);\n        assertEquals(String.class, acu.getFirstDescendantOfType(ASTClassOrInterfaceType.class).getType());\n        assertEquals(Override.class, acu.findDescendantsOfType(ASTName.class).get(1).getType());\n    }\n\n    /**\n     * See bug #1138 Anonymous inner class in enum causes NPE\n     */\n    @Test\n    public void testEnumAnonymousInnerClass() {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(EnumWithAnonymousInnerClass.class);\n        Class<?> inner = acu.getFirstDescendantOfType(ASTAllocationExpression.class)\n                .getFirstDescendantOfType(ASTClassOrInterfaceType.class).getType();\n        assertEquals(\"net.sourceforge.pmd.typeresolution.testdata.EnumWithAnonymousInnerClass$1\",\n                inner.getName());\n    }\n\n    @Test\n    public void testExtraTopLevelClass() throws ClassNotFoundException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(ExtraTopLevelClass.class);\n        Class<?> theExtraTopLevelClass = Class.forName(\"net.sourceforge.pmd.typeresolution.testdata.TheExtraTopLevelClass\");\n        // First class\n        ASTTypeDeclaration typeDeclaration = (ASTTypeDeclaration) acu.jjtGetChild(1);\n        assertEquals(ExtraTopLevelClass.class, typeDeclaration.getType());\n        assertEquals(ExtraTopLevelClass.class,\n                typeDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());\n        // Second class\n        typeDeclaration = (ASTTypeDeclaration) acu.jjtGetChild(2);\n        assertEquals(theExtraTopLevelClass, typeDeclaration.getType());\n        assertEquals(theExtraTopLevelClass,\n                typeDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());\n    }\n\n    @Test\n    public void testInnerClass() throws ClassNotFoundException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(InnerClass.class);\n        Class<?> theInnerClass = Class.forName(\"net.sourceforge.pmd.typeresolution.testdata.InnerClass$TheInnerClass\");\n        // Outer class\n        ASTTypeDeclaration typeDeclaration = acu.getFirstDescendantOfType(ASTTypeDeclaration.class);\n        assertEquals(InnerClass.class, typeDeclaration.getType());\n        ASTClassOrInterfaceDeclaration outerClassDeclaration = typeDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class);\n        assertEquals(InnerClass.class, outerClassDeclaration.getType());\n        // Inner class\n        assertEquals(theInnerClass,\n                outerClassDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());\n        // Method parameter as inner class\n        ASTFormalParameter formalParameter = typeDeclaration.getFirstDescendantOfType(ASTFormalParameter.class);\n        assertEquals(theInnerClass, formalParameter.getTypeNode().getType());\n    }\n\n    @Test\n    public void testAnonymousInnerClass() throws ClassNotFoundException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(AnonymousInnerClass.class);\n        Class<?> theAnonymousInnerClass = Class.forName(\"net.sourceforge.pmd.typeresolution.testdata.AnonymousInnerClass$1\");\n        // Outer class\n        ASTTypeDeclaration typeDeclaration = acu.getFirstDescendantOfType(ASTTypeDeclaration.class);\n        assertEquals(AnonymousInnerClass.class, typeDeclaration.getType());\n        ASTClassOrInterfaceDeclaration outerClassDeclaration = typeDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class);\n        assertEquals(AnonymousInnerClass.class, outerClassDeclaration.getType());\n        // Anonymous Inner class\n        assertEquals(theAnonymousInnerClass,\n                outerClassDeclaration.getFirstDescendantOfType(ASTAllocationExpression.class).getType());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testLiterals() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Literals.class);\n        List<ASTLiteral> literals = acu.findChildNodesWithXPath(\"//Literal\");\n        int index = 0;\n\n        // String s = \"s\";\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(String.class, literals.get(index++).getType());\n\n        // boolean boolean1 = false;\n        assertEquals(Boolean.TYPE, literals.get(index).getFirstDescendantOfType(ASTBooleanLiteral.class).getType());\n        assertEquals(Boolean.TYPE, literals.get(index++).getType());\n\n        // boolean boolean2 = true;\n        assertEquals(Boolean.TYPE, literals.get(index).getFirstDescendantOfType(ASTBooleanLiteral.class).getType());\n        assertEquals(Boolean.TYPE, literals.get(index++).getType());\n\n        // Object obj = null;\n        assertNull(literals.get(index).getFirstDescendantOfType(ASTNullLiteral.class).getType());\n        assertNull(literals.get(index++).getType());\n\n        // byte byte1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // byte byte2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // byte byte3 = -007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // short short1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // short short2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // short short3 = -007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // char char1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // char char2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // char char3 = 007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // char char4 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // int int1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // int int2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // int int3 = -007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // int int4 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // long long1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // long long2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // long long3 = -007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // long long4 = 0L;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Long.TYPE, literals.get(index++).getType());\n\n        // long long5 = 0x0Fl;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Long.TYPE, literals.get(index++).getType());\n\n        // long long6 = -007L;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Long.TYPE, literals.get(index++).getType());\n\n        // long long7 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // float float1 = 0.0f;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Float.TYPE, literals.get(index++).getType());\n\n        // float float2 = -10e+01f;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Float.TYPE, literals.get(index++).getType());\n\n        // float float3 = 0x08.08p3f;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Float.TYPE, literals.get(index++).getType());\n\n        // float float4 = 0xFF;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // float float5 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // double double1 = 0.0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Double.TYPE, literals.get(index++).getType());\n\n        // double double2 = -10e+01;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Double.TYPE, literals.get(index++).getType());\n\n        // double double3 = 0x08.08p3;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Double.TYPE, literals.get(index++).getType());\n\n        // double double4 = 0xFF;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // double double5 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All literals not tested\", index, literals.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testUnaryNumericPromotion() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Promotion.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericPromotion']]//Expression[UnaryExpression]\");\n        int index = 0;\n\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBinaryNumericPromotion() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Promotion.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'binaryNumericPromotion']]//Expression[AdditiveExpression]\");\n        int index = 0;\n\n        // LHS = byte\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = short\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = char\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = int\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = long\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = float\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = double\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBinaryStringPromotion() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Promotion.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'binaryStringPromotion']]//Expression\");\n        int index = 0;\n\n        assertEquals(String.class, expressions.get(index++).getType());\n        assertEquals(String.class, expressions.get(index++).getType());\n        assertEquals(String.class, expressions.get(index++).getType());\n        assertEquals(String.class, expressions.get(index++).getType());\n        assertEquals(String.class, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testUnaryLogicalOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Operators.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryLogicalOperators']]//Expression\");\n        int index = 0;\n\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBinaryLogicalOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Operators.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'binaryLogicalOperators']]//Expression\");\n        int index = 0;\n\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testUnaryNumericOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Operators.class);\n        List<TypeNode> expressions = new ArrayList<TypeNode>();\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//Expression\"));\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//PostfixExpression\"));\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//PreIncrementExpression\"));\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//PreDecrementExpression\"));\n        int index = 0;\n\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBinaryNumericOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Operators.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'binaryNumericOperators']]//Expression\");\n        int index = 0;\n\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testAssignmentOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Operators.class);\n        List<ASTStatementExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'assignmentOperators']]//StatementExpression\");\n        int index = 0;\n\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    public static junit.framework.Test suite() {\n        return new junit.framework.JUnit4TestAdapter(ClassTypeResolverTest.class);\n    }\n\n    private ASTCompilationUnit parseAndTypeResolveForClass15(Class<?> clazz) {\n        return parseAndTypeResolveForClass(clazz, \"1.5\");\n    }\n\n    // Note: If you're using Eclipse or some other IDE to run this test, you _must_ have the regress folder in\n    // the classpath.  Normally the IDE doesn't put source directories themselves directly in the classpath, only\n    // the output directories are in the classpath.\n    private ASTCompilationUnit parseAndTypeResolveForClass(Class<?> clazz, String version) {\n        String sourceFile = clazz.getName().replace('.', '/') + \".java\";\n        InputStream is = ClassTypeResolverTest.class.getClassLoader().getResourceAsStream(sourceFile);\n        if (is == null) {\n            throw new IllegalArgumentException(\"Unable to find source file \" + sourceFile + \" for \" + clazz);\n        }\n        LanguageVersionHandler languageVersionHandler = LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion(version).getLanguageVersionHandler();\n        ASTCompilationUnit acu = (ASTCompilationUnit) languageVersionHandler.getParser(languageVersionHandler.getDefaultParserOptions()).parse(null, new InputStreamReader(is));\n        languageVersionHandler.getSymbolFacade().start(acu);\n        languageVersionHandler.getTypeResolutionFacade(ClassTypeResolverTest.class.getClassLoader()).start(acu);\n        return acu;\n    }\n}\n",
        "diffSourceCodeSet": [
            "private ASTCompilationUnit parseAndTypeResolveForClass15(Class<?> clazz) {\n        return parseAndTypeResolveForClass(clazz, \"1.5\");\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.typeresolution.ClassTypeResolverTest#parseAndTypeResolveForClass\n methodBody: private ASTCompilationUnit parseAndTypeResolveForClass(Class<?> clazz) {\nString sourceFile=clazz.getName().replace('.','/') + \".java\";\nInputStream is=ClassTypeResolverTest.class.getClassLoader().getResourceAsStream(sourceFile);\nif(is == null){throw new IllegalArgumentException(\"Unable to find source file \" + sourceFile + \" for \" + clazz);\n}LanguageVersionHandler languageVersionHandler=LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion(\"1.5\").getLanguageVersionHandler();\nASTCompilationUnit acu=(ASTCompilationUnit)languageVersionHandler.getParser(languageVersionHandler.getDefaultParserOptions()).parse(null,new InputStreamReader(is));\nlanguageVersionHandler.getSymbolFacade().start(acu);\nlanguageVersionHandler.getTypeResolutionFacade(ClassTypeResolverTest.class.getClassLoader()).start(acu);\nreturn acu;\n}"
        ],
        "sourceCodeAfterRefactoring": "@Test\n    @SuppressWarnings(\"unchecked\")\n    public void testUnaryLogicalOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Operators.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryLogicalOperators']]//Expression\");\n        int index = 0;\n\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\nprivate ASTCompilationUnit parseAndTypeResolveForClass15(Class<?> clazz) {\n        return parseAndTypeResolveForClass(clazz, \"1.5\");\n    }",
        "diffSourceCode": "   392:     @Test\n   393:     @SuppressWarnings(\"unchecked\")\n   394:     public void testUnaryLogicalOperators() throws JaxenException {\n-  395:         ASTCompilationUnit acu = parseAndTypeResolveForClass(Operators.class);\n+  395:         ASTCompilationUnit acu = parseAndTypeResolveForClass15(Operators.class);\n   396:         List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryLogicalOperators']]//Expression\");\n   397:         int index = 0;\n   398: \n   399:         assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n   400:         assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n   401: \n   402:         // Make sure we got them all.\n   403:         assertEquals(\"All expressions not tested\", index, expressions.size());\n   404:     }\n-  501:     // Note: If you're using Eclipse or some other IDE to run this test, you _must_ have the regress folder in\n-  502:     // the classpath.  Normally the IDE doesn't put source directories themselves directly in the classpath, only\n-  503:     // the output directories are in the classpath.\n+  501:     private ASTCompilationUnit parseAndTypeResolveForClass15(Class<?> clazz) {\n+  502:         return parseAndTypeResolveForClass(clazz, \"1.5\");\n+  503:     }\n",
        "uniqueId": "18f393da3c8dc4aa426b27307baf55c3f700e6f1_392_404_501_503_392_404",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 1.8,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate assertWarningsWithFoo(size int, code String) : void extracted from package testClassLevelSuppression() : void in class net.sourceforge.pmd.lang.apex.SuppressWarningsTest",
        "diffLocations": [
            {
                "filePath": "pmd-apex/src/test/java/net/sourceforge/pmd/lang/apex/SuppressWarningsTest.java",
                "startLine": 47,
                "endLine": 53,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-apex/src/test/java/net/sourceforge/pmd/lang/apex/SuppressWarningsTest.java",
                "startLine": 52,
                "endLine": 54,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-apex/src/test/java/net/sourceforge/pmd/lang/apex/SuppressWarningsTest.java",
                "startLine": 158,
                "endLine": 161,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n    void testClassLevelSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST1);\n        assertSize(rpt, 0);\n        rpt = apex.executeRule(new FooRule(), TEST2);\n        assertSize(rpt, 0);\n    }",
        "filePathBefore": "pmd-apex/src/test/java/net/sourceforge/pmd/lang/apex/SuppressWarningsTest.java",
        "isPureRefactoring": true,
        "commitId": "b25c16f94d8d7c998e391eecb3ae06ac8be2aa32",
        "packageNameBefore": "net.sourceforge.pmd.lang.apex",
        "classNameBefore": "net.sourceforge.pmd.lang.apex.SuppressWarningsTest",
        "methodNameBefore": "net.sourceforge.pmd.lang.apex.SuppressWarningsTest#testClassLevelSuppression",
        "classSignatureBefore": "class SuppressWarningsTest extends ApexParserTestBase ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.apex.SuppressWarningsTest#testClassLevelSuppression"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.apex.SuppressWarningsTest"
        ],
        "classSignatureBeforeSet": [
            "class SuppressWarningsTest extends ApexParserTestBase "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics\nOverlapped refactoring - can be identical by undoing the overlapped refactoring\n- Rename Variable-",
                "description": "Rename Variable on top of the extract method - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex;\n\nimport static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSize;\nimport static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSuppressed;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.List;\n\nimport org.junit.jupiter.api.Test;\n\nimport net.sourceforge.pmd.PMD;\nimport net.sourceforge.pmd.Report;\nimport net.sourceforge.pmd.ViolationSuppressor;\nimport net.sourceforge.pmd.lang.apex.ast.ASTUserClass;\nimport net.sourceforge.pmd.lang.apex.ast.ApexParserTestBase;\nimport net.sourceforge.pmd.lang.apex.rule.AbstractApexRule;\n\nclass SuppressWarningsTest extends ApexParserTestBase {\n\n    // This could be a regular xml test\n\n    private static class BarRule extends AbstractApexRule {\n\n        @Override\n        public String getMessage() {\n            return \"a message\";\n        }\n\n        @Override\n        public Object visit(ASTUserClass clazz, Object ctx) {\n            if (clazz.getSimpleName().equalsIgnoreCase(\"bar\")) {\n                addViolation(ctx, clazz);\n            }\n            return super.visit(clazz, ctx);\n        }\n\n        @Override\n        public String getName() {\n            return \"NoBar\";\n        }\n    }\n\n    @Test\n    void testClassLevelSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST1);\n        assertSize(rpt, 0);\n        rpt = apex.executeRule(new FooRule(), TEST2);\n        assertSize(rpt, 0);\n    }\n\n    @Test\n    void testInheritedSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST3);\n        assertSize(rpt, 0);\n    }\n\n    @Test\n    void testMethodLevelSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST4);\n        assertSize(rpt, 1);\n    }\n\n    @Test\n    void testConstructorLevelSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST5);\n        assertSize(rpt, 0);\n    }\n\n    @Test\n    void testFieldLevelSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST6);\n        assertSize(rpt, 1);\n    }\n\n    @Test\n    void testParameterLevelSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST7);\n        assertSize(rpt, 1);\n    }\n\n    @Test\n    void testLocalVariableLevelSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST8);\n        assertSize(rpt, 1);\n    }\n\n    @Test\n    void testSpecificSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST9);\n        assertSize(rpt, 1);\n    }\n\n    @Test\n    void testSpecificSuppressionMulitpleValues() {\n        Report rpt = apex.executeRule(new FooRule(), TEST9_MULTIPLE_VALUES);\n        assertSize(rpt, 0);\n    }\n\n    @Test\n    void testNoSuppressionBlank() {\n        Report rpt = apex.executeRule(new FooRule(), TEST10);\n        assertSize(rpt, 2);\n    }\n\n    @Test\n    void testNoSuppressionSomethingElseS() {\n        Report rpt = apex.executeRule(new FooRule(), TEST11);\n        assertSize(rpt, 2);\n    }\n\n    @Test\n    void testSuppressAll() {\n        Report rpt = apex.executeRule(new FooRule(), TEST12);\n        assertSize(rpt, 0);\n    }\n\n    @Test\n    void testSpecificSuppressionAtTopLevel() {\n        Report rpt = apex.executeRule(new BarRule(), TEST13);\n        assertSize(rpt, 0);\n    }\n\n    @Test\n    void testCommentSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST14);\n        assertSize(rpt, 0);\n        assertSuppressed(rpt, 1);\n    }\n\n    @Test\n    void testMessageWithCommentSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST15);\n        assertSize(rpt, 0);\n\n        List<Report.SuppressedViolation> suppressions = assertSuppressed(rpt, 1);\n        Report.SuppressedViolation suppression = suppressions.get(0);\n\n        assertEquals(ViolationSuppressor.NOPMD_COMMENT_SUPPRESSOR, suppression.getSuppressor());\n        assertEquals(\"We allow foo here\", suppression.getUserMessage());\n    }\n\n    private static final String TEST1 = \"@SuppressWarnings('PMD')\" + PMD.EOL + \"public class Foo {}\";\n\n    private static final String TEST2 = \"@SuppressWarnings('PMD')\" + PMD.EOL + \"public class Foo {\" + PMD.EOL\n            + \" void bar() {\" + PMD.EOL + \"  Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST3 = \"public class Baz {\" + PMD.EOL + \" @SuppressWarnings('PMD')\" + PMD.EOL\n            + \" public class Bar {\" + PMD.EOL + \"  void bar() {\" + PMD.EOL + \"   Integer foo;\" + PMD.EOL + \"  }\" + PMD.EOL\n            + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST4 = \"public class Foo {\" + PMD.EOL + \" @SuppressWarnings('PMD')\" + PMD.EOL\n            + \" void bar() {\" + PMD.EOL + \"  Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST5 = \"public class Bar {\" + PMD.EOL + \" @SuppressWarnings('PMD')\" + PMD.EOL\n            + \" public Bar() {\" + PMD.EOL + \"  Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST6 = \"public class Bar {\" + PMD.EOL + \" @SuppressWarnings('PMD')\" + PMD.EOL\n            + \" Integer foo;\" + PMD.EOL + \" void bar() {\" + PMD.EOL + \"  Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST7 = \"public class Bar {\" + PMD.EOL + \" Integer foo;\" + PMD.EOL\n            + \" void bar(@SuppressWarnings('PMD') Integer foo) {}\" + PMD.EOL + \"}\";\n\n    private static final String TEST8 = \"public class Bar {\" + PMD.EOL + \" Integer foo;\" + PMD.EOL + \" void bar() {\"\n            + PMD.EOL + \"  @SuppressWarnings('PMD') Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST9 = \"public class Bar {\" + PMD.EOL + \" Integer foo;\" + PMD.EOL + \" void bar() {\"\n            + PMD.EOL + \"  @SuppressWarnings('PMD.NoFoo') Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST9_MULTIPLE_VALUES = \"@SuppressWarnings('PMD.NoFoo, PMD.NoBar')\"\n            + PMD.EOL + \"public class Bar {\" + PMD.EOL + \" Integer foo;\" + PMD.EOL + \" void bar() {\" + PMD.EOL\n            + \"  Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST10 = \"public class Bar {\" + PMD.EOL + \" Integer foo;\" + PMD.EOL + \" void bar() {\"\n            + PMD.EOL + \"  @SuppressWarnings('') Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST11 = \"public class Bar {\" + PMD.EOL + \" Integer foo;\" + PMD.EOL + \" void bar() {\"\n            + PMD.EOL + \"  @SuppressWarnings('SomethingElse') Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST12 = \"public class Bar {\" + PMD.EOL + \" @SuppressWarnings('all') Integer foo;\"\n            + PMD.EOL + \"}\";\n\n    private static final String TEST13 = \"@SuppressWarnings('PMD.NoBar')\" + PMD.EOL + \"public class Bar {\" + PMD.EOL\n            + \"}\";\n\n    private static final String TEST14 = \"public class Bar {\" + PMD.EOL + \"Integer foo; // NOPMD\" + PMD.EOL + \"}\";\n\n    private static final String TEST15 = \"public class Bar {\" + PMD.EOL + \"Integer foo; //NOPMD We allow foo here\" + PMD.EOL + \"}\";\n}\n",
        "filePathAfter": "pmd-apex/src/test/java/net/sourceforge/pmd/lang/apex/SuppressWarningsTest.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex;\n\nimport static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSize;\nimport static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSuppressed;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.List;\n\nimport org.junit.jupiter.api.Test;\n\nimport net.sourceforge.pmd.Report;\nimport net.sourceforge.pmd.ViolationSuppressor;\nimport net.sourceforge.pmd.lang.apex.ast.ASTUserClass;\nimport net.sourceforge.pmd.lang.apex.ast.ApexParserTestBase;\nimport net.sourceforge.pmd.lang.apex.rule.AbstractApexRule;\n\nclass SuppressWarningsTest extends ApexParserTestBase {\n\n    // This could be a regular xml test\n\n    private static class BarRule extends AbstractApexRule {\n\n        @Override\n        public String getMessage() {\n            return \"a message\";\n        }\n\n        @Override\n        public Object visit(ASTUserClass clazz, Object ctx) {\n            if (clazz.getSimpleName().equalsIgnoreCase(\"bar\")) {\n                addViolation(ctx, clazz);\n            }\n            return super.visit(clazz, ctx);\n        }\n\n        @Override\n        public String getName() {\n            return \"NoBar\";\n        }\n    }\n\n    @Test\n    void testClassLevelSuppression() {\n        assertNoWarningsWithFoo(\"@SuppressWarnings('PMD')\\n\"\n                                    + \"public class Foo {}\");\n    }\n\n    private void assertNoWarningsWithFoo(String code) {\n        assertWarningsWithFoo(0, code);\n    }\n\n    @Test\n    void testClassLevelSuppression2() {\n        assertNoWarningsWithFoo(\"@SuppressWarnings('PMD')\\n\"\n            + \"public class Foo {\" + \"\\n\"\n            + \" void bar() {\\n\"\n            + \"  Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testInheritedSuppression() {\n        assertNoWarningsWithFoo(\"public class Baz {\\n\"\n            + \" @SuppressWarnings('PMD')\" + \"\\n\"\n            + \" public class Bar {\\n\"\n            + \"  void bar() {\\n\"\n            + \"   Integer foo;\\n\"\n            + \"  }\" + \"\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testMethodLevelSuppression() {\n        assertWarningsWithFoo(1, \"public class Foo {\\n\" +\n            \" @SuppressWarnings('PMD')\\n\" +\n            \" void bar() {\\n\" +\n            \"  Integer foo;\\n\" +\n            \" }\\n\" +\n            \"}\");\n    }\n\n    @Test\n    void testConstructorLevelSuppression() {\n        assertNoWarningsWithFoo(\"public class Bar {\\n\"\n            + \" @SuppressWarnings('PMD')\" + \"\\n\"\n            + \" public Bar() {\\n\"\n            + \"  Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testFieldLevelSuppression() {\n        assertWarningsWithFoo(1, \"public class Bar {\\n\"\n            + \" @SuppressWarnings('PMD')\" + \"\\n\"\n            + \" Integer foo;\\n\"\n            + \" void bar() {\\n\"\n            + \"  Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testParameterLevelSuppression() {\n        assertWarningsWithFoo(1, \"public class Bar {\\n\"\n            + \" Integer foo;\" + \"\\n\"\n            + \" void bar(@SuppressWarnings('PMD') Integer foo) {}\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testLocalVariableLevelSuppression() {\n        assertWarningsWithFoo(1, \"public class Bar {\\n\"\n            + \" Integer foo;\\n\"\n            + \" void bar() {\"\n            + \"\\n\" + \"  @SuppressWarnings('PMD') Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testSpecificSuppression() {\n        assertWarningsWithFoo(1, \"public class Bar {\\n\"\n            + \" Integer foo;\\n\"\n            + \" void bar() {\"\n            + \"\\n\" + \"  @SuppressWarnings('PMD.NoFoo') Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testSpecificSuppressionMulitpleValues() {\n        assertNoWarningsWithFoo(\"@SuppressWarnings('PMD.NoFoo, PMD.NoBar')\"\n            + \"\\n\" + \"public class Bar {\\n\"\n            + \" Integer foo;\\n\"\n            + \" void bar() {\" + \"\\n\"\n            + \"  Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testNoSuppressionBlank() {\n        assertWarningsWithFoo(2, \"public class Bar {\\n\"\n            + \" Integer foo;\\n\"\n            + \" void bar() {\"\n            + \"\\n\" + \"  @SuppressWarnings('') Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    private void assertWarningsWithFoo(int size, String code) {\n        Report rpt = apex.executeRule(new FooRule(), code);\n        assertSize(rpt, size);\n    }\n\n    @Test\n    void testNoSuppressionSomethingElseS() {\n        assertWarningsWithFoo(2, \"public class Bar {\\n\"\n            + \" Integer foo;\\n\"\n            + \" void bar() {\"\n            + \"\\n\" + \"  @SuppressWarnings('SomethingElse') Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testSuppressAll() {\n        assertNoWarningsWithFoo(\"public class Bar {\\n\"\n            + \" @SuppressWarnings('all') Integer foo;\"\n            + \"\\n\" + \"}\");\n    }\n\n    @Test\n    void testSpecificSuppressionAtTopLevel() {\n        Report rpt = apex.executeRule(new BarRule(), \"@SuppressWarnings('PMD.NoBar')\\n\"\n            + \"public class Bar {\" + \"\\n\"\n            + \"}\");\n        assertSize(rpt, 0);\n    }\n\n    @Test\n    void testCommentSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), \"public class Bar {\\n\"\n            + \"Integer foo; // NOPMD\\n\"\n            + \"}\");\n        assertSize(rpt, 0);\n        assertSuppressed(rpt, 1);\n    }\n\n    @Test\n    void testMessageWithCommentSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), \"public class Bar {\\n\"\n            + \"Integer foo; //NOPMD We allow foo here\\n\"\n            + \"}\");\n        assertSize(rpt, 0);\n\n        List<Report.SuppressedViolation> suppressions = assertSuppressed(rpt, 1);\n        Report.SuppressedViolation suppression = suppressions.get(0);\n\n        assertEquals(ViolationSuppressor.NOPMD_COMMENT_SUPPRESSOR, suppression.getSuppressor());\n        assertEquals(\"We allow foo here\", suppression.getUserMessage());\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "private void assertWarningsWithFoo(int size, String code) {\n        Report rpt = apex.executeRule(new FooRule(), code);\n        assertSize(rpt, size);\n    }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "private void assertNoWarningsWithFoo(String code) {\n        assertWarningsWithFoo(0, code);\n    }\nprivate void assertWarningsWithFoo(int size, String code) {\n        Report rpt = apex.executeRule(new FooRule(), code);\n        assertSize(rpt, size);\n    }",
        "diffSourceCode": "-   47:     @Test\n-   48:     void testClassLevelSuppression() {\n-   49:         Report rpt = apex.executeRule(new FooRule(), TEST1);\n-   50:         assertSize(rpt, 0);\n-   51:         rpt = apex.executeRule(new FooRule(), TEST2);\n-   52:         assertSize(rpt, 0);\n-   53:     }\n-   54: \n-  158:     private static final String TEST5 = \"public class Bar {\" + PMD.EOL + \" @SuppressWarnings('PMD')\" + PMD.EOL\n-  159:             + \" public Bar() {\" + PMD.EOL + \"  Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n-  160: \n-  161:     private static final String TEST6 = \"public class Bar {\" + PMD.EOL + \" @SuppressWarnings('PMD')\" + PMD.EOL\n+   47:     void testClassLevelSuppression() {\n+   48:         assertNoWarningsWithFoo(\"@SuppressWarnings('PMD')\\n\"\n+   49:                                     + \"public class Foo {}\");\n+   50:     }\n+   51: \n+   52:     private void assertNoWarningsWithFoo(String code) {\n+   53:         assertWarningsWithFoo(0, code);\n+   54:     }\n+  158:     private void assertWarningsWithFoo(int size, String code) {\n+  159:         Report rpt = apex.executeRule(new FooRule(), code);\n+  160:         assertSize(rpt, size);\n+  161:     }\n",
        "uniqueId": "b25c16f94d8d7c998e391eecb3ae06ac8be2aa32_47_53_158_161_52_54",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic noop() : MessageReporter extracted from private parseReferenceAndWarn(ref String, xmlPlace Node, err PmdXmlReporter) : RuleSetReferenceId in class net.sourceforge.pmd.RuleSetFactory & moved to class net.sourceforge.pmd.util.log.MessageReporter",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/RuleSetFactory.java",
                "startLine": 442,
                "endLine": 462,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/RuleSetFactory.java",
                "startLine": 441,
                "endLine": 461,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/RuleSetFactory.java",
                "startLine": 100,
                "endLine": 106,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private RuleSetReferenceId parseReferenceAndWarn(String ref,\n                                                     Node xmlPlace,\n                                                     PmdXmlReporter err) {\n        ref = compatibilityFilter.applyRef(ref, this.warnDeprecated);\n        if (ref == null) {\n            err.at(xmlPlace).warn(\"Rule reference references a deleted rule, ignoring\");\n            return null; // deleted rule\n        }\n        // only emit a warning if we check for deprecated syntax\n        MessageReporter subReporter = warnDeprecated ? err.at(xmlPlace) : new NoopReporter();\n\n        List<RuleSetReferenceId> references = RuleSetReferenceId.parse(ref, subReporter);\n        if (references.size() > 1 && warnDeprecated) {\n            err.at(xmlPlace).warn(\"Using a comma separated list as a ref attribute is deprecated. \"\n                                      + \"All references but the first are ignored.\");\n        } else if (references.isEmpty()) {\n            err.at(xmlPlace).warn(\"Empty ref attribute\");\n            return null;\n        }\n        return references.get(0);\n    }",
        "filePathBefore": "pmd-core/src/main/java/net/sourceforge/pmd/RuleSetFactory.java",
        "isPureRefactoring": true,
        "commitId": "214e80a5f1d68e3b42efeacab5b0fc226202ef05",
        "packageNameBefore": "net.sourceforge.pmd",
        "classNameBefore": "net.sourceforge.pmd.RuleSetFactory",
        "methodNameBefore": "net.sourceforge.pmd.RuleSetFactory#parseReferenceAndWarn",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.util.log.MessageReporter#warn\n methodBody: default void warn(String message, Object... formatArgs) {\nlog(Level.WARN,message,formatArgs);\n}\nmethodSignature: net.sourceforge.pmd.DummyParsingHelper#parse\n methodBody: public DummyRootNode parse(String code, String filename) {\nLanguageVersion version=DummyLanguageModule.getInstance().getDefaultVersion();\nParserTask task=new ParserTask(TextDocument.readOnlyString(code,filename,version),SemanticErrorReporter.noop(),LanguageProcessorRegistry.singleton(dummyProcessor));\nreturn (DummyRootNode)dummyProcessor.services().getParser().parse(task);\n}",
        "classSignatureBefore": "final class RuleSetFactory ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.RuleSetFactory#parseReferenceAndWarn"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.RuleSetFactory"
        ],
        "classSignatureBeforeSet": [
            "final class RuleSetFactory "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd;\n\nimport static net.sourceforge.pmd.util.CollectionUtil.setOf;\nimport static net.sourceforge.pmd.util.internal.xml.SchemaConstants.DESCRIPTION;\nimport static net.sourceforge.pmd.util.internal.xml.SchemaConstants.EXCLUDE;\nimport static net.sourceforge.pmd.util.internal.xml.SchemaConstants.EXCLUDE_PATTERN;\nimport static net.sourceforge.pmd.util.internal.xml.SchemaConstants.INCLUDE_PATTERN;\nimport static net.sourceforge.pmd.util.internal.xml.SchemaConstants.NAME;\nimport static net.sourceforge.pmd.util.internal.xml.SchemaConstants.PRIORITY;\nimport static net.sourceforge.pmd.util.internal.xml.SchemaConstants.REF;\nimport static net.sourceforge.pmd.util.internal.xml.SchemaConstants.RULE;\nimport static net.sourceforge.pmd.util.internal.xml.SchemaConstants.RULESET;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.text.MessageFormat;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport java.util.zip.Adler32;\nimport java.util.zip.CheckedInputStream;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.slf4j.event.Level;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\nimport net.sourceforge.pmd.RuleSet.RuleSetBuilder;\nimport net.sourceforge.pmd.lang.LanguageRegistry;\nimport net.sourceforge.pmd.lang.rule.RuleReference;\nimport net.sourceforge.pmd.rules.RuleFactory;\nimport net.sourceforge.pmd.util.ResourceLoader;\nimport net.sourceforge.pmd.util.StringUtil;\nimport net.sourceforge.pmd.util.internal.xml.PmdXmlReporter;\nimport net.sourceforge.pmd.util.internal.xml.XmlErrorMessages;\nimport net.sourceforge.pmd.util.internal.xml.XmlUtil;\nimport net.sourceforge.pmd.util.log.MessageReporter;\nimport net.sourceforge.pmd.util.log.internal.NoopReporter;\n\nimport com.github.oowekyala.ooxml.DomUtils;\nimport com.github.oowekyala.ooxml.messages.NiceXmlMessageSpec;\nimport com.github.oowekyala.ooxml.messages.OoxmlFacade;\nimport com.github.oowekyala.ooxml.messages.PositionedXmlDoc;\nimport com.github.oowekyala.ooxml.messages.XmlException;\nimport com.github.oowekyala.ooxml.messages.XmlMessageHandler;\nimport com.github.oowekyala.ooxml.messages.XmlMessageReporterBase;\nimport com.github.oowekyala.ooxml.messages.XmlPosition;\nimport com.github.oowekyala.ooxml.messages.XmlPositioner;\nimport com.github.oowekyala.ooxml.messages.XmlSeverity;\n\n/**\n * RuleSetFactory is responsible for creating RuleSet instances from XML\n * content. See {@link RuleSetLoader} for configuration options and\n * their defaults.\n */\nfinal class RuleSetFactory {\n\n    private static final Logger LOG = LoggerFactory.getLogger(RuleSetFactory.class);\n\n    private final ResourceLoader resourceLoader;\n    private final LanguageRegistry languageRegistry;\n    private final RulePriority minimumPriority;\n    private final boolean warnDeprecated;\n    private final RuleSetFactoryCompatibility compatibilityFilter;\n    private final MessageReporter reporter;\n    private final boolean includeDeprecatedRuleReferences;\n\n    private final Map<RuleSetReferenceId, RuleSet> parsedRulesets = new HashMap<>();\n\n    RuleSetFactory(ResourceLoader resourceLoader,\n                   LanguageRegistry languageRegistry,\n                   RulePriority minimumPriority,\n                   boolean warnDeprecated,\n                   RuleSetFactoryCompatibility compatFilter,\n                   boolean includeDeprecatedRuleReferences,\n                   MessageReporter reporter) {\n        this.resourceLoader = resourceLoader;\n        this.languageRegistry = Objects.requireNonNull(languageRegistry);\n        this.minimumPriority = minimumPriority;\n        this.warnDeprecated = warnDeprecated;\n        this.includeDeprecatedRuleReferences = includeDeprecatedRuleReferences;\n\n        this.compatibilityFilter = compatFilter;\n        this.reporter = reporter;\n    }\n\n\n    /**\n     * Create a RuleSet from a RuleSetReferenceId. Priority filtering is ignored\n     * when loading a single Rule. The currently configured ResourceLoader is used.\n     *\n     * @param ruleSetReferenceId The RuleSetReferenceId of the RuleSet to create.\n     *\n     * @return A new RuleSet.\n     */\n    @NonNull RuleSet createRuleSet(RuleSetReferenceId ruleSetReferenceId) {\n        return createRuleSet(ruleSetReferenceId, includeDeprecatedRuleReferences);\n    }\n\n    private @NonNull RuleSet createRuleSet(RuleSetReferenceId ruleSetReferenceId, boolean withDeprecatedRuleReferences)\n        throws RuleSetLoadException {\n        return readDocument(ruleSetReferenceId, withDeprecatedRuleReferences);\n    }\n\n    /**\n     * Create a Rule from a RuleSet created from a file name resource. The\n     * currently configured ResourceLoader is used.\n     * <p>\n     * Any Rules in the RuleSet other than the one being created, are _not_\n     * created. Deprecated rules are _not_ ignored, so that they can be\n     * referenced.\n     *\n     * @param ruleSetReferenceId\n     *            The RuleSetReferenceId of the RuleSet with the Rule to create.\n     * @param withDeprecatedRuleReferences\n     *            Whether RuleReferences that are deprecated should be ignored\n     *            or not\n     * @return A new Rule.\n     */\n    private Rule createRule(RuleSetReferenceId ruleSetReferenceId, boolean withDeprecatedRuleReferences) {\n        RuleSetReferenceId parentRuleset = ruleSetReferenceId.getParentRulesetIfThisIsARule();\n        if (parentRuleset == null) {\n            throw new IllegalArgumentException(\n                \"Cannot parse a single Rule from an all Rule RuleSet reference: <\" + ruleSetReferenceId + \">.\");\n        }\n        // can't use computeIfAbsent as creating a ruleset may add more entries to the map.\n        RuleSet ruleSet = parsedRulesets.get(parentRuleset);\n        if (ruleSet == null) {\n            ruleSet = createRuleSet(ruleSetReferenceId, withDeprecatedRuleReferences);\n            parsedRulesets.put(ruleSetReferenceId, ruleSet);\n        }\n        return ruleSet.getRuleByName(ruleSetReferenceId.getRuleName());\n    }\n\n    /**\n     * Parse a ruleset node to construct a RuleSet.\n     *\n     * @param ruleSetReferenceId           The RuleSetReferenceId of the RuleSet being parsed.\n     * @param withDeprecatedRuleReferences whether rule references that are deprecated should be ignored\n     *                                     or not\n     *\n     * @return The new RuleSet.\n     *\n     * @throws RuleSetLoadException If the ruleset cannot be parsed (eg IO exception, malformed XML, validation errors)\n     */\n    private @NonNull RuleSet readDocument(RuleSetReferenceId ruleSetReferenceId, boolean withDeprecatedRuleReferences) {\n\n        try (CheckedInputStream inputStream = new CheckedInputStream(ruleSetReferenceId.getInputStream(resourceLoader), new Adler32())) {\n            if (!ruleSetReferenceId.isExternal()) {\n                throw new IllegalArgumentException(\n                    \"Cannot parse a RuleSet from a non-external reference: <\" + ruleSetReferenceId + \">.\");\n            }\n\n            XmlMessageHandler printer = getXmlMessagePrinter();\n            DocumentBuilder builder = createDocumentBuilder();\n            InputSource inputSource = new InputSource(inputStream);\n            inputSource.setSystemId(ruleSetReferenceId.getRuleSetFileName());\n\n            OoxmlFacade ooxml = new OoxmlFacade()\n                .withPrinter(printer)\n                .withAnsiColors(false);\n            PositionedXmlDoc parsed = ooxml.parse(builder, inputSource);\n\n            @SuppressWarnings(\"PMD.CloseResource\")\n            PmdXmlReporterImpl err = new PmdXmlReporterImpl(reporter, ooxml, parsed.getPositioner());\n            try {\n                RuleSetBuilder ruleSetBuilder = new RuleSetBuilder(inputStream.getChecksum().getValue()).withFileName(ruleSetReferenceId.getRuleSetFileName());\n\n                RuleSet ruleSet = parseRulesetNode(ruleSetReferenceId, withDeprecatedRuleReferences, parsed, ruleSetBuilder, err);\n                if (err.errCount > 0) {\n                    // note this makes us jump to the catch branch\n                    // these might have been non-fatal errors\n                    String message;\n                    if (err.errCount == 1) {\n                        message = \"An XML validation error occurred\";\n                    } else {\n                        message = err.errCount + \" XML validation errors occurred\";\n                    }\n                    throw new RuleSetLoadException(ruleSetReferenceId, message);\n                }\n                return ruleSet;\n            } catch (Exception | Error e) {\n                throw e;\n            }\n        } catch (ParserConfigurationException | IOException ex) {\n            throw new RuleSetLoadException(ruleSetReferenceId, ex);\n        }\n    }\n\n\n    private RuleSet parseRulesetNode(RuleSetReferenceId ruleSetReferenceId,\n                                     boolean withDeprecatedRuleReferences,\n                                     PositionedXmlDoc parsed,\n                                     RuleSetBuilder builder,\n                                     PmdXmlReporter err) {\n        Element ruleSetElement = parsed.getDocument().getDocumentElement();\n\n        if (ruleSetElement.hasAttribute(\"name\")) {\n            builder.withName(ruleSetElement.getAttribute(\"name\"));\n        } else {\n            err.at(ruleSetElement).warn(\"RuleSet name is missing. Future versions of PMD will require it.\");\n            builder.withName(\"Missing RuleSet Name\");\n        }\n\n        Set<String> rulesetReferences = new HashSet<>();\n\n        for (Element node : DomUtils.children(ruleSetElement)) {\n            String text = XmlUtil.parseTextNode(node);\n            if (DESCRIPTION.matchesElt(node)) {\n                builder.withDescription(text);\n            } else if (INCLUDE_PATTERN.matchesElt(node)) {\n                final Pattern pattern = parseRegex(node, text, err);\n                if (pattern == null) {\n                    continue;\n                }\n                builder.withFileInclusions(pattern);\n            } else if (EXCLUDE_PATTERN.matchesElt(node)) {\n                final Pattern pattern = parseRegex(node, text, err);\n                if (pattern == null) {\n                    continue;\n                }\n                builder.withFileExclusions(pattern);\n            } else if (RULE.matchesElt(node)) {\n                try {\n                    parseRuleNode(ruleSetReferenceId, builder, node, withDeprecatedRuleReferences, rulesetReferences, err);\n                } catch (XmlException ignored) {\n                    // already reported (it's an XmlException), error count\n                    // was incremented so parent method will throw RuleSetLoadException.\n                }\n            } else {\n                err.at(node).error(XmlErrorMessages.ERR__UNEXPECTED_ELEMENT_IN,\n                                   node.getTagName(),\n                                   RULESET);\n            }\n        }\n\n        if (!builder.hasDescription()) {\n            err.at(ruleSetElement).warn(\"RuleSet description is missing. Future versions of PMD will require it.\");\n            builder.withDescription(\"Missing description\");\n        }\n\n        builder.filterRulesByPriority(minimumPriority);\n\n        return builder.build();\n    }\n\n    private Pattern parseRegex(Element node, String text, PmdXmlReporter err) {\n        final Pattern pattern;\n        try {\n            pattern = Pattern.compile(text);\n        } catch (PatternSyntaxException pse) {\n            err.at(node).error(pse);\n            return null;\n        }\n        return pattern;\n    }\n\n\n    private DocumentBuilder createDocumentBuilder() throws ParserConfigurationException {\n        final DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\n        try {\n            /*\n             * parser hardening\n             * https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet#JAXP_DocumentBuilderFactory.2C_SAXParserFactory_and_DOM4J\n             */\n            // This is the PRIMARY defense. If DTDs (doctypes) are disallowed, almost all XML entity attacks are prevented\n            // Xerces 2 only - http://xerces.apache.org/xerces2-j/features.html#disallow-doctype-decl\n            dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\n            // If you can't completely disable DTDs, then at least do the following:\n            // Xerces 1 - http://xerces.apache.org/xerces-j/features.html#external-general-entities\n            // Xerces 2 - http://xerces.apache.org/xerces2-j/features.html#external-general-entities\n            // JDK7+ - http://xml.org/sax/features/external-general-entities\n            dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\n            // Xerces 1 - http://xerces.apache.org/xerces-j/features.html#external-parameter-entities\n            // Xerces 2 - http://xerces.apache.org/xerces2-j/features.html#external-parameter-entities\n            // JDK7+ - http://xml.org/sax/features/external-parameter-entities\n            dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\n            // Disable external DTDs as well\n            dbf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\n            // and these as well, per Timothy Morgan's 2014 paper: \"XML Schema, DTD, and Entity Attacks\"\n            dbf.setXIncludeAware(false);\n            dbf.setExpandEntityReferences(false);\n        } catch (final ParserConfigurationException e) {\n            // an unsupported feature... too bad, but won't fail execution due to this\n            LOG.warn(\"Ignored unsupported XML Parser Feature for parsing rulesets\", e);\n        }\n\n        return dbf.newDocumentBuilder();\n    }\n\n    /**\n     * Parse a rule node.\n     *\n     * @param ruleSetReferenceId           The RuleSetReferenceId of the RuleSet being parsed.\n     * @param ruleSetBuilder               The RuleSet being constructed.\n     * @param ruleNode                     Must be a rule element node.\n     * @param withDeprecatedRuleReferences whether rule references that are deprecated should be ignored\n     *                                     or not\n     * @param rulesetReferences            keeps track of already processed complete ruleset references in order to log\n     *                                     a warning\n     */\n    private void parseRuleNode(RuleSetReferenceId ruleSetReferenceId,\n                               RuleSetBuilder ruleSetBuilder,\n                               Element ruleNode,\n                               boolean withDeprecatedRuleReferences,\n                               Set<String> rulesetReferences,\n                               PmdXmlReporter err) {\n        if (REF.hasAttribute(ruleNode)) {\n            String ref = REF.getAttributeOrThrow(ruleNode, err);\n            RuleSetReferenceId refId = parseReferenceAndWarn(ref, REF.getAttributeNode(ruleNode), err);\n            if (refId != null) {\n                if (refId.isAllRules()) {\n                    parseRuleSetReferenceNode(ruleSetBuilder, ruleNode, ref, refId, rulesetReferences, err);\n                } else {\n                    parseRuleReferenceNode(ruleSetReferenceId, ruleSetBuilder, ruleNode, ref, refId, withDeprecatedRuleReferences, err);\n                }\n                return;\n            }\n        }\n        parseSingleRuleNode(ruleSetReferenceId, ruleSetBuilder, ruleNode, err);\n    }\n\n    /**\n     * Parse a rule node as an RuleSetReference for all Rules. Every Rule from\n     * the referred to RuleSet will be added as a RuleReference except for those\n     * explicitly excluded, below the minimum priority threshold for this\n     * RuleSetFactory, or which are deprecated.\n     *\n     * @param ruleSetBuilder\n     *            The RuleSet being constructed.\n     * @param ruleElement\n     *            Must be a rule element node.\n     * @param ref\n     *            The RuleSet reference.\n     * @param rulesetReferences keeps track of already processed complete ruleset references in order to log a warning\n     */\n    private void parseRuleSetReferenceNode(RuleSetBuilder ruleSetBuilder,\n                                           Element ruleElement,\n                                           String ref,\n                                          RuleSetReferenceId ruleSetReferenceId, Set<String> rulesetReferences,\n                                           PmdXmlReporter err) {\n        RulePriority priority = null;\n        Map<String, Element> excludedRulesCheck = new HashMap<>();\n        for (Element child : XmlUtil.getElementChildrenList(ruleElement)) {\n            if (EXCLUDE.matchesElt(child)) {\n                String excludedRuleName;\n                try {\n                    excludedRuleName = NAME.getAttributeOrThrow(child, err);\n                } catch (XmlException ignored) {\n                    // has been reported\n                    continue;\n                }\n                excludedRuleName = compatibilityFilter.applyExclude(ref, excludedRuleName, this.warnDeprecated);\n                if (excludedRuleName != null) {\n                    excludedRulesCheck.put(excludedRuleName, child);\n                }\n            } else if (PRIORITY.matchesElt(child)) {\n                priority = RuleFactory.parsePriority(err, child);\n            } else {\n                XmlUtil.reportIgnoredUnexpectedElt(ruleElement, child, setOf(EXCLUDE, PRIORITY), err);\n            }\n        }\n        final RuleSetReference ruleSetReference = new RuleSetReference(ref, true, excludedRulesCheck.keySet());\n\n        // load the ruleset with minimum priority low, so that we get all rules, to be able to exclude any rule\n        // minimum priority will be applied again, before constructing the final ruleset\n        RuleSetFactory ruleSetFactory = toLoader().filterAbovePriority(RulePriority.LOW).warnDeprecated(false).toFactory();\n        RuleSet otherRuleSet = ruleSetFactory.createRuleSet(ruleSetReferenceId);\n        List<RuleReference> potentialRules = new ArrayList<>();\n        int countDeprecated = 0;\n        for (Rule rule : otherRuleSet.getRules()) {\n            excludedRulesCheck.remove(rule.getName());\n            if (!ruleSetReference.getExcludes().contains(rule.getName())) {\n                RuleReference ruleReference = new RuleReference(rule, ruleSetReference);\n                // override the priority\n                if (priority != null) {\n                    ruleReference.setPriority(priority);\n                }\n\n                if (rule.isDeprecated()) {\n                    countDeprecated++;\n                }\n                potentialRules.add(ruleReference);\n            }\n        }\n\n        boolean rulesetDeprecated = false;\n        if (!potentialRules.isEmpty() && potentialRules.size() == countDeprecated) {\n            // all rules in the ruleset have been deprecated - the ruleset itself is considered to be deprecated\n            rulesetDeprecated = true;\n            err.at(REF.getAttributeNode(ruleElement))\n                .warn(\"The RuleSet {0} has been deprecated and will be removed in PMD {1}\",\n                      ref, PMDVersion.getNextMajorRelease());\n        }\n\n        for (RuleReference r : potentialRules) {\n            if (rulesetDeprecated || !r.getRule().isDeprecated()) {\n                // add the rule, if either the ruleset itself is deprecated (then we add all rules)\n                // or if the rule is not deprecated (in that case, the ruleset might contain deprecated as well\n                // as valid rules)\n                ruleSetBuilder.addRuleIfNotExists(r);\n            }\n        }\n\n        if (!excludedRulesCheck.isEmpty()) {\n            excludedRulesCheck.forEach(\n                (name, elt) ->\n                    err.at(elt).warn(\"Exclude pattern ''{0}'' did not match any rule in ruleset ''{1}''\", name, ref));\n        }\n\n        if (rulesetReferences.contains(ref)) {\n            err.at(ruleElement).warn(\"The ruleset {0} is referenced multiple times in ruleset ''{1}''\", ref, ruleSetBuilder.getName());\n        }\n        rulesetReferences.add(ref);\n    }\n\n    private RuleSetReferenceId parseReferenceAndWarn(String ref,\n                                                     Node xmlPlace,\n                                                     PmdXmlReporter err) {\n        ref = compatibilityFilter.applyRef(ref, this.warnDeprecated);\n        if (ref == null) {\n            err.at(xmlPlace).warn(\"Rule reference references a deleted rule, ignoring\");\n            return null; // deleted rule\n        }\n        // only emit a warning if we check for deprecated syntax\n        MessageReporter subReporter = warnDeprecated ? err.at(xmlPlace) : new NoopReporter();\n\n        List<RuleSetReferenceId> references = RuleSetReferenceId.parse(ref, subReporter);\n        if (references.size() > 1 && warnDeprecated) {\n            err.at(xmlPlace).warn(\"Using a comma separated list as a ref attribute is deprecated. \"\n                                      + \"All references but the first are ignored.\");\n        } else if (references.isEmpty()) {\n            err.at(xmlPlace).warn(\"Empty ref attribute\");\n            return null;\n        }\n        return references.get(0);\n    }\n\n    /**\n     * Parse a rule node as a single Rule. The Rule has been fully defined\n     * within the context of the current RuleSet.\n     *\n     * @param ruleSetReferenceId The RuleSetReferenceId of the RuleSet being parsed.\n     * @param ruleSetBuilder     The RuleSet being constructed.\n     * @param ruleNode           Must be a rule element node.\n     * @param err                Error reporter\n     */\n    private void parseSingleRuleNode(RuleSetReferenceId ruleSetReferenceId,\n                                     RuleSetBuilder ruleSetBuilder,\n                                     Element ruleNode,\n                                     PmdXmlReporter err) {\n\n        // Stop if we're looking for a particular Rule, and this element is not\n        // it.\n        if (StringUtils.isNotBlank(ruleSetReferenceId.getRuleName())\n            && !isRuleName(ruleNode, ruleSetReferenceId.getRuleName())) {\n            return;\n        }\n        Rule rule = new RuleFactory(resourceLoader, languageRegistry).buildRule(ruleNode, err);\n        rule.setRuleSetName(ruleSetBuilder.getName());\n\n        if (warnDeprecated && StringUtils.isBlank(ruleNode.getAttribute(\"language\"))) {\n            err.at(ruleNode).warn(\n                \"Rule {0}/{1} does not mention attribute language='{2}',\"\n                    + \" please mention it explicitly to be compatible with PMD 7\",\n                ruleSetReferenceId.getRuleSetFileName(), rule.getName(),\n                rule.getLanguage().getTerseName());\n        }\n\n        ruleSetBuilder.addRule(rule);\n    }\n\n\n    /**\n     * Parse a rule node as a RuleReference. A RuleReference is a single Rule\n     * which comes from another RuleSet with some of it's attributes potentially\n     * overridden.\n     *\n     * @param ruleSetReferenceId           The RuleSetReferenceId of the RuleSet being parsed.\n     * @param ruleSetBuilder               The RuleSet being constructed.\n     * @param ruleNode                     Must be a rule element node.\n     * @param ref                          A reference to a Rule.\n     * @param withDeprecatedRuleReferences whether rule references that are deprecated should be ignored\n     * @param err                          Error reporter\n     */\n    private void parseRuleReferenceNode(RuleSetReferenceId ruleSetReferenceId,\n                                        RuleSetBuilder ruleSetBuilder,\n                                        Element ruleNode,\n                                        String ref,\n                                       RuleSetReferenceId otherRuleSetReferenceId,\n                                        boolean withDeprecatedRuleReferences,\n                                        PmdXmlReporter err) {\n\n        // Stop if we're looking for a particular Rule, and this element is not\n        // it.\n        if (StringUtils.isNotBlank(ruleSetReferenceId.getRuleName())\n            && !isRuleName(ruleNode, ruleSetReferenceId.getRuleName())) {\n            return;\n        }\n\n        // load the ruleset with minimum priority low, so that we get all rules, to be able to exclude any rule\n        // minimum priority will be applied again, before constructing the final ruleset\n        RuleSetFactory ruleSetFactory = toLoader().filterAbovePriority(RulePriority.LOW).warnDeprecated(false).toFactory();\n\n        boolean isSameRuleSet = false;\n        if (!otherRuleSetReferenceId.isExternal()\n            && containsRule(ruleSetReferenceId, otherRuleSetReferenceId.getRuleName())) {\n            otherRuleSetReferenceId = new RuleSetReferenceId(ref, ruleSetReferenceId, err.at(REF.getAttributeNode(ruleNode)));\n            isSameRuleSet = true;\n        } else if (otherRuleSetReferenceId.isExternal()\n            && otherRuleSetReferenceId.getRuleSetFileName().equals(ruleSetReferenceId.getRuleSetFileName())) {\n            otherRuleSetReferenceId = new RuleSetReferenceId(otherRuleSetReferenceId.getRuleName(), ruleSetReferenceId, err.at(REF.getAttributeNode(ruleNode)));\n            isSameRuleSet = true;\n        }\n        // do not ignore deprecated rule references\n        Rule referencedRule = ruleSetFactory.createRule(otherRuleSetReferenceId, true);\n\n        if (referencedRule == null) {\n            throw err.at(ruleNode).error(\n                \"Unable to find referenced rule {0}\"\n                    + \"; perhaps the rule name is misspelled?\",\n                otherRuleSetReferenceId.getRuleName());\n        }\n\n        if (warnDeprecated && referencedRule.isDeprecated()) {\n            if (referencedRule instanceof RuleReference) {\n                RuleReference ruleReference = (RuleReference) referencedRule;\n                err.at(ruleNode).warn(\n                    \"Use Rule name {0}/{1} instead of the deprecated Rule name {2}. PMD {3}\"\n                        + \" will remove support for this deprecated Rule name usage.\",\n                    ruleReference.getRuleSetReference().getRuleSetFileName(),\n                    ruleReference.getOriginalName(), otherRuleSetReferenceId,\n                    PMDVersion.getNextMajorRelease());\n            } else {\n                err.at(ruleNode).warn(\n                    \"Discontinue using Rule name {0} as it is scheduled for removal from PMD.\"\n                        + \" PMD {1} will remove support for this Rule.\",\n                    otherRuleSetReferenceId, PMDVersion.getNextMajorRelease());\n            }\n        }\n\n        RuleSetReference ruleSetReference = new RuleSetReference(otherRuleSetReferenceId.getRuleSetFileName(), false);\n\n        RuleReference ruleReference;\n        try {\n            ruleReference = new RuleFactory(resourceLoader, languageRegistry).decorateRule(referencedRule, ruleSetReference, ruleNode, err);\n        } catch (XmlException e) {\n            throw err.at(ruleNode).error(e, \"Error while parsing rule reference\");\n        }\n\n        if (warnDeprecated && ruleReference.isDeprecated() && !isSameRuleSet) {\n            err.at(ruleNode).warn(\n                \"Use Rule name {0}/{1} instead of the deprecated Rule name {2}/{3}. PMD {4}\"\n                    + \" will remove support for this deprecated Rule name usage.\",\n                ruleReference.getRuleSetReference().getRuleSetFileName(),\n                ruleReference.getOriginalName(),\n                ruleSetReferenceId.getRuleSetFileName(),\n                ruleReference.getName(),\n                PMDVersion.getNextMajorRelease());\n        }\n\n        if (withDeprecatedRuleReferences || !isSameRuleSet || !ruleReference.isDeprecated()) {\n            Rule existingRule = ruleSetBuilder.getExistingRule(ruleReference);\n            if (existingRule instanceof RuleReference) {\n                RuleReference existingRuleReference = (RuleReference) existingRule;\n                // the only valid use case is: the existing rule does not override anything yet\n                // which means, it is a plain reference. And the new reference overrides.\n                // for all other cases, we should log a warning\n                if (existingRuleReference.hasOverriddenAttributes() || !ruleReference.hasOverriddenAttributes()) {\n                    err.at(ruleNode).warn(\n                        \"The rule {0} is referenced multiple times in ruleset ''{1}''. \"\n                            + \"Only the last rule configuration is used.\",\n                        ruleReference.getName(),\n                        ruleSetBuilder.getName());\n                }\n            }\n\n            ruleSetBuilder.addRuleReplaceIfExists(ruleReference);\n        }\n    }\n\n\n    /**\n     * Check whether the given ruleName is contained in the given ruleset.\n     *\n     * @param ruleSetReferenceId the ruleset to check\n     * @param ruleName           the rule name to search for\n     *\n     * @return {@code true} if the ruleName exists\n     */\n    private boolean containsRule(RuleSetReferenceId ruleSetReferenceId, String ruleName) {\n        // TODO: avoid reloading the ruleset once again\n        boolean found = false;\n        try (InputStream ruleSet = ruleSetReferenceId.getInputStream(resourceLoader)) {\n            DocumentBuilder builder = createDocumentBuilder();\n            Document document = builder.parse(ruleSet);\n            Element ruleSetElement = document.getDocumentElement();\n\n            NodeList rules = ruleSetElement.getElementsByTagName(\"rule\");\n            for (int i = 0; i < rules.getLength(); i++) {\n                Element rule = (Element) rules.item(i);\n                if (rule.hasAttribute(\"name\") && rule.getAttribute(\"name\").equals(ruleName)) {\n                    found = true;\n                    break;\n                }\n            }\n        } catch (Exception e) {\n            throw new RuleSetLoadException(ruleSetReferenceId, e);\n        }\n\n        return found;\n    }\n\n    /**\n     * Determine if the specified rule element will represent a Rule with the\n     * given name.\n     *\n     * @param ruleElement The rule element.\n     * @param ruleName    The Rule name.\n     *\n     * @return {@code true} if the Rule would have the given name, {@code false} otherwise.\n     */\n    private boolean isRuleName(Element ruleElement, String ruleName) {\n        if (ruleElement.hasAttribute(\"name\")) {\n            return ruleElement.getAttribute(\"name\").equals(ruleName);\n        } else if (ruleElement.hasAttribute(\"ref\")) {\n            RuleSetReferenceId ruleSetReferenceId = RuleSetReferenceId.parse(ruleElement.getAttribute(\"ref\")).get(0);\n            return ruleSetReferenceId.getRuleName() != null && ruleSetReferenceId.getRuleName().equals(ruleName);\n        } else {\n            return false;\n        }\n    }\n\n\n    /**\n     * Create a new {@link RuleSetLoader} with the same config as this\n     * factory. This is a transitional API.\n     */\n    public RuleSetLoader toLoader() {\n        return new RuleSetLoader().loadResourcesWith(resourceLoader)\n                                  .filterAbovePriority(minimumPriority)\n                                  .warnDeprecated(warnDeprecated)\n                                  .enableCompatibility(compatibilityFilter != null)\n                                  .includeDeprecatedRuleReferences(includeDeprecatedRuleReferences);\n    }\n\n    private @NonNull XmlMessageHandler getXmlMessagePrinter() {\n        return entry -> {\n            Level level = entry.getSeverity() == XmlSeverity.WARNING ? Level.WARN : Level.ERROR;\n            String quotedText = StringUtil.quoteMessageFormat(entry.toString());\n            reporter.logEx(level, quotedText, new Object[0], entry.getCause());\n        };\n    }\n\n    private static final class PmdXmlReporterImpl\n        extends XmlMessageReporterBase<MessageReporter>\n        implements PmdXmlReporter {\n\n        private final MessageReporter pmdReporter;\n        private int errCount;\n\n        PmdXmlReporterImpl(MessageReporter pmdReporter, OoxmlFacade ooxml, XmlPositioner positioner) {\n            super(ooxml, positioner);\n            this.pmdReporter = pmdReporter;\n        }\n\n        @Override\n        protected MessageReporter create2ndStage(XmlPosition position, XmlPositioner positioner) {\n            return new MessageReporter() {\n                @Override\n                public boolean isLoggable(Level level) {\n                    return pmdReporter.isLoggable(level);\n                }\n\n\n                @Override\n                public void log(Level level, String message, Object... formatArgs) {\n                    logEx(level, message, formatArgs, null);\n                }\n\n                @Override\n                public void logEx(Level level, String message, Object[] formatArgs, @Nullable Throwable error) {\n                    newException(level, error, message, formatArgs);\n                }\n\n                @Override\n                public XmlException error(@Nullable Throwable cause, @Nullable String contextMessage, Object... formatArgs) {\n                    return newException(Level.ERROR, cause, contextMessage, formatArgs);\n                }\n\n                @Override\n                public XmlException newException(Level level, Throwable cause, String message, Object... formatArgs) {\n                    XmlSeverity severity;\n                    switch (level) {\n                    case WARN:\n                        severity = XmlSeverity.WARNING;\n                        break;\n                    case ERROR:\n                        errCount++;\n                        severity = XmlSeverity.ERROR;\n                        break;\n                    default:\n                        throw new IllegalArgumentException(\"unexpected level \" + level);\n                    }\n\n                    if (message == null && formatArgs.length != 0) {\n                        throw new IllegalArgumentException(\"Cannot pass format arguments for null message\");\n                    }\n\n                    String actualMessage = message == null ? cause.getMessage()\n                                                           : MessageFormat.format(message, formatArgs);\n                    NiceXmlMessageSpec spec =\n                        new NiceXmlMessageSpec(position, actualMessage)\n                            .withSeverity(severity)\n                            .withCause(cause);\n                    String fullMessage = ooxml.getFormatter().formatSpec(ooxml, spec, positioner);\n                    XmlException ex = new XmlException(spec, fullMessage);\n                    ooxml.getPrinter().accept(ex); // spec of newException is also to log.\n                    return ex;\n                }\n\n                @Override\n                public int numErrors() {\n                    return pmdReporter.numErrors();\n                }\n            };\n        }\n    }\n\n}\n",
        "filePathAfter": "pmd-core/src/main/java/net/sourceforge/pmd/RuleSetFactory.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd;\n\nimport static net.sourceforge.pmd.util.CollectionUtil.setOf;\nimport static net.sourceforge.pmd.util.internal.xml.SchemaConstants.DESCRIPTION;\nimport static net.sourceforge.pmd.util.internal.xml.SchemaConstants.EXCLUDE;\nimport static net.sourceforge.pmd.util.internal.xml.SchemaConstants.EXCLUDE_PATTERN;\nimport static net.sourceforge.pmd.util.internal.xml.SchemaConstants.INCLUDE_PATTERN;\nimport static net.sourceforge.pmd.util.internal.xml.SchemaConstants.NAME;\nimport static net.sourceforge.pmd.util.internal.xml.SchemaConstants.PRIORITY;\nimport static net.sourceforge.pmd.util.internal.xml.SchemaConstants.REF;\nimport static net.sourceforge.pmd.util.internal.xml.SchemaConstants.RULE;\nimport static net.sourceforge.pmd.util.internal.xml.SchemaConstants.RULESET;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.text.MessageFormat;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport java.util.zip.Adler32;\nimport java.util.zip.CheckedInputStream;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.slf4j.event.Level;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\nimport net.sourceforge.pmd.RuleSet.RuleSetBuilder;\nimport net.sourceforge.pmd.lang.LanguageRegistry;\nimport net.sourceforge.pmd.lang.rule.RuleReference;\nimport net.sourceforge.pmd.rules.RuleFactory;\nimport net.sourceforge.pmd.util.ResourceLoader;\nimport net.sourceforge.pmd.util.StringUtil;\nimport net.sourceforge.pmd.util.internal.xml.PmdXmlReporter;\nimport net.sourceforge.pmd.util.internal.xml.XmlErrorMessages;\nimport net.sourceforge.pmd.util.internal.xml.XmlUtil;\nimport net.sourceforge.pmd.util.log.MessageReporter;\n\nimport com.github.oowekyala.ooxml.DomUtils;\nimport com.github.oowekyala.ooxml.messages.NiceXmlMessageSpec;\nimport com.github.oowekyala.ooxml.messages.OoxmlFacade;\nimport com.github.oowekyala.ooxml.messages.PositionedXmlDoc;\nimport com.github.oowekyala.ooxml.messages.XmlException;\nimport com.github.oowekyala.ooxml.messages.XmlMessageHandler;\nimport com.github.oowekyala.ooxml.messages.XmlMessageReporterBase;\nimport com.github.oowekyala.ooxml.messages.XmlPosition;\nimport com.github.oowekyala.ooxml.messages.XmlPositioner;\nimport com.github.oowekyala.ooxml.messages.XmlSeverity;\n\n/**\n * RuleSetFactory is responsible for creating RuleSet instances from XML\n * content. See {@link RuleSetLoader} for configuration options and\n * their defaults.\n */\nfinal class RuleSetFactory {\n\n    private static final Logger LOG = LoggerFactory.getLogger(RuleSetFactory.class);\n\n    private final ResourceLoader resourceLoader;\n    private final LanguageRegistry languageRegistry;\n    private final RulePriority minimumPriority;\n    private final boolean warnDeprecated;\n    private final RuleSetFactoryCompatibility compatibilityFilter;\n    private final MessageReporter reporter;\n    private final boolean includeDeprecatedRuleReferences;\n\n    private final Map<RuleSetReferenceId, RuleSet> parsedRulesets = new HashMap<>();\n\n    RuleSetFactory(ResourceLoader resourceLoader,\n                   LanguageRegistry languageRegistry,\n                   RulePriority minimumPriority,\n                   boolean warnDeprecated,\n                   RuleSetFactoryCompatibility compatFilter,\n                   boolean includeDeprecatedRuleReferences,\n                   MessageReporter reporter) {\n        this.resourceLoader = resourceLoader;\n        this.languageRegistry = Objects.requireNonNull(languageRegistry);\n        this.minimumPriority = minimumPriority;\n        this.warnDeprecated = warnDeprecated;\n        this.includeDeprecatedRuleReferences = includeDeprecatedRuleReferences;\n\n        this.compatibilityFilter = compatFilter;\n        this.reporter = reporter;\n    }\n\n\n    /**\n     * Create a RuleSet from a RuleSetReferenceId. Priority filtering is ignored\n     * when loading a single Rule. The currently configured ResourceLoader is used.\n     *\n     * @param ruleSetReferenceId The RuleSetReferenceId of the RuleSet to create.\n     *\n     * @return A new RuleSet.\n     */\n    @NonNull RuleSet createRuleSet(RuleSetReferenceId ruleSetReferenceId) {\n        return createRuleSet(ruleSetReferenceId, includeDeprecatedRuleReferences);\n    }\n\n    private @NonNull RuleSet createRuleSet(RuleSetReferenceId ruleSetReferenceId, boolean withDeprecatedRuleReferences)\n        throws RuleSetLoadException {\n        return readDocument(ruleSetReferenceId, withDeprecatedRuleReferences);\n    }\n\n    /**\n     * Create a Rule from a RuleSet created from a file name resource. The\n     * currently configured ResourceLoader is used.\n     * <p>\n     * Any Rules in the RuleSet other than the one being created, are _not_\n     * created. Deprecated rules are _not_ ignored, so that they can be\n     * referenced.\n     *\n     * @param ruleSetReferenceId\n     *            The RuleSetReferenceId of the RuleSet with the Rule to create.\n     * @param withDeprecatedRuleReferences\n     *            Whether RuleReferences that are deprecated should be ignored\n     *            or not\n     * @return A new Rule.\n     */\n    private Rule createRule(RuleSetReferenceId ruleSetReferenceId, boolean withDeprecatedRuleReferences) {\n        RuleSetReferenceId parentRuleset = ruleSetReferenceId.getParentRulesetIfThisIsARule();\n        if (parentRuleset == null) {\n            throw new IllegalArgumentException(\n                \"Cannot parse a single Rule from an all Rule RuleSet reference: <\" + ruleSetReferenceId + \">.\");\n        }\n        // can't use computeIfAbsent as creating a ruleset may add more entries to the map.\n        RuleSet ruleSet = parsedRulesets.get(parentRuleset);\n        if (ruleSet == null) {\n            ruleSet = createRuleSet(ruleSetReferenceId, withDeprecatedRuleReferences);\n            parsedRulesets.put(ruleSetReferenceId, ruleSet);\n        }\n        return ruleSet.getRuleByName(ruleSetReferenceId.getRuleName());\n    }\n\n    /**\n     * Parse a ruleset node to construct a RuleSet.\n     *\n     * @param ruleSetReferenceId           The RuleSetReferenceId of the RuleSet being parsed.\n     * @param withDeprecatedRuleReferences whether rule references that are deprecated should be ignored\n     *                                     or not\n     *\n     * @return The new RuleSet.\n     *\n     * @throws RuleSetLoadException If the ruleset cannot be parsed (eg IO exception, malformed XML, validation errors)\n     */\n    private @NonNull RuleSet readDocument(RuleSetReferenceId ruleSetReferenceId, boolean withDeprecatedRuleReferences) {\n\n        try (CheckedInputStream inputStream = new CheckedInputStream(ruleSetReferenceId.getInputStream(resourceLoader), new Adler32())) {\n            if (!ruleSetReferenceId.isExternal()) {\n                throw new IllegalArgumentException(\n                    \"Cannot parse a RuleSet from a non-external reference: <\" + ruleSetReferenceId + \">.\");\n            }\n\n            XmlMessageHandler printer = getXmlMessagePrinter();\n            DocumentBuilder builder = createDocumentBuilder();\n            InputSource inputSource = new InputSource(inputStream);\n            inputSource.setSystemId(ruleSetReferenceId.getRuleSetFileName());\n\n            OoxmlFacade ooxml = new OoxmlFacade()\n                .withPrinter(printer)\n                .withAnsiColors(false);\n            PositionedXmlDoc parsed = ooxml.parse(builder, inputSource);\n\n            @SuppressWarnings(\"PMD.CloseResource\")\n            PmdXmlReporterImpl err = new PmdXmlReporterImpl(reporter, ooxml, parsed.getPositioner());\n            try {\n                RuleSetBuilder ruleSetBuilder = new RuleSetBuilder(inputStream.getChecksum().getValue()).withFileName(ruleSetReferenceId.getRuleSetFileName());\n\n                RuleSet ruleSet = parseRulesetNode(ruleSetReferenceId, withDeprecatedRuleReferences, parsed, ruleSetBuilder, err);\n                if (err.errCount > 0) {\n                    // note this makes us jump to the catch branch\n                    // these might have been non-fatal errors\n                    String message;\n                    if (err.errCount == 1) {\n                        message = \"An XML validation error occurred\";\n                    } else {\n                        message = err.errCount + \" XML validation errors occurred\";\n                    }\n                    throw new RuleSetLoadException(ruleSetReferenceId, message);\n                }\n                return ruleSet;\n            } catch (Exception | Error e) {\n                throw e;\n            }\n        } catch (ParserConfigurationException | IOException ex) {\n            throw new RuleSetLoadException(ruleSetReferenceId, ex);\n        }\n    }\n\n\n    private RuleSet parseRulesetNode(RuleSetReferenceId ruleSetReferenceId,\n                                     boolean withDeprecatedRuleReferences,\n                                     PositionedXmlDoc parsed,\n                                     RuleSetBuilder builder,\n                                     PmdXmlReporter err) {\n        Element ruleSetElement = parsed.getDocument().getDocumentElement();\n\n        if (ruleSetElement.hasAttribute(\"name\")) {\n            builder.withName(ruleSetElement.getAttribute(\"name\"));\n        } else {\n            err.at(ruleSetElement).warn(\"RuleSet name is missing. Future versions of PMD will require it.\");\n            builder.withName(\"Missing RuleSet Name\");\n        }\n\n        Set<String> rulesetReferences = new HashSet<>();\n\n        for (Element node : DomUtils.children(ruleSetElement)) {\n            String text = XmlUtil.parseTextNode(node);\n            if (DESCRIPTION.matchesElt(node)) {\n                builder.withDescription(text);\n            } else if (INCLUDE_PATTERN.matchesElt(node)) {\n                final Pattern pattern = parseRegex(node, text, err);\n                if (pattern == null) {\n                    continue;\n                }\n                builder.withFileInclusions(pattern);\n            } else if (EXCLUDE_PATTERN.matchesElt(node)) {\n                final Pattern pattern = parseRegex(node, text, err);\n                if (pattern == null) {\n                    continue;\n                }\n                builder.withFileExclusions(pattern);\n            } else if (RULE.matchesElt(node)) {\n                try {\n                    parseRuleNode(ruleSetReferenceId, builder, node, withDeprecatedRuleReferences, rulesetReferences, err);\n                } catch (XmlException ignored) {\n                    // already reported (it's an XmlException), error count\n                    // was incremented so parent method will throw RuleSetLoadException.\n                }\n            } else {\n                err.at(node).error(XmlErrorMessages.ERR__UNEXPECTED_ELEMENT_IN,\n                                   node.getTagName(),\n                                   RULESET);\n            }\n        }\n\n        if (!builder.hasDescription()) {\n            err.at(ruleSetElement).warn(\"RuleSet description is missing. Future versions of PMD will require it.\");\n            builder.withDescription(\"Missing description\");\n        }\n\n        builder.filterRulesByPriority(minimumPriority);\n\n        return builder.build();\n    }\n\n    private Pattern parseRegex(Element node, String text, PmdXmlReporter err) {\n        final Pattern pattern;\n        try {\n            pattern = Pattern.compile(text);\n        } catch (PatternSyntaxException pse) {\n            err.at(node).error(pse);\n            return null;\n        }\n        return pattern;\n    }\n\n\n    private DocumentBuilder createDocumentBuilder() throws ParserConfigurationException {\n        final DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\n        try {\n            /*\n             * parser hardening\n             * https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet#JAXP_DocumentBuilderFactory.2C_SAXParserFactory_and_DOM4J\n             */\n            // This is the PRIMARY defense. If DTDs (doctypes) are disallowed, almost all XML entity attacks are prevented\n            // Xerces 2 only - http://xerces.apache.org/xerces2-j/features.html#disallow-doctype-decl\n            dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\n            // If you can't completely disable DTDs, then at least do the following:\n            // Xerces 1 - http://xerces.apache.org/xerces-j/features.html#external-general-entities\n            // Xerces 2 - http://xerces.apache.org/xerces2-j/features.html#external-general-entities\n            // JDK7+ - http://xml.org/sax/features/external-general-entities\n            dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\n            // Xerces 1 - http://xerces.apache.org/xerces-j/features.html#external-parameter-entities\n            // Xerces 2 - http://xerces.apache.org/xerces2-j/features.html#external-parameter-entities\n            // JDK7+ - http://xml.org/sax/features/external-parameter-entities\n            dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\n            // Disable external DTDs as well\n            dbf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\n            // and these as well, per Timothy Morgan's 2014 paper: \"XML Schema, DTD, and Entity Attacks\"\n            dbf.setXIncludeAware(false);\n            dbf.setExpandEntityReferences(false);\n        } catch (final ParserConfigurationException e) {\n            // an unsupported feature... too bad, but won't fail execution due to this\n            LOG.warn(\"Ignored unsupported XML Parser Feature for parsing rulesets\", e);\n        }\n\n        return dbf.newDocumentBuilder();\n    }\n\n    /**\n     * Parse a rule node.\n     *\n     * @param ruleSetReferenceId           The RuleSetReferenceId of the RuleSet being parsed.\n     * @param ruleSetBuilder               The RuleSet being constructed.\n     * @param ruleNode                     Must be a rule element node.\n     * @param withDeprecatedRuleReferences whether rule references that are deprecated should be ignored\n     *                                     or not\n     * @param rulesetReferences            keeps track of already processed complete ruleset references in order to log\n     *                                     a warning\n     */\n    private void parseRuleNode(RuleSetReferenceId ruleSetReferenceId,\n                               RuleSetBuilder ruleSetBuilder,\n                               Element ruleNode,\n                               boolean withDeprecatedRuleReferences,\n                               Set<String> rulesetReferences,\n                               PmdXmlReporter err) {\n        if (REF.hasAttribute(ruleNode)) {\n            String ref = REF.getAttributeOrThrow(ruleNode, err);\n            RuleSetReferenceId refId = parseReferenceAndWarn(ref, REF.getAttributeNode(ruleNode), err);\n            if (refId != null) {\n                if (refId.isAllRules()) {\n                    parseRuleSetReferenceNode(ruleSetBuilder, ruleNode, ref, refId, rulesetReferences, err);\n                } else {\n                    parseRuleReferenceNode(ruleSetReferenceId, ruleSetBuilder, ruleNode, ref, refId, withDeprecatedRuleReferences, err);\n                }\n                return;\n            }\n        }\n        parseSingleRuleNode(ruleSetReferenceId, ruleSetBuilder, ruleNode, err);\n    }\n\n    /**\n     * Parse a rule node as an RuleSetReference for all Rules. Every Rule from\n     * the referred to RuleSet will be added as a RuleReference except for those\n     * explicitly excluded, below the minimum priority threshold for this\n     * RuleSetFactory, or which are deprecated.\n     *\n     * @param ruleSetBuilder\n     *            The RuleSet being constructed.\n     * @param ruleElement\n     *            Must be a rule element node.\n     * @param ref\n     *            The RuleSet reference.\n     * @param rulesetReferences keeps track of already processed complete ruleset references in order to log a warning\n     */\n    private void parseRuleSetReferenceNode(RuleSetBuilder ruleSetBuilder,\n                                           Element ruleElement,\n                                           String ref,\n                                          RuleSetReferenceId ruleSetReferenceId, Set<String> rulesetReferences,\n                                           PmdXmlReporter err) {\n        RulePriority priority = null;\n        Map<String, Element> excludedRulesCheck = new HashMap<>();\n        for (Element child : XmlUtil.getElementChildrenList(ruleElement)) {\n            if (EXCLUDE.matchesElt(child)) {\n                String excludedRuleName;\n                try {\n                    excludedRuleName = NAME.getAttributeOrThrow(child, err);\n                } catch (XmlException ignored) {\n                    // has been reported\n                    continue;\n                }\n                excludedRuleName = compatibilityFilter.applyExclude(ref, excludedRuleName, this.warnDeprecated);\n                if (excludedRuleName != null) {\n                    excludedRulesCheck.put(excludedRuleName, child);\n                }\n            } else if (PRIORITY.matchesElt(child)) {\n                priority = RuleFactory.parsePriority(err, child);\n            } else {\n                XmlUtil.reportIgnoredUnexpectedElt(ruleElement, child, setOf(EXCLUDE, PRIORITY), err);\n            }\n        }\n        final RuleSetReference ruleSetReference = new RuleSetReference(ref, true, excludedRulesCheck.keySet());\n\n        // load the ruleset with minimum priority low, so that we get all rules, to be able to exclude any rule\n        // minimum priority will be applied again, before constructing the final ruleset\n        RuleSetFactory ruleSetFactory = toLoader().filterAbovePriority(RulePriority.LOW).warnDeprecated(false).toFactory();\n        RuleSet otherRuleSet = ruleSetFactory.createRuleSet(ruleSetReferenceId);\n        List<RuleReference> potentialRules = new ArrayList<>();\n        int countDeprecated = 0;\n        for (Rule rule : otherRuleSet.getRules()) {\n            excludedRulesCheck.remove(rule.getName());\n            if (!ruleSetReference.getExcludes().contains(rule.getName())) {\n                RuleReference ruleReference = new RuleReference(rule, ruleSetReference);\n                // override the priority\n                if (priority != null) {\n                    ruleReference.setPriority(priority);\n                }\n\n                if (rule.isDeprecated()) {\n                    countDeprecated++;\n                }\n                potentialRules.add(ruleReference);\n            }\n        }\n\n        boolean rulesetDeprecated = false;\n        if (!potentialRules.isEmpty() && potentialRules.size() == countDeprecated) {\n            // all rules in the ruleset have been deprecated - the ruleset itself is considered to be deprecated\n            rulesetDeprecated = true;\n            err.at(REF.getAttributeNode(ruleElement))\n                .warn(\"The RuleSet {0} has been deprecated and will be removed in PMD {1}\",\n                      ref, PMDVersion.getNextMajorRelease());\n        }\n\n        for (RuleReference r : potentialRules) {\n            if (rulesetDeprecated || !r.getRule().isDeprecated()) {\n                // add the rule, if either the ruleset itself is deprecated (then we add all rules)\n                // or if the rule is not deprecated (in that case, the ruleset might contain deprecated as well\n                // as valid rules)\n                ruleSetBuilder.addRuleIfNotExists(r);\n            }\n        }\n\n        if (!excludedRulesCheck.isEmpty()) {\n            excludedRulesCheck.forEach(\n                (name, elt) ->\n                    err.at(elt).warn(\"Exclude pattern ''{0}'' did not match any rule in ruleset ''{1}''\", name, ref));\n        }\n\n        if (rulesetReferences.contains(ref)) {\n            err.at(ruleElement).warn(\"The ruleset {0} is referenced multiple times in ruleset ''{1}''\", ref, ruleSetBuilder.getName());\n        }\n        rulesetReferences.add(ref);\n    }\n\n    private RuleSetReferenceId parseReferenceAndWarn(String ref,\n                                                     Node xmlPlace,\n                                                     PmdXmlReporter err) {\n        ref = compatibilityFilter.applyRef(ref, this.warnDeprecated);\n        if (ref == null) {\n            err.at(xmlPlace).warn(\"Rule reference references a deleted rule, ignoring\");\n            return null; // deleted rule\n        }\n        // only emit a warning if we check for deprecated syntax\n        MessageReporter subReporter = warnDeprecated ? err.at(xmlPlace) : MessageReporter.noop();\n\n        List<RuleSetReferenceId> references = RuleSetReferenceId.parse(ref, subReporter);\n        if (references.size() > 1 && warnDeprecated) {\n            err.at(xmlPlace).warn(\"Using a comma separated list as a ref attribute is deprecated. \"\n                                      + \"All references but the first are ignored.\");\n        } else if (references.isEmpty()) {\n            err.at(xmlPlace).warn(\"Empty ref attribute\");\n            return null;\n        }\n        return references.get(0);\n    }\n\n    /**\n     * Parse a rule node as a single Rule. The Rule has been fully defined\n     * within the context of the current RuleSet.\n     *\n     * @param ruleSetReferenceId The RuleSetReferenceId of the RuleSet being parsed.\n     * @param ruleSetBuilder     The RuleSet being constructed.\n     * @param ruleNode           Must be a rule element node.\n     * @param err                Error reporter\n     */\n    private void parseSingleRuleNode(RuleSetReferenceId ruleSetReferenceId,\n                                     RuleSetBuilder ruleSetBuilder,\n                                     Element ruleNode,\n                                     PmdXmlReporter err) {\n\n        // Stop if we're looking for a particular Rule, and this element is not\n        // it.\n        if (StringUtils.isNotBlank(ruleSetReferenceId.getRuleName())\n            && !isRuleName(ruleNode, ruleSetReferenceId.getRuleName())) {\n            return;\n        }\n        Rule rule = new RuleFactory(resourceLoader, languageRegistry).buildRule(ruleNode, err);\n        rule.setRuleSetName(ruleSetBuilder.getName());\n\n        if (warnDeprecated && StringUtils.isBlank(ruleNode.getAttribute(\"language\"))) {\n            err.at(ruleNode).warn(\n                \"Rule {0}/{1} does not mention attribute language='{2}',\"\n                    + \" please mention it explicitly to be compatible with PMD 7\",\n                ruleSetReferenceId.getRuleSetFileName(), rule.getName(),\n                rule.getLanguage().getTerseName());\n        }\n\n        ruleSetBuilder.addRule(rule);\n    }\n\n\n    /**\n     * Parse a rule node as a RuleReference. A RuleReference is a single Rule\n     * which comes from another RuleSet with some of it's attributes potentially\n     * overridden.\n     *\n     * @param ruleSetReferenceId           The RuleSetReferenceId of the RuleSet being parsed.\n     * @param ruleSetBuilder               The RuleSet being constructed.\n     * @param ruleNode                     Must be a rule element node.\n     * @param ref                          A reference to a Rule.\n     * @param withDeprecatedRuleReferences whether rule references that are deprecated should be ignored\n     * @param err                          Error reporter\n     */\n    private void parseRuleReferenceNode(RuleSetReferenceId ruleSetReferenceId,\n                                        RuleSetBuilder ruleSetBuilder,\n                                        Element ruleNode,\n                                        String ref,\n                                       RuleSetReferenceId otherRuleSetReferenceId,\n                                        boolean withDeprecatedRuleReferences,\n                                        PmdXmlReporter err) {\n\n        // Stop if we're looking for a particular Rule, and this element is not\n        // it.\n        if (StringUtils.isNotBlank(ruleSetReferenceId.getRuleName())\n            && !isRuleName(ruleNode, ruleSetReferenceId.getRuleName())) {\n            return;\n        }\n\n        // load the ruleset with minimum priority low, so that we get all rules, to be able to exclude any rule\n        // minimum priority will be applied again, before constructing the final ruleset\n        RuleSetFactory ruleSetFactory = toLoader().filterAbovePriority(RulePriority.LOW).warnDeprecated(false).toFactory();\n\n        boolean isSameRuleSet = false;\n        if (!otherRuleSetReferenceId.isExternal()\n            && containsRule(ruleSetReferenceId, otherRuleSetReferenceId.getRuleName())) {\n            otherRuleSetReferenceId = new RuleSetReferenceId(ref, ruleSetReferenceId, err.at(REF.getAttributeNode(ruleNode)));\n            isSameRuleSet = true;\n        } else if (otherRuleSetReferenceId.isExternal()\n            && otherRuleSetReferenceId.getRuleSetFileName().equals(ruleSetReferenceId.getRuleSetFileName())) {\n            otherRuleSetReferenceId = new RuleSetReferenceId(otherRuleSetReferenceId.getRuleName(), ruleSetReferenceId, err.at(REF.getAttributeNode(ruleNode)));\n            isSameRuleSet = true;\n        }\n        // do not ignore deprecated rule references\n        Rule referencedRule = ruleSetFactory.createRule(otherRuleSetReferenceId, true);\n\n        if (referencedRule == null) {\n            throw err.at(ruleNode).error(\n                \"Unable to find referenced rule {0}\"\n                    + \"; perhaps the rule name is misspelled?\",\n                otherRuleSetReferenceId.getRuleName());\n        }\n\n        if (warnDeprecated && referencedRule.isDeprecated()) {\n            if (referencedRule instanceof RuleReference) {\n                RuleReference ruleReference = (RuleReference) referencedRule;\n                err.at(ruleNode).warn(\n                    \"Use Rule name {0}/{1} instead of the deprecated Rule name {2}. PMD {3}\"\n                        + \" will remove support for this deprecated Rule name usage.\",\n                    ruleReference.getRuleSetReference().getRuleSetFileName(),\n                    ruleReference.getOriginalName(), otherRuleSetReferenceId,\n                    PMDVersion.getNextMajorRelease());\n            } else {\n                err.at(ruleNode).warn(\n                    \"Discontinue using Rule name {0} as it is scheduled for removal from PMD.\"\n                        + \" PMD {1} will remove support for this Rule.\",\n                    otherRuleSetReferenceId, PMDVersion.getNextMajorRelease());\n            }\n        }\n\n        RuleSetReference ruleSetReference = new RuleSetReference(otherRuleSetReferenceId.getRuleSetFileName(), false);\n\n        RuleReference ruleReference;\n        try {\n            ruleReference = new RuleFactory(resourceLoader, languageRegistry).decorateRule(referencedRule, ruleSetReference, ruleNode, err);\n        } catch (XmlException e) {\n            throw err.at(ruleNode).error(e, \"Error while parsing rule reference\");\n        }\n\n        if (warnDeprecated && ruleReference.isDeprecated() && !isSameRuleSet) {\n            err.at(ruleNode).warn(\n                \"Use Rule name {0}/{1} instead of the deprecated Rule name {2}/{3}. PMD {4}\"\n                    + \" will remove support for this deprecated Rule name usage.\",\n                ruleReference.getRuleSetReference().getRuleSetFileName(),\n                ruleReference.getOriginalName(),\n                ruleSetReferenceId.getRuleSetFileName(),\n                ruleReference.getName(),\n                PMDVersion.getNextMajorRelease());\n        }\n\n        if (withDeprecatedRuleReferences || !isSameRuleSet || !ruleReference.isDeprecated()) {\n            Rule existingRule = ruleSetBuilder.getExistingRule(ruleReference);\n            if (existingRule instanceof RuleReference) {\n                RuleReference existingRuleReference = (RuleReference) existingRule;\n                // the only valid use case is: the existing rule does not override anything yet\n                // which means, it is a plain reference. And the new reference overrides.\n                // for all other cases, we should log a warning\n                if (existingRuleReference.hasOverriddenAttributes() || !ruleReference.hasOverriddenAttributes()) {\n                    err.at(ruleNode).warn(\n                        \"The rule {0} is referenced multiple times in ruleset ''{1}''. \"\n                            + \"Only the last rule configuration is used.\",\n                        ruleReference.getName(),\n                        ruleSetBuilder.getName());\n                }\n            }\n\n            ruleSetBuilder.addRuleReplaceIfExists(ruleReference);\n        }\n    }\n\n\n    /**\n     * Check whether the given ruleName is contained in the given ruleset.\n     *\n     * @param ruleSetReferenceId the ruleset to check\n     * @param ruleName           the rule name to search for\n     *\n     * @return {@code true} if the ruleName exists\n     */\n    private boolean containsRule(RuleSetReferenceId ruleSetReferenceId, String ruleName) {\n        // TODO: avoid reloading the ruleset once again\n        boolean found = false;\n        try (InputStream ruleSet = ruleSetReferenceId.getInputStream(resourceLoader)) {\n            DocumentBuilder builder = createDocumentBuilder();\n            Document document = builder.parse(ruleSet);\n            Element ruleSetElement = document.getDocumentElement();\n\n            NodeList rules = ruleSetElement.getElementsByTagName(\"rule\");\n            for (int i = 0; i < rules.getLength(); i++) {\n                Element rule = (Element) rules.item(i);\n                if (rule.hasAttribute(\"name\") && rule.getAttribute(\"name\").equals(ruleName)) {\n                    found = true;\n                    break;\n                }\n            }\n        } catch (Exception e) {\n            throw new RuleSetLoadException(ruleSetReferenceId, e);\n        }\n\n        return found;\n    }\n\n    /**\n     * Determine if the specified rule element will represent a Rule with the\n     * given name.\n     *\n     * @param ruleElement The rule element.\n     * @param ruleName    The Rule name.\n     *\n     * @return {@code true} if the Rule would have the given name, {@code false} otherwise.\n     */\n    private boolean isRuleName(Element ruleElement, String ruleName) {\n        if (ruleElement.hasAttribute(\"name\")) {\n            return ruleElement.getAttribute(\"name\").equals(ruleName);\n        } else if (ruleElement.hasAttribute(\"ref\")) {\n            RuleSetReferenceId ruleSetReferenceId = RuleSetReferenceId.parse(ruleElement.getAttribute(\"ref\")).get(0);\n            return ruleSetReferenceId.getRuleName() != null && ruleSetReferenceId.getRuleName().equals(ruleName);\n        } else {\n            return false;\n        }\n    }\n\n\n    /**\n     * Create a new {@link RuleSetLoader} with the same config as this\n     * factory. This is a transitional API.\n     */\n    public RuleSetLoader toLoader() {\n        return new RuleSetLoader().loadResourcesWith(resourceLoader)\n                                  .filterAbovePriority(minimumPriority)\n                                  .warnDeprecated(warnDeprecated)\n                                  .enableCompatibility(compatibilityFilter != null)\n                                  .includeDeprecatedRuleReferences(includeDeprecatedRuleReferences);\n    }\n\n    private @NonNull XmlMessageHandler getXmlMessagePrinter() {\n        return entry -> {\n            Level level = entry.getSeverity() == XmlSeverity.WARNING ? Level.WARN : Level.ERROR;\n            String quotedText = StringUtil.quoteMessageFormat(entry.toString());\n            reporter.logEx(level, quotedText, new Object[0], entry.getCause());\n        };\n    }\n\n    private static final class PmdXmlReporterImpl\n        extends XmlMessageReporterBase<MessageReporter>\n        implements PmdXmlReporter {\n\n        private final MessageReporter pmdReporter;\n        private int errCount;\n\n        PmdXmlReporterImpl(MessageReporter pmdReporter, OoxmlFacade ooxml, XmlPositioner positioner) {\n            super(ooxml, positioner);\n            this.pmdReporter = pmdReporter;\n        }\n\n        @Override\n        protected MessageReporter create2ndStage(XmlPosition position, XmlPositioner positioner) {\n            return new MessageReporter() {\n                @Override\n                public boolean isLoggable(Level level) {\n                    return pmdReporter.isLoggable(level);\n                }\n\n\n                @Override\n                public void log(Level level, String message, Object... formatArgs) {\n                    logEx(level, message, formatArgs, null);\n                }\n\n                @Override\n                public void logEx(Level level, String message, Object[] formatArgs, @Nullable Throwable error) {\n                    newException(level, error, message, formatArgs);\n                }\n\n                @Override\n                public XmlException error(@Nullable Throwable cause, @Nullable String contextMessage, Object... formatArgs) {\n                    return newException(Level.ERROR, cause, contextMessage, formatArgs);\n                }\n\n                @Override\n                public XmlException newException(Level level, Throwable cause, String message, Object... formatArgs) {\n                    XmlSeverity severity;\n                    switch (level) {\n                    case WARN:\n                        severity = XmlSeverity.WARNING;\n                        break;\n                    case ERROR:\n                        errCount++;\n                        severity = XmlSeverity.ERROR;\n                        break;\n                    default:\n                        throw new IllegalArgumentException(\"unexpected level \" + level);\n                    }\n\n                    if (message == null && formatArgs.length != 0) {\n                        throw new IllegalArgumentException(\"Cannot pass format arguments for null message\");\n                    }\n\n                    String actualMessage = message == null ? cause.getMessage()\n                                                           : MessageFormat.format(message, formatArgs);\n                    NiceXmlMessageSpec spec =\n                        new NiceXmlMessageSpec(position, actualMessage)\n                            .withSeverity(severity)\n                            .withCause(cause);\n                    String fullMessage = ooxml.getFormatter().formatSpec(ooxml, spec, positioner);\n                    XmlException ex = new XmlException(spec, fullMessage);\n                    ooxml.getPrinter().accept(ex); // spec of newException is also to log.\n                    return ex;\n                }\n\n                @Override\n                public int numErrors() {\n                    return pmdReporter.numErrors();\n                }\n            };\n        }\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "this.includeDeprecatedRuleReferences = includeDeprecatedRuleReferences;\n\n        this.compatibilityFilter = compatFilter;\n        this.reporter = reporter;\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.util.log.MessageReporter#warn\n methodBody: default void warn(String message, Object... formatArgs) {\nlog(Level.WARN,message,formatArgs);\n}",
            "methodSignature: net.sourceforge.pmd.DummyParsingHelper#parse\n methodBody: public DummyRootNode parse(String code, String filename) {\nLanguageVersion version=DummyLanguageModule.getInstance().getDefaultVersion();\nParserTask task=new ParserTask(TextDocument.readOnlyString(code,filename,version),SemanticErrorReporter.noop(),LanguageProcessorRegistry.singleton(dummyProcessor));\nreturn (DummyRootNode)dummyProcessor.services().getParser().parse(task);\n}"
        ],
        "sourceCodeAfterRefactoring": "private RuleSetReferenceId parseReferenceAndWarn(String ref,\n                                                     Node xmlPlace,\n                                                     PmdXmlReporter err) {\n        ref = compatibilityFilter.applyRef(ref, this.warnDeprecated);\n        if (ref == null) {\n            err.at(xmlPlace).warn(\"Rule reference references a deleted rule, ignoring\");\n            return null; // deleted rule\n        }\n        // only emit a warning if we check for deprecated syntax\n        MessageReporter subReporter = warnDeprecated ? err.at(xmlPlace) : MessageReporter.noop();\n\n        List<RuleSetReferenceId> references = RuleSetReferenceId.parse(ref, subReporter);\n        if (references.size() > 1 && warnDeprecated) {\n            err.at(xmlPlace).warn(\"Using a comma separated list as a ref attribute is deprecated. \"\n                                      + \"All references but the first are ignored.\");\n        } else if (references.isEmpty()) {\n            err.at(xmlPlace).warn(\"Empty ref attribute\");\n            return null;\n        }\n        return references.get(0);\n    }\nthis.includeDeprecatedRuleReferences = includeDeprecatedRuleReferences;\n\n        this.compatibilityFilter = compatFilter;\n        this.reporter = reporter;\n    }",
        "diffSourceCode": "-  100:         this.warnDeprecated = warnDeprecated;\n-  101:         this.includeDeprecatedRuleReferences = includeDeprecatedRuleReferences;\n-  102: \n-  103:         this.compatibilityFilter = compatFilter;\n-  104:         this.reporter = reporter;\n-  105:     }\n+  100:         this.includeDeprecatedRuleReferences = includeDeprecatedRuleReferences;\n+  101: \n+  102:         this.compatibilityFilter = compatFilter;\n+  103:         this.reporter = reporter;\n+  104:     }\n+  105: \n   106: \n-  441: \n-  442:     private RuleSetReferenceId parseReferenceAndWarn(String ref,\n-  443:                                                      Node xmlPlace,\n-  444:                                                      PmdXmlReporter err) {\n-  445:         ref = compatibilityFilter.applyRef(ref, this.warnDeprecated);\n-  446:         if (ref == null) {\n-  447:             err.at(xmlPlace).warn(\"Rule reference references a deleted rule, ignoring\");\n-  448:             return null; // deleted rule\n-  449:         }\n-  450:         // only emit a warning if we check for deprecated syntax\n-  451:         MessageReporter subReporter = warnDeprecated ? err.at(xmlPlace) : new NoopReporter();\n-  452: \n-  453:         List<RuleSetReferenceId> references = RuleSetReferenceId.parse(ref, subReporter);\n-  454:         if (references.size() > 1 && warnDeprecated) {\n-  455:             err.at(xmlPlace).warn(\"Using a comma separated list as a ref attribute is deprecated. \"\n-  456:                                       + \"All references but the first are ignored.\");\n-  457:         } else if (references.isEmpty()) {\n-  458:             err.at(xmlPlace).warn(\"Empty ref attribute\");\n-  459:             return null;\n-  460:         }\n-  461:         return references.get(0);\n-  462:     }\n+  441:     private RuleSetReferenceId parseReferenceAndWarn(String ref,\n+  442:                                                      Node xmlPlace,\n+  443:                                                      PmdXmlReporter err) {\n+  444:         ref = compatibilityFilter.applyRef(ref, this.warnDeprecated);\n+  445:         if (ref == null) {\n+  446:             err.at(xmlPlace).warn(\"Rule reference references a deleted rule, ignoring\");\n+  447:             return null; // deleted rule\n+  448:         }\n+  449:         // only emit a warning if we check for deprecated syntax\n+  450:         MessageReporter subReporter = warnDeprecated ? err.at(xmlPlace) : MessageReporter.noop();\n+  451: \n+  452:         List<RuleSetReferenceId> references = RuleSetReferenceId.parse(ref, subReporter);\n+  453:         if (references.size() > 1 && warnDeprecated) {\n+  454:             err.at(xmlPlace).warn(\"Using a comma separated list as a ref attribute is deprecated. \"\n+  455:                                       + \"All references but the first are ignored.\");\n+  456:         } else if (references.isEmpty()) {\n+  457:             err.at(xmlPlace).warn(\"Empty ref attribute\");\n+  458:             return null;\n+  459:         }\n+  460:         return references.get(0);\n+  461:     }\n+  462: \n",
        "uniqueId": "214e80a5f1d68e3b42efeacab5b0fc226202ef05_442_462_100_106_441_461",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 22,
                "covered": 47
            },
            "BRANCH": {
                "missed": 4,
                "covered": 6
            },
            "LINE": {
                "missed": 3,
                "covered": 9
            },
            "COMPLEXITY": {
                "missed": 3,
                "covered": 3
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate findWrapperImpl(node Node) : AstElementNode extracted from public findWrapperFor(node Node) : AstElementNode in class net.sourceforge.pmd.lang.rule.xpath.internal.AstTreeInfo",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/internal/AstTreeInfo.java",
                "startLine": 39,
                "endLine": 61,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/internal/AstTreeInfo.java",
                "startLine": 48,
                "endLine": 50,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/internal/AstTreeInfo.java",
                "startLine": 52,
                "endLine": 74,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public AstElementNode findWrapperFor(Node node) {\n        // for the RootNode, this returns the document node\n        List<Integer> indices = node.ancestorsOrSelf().toList(Node::getIndexInParent);\n        AstElementNode cur = getRootNode().getRootElement();\n\n        // this is a quick but possibly expensive check\n        assert cur.getUnderlyingNode() == node.getRoot() : \"Node is not in this tree\";\n\n        // note we skip the first, who is the root\n        for (int i = indices.size() - 2; i >= 0; i--) {\n            Integer idx = indices.get(i);\n            if (idx >= cur.getChildren().size()) {\n                throw new IllegalArgumentException(\"Node is not part of this tree \" + node);\n            }\n\n            cur = cur.getChildren().get(idx);\n        }\n        if (cur.getUnderlyingNode() != node) {\n            // may happen with the root\n            throw new IllegalArgumentException(\"Node is not part of this tree \" + node);\n        }\n        return cur;\n    }",
        "filePathBefore": "pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/internal/AstTreeInfo.java",
        "isPureRefactoring": true,
        "commitId": "056516bee4f02af66f4f74aa637c29547f3b42b3",
        "packageNameBefore": "net.sourceforge.pmd.lang.rule.xpath.internal",
        "classNameBefore": "net.sourceforge.pmd.lang.rule.xpath.internal.AstTreeInfo",
        "methodNameBefore": "net.sourceforge.pmd.lang.rule.xpath.internal.AstTreeInfo#findWrapperFor",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.java.ast.ASTList#get\n methodBody: public N get(int i) {\nN n=toStream().get(i);\nif(n == null){throw new IndexOutOfBoundsException(\"Index \" + i + \" for length \" + size());\n}return n;\n}\nmethodSignature: net.sourceforge.pmd.lang.rule.xpath.internal.AstTreeInfo#getRootNode\n methodBody: public AstDocumentNode getRootNode() {\nreturn (AstDocumentNode)super.getRootNode();\n}\nmethodSignature: net.sourceforge.pmd.lang.ast.impl.AbstractNode#getIndexInParent\n methodBody: public int getIndexInParent() {\nreturn childIndex;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.ast.ASTList#size\n methodBody: public int size() {\nreturn toStream().count();\n}\nmethodSignature: net.sourceforge.pmd.RuleSet#size\n methodBody: public int size() {\nreturn rules.size();\n}\nmethodSignature: net.sourceforge.pmd.lang.java.ast.ASTList#toList\n methodBody: public List<N> toList() {\nreturn toStream().toList();\n}",
        "classSignatureBefore": "public final class AstTreeInfo extends GenericTreeInfo ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.rule.xpath.internal.AstTreeInfo#findWrapperFor"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.rule.xpath.internal.AstTreeInfo"
        ],
        "classSignatureBeforeSet": [
            "public final class AstTreeInfo extends GenericTreeInfo "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.rule.xpath.internal;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.MutableInt;\n\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.ast.RootNode;\n\nimport net.sf.saxon.Configuration;\nimport net.sf.saxon.om.GenericTreeInfo;\n\n\n/**\n * A wrapper around the root node of an AST, implementing {@link net.sf.saxon.om.TreeInfo}.\n */\npublic final class AstTreeInfo extends GenericTreeInfo {\n\n    private DeprecatedAttrLogger logger;\n\n    /**\n     * Builds an AstDocument, with the given node as the root.\n     *\n     * @param node          The root AST Node.\n     * @param configuration Configuration of the run\n     *\n     * @see AstElementNode\n     */\n    public AstTreeInfo(RootNode node, Configuration configuration) {\n        super(configuration);\n        MutableInt idGenerator = new MutableInt(1); // 0 is taken by the document node\n        setRootNode(new AstDocumentNode(this, idGenerator, node, configuration));\n    }\n\n    public AstElementNode findWrapperFor(Node node) {\n        // for the RootNode, this returns the document node\n        List<Integer> indices = node.ancestorsOrSelf().toList(Node::getIndexInParent);\n        AstElementNode cur = getRootNode().getRootElement();\n\n        // this is a quick but possibly expensive check\n        assert cur.getUnderlyingNode() == node.getRoot() : \"Node is not in this tree\";\n\n        // note we skip the first, who is the root\n        for (int i = indices.size() - 2; i >= 0; i--) {\n            Integer idx = indices.get(i);\n            if (idx >= cur.getChildren().size()) {\n                throw new IllegalArgumentException(\"Node is not part of this tree \" + node);\n            }\n\n            cur = cur.getChildren().get(idx);\n        }\n        if (cur.getUnderlyingNode() != node) {\n            // may happen with the root\n            throw new IllegalArgumentException(\"Node is not part of this tree \" + node);\n        }\n        return cur;\n    }\n\n    /**\n     * Returns the document node of the tree. Note that this has a single\n     * child of element type. Both the document and this element child have\n     * the {@link RootNode} as {@link AstElementNode#getUnderlyingNode()}.\n     */\n    @Override\n    public AstDocumentNode getRootNode() {\n        return (AstDocumentNode) super.getRootNode();\n    }\n\n\n    public void setAttrCtx(DeprecatedAttrLogger attrCtx) {\n        this.logger = attrCtx;\n    }\n\n    public DeprecatedAttrLogger getLogger() {\n        return logger == null ? DeprecatedAttrLogger.noop() : logger;\n    }\n}\n",
        "filePathAfter": "pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/xpath/internal/AstTreeInfo.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.rule.xpath.internal;\n\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport org.apache.commons.lang3.mutable.MutableInt;\n\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.ast.RootNode;\n\nimport net.sf.saxon.Configuration;\nimport net.sf.saxon.om.GenericTreeInfo;\n\n\n/**\n * A wrapper around the root node of an AST, implementing {@link net.sf.saxon.om.TreeInfo}.\n */\npublic final class AstTreeInfo extends GenericTreeInfo {\n\n    private DeprecatedAttrLogger logger;\n    private final Map<Node, AstElementNode> wrapperCache = new LinkedHashMap<Node, AstElementNode>() {\n        @Override\n        protected boolean removeEldestEntry(Entry eldest) {\n            return size() > 128;\n        }\n    };\n\n    /**\n     * Builds an AstDocument, with the given node as the root.\n     *\n     * @param node          The root AST Node.\n     * @param configuration Configuration of the run\n     *\n     * @see AstElementNode\n     */\n    public AstTreeInfo(RootNode node, Configuration configuration) {\n        super(configuration);\n        MutableInt idGenerator = new MutableInt(1); // 0 is taken by the document node\n        setRootNode(new AstDocumentNode(this, idGenerator, node, configuration));\n    }\n\n    public AstElementNode findWrapperFor(Node node) {\n        return wrapperCache.computeIfAbsent(node, this::findWrapperImpl);\n    }\n\n    private AstElementNode findWrapperImpl(Node node) {\n        // for the RootNode, this returns the document node\n        List<Integer> indices = node.ancestorsOrSelf().toList(Node::getIndexInParent);\n        AstElementNode cur = getRootNode().getRootElement();\n\n        // this is a quick but possibly expensive check\n        assert cur.getUnderlyingNode() == node.getRoot() : \"Node is not in this tree\";\n\n        // note we skip the first, who is the root\n        for (int i = indices.size() - 2; i >= 0; i--) {\n            Integer idx = indices.get(i);\n            if (idx >= cur.getChildren().size()) {\n                throw new IllegalArgumentException(\"Node is not part of this tree \" + node);\n            }\n\n            cur = cur.getChildren().get(idx);\n        }\n        if (cur.getUnderlyingNode() != node) {\n            // may happen with the root\n            throw new IllegalArgumentException(\"Node is not part of this tree \" + node);\n        }\n        return cur;\n    }\n\n    /**\n     * Returns the document node of the tree. Note that this has a single\n     * child of element type. Both the document and this element child have\n     * the {@link RootNode} as {@link AstElementNode#getUnderlyingNode()}.\n     */\n    @Override\n    public AstDocumentNode getRootNode() {\n        return (AstDocumentNode) super.getRootNode();\n    }\n\n\n    public void setAttrCtx(DeprecatedAttrLogger attrCtx) {\n        this.logger = attrCtx;\n    }\n\n    public DeprecatedAttrLogger getLogger() {\n        return logger == null ? DeprecatedAttrLogger.noop() : logger;\n    }\n}\n",
        "diffSourceCodeSet": [
            "private AstElementNode findWrapperImpl(Node node) {\n        // for the RootNode, this returns the document node\n        List<Integer> indices = node.ancestorsOrSelf().toList(Node::getIndexInParent);\n        AstElementNode cur = getRootNode().getRootElement();\n\n        // this is a quick but possibly expensive check\n        assert cur.getUnderlyingNode() == node.getRoot() : \"Node is not in this tree\";\n\n        // note we skip the first, who is the root\n        for (int i = indices.size() - 2; i >= 0; i--) {\n            Integer idx = indices.get(i);\n            if (idx >= cur.getChildren().size()) {\n                throw new IllegalArgumentException(\"Node is not part of this tree \" + node);\n            }\n\n            cur = cur.getChildren().get(idx);\n        }\n        if (cur.getUnderlyingNode() != node) {\n            // may happen with the root\n            throw new IllegalArgumentException(\"Node is not part of this tree \" + node);\n        }\n        return cur;\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.java.ast.ASTList#get\n methodBody: public N get(int i) {\nN n=toStream().get(i);\nif(n == null){throw new IndexOutOfBoundsException(\"Index \" + i + \" for length \" + size());\n}return n;\n}",
            "methodSignature: net.sourceforge.pmd.lang.rule.xpath.internal.AstTreeInfo#getRootNode\n methodBody: public AstDocumentNode getRootNode() {\nreturn (AstDocumentNode)super.getRootNode();\n}",
            "methodSignature: net.sourceforge.pmd.lang.ast.impl.AbstractNode#getIndexInParent\n methodBody: public int getIndexInParent() {\nreturn childIndex;\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.ast.ASTList#size\n methodBody: public int size() {\nreturn toStream().count();\n}",
            "methodSignature: net.sourceforge.pmd.RuleSet#size\n methodBody: public int size() {\nreturn rules.size();\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.ast.ASTList#toList\n methodBody: public List<N> toList() {\nreturn toStream().toList();\n}"
        ],
        "sourceCodeAfterRefactoring": "public AstElementNode findWrapperFor(Node node) {\n        return wrapperCache.computeIfAbsent(node, this::findWrapperImpl);\n    }\nprivate AstElementNode findWrapperImpl(Node node) {\n        // for the RootNode, this returns the document node\n        List<Integer> indices = node.ancestorsOrSelf().toList(Node::getIndexInParent);\n        AstElementNode cur = getRootNode().getRootElement();\n\n        // this is a quick but possibly expensive check\n        assert cur.getUnderlyingNode() == node.getRoot() : \"Node is not in this tree\";\n\n        // note we skip the first, who is the root\n        for (int i = indices.size() - 2; i >= 0; i--) {\n            Integer idx = indices.get(i);\n            if (idx >= cur.getChildren().size()) {\n                throw new IllegalArgumentException(\"Node is not part of this tree \" + node);\n            }\n\n            cur = cur.getChildren().get(idx);\n        }\n        if (cur.getUnderlyingNode() != node) {\n            // may happen with the root\n            throw new IllegalArgumentException(\"Node is not part of this tree \" + node);\n        }\n        return cur;\n    }",
        "diffSourceCode": "-   39:     public AstElementNode findWrapperFor(Node node) {\n-   40:         // for the RootNode, this returns the document node\n-   41:         List<Integer> indices = node.ancestorsOrSelf().toList(Node::getIndexInParent);\n-   42:         AstElementNode cur = getRootNode().getRootElement();\n-   43: \n-   44:         // this is a quick but possibly expensive check\n-   45:         assert cur.getUnderlyingNode() == node.getRoot() : \"Node is not in this tree\";\n-   46: \n-   47:         // note we skip the first, who is the root\n-   48:         for (int i = indices.size() - 2; i >= 0; i--) {\n-   49:             Integer idx = indices.get(i);\n-   50:             if (idx >= cur.getChildren().size()) {\n-   51:                 throw new IllegalArgumentException(\"Node is not part of this tree \" + node);\n-   52:             }\n-   53: \n-   54:             cur = cur.getChildren().get(idx);\n-   55:         }\n-   56:         if (cur.getUnderlyingNode() != node) {\n-   57:             // may happen with the root\n-   58:             throw new IllegalArgumentException(\"Node is not part of this tree \" + node);\n-   59:         }\n-   60:         return cur;\n-   61:     }\n-   62: \n-   63:     /**\n-   64:      * Returns the document node of the tree. Note that this has a single\n-   65:      * child of element type. Both the document and this element child have\n-   66:      * the {@link RootNode} as {@link AstElementNode#getUnderlyingNode()}.\n-   67:      */\n-   68:     @Override\n-   69:     public AstDocumentNode getRootNode() {\n-   70:         return (AstDocumentNode) super.getRootNode();\n-   71:     }\n-   72: \n-   73: \n-   74:     public void setAttrCtx(DeprecatedAttrLogger attrCtx) {\n+   39:      *\n+   40:      * @see AstElementNode\n+   41:      */\n+   42:     public AstTreeInfo(RootNode node, Configuration configuration) {\n+   43:         super(configuration);\n+   44:         MutableInt idGenerator = new MutableInt(1); // 0 is taken by the document node\n+   45:         setRootNode(new AstDocumentNode(this, idGenerator, node, configuration));\n+   46:     }\n+   47: \n+   48:     public AstElementNode findWrapperFor(Node node) {\n+   49:         return wrapperCache.computeIfAbsent(node, this::findWrapperImpl);\n+   50:     }\n+   51: \n+   52:     private AstElementNode findWrapperImpl(Node node) {\n+   53:         // for the RootNode, this returns the document node\n+   54:         List<Integer> indices = node.ancestorsOrSelf().toList(Node::getIndexInParent);\n+   55:         AstElementNode cur = getRootNode().getRootElement();\n+   56: \n+   57:         // this is a quick but possibly expensive check\n+   58:         assert cur.getUnderlyingNode() == node.getRoot() : \"Node is not in this tree\";\n+   59: \n+   60:         // note we skip the first, who is the root\n+   61:         for (int i = indices.size() - 2; i >= 0; i--) {\n+   62:             Integer idx = indices.get(i);\n+   63:             if (idx >= cur.getChildren().size()) {\n+   64:                 throw new IllegalArgumentException(\"Node is not part of this tree \" + node);\n+   65:             }\n+   66: \n+   67:             cur = cur.getChildren().get(idx);\n+   68:         }\n+   69:         if (cur.getUnderlyingNode() != node) {\n+   70:             // may happen with the root\n+   71:             throw new IllegalArgumentException(\"Node is not part of this tree \" + node);\n+   72:         }\n+   73:         return cur;\n+   74:     }\n",
        "uniqueId": "056516bee4f02af66f4f74aa637c29547f3b42b3_39_61_52_74_48_50",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 29,
                "covered": 49
            },
            "BRANCH": {
                "missed": 4,
                "covered": 6
            },
            "LINE": {
                "missed": 2,
                "covered": 9
            },
            "COMPLEXITY": {
                "missed": 4,
                "covered": 2
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17
    },
    {
        "type": "Move Method",
        "description": "Move Method\tpublic versionWithParserThatReportsSemanticError() : LanguageVersion from class net.sourceforge.pmd.processor.PmdRunnableTest to public versionWithParserThatReportsSemanticError() : LanguageVersion from class net.sourceforge.pmd.lang.DummyLanguageModule",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/processor/PmdRunnableTest.java",
                "startLine": 170,
                "endLine": 172,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/lang/DummyLanguageModule.java",
                "startLine": 65,
                "endLine": 67,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public static LanguageVersion versionWithParserThatReportsSemanticError() {\n        return DummyLanguageModule.getInstance().getVersion(PARSER_REPORTS_SEMANTIC_ERROR);\n    }",
        "filePathBefore": "pmd-core/src/test/java/net/sourceforge/pmd/processor/PmdRunnableTest.java",
        "isPureRefactoring": true,
        "commitId": "d5b3478c8a5d06ab221c2a8d31d976a508beb0a8",
        "packageNameBefore": "net.sourceforge.pmd.processor",
        "classNameBefore": "net.sourceforge.pmd.processor.PmdRunnableTest",
        "methodNameBefore": "net.sourceforge.pmd.processor.PmdRunnableTest#versionWithParserThatReportsSemanticError",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.DummyLanguageModule#getInstance\n methodBody: public static DummyLanguageModule getInstance() {\nreturn (DummyLanguageModule)Objects.requireNonNull(LanguageRegistry.PMD.getLanguageByFullName(NAME));\n}",
        "classSignatureBefore": "public class PmdRunnableTest ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.processor.PmdRunnableTest#versionWithParserThatReportsSemanticError"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.processor.PmdRunnableTest"
        ],
        "classSignatureBeforeSet": [
            "public class PmdRunnableTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.processor;\n\nimport static org.hamcrest.CoreMatchers.instanceOf;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.hasSize;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.Mockito.contains;\nimport static org.mockito.Mockito.eq;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.spy;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\n\nimport java.util.List;\nimport java.util.function.BiConsumer;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\nimport org.slf4j.event.Level;\n\nimport net.sourceforge.pmd.PMDConfiguration;\nimport net.sourceforge.pmd.Report;\nimport net.sourceforge.pmd.Report.GlobalReportBuilderListener;\nimport net.sourceforge.pmd.Report.ProcessingError;\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RuleContext;\nimport net.sourceforge.pmd.RuleSet;\nimport net.sourceforge.pmd.RuleSets;\nimport net.sourceforge.pmd.internal.SystemProps;\nimport net.sourceforge.pmd.internal.util.ContextedAssertionError;\nimport net.sourceforge.pmd.lang.DummyLanguageModule;\nimport net.sourceforge.pmd.lang.DummyLanguageModule.Handler;\nimport net.sourceforge.pmd.lang.Language;\nimport net.sourceforge.pmd.lang.LanguageVersion;\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.ast.Parser;\nimport net.sourceforge.pmd.lang.ast.RootNode;\nimport net.sourceforge.pmd.lang.document.TextFile;\nimport net.sourceforge.pmd.lang.rule.AbstractRule;\nimport net.sourceforge.pmd.processor.MonoThreadProcessor.MonothreadRunnable;\nimport net.sourceforge.pmd.util.log.MessageReporter;\n\nimport com.github.stefanbirkner.systemlambda.SystemLambda;\n\npublic class PmdRunnableTest {\n\n    public static final String TEST_MESSAGE_SEMANTIC_ERROR = \"An error occurred!\";\n    private static final String PARSER_REPORTS_SEMANTIC_ERROR = \"1.9-semantic_error\";\n    private static final String THROWS_SEMANTIC_ERROR = \"1.9-throws_semantic_error\";\n    private static final String THROWS_ASSERTION_ERROR = \"1.9-throws\";\n\n    private PMDConfiguration configuration;\n    private PmdRunnable pmdRunnable;\n    private MessageReporter reporter;\n    private Rule rule;\n\n\n    @BeforeEach\n    public void prepare() {\n        // reset data\n        rule = spy(new RuleThatThrows());\n        configuration = new PMDConfiguration();\n        reporter = mock(MessageReporter.class);\n        configuration.setReporter(reporter);\n\n        // will be populated by a call to process(LanguageVersion)\n        pmdRunnable = null;\n    }\n\n\n    private Report process(LanguageVersion lv) {\n        TextFile dataSource = TextFile.forCharSeq(\"test\", \"test.dummy\", lv);\n\n        GlobalReportBuilderListener reportBuilder = new GlobalReportBuilderListener();\n\n        pmdRunnable = new MonothreadRunnable(new RuleSets(RuleSet.forSingleRule(rule)),\n                                             dataSource,\n                                             reportBuilder,\n                                             configuration);\n\n        pmdRunnable.run();\n        reportBuilder.close();\n        return reportBuilder.getResult();\n    }\n\n    @Test\n    public void inErrorRecoveryModeErrorsShouldBeLoggedByParser() throws Exception {\n        SystemLambda.restoreSystemProperties(() -> {\n            System.setProperty(SystemProps.PMD_ERROR_RECOVERY, \"\");\n\n            Report report = process(versionWithParserThatThrowsAssertionError());\n\n            assertEquals(1, report.getProcessingErrors().size());\n        });\n    }\n\n    @Test\n    public void inErrorRecoveryModeErrorsShouldBeLoggedByRule() throws Exception {\n        SystemLambda.restoreSystemProperties(() -> {\n            System.setProperty(SystemProps.PMD_ERROR_RECOVERY, \"\");\n\n            Report report = process(DummyLanguageModule.getInstance().getDefaultVersion());\n\n            List<ProcessingError> errors = report.getProcessingErrors();\n            assertThat(errors, hasSize(1));\n            assertThat(errors.get(0).getError(), instanceOf(ContextedAssertionError.class));\n        });\n\n    }\n\n    @Test\n    public void withoutErrorRecoveryModeProcessingShouldBeAbortedByParser() throws Exception {\n        SystemLambda.restoreSystemProperties(() -> {\n            System.clearProperty(SystemProps.PMD_ERROR_RECOVERY);\n            assertThrows(AssertionError.class, () -> process(versionWithParserThatThrowsAssertionError()));\n        });\n    }\n\n    @Test\n    public void withoutErrorRecoveryModeProcessingShouldBeAbortedByRule() throws Exception {\n        SystemLambda.restoreSystemProperties(() -> {\n            System.clearProperty(SystemProps.PMD_ERROR_RECOVERY);\n            assertThrows(AssertionError.class, () -> process(DummyLanguageModule.getInstance().getDefaultVersion()));\n        });\n    }\n\n\n    @Test\n    public void semanticErrorShouldAbortTheRun() {\n        Report report = process(versionWithParserThatReportsSemanticError());\n\n        verify(reporter, times(1))\n            .log(eq(Level.ERROR), eq(\"at !debug only! test.dummy:1:1: \" + TEST_MESSAGE_SEMANTIC_ERROR));\n        verify(rule, never()).apply(Mockito.any(), Mockito.any());\n\n        assertEquals(1, report.getProcessingErrors().size());\n    }\n\n    @Test\n    public void semanticErrorThrownShouldAbortTheRun() {\n        Report report = process(getVersionWithParserThatThrowsSemanticError());\n\n        verify(reporter, times(1)).log(eq(Level.ERROR), contains(TEST_MESSAGE_SEMANTIC_ERROR));\n        verify(rule, never()).apply(Mockito.any(), Mockito.any());\n\n        assertEquals(1, report.getProcessingErrors().size());\n    }\n\n    public static void registerCustomVersions(BiConsumer<String, Handler> addVersion) {\n        addVersion.accept(THROWS_ASSERTION_ERROR, new HandlerWithParserThatThrows());\n        addVersion.accept(PARSER_REPORTS_SEMANTIC_ERROR, new HandlerWithParserThatReportsSemanticError());\n        addVersion.accept(THROWS_SEMANTIC_ERROR, new HandlerWithParserThatThrowsSemanticError());\n    }\n\n    public static LanguageVersion versionWithParserThatThrowsAssertionError() {\n        return DummyLanguageModule.getInstance().getVersion(THROWS_ASSERTION_ERROR);\n    }\n\n    public static LanguageVersion getVersionWithParserThatThrowsSemanticError() {\n        return DummyLanguageModule.getInstance().getVersion(THROWS_SEMANTIC_ERROR);\n    }\n\n    public static LanguageVersion versionWithParserThatReportsSemanticError() {\n        return DummyLanguageModule.getInstance().getVersion(PARSER_REPORTS_SEMANTIC_ERROR);\n    }\n\n    private static class RuleThatThrows extends AbstractRule {\n\n        RuleThatThrows() {\n            Language dummyLanguage = DummyLanguageModule.getInstance();\n            setLanguage(dummyLanguage);\n        }\n\n        @Override\n        public void apply(Node target, RuleContext ctx) {\n            throw new AssertionError(\"test\");\n        }\n    }\n\n    public static class HandlerWithParserThatThrowsSemanticError extends Handler {\n\n        @Override\n        public Parser getParser() {\n            return task -> {\n                RootNode root = super.getParser().parse(task);\n                throw task.getReporter().error(root, TEST_MESSAGE_SEMANTIC_ERROR);\n            };\n        }\n    }\n\n    public static class HandlerWithParserThatThrows extends Handler {\n\n        @Override\n        public Parser getParser() {\n            return task -> {\n                throw new AssertionError(\"test error while parsing\");\n            };\n        }\n    }\n\n    public static class HandlerWithParserThatReportsSemanticError extends Handler {\n\n        @Override\n        public Parser getParser() {\n            return task -> {\n                RootNode root = super.getParser().parse(task);\n                task.getReporter().error(root, TEST_MESSAGE_SEMANTIC_ERROR);\n                return root;\n            };\n        }\n    }\n}\n",
        "filePathAfter": "pmd-core/src/test/java/net/sourceforge/pmd/lang/DummyLanguageModule.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang;\n\nimport java.util.Objects;\n\nimport net.sourceforge.pmd.RuleViolation;\nimport net.sourceforge.pmd.lang.ast.DummyNode;\nimport net.sourceforge.pmd.lang.ast.DummyNode.DummyRootNode;\nimport net.sourceforge.pmd.lang.ast.ParseException;\nimport net.sourceforge.pmd.lang.ast.Parser;\nimport net.sourceforge.pmd.lang.ast.Parser.ParserTask;\nimport net.sourceforge.pmd.lang.ast.RootNode;\nimport net.sourceforge.pmd.lang.ast.SemanticErrorReporter;\nimport net.sourceforge.pmd.lang.document.Chars;\nimport net.sourceforge.pmd.lang.document.TextDocument;\nimport net.sourceforge.pmd.lang.document.TextFile;\nimport net.sourceforge.pmd.lang.document.TextRegion;\nimport net.sourceforge.pmd.reporting.ViolationDecorator;\n\n/**\n * Dummy language used for testing PMD.\n */\npublic class DummyLanguageModule extends BaseLanguageModule {\n\n    public static final String NAME = \"Dummy\";\n    public static final String TERSE_NAME = \"dummy\";\n\n    public static final String TEST_MESSAGE_SEMANTIC_ERROR = \"An error occurred!\";\n    private static final String PARSER_REPORTS_SEMANTIC_ERROR = \"1.9-semantic_error\";\n    private static final String THROWS_SEMANTIC_ERROR = \"1.9-throws_semantic_error\";\n    private static final String THROWS_ASSERTION_ERROR = \"1.9-throws\";\n\n    public DummyLanguageModule() {\n        super(NAME, null, TERSE_NAME, \"dummy\");\n        addVersion(\"1.0\", new Handler());\n        addVersion(\"1.1\", new Handler());\n        addVersion(\"1.2\", new Handler());\n        addVersion(\"1.3\", new Handler());\n        addVersion(\"1.4\", new Handler());\n        addVersion(\"1.5\", new Handler(), \"5\");\n        addVersion(\"1.6\", new Handler(), \"6\");\n        addDefaultVersion(\"1.7\", new Handler(), \"7\");\n        addVersion(\"1.8\", new Handler(), \"8\");\n\n        addVersion(THROWS_ASSERTION_ERROR, new HandlerWithParserThatThrows());\n        addVersion(PARSER_REPORTS_SEMANTIC_ERROR, new HandlerWithParserThatReportsSemanticError());\n        addVersion(THROWS_SEMANTIC_ERROR, new HandlerWithParserThatThrowsSemanticError());\n    }\n\n    public static DummyLanguageModule getInstance() {\n        return (DummyLanguageModule) Objects.requireNonNull(LanguageRegistry.PMD.getLanguageByFullName(NAME));\n    }\n\n    public static LanguageVersion versionWithParserThatThrowsAssertionError() {\n        return DummyLanguageModule.getInstance().getVersion(THROWS_ASSERTION_ERROR);\n    }\n\n    public static LanguageVersion getVersionWithParserThatThrowsSemanticError() {\n        return DummyLanguageModule.getInstance().getVersion(THROWS_SEMANTIC_ERROR);\n    }\n\n    public static LanguageVersion versionWithParserThatReportsSemanticError() {\n        return DummyLanguageModule.getInstance().getVersion(PARSER_REPORTS_SEMANTIC_ERROR);\n    }\n\n    public static DummyRootNode parse(String code) {\n        return parse(code, TextFile.UNKNOWN_FILENAME);\n    }\n\n    public static DummyRootNode parse(String code, String filename) {\n        LanguageVersion version = DummyLanguageModule.getInstance().getDefaultVersion();\n        ParserTask task = new ParserTask(\n            TextDocument.readOnlyString(code, filename, version),\n            SemanticErrorReporter.noop()\n        );\n        return (DummyRootNode) version.getLanguageVersionHandler().getParser().parse(task);\n    }\n\n    public static class Handler extends AbstractPmdLanguageVersionHandler {\n\n        @Override\n        public Parser getParser() {\n            return DummyLanguageModule::readLispNode;\n        }\n\n        @Override\n        public ViolationDecorator getViolationDecorator() {\n            return (node, data) -> data.put(RuleViolation.PACKAGE_NAME, \"foo\");\n        }\n    }\n\n    /**\n     * Creates a tree of nodes that corresponds to the nesting structures\n     * of parentheses in the text. The image of each node is also populated.\n     * This is useful to create non-trivial trees with all the relevant\n     * data (eg coordinates) set properly.\n     *\n     * Eg {@code (a(b)x(c))} will create a tree with a node \"a\", with two\n     * children \"b\" and \"c\". \"x\" is ignored. The node \"a\" is not the root\n     * node, it has a {@link DummyRootNode} as parent, whose image is \"\".\n     */\n    private static DummyRootNode readLispNode(ParserTask task) {\n        TextDocument document = task.getTextDocument();\n        final DummyRootNode root = new DummyRootNode().withTaskInfo(task);\n        root.setRegion(document.getEntireRegion());\n\n        DummyNode top = root;\n        int lastNodeStart = 0;\n        Chars text = document.getText();\n        for (int i = 0; i < text.length(); i++) {\n            char c = text.charAt(i);\n            if (c == '(') {\n                DummyNode node = new DummyNode();\n                node.setParent(top);\n                top.addChild(node, top.getNumChildren());\n                // setup coordinates, temporary (will be completed when node closes)\n                node.setRegion(TextRegion.caretAt(i));\n\n                // cut out image\n                if (top.getImage() == null) {\n                    // image may be non null if this is not the first child of 'top'\n                    // eg in (a(b)x(c)), the image of the parent is set to \"a\".\n                    // When we're processing \"(c\", we ignore \"x\".\n                    String image = text.substring(lastNodeStart, i);\n                    top.setImage(image);\n                }\n                lastNodeStart = i + 1;\n                // node is the top of the stack now\n                top = node;\n            } else if (c == ')') {\n                if (top == null) {\n                    throw new ParseException(\"Unbalanced parentheses: \" + text);\n                }\n\n                top.setRegion(TextRegion.fromBothOffsets(top.getTextRegion().getStartOffset(), i));\n\n                if (top.getImage() == null) {\n                    // cut out image (if node doesn't have children it hasn't been populated yet)\n                    String image = text.substring(lastNodeStart, i);\n                    top.setImage(image);\n                    lastNodeStart = i + 1;\n                }\n                top = top.getParent();\n            }\n        }\n        if (top != root) {\n            throw new ParseException(\"Unbalanced parentheses: \" + text);\n        }\n        return root;\n    }\n\n    private static class HandlerWithParserThatThrowsSemanticError extends Handler {\n\n        @Override\n        public Parser getParser() {\n            return task -> {\n                RootNode root = super.getParser().parse(task);\n                throw task.getReporter().error(root, TEST_MESSAGE_SEMANTIC_ERROR);\n            };\n        }\n    }\n\n    private static class HandlerWithParserThatThrows extends Handler {\n\n        @Override\n        public Parser getParser() {\n            return task -> {\n                throw new AssertionError(\"test error while parsing\");\n            };\n        }\n    }\n\n    private static class HandlerWithParserThatReportsSemanticError extends Handler {\n\n        @Override\n        public Parser getParser() {\n            return task -> {\n                RootNode root = super.getParser().parse(task);\n                task.getReporter().error(root, TEST_MESSAGE_SEMANTIC_ERROR);\n                return root;\n            };\n        }\n    }\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.DummyLanguageModule#getInstance\n methodBody: public static DummyLanguageModule getInstance() {\nreturn (DummyLanguageModule)Objects.requireNonNull(LanguageRegistry.PMD.getLanguageByFullName(NAME));\n}"
        ],
        "sourceCodeAfterRefactoring": "public static LanguageVersion versionWithParserThatReportsSemanticError() {\n        return DummyLanguageModule.getInstance().getVersion(PARSER_REPORTS_SEMANTIC_ERROR);\n    }",
        "diffSourceCode": "-   65:     @BeforeEach\n-   66:     public void prepare() {\n-   67:         // reset data\n-  170:     public static LanguageVersion versionWithParserThatReportsSemanticError() {\n-  171:         return DummyLanguageModule.getInstance().getVersion(PARSER_REPORTS_SEMANTIC_ERROR);\n-  172:     }\n+   65:     public static LanguageVersion versionWithParserThatReportsSemanticError() {\n+   66:         return DummyLanguageModule.getInstance().getVersion(PARSER_REPORTS_SEMANTIC_ERROR);\n+   67:     }\n+  170:             return task -> {\n+  171:                 throw new AssertionError(\"test error while parsing\");\n+  172:             };\n",
        "uniqueId": "d5b3478c8a5d06ab221c2a8d31d976a508beb0a8_170_172__65_67",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17
    },
    {
        "type": "Move Method",
        "description": "Move Method\tpublic getVersionWithParserThatThrowsSemanticError() : LanguageVersion from class net.sourceforge.pmd.processor.PmdRunnableTest to public getVersionWithParserThatThrowsSemanticError() : LanguageVersion from class net.sourceforge.pmd.lang.DummyLanguageModule",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/processor/PmdRunnableTest.java",
                "startLine": 166,
                "endLine": 168,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/lang/DummyLanguageModule.java",
                "startLine": 61,
                "endLine": 63,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public static LanguageVersion getVersionWithParserThatThrowsSemanticError() {\n        return DummyLanguageModule.getInstance().getVersion(THROWS_SEMANTIC_ERROR);\n    }",
        "filePathBefore": "pmd-core/src/test/java/net/sourceforge/pmd/processor/PmdRunnableTest.java",
        "isPureRefactoring": true,
        "commitId": "d5b3478c8a5d06ab221c2a8d31d976a508beb0a8",
        "packageNameBefore": "net.sourceforge.pmd.processor",
        "classNameBefore": "net.sourceforge.pmd.processor.PmdRunnableTest",
        "methodNameBefore": "net.sourceforge.pmd.processor.PmdRunnableTest#getVersionWithParserThatThrowsSemanticError",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.DummyLanguageModule#getInstance\n methodBody: public static DummyLanguageModule getInstance() {\nreturn (DummyLanguageModule)Objects.requireNonNull(LanguageRegistry.PMD.getLanguageByFullName(NAME));\n}",
        "classSignatureBefore": "public class PmdRunnableTest ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.processor.PmdRunnableTest#getVersionWithParserThatThrowsSemanticError"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.processor.PmdRunnableTest"
        ],
        "classSignatureBeforeSet": [
            "public class PmdRunnableTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.processor;\n\nimport static org.hamcrest.CoreMatchers.instanceOf;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.hasSize;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.Mockito.contains;\nimport static org.mockito.Mockito.eq;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.spy;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\n\nimport java.util.List;\nimport java.util.function.BiConsumer;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\nimport org.slf4j.event.Level;\n\nimport net.sourceforge.pmd.PMDConfiguration;\nimport net.sourceforge.pmd.Report;\nimport net.sourceforge.pmd.Report.GlobalReportBuilderListener;\nimport net.sourceforge.pmd.Report.ProcessingError;\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RuleContext;\nimport net.sourceforge.pmd.RuleSet;\nimport net.sourceforge.pmd.RuleSets;\nimport net.sourceforge.pmd.internal.SystemProps;\nimport net.sourceforge.pmd.internal.util.ContextedAssertionError;\nimport net.sourceforge.pmd.lang.DummyLanguageModule;\nimport net.sourceforge.pmd.lang.DummyLanguageModule.Handler;\nimport net.sourceforge.pmd.lang.Language;\nimport net.sourceforge.pmd.lang.LanguageVersion;\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.ast.Parser;\nimport net.sourceforge.pmd.lang.ast.RootNode;\nimport net.sourceforge.pmd.lang.document.TextFile;\nimport net.sourceforge.pmd.lang.rule.AbstractRule;\nimport net.sourceforge.pmd.processor.MonoThreadProcessor.MonothreadRunnable;\nimport net.sourceforge.pmd.util.log.MessageReporter;\n\nimport com.github.stefanbirkner.systemlambda.SystemLambda;\n\npublic class PmdRunnableTest {\n\n    public static final String TEST_MESSAGE_SEMANTIC_ERROR = \"An error occurred!\";\n    private static final String PARSER_REPORTS_SEMANTIC_ERROR = \"1.9-semantic_error\";\n    private static final String THROWS_SEMANTIC_ERROR = \"1.9-throws_semantic_error\";\n    private static final String THROWS_ASSERTION_ERROR = \"1.9-throws\";\n\n    private PMDConfiguration configuration;\n    private PmdRunnable pmdRunnable;\n    private MessageReporter reporter;\n    private Rule rule;\n\n\n    @BeforeEach\n    public void prepare() {\n        // reset data\n        rule = spy(new RuleThatThrows());\n        configuration = new PMDConfiguration();\n        reporter = mock(MessageReporter.class);\n        configuration.setReporter(reporter);\n\n        // will be populated by a call to process(LanguageVersion)\n        pmdRunnable = null;\n    }\n\n\n    private Report process(LanguageVersion lv) {\n        TextFile dataSource = TextFile.forCharSeq(\"test\", \"test.dummy\", lv);\n\n        GlobalReportBuilderListener reportBuilder = new GlobalReportBuilderListener();\n\n        pmdRunnable = new MonothreadRunnable(new RuleSets(RuleSet.forSingleRule(rule)),\n                                             dataSource,\n                                             reportBuilder,\n                                             configuration);\n\n        pmdRunnable.run();\n        reportBuilder.close();\n        return reportBuilder.getResult();\n    }\n\n    @Test\n    public void inErrorRecoveryModeErrorsShouldBeLoggedByParser() throws Exception {\n        SystemLambda.restoreSystemProperties(() -> {\n            System.setProperty(SystemProps.PMD_ERROR_RECOVERY, \"\");\n\n            Report report = process(versionWithParserThatThrowsAssertionError());\n\n            assertEquals(1, report.getProcessingErrors().size());\n        });\n    }\n\n    @Test\n    public void inErrorRecoveryModeErrorsShouldBeLoggedByRule() throws Exception {\n        SystemLambda.restoreSystemProperties(() -> {\n            System.setProperty(SystemProps.PMD_ERROR_RECOVERY, \"\");\n\n            Report report = process(DummyLanguageModule.getInstance().getDefaultVersion());\n\n            List<ProcessingError> errors = report.getProcessingErrors();\n            assertThat(errors, hasSize(1));\n            assertThat(errors.get(0).getError(), instanceOf(ContextedAssertionError.class));\n        });\n\n    }\n\n    @Test\n    public void withoutErrorRecoveryModeProcessingShouldBeAbortedByParser() throws Exception {\n        SystemLambda.restoreSystemProperties(() -> {\n            System.clearProperty(SystemProps.PMD_ERROR_RECOVERY);\n            assertThrows(AssertionError.class, () -> process(versionWithParserThatThrowsAssertionError()));\n        });\n    }\n\n    @Test\n    public void withoutErrorRecoveryModeProcessingShouldBeAbortedByRule() throws Exception {\n        SystemLambda.restoreSystemProperties(() -> {\n            System.clearProperty(SystemProps.PMD_ERROR_RECOVERY);\n            assertThrows(AssertionError.class, () -> process(DummyLanguageModule.getInstance().getDefaultVersion()));\n        });\n    }\n\n\n    @Test\n    public void semanticErrorShouldAbortTheRun() {\n        Report report = process(versionWithParserThatReportsSemanticError());\n\n        verify(reporter, times(1))\n            .log(eq(Level.ERROR), eq(\"at !debug only! test.dummy:1:1: \" + TEST_MESSAGE_SEMANTIC_ERROR));\n        verify(rule, never()).apply(Mockito.any(), Mockito.any());\n\n        assertEquals(1, report.getProcessingErrors().size());\n    }\n\n    @Test\n    public void semanticErrorThrownShouldAbortTheRun() {\n        Report report = process(getVersionWithParserThatThrowsSemanticError());\n\n        verify(reporter, times(1)).log(eq(Level.ERROR), contains(TEST_MESSAGE_SEMANTIC_ERROR));\n        verify(rule, never()).apply(Mockito.any(), Mockito.any());\n\n        assertEquals(1, report.getProcessingErrors().size());\n    }\n\n    public static void registerCustomVersions(BiConsumer<String, Handler> addVersion) {\n        addVersion.accept(THROWS_ASSERTION_ERROR, new HandlerWithParserThatThrows());\n        addVersion.accept(PARSER_REPORTS_SEMANTIC_ERROR, new HandlerWithParserThatReportsSemanticError());\n        addVersion.accept(THROWS_SEMANTIC_ERROR, new HandlerWithParserThatThrowsSemanticError());\n    }\n\n    public static LanguageVersion versionWithParserThatThrowsAssertionError() {\n        return DummyLanguageModule.getInstance().getVersion(THROWS_ASSERTION_ERROR);\n    }\n\n    public static LanguageVersion getVersionWithParserThatThrowsSemanticError() {\n        return DummyLanguageModule.getInstance().getVersion(THROWS_SEMANTIC_ERROR);\n    }\n\n    public static LanguageVersion versionWithParserThatReportsSemanticError() {\n        return DummyLanguageModule.getInstance().getVersion(PARSER_REPORTS_SEMANTIC_ERROR);\n    }\n\n    private static class RuleThatThrows extends AbstractRule {\n\n        RuleThatThrows() {\n            Language dummyLanguage = DummyLanguageModule.getInstance();\n            setLanguage(dummyLanguage);\n        }\n\n        @Override\n        public void apply(Node target, RuleContext ctx) {\n            throw new AssertionError(\"test\");\n        }\n    }\n\n    public static class HandlerWithParserThatThrowsSemanticError extends Handler {\n\n        @Override\n        public Parser getParser() {\n            return task -> {\n                RootNode root = super.getParser().parse(task);\n                throw task.getReporter().error(root, TEST_MESSAGE_SEMANTIC_ERROR);\n            };\n        }\n    }\n\n    public static class HandlerWithParserThatThrows extends Handler {\n\n        @Override\n        public Parser getParser() {\n            return task -> {\n                throw new AssertionError(\"test error while parsing\");\n            };\n        }\n    }\n\n    public static class HandlerWithParserThatReportsSemanticError extends Handler {\n\n        @Override\n        public Parser getParser() {\n            return task -> {\n                RootNode root = super.getParser().parse(task);\n                task.getReporter().error(root, TEST_MESSAGE_SEMANTIC_ERROR);\n                return root;\n            };\n        }\n    }\n}\n",
        "filePathAfter": "pmd-core/src/test/java/net/sourceforge/pmd/lang/DummyLanguageModule.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang;\n\nimport java.util.Objects;\n\nimport net.sourceforge.pmd.RuleViolation;\nimport net.sourceforge.pmd.lang.ast.DummyNode;\nimport net.sourceforge.pmd.lang.ast.DummyNode.DummyRootNode;\nimport net.sourceforge.pmd.lang.ast.ParseException;\nimport net.sourceforge.pmd.lang.ast.Parser;\nimport net.sourceforge.pmd.lang.ast.Parser.ParserTask;\nimport net.sourceforge.pmd.lang.ast.RootNode;\nimport net.sourceforge.pmd.lang.ast.SemanticErrorReporter;\nimport net.sourceforge.pmd.lang.document.Chars;\nimport net.sourceforge.pmd.lang.document.TextDocument;\nimport net.sourceforge.pmd.lang.document.TextFile;\nimport net.sourceforge.pmd.lang.document.TextRegion;\nimport net.sourceforge.pmd.reporting.ViolationDecorator;\n\n/**\n * Dummy language used for testing PMD.\n */\npublic class DummyLanguageModule extends BaseLanguageModule {\n\n    public static final String NAME = \"Dummy\";\n    public static final String TERSE_NAME = \"dummy\";\n\n    public static final String TEST_MESSAGE_SEMANTIC_ERROR = \"An error occurred!\";\n    private static final String PARSER_REPORTS_SEMANTIC_ERROR = \"1.9-semantic_error\";\n    private static final String THROWS_SEMANTIC_ERROR = \"1.9-throws_semantic_error\";\n    private static final String THROWS_ASSERTION_ERROR = \"1.9-throws\";\n\n    public DummyLanguageModule() {\n        super(NAME, null, TERSE_NAME, \"dummy\");\n        addVersion(\"1.0\", new Handler());\n        addVersion(\"1.1\", new Handler());\n        addVersion(\"1.2\", new Handler());\n        addVersion(\"1.3\", new Handler());\n        addVersion(\"1.4\", new Handler());\n        addVersion(\"1.5\", new Handler(), \"5\");\n        addVersion(\"1.6\", new Handler(), \"6\");\n        addDefaultVersion(\"1.7\", new Handler(), \"7\");\n        addVersion(\"1.8\", new Handler(), \"8\");\n\n        addVersion(THROWS_ASSERTION_ERROR, new HandlerWithParserThatThrows());\n        addVersion(PARSER_REPORTS_SEMANTIC_ERROR, new HandlerWithParserThatReportsSemanticError());\n        addVersion(THROWS_SEMANTIC_ERROR, new HandlerWithParserThatThrowsSemanticError());\n    }\n\n    public static DummyLanguageModule getInstance() {\n        return (DummyLanguageModule) Objects.requireNonNull(LanguageRegistry.PMD.getLanguageByFullName(NAME));\n    }\n\n    public static LanguageVersion versionWithParserThatThrowsAssertionError() {\n        return DummyLanguageModule.getInstance().getVersion(THROWS_ASSERTION_ERROR);\n    }\n\n    public static LanguageVersion getVersionWithParserThatThrowsSemanticError() {\n        return DummyLanguageModule.getInstance().getVersion(THROWS_SEMANTIC_ERROR);\n    }\n\n    public static LanguageVersion versionWithParserThatReportsSemanticError() {\n        return DummyLanguageModule.getInstance().getVersion(PARSER_REPORTS_SEMANTIC_ERROR);\n    }\n\n    public static DummyRootNode parse(String code) {\n        return parse(code, TextFile.UNKNOWN_FILENAME);\n    }\n\n    public static DummyRootNode parse(String code, String filename) {\n        LanguageVersion version = DummyLanguageModule.getInstance().getDefaultVersion();\n        ParserTask task = new ParserTask(\n            TextDocument.readOnlyString(code, filename, version),\n            SemanticErrorReporter.noop()\n        );\n        return (DummyRootNode) version.getLanguageVersionHandler().getParser().parse(task);\n    }\n\n    public static class Handler extends AbstractPmdLanguageVersionHandler {\n\n        @Override\n        public Parser getParser() {\n            return DummyLanguageModule::readLispNode;\n        }\n\n        @Override\n        public ViolationDecorator getViolationDecorator() {\n            return (node, data) -> data.put(RuleViolation.PACKAGE_NAME, \"foo\");\n        }\n    }\n\n    /**\n     * Creates a tree of nodes that corresponds to the nesting structures\n     * of parentheses in the text. The image of each node is also populated.\n     * This is useful to create non-trivial trees with all the relevant\n     * data (eg coordinates) set properly.\n     *\n     * Eg {@code (a(b)x(c))} will create a tree with a node \"a\", with two\n     * children \"b\" and \"c\". \"x\" is ignored. The node \"a\" is not the root\n     * node, it has a {@link DummyRootNode} as parent, whose image is \"\".\n     */\n    private static DummyRootNode readLispNode(ParserTask task) {\n        TextDocument document = task.getTextDocument();\n        final DummyRootNode root = new DummyRootNode().withTaskInfo(task);\n        root.setRegion(document.getEntireRegion());\n\n        DummyNode top = root;\n        int lastNodeStart = 0;\n        Chars text = document.getText();\n        for (int i = 0; i < text.length(); i++) {\n            char c = text.charAt(i);\n            if (c == '(') {\n                DummyNode node = new DummyNode();\n                node.setParent(top);\n                top.addChild(node, top.getNumChildren());\n                // setup coordinates, temporary (will be completed when node closes)\n                node.setRegion(TextRegion.caretAt(i));\n\n                // cut out image\n                if (top.getImage() == null) {\n                    // image may be non null if this is not the first child of 'top'\n                    // eg in (a(b)x(c)), the image of the parent is set to \"a\".\n                    // When we're processing \"(c\", we ignore \"x\".\n                    String image = text.substring(lastNodeStart, i);\n                    top.setImage(image);\n                }\n                lastNodeStart = i + 1;\n                // node is the top of the stack now\n                top = node;\n            } else if (c == ')') {\n                if (top == null) {\n                    throw new ParseException(\"Unbalanced parentheses: \" + text);\n                }\n\n                top.setRegion(TextRegion.fromBothOffsets(top.getTextRegion().getStartOffset(), i));\n\n                if (top.getImage() == null) {\n                    // cut out image (if node doesn't have children it hasn't been populated yet)\n                    String image = text.substring(lastNodeStart, i);\n                    top.setImage(image);\n                    lastNodeStart = i + 1;\n                }\n                top = top.getParent();\n            }\n        }\n        if (top != root) {\n            throw new ParseException(\"Unbalanced parentheses: \" + text);\n        }\n        return root;\n    }\n\n    private static class HandlerWithParserThatThrowsSemanticError extends Handler {\n\n        @Override\n        public Parser getParser() {\n            return task -> {\n                RootNode root = super.getParser().parse(task);\n                throw task.getReporter().error(root, TEST_MESSAGE_SEMANTIC_ERROR);\n            };\n        }\n    }\n\n    private static class HandlerWithParserThatThrows extends Handler {\n\n        @Override\n        public Parser getParser() {\n            return task -> {\n                throw new AssertionError(\"test error while parsing\");\n            };\n        }\n    }\n\n    private static class HandlerWithParserThatReportsSemanticError extends Handler {\n\n        @Override\n        public Parser getParser() {\n            return task -> {\n                RootNode root = super.getParser().parse(task);\n                task.getReporter().error(root, TEST_MESSAGE_SEMANTIC_ERROR);\n                return root;\n            };\n        }\n    }\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.DummyLanguageModule#getInstance\n methodBody: public static DummyLanguageModule getInstance() {\nreturn (DummyLanguageModule)Objects.requireNonNull(LanguageRegistry.PMD.getLanguageByFullName(NAME));\n}"
        ],
        "sourceCodeAfterRefactoring": "public static LanguageVersion getVersionWithParserThatThrowsSemanticError() {\n        return DummyLanguageModule.getInstance().getVersion(THROWS_SEMANTIC_ERROR);\n    }",
        "diffSourceCode": "-   61:     private MessageReporter reporter;\n-   62:     private Rule rule;\n-   63: \n-  166:     public static LanguageVersion getVersionWithParserThatThrowsSemanticError() {\n-  167:         return DummyLanguageModule.getInstance().getVersion(THROWS_SEMANTIC_ERROR);\n-  168:     }\n+   61:     public static LanguageVersion getVersionWithParserThatThrowsSemanticError() {\n+   62:         return DummyLanguageModule.getInstance().getVersion(THROWS_SEMANTIC_ERROR);\n+   63:     }\n+  166:     private static class HandlerWithParserThatThrows extends Handler {\n+  167: \n+  168:         @Override\n",
        "uniqueId": "d5b3478c8a5d06ab221c2a8d31d976a508beb0a8_166_168__61_63",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate assertWarningsWithFoo(size int, code String) : void extracted from package testSuppressAll() : void in class net.sourceforge.pmd.lang.apex.SuppressWarningsTest",
        "diffLocations": [
            {
                "filePath": "pmd-apex/src/test/java/net/sourceforge/pmd/lang/apex/SuppressWarningsTest.java",
                "startLine": 115,
                "endLine": 119,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-apex/src/test/java/net/sourceforge/pmd/lang/apex/SuppressWarningsTest.java",
                "startLine": 52,
                "endLine": 54,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-apex/src/test/java/net/sourceforge/pmd/lang/apex/SuppressWarningsTest.java",
                "startLine": 158,
                "endLine": 161,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n    void testSuppressAll() {\n        Report rpt = apex.executeRule(new FooRule(), TEST12);\n        assertSize(rpt, 0);\n    }",
        "filePathBefore": "pmd-apex/src/test/java/net/sourceforge/pmd/lang/apex/SuppressWarningsTest.java",
        "isPureRefactoring": true,
        "commitId": "b25c16f94d8d7c998e391eecb3ae06ac8be2aa32",
        "packageNameBefore": "net.sourceforge.pmd.lang.apex",
        "classNameBefore": "net.sourceforge.pmd.lang.apex.SuppressWarningsTest",
        "methodNameBefore": "net.sourceforge.pmd.lang.apex.SuppressWarningsTest#testSuppressAll",
        "classSignatureBefore": "class SuppressWarningsTest extends ApexParserTestBase ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.apex.SuppressWarningsTest#testSuppressAll"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.apex.SuppressWarningsTest"
        ],
        "classSignatureBeforeSet": [
            "class SuppressWarningsTest extends ApexParserTestBase "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics\nOverlapped refactoring - can be identical by undoing the overlapped refactoring\n- Rename Variable-",
                "description": "Rename Variable on top of the extract method - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex;\n\nimport static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSize;\nimport static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSuppressed;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.List;\n\nimport org.junit.jupiter.api.Test;\n\nimport net.sourceforge.pmd.PMD;\nimport net.sourceforge.pmd.Report;\nimport net.sourceforge.pmd.ViolationSuppressor;\nimport net.sourceforge.pmd.lang.apex.ast.ASTUserClass;\nimport net.sourceforge.pmd.lang.apex.ast.ApexParserTestBase;\nimport net.sourceforge.pmd.lang.apex.rule.AbstractApexRule;\n\nclass SuppressWarningsTest extends ApexParserTestBase {\n\n    // This could be a regular xml test\n\n    private static class BarRule extends AbstractApexRule {\n\n        @Override\n        public String getMessage() {\n            return \"a message\";\n        }\n\n        @Override\n        public Object visit(ASTUserClass clazz, Object ctx) {\n            if (clazz.getSimpleName().equalsIgnoreCase(\"bar\")) {\n                addViolation(ctx, clazz);\n            }\n            return super.visit(clazz, ctx);\n        }\n\n        @Override\n        public String getName() {\n            return \"NoBar\";\n        }\n    }\n\n    @Test\n    void testClassLevelSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST1);\n        assertSize(rpt, 0);\n        rpt = apex.executeRule(new FooRule(), TEST2);\n        assertSize(rpt, 0);\n    }\n\n    @Test\n    void testInheritedSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST3);\n        assertSize(rpt, 0);\n    }\n\n    @Test\n    void testMethodLevelSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST4);\n        assertSize(rpt, 1);\n    }\n\n    @Test\n    void testConstructorLevelSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST5);\n        assertSize(rpt, 0);\n    }\n\n    @Test\n    void testFieldLevelSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST6);\n        assertSize(rpt, 1);\n    }\n\n    @Test\n    void testParameterLevelSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST7);\n        assertSize(rpt, 1);\n    }\n\n    @Test\n    void testLocalVariableLevelSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST8);\n        assertSize(rpt, 1);\n    }\n\n    @Test\n    void testSpecificSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST9);\n        assertSize(rpt, 1);\n    }\n\n    @Test\n    void testSpecificSuppressionMulitpleValues() {\n        Report rpt = apex.executeRule(new FooRule(), TEST9_MULTIPLE_VALUES);\n        assertSize(rpt, 0);\n    }\n\n    @Test\n    void testNoSuppressionBlank() {\n        Report rpt = apex.executeRule(new FooRule(), TEST10);\n        assertSize(rpt, 2);\n    }\n\n    @Test\n    void testNoSuppressionSomethingElseS() {\n        Report rpt = apex.executeRule(new FooRule(), TEST11);\n        assertSize(rpt, 2);\n    }\n\n    @Test\n    void testSuppressAll() {\n        Report rpt = apex.executeRule(new FooRule(), TEST12);\n        assertSize(rpt, 0);\n    }\n\n    @Test\n    void testSpecificSuppressionAtTopLevel() {\n        Report rpt = apex.executeRule(new BarRule(), TEST13);\n        assertSize(rpt, 0);\n    }\n\n    @Test\n    void testCommentSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST14);\n        assertSize(rpt, 0);\n        assertSuppressed(rpt, 1);\n    }\n\n    @Test\n    void testMessageWithCommentSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST15);\n        assertSize(rpt, 0);\n\n        List<Report.SuppressedViolation> suppressions = assertSuppressed(rpt, 1);\n        Report.SuppressedViolation suppression = suppressions.get(0);\n\n        assertEquals(ViolationSuppressor.NOPMD_COMMENT_SUPPRESSOR, suppression.getSuppressor());\n        assertEquals(\"We allow foo here\", suppression.getUserMessage());\n    }\n\n    private static final String TEST1 = \"@SuppressWarnings('PMD')\" + PMD.EOL + \"public class Foo {}\";\n\n    private static final String TEST2 = \"@SuppressWarnings('PMD')\" + PMD.EOL + \"public class Foo {\" + PMD.EOL\n            + \" void bar() {\" + PMD.EOL + \"  Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST3 = \"public class Baz {\" + PMD.EOL + \" @SuppressWarnings('PMD')\" + PMD.EOL\n            + \" public class Bar {\" + PMD.EOL + \"  void bar() {\" + PMD.EOL + \"   Integer foo;\" + PMD.EOL + \"  }\" + PMD.EOL\n            + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST4 = \"public class Foo {\" + PMD.EOL + \" @SuppressWarnings('PMD')\" + PMD.EOL\n            + \" void bar() {\" + PMD.EOL + \"  Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST5 = \"public class Bar {\" + PMD.EOL + \" @SuppressWarnings('PMD')\" + PMD.EOL\n            + \" public Bar() {\" + PMD.EOL + \"  Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST6 = \"public class Bar {\" + PMD.EOL + \" @SuppressWarnings('PMD')\" + PMD.EOL\n            + \" Integer foo;\" + PMD.EOL + \" void bar() {\" + PMD.EOL + \"  Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST7 = \"public class Bar {\" + PMD.EOL + \" Integer foo;\" + PMD.EOL\n            + \" void bar(@SuppressWarnings('PMD') Integer foo) {}\" + PMD.EOL + \"}\";\n\n    private static final String TEST8 = \"public class Bar {\" + PMD.EOL + \" Integer foo;\" + PMD.EOL + \" void bar() {\"\n            + PMD.EOL + \"  @SuppressWarnings('PMD') Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST9 = \"public class Bar {\" + PMD.EOL + \" Integer foo;\" + PMD.EOL + \" void bar() {\"\n            + PMD.EOL + \"  @SuppressWarnings('PMD.NoFoo') Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST9_MULTIPLE_VALUES = \"@SuppressWarnings('PMD.NoFoo, PMD.NoBar')\"\n            + PMD.EOL + \"public class Bar {\" + PMD.EOL + \" Integer foo;\" + PMD.EOL + \" void bar() {\" + PMD.EOL\n            + \"  Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST10 = \"public class Bar {\" + PMD.EOL + \" Integer foo;\" + PMD.EOL + \" void bar() {\"\n            + PMD.EOL + \"  @SuppressWarnings('') Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST11 = \"public class Bar {\" + PMD.EOL + \" Integer foo;\" + PMD.EOL + \" void bar() {\"\n            + PMD.EOL + \"  @SuppressWarnings('SomethingElse') Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST12 = \"public class Bar {\" + PMD.EOL + \" @SuppressWarnings('all') Integer foo;\"\n            + PMD.EOL + \"}\";\n\n    private static final String TEST13 = \"@SuppressWarnings('PMD.NoBar')\" + PMD.EOL + \"public class Bar {\" + PMD.EOL\n            + \"}\";\n\n    private static final String TEST14 = \"public class Bar {\" + PMD.EOL + \"Integer foo; // NOPMD\" + PMD.EOL + \"}\";\n\n    private static final String TEST15 = \"public class Bar {\" + PMD.EOL + \"Integer foo; //NOPMD We allow foo here\" + PMD.EOL + \"}\";\n}\n",
        "filePathAfter": "pmd-apex/src/test/java/net/sourceforge/pmd/lang/apex/SuppressWarningsTest.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex;\n\nimport static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSize;\nimport static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSuppressed;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.List;\n\nimport org.junit.jupiter.api.Test;\n\nimport net.sourceforge.pmd.Report;\nimport net.sourceforge.pmd.ViolationSuppressor;\nimport net.sourceforge.pmd.lang.apex.ast.ASTUserClass;\nimport net.sourceforge.pmd.lang.apex.ast.ApexParserTestBase;\nimport net.sourceforge.pmd.lang.apex.rule.AbstractApexRule;\n\nclass SuppressWarningsTest extends ApexParserTestBase {\n\n    // This could be a regular xml test\n\n    private static class BarRule extends AbstractApexRule {\n\n        @Override\n        public String getMessage() {\n            return \"a message\";\n        }\n\n        @Override\n        public Object visit(ASTUserClass clazz, Object ctx) {\n            if (clazz.getSimpleName().equalsIgnoreCase(\"bar\")) {\n                addViolation(ctx, clazz);\n            }\n            return super.visit(clazz, ctx);\n        }\n\n        @Override\n        public String getName() {\n            return \"NoBar\";\n        }\n    }\n\n    @Test\n    void testClassLevelSuppression() {\n        assertNoWarningsWithFoo(\"@SuppressWarnings('PMD')\\n\"\n                                    + \"public class Foo {}\");\n    }\n\n    private void assertNoWarningsWithFoo(String code) {\n        assertWarningsWithFoo(0, code);\n    }\n\n    @Test\n    void testClassLevelSuppression2() {\n        assertNoWarningsWithFoo(\"@SuppressWarnings('PMD')\\n\"\n            + \"public class Foo {\" + \"\\n\"\n            + \" void bar() {\\n\"\n            + \"  Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testInheritedSuppression() {\n        assertNoWarningsWithFoo(\"public class Baz {\\n\"\n            + \" @SuppressWarnings('PMD')\" + \"\\n\"\n            + \" public class Bar {\\n\"\n            + \"  void bar() {\\n\"\n            + \"   Integer foo;\\n\"\n            + \"  }\" + \"\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testMethodLevelSuppression() {\n        assertWarningsWithFoo(1, \"public class Foo {\\n\" +\n            \" @SuppressWarnings('PMD')\\n\" +\n            \" void bar() {\\n\" +\n            \"  Integer foo;\\n\" +\n            \" }\\n\" +\n            \"}\");\n    }\n\n    @Test\n    void testConstructorLevelSuppression() {\n        assertNoWarningsWithFoo(\"public class Bar {\\n\"\n            + \" @SuppressWarnings('PMD')\" + \"\\n\"\n            + \" public Bar() {\\n\"\n            + \"  Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testFieldLevelSuppression() {\n        assertWarningsWithFoo(1, \"public class Bar {\\n\"\n            + \" @SuppressWarnings('PMD')\" + \"\\n\"\n            + \" Integer foo;\\n\"\n            + \" void bar() {\\n\"\n            + \"  Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testParameterLevelSuppression() {\n        assertWarningsWithFoo(1, \"public class Bar {\\n\"\n            + \" Integer foo;\" + \"\\n\"\n            + \" void bar(@SuppressWarnings('PMD') Integer foo) {}\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testLocalVariableLevelSuppression() {\n        assertWarningsWithFoo(1, \"public class Bar {\\n\"\n            + \" Integer foo;\\n\"\n            + \" void bar() {\"\n            + \"\\n\" + \"  @SuppressWarnings('PMD') Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testSpecificSuppression() {\n        assertWarningsWithFoo(1, \"public class Bar {\\n\"\n            + \" Integer foo;\\n\"\n            + \" void bar() {\"\n            + \"\\n\" + \"  @SuppressWarnings('PMD.NoFoo') Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testSpecificSuppressionMulitpleValues() {\n        assertNoWarningsWithFoo(\"@SuppressWarnings('PMD.NoFoo, PMD.NoBar')\"\n            + \"\\n\" + \"public class Bar {\\n\"\n            + \" Integer foo;\\n\"\n            + \" void bar() {\" + \"\\n\"\n            + \"  Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testNoSuppressionBlank() {\n        assertWarningsWithFoo(2, \"public class Bar {\\n\"\n            + \" Integer foo;\\n\"\n            + \" void bar() {\"\n            + \"\\n\" + \"  @SuppressWarnings('') Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    private void assertWarningsWithFoo(int size, String code) {\n        Report rpt = apex.executeRule(new FooRule(), code);\n        assertSize(rpt, size);\n    }\n\n    @Test\n    void testNoSuppressionSomethingElseS() {\n        assertWarningsWithFoo(2, \"public class Bar {\\n\"\n            + \" Integer foo;\\n\"\n            + \" void bar() {\"\n            + \"\\n\" + \"  @SuppressWarnings('SomethingElse') Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testSuppressAll() {\n        assertNoWarningsWithFoo(\"public class Bar {\\n\"\n            + \" @SuppressWarnings('all') Integer foo;\"\n            + \"\\n\" + \"}\");\n    }\n\n    @Test\n    void testSpecificSuppressionAtTopLevel() {\n        Report rpt = apex.executeRule(new BarRule(), \"@SuppressWarnings('PMD.NoBar')\\n\"\n            + \"public class Bar {\" + \"\\n\"\n            + \"}\");\n        assertSize(rpt, 0);\n    }\n\n    @Test\n    void testCommentSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), \"public class Bar {\\n\"\n            + \"Integer foo; // NOPMD\\n\"\n            + \"}\");\n        assertSize(rpt, 0);\n        assertSuppressed(rpt, 1);\n    }\n\n    @Test\n    void testMessageWithCommentSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), \"public class Bar {\\n\"\n            + \"Integer foo; //NOPMD We allow foo here\\n\"\n            + \"}\");\n        assertSize(rpt, 0);\n\n        List<Report.SuppressedViolation> suppressions = assertSuppressed(rpt, 1);\n        Report.SuppressedViolation suppression = suppressions.get(0);\n\n        assertEquals(ViolationSuppressor.NOPMD_COMMENT_SUPPRESSOR, suppression.getSuppressor());\n        assertEquals(\"We allow foo here\", suppression.getUserMessage());\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "private void assertWarningsWithFoo(int size, String code) {\n        Report rpt = apex.executeRule(new FooRule(), code);\n        assertSize(rpt, size);\n    }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "private void assertNoWarningsWithFoo(String code) {\n        assertWarningsWithFoo(0, code);\n    }\nprivate void assertWarningsWithFoo(int size, String code) {\n        Report rpt = apex.executeRule(new FooRule(), code);\n        assertSize(rpt, size);\n    }",
        "diffSourceCode": "-   52:         assertSize(rpt, 0);\n-   53:     }\n-   54: \n-  115:     @Test\n-  116:     void testSuppressAll() {\n-  117:         Report rpt = apex.executeRule(new FooRule(), TEST12);\n-  118:         assertSize(rpt, 0);\n-  119:     }\n-  158:     private static final String TEST5 = \"public class Bar {\" + PMD.EOL + \" @SuppressWarnings('PMD')\" + PMD.EOL\n-  159:             + \" public Bar() {\" + PMD.EOL + \"  Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n-  160: \n-  161:     private static final String TEST6 = \"public class Bar {\" + PMD.EOL + \" @SuppressWarnings('PMD')\" + PMD.EOL\n+   52:     private void assertNoWarningsWithFoo(String code) {\n+   53:         assertWarningsWithFoo(0, code);\n+   54:     }\n+  115:     }\n+  116: \n+  117:     @Test\n+  118:     void testLocalVariableLevelSuppression() {\n+  119:         assertWarningsWithFoo(1, \"public class Bar {\\n\"\n+  158:     private void assertWarningsWithFoo(int size, String code) {\n+  159:         Report rpt = apex.executeRule(new FooRule(), code);\n+  160:         assertSize(rpt, size);\n+  161:     }\n",
        "uniqueId": "b25c16f94d8d7c998e391eecb3ae06ac8be2aa32_115_119_158_161_52_54",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate assertWarningsWithFoo(size int, code String) : void extracted from package testSpecificSuppressionMulitpleValues() : void in class net.sourceforge.pmd.lang.apex.SuppressWarningsTest",
        "diffLocations": [
            {
                "filePath": "pmd-apex/src/test/java/net/sourceforge/pmd/lang/apex/SuppressWarningsTest.java",
                "startLine": 97,
                "endLine": 101,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-apex/src/test/java/net/sourceforge/pmd/lang/apex/SuppressWarningsTest.java",
                "startLine": 52,
                "endLine": 54,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-apex/src/test/java/net/sourceforge/pmd/lang/apex/SuppressWarningsTest.java",
                "startLine": 158,
                "endLine": 161,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n    void testSpecificSuppressionMulitpleValues() {\n        Report rpt = apex.executeRule(new FooRule(), TEST9_MULTIPLE_VALUES);\n        assertSize(rpt, 0);\n    }",
        "filePathBefore": "pmd-apex/src/test/java/net/sourceforge/pmd/lang/apex/SuppressWarningsTest.java",
        "isPureRefactoring": true,
        "commitId": "b25c16f94d8d7c998e391eecb3ae06ac8be2aa32",
        "packageNameBefore": "net.sourceforge.pmd.lang.apex",
        "classNameBefore": "net.sourceforge.pmd.lang.apex.SuppressWarningsTest",
        "methodNameBefore": "net.sourceforge.pmd.lang.apex.SuppressWarningsTest#testSpecificSuppressionMulitpleValues",
        "classSignatureBefore": "class SuppressWarningsTest extends ApexParserTestBase ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.apex.SuppressWarningsTest#testSpecificSuppressionMulitpleValues"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.apex.SuppressWarningsTest"
        ],
        "classSignatureBeforeSet": [
            "class SuppressWarningsTest extends ApexParserTestBase "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics\nOverlapped refactoring - can be identical by undoing the overlapped refactoring\n- Rename Variable-",
                "description": "Rename Variable on top of the extract method - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex;\n\nimport static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSize;\nimport static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSuppressed;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.List;\n\nimport org.junit.jupiter.api.Test;\n\nimport net.sourceforge.pmd.PMD;\nimport net.sourceforge.pmd.Report;\nimport net.sourceforge.pmd.ViolationSuppressor;\nimport net.sourceforge.pmd.lang.apex.ast.ASTUserClass;\nimport net.sourceforge.pmd.lang.apex.ast.ApexParserTestBase;\nimport net.sourceforge.pmd.lang.apex.rule.AbstractApexRule;\n\nclass SuppressWarningsTest extends ApexParserTestBase {\n\n    // This could be a regular xml test\n\n    private static class BarRule extends AbstractApexRule {\n\n        @Override\n        public String getMessage() {\n            return \"a message\";\n        }\n\n        @Override\n        public Object visit(ASTUserClass clazz, Object ctx) {\n            if (clazz.getSimpleName().equalsIgnoreCase(\"bar\")) {\n                addViolation(ctx, clazz);\n            }\n            return super.visit(clazz, ctx);\n        }\n\n        @Override\n        public String getName() {\n            return \"NoBar\";\n        }\n    }\n\n    @Test\n    void testClassLevelSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST1);\n        assertSize(rpt, 0);\n        rpt = apex.executeRule(new FooRule(), TEST2);\n        assertSize(rpt, 0);\n    }\n\n    @Test\n    void testInheritedSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST3);\n        assertSize(rpt, 0);\n    }\n\n    @Test\n    void testMethodLevelSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST4);\n        assertSize(rpt, 1);\n    }\n\n    @Test\n    void testConstructorLevelSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST5);\n        assertSize(rpt, 0);\n    }\n\n    @Test\n    void testFieldLevelSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST6);\n        assertSize(rpt, 1);\n    }\n\n    @Test\n    void testParameterLevelSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST7);\n        assertSize(rpt, 1);\n    }\n\n    @Test\n    void testLocalVariableLevelSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST8);\n        assertSize(rpt, 1);\n    }\n\n    @Test\n    void testSpecificSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST9);\n        assertSize(rpt, 1);\n    }\n\n    @Test\n    void testSpecificSuppressionMulitpleValues() {\n        Report rpt = apex.executeRule(new FooRule(), TEST9_MULTIPLE_VALUES);\n        assertSize(rpt, 0);\n    }\n\n    @Test\n    void testNoSuppressionBlank() {\n        Report rpt = apex.executeRule(new FooRule(), TEST10);\n        assertSize(rpt, 2);\n    }\n\n    @Test\n    void testNoSuppressionSomethingElseS() {\n        Report rpt = apex.executeRule(new FooRule(), TEST11);\n        assertSize(rpt, 2);\n    }\n\n    @Test\n    void testSuppressAll() {\n        Report rpt = apex.executeRule(new FooRule(), TEST12);\n        assertSize(rpt, 0);\n    }\n\n    @Test\n    void testSpecificSuppressionAtTopLevel() {\n        Report rpt = apex.executeRule(new BarRule(), TEST13);\n        assertSize(rpt, 0);\n    }\n\n    @Test\n    void testCommentSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST14);\n        assertSize(rpt, 0);\n        assertSuppressed(rpt, 1);\n    }\n\n    @Test\n    void testMessageWithCommentSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST15);\n        assertSize(rpt, 0);\n\n        List<Report.SuppressedViolation> suppressions = assertSuppressed(rpt, 1);\n        Report.SuppressedViolation suppression = suppressions.get(0);\n\n        assertEquals(ViolationSuppressor.NOPMD_COMMENT_SUPPRESSOR, suppression.getSuppressor());\n        assertEquals(\"We allow foo here\", suppression.getUserMessage());\n    }\n\n    private static final String TEST1 = \"@SuppressWarnings('PMD')\" + PMD.EOL + \"public class Foo {}\";\n\n    private static final String TEST2 = \"@SuppressWarnings('PMD')\" + PMD.EOL + \"public class Foo {\" + PMD.EOL\n            + \" void bar() {\" + PMD.EOL + \"  Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST3 = \"public class Baz {\" + PMD.EOL + \" @SuppressWarnings('PMD')\" + PMD.EOL\n            + \" public class Bar {\" + PMD.EOL + \"  void bar() {\" + PMD.EOL + \"   Integer foo;\" + PMD.EOL + \"  }\" + PMD.EOL\n            + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST4 = \"public class Foo {\" + PMD.EOL + \" @SuppressWarnings('PMD')\" + PMD.EOL\n            + \" void bar() {\" + PMD.EOL + \"  Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST5 = \"public class Bar {\" + PMD.EOL + \" @SuppressWarnings('PMD')\" + PMD.EOL\n            + \" public Bar() {\" + PMD.EOL + \"  Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST6 = \"public class Bar {\" + PMD.EOL + \" @SuppressWarnings('PMD')\" + PMD.EOL\n            + \" Integer foo;\" + PMD.EOL + \" void bar() {\" + PMD.EOL + \"  Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST7 = \"public class Bar {\" + PMD.EOL + \" Integer foo;\" + PMD.EOL\n            + \" void bar(@SuppressWarnings('PMD') Integer foo) {}\" + PMD.EOL + \"}\";\n\n    private static final String TEST8 = \"public class Bar {\" + PMD.EOL + \" Integer foo;\" + PMD.EOL + \" void bar() {\"\n            + PMD.EOL + \"  @SuppressWarnings('PMD') Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST9 = \"public class Bar {\" + PMD.EOL + \" Integer foo;\" + PMD.EOL + \" void bar() {\"\n            + PMD.EOL + \"  @SuppressWarnings('PMD.NoFoo') Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST9_MULTIPLE_VALUES = \"@SuppressWarnings('PMD.NoFoo, PMD.NoBar')\"\n            + PMD.EOL + \"public class Bar {\" + PMD.EOL + \" Integer foo;\" + PMD.EOL + \" void bar() {\" + PMD.EOL\n            + \"  Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST10 = \"public class Bar {\" + PMD.EOL + \" Integer foo;\" + PMD.EOL + \" void bar() {\"\n            + PMD.EOL + \"  @SuppressWarnings('') Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST11 = \"public class Bar {\" + PMD.EOL + \" Integer foo;\" + PMD.EOL + \" void bar() {\"\n            + PMD.EOL + \"  @SuppressWarnings('SomethingElse') Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST12 = \"public class Bar {\" + PMD.EOL + \" @SuppressWarnings('all') Integer foo;\"\n            + PMD.EOL + \"}\";\n\n    private static final String TEST13 = \"@SuppressWarnings('PMD.NoBar')\" + PMD.EOL + \"public class Bar {\" + PMD.EOL\n            + \"}\";\n\n    private static final String TEST14 = \"public class Bar {\" + PMD.EOL + \"Integer foo; // NOPMD\" + PMD.EOL + \"}\";\n\n    private static final String TEST15 = \"public class Bar {\" + PMD.EOL + \"Integer foo; //NOPMD We allow foo here\" + PMD.EOL + \"}\";\n}\n",
        "filePathAfter": "pmd-apex/src/test/java/net/sourceforge/pmd/lang/apex/SuppressWarningsTest.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex;\n\nimport static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSize;\nimport static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSuppressed;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.List;\n\nimport org.junit.jupiter.api.Test;\n\nimport net.sourceforge.pmd.Report;\nimport net.sourceforge.pmd.ViolationSuppressor;\nimport net.sourceforge.pmd.lang.apex.ast.ASTUserClass;\nimport net.sourceforge.pmd.lang.apex.ast.ApexParserTestBase;\nimport net.sourceforge.pmd.lang.apex.rule.AbstractApexRule;\n\nclass SuppressWarningsTest extends ApexParserTestBase {\n\n    // This could be a regular xml test\n\n    private static class BarRule extends AbstractApexRule {\n\n        @Override\n        public String getMessage() {\n            return \"a message\";\n        }\n\n        @Override\n        public Object visit(ASTUserClass clazz, Object ctx) {\n            if (clazz.getSimpleName().equalsIgnoreCase(\"bar\")) {\n                addViolation(ctx, clazz);\n            }\n            return super.visit(clazz, ctx);\n        }\n\n        @Override\n        public String getName() {\n            return \"NoBar\";\n        }\n    }\n\n    @Test\n    void testClassLevelSuppression() {\n        assertNoWarningsWithFoo(\"@SuppressWarnings('PMD')\\n\"\n                                    + \"public class Foo {}\");\n    }\n\n    private void assertNoWarningsWithFoo(String code) {\n        assertWarningsWithFoo(0, code);\n    }\n\n    @Test\n    void testClassLevelSuppression2() {\n        assertNoWarningsWithFoo(\"@SuppressWarnings('PMD')\\n\"\n            + \"public class Foo {\" + \"\\n\"\n            + \" void bar() {\\n\"\n            + \"  Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testInheritedSuppression() {\n        assertNoWarningsWithFoo(\"public class Baz {\\n\"\n            + \" @SuppressWarnings('PMD')\" + \"\\n\"\n            + \" public class Bar {\\n\"\n            + \"  void bar() {\\n\"\n            + \"   Integer foo;\\n\"\n            + \"  }\" + \"\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testMethodLevelSuppression() {\n        assertWarningsWithFoo(1, \"public class Foo {\\n\" +\n            \" @SuppressWarnings('PMD')\\n\" +\n            \" void bar() {\\n\" +\n            \"  Integer foo;\\n\" +\n            \" }\\n\" +\n            \"}\");\n    }\n\n    @Test\n    void testConstructorLevelSuppression() {\n        assertNoWarningsWithFoo(\"public class Bar {\\n\"\n            + \" @SuppressWarnings('PMD')\" + \"\\n\"\n            + \" public Bar() {\\n\"\n            + \"  Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testFieldLevelSuppression() {\n        assertWarningsWithFoo(1, \"public class Bar {\\n\"\n            + \" @SuppressWarnings('PMD')\" + \"\\n\"\n            + \" Integer foo;\\n\"\n            + \" void bar() {\\n\"\n            + \"  Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testParameterLevelSuppression() {\n        assertWarningsWithFoo(1, \"public class Bar {\\n\"\n            + \" Integer foo;\" + \"\\n\"\n            + \" void bar(@SuppressWarnings('PMD') Integer foo) {}\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testLocalVariableLevelSuppression() {\n        assertWarningsWithFoo(1, \"public class Bar {\\n\"\n            + \" Integer foo;\\n\"\n            + \" void bar() {\"\n            + \"\\n\" + \"  @SuppressWarnings('PMD') Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testSpecificSuppression() {\n        assertWarningsWithFoo(1, \"public class Bar {\\n\"\n            + \" Integer foo;\\n\"\n            + \" void bar() {\"\n            + \"\\n\" + \"  @SuppressWarnings('PMD.NoFoo') Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testSpecificSuppressionMulitpleValues() {\n        assertNoWarningsWithFoo(\"@SuppressWarnings('PMD.NoFoo, PMD.NoBar')\"\n            + \"\\n\" + \"public class Bar {\\n\"\n            + \" Integer foo;\\n\"\n            + \" void bar() {\" + \"\\n\"\n            + \"  Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testNoSuppressionBlank() {\n        assertWarningsWithFoo(2, \"public class Bar {\\n\"\n            + \" Integer foo;\\n\"\n            + \" void bar() {\"\n            + \"\\n\" + \"  @SuppressWarnings('') Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    private void assertWarningsWithFoo(int size, String code) {\n        Report rpt = apex.executeRule(new FooRule(), code);\n        assertSize(rpt, size);\n    }\n\n    @Test\n    void testNoSuppressionSomethingElseS() {\n        assertWarningsWithFoo(2, \"public class Bar {\\n\"\n            + \" Integer foo;\\n\"\n            + \" void bar() {\"\n            + \"\\n\" + \"  @SuppressWarnings('SomethingElse') Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testSuppressAll() {\n        assertNoWarningsWithFoo(\"public class Bar {\\n\"\n            + \" @SuppressWarnings('all') Integer foo;\"\n            + \"\\n\" + \"}\");\n    }\n\n    @Test\n    void testSpecificSuppressionAtTopLevel() {\n        Report rpt = apex.executeRule(new BarRule(), \"@SuppressWarnings('PMD.NoBar')\\n\"\n            + \"public class Bar {\" + \"\\n\"\n            + \"}\");\n        assertSize(rpt, 0);\n    }\n\n    @Test\n    void testCommentSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), \"public class Bar {\\n\"\n            + \"Integer foo; // NOPMD\\n\"\n            + \"}\");\n        assertSize(rpt, 0);\n        assertSuppressed(rpt, 1);\n    }\n\n    @Test\n    void testMessageWithCommentSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), \"public class Bar {\\n\"\n            + \"Integer foo; //NOPMD We allow foo here\\n\"\n            + \"}\");\n        assertSize(rpt, 0);\n\n        List<Report.SuppressedViolation> suppressions = assertSuppressed(rpt, 1);\n        Report.SuppressedViolation suppression = suppressions.get(0);\n\n        assertEquals(ViolationSuppressor.NOPMD_COMMENT_SUPPRESSOR, suppression.getSuppressor());\n        assertEquals(\"We allow foo here\", suppression.getUserMessage());\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "private void assertWarningsWithFoo(int size, String code) {\n        Report rpt = apex.executeRule(new FooRule(), code);\n        assertSize(rpt, size);\n    }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "private void assertNoWarningsWithFoo(String code) {\n        assertWarningsWithFoo(0, code);\n    }\nprivate void assertWarningsWithFoo(int size, String code) {\n        Report rpt = apex.executeRule(new FooRule(), code);\n        assertSize(rpt, size);\n    }",
        "diffSourceCode": "-   52:         assertSize(rpt, 0);\n-   53:     }\n-   54: \n-   97:     @Test\n-   98:     void testSpecificSuppressionMulitpleValues() {\n-   99:         Report rpt = apex.executeRule(new FooRule(), TEST9_MULTIPLE_VALUES);\n-  100:         assertSize(rpt, 0);\n-  101:     }\n-  158:     private static final String TEST5 = \"public class Bar {\" + PMD.EOL + \" @SuppressWarnings('PMD')\" + PMD.EOL\n-  159:             + \" public Bar() {\" + PMD.EOL + \"  Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n-  160: \n-  161:     private static final String TEST6 = \"public class Bar {\" + PMD.EOL + \" @SuppressWarnings('PMD')\" + PMD.EOL\n+   52:     private void assertNoWarningsWithFoo(String code) {\n+   53:         assertWarningsWithFoo(0, code);\n+   54:     }\n+   97: \n+   98:     @Test\n+   99:     void testFieldLevelSuppression() {\n+  100:         assertWarningsWithFoo(1, \"public class Bar {\\n\"\n+  101:             + \" @SuppressWarnings('PMD')\" + \"\\n\"\n+  158:     private void assertWarningsWithFoo(int size, String code) {\n+  159:         Report rpt = apex.executeRule(new FooRule(), code);\n+  160:         assertSize(rpt, size);\n+  161:     }\n",
        "uniqueId": "b25c16f94d8d7c998e391eecb3ae06ac8be2aa32_97_101_158_161_52_54",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate assertWarningsWithFoo(size int, code String) : void extracted from package testConstructorLevelSuppression() : void in class net.sourceforge.pmd.lang.apex.SuppressWarningsTest",
        "diffLocations": [
            {
                "filePath": "pmd-apex/src/test/java/net/sourceforge/pmd/lang/apex/SuppressWarningsTest.java",
                "startLine": 67,
                "endLine": 71,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-apex/src/test/java/net/sourceforge/pmd/lang/apex/SuppressWarningsTest.java",
                "startLine": 52,
                "endLine": 54,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-apex/src/test/java/net/sourceforge/pmd/lang/apex/SuppressWarningsTest.java",
                "startLine": 158,
                "endLine": 161,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n    void testConstructorLevelSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST5);\n        assertSize(rpt, 0);\n    }",
        "filePathBefore": "pmd-apex/src/test/java/net/sourceforge/pmd/lang/apex/SuppressWarningsTest.java",
        "isPureRefactoring": true,
        "commitId": "b25c16f94d8d7c998e391eecb3ae06ac8be2aa32",
        "packageNameBefore": "net.sourceforge.pmd.lang.apex",
        "classNameBefore": "net.sourceforge.pmd.lang.apex.SuppressWarningsTest",
        "methodNameBefore": "net.sourceforge.pmd.lang.apex.SuppressWarningsTest#testConstructorLevelSuppression",
        "classSignatureBefore": "class SuppressWarningsTest extends ApexParserTestBase ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.apex.SuppressWarningsTest#testConstructorLevelSuppression"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.apex.SuppressWarningsTest"
        ],
        "classSignatureBeforeSet": [
            "class SuppressWarningsTest extends ApexParserTestBase "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics\nOverlapped refactoring - can be identical by undoing the overlapped refactoring\n- Rename Variable-",
                "description": "Rename Variable on top of the extract method - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex;\n\nimport static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSize;\nimport static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSuppressed;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.List;\n\nimport org.junit.jupiter.api.Test;\n\nimport net.sourceforge.pmd.PMD;\nimport net.sourceforge.pmd.Report;\nimport net.sourceforge.pmd.ViolationSuppressor;\nimport net.sourceforge.pmd.lang.apex.ast.ASTUserClass;\nimport net.sourceforge.pmd.lang.apex.ast.ApexParserTestBase;\nimport net.sourceforge.pmd.lang.apex.rule.AbstractApexRule;\n\nclass SuppressWarningsTest extends ApexParserTestBase {\n\n    // This could be a regular xml test\n\n    private static class BarRule extends AbstractApexRule {\n\n        @Override\n        public String getMessage() {\n            return \"a message\";\n        }\n\n        @Override\n        public Object visit(ASTUserClass clazz, Object ctx) {\n            if (clazz.getSimpleName().equalsIgnoreCase(\"bar\")) {\n                addViolation(ctx, clazz);\n            }\n            return super.visit(clazz, ctx);\n        }\n\n        @Override\n        public String getName() {\n            return \"NoBar\";\n        }\n    }\n\n    @Test\n    void testClassLevelSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST1);\n        assertSize(rpt, 0);\n        rpt = apex.executeRule(new FooRule(), TEST2);\n        assertSize(rpt, 0);\n    }\n\n    @Test\n    void testInheritedSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST3);\n        assertSize(rpt, 0);\n    }\n\n    @Test\n    void testMethodLevelSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST4);\n        assertSize(rpt, 1);\n    }\n\n    @Test\n    void testConstructorLevelSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST5);\n        assertSize(rpt, 0);\n    }\n\n    @Test\n    void testFieldLevelSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST6);\n        assertSize(rpt, 1);\n    }\n\n    @Test\n    void testParameterLevelSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST7);\n        assertSize(rpt, 1);\n    }\n\n    @Test\n    void testLocalVariableLevelSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST8);\n        assertSize(rpt, 1);\n    }\n\n    @Test\n    void testSpecificSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST9);\n        assertSize(rpt, 1);\n    }\n\n    @Test\n    void testSpecificSuppressionMulitpleValues() {\n        Report rpt = apex.executeRule(new FooRule(), TEST9_MULTIPLE_VALUES);\n        assertSize(rpt, 0);\n    }\n\n    @Test\n    void testNoSuppressionBlank() {\n        Report rpt = apex.executeRule(new FooRule(), TEST10);\n        assertSize(rpt, 2);\n    }\n\n    @Test\n    void testNoSuppressionSomethingElseS() {\n        Report rpt = apex.executeRule(new FooRule(), TEST11);\n        assertSize(rpt, 2);\n    }\n\n    @Test\n    void testSuppressAll() {\n        Report rpt = apex.executeRule(new FooRule(), TEST12);\n        assertSize(rpt, 0);\n    }\n\n    @Test\n    void testSpecificSuppressionAtTopLevel() {\n        Report rpt = apex.executeRule(new BarRule(), TEST13);\n        assertSize(rpt, 0);\n    }\n\n    @Test\n    void testCommentSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST14);\n        assertSize(rpt, 0);\n        assertSuppressed(rpt, 1);\n    }\n\n    @Test\n    void testMessageWithCommentSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST15);\n        assertSize(rpt, 0);\n\n        List<Report.SuppressedViolation> suppressions = assertSuppressed(rpt, 1);\n        Report.SuppressedViolation suppression = suppressions.get(0);\n\n        assertEquals(ViolationSuppressor.NOPMD_COMMENT_SUPPRESSOR, suppression.getSuppressor());\n        assertEquals(\"We allow foo here\", suppression.getUserMessage());\n    }\n\n    private static final String TEST1 = \"@SuppressWarnings('PMD')\" + PMD.EOL + \"public class Foo {}\";\n\n    private static final String TEST2 = \"@SuppressWarnings('PMD')\" + PMD.EOL + \"public class Foo {\" + PMD.EOL\n            + \" void bar() {\" + PMD.EOL + \"  Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST3 = \"public class Baz {\" + PMD.EOL + \" @SuppressWarnings('PMD')\" + PMD.EOL\n            + \" public class Bar {\" + PMD.EOL + \"  void bar() {\" + PMD.EOL + \"   Integer foo;\" + PMD.EOL + \"  }\" + PMD.EOL\n            + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST4 = \"public class Foo {\" + PMD.EOL + \" @SuppressWarnings('PMD')\" + PMD.EOL\n            + \" void bar() {\" + PMD.EOL + \"  Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST5 = \"public class Bar {\" + PMD.EOL + \" @SuppressWarnings('PMD')\" + PMD.EOL\n            + \" public Bar() {\" + PMD.EOL + \"  Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST6 = \"public class Bar {\" + PMD.EOL + \" @SuppressWarnings('PMD')\" + PMD.EOL\n            + \" Integer foo;\" + PMD.EOL + \" void bar() {\" + PMD.EOL + \"  Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST7 = \"public class Bar {\" + PMD.EOL + \" Integer foo;\" + PMD.EOL\n            + \" void bar(@SuppressWarnings('PMD') Integer foo) {}\" + PMD.EOL + \"}\";\n\n    private static final String TEST8 = \"public class Bar {\" + PMD.EOL + \" Integer foo;\" + PMD.EOL + \" void bar() {\"\n            + PMD.EOL + \"  @SuppressWarnings('PMD') Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST9 = \"public class Bar {\" + PMD.EOL + \" Integer foo;\" + PMD.EOL + \" void bar() {\"\n            + PMD.EOL + \"  @SuppressWarnings('PMD.NoFoo') Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST9_MULTIPLE_VALUES = \"@SuppressWarnings('PMD.NoFoo, PMD.NoBar')\"\n            + PMD.EOL + \"public class Bar {\" + PMD.EOL + \" Integer foo;\" + PMD.EOL + \" void bar() {\" + PMD.EOL\n            + \"  Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST10 = \"public class Bar {\" + PMD.EOL + \" Integer foo;\" + PMD.EOL + \" void bar() {\"\n            + PMD.EOL + \"  @SuppressWarnings('') Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST11 = \"public class Bar {\" + PMD.EOL + \" Integer foo;\" + PMD.EOL + \" void bar() {\"\n            + PMD.EOL + \"  @SuppressWarnings('SomethingElse') Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST12 = \"public class Bar {\" + PMD.EOL + \" @SuppressWarnings('all') Integer foo;\"\n            + PMD.EOL + \"}\";\n\n    private static final String TEST13 = \"@SuppressWarnings('PMD.NoBar')\" + PMD.EOL + \"public class Bar {\" + PMD.EOL\n            + \"}\";\n\n    private static final String TEST14 = \"public class Bar {\" + PMD.EOL + \"Integer foo; // NOPMD\" + PMD.EOL + \"}\";\n\n    private static final String TEST15 = \"public class Bar {\" + PMD.EOL + \"Integer foo; //NOPMD We allow foo here\" + PMD.EOL + \"}\";\n}\n",
        "filePathAfter": "pmd-apex/src/test/java/net/sourceforge/pmd/lang/apex/SuppressWarningsTest.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex;\n\nimport static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSize;\nimport static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSuppressed;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.List;\n\nimport org.junit.jupiter.api.Test;\n\nimport net.sourceforge.pmd.Report;\nimport net.sourceforge.pmd.ViolationSuppressor;\nimport net.sourceforge.pmd.lang.apex.ast.ASTUserClass;\nimport net.sourceforge.pmd.lang.apex.ast.ApexParserTestBase;\nimport net.sourceforge.pmd.lang.apex.rule.AbstractApexRule;\n\nclass SuppressWarningsTest extends ApexParserTestBase {\n\n    // This could be a regular xml test\n\n    private static class BarRule extends AbstractApexRule {\n\n        @Override\n        public String getMessage() {\n            return \"a message\";\n        }\n\n        @Override\n        public Object visit(ASTUserClass clazz, Object ctx) {\n            if (clazz.getSimpleName().equalsIgnoreCase(\"bar\")) {\n                addViolation(ctx, clazz);\n            }\n            return super.visit(clazz, ctx);\n        }\n\n        @Override\n        public String getName() {\n            return \"NoBar\";\n        }\n    }\n\n    @Test\n    void testClassLevelSuppression() {\n        assertNoWarningsWithFoo(\"@SuppressWarnings('PMD')\\n\"\n                                    + \"public class Foo {}\");\n    }\n\n    private void assertNoWarningsWithFoo(String code) {\n        assertWarningsWithFoo(0, code);\n    }\n\n    @Test\n    void testClassLevelSuppression2() {\n        assertNoWarningsWithFoo(\"@SuppressWarnings('PMD')\\n\"\n            + \"public class Foo {\" + \"\\n\"\n            + \" void bar() {\\n\"\n            + \"  Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testInheritedSuppression() {\n        assertNoWarningsWithFoo(\"public class Baz {\\n\"\n            + \" @SuppressWarnings('PMD')\" + \"\\n\"\n            + \" public class Bar {\\n\"\n            + \"  void bar() {\\n\"\n            + \"   Integer foo;\\n\"\n            + \"  }\" + \"\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testMethodLevelSuppression() {\n        assertWarningsWithFoo(1, \"public class Foo {\\n\" +\n            \" @SuppressWarnings('PMD')\\n\" +\n            \" void bar() {\\n\" +\n            \"  Integer foo;\\n\" +\n            \" }\\n\" +\n            \"}\");\n    }\n\n    @Test\n    void testConstructorLevelSuppression() {\n        assertNoWarningsWithFoo(\"public class Bar {\\n\"\n            + \" @SuppressWarnings('PMD')\" + \"\\n\"\n            + \" public Bar() {\\n\"\n            + \"  Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testFieldLevelSuppression() {\n        assertWarningsWithFoo(1, \"public class Bar {\\n\"\n            + \" @SuppressWarnings('PMD')\" + \"\\n\"\n            + \" Integer foo;\\n\"\n            + \" void bar() {\\n\"\n            + \"  Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testParameterLevelSuppression() {\n        assertWarningsWithFoo(1, \"public class Bar {\\n\"\n            + \" Integer foo;\" + \"\\n\"\n            + \" void bar(@SuppressWarnings('PMD') Integer foo) {}\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testLocalVariableLevelSuppression() {\n        assertWarningsWithFoo(1, \"public class Bar {\\n\"\n            + \" Integer foo;\\n\"\n            + \" void bar() {\"\n            + \"\\n\" + \"  @SuppressWarnings('PMD') Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testSpecificSuppression() {\n        assertWarningsWithFoo(1, \"public class Bar {\\n\"\n            + \" Integer foo;\\n\"\n            + \" void bar() {\"\n            + \"\\n\" + \"  @SuppressWarnings('PMD.NoFoo') Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testSpecificSuppressionMulitpleValues() {\n        assertNoWarningsWithFoo(\"@SuppressWarnings('PMD.NoFoo, PMD.NoBar')\"\n            + \"\\n\" + \"public class Bar {\\n\"\n            + \" Integer foo;\\n\"\n            + \" void bar() {\" + \"\\n\"\n            + \"  Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testNoSuppressionBlank() {\n        assertWarningsWithFoo(2, \"public class Bar {\\n\"\n            + \" Integer foo;\\n\"\n            + \" void bar() {\"\n            + \"\\n\" + \"  @SuppressWarnings('') Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    private void assertWarningsWithFoo(int size, String code) {\n        Report rpt = apex.executeRule(new FooRule(), code);\n        assertSize(rpt, size);\n    }\n\n    @Test\n    void testNoSuppressionSomethingElseS() {\n        assertWarningsWithFoo(2, \"public class Bar {\\n\"\n            + \" Integer foo;\\n\"\n            + \" void bar() {\"\n            + \"\\n\" + \"  @SuppressWarnings('SomethingElse') Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testSuppressAll() {\n        assertNoWarningsWithFoo(\"public class Bar {\\n\"\n            + \" @SuppressWarnings('all') Integer foo;\"\n            + \"\\n\" + \"}\");\n    }\n\n    @Test\n    void testSpecificSuppressionAtTopLevel() {\n        Report rpt = apex.executeRule(new BarRule(), \"@SuppressWarnings('PMD.NoBar')\\n\"\n            + \"public class Bar {\" + \"\\n\"\n            + \"}\");\n        assertSize(rpt, 0);\n    }\n\n    @Test\n    void testCommentSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), \"public class Bar {\\n\"\n            + \"Integer foo; // NOPMD\\n\"\n            + \"}\");\n        assertSize(rpt, 0);\n        assertSuppressed(rpt, 1);\n    }\n\n    @Test\n    void testMessageWithCommentSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), \"public class Bar {\\n\"\n            + \"Integer foo; //NOPMD We allow foo here\\n\"\n            + \"}\");\n        assertSize(rpt, 0);\n\n        List<Report.SuppressedViolation> suppressions = assertSuppressed(rpt, 1);\n        Report.SuppressedViolation suppression = suppressions.get(0);\n\n        assertEquals(ViolationSuppressor.NOPMD_COMMENT_SUPPRESSOR, suppression.getSuppressor());\n        assertEquals(\"We allow foo here\", suppression.getUserMessage());\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "private void assertWarningsWithFoo(int size, String code) {\n        Report rpt = apex.executeRule(new FooRule(), code);\n        assertSize(rpt, size);\n    }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "private void assertNoWarningsWithFoo(String code) {\n        assertWarningsWithFoo(0, code);\n    }\nprivate void assertWarningsWithFoo(int size, String code) {\n        Report rpt = apex.executeRule(new FooRule(), code);\n        assertSize(rpt, size);\n    }",
        "diffSourceCode": "-   52:         assertSize(rpt, 0);\n-   53:     }\n-   54: \n-   67:     @Test\n-   68:     void testConstructorLevelSuppression() {\n-   69:         Report rpt = apex.executeRule(new FooRule(), TEST5);\n-   70:         assertSize(rpt, 0);\n-   71:     }\n-  158:     private static final String TEST5 = \"public class Bar {\" + PMD.EOL + \" @SuppressWarnings('PMD')\" + PMD.EOL\n-  159:             + \" public Bar() {\" + PMD.EOL + \"  Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n-  160: \n-  161:     private static final String TEST6 = \"public class Bar {\" + PMD.EOL + \" @SuppressWarnings('PMD')\" + PMD.EOL\n+   52:     private void assertNoWarningsWithFoo(String code) {\n+   53:         assertWarningsWithFoo(0, code);\n+   54:     }\n+   67:     void testInheritedSuppression() {\n+   68:         assertNoWarningsWithFoo(\"public class Baz {\\n\"\n+   69:             + \" @SuppressWarnings('PMD')\" + \"\\n\"\n+   70:             + \" public class Bar {\\n\"\n+   71:             + \"  void bar() {\\n\"\n+  158:     private void assertWarningsWithFoo(int size, String code) {\n+  159:         Report rpt = apex.executeRule(new FooRule(), code);\n+  160:         assertSize(rpt, size);\n+  161:     }\n",
        "uniqueId": "b25c16f94d8d7c998e391eecb3ae06ac8be2aa32_67_71_158_161_52_54",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate assertWarningsWithFoo(size int, code String) : void extracted from package testInheritedSuppression() : void in class net.sourceforge.pmd.lang.apex.SuppressWarningsTest",
        "diffLocations": [
            {
                "filePath": "pmd-apex/src/test/java/net/sourceforge/pmd/lang/apex/SuppressWarningsTest.java",
                "startLine": 55,
                "endLine": 59,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-apex/src/test/java/net/sourceforge/pmd/lang/apex/SuppressWarningsTest.java",
                "startLine": 52,
                "endLine": 54,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-apex/src/test/java/net/sourceforge/pmd/lang/apex/SuppressWarningsTest.java",
                "startLine": 158,
                "endLine": 161,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n    void testInheritedSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST3);\n        assertSize(rpt, 0);\n    }",
        "filePathBefore": "pmd-apex/src/test/java/net/sourceforge/pmd/lang/apex/SuppressWarningsTest.java",
        "isPureRefactoring": true,
        "commitId": "b25c16f94d8d7c998e391eecb3ae06ac8be2aa32",
        "packageNameBefore": "net.sourceforge.pmd.lang.apex",
        "classNameBefore": "net.sourceforge.pmd.lang.apex.SuppressWarningsTest",
        "methodNameBefore": "net.sourceforge.pmd.lang.apex.SuppressWarningsTest#testInheritedSuppression",
        "classSignatureBefore": "class SuppressWarningsTest extends ApexParserTestBase ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.apex.SuppressWarningsTest#testInheritedSuppression"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.apex.SuppressWarningsTest"
        ],
        "classSignatureBeforeSet": [
            "class SuppressWarningsTest extends ApexParserTestBase "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics\nOverlapped refactoring - can be identical by undoing the overlapped refactoring\n- Rename Variable-",
                "description": "Rename Variable on top of the extract method - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex;\n\nimport static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSize;\nimport static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSuppressed;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.List;\n\nimport org.junit.jupiter.api.Test;\n\nimport net.sourceforge.pmd.PMD;\nimport net.sourceforge.pmd.Report;\nimport net.sourceforge.pmd.ViolationSuppressor;\nimport net.sourceforge.pmd.lang.apex.ast.ASTUserClass;\nimport net.sourceforge.pmd.lang.apex.ast.ApexParserTestBase;\nimport net.sourceforge.pmd.lang.apex.rule.AbstractApexRule;\n\nclass SuppressWarningsTest extends ApexParserTestBase {\n\n    // This could be a regular xml test\n\n    private static class BarRule extends AbstractApexRule {\n\n        @Override\n        public String getMessage() {\n            return \"a message\";\n        }\n\n        @Override\n        public Object visit(ASTUserClass clazz, Object ctx) {\n            if (clazz.getSimpleName().equalsIgnoreCase(\"bar\")) {\n                addViolation(ctx, clazz);\n            }\n            return super.visit(clazz, ctx);\n        }\n\n        @Override\n        public String getName() {\n            return \"NoBar\";\n        }\n    }\n\n    @Test\n    void testClassLevelSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST1);\n        assertSize(rpt, 0);\n        rpt = apex.executeRule(new FooRule(), TEST2);\n        assertSize(rpt, 0);\n    }\n\n    @Test\n    void testInheritedSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST3);\n        assertSize(rpt, 0);\n    }\n\n    @Test\n    void testMethodLevelSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST4);\n        assertSize(rpt, 1);\n    }\n\n    @Test\n    void testConstructorLevelSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST5);\n        assertSize(rpt, 0);\n    }\n\n    @Test\n    void testFieldLevelSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST6);\n        assertSize(rpt, 1);\n    }\n\n    @Test\n    void testParameterLevelSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST7);\n        assertSize(rpt, 1);\n    }\n\n    @Test\n    void testLocalVariableLevelSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST8);\n        assertSize(rpt, 1);\n    }\n\n    @Test\n    void testSpecificSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST9);\n        assertSize(rpt, 1);\n    }\n\n    @Test\n    void testSpecificSuppressionMulitpleValues() {\n        Report rpt = apex.executeRule(new FooRule(), TEST9_MULTIPLE_VALUES);\n        assertSize(rpt, 0);\n    }\n\n    @Test\n    void testNoSuppressionBlank() {\n        Report rpt = apex.executeRule(new FooRule(), TEST10);\n        assertSize(rpt, 2);\n    }\n\n    @Test\n    void testNoSuppressionSomethingElseS() {\n        Report rpt = apex.executeRule(new FooRule(), TEST11);\n        assertSize(rpt, 2);\n    }\n\n    @Test\n    void testSuppressAll() {\n        Report rpt = apex.executeRule(new FooRule(), TEST12);\n        assertSize(rpt, 0);\n    }\n\n    @Test\n    void testSpecificSuppressionAtTopLevel() {\n        Report rpt = apex.executeRule(new BarRule(), TEST13);\n        assertSize(rpt, 0);\n    }\n\n    @Test\n    void testCommentSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST14);\n        assertSize(rpt, 0);\n        assertSuppressed(rpt, 1);\n    }\n\n    @Test\n    void testMessageWithCommentSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), TEST15);\n        assertSize(rpt, 0);\n\n        List<Report.SuppressedViolation> suppressions = assertSuppressed(rpt, 1);\n        Report.SuppressedViolation suppression = suppressions.get(0);\n\n        assertEquals(ViolationSuppressor.NOPMD_COMMENT_SUPPRESSOR, suppression.getSuppressor());\n        assertEquals(\"We allow foo here\", suppression.getUserMessage());\n    }\n\n    private static final String TEST1 = \"@SuppressWarnings('PMD')\" + PMD.EOL + \"public class Foo {}\";\n\n    private static final String TEST2 = \"@SuppressWarnings('PMD')\" + PMD.EOL + \"public class Foo {\" + PMD.EOL\n            + \" void bar() {\" + PMD.EOL + \"  Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST3 = \"public class Baz {\" + PMD.EOL + \" @SuppressWarnings('PMD')\" + PMD.EOL\n            + \" public class Bar {\" + PMD.EOL + \"  void bar() {\" + PMD.EOL + \"   Integer foo;\" + PMD.EOL + \"  }\" + PMD.EOL\n            + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST4 = \"public class Foo {\" + PMD.EOL + \" @SuppressWarnings('PMD')\" + PMD.EOL\n            + \" void bar() {\" + PMD.EOL + \"  Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST5 = \"public class Bar {\" + PMD.EOL + \" @SuppressWarnings('PMD')\" + PMD.EOL\n            + \" public Bar() {\" + PMD.EOL + \"  Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST6 = \"public class Bar {\" + PMD.EOL + \" @SuppressWarnings('PMD')\" + PMD.EOL\n            + \" Integer foo;\" + PMD.EOL + \" void bar() {\" + PMD.EOL + \"  Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST7 = \"public class Bar {\" + PMD.EOL + \" Integer foo;\" + PMD.EOL\n            + \" void bar(@SuppressWarnings('PMD') Integer foo) {}\" + PMD.EOL + \"}\";\n\n    private static final String TEST8 = \"public class Bar {\" + PMD.EOL + \" Integer foo;\" + PMD.EOL + \" void bar() {\"\n            + PMD.EOL + \"  @SuppressWarnings('PMD') Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST9 = \"public class Bar {\" + PMD.EOL + \" Integer foo;\" + PMD.EOL + \" void bar() {\"\n            + PMD.EOL + \"  @SuppressWarnings('PMD.NoFoo') Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST9_MULTIPLE_VALUES = \"@SuppressWarnings('PMD.NoFoo, PMD.NoBar')\"\n            + PMD.EOL + \"public class Bar {\" + PMD.EOL + \" Integer foo;\" + PMD.EOL + \" void bar() {\" + PMD.EOL\n            + \"  Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST10 = \"public class Bar {\" + PMD.EOL + \" Integer foo;\" + PMD.EOL + \" void bar() {\"\n            + PMD.EOL + \"  @SuppressWarnings('') Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST11 = \"public class Bar {\" + PMD.EOL + \" Integer foo;\" + PMD.EOL + \" void bar() {\"\n            + PMD.EOL + \"  @SuppressWarnings('SomethingElse') Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n\n    private static final String TEST12 = \"public class Bar {\" + PMD.EOL + \" @SuppressWarnings('all') Integer foo;\"\n            + PMD.EOL + \"}\";\n\n    private static final String TEST13 = \"@SuppressWarnings('PMD.NoBar')\" + PMD.EOL + \"public class Bar {\" + PMD.EOL\n            + \"}\";\n\n    private static final String TEST14 = \"public class Bar {\" + PMD.EOL + \"Integer foo; // NOPMD\" + PMD.EOL + \"}\";\n\n    private static final String TEST15 = \"public class Bar {\" + PMD.EOL + \"Integer foo; //NOPMD We allow foo here\" + PMD.EOL + \"}\";\n}\n",
        "filePathAfter": "pmd-apex/src/test/java/net/sourceforge/pmd/lang/apex/SuppressWarningsTest.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex;\n\nimport static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSize;\nimport static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSuppressed;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.List;\n\nimport org.junit.jupiter.api.Test;\n\nimport net.sourceforge.pmd.Report;\nimport net.sourceforge.pmd.ViolationSuppressor;\nimport net.sourceforge.pmd.lang.apex.ast.ASTUserClass;\nimport net.sourceforge.pmd.lang.apex.ast.ApexParserTestBase;\nimport net.sourceforge.pmd.lang.apex.rule.AbstractApexRule;\n\nclass SuppressWarningsTest extends ApexParserTestBase {\n\n    // This could be a regular xml test\n\n    private static class BarRule extends AbstractApexRule {\n\n        @Override\n        public String getMessage() {\n            return \"a message\";\n        }\n\n        @Override\n        public Object visit(ASTUserClass clazz, Object ctx) {\n            if (clazz.getSimpleName().equalsIgnoreCase(\"bar\")) {\n                addViolation(ctx, clazz);\n            }\n            return super.visit(clazz, ctx);\n        }\n\n        @Override\n        public String getName() {\n            return \"NoBar\";\n        }\n    }\n\n    @Test\n    void testClassLevelSuppression() {\n        assertNoWarningsWithFoo(\"@SuppressWarnings('PMD')\\n\"\n                                    + \"public class Foo {}\");\n    }\n\n    private void assertNoWarningsWithFoo(String code) {\n        assertWarningsWithFoo(0, code);\n    }\n\n    @Test\n    void testClassLevelSuppression2() {\n        assertNoWarningsWithFoo(\"@SuppressWarnings('PMD')\\n\"\n            + \"public class Foo {\" + \"\\n\"\n            + \" void bar() {\\n\"\n            + \"  Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testInheritedSuppression() {\n        assertNoWarningsWithFoo(\"public class Baz {\\n\"\n            + \" @SuppressWarnings('PMD')\" + \"\\n\"\n            + \" public class Bar {\\n\"\n            + \"  void bar() {\\n\"\n            + \"   Integer foo;\\n\"\n            + \"  }\" + \"\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testMethodLevelSuppression() {\n        assertWarningsWithFoo(1, \"public class Foo {\\n\" +\n            \" @SuppressWarnings('PMD')\\n\" +\n            \" void bar() {\\n\" +\n            \"  Integer foo;\\n\" +\n            \" }\\n\" +\n            \"}\");\n    }\n\n    @Test\n    void testConstructorLevelSuppression() {\n        assertNoWarningsWithFoo(\"public class Bar {\\n\"\n            + \" @SuppressWarnings('PMD')\" + \"\\n\"\n            + \" public Bar() {\\n\"\n            + \"  Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testFieldLevelSuppression() {\n        assertWarningsWithFoo(1, \"public class Bar {\\n\"\n            + \" @SuppressWarnings('PMD')\" + \"\\n\"\n            + \" Integer foo;\\n\"\n            + \" void bar() {\\n\"\n            + \"  Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testParameterLevelSuppression() {\n        assertWarningsWithFoo(1, \"public class Bar {\\n\"\n            + \" Integer foo;\" + \"\\n\"\n            + \" void bar(@SuppressWarnings('PMD') Integer foo) {}\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testLocalVariableLevelSuppression() {\n        assertWarningsWithFoo(1, \"public class Bar {\\n\"\n            + \" Integer foo;\\n\"\n            + \" void bar() {\"\n            + \"\\n\" + \"  @SuppressWarnings('PMD') Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testSpecificSuppression() {\n        assertWarningsWithFoo(1, \"public class Bar {\\n\"\n            + \" Integer foo;\\n\"\n            + \" void bar() {\"\n            + \"\\n\" + \"  @SuppressWarnings('PMD.NoFoo') Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testSpecificSuppressionMulitpleValues() {\n        assertNoWarningsWithFoo(\"@SuppressWarnings('PMD.NoFoo, PMD.NoBar')\"\n            + \"\\n\" + \"public class Bar {\\n\"\n            + \" Integer foo;\\n\"\n            + \" void bar() {\" + \"\\n\"\n            + \"  Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testNoSuppressionBlank() {\n        assertWarningsWithFoo(2, \"public class Bar {\\n\"\n            + \" Integer foo;\\n\"\n            + \" void bar() {\"\n            + \"\\n\" + \"  @SuppressWarnings('') Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    private void assertWarningsWithFoo(int size, String code) {\n        Report rpt = apex.executeRule(new FooRule(), code);\n        assertSize(rpt, size);\n    }\n\n    @Test\n    void testNoSuppressionSomethingElseS() {\n        assertWarningsWithFoo(2, \"public class Bar {\\n\"\n            + \" Integer foo;\\n\"\n            + \" void bar() {\"\n            + \"\\n\" + \"  @SuppressWarnings('SomethingElse') Integer foo;\\n\"\n            + \" }\\n\"\n            + \"}\");\n    }\n\n    @Test\n    void testSuppressAll() {\n        assertNoWarningsWithFoo(\"public class Bar {\\n\"\n            + \" @SuppressWarnings('all') Integer foo;\"\n            + \"\\n\" + \"}\");\n    }\n\n    @Test\n    void testSpecificSuppressionAtTopLevel() {\n        Report rpt = apex.executeRule(new BarRule(), \"@SuppressWarnings('PMD.NoBar')\\n\"\n            + \"public class Bar {\" + \"\\n\"\n            + \"}\");\n        assertSize(rpt, 0);\n    }\n\n    @Test\n    void testCommentSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), \"public class Bar {\\n\"\n            + \"Integer foo; // NOPMD\\n\"\n            + \"}\");\n        assertSize(rpt, 0);\n        assertSuppressed(rpt, 1);\n    }\n\n    @Test\n    void testMessageWithCommentSuppression() {\n        Report rpt = apex.executeRule(new FooRule(), \"public class Bar {\\n\"\n            + \"Integer foo; //NOPMD We allow foo here\\n\"\n            + \"}\");\n        assertSize(rpt, 0);\n\n        List<Report.SuppressedViolation> suppressions = assertSuppressed(rpt, 1);\n        Report.SuppressedViolation suppression = suppressions.get(0);\n\n        assertEquals(ViolationSuppressor.NOPMD_COMMENT_SUPPRESSOR, suppression.getSuppressor());\n        assertEquals(\"We allow foo here\", suppression.getUserMessage());\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "private void assertWarningsWithFoo(int size, String code) {\n        Report rpt = apex.executeRule(new FooRule(), code);\n        assertSize(rpt, size);\n    }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "private void assertNoWarningsWithFoo(String code) {\n        assertWarningsWithFoo(0, code);\n    }\nprivate void assertWarningsWithFoo(int size, String code) {\n        Report rpt = apex.executeRule(new FooRule(), code);\n        assertSize(rpt, size);\n    }",
        "diffSourceCode": "-   52:         assertSize(rpt, 0);\n-   53:     }\n-   54: \n-   55:     @Test\n-   56:     void testInheritedSuppression() {\n-   57:         Report rpt = apex.executeRule(new FooRule(), TEST3);\n-   58:         assertSize(rpt, 0);\n-   59:     }\n-  158:     private static final String TEST5 = \"public class Bar {\" + PMD.EOL + \" @SuppressWarnings('PMD')\" + PMD.EOL\n-  159:             + \" public Bar() {\" + PMD.EOL + \"  Integer foo;\" + PMD.EOL + \" }\" + PMD.EOL + \"}\";\n-  160: \n-  161:     private static final String TEST6 = \"public class Bar {\" + PMD.EOL + \" @SuppressWarnings('PMD')\" + PMD.EOL\n+   52:     private void assertNoWarningsWithFoo(String code) {\n+   53:         assertWarningsWithFoo(0, code);\n+   54:     }\n+   55: \n+   56:     @Test\n+   57:     void testClassLevelSuppression2() {\n+   58:         assertNoWarningsWithFoo(\"@SuppressWarnings('PMD')\\n\"\n+   59:             + \"public class Foo {\" + \"\\n\"\n+  158:     private void assertWarningsWithFoo(int size, String code) {\n+  159:         Report rpt = apex.executeRule(new FooRule(), code);\n+  160:         assertSize(rpt, size);\n+  161:     }\n",
        "uniqueId": "b25c16f94d8d7c998e391eecb3ae06ac8be2aa32_55_59_158_161_52_54",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Move Method",
        "description": "Move Method\tpublic getVersionWithParserThatThrowsSemanticError() : LanguageVersion from class net.sourceforge.pmd.lang.DummyLanguageModule to public getVersionWithParserThatThrowsSemanticError() : LanguageVersion from class net.sourceforge.pmd.processor.PmdRunnableTest",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/lang/DummyLanguageModule.java",
                "startLine": 51,
                "endLine": 53,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/processor/PmdRunnableTest.java",
                "startLine": 160,
                "endLine": 162,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public LanguageVersion getVersionWithParserThatThrowsSemanticError() {\n        return getVersion(THROWS_SEMANTIC_ERROR);\n    }",
        "filePathBefore": "pmd-core/src/test/java/net/sourceforge/pmd/lang/DummyLanguageModule.java",
        "isPureRefactoring": true,
        "commitId": "ff2f5ef93c1b3150583e9611b2a8fd8159e3aa66",
        "packageNameBefore": "net.sourceforge.pmd.lang",
        "classNameBefore": "net.sourceforge.pmd.lang.DummyLanguageModule",
        "methodNameBefore": "net.sourceforge.pmd.lang.DummyLanguageModule#getVersionWithParserThatThrowsSemanticError",
        "classSignatureBefore": "public class DummyLanguageModule extends BaseLanguageModule ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.DummyLanguageModule#getVersionWithParserThatThrowsSemanticError"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.DummyLanguageModule"
        ],
        "classSignatureBeforeSet": [
            "public class DummyLanguageModule extends BaseLanguageModule "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Move Method refactoring mechanics\n",
                "description": "Move Method specific changes - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\n\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RuleViolation;\nimport net.sourceforge.pmd.lang.ast.DummyNode;\nimport net.sourceforge.pmd.lang.ast.DummyNode.DummyRootNode;\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.ast.ParseException;\nimport net.sourceforge.pmd.lang.ast.Parser;\nimport net.sourceforge.pmd.lang.ast.RootNode;\nimport net.sourceforge.pmd.lang.ast.SourceCodePositioner;\nimport net.sourceforge.pmd.lang.rule.ParametricRuleViolation;\nimport net.sourceforge.pmd.lang.rule.impl.DefaultRuleViolationFactory;\n\n/**\n * Dummy language used for testing PMD.\n */\npublic class DummyLanguageModule extends BaseLanguageModule {\n\n    public static final String NAME = \"Dummy\";\n    public static final String TERSE_NAME = \"dummy\";\n    private static final String PARSER_REPORTS_SEMANTIC_ERROR = \"1.9-semantic_error\";\n    private static final String THROWS_SEMANTIC_ERROR = \"1.9-throws_semantic_error\";\n    private static final String THROWS_ASSERTION_ERROR = \"1.9-throws\";\n\n    public DummyLanguageModule() {\n        super(NAME, null, TERSE_NAME, \"dummy\");\n        addVersion(\"1.0\", new Handler());\n        addVersion(\"1.1\", new Handler());\n        addVersion(\"1.2\", new Handler());\n        addVersion(\"1.3\", new Handler());\n        addVersion(\"1.4\", new Handler());\n        addVersion(\"1.5\", new Handler(), \"5\");\n        addVersion(\"1.6\", new Handler(), \"6\");\n        addDefaultVersion(\"1.7\", new Handler(), \"7\");\n        addVersion(\"1.8\", new Handler(), \"8\");\n        addVersion(THROWS_ASSERTION_ERROR, new HandlerWithParserThatThrows());\n        addVersion(PARSER_REPORTS_SEMANTIC_ERROR, new HandlerWithParserThatReportsSemanticError());\n        addVersion(THROWS_SEMANTIC_ERROR, new HandlerWithParserThatThrowsSemanticError());\n    }\n\n    public LanguageVersion getVersionWithParserThatThrowsAssertionError() {\n        return getVersion(THROWS_ASSERTION_ERROR);\n    }\n    public LanguageVersion getVersionWithParserThatThrowsSemanticError() {\n        return getVersion(THROWS_SEMANTIC_ERROR);\n    }\n    public LanguageVersion getVersionWithParserThatReportsSemanticError() {\n        return getVersion(PARSER_REPORTS_SEMANTIC_ERROR);\n    }\n\n    public static DummyLanguageModule getInstance() {\n        return (DummyLanguageModule) LanguageRegistry.getLanguage(NAME);\n    }\n\n    public static DummyRootNode parse(String code) {\n        return parse(code, \"nofilename\");\n    }\n\n    public static DummyRootNode parse(String code, String filename) {\n        DummyRootNode rootNode = readLispNode(code);\n        rootNode.withFileName(filename);\n        return rootNode;\n    }\n\n\n    public static class Handler extends AbstractPmdLanguageVersionHandler {\n        @Override\n        public RuleViolationFactory getRuleViolationFactory() {\n            return new RuleViolationFactory();\n        }\n\n        @Override\n        public Parser getParser() {\n            return task -> {\n                DummyRootNode rootNode = readLispNode(task.getSourceText());\n                rootNode.withFileName(task.getFileDisplayName());\n                rootNode.withLanguage(task.getLanguageVersion());\n                rootNode.withSourceText(task.getSourceText());\n                return rootNode;\n            };\n        }\n    }\n\n    public static class HandlerWithParserThatThrows extends Handler {\n        @Override\n        public Parser getParser() {\n            return task -> {\n                throw new AssertionError(\"test error while parsing\");\n            };\n        }\n    }\n\n    public static class HandlerWithParserThatReportsSemanticError extends Handler {\n        @Override\n        public Parser getParser() {\n            return task -> {\n                RootNode root = super.getParser().parse(task);\n                task.getReporter().error(root, \"An error occurred!\");\n                return root;\n            };\n        }\n    }\n\n    public static class HandlerWithParserThatThrowsSemanticError extends Handler {\n        @Override\n        public Parser getParser() {\n            return task -> {\n                RootNode root = super.getParser().parse(task);\n                throw task.getReporter().error(root, \"An error occurred!\");\n            };\n        }\n    }\n\n    /**\n     * Creates a tree of nodes that corresponds to the nesting structures\n     * of parentheses in the text. The image of each node is also populated.\n     * This is useful to create non-trivial trees with all the relevant\n     * data (eg coordinates) set properly.\n     *\n     * Eg {@code (a(b)x(c))} will create a tree with a node \"a\", with two\n     * children \"b\" and \"c\". \"x\" is ignored. The node \"a\" is not the root\n     * node, it has a {@link DummyRootNode} as parent, whose image is \"\".\n     */\n    private static DummyRootNode readLispNode(String text) {\n        final DummyRootNode root = new DummyRootNode().withSourceText(text);\n        DummyNode top = root;\n        SourceCodePositioner positioner = new SourceCodePositioner(text);\n        top.setCoords(1, 1, positioner.getLastLine(), positioner.getLastLineColumn());\n        int lastNodeStart = 0;\n        for (int i = 0; i < text.length(); i++) {\n            char c = text.charAt(i);\n            if (c == '(') {\n                DummyNode node = new DummyNode();\n                node.setParent(top);\n                top.addChild(node, top.getNumChildren());\n                // setup coordinates\n                int bline = positioner.lineNumberFromOffset(i);\n                int bcol = positioner.columnFromOffset(bline, i);\n                node.setCoords(bline, bcol, bline, bcol);\n                // cut out image\n                if (top.getImage() == null) {\n                    // image may be non null if this is not the first child of 'top'\n                    // eg in (a(b)x(c)), the image of the parent is set to \"a\".\n                    // When we're processing \"(c\", we ignore \"x\".\n                    String image = text.substring(lastNodeStart, i);\n                    top.setImage(image);\n                }\n                lastNodeStart = i + 1;\n                // node is the top of the stack now\n                top = node;\n            } else if (c == ')') {\n                if (top == null) {\n                    throw new ParseException(\"Unbalanced parentheses: \" + text);\n                }\n                // setup coordinates\n                int eline = positioner.lineNumberFromOffset(i);\n                int ecol = positioner.columnFromOffset(eline, i);\n                top.setCoords(top.getBeginLine(), top.getBeginColumn(), eline, ecol);\n\n                if (top.getImage() == null) {\n                    // cut out image (if node doesn't have children it hasn't been populated yet)\n                    String image = text.substring(lastNodeStart, i);\n                    top.setImage(image);\n                    lastNodeStart = i + 1;\n                }\n                top = top.getParent();\n            }\n        }\n        if (top != root) {\n            throw new ParseException(\"Unbalanced parentheses: \" + text);\n        }\n        return root;\n    }\n\n    public static class RuleViolationFactory extends DefaultRuleViolationFactory {\n\n        @Override\n        public RuleViolation createViolation(Rule rule, @NonNull Node location, @NonNull String formattedMessage) {\n            return new ParametricRuleViolation<Node>(rule, location, formattedMessage) {\n                {\n                    this.packageName = \"foo\"; // just for testing variable expansion\n                }\n            };\n        }\n    }\n}\n",
        "filePathAfter": "pmd-core/src/test/java/net/sourceforge/pmd/processor/PmdRunnableTest.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.processor;\n\nimport static org.hamcrest.CoreMatchers.instanceOf;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.hasSize;\nimport static org.mockito.Mockito.contains;\nimport static org.mockito.Mockito.eq;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.spy;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\n\nimport java.util.List;\nimport java.util.function.BiConsumer;\n\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.contrib.java.lang.system.RestoreSystemProperties;\nimport org.junit.rules.TestRule;\nimport org.mockito.Mockito;\nimport org.slf4j.event.Level;\n\nimport net.sourceforge.pmd.PMDConfiguration;\nimport net.sourceforge.pmd.Report;\nimport net.sourceforge.pmd.Report.GlobalReportBuilderListener;\nimport net.sourceforge.pmd.Report.ProcessingError;\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RuleContext;\nimport net.sourceforge.pmd.RuleSet;\nimport net.sourceforge.pmd.RuleSets;\nimport net.sourceforge.pmd.internal.SystemProps;\nimport net.sourceforge.pmd.internal.util.ContextedAssertionError;\nimport net.sourceforge.pmd.lang.DummyLanguageModule;\nimport net.sourceforge.pmd.lang.DummyLanguageModule.Handler;\nimport net.sourceforge.pmd.lang.Language;\nimport net.sourceforge.pmd.lang.LanguageRegistry;\nimport net.sourceforge.pmd.lang.LanguageVersion;\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.ast.Parser;\nimport net.sourceforge.pmd.lang.ast.RootNode;\nimport net.sourceforge.pmd.lang.rule.AbstractRule;\nimport net.sourceforge.pmd.processor.MonoThreadProcessor.MonothreadRunnable;\nimport net.sourceforge.pmd.util.datasource.DataSource;\nimport net.sourceforge.pmd.util.log.MessageReporter;\n\npublic class PmdRunnableTest {\n\n    public static final String TEST_MESSAGE_SEMANTIC_ERROR = \"An error occurred!\";\n    private static final String PARSER_REPORTS_SEMANTIC_ERROR = \"1.9-semantic_error\";\n    private static final String THROWS_SEMANTIC_ERROR = \"1.9-throws_semantic_error\";\n    private static final String THROWS_ASSERTION_ERROR = \"1.9-throws\";\n\n\n    @org.junit.Rule\n    public TestRule restoreSystemProperties = new RestoreSystemProperties();\n\n\n    private final DummyLanguageModule dummyLang = DummyLanguageModule.getInstance();\n\n    private PMDConfiguration configuration;\n    private PmdRunnable pmdRunnable;\n    private GlobalReportBuilderListener reportBuilder;\n    private MessageReporter reporter;\n    private Rule rule;\n\n    @Before\n    public void prepare() {\n        DataSource dataSource = DataSource.forString(\"test\", \"test.dummy\");\n\n\n        rule = spy(new RuleThatThrows());\n        configuration = new PMDConfiguration();\n        reportBuilder = new GlobalReportBuilderListener();\n        reporter = mock(MessageReporter.class);\n        configuration.setReporter(reporter);\n        pmdRunnable = new MonothreadRunnable(new RuleSets(RuleSet.forSingleRule(rule)),\n                                             dataSource,\n                                             reportBuilder,\n                                             configuration);\n\n    }\n\n    @Test\n    public void inErrorRecoveryModeErrorsShouldBeLoggedByParser() {\n        System.setProperty(SystemProps.PMD_ERROR_RECOVERY, \"\");\n        configuration.setDefaultLanguageVersion(versionWithParserThatThrowsAssertionError());\n\n        pmdRunnable.run();\n        reportBuilder.close();\n        Assert.assertEquals(1, reportBuilder.getResult().getProcessingErrors().size());\n    }\n\n    @Test\n    public void inErrorRecoveryModeErrorsShouldBeLoggedByRule() {\n        System.setProperty(SystemProps.PMD_ERROR_RECOVERY, \"\");\n        configuration.setDefaultLanguageVersion(dummyLang.getDefaultVersion());\n\n        pmdRunnable.run();\n        reportBuilder.close();\n        Report report = reportBuilder.getResult();\n        List<ProcessingError> errors = report.getProcessingErrors();\n        assertThat(errors, hasSize(1));\n        assertThat(errors.get(0).getError(), instanceOf(ContextedAssertionError.class));\n    }\n\n    @Test\n    public void withoutErrorRecoveryModeProcessingShouldBeAbortedByParser() {\n        Assert.assertNull(System.getProperty(SystemProps.PMD_ERROR_RECOVERY));\n        configuration.setDefaultLanguageVersion(versionWithParserThatThrowsAssertionError());\n\n        Assert.assertThrows(AssertionError.class, pmdRunnable::run);\n    }\n\n    @Test\n    public void withoutErrorRecoveryModeProcessingShouldBeAbortedByRule() {\n        Assert.assertNull(System.getProperty(SystemProps.PMD_ERROR_RECOVERY));\n        configuration.setDefaultLanguageVersion(dummyLang.getDefaultVersion());\n\n        Assert.assertThrows(AssertionError.class, pmdRunnable::run);\n    }\n\n\n    @Test\n    public void semanticErrorShouldAbortTheRun() {\n        configuration.setDefaultLanguageVersion(versionWithParserThatReportsSemanticError());\n\n        pmdRunnable.run();\n\n        verify(reporter).log(eq(Level.INFO), contains(\"skipping rule analysis\"));\n        verify(rule, never()).apply(Mockito.any(), Mockito.any());\n    }\n\n    @Test\n    public void semanticErrorThrownShouldAbortTheRun() {\n        configuration.setDefaultLanguageVersion(getVersionWithParserThatThrowsSemanticError());\n\n        pmdRunnable.run();\n\n        verify(reporter, times(1)).log(eq(Level.ERROR), contains(TEST_MESSAGE_SEMANTIC_ERROR));\n        verify(rule, never()).apply(Mockito.any(), Mockito.any());\n    }\n\n    public static void registerCustomVersions(BiConsumer<String, Handler> addVersion) {\n        addVersion.accept(THROWS_ASSERTION_ERROR, new HandlerWithParserThatThrows());\n        addVersion.accept(PARSER_REPORTS_SEMANTIC_ERROR, new HandlerWithParserThatReportsSemanticError());\n        addVersion.accept(THROWS_SEMANTIC_ERROR, new HandlerWithParserThatThrowsSemanticError());\n\n    }\n\n    public LanguageVersion versionWithParserThatThrowsAssertionError() {\n        return dummyLang.getVersion(THROWS_ASSERTION_ERROR);\n    }\n\n    public LanguageVersion getVersionWithParserThatThrowsSemanticError() {\n        return dummyLang.getVersion(THROWS_SEMANTIC_ERROR);\n    }\n\n    public LanguageVersion versionWithParserThatReportsSemanticError() {\n        return dummyLang.getVersion(PARSER_REPORTS_SEMANTIC_ERROR);\n    }\n\n    private static class RuleThatThrows extends AbstractRule {\n\n        RuleThatThrows() {\n            Language dummyLanguage = LanguageRegistry.findLanguageByTerseName(DummyLanguageModule.TERSE_NAME);\n            setLanguage(dummyLanguage);\n        }\n\n        @Override\n        public void apply(Node target, RuleContext ctx) {\n            throw new AssertionError(\"test\");\n        }\n    }\n\n    public static class HandlerWithParserThatThrowsSemanticError extends Handler {\n\n        @Override\n        public Parser getParser() {\n            return task -> {\n                RootNode root = super.getParser().parse(task);\n                throw task.getReporter().error(root, TEST_MESSAGE_SEMANTIC_ERROR);\n            };\n        }\n    }\n\n    public static class HandlerWithParserThatThrows extends Handler {\n\n        @Override\n        public Parser getParser() {\n            return task -> {\n                throw new AssertionError(\"test error while parsing\");\n            };\n        }\n    }\n\n    public static class HandlerWithParserThatReportsSemanticError extends Handler {\n\n        @Override\n        public Parser getParser() {\n            return task -> {\n                RootNode root = super.getParser().parse(task);\n                task.getReporter().error(root, TEST_MESSAGE_SEMANTIC_ERROR);\n                return root;\n            };\n        }\n    }\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "public LanguageVersion getVersionWithParserThatThrowsSemanticError() {\n        return dummyLang.getVersion(THROWS_SEMANTIC_ERROR);\n    }",
        "diffSourceCode": "-   51:     public LanguageVersion getVersionWithParserThatThrowsSemanticError() {\n-   52:         return getVersion(THROWS_SEMANTIC_ERROR);\n-   53:     }\n-  160:                     throw new ParseException(\"Unbalanced parentheses: \" + text);\n-  161:                 }\n-  162:                 // setup coordinates\n+   51: \n+   52: public class PmdRunnableTest {\n+   53: \n+  160:     public LanguageVersion getVersionWithParserThatThrowsSemanticError() {\n+  161:         return dummyLang.getVersion(THROWS_SEMANTIC_ERROR);\n+  162:     }\n",
        "uniqueId": "ff2f5ef93c1b3150583e9611b2a8fd8159e3aa66_51_53__160_162",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Move And Rename Method",
        "description": "Move And Rename Method\tpublic getVersionWithParserThatThrowsAssertionError() : LanguageVersion from class net.sourceforge.pmd.lang.DummyLanguageModule to public versionWithParserThatThrowsAssertionError() : LanguageVersion from class net.sourceforge.pmd.processor.PmdRunnableTest",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/lang/DummyLanguageModule.java",
                "startLine": 48,
                "endLine": 50,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/processor/PmdRunnableTest.java",
                "startLine": 156,
                "endLine": 158,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public LanguageVersion getVersionWithParserThatThrowsAssertionError() {\n        return getVersion(THROWS_ASSERTION_ERROR);\n    }",
        "filePathBefore": "pmd-core/src/test/java/net/sourceforge/pmd/lang/DummyLanguageModule.java",
        "isPureRefactoring": true,
        "commitId": "ff2f5ef93c1b3150583e9611b2a8fd8159e3aa66",
        "packageNameBefore": "net.sourceforge.pmd.lang",
        "classNameBefore": "net.sourceforge.pmd.lang.DummyLanguageModule",
        "methodNameBefore": "net.sourceforge.pmd.lang.DummyLanguageModule#getVersionWithParserThatThrowsAssertionError",
        "classSignatureBefore": "public class DummyLanguageModule extends BaseLanguageModule ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.DummyLanguageModule#getVersionWithParserThatThrowsAssertionError"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.DummyLanguageModule"
        ],
        "classSignatureBeforeSet": [
            "public class DummyLanguageModule extends BaseLanguageModule "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Move Method refactoring mechanics\n",
                "description": "Move Method specific changes - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\n\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RuleViolation;\nimport net.sourceforge.pmd.lang.ast.DummyNode;\nimport net.sourceforge.pmd.lang.ast.DummyNode.DummyRootNode;\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.ast.ParseException;\nimport net.sourceforge.pmd.lang.ast.Parser;\nimport net.sourceforge.pmd.lang.ast.RootNode;\nimport net.sourceforge.pmd.lang.ast.SourceCodePositioner;\nimport net.sourceforge.pmd.lang.rule.ParametricRuleViolation;\nimport net.sourceforge.pmd.lang.rule.impl.DefaultRuleViolationFactory;\n\n/**\n * Dummy language used for testing PMD.\n */\npublic class DummyLanguageModule extends BaseLanguageModule {\n\n    public static final String NAME = \"Dummy\";\n    public static final String TERSE_NAME = \"dummy\";\n    private static final String PARSER_REPORTS_SEMANTIC_ERROR = \"1.9-semantic_error\";\n    private static final String THROWS_SEMANTIC_ERROR = \"1.9-throws_semantic_error\";\n    private static final String THROWS_ASSERTION_ERROR = \"1.9-throws\";\n\n    public DummyLanguageModule() {\n        super(NAME, null, TERSE_NAME, \"dummy\");\n        addVersion(\"1.0\", new Handler());\n        addVersion(\"1.1\", new Handler());\n        addVersion(\"1.2\", new Handler());\n        addVersion(\"1.3\", new Handler());\n        addVersion(\"1.4\", new Handler());\n        addVersion(\"1.5\", new Handler(), \"5\");\n        addVersion(\"1.6\", new Handler(), \"6\");\n        addDefaultVersion(\"1.7\", new Handler(), \"7\");\n        addVersion(\"1.8\", new Handler(), \"8\");\n        addVersion(THROWS_ASSERTION_ERROR, new HandlerWithParserThatThrows());\n        addVersion(PARSER_REPORTS_SEMANTIC_ERROR, new HandlerWithParserThatReportsSemanticError());\n        addVersion(THROWS_SEMANTIC_ERROR, new HandlerWithParserThatThrowsSemanticError());\n    }\n\n    public LanguageVersion getVersionWithParserThatThrowsAssertionError() {\n        return getVersion(THROWS_ASSERTION_ERROR);\n    }\n    public LanguageVersion getVersionWithParserThatThrowsSemanticError() {\n        return getVersion(THROWS_SEMANTIC_ERROR);\n    }\n    public LanguageVersion getVersionWithParserThatReportsSemanticError() {\n        return getVersion(PARSER_REPORTS_SEMANTIC_ERROR);\n    }\n\n    public static DummyLanguageModule getInstance() {\n        return (DummyLanguageModule) LanguageRegistry.getLanguage(NAME);\n    }\n\n    public static DummyRootNode parse(String code) {\n        return parse(code, \"nofilename\");\n    }\n\n    public static DummyRootNode parse(String code, String filename) {\n        DummyRootNode rootNode = readLispNode(code);\n        rootNode.withFileName(filename);\n        return rootNode;\n    }\n\n\n    public static class Handler extends AbstractPmdLanguageVersionHandler {\n        @Override\n        public RuleViolationFactory getRuleViolationFactory() {\n            return new RuleViolationFactory();\n        }\n\n        @Override\n        public Parser getParser() {\n            return task -> {\n                DummyRootNode rootNode = readLispNode(task.getSourceText());\n                rootNode.withFileName(task.getFileDisplayName());\n                rootNode.withLanguage(task.getLanguageVersion());\n                rootNode.withSourceText(task.getSourceText());\n                return rootNode;\n            };\n        }\n    }\n\n    public static class HandlerWithParserThatThrows extends Handler {\n        @Override\n        public Parser getParser() {\n            return task -> {\n                throw new AssertionError(\"test error while parsing\");\n            };\n        }\n    }\n\n    public static class HandlerWithParserThatReportsSemanticError extends Handler {\n        @Override\n        public Parser getParser() {\n            return task -> {\n                RootNode root = super.getParser().parse(task);\n                task.getReporter().error(root, \"An error occurred!\");\n                return root;\n            };\n        }\n    }\n\n    public static class HandlerWithParserThatThrowsSemanticError extends Handler {\n        @Override\n        public Parser getParser() {\n            return task -> {\n                RootNode root = super.getParser().parse(task);\n                throw task.getReporter().error(root, \"An error occurred!\");\n            };\n        }\n    }\n\n    /**\n     * Creates a tree of nodes that corresponds to the nesting structures\n     * of parentheses in the text. The image of each node is also populated.\n     * This is useful to create non-trivial trees with all the relevant\n     * data (eg coordinates) set properly.\n     *\n     * Eg {@code (a(b)x(c))} will create a tree with a node \"a\", with two\n     * children \"b\" and \"c\". \"x\" is ignored. The node \"a\" is not the root\n     * node, it has a {@link DummyRootNode} as parent, whose image is \"\".\n     */\n    private static DummyRootNode readLispNode(String text) {\n        final DummyRootNode root = new DummyRootNode().withSourceText(text);\n        DummyNode top = root;\n        SourceCodePositioner positioner = new SourceCodePositioner(text);\n        top.setCoords(1, 1, positioner.getLastLine(), positioner.getLastLineColumn());\n        int lastNodeStart = 0;\n        for (int i = 0; i < text.length(); i++) {\n            char c = text.charAt(i);\n            if (c == '(') {\n                DummyNode node = new DummyNode();\n                node.setParent(top);\n                top.addChild(node, top.getNumChildren());\n                // setup coordinates\n                int bline = positioner.lineNumberFromOffset(i);\n                int bcol = positioner.columnFromOffset(bline, i);\n                node.setCoords(bline, bcol, bline, bcol);\n                // cut out image\n                if (top.getImage() == null) {\n                    // image may be non null if this is not the first child of 'top'\n                    // eg in (a(b)x(c)), the image of the parent is set to \"a\".\n                    // When we're processing \"(c\", we ignore \"x\".\n                    String image = text.substring(lastNodeStart, i);\n                    top.setImage(image);\n                }\n                lastNodeStart = i + 1;\n                // node is the top of the stack now\n                top = node;\n            } else if (c == ')') {\n                if (top == null) {\n                    throw new ParseException(\"Unbalanced parentheses: \" + text);\n                }\n                // setup coordinates\n                int eline = positioner.lineNumberFromOffset(i);\n                int ecol = positioner.columnFromOffset(eline, i);\n                top.setCoords(top.getBeginLine(), top.getBeginColumn(), eline, ecol);\n\n                if (top.getImage() == null) {\n                    // cut out image (if node doesn't have children it hasn't been populated yet)\n                    String image = text.substring(lastNodeStart, i);\n                    top.setImage(image);\n                    lastNodeStart = i + 1;\n                }\n                top = top.getParent();\n            }\n        }\n        if (top != root) {\n            throw new ParseException(\"Unbalanced parentheses: \" + text);\n        }\n        return root;\n    }\n\n    public static class RuleViolationFactory extends DefaultRuleViolationFactory {\n\n        @Override\n        public RuleViolation createViolation(Rule rule, @NonNull Node location, @NonNull String formattedMessage) {\n            return new ParametricRuleViolation<Node>(rule, location, formattedMessage) {\n                {\n                    this.packageName = \"foo\"; // just for testing variable expansion\n                }\n            };\n        }\n    }\n}\n",
        "filePathAfter": "pmd-core/src/test/java/net/sourceforge/pmd/processor/PmdRunnableTest.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.processor;\n\nimport static org.hamcrest.CoreMatchers.instanceOf;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.hasSize;\nimport static org.mockito.Mockito.contains;\nimport static org.mockito.Mockito.eq;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.spy;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\n\nimport java.util.List;\nimport java.util.function.BiConsumer;\n\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.contrib.java.lang.system.RestoreSystemProperties;\nimport org.junit.rules.TestRule;\nimport org.mockito.Mockito;\nimport org.slf4j.event.Level;\n\nimport net.sourceforge.pmd.PMDConfiguration;\nimport net.sourceforge.pmd.Report;\nimport net.sourceforge.pmd.Report.GlobalReportBuilderListener;\nimport net.sourceforge.pmd.Report.ProcessingError;\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RuleContext;\nimport net.sourceforge.pmd.RuleSet;\nimport net.sourceforge.pmd.RuleSets;\nimport net.sourceforge.pmd.internal.SystemProps;\nimport net.sourceforge.pmd.internal.util.ContextedAssertionError;\nimport net.sourceforge.pmd.lang.DummyLanguageModule;\nimport net.sourceforge.pmd.lang.DummyLanguageModule.Handler;\nimport net.sourceforge.pmd.lang.Language;\nimport net.sourceforge.pmd.lang.LanguageRegistry;\nimport net.sourceforge.pmd.lang.LanguageVersion;\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.ast.Parser;\nimport net.sourceforge.pmd.lang.ast.RootNode;\nimport net.sourceforge.pmd.lang.rule.AbstractRule;\nimport net.sourceforge.pmd.processor.MonoThreadProcessor.MonothreadRunnable;\nimport net.sourceforge.pmd.util.datasource.DataSource;\nimport net.sourceforge.pmd.util.log.MessageReporter;\n\npublic class PmdRunnableTest {\n\n    public static final String TEST_MESSAGE_SEMANTIC_ERROR = \"An error occurred!\";\n    private static final String PARSER_REPORTS_SEMANTIC_ERROR = \"1.9-semantic_error\";\n    private static final String THROWS_SEMANTIC_ERROR = \"1.9-throws_semantic_error\";\n    private static final String THROWS_ASSERTION_ERROR = \"1.9-throws\";\n\n\n    @org.junit.Rule\n    public TestRule restoreSystemProperties = new RestoreSystemProperties();\n\n\n    private final DummyLanguageModule dummyLang = DummyLanguageModule.getInstance();\n\n    private PMDConfiguration configuration;\n    private PmdRunnable pmdRunnable;\n    private GlobalReportBuilderListener reportBuilder;\n    private MessageReporter reporter;\n    private Rule rule;\n\n    @Before\n    public void prepare() {\n        DataSource dataSource = DataSource.forString(\"test\", \"test.dummy\");\n\n\n        rule = spy(new RuleThatThrows());\n        configuration = new PMDConfiguration();\n        reportBuilder = new GlobalReportBuilderListener();\n        reporter = mock(MessageReporter.class);\n        configuration.setReporter(reporter);\n        pmdRunnable = new MonothreadRunnable(new RuleSets(RuleSet.forSingleRule(rule)),\n                                             dataSource,\n                                             reportBuilder,\n                                             configuration);\n\n    }\n\n    @Test\n    public void inErrorRecoveryModeErrorsShouldBeLoggedByParser() {\n        System.setProperty(SystemProps.PMD_ERROR_RECOVERY, \"\");\n        configuration.setDefaultLanguageVersion(versionWithParserThatThrowsAssertionError());\n\n        pmdRunnable.run();\n        reportBuilder.close();\n        Assert.assertEquals(1, reportBuilder.getResult().getProcessingErrors().size());\n    }\n\n    @Test\n    public void inErrorRecoveryModeErrorsShouldBeLoggedByRule() {\n        System.setProperty(SystemProps.PMD_ERROR_RECOVERY, \"\");\n        configuration.setDefaultLanguageVersion(dummyLang.getDefaultVersion());\n\n        pmdRunnable.run();\n        reportBuilder.close();\n        Report report = reportBuilder.getResult();\n        List<ProcessingError> errors = report.getProcessingErrors();\n        assertThat(errors, hasSize(1));\n        assertThat(errors.get(0).getError(), instanceOf(ContextedAssertionError.class));\n    }\n\n    @Test\n    public void withoutErrorRecoveryModeProcessingShouldBeAbortedByParser() {\n        Assert.assertNull(System.getProperty(SystemProps.PMD_ERROR_RECOVERY));\n        configuration.setDefaultLanguageVersion(versionWithParserThatThrowsAssertionError());\n\n        Assert.assertThrows(AssertionError.class, pmdRunnable::run);\n    }\n\n    @Test\n    public void withoutErrorRecoveryModeProcessingShouldBeAbortedByRule() {\n        Assert.assertNull(System.getProperty(SystemProps.PMD_ERROR_RECOVERY));\n        configuration.setDefaultLanguageVersion(dummyLang.getDefaultVersion());\n\n        Assert.assertThrows(AssertionError.class, pmdRunnable::run);\n    }\n\n\n    @Test\n    public void semanticErrorShouldAbortTheRun() {\n        configuration.setDefaultLanguageVersion(versionWithParserThatReportsSemanticError());\n\n        pmdRunnable.run();\n\n        verify(reporter).log(eq(Level.INFO), contains(\"skipping rule analysis\"));\n        verify(rule, never()).apply(Mockito.any(), Mockito.any());\n    }\n\n    @Test\n    public void semanticErrorThrownShouldAbortTheRun() {\n        configuration.setDefaultLanguageVersion(getVersionWithParserThatThrowsSemanticError());\n\n        pmdRunnable.run();\n\n        verify(reporter, times(1)).log(eq(Level.ERROR), contains(TEST_MESSAGE_SEMANTIC_ERROR));\n        verify(rule, never()).apply(Mockito.any(), Mockito.any());\n    }\n\n    public static void registerCustomVersions(BiConsumer<String, Handler> addVersion) {\n        addVersion.accept(THROWS_ASSERTION_ERROR, new HandlerWithParserThatThrows());\n        addVersion.accept(PARSER_REPORTS_SEMANTIC_ERROR, new HandlerWithParserThatReportsSemanticError());\n        addVersion.accept(THROWS_SEMANTIC_ERROR, new HandlerWithParserThatThrowsSemanticError());\n\n    }\n\n    public LanguageVersion versionWithParserThatThrowsAssertionError() {\n        return dummyLang.getVersion(THROWS_ASSERTION_ERROR);\n    }\n\n    public LanguageVersion getVersionWithParserThatThrowsSemanticError() {\n        return dummyLang.getVersion(THROWS_SEMANTIC_ERROR);\n    }\n\n    public LanguageVersion versionWithParserThatReportsSemanticError() {\n        return dummyLang.getVersion(PARSER_REPORTS_SEMANTIC_ERROR);\n    }\n\n    private static class RuleThatThrows extends AbstractRule {\n\n        RuleThatThrows() {\n            Language dummyLanguage = LanguageRegistry.findLanguageByTerseName(DummyLanguageModule.TERSE_NAME);\n            setLanguage(dummyLanguage);\n        }\n\n        @Override\n        public void apply(Node target, RuleContext ctx) {\n            throw new AssertionError(\"test\");\n        }\n    }\n\n    public static class HandlerWithParserThatThrowsSemanticError extends Handler {\n\n        @Override\n        public Parser getParser() {\n            return task -> {\n                RootNode root = super.getParser().parse(task);\n                throw task.getReporter().error(root, TEST_MESSAGE_SEMANTIC_ERROR);\n            };\n        }\n    }\n\n    public static class HandlerWithParserThatThrows extends Handler {\n\n        @Override\n        public Parser getParser() {\n            return task -> {\n                throw new AssertionError(\"test error while parsing\");\n            };\n        }\n    }\n\n    public static class HandlerWithParserThatReportsSemanticError extends Handler {\n\n        @Override\n        public Parser getParser() {\n            return task -> {\n                RootNode root = super.getParser().parse(task);\n                task.getReporter().error(root, TEST_MESSAGE_SEMANTIC_ERROR);\n                return root;\n            };\n        }\n    }\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "public LanguageVersion versionWithParserThatThrowsAssertionError() {\n        return dummyLang.getVersion(THROWS_ASSERTION_ERROR);\n    }",
        "diffSourceCode": "-   48:     public LanguageVersion getVersionWithParserThatThrowsAssertionError() {\n-   49:         return getVersion(THROWS_ASSERTION_ERROR);\n-   50:     }\n-  156:                 // node is the top of the stack now\n-  157:                 top = node;\n-  158:             } else if (c == ')') {\n+   48: import net.sourceforge.pmd.processor.MonoThreadProcessor.MonothreadRunnable;\n+   49: import net.sourceforge.pmd.util.datasource.DataSource;\n+   50: import net.sourceforge.pmd.util.log.MessageReporter;\n+  156:     public LanguageVersion versionWithParserThatThrowsAssertionError() {\n+  157:         return dummyLang.getVersion(THROWS_ASSERTION_ERROR);\n+  158:     }\n",
        "uniqueId": "ff2f5ef93c1b3150583e9611b2a8fd8159e3aa66_48_50__156_158",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate getErrorMessage(error Throwable) : String extracted from public logEx(level Level, message String, formatArgs Object[], error Throwable) : void in class net.sourceforge.pmd.util.log.internal.MessageReporterBase",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/util/log/internal/MessageReporterBase.java",
                "startLine": 43,
                "endLine": 58,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/util/log/internal/MessageReporterBase.java",
                "startLine": 46,
                "endLine": 62,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/util/log/internal/MessageReporterBase.java",
                "startLine": 64,
                "endLine": 70,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n    public void logEx(Level level, String message, Object[] formatArgs, Throwable error) {\n        if (isLoggable(level)) {\n            message = MessageFormat.format(message, formatArgs);\n            String errorMessage = error.getMessage();\n            if (errorMessage == null) {\n                errorMessage = error.getClass().getSimpleName();\n            }\n            errorMessage = StringUtil.quoteMessageFormat(errorMessage);\n            log(level, message + \": \" + errorMessage);\n            if (isLoggable(Level.DEBUG)) {\n                String stackTrace = StringUtil.quoteMessageFormat(ExceptionUtils.getStackTrace(error));\n                log(Level.DEBUG, stackTrace);\n            }\n        }\n    }",
        "filePathBefore": "pmd-core/src/main/java/net/sourceforge/pmd/util/log/internal/MessageReporterBase.java",
        "isPureRefactoring": true,
        "commitId": "fc81d649b84e1e7bb030a0dc4d95f1f195d71669",
        "packageNameBefore": "net.sourceforge.pmd.util.log.internal",
        "classNameBefore": "net.sourceforge.pmd.util.log.internal.MessageReporterBase",
        "methodNameBefore": "net.sourceforge.pmd.util.log.internal.MessageReporterBase#logEx",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.util.log.internal.MessageReporterBase#log\n methodBody: public final void log(Level level, String message, Object... formatArgs) {\nif(level == Level.ERROR){this.numErrors++;\n}if(isLoggable(level)){logImpl(level,message,formatArgs);\n}}\nmethodSignature: net.sourceforge.pmd.util.log.internal.MessageReporterBase#isLoggable\n methodBody: public final boolean isLoggable(Level level) {\nreturn minLevel != null && minLevel.compareTo(level) >= 0 && isLoggableImpl(level);\n}\nmethodSignature: net.sourceforge.pmd.util.StringUtil#quoteMessageFormat\n methodBody: public static String quoteMessageFormat(String str) {\nreturn str.replaceAll(\"'\",\"''\");\n}\nmethodSignature: net.sourceforge.pmd.util.log.MessageReporter#log\n methodBody: void log(Level level, String message, Object... formatArgs);\nmethodSignature: net.sourceforge.pmd.util.log.MessageReporter#isLoggable\n methodBody: boolean isLoggable(Level level);",
        "classSignatureBefore": "abstract class MessageReporterBase implements MessageReporter ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.util.log.internal.MessageReporterBase#logEx"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.util.log.internal.MessageReporterBase"
        ],
        "classSignatureBeforeSet": [
            "abstract class MessageReporterBase implements MessageReporter "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics Severe changes",
                "description": "Return expression has been added within the Extract Method mechanics - with non-mapped leaves",
                "mappingState": 2
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.util.log.internal;\n\nimport java.text.MessageFormat;\n\nimport org.apache.commons.lang3.exception.ExceptionUtils;\nimport org.slf4j.event.Level;\n\nimport net.sourceforge.pmd.util.StringUtil;\nimport net.sourceforge.pmd.util.log.MessageReporter;\n\n/**\n * Base implementation.\n *\n * @author Cl\u00e9ment Fournier\n */\nabstract class MessageReporterBase implements MessageReporter {\n\n    private int numErrors;\n    private Level minLevel = Level.TRACE;\n\n    /**\n     * null level means off.\n     */\n    public final void setLevel(Level minLevel) {\n        this.minLevel = minLevel;\n    }\n\n    @Override\n    public final boolean isLoggable(Level level) {\n        return minLevel != null\n            && minLevel.compareTo(level) >= 0\n            && isLoggableImpl(level);\n    }\n\n    protected boolean isLoggableImpl(Level level) {\n        return true;\n    }\n\n    @Override\n    public void logEx(Level level, String message, Object[] formatArgs, Throwable error) {\n        if (isLoggable(level)) {\n            message = MessageFormat.format(message, formatArgs);\n            String errorMessage = error.getMessage();\n            if (errorMessage == null) {\n                errorMessage = error.getClass().getSimpleName();\n            }\n            errorMessage = StringUtil.quoteMessageFormat(errorMessage);\n            log(level, message + \": \" + errorMessage);\n            if (isLoggable(Level.DEBUG)) {\n                String stackTrace = StringUtil.quoteMessageFormat(ExceptionUtils.getStackTrace(error));\n                log(Level.DEBUG, stackTrace);\n            }\n        }\n    }\n\n    @Override\n    public final void log(Level level, String message, Object... formatArgs) {\n        if (level == Level.ERROR) {\n            this.numErrors++;\n        }\n        if (isLoggable(level)) {\n            logImpl(level, message, formatArgs);\n        }\n    }\n\n    /**\n     * Perform logging assuming {@link #isLoggable(Level)} is true.\n     */\n    protected abstract void logImpl(Level level, String message, Object[] formatArgs);\n\n\n    @Override\n    public int numErrors() {\n        return numErrors;\n    }\n}\n",
        "filePathAfter": "pmd-core/src/main/java/net/sourceforge/pmd/util/log/internal/MessageReporterBase.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.util.log.internal;\n\nimport static net.sourceforge.pmd.util.StringUtil.quoteMessageFormat;\n\nimport java.text.MessageFormat;\nimport java.util.Objects;\n\nimport org.apache.commons.lang3.exception.ExceptionUtils;\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.slf4j.event.Level;\n\nimport net.sourceforge.pmd.util.log.MessageReporter;\n\n/**\n * Base implementation.\n *\n * @author Cl\u00e9ment Fournier\n */\nabstract class MessageReporterBase implements MessageReporter {\n\n    private int numErrors;\n    private Level minLevel = Level.TRACE;\n\n    /**\n     * null level means off.\n     */\n    public final void setLevel(Level minLevel) {\n        this.minLevel = minLevel;\n    }\n\n    @Override\n    public final boolean isLoggable(Level level) {\n        return minLevel != null\n            && minLevel.compareTo(level) >= 0\n            && isLoggableImpl(level);\n    }\n\n    protected boolean isLoggableImpl(Level level) {\n        return true;\n    }\n\n    @Override\n    public void logEx(Level level, String message, Object[] formatArgs, Throwable error) {\n        if (isLoggable(level)) {\n            if (error == null) {\n                Objects.requireNonNull(message, \"cannot call this method with null message and error\");\n                log(level, message, formatArgs);\n                return;\n            }\n            message = MessageFormat.format(message, formatArgs);\n            String errorMessage = getErrorMessage(error);\n            logImpl(level, message + \": \" + errorMessage);\n            if (isLoggable(Level.DEBUG)) {\n                String stackTrace = quoteMessageFormat(ExceptionUtils.getStackTrace(error));\n                log(Level.DEBUG, stackTrace);\n            }\n        }\n    }\n\n    private @NonNull String getErrorMessage(Throwable error) {\n        String errorMessage = error.getMessage();\n        if (errorMessage == null) {\n            errorMessage = error.getClass().getSimpleName();\n        }\n        return errorMessage;\n    }\n\n    @Override\n    public final void log(Level level, String message, Object... formatArgs) {\n        if (level == Level.ERROR) {\n            this.numErrors++;\n        }\n        if (isLoggable(level)) {\n            logImpl(level, MessageFormat.format(message, formatArgs));\n        }\n    }\n\n    /**\n     * Perform logging assuming {@link #isLoggable(Level)} is true.\n     */\n    protected abstract void logImpl(Level level, String message);\n\n\n    @Override\n    public int numErrors() {\n        return numErrors;\n    }\n}\n",
        "diffSourceCodeSet": [
            "private @NonNull String getErrorMessage(Throwable error) {\n        String errorMessage = error.getMessage();\n        if (errorMessage == null) {\n            errorMessage = error.getClass().getSimpleName();\n        }\n        return errorMessage;\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.util.log.internal.MessageReporterBase#log\n methodBody: public final void log(Level level, String message, Object... formatArgs) {\nif(level == Level.ERROR){this.numErrors++;\n}if(isLoggable(level)){logImpl(level,message,formatArgs);\n}}",
            "methodSignature: net.sourceforge.pmd.util.log.internal.MessageReporterBase#isLoggable\n methodBody: public final boolean isLoggable(Level level) {\nreturn minLevel != null && minLevel.compareTo(level) >= 0 && isLoggableImpl(level);\n}",
            "methodSignature: net.sourceforge.pmd.util.StringUtil#quoteMessageFormat\n methodBody: public static String quoteMessageFormat(String str) {\nreturn str.replaceAll(\"'\",\"''\");\n}",
            "methodSignature: net.sourceforge.pmd.util.log.MessageReporter#log\n methodBody: void log(Level level, String message, Object... formatArgs);",
            "methodSignature: net.sourceforge.pmd.util.log.MessageReporter#isLoggable\n methodBody: boolean isLoggable(Level level);"
        ],
        "sourceCodeAfterRefactoring": "@Override\n    public void logEx(Level level, String message, Object[] formatArgs, Throwable error) {\n        if (isLoggable(level)) {\n            if (error == null) {\n                Objects.requireNonNull(message, \"cannot call this method with null message and error\");\n                log(level, message, formatArgs);\n                return;\n            }\n            message = MessageFormat.format(message, formatArgs);\n            String errorMessage = getErrorMessage(error);\n            logImpl(level, message + \": \" + errorMessage);\n            if (isLoggable(Level.DEBUG)) {\n                String stackTrace = quoteMessageFormat(ExceptionUtils.getStackTrace(error));\n                log(Level.DEBUG, stackTrace);\n            }\n        }\n    }\nprivate @NonNull String getErrorMessage(Throwable error) {\n        String errorMessage = error.getMessage();\n        if (errorMessage == null) {\n            errorMessage = error.getClass().getSimpleName();\n        }\n        return errorMessage;\n    }",
        "diffSourceCode": "-   43:     @Override\n-   44:     public void logEx(Level level, String message, Object[] formatArgs, Throwable error) {\n-   45:         if (isLoggable(level)) {\n-   46:             message = MessageFormat.format(message, formatArgs);\n-   47:             String errorMessage = error.getMessage();\n-   48:             if (errorMessage == null) {\n-   49:                 errorMessage = error.getClass().getSimpleName();\n-   50:             }\n-   51:             errorMessage = StringUtil.quoteMessageFormat(errorMessage);\n-   52:             log(level, message + \": \" + errorMessage);\n-   53:             if (isLoggable(Level.DEBUG)) {\n-   54:                 String stackTrace = StringUtil.quoteMessageFormat(ExceptionUtils.getStackTrace(error));\n-   55:                 log(Level.DEBUG, stackTrace);\n-   56:             }\n-   57:         }\n-   58:     }\n-   59: \n-   60:     @Override\n-   61:     public final void log(Level level, String message, Object... formatArgs) {\n-   62:         if (level == Level.ERROR) {\n-   64:         }\n-   65:         if (isLoggable(level)) {\n-   66:             logImpl(level, message, formatArgs);\n-   67:         }\n-   68:     }\n-   69: \n-   70:     /**\n+   43:         return true;\n+   44:     }\n+   45: \n+   46:     @Override\n+   47:     public void logEx(Level level, String message, Object[] formatArgs, Throwable error) {\n+   48:         if (isLoggable(level)) {\n+   49:             if (error == null) {\n+   50:                 Objects.requireNonNull(message, \"cannot call this method with null message and error\");\n+   51:                 log(level, message, formatArgs);\n+   52:                 return;\n+   53:             }\n+   54:             message = MessageFormat.format(message, formatArgs);\n+   55:             String errorMessage = getErrorMessage(error);\n+   56:             logImpl(level, message + \": \" + errorMessage);\n+   57:             if (isLoggable(Level.DEBUG)) {\n+   58:                 String stackTrace = quoteMessageFormat(ExceptionUtils.getStackTrace(error));\n+   59:                 log(Level.DEBUG, stackTrace);\n+   60:             }\n+   61:         }\n+   62:     }\n+   64:     private @NonNull String getErrorMessage(Throwable error) {\n+   65:         String errorMessage = error.getMessage();\n+   66:         if (errorMessage == null) {\n+   67:             errorMessage = error.getClass().getSimpleName();\n+   68:         }\n+   69:         return errorMessage;\n+   70:     }\n",
        "uniqueId": "fc81d649b84e1e7bb030a0dc4d95f1f195d71669_43_58_64_70_46_62",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 14,
                "covered": 36
            },
            "BRANCH": {
                "missed": 3,
                "covered": 3
            },
            "LINE": {
                "missed": 3,
                "covered": 8
            },
            "COMPLEXITY": {
                "missed": 3,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Inline Method",
        "description": "Inline Method\tprivate incrementProgress() : void inlined to public startFileAnalysis(file DataSource) : FileAnalysisListener in class net.sourceforge.pmd.cli.internal.ProgressBarListener",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/cli/internal/ProgressBarListener.java",
                "startLine": 64,
                "endLine": 91,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/cli/internal/ProgressBarListener.java",
                "startLine": 60,
                "endLine": 88,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/cli/internal/ProgressBarListener.java",
                "startLine": 41,
                "endLine": 44,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private void incrementProgress() {\n        progressBar.step();\n        refreshProgressBar();\n    }",
        "filePathBefore": "pmd-core/src/main/java/net/sourceforge/pmd/cli/internal/ProgressBarListener.java",
        "isPureRefactoring": true,
        "commitId": "70238044414cd846f6be19a568dc20eaeb793933",
        "packageNameBefore": "net.sourceforge.pmd.cli.internal",
        "classNameBefore": "net.sourceforge.pmd.cli.internal.ProgressBarListener",
        "methodNameBefore": "net.sourceforge.pmd.cli.internal.ProgressBarListener#incrementProgress",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.cli.internal.ProgressBarListener#refreshProgressBar\n methodBody: private void refreshProgressBar() {\nif(progressBar.getCurrent() != progressBar.getMax()){progressBar.setExtraMessage(extraMessage() + \"\\r\");\n}{progressBar.setExtraMessage(extraMessage() + System.lineSeparator());\n}progressBar.refresh();\n}",
        "classSignatureBefore": "public final class ProgressBarListener implements GlobalAnalysisListener ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.cli.internal.ProgressBarListener#incrementProgress"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.cli.internal.ProgressBarListener"
        ],
        "classSignatureBeforeSet": [
            "public final class ProgressBarListener implements GlobalAnalysisListener "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.cli.internal;\n\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.Consumer;\n\nimport net.sourceforge.pmd.Report;\nimport net.sourceforge.pmd.RuleViolation;\nimport net.sourceforge.pmd.reporting.FileAnalysisListener;\nimport net.sourceforge.pmd.reporting.GlobalAnalysisListener;\nimport net.sourceforge.pmd.util.datasource.DataSource;\n\nimport me.tongfei.progressbar.DelegatingProgressBarConsumer;\nimport me.tongfei.progressbar.ProgressBar;\nimport me.tongfei.progressbar.ProgressBarBuilder;\nimport me.tongfei.progressbar.ProgressBarStyle;\n\n/**\n * Collects runtime analysis statistics and displays them live on command line output.\n * Toggled off through --no-progress command line argument.\n */\npublic final class ProgressBarListener implements GlobalAnalysisListener {\n    private final ProgressBar progressBar;\n    private final AtomicInteger numErrors = new AtomicInteger(0);\n    private final AtomicInteger numViolations = new AtomicInteger(0);\n    \n    public ProgressBarListener(int totalFiles, Consumer<String> loggingFunction) {\n        progressBar = new ProgressBarBuilder()\n                .setTaskName(\"Processing files\")\n                .setInitialMax(totalFiles)\n                .setStyle(ProgressBarStyle.ASCII)\n                .continuousUpdate()\n                .setConsumer(new DelegatingProgressBarConsumer(loggingFunction))\n                .build();\n        progressBar.setExtraMessage(extraMessage() + \"\\r\");\n    }\n\n    private void incrementProgress() {\n        progressBar.step();\n        refreshProgressBar();\n    }\n\n    /**\n     * Updates progress bar string and forces it to be output regardless of its update interval.\n     */\n    private void refreshProgressBar() {\n        // Use trailing carriage return to interleave with other output\n        if (progressBar.getCurrent() != progressBar.getMax()) {\n            progressBar.setExtraMessage(extraMessage() + \"\\r\");\n        } else {\n            // Don't include trailing carriage return on last draw\n            progressBar.setExtraMessage(extraMessage() + System.lineSeparator());\n        }\n        progressBar.refresh();\n    }\n\n    private String extraMessage() {\n        return String.format(\"Violations:%d, Errors:%d\", numViolations.get(), numErrors.get());\n    }\n\n    @Override\n    public FileAnalysisListener startFileAnalysis(DataSource file) {\n        // Refresh progress on file analysis start\n        refreshProgressBar();\n\n        return new FileAnalysisListener() {\n            @Override\n            public void onRuleViolation(RuleViolation violation) {\n                ProgressBarListener.this.numViolations.addAndGet(1);\n            }\n\n            @Override\n            public void onSuppressedRuleViolation(Report.SuppressedViolation violation) {\n                /*Not handled*/\n            }\n\n            @Override\n            public void onError(Report.ProcessingError error) {\n                ProgressBarListener.this.numErrors.addAndGet(1);\n            }\n\n            @Override\n            public void close() {\n                // Refresh progress bar on file analysis end (or file was in cache)\n                ProgressBarListener.this.incrementProgress();\n            }\n        };\n    }\n\n    @Override\n    public void close() throws Exception {\n        /*ProgressBar auto-closed*/\n    }\n}\n",
        "filePathAfter": "pmd-core/src/main/java/net/sourceforge/pmd/cli/internal/ProgressBarListener.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.cli.internal;\n\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.Consumer;\n\nimport net.sourceforge.pmd.Report;\nimport net.sourceforge.pmd.RuleViolation;\nimport net.sourceforge.pmd.reporting.FileAnalysisListener;\nimport net.sourceforge.pmd.reporting.GlobalAnalysisListener;\nimport net.sourceforge.pmd.util.datasource.DataSource;\n\nimport me.tongfei.progressbar.DelegatingProgressBarConsumer;\nimport me.tongfei.progressbar.ProgressBar;\nimport me.tongfei.progressbar.ProgressBarBuilder;\nimport me.tongfei.progressbar.ProgressBarStyle;\n\n/**\n * Collects runtime analysis statistics and displays them live on command line output.\n * Toggled off through --no-progress command line argument.\n */\npublic final class ProgressBarListener implements GlobalAnalysisListener {\n    private final ProgressBar progressBar;\n    private final AtomicInteger numErrors = new AtomicInteger(0);\n    private final AtomicInteger numViolations = new AtomicInteger(0);\n    \n    public ProgressBarListener(int totalFiles, Consumer<String> loggingFunction) {\n        progressBar = new ProgressBarBuilder()\n                .setTaskName(\"Processing files\")\n                .setInitialMax(totalFiles)\n                .setStyle(ProgressBarStyle.ASCII)\n                .continuousUpdate()\n                .setConsumer(new DelegatingProgressBarConsumer(loggingFunction))\n                .build();\n        progressBar.setExtraMessage(extraMessage() + \"\\r\");\n    }\n\n\n    /**\n     * Updates progress bar string and forces it to be output regardless of its update interval.\n     */\n    private void refreshProgressBar() {\n        // Use trailing carriage return to interleave with other output\n        if (progressBar.getCurrent() != progressBar.getMax()) {\n            progressBar.setExtraMessage(extraMessage() + \"\\r\");\n        } else {\n            // Don't include trailing carriage return on last draw\n            progressBar.setExtraMessage(extraMessage() + System.lineSeparator());\n        }\n        progressBar.refresh();\n    }\n\n    private String extraMessage() {\n        return String.format(\"Violations:%d, Errors:%d\", numViolations.get(), numErrors.get());\n    }\n\n    @Override\n    public FileAnalysisListener startFileAnalysis(DataSource file) {\n        // Refresh progress on file analysis start\n        refreshProgressBar();\n\n        return new FileAnalysisListener() {\n            @Override\n            public void onRuleViolation(RuleViolation violation) {\n                ProgressBarListener.this.numViolations.addAndGet(1);\n            }\n\n            @Override\n            public void onSuppressedRuleViolation(Report.SuppressedViolation violation) {\n                /*Not handled*/\n            }\n\n            @Override\n            public void onError(Report.ProcessingError error) {\n                ProgressBarListener.this.numErrors.addAndGet(1);\n            }\n\n            @Override\n            public void close() {\n                // Refresh progress bar on file analysis end (or file was in cache)\n                progressBar.step();\n                refreshProgressBar();\n            }\n        };\n    }\n\n    @Override\n    public void close() throws Exception {\n        /*ProgressBar auto-closed*/\n    }\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.cli.internal.ProgressBarListener#refreshProgressBar\n methodBody: private void refreshProgressBar() {\nif(progressBar.getCurrent() != progressBar.getMax()){progressBar.setExtraMessage(extraMessage() + \"\\r\");\n}{progressBar.setExtraMessage(extraMessage() + System.lineSeparator());\n}progressBar.refresh();\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n    public FileAnalysisListener startFileAnalysis(DataSource file) {\n        // Refresh progress on file analysis start\n        refreshProgressBar();\n\n        return new FileAnalysisListener() {\n            @Override\n            public void onRuleViolation(RuleViolation violation) {\n                ProgressBarListener.this.numViolations.addAndGet(1);\n            }\n\n            @Override\n            public void onSuppressedRuleViolation(Report.SuppressedViolation violation) {\n                /*Not handled*/\n            }\n\n            @Override\n            public void onError(Report.ProcessingError error) {\n                ProgressBarListener.this.numErrors.addAndGet(1);\n            }\n\n            @Override\n            public void close() {\n                // Refresh progress bar on file analysis end (or file was in cache)\n                progressBar.step();\n                refreshProgressBar();\n            }\n        };\n    }",
        "diffSourceCode": "-   41:     private void incrementProgress() {\n-   42:         progressBar.step();\n-   43:         refreshProgressBar();\n-   44:     }\n-   60:     private String extraMessage() {\n-   61:         return String.format(\"Violations:%d, Errors:%d\", numViolations.get(), numErrors.get());\n-   62:     }\n-   63: \n-   64:     @Override\n-   65:     public FileAnalysisListener startFileAnalysis(DataSource file) {\n-   66:         // Refresh progress on file analysis start\n-   67:         refreshProgressBar();\n-   68: \n-   69:         return new FileAnalysisListener() {\n-   70:             @Override\n-   71:             public void onRuleViolation(RuleViolation violation) {\n-   72:                 ProgressBarListener.this.numViolations.addAndGet(1);\n-   73:             }\n-   74: \n-   75:             @Override\n-   76:             public void onSuppressedRuleViolation(Report.SuppressedViolation violation) {\n-   77:                 /*Not handled*/\n-   78:             }\n-   79: \n-   80:             @Override\n-   81:             public void onError(Report.ProcessingError error) {\n-   82:                 ProgressBarListener.this.numErrors.addAndGet(1);\n-   83:             }\n-   84: \n-   85:             @Override\n-   86:             public void close() {\n-   87:                 // Refresh progress bar on file analysis end (or file was in cache)\n-   88:                 ProgressBarListener.this.incrementProgress();\n-   89:             }\n-   90:         };\n-   91:     }\n+   41: \n+   42:     /**\n+   43:      * Updates progress bar string and forces it to be output regardless of its update interval.\n+   44:      */\n+   60:     @Override\n+   61:     public FileAnalysisListener startFileAnalysis(DataSource file) {\n+   62:         // Refresh progress on file analysis start\n+   63:         refreshProgressBar();\n+   64: \n+   65:         return new FileAnalysisListener() {\n+   66:             @Override\n+   67:             public void onRuleViolation(RuleViolation violation) {\n+   68:                 ProgressBarListener.this.numViolations.addAndGet(1);\n+   69:             }\n+   70: \n+   71:             @Override\n+   72:             public void onSuppressedRuleViolation(Report.SuppressedViolation violation) {\n+   73:                 /*Not handled*/\n+   74:             }\n+   75: \n+   76:             @Override\n+   77:             public void onError(Report.ProcessingError error) {\n+   78:                 ProgressBarListener.this.numErrors.addAndGet(1);\n+   79:             }\n+   80: \n+   81:             @Override\n+   82:             public void close() {\n+   83:                 // Refresh progress bar on file analysis end (or file was in cache)\n+   84:                 progressBar.step();\n+   85:                 refreshProgressBar();\n+   86:             }\n+   87:         };\n+   88:     }\n+   89: \n+   90:     @Override\n+   91:     public void close() throws Exception {\n",
        "uniqueId": "70238044414cd846f6be19a568dc20eaeb793933_64_91__60_88_41_44",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 7
            },
            "LINE": {
                "missed": 0,
                "covered": 3
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic setFileName(fileName String, rootNode Node) : void extracted from public doParse(parser Parser, fileName String, source Reader) : Node in class net.sourceforge.pmd.lang.AbstractParser",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/lang/AbstractParser.java",
                "startLine": 42,
                "endLine": 49,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/lang/AbstractParser.java",
                "startLine": 42,
                "endLine": 47,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/lang/AbstractParser.java",
                "startLine": 49,
                "endLine": 53,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Deprecated\n    public static Node doParse(Parser parser, String fileName, Reader source) {\n        Node rootNode = parser.parse(fileName, source);\n        // remove prefixed path segments.\n        String simpleFileName = Paths.get(fileName).getFileName().toString();\n        rootNode.getUserMap().set(FileNameXPathFunction.FILE_NAME_KEY, simpleFileName);\n        return rootNode;\n    }",
        "filePathBefore": "pmd-core/src/main/java/net/sourceforge/pmd/lang/AbstractParser.java",
        "isPureRefactoring": true,
        "commitId": "41b03fec64b239029ca078cb1d047dd141fa9da6",
        "packageNameBefore": "net.sourceforge.pmd.lang",
        "classNameBefore": "net.sourceforge.pmd.lang.AbstractParser",
        "methodNameBefore": "net.sourceforge.pmd.lang.AbstractParser#doParse",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.ast.DummyNode#toString\n methodBody: public String toString() {\nreturn xpathName;\n}",
        "classSignatureBefore": "public abstract class AbstractParser implements Parser ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.AbstractParser#doParse"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.AbstractParser"
        ],
        "classSignatureBeforeSet": [
            "public abstract class AbstractParser implements Parser "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang;\n\nimport java.io.Reader;\nimport java.nio.file.Paths;\n\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.ast.xpath.internal.FileNameXPathFunction;\n\n/**\n * This is a generic implementation of the Parser interface.\n *\n * @see Parser\n *\n * @deprecated This will become useless in PMD 7. Implement or use {@link Parser} directly\n */\n@Deprecated\npublic abstract class AbstractParser implements Parser {\n    protected final ParserOptions parserOptions;\n\n    public AbstractParser(ParserOptions parserOptions) {\n        this.parserOptions = parserOptions;\n    }\n\n    @Override\n    public ParserOptions getParserOptions() {\n        return parserOptions;\n    }\n\n    @Override\n    public TokenManager getTokenManager(String fileName, Reader source) {\n        TokenManager tokenManager = createTokenManager(source);\n        tokenManager.setFileName(fileName);\n        return tokenManager;\n    }\n\n    protected abstract TokenManager createTokenManager(Reader source);\n\n    @Deprecated\n    public static Node doParse(Parser parser, String fileName, Reader source) {\n        Node rootNode = parser.parse(fileName, source);\n        // remove prefixed path segments.\n        String simpleFileName = Paths.get(fileName).getFileName().toString();\n        rootNode.getUserMap().set(FileNameXPathFunction.FILE_NAME_KEY, simpleFileName);\n        return rootNode;\n    }\n}\n",
        "filePathAfter": "pmd-core/src/main/java/net/sourceforge/pmd/lang/AbstractParser.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang;\n\nimport java.io.Reader;\nimport java.nio.file.Paths;\n\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.ast.xpath.internal.FileNameXPathFunction;\n\n/**\n * This is a generic implementation of the Parser interface.\n *\n * @see Parser\n *\n * @deprecated This will become useless in PMD 7. Implement or use {@link Parser} directly\n */\n@Deprecated\npublic abstract class AbstractParser implements Parser {\n    protected final ParserOptions parserOptions;\n\n    public AbstractParser(ParserOptions parserOptions) {\n        this.parserOptions = parserOptions;\n    }\n\n    @Override\n    public ParserOptions getParserOptions() {\n        return parserOptions;\n    }\n\n    @Override\n    public TokenManager getTokenManager(String fileName, Reader source) {\n        TokenManager tokenManager = createTokenManager(source);\n        tokenManager.setFileName(fileName);\n        return tokenManager;\n    }\n\n    protected abstract TokenManager createTokenManager(Reader source);\n\n    @Deprecated\n    public static Node doParse(Parser parser, String fileName, Reader source) {\n        Node rootNode = parser.parse(fileName, source);\n        setFileName(fileName, rootNode);\n        return rootNode;\n    }\n\n    public static void setFileName(String fileName, Node rootNode) {\n        // remove prefixed path segments.\n        String simpleFileName = Paths.get(fileName).getFileName().toString();\n        rootNode.getUserMap().set(FileNameXPathFunction.FILE_NAME_KEY, simpleFileName);\n    }\n}\n",
        "diffSourceCodeSet": [
            "public static void setFileName(String fileName, Node rootNode) {\n        // remove prefixed path segments.\n        String simpleFileName = Paths.get(fileName).getFileName().toString();\n        rootNode.getUserMap().set(FileNameXPathFunction.FILE_NAME_KEY, simpleFileName);\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.ast.DummyNode#toString\n methodBody: public String toString() {\nreturn xpathName;\n}"
        ],
        "sourceCodeAfterRefactoring": "@Deprecated\n    public static Node doParse(Parser parser, String fileName, Reader source) {\n        Node rootNode = parser.parse(fileName, source);\n        setFileName(fileName, rootNode);\n        return rootNode;\n    }\npublic static void setFileName(String fileName, Node rootNode) {\n        // remove prefixed path segments.\n        String simpleFileName = Paths.get(fileName).getFileName().toString();\n        rootNode.getUserMap().set(FileNameXPathFunction.FILE_NAME_KEY, simpleFileName);\n    }",
        "diffSourceCode": "    42:     @Deprecated\n    43:     public static Node doParse(Parser parser, String fileName, Reader source) {\n    44:         Node rootNode = parser.parse(fileName, source);\n-   45:         // remove prefixed path segments.\n-   46:         String simpleFileName = Paths.get(fileName).getFileName().toString();\n-   47:         rootNode.getUserMap().set(FileNameXPathFunction.FILE_NAME_KEY, simpleFileName);\n-   48:         return rootNode;\n-   49:     }\n-   50: }\n+   45:         setFileName(fileName, rootNode);\n+   46:         return rootNode;\n+   47:     }\n+   48: \n+   49:     public static void setFileName(String fileName, Node rootNode) {\n+   50:         // remove prefixed path segments.\n+   51:         String simpleFileName = Paths.get(fileName).getFileName().toString();\n+   52:         rootNode.getUserMap().set(FileNameXPathFunction.FILE_NAME_KEY, simpleFileName);\n+   53:     }\n",
        "uniqueId": "41b03fec64b239029ca078cb1d047dd141fa9da6_42_49_49_53_42_47",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 20
            },
            "LINE": {
                "missed": 0,
                "covered": 4
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Move Method",
        "description": "Move Method\tpublic getQualifiedName() : JavaOperationQualifiedName from class net.sourceforge.pmd.lang.java.ast.AbstractMethodLikeNode to public getQualifiedName() : JavaOperationQualifiedName from class net.sourceforge.pmd.lang.java.ast.AbstractMethodOrConstructorDeclaration",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractMethodLikeNode.java",
                "startLine": 24,
                "endLine": 28,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractMethodOrConstructorDeclaration.java",
                "startLine": 36,
                "endLine": 39,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n    @Deprecated\n    public JavaOperationQualifiedName getQualifiedName() {\n        return qualifiedName;\n    }",
        "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractMethodLikeNode.java",
        "isPureRefactoring": true,
        "commitId": "3191ef360dad948ffeb7b65c9c0d45dfa3bcc40c",
        "packageNameBefore": "net.sourceforge.pmd.lang.java.ast",
        "classNameBefore": "net.sourceforge.pmd.lang.java.ast.AbstractMethodLikeNode",
        "methodNameBefore": "net.sourceforge.pmd.lang.java.ast.AbstractMethodLikeNode#getQualifiedName",
        "classSignatureBefore": "abstract class AbstractMethodLikeNode extends AbstractJavaAccessNode implements MethodLikeNode ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.ast.AbstractMethodLikeNode#getQualifiedName"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.ast.AbstractMethodLikeNode"
        ],
        "classSignatureBeforeSet": [
            "abstract class AbstractMethodLikeNode extends AbstractJavaAccessNode implements MethodLikeNode "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.ast;\n\nimport net.sourceforge.pmd.lang.java.qname.JavaOperationQualifiedName;\n\nabstract class AbstractMethodLikeNode extends AbstractJavaAccessNode implements MethodLikeNode {\n\n    private JavaOperationQualifiedName qualifiedName;\n\n\n    AbstractMethodLikeNode(int i) {\n        super(i);\n    }\n\n\n    void setQualifiedName(JavaOperationQualifiedName qualifiedName) {\n        this.qualifiedName = qualifiedName;\n    }\n\n\n    @Override\n    @Deprecated\n    public JavaOperationQualifiedName getQualifiedName() {\n        return qualifiedName;\n    }\n\n}\n",
        "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractMethodOrConstructorDeclaration.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.ast;\n\nimport net.sourceforge.pmd.lang.java.multifile.signature.JavaOperationSignature;\nimport net.sourceforge.pmd.lang.java.qname.JavaOperationQualifiedName;\n\n\nabstract class AbstractMethodOrConstructorDeclaration extends AbstractJavaNode implements ASTMethodOrConstructorDeclaration, LeftRecursiveNode, AccessNode {\n\n    private JavaOperationSignature signature;\n    private JavaOperationQualifiedName qualifiedName;\n\n    AbstractMethodOrConstructorDeclaration(int i) {\n        super(i);\n    }\n\n\n    @Override\n    public JavaOperationSignature getSignature() {\n        if (signature == null) {\n            signature = JavaOperationSignature.buildFor(this);\n        }\n\n        return signature;\n    }\n\n\n    void setQualifiedName(JavaOperationQualifiedName qualifiedName) {\n        this.qualifiedName = qualifiedName;\n    }\n\n\n    @Override\n    public JavaOperationQualifiedName getQualifiedName() {\n        return qualifiedName;\n    }\n\n\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "@Override\n    public JavaOperationQualifiedName getQualifiedName() {\n        return qualifiedName;\n    }",
        "diffSourceCode": "-   24:     @Override\n-   25:     @Deprecated\n-   26:     public JavaOperationQualifiedName getQualifiedName() {\n-   27:         return qualifiedName;\n+   24:             signature = JavaOperationSignature.buildFor(this);\n+   25:         }\n+   26: \n+   27:         return signature;\n    28:     }\n+   36:     @Override\n+   37:     public JavaOperationQualifiedName getQualifiedName() {\n+   38:         return qualifiedName;\n+   39:     }\n",
        "uniqueId": "3191ef360dad948ffeb7b65c9c0d45dfa3bcc40c_24_28__36_39",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 3
            },
            "LINE": {
                "missed": 0,
                "covered": 1
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpackage findOps(node ASTUserClassOrInterface<?>) : List<ASTMethod> extracted from protected findOperations(node ASTUserClassOrInterface<?>) : List<ASTMethod> in class net.sourceforge.pmd.lang.apex.metrics.ApexMetricsComputer & moved to class net.sourceforge.pmd.lang.apex.metrics.ApexMetrics",
        "diffLocations": [
            {
                "filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/ApexMetricsComputer.java",
                "startLine": 31,
                "endLine": 41,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/ApexMetricsComputer.java",
                "startLine": 23,
                "endLine": 26,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/ApexMetricsComputer.java",
                "startLine": 140,
                "endLine": 150,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n    protected List<ASTMethod> findOperations(ASTUserClassOrInterface<?> node) {\n        List<ASTMethod> candidates = node.findChildrenOfType(ASTMethod.class);\n        List<ASTMethod> result = new ArrayList<>(candidates);\n        for (ASTMethod method : candidates) {\n            if (method.getImage().matches(\"(<clinit>|<init>|clone)\")) {\n                result.remove(method);\n            }\n        }\n        return result;\n    }",
        "filePathBefore": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/ApexMetricsComputer.java",
        "isPureRefactoring": true,
        "commitId": "2123ab3d5d7dcfc867ada3af119c3d3e9cb6183e",
        "packageNameBefore": "net.sourceforge.pmd.lang.apex.metrics",
        "classNameBefore": "net.sourceforge.pmd.lang.apex.metrics.ApexMetricsComputer",
        "methodNameBefore": "net.sourceforge.pmd.lang.apex.metrics.ApexMetricsComputer#findOperations",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.ast.Node#getImage\n methodBody: String getImage();\nmethodSignature: net.sourceforge.pmd.lang.ast.Node#remove\n methodBody: void remove();\nmethodSignature: net.sourceforge.pmd.lang.ast.Node#findChildrenOfType\n methodBody: T> List<T> findChildrenOfType(Class<T> childType);",
        "classSignatureBefore": "public class ApexMetricsComputer extends AbstractMetricsComputer<ASTUserClassOrInterface<?>, ASTMethod> ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.apex.metrics.ApexMetricsComputer#findOperations"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.apex.metrics.ApexMetricsComputer"
        ],
        "classSignatureBeforeSet": [
            "public class ApexMetricsComputer extends AbstractMetricsComputer<ASTUserClassOrInterface<?>, ASTMethod> "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex.metrics;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.lang.apex.ast.ASTMethod;\nimport net.sourceforge.pmd.lang.apex.ast.ASTUserClassOrInterface;\nimport net.sourceforge.pmd.lang.metrics.AbstractMetricsComputer;\n\n/**\n * Computes metrics for the Apex framework.\n *\n * @author Cl\u00e9ment Fournier\n */\npublic class ApexMetricsComputer extends AbstractMetricsComputer<ASTUserClassOrInterface<?>, ASTMethod> {\n\n    private static final ApexMetricsComputer INSTANCE = new ApexMetricsComputer();\n\n\n    @InternalApi\n    public static ApexMetricsComputer getInstance() {\n        return INSTANCE;\n    }\n\n\n    @Override\n    protected List<ASTMethod> findOperations(ASTUserClassOrInterface<?> node) {\n        List<ASTMethod> candidates = node.findChildrenOfType(ASTMethod.class);\n        List<ASTMethod> result = new ArrayList<>(candidates);\n        for (ASTMethod method : candidates) {\n            if (method.getImage().matches(\"(<clinit>|<init>|clone)\")) {\n                result.remove(method);\n            }\n        }\n        return result;\n    }\n}\n",
        "filePathAfter": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/ApexMetricsComputer.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex.metrics;\n\nimport java.util.List;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.lang.apex.ast.ASTMethod;\nimport net.sourceforge.pmd.lang.apex.ast.ASTUserClassOrInterface;\nimport net.sourceforge.pmd.lang.metrics.AbstractMetricsComputer;\n\n/**\n * Computes metrics for the Apex framework.\n *\n * @author Cl\u00e9ment Fournier\n */\npublic class ApexMetricsComputer extends AbstractMetricsComputer<ASTUserClassOrInterface<?>, ASTMethod> {\n\n    private static final ApexMetricsComputer INSTANCE = new ApexMetricsComputer();\n\n    @Override\n    protected List<ASTMethod> findOperations(ASTUserClassOrInterface<?> node) {\n        return ApexMetrics.findOps(node);\n    }\n\n    @InternalApi\n    public static ApexMetricsComputer getInstance() {\n        return INSTANCE;\n    }\n\n}\n",
        "diffSourceCodeSet": [
            ""
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.ast.Node#getImage\n methodBody: String getImage();",
            "methodSignature: net.sourceforge.pmd.lang.ast.Node#remove\n methodBody: void remove();",
            "methodSignature: net.sourceforge.pmd.lang.ast.Node#findChildrenOfType\n methodBody: T> List<T> findChildrenOfType(Class<T> childType);"
        ],
        "sourceCodeAfterRefactoring": "@Override\n    protected List<ASTMethod> findOperations(ASTUserClassOrInterface<?> node) {\n        return ApexMetrics.findOps(node);\n    }\n",
        "diffSourceCode": "-   23: \n-   24: \n-   25:     @InternalApi\n-   26:     public static ApexMetricsComputer getInstance() {\n-   31:     @Override\n-   32:     protected List<ASTMethod> findOperations(ASTUserClassOrInterface<?> node) {\n-   33:         List<ASTMethod> candidates = node.findChildrenOfType(ASTMethod.class);\n-   34:         List<ASTMethod> result = new ArrayList<>(candidates);\n-   35:         for (ASTMethod method : candidates) {\n-   36:             if (method.getImage().matches(\"(<clinit>|<init>|clone)\")) {\n-   37:                 result.remove(method);\n-   38:             }\n-   39:         }\n-   40:         return result;\n-   41:     }\n+   23:     @Override\n+   24:     protected List<ASTMethod> findOperations(ASTUserClassOrInterface<?> node) {\n+   25:         return ApexMetrics.findOps(node);\n+   26:     }\n+   31:     }\n+   32: \n+   33: }\n",
        "uniqueId": "2123ab3d5d7dcfc867ada3af119c3d3e9cb6183e_31_41_140_150_23_26",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 31
            },
            "BRANCH": {
                "missed": 0,
                "covered": 4
            },
            "LINE": {
                "missed": 0,
                "covered": 7
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 3
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic loadClassOrNull(name String) : Class<?> extracted from public loadClass(name String) : Class<?> in class net.sourceforge.pmd.lang.java.typeresolution.PMDASMClassLoader",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/typeresolution/PMDASMClassLoader.java",
                "startLine": 71,
                "endLine": 89,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/typeresolution/PMDASMClassLoader.java",
                "startLine": 71,
                "endLine": 78,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/typeresolution/PMDASMClassLoader.java",
                "startLine": 80,
                "endLine": 95,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n    public Class<?> loadClass(String name) throws ClassNotFoundException {\n        if (dontBother.containsKey(name)) {\n            throw new ClassNotFoundException(name);\n        }\n\n        try {\n            return super.loadClass(name);\n        } catch (ClassNotFoundException e) {\n            dontBother.put(name, Boolean.TRUE);\n            throw e;\n        } catch (NoClassDefFoundError e) {\n            dontBother.put(name, Boolean.TRUE);\n            // rethrow as ClassNotFoundException, as the remaining part just\n            // deals with that\n            // see also: https://sourceforge.net/p/pmd/bugs/1319/\n            throw new ClassNotFoundException(name, e);\n        }\n    }",
        "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/typeresolution/PMDASMClassLoader.java",
        "isPureRefactoring": true,
        "commitId": "19d35ff9e2866b299bce258bc2301c02ff779072",
        "packageNameBefore": "net.sourceforge.pmd.lang.java.typeresolution",
        "classNameBefore": "net.sourceforge.pmd.lang.java.typeresolution.PMDASMClassLoader",
        "methodNameBefore": "net.sourceforge.pmd.lang.java.typeresolution.PMDASMClassLoader#loadClass",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.java.typeresolution.ClassTypeResolver#loadClass\n methodBody: public Class<?> loadClass(String fullyQualifiedClassName) {\ntryreturn pmdClassLoader.loadClass(fullyQualifiedClassName);\ncatch(ClassNotFoundException e)return null;\ncatch(LinkageError e2)if(LOG.isLoggable(Level.FINE)){LOG.log(Level.FINE,\"Tried to load class \" + fullyQualifiedClassName + \" from on demand import, \" + \"with an incomplete classpath.\",e2);\n}return null;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.typeresolution.PMDASMClassLoader#loadClass\n methodBody: public Class<?> loadClass(String name) throws ClassNotFoundException {\nif(dontBother.containsKey(name)){throw new ClassNotFoundException(name);\n}tryreturn super.loadClass(name);\ncatch(ClassNotFoundException e)dontBother.put(name,Boolean.TRUE);\nthrow e;\ncatch(NoClassDefFoundError e)dontBother.put(name,Boolean.TRUE);\nthrow new ClassNotFoundException(name,e);\n}",
        "classSignatureBefore": "public final class PMDASMClassLoader extends ClassLoader ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.typeresolution.PMDASMClassLoader#loadClass"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.typeresolution.PMDASMClassLoader"
        ],
        "classSignatureBeforeSet": [
            "public final class PMDASMClassLoader extends ClassLoader "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics Severe changes",
                "description": "Just an empty block - with non-mapped leaves",
                "mappingState": 3
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.typeresolution;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nimport org.objectweb.asm.ClassReader;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.lang.java.typeresolution.visitors.PMDASMVisitor;\n\n/*\n * I've refactored this class to not cache the results any more. This is a\n * tradeoff in testing I've found the CPU tradeoff is negligeable. With the\n * cache, large codebases consumed a lot of memory and slowed down greatly when\n * approaching 3,000 classes. I'm adding this comment in case someone is looking\n * at this code and thinks a cache may help.\n *\n * see: git show 9e7deee88f63870a1de2cd86458278a027deb6d6\n *\n * However, there seems to be a big performance improvement by caching\n * the negative cases only. The cache is shared between loadClass and getImportedClasses,\n * as they are using the same (parent) class loader, e.g. if the class foo.Bar cannot be loaded,\n * then the resource foo/Bar.class will not exist, too.\n * \n * Note: since git show 46ad3a4700b7a233a177fa77d08110127a85604c the cache is using\n * a concurrent hash map to avoid synchronizing on the class loader instance.\n */\n@InternalApi\n@Deprecated\npublic final class PMDASMClassLoader extends ClassLoader {\n\n    private static PMDASMClassLoader cachedPMDASMClassLoader;\n    private static ClassLoader cachedClassLoader;\n\n    /**\n     * Caches the names of the classes that we can't load or that don't exist.\n     */\n    private final ConcurrentMap<String, Boolean> dontBother = new ConcurrentHashMap<>();\n\n    static {\n        registerAsParallelCapable();\n    }\n\n    private PMDASMClassLoader(ClassLoader parent) {\n        super(parent);\n    }\n\n    /**\n     * A new PMDASMClassLoader is created for each compilation unit, this method\n     * allows to reuse the same PMDASMClassLoader across all the compilation\n     * units.\n     */\n    public static synchronized PMDASMClassLoader getInstance(ClassLoader parent) {\n        if (parent.equals(cachedClassLoader)) {\n            return cachedPMDASMClassLoader;\n        }\n        cachedClassLoader = parent;\n        cachedPMDASMClassLoader = new PMDASMClassLoader(parent);\n        return cachedPMDASMClassLoader;\n    }\n\n    @Override\n    public Class<?> loadClass(String name) throws ClassNotFoundException {\n        if (dontBother.containsKey(name)) {\n            throw new ClassNotFoundException(name);\n        }\n\n        try {\n            return super.loadClass(name);\n        } catch (ClassNotFoundException e) {\n            dontBother.put(name, Boolean.TRUE);\n            throw e;\n        } catch (NoClassDefFoundError e) {\n            dontBother.put(name, Boolean.TRUE);\n            // rethrow as ClassNotFoundException, as the remaining part just\n            // deals with that\n            // see also: https://sourceforge.net/p/pmd/bugs/1319/\n            throw new ClassNotFoundException(name, e);\n        }\n    }\n\n    /**\n     * Checks if the class loader could resolve a given class name (ie: it\n     * doesn't know for sure it will fail). Notice, that the ability to resolve\n     * a class does not imply that the class will actually be found and\n     * resolved.\n     * \n     * @param name\n     *            the name of the class\n     * @return whether the class can be resolved\n     */\n    public boolean couldResolve(String name) {\n        return !dontBother.containsKey(name);\n    }\n\n    public synchronized Map<String, String> getImportedClasses(String name) throws ClassNotFoundException {\n        if (dontBother.containsKey(name)) {\n            throw new ClassNotFoundException(name);\n        }\n        try (InputStream classResource = getResourceAsStream(name.replace('.', '/') + \".class\")) {\n            ClassReader reader = new ClassReader(classResource);\n            PMDASMVisitor asmVisitor = new PMDASMVisitor(name);\n            reader.accept(asmVisitor, 0);\n\n            List<String> inner = asmVisitor.getInnerClasses();\n            if (inner != null && !inner.isEmpty()) {\n                // to avoid ConcurrentModificationException\n                inner = new ArrayList<>(inner);\n                for (String str : inner) {\n                    try (InputStream innerClassStream = getResourceAsStream(str.replace('.', '/') + \".class\")) {\n                        if (innerClassStream != null) {\n                            reader = new ClassReader(innerClassStream);\n                            reader.accept(asmVisitor, 0);\n                        }\n                    }\n                }\n            }\n            return asmVisitor.getPackages();\n        } catch (IOException e) {\n            dontBother.put(name, Boolean.TRUE);\n            throw new ClassNotFoundException(name, e);\n        }\n    }\n}\n",
        "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/typeresolution/PMDASMClassLoader.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.typeresolution;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nimport org.objectweb.asm.ClassReader;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.lang.java.typeresolution.visitors.PMDASMVisitor;\n\n/*\n * I've refactored this class to not cache the results any more. This is a\n * tradeoff in testing I've found the CPU tradeoff is negligeable. With the\n * cache, large codebases consumed a lot of memory and slowed down greatly when\n * approaching 3,000 classes. I'm adding this comment in case someone is looking\n * at this code and thinks a cache may help.\n *\n * see: git show 9e7deee88f63870a1de2cd86458278a027deb6d6\n *\n * However, there seems to be a big performance improvement by caching\n * the negative cases only. The cache is shared between loadClass and getImportedClasses,\n * as they are using the same (parent) class loader, e.g. if the class foo.Bar cannot be loaded,\n * then the resource foo/Bar.class will not exist, too.\n *\n * Note: since git show 46ad3a4700b7a233a177fa77d08110127a85604c the cache is using\n * a concurrent hash map to avoid synchronizing on the class loader instance.\n */\n@InternalApi\n@Deprecated\npublic final class PMDASMClassLoader extends ClassLoader {\n\n    private static PMDASMClassLoader cachedPMDASMClassLoader;\n    private static ClassLoader cachedClassLoader;\n\n    /**\n     * Caches the names of the classes that we can't load or that don't exist.\n     */\n    private final ConcurrentMap<String, Boolean> dontBother = new ConcurrentHashMap<>();\n\n    static {\n        registerAsParallelCapable();\n    }\n\n    private PMDASMClassLoader(ClassLoader parent) {\n        super(parent);\n    }\n\n    /**\n     * A new PMDASMClassLoader is created for each compilation unit, this method\n     * allows to reuse the same PMDASMClassLoader across all the compilation\n     * units.\n     */\n    public static synchronized PMDASMClassLoader getInstance(ClassLoader parent) {\n        if (parent.equals(cachedClassLoader)) {\n            return cachedPMDASMClassLoader;\n        }\n        cachedClassLoader = parent;\n        cachedPMDASMClassLoader = new PMDASMClassLoader(parent);\n        return cachedPMDASMClassLoader;\n    }\n\n    @Override\n    public Class<?> loadClass(String name) throws ClassNotFoundException {\n        Class<?> aClass = loadClassOrNull(name);\n        if (aClass == null) {\n            throw new ClassNotFoundException(name);\n        }\n        return aClass;\n    }\n\n    /**\n     * Not throwing CNFEs to represent failure makes a huge performance\n     * difference. Typeres as a whole is 2x faster.\n     */\n    public Class<?> loadClassOrNull(String name) {\n        if (dontBother.containsKey(name)) {\n            return null;\n        }\n\n        try {\n            return super.loadClass(name);\n        } catch (ClassNotFoundException | LinkageError e) {\n            dontBother.put(name, Boolean.TRUE);\n            return null;\n        }\n    }\n\n    /**\n     * Checks if the class loader could resolve a given class name (ie: it\n     * doesn't know for sure it will fail). Notice, that the ability to resolve\n     * a class does not imply that the class will actually be found and\n     * resolved.\n     *\n     * @param name\n     *            the name of the class\n     * @return whether the class can be resolved\n     */\n    public boolean couldResolve(String name) {\n        return !dontBother.containsKey(name);\n    }\n\n    public synchronized Map<String, String> getImportedClasses(String name) throws ClassNotFoundException {\n        if (dontBother.containsKey(name)) {\n            throw new ClassNotFoundException(name);\n        }\n        try (InputStream classResource = getResourceAsStream(name.replace('.', '/') + \".class\")) {\n            ClassReader reader = new ClassReader(classResource);\n            PMDASMVisitor asmVisitor = new PMDASMVisitor(name);\n            reader.accept(asmVisitor, 0);\n\n            List<String> inner = asmVisitor.getInnerClasses();\n            if (inner != null && !inner.isEmpty()) {\n                // to avoid ConcurrentModificationException\n                inner = new ArrayList<>(inner);\n                for (String str : inner) {\n                    try (InputStream innerClassStream = getResourceAsStream(str.replace('.', '/') + \".class\")) {\n                        if (innerClassStream != null) {\n                            reader = new ClassReader(innerClassStream);\n                            reader.accept(asmVisitor, 0);\n                        }\n                    }\n                }\n            }\n            return asmVisitor.getPackages();\n        } catch (IOException e) {\n            dontBother.put(name, Boolean.TRUE);\n            throw new ClassNotFoundException(name, e);\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * Not throwing CNFEs to represent failure makes a huge performance\n     * difference. Typeres as a whole is 2x faster.\n     */\n    public Class<?> loadClassOrNull(String name) {\n        if (dontBother.containsKey(name)) {\n            return null;\n        }\n\n        try {\n            return super.loadClass(name);\n        } catch (ClassNotFoundException | LinkageError e) {\n            dontBother.put(name, Boolean.TRUE);\n            return null;\n        }\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.java.typeresolution.ClassTypeResolver#loadClass\n methodBody: public Class<?> loadClass(String fullyQualifiedClassName) {\ntryreturn pmdClassLoader.loadClass(fullyQualifiedClassName);\ncatch(ClassNotFoundException e)return null;\ncatch(LinkageError e2)if(LOG.isLoggable(Level.FINE)){LOG.log(Level.FINE,\"Tried to load class \" + fullyQualifiedClassName + \" from on demand import, \" + \"with an incomplete classpath.\",e2);\n}return null;\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.typeresolution.PMDASMClassLoader#loadClass\n methodBody: public Class<?> loadClass(String name) throws ClassNotFoundException {\nif(dontBother.containsKey(name)){throw new ClassNotFoundException(name);\n}tryreturn super.loadClass(name);\ncatch(ClassNotFoundException e)dontBother.put(name,Boolean.TRUE);\nthrow e;\ncatch(NoClassDefFoundError e)dontBother.put(name,Boolean.TRUE);\nthrow new ClassNotFoundException(name,e);\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n    public Class<?> loadClass(String name) throws ClassNotFoundException {\n        Class<?> aClass = loadClassOrNull(name);\n        if (aClass == null) {\n            throw new ClassNotFoundException(name);\n        }\n        return aClass;\n    }\n/**\n     * Not throwing CNFEs to represent failure makes a huge performance\n     * difference. Typeres as a whole is 2x faster.\n     */\n    public Class<?> loadClassOrNull(String name) {\n        if (dontBother.containsKey(name)) {\n            return null;\n        }\n\n        try {\n            return super.loadClass(name);\n        } catch (ClassNotFoundException | LinkageError e) {\n            dontBother.put(name, Boolean.TRUE);\n            return null;\n        }\n    }",
        "diffSourceCode": "    71:     @Override\n    72:     public Class<?> loadClass(String name) throws ClassNotFoundException {\n-   73:         if (dontBother.containsKey(name)) {\n-   74:             throw new ClassNotFoundException(name);\n-   75:         }\n-   76: \n-   77:         try {\n-   78:             return super.loadClass(name);\n-   79:         } catch (ClassNotFoundException e) {\n-   80:             dontBother.put(name, Boolean.TRUE);\n-   81:             throw e;\n-   82:         } catch (NoClassDefFoundError e) {\n-   83:             dontBother.put(name, Boolean.TRUE);\n-   84:             // rethrow as ClassNotFoundException, as the remaining part just\n-   85:             // deals with that\n-   86:             // see also: https://sourceforge.net/p/pmd/bugs/1319/\n-   87:             throw new ClassNotFoundException(name, e);\n-   88:         }\n-   89:     }\n-   90: \n-   91:     /**\n-   92:      * Checks if the class loader could resolve a given class name (ie: it\n-   93:      * doesn't know for sure it will fail). Notice, that the ability to resolve\n-   94:      * a class does not imply that the class will actually be found and\n-   95:      * resolved.\n+   73:         Class<?> aClass = loadClassOrNull(name);\n+   74:         if (aClass == null) {\n+   75:             throw new ClassNotFoundException(name);\n+   76:         }\n+   77:         return aClass;\n+   78:     }\n+   79: \n+   80:     /**\n+   81:      * Not throwing CNFEs to represent failure makes a huge performance\n+   82:      * difference. Typeres as a whole is 2x faster.\n+   83:      */\n+   84:     public Class<?> loadClassOrNull(String name) {\n+   85:         if (dontBother.containsKey(name)) {\n+   86:             return null;\n+   87:         }\n+   88: \n+   89:         try {\n+   90:             return super.loadClass(name);\n+   91:         } catch (ClassNotFoundException | LinkageError e) {\n+   92:             dontBother.put(name, Boolean.TRUE);\n+   93:             return null;\n+   94:         }\n+   95:     }\n",
        "uniqueId": "19d35ff9e2866b299bce258bc2301c02ff779072_71_89_80_95_71_78",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 13,
                "covered": 23
            },
            "BRANCH": {
                "missed": 0,
                "covered": 2
            },
            "LINE": {
                "missed": 3,
                "covered": 6
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 2
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic getEndToken(mark TokenEntry, match Match) : TokenEntry extracted from public getLineCount(mark TokenEntry, match Match) : int in class net.sourceforge.pmd.cpd.Tokens",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/cpd/Tokens.java",
                "startLine": 31,
                "endLine": 37,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/cpd/Tokens.java",
                "startLine": 35,
                "endLine": 41,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/cpd/Tokens.java",
                "startLine": 31,
                "endLine": 33,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public int getLineCount(TokenEntry mark, Match match) {\n        TokenEntry endTok = get(mark.getIndex() + match.getTokenCount() - 1);\n        if (endTok == TokenEntry.EOF) {\n            endTok = get(mark.getIndex() + match.getTokenCount() - 2);\n        }\n        return endTok.getBeginLine() - mark.getBeginLine() + 1;\n    }",
        "filePathBefore": "pmd-core/src/main/java/net/sourceforge/pmd/cpd/Tokens.java",
        "isPureRefactoring": true,
        "commitId": "f79941e174911ddbf7edf977da813522ccffd7ab",
        "packageNameBefore": "net.sourceforge.pmd.cpd",
        "classNameBefore": "net.sourceforge.pmd.cpd.Tokens",
        "methodNameBefore": "net.sourceforge.pmd.cpd.Tokens#getLineCount",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.cpd.Tokens#get\n methodBody: private TokenEntry get(int index) {\nreturn tokens.get(index);\n}\nmethodSignature: net.sourceforge.pmd.cpd.Mark#getBeginLine\n methodBody: public int getBeginLine() {\nreturn this.token.getBeginLine();\n}\nmethodSignature: net.sourceforge.pmd.cpd.TokenEntry#getBeginLine\n methodBody: public int getBeginLine() {\nreturn beginLine;\n}\nmethodSignature: net.sourceforge.pmd.cpd.TokenEntry#getIndex\n methodBody: public int getIndex() {\nreturn this.index;\n}",
        "classSignatureBefore": "public class Tokens ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.cpd.Tokens#getLineCount"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.cpd.Tokens"
        ],
        "classSignatureBeforeSet": [
            "public class Tokens "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.cpd;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class Tokens {\n\n    private List<TokenEntry> tokens = new ArrayList<>();\n\n    public void add(TokenEntry tokenEntry) {\n        this.tokens.add(tokenEntry);\n    }\n\n    public Iterator<TokenEntry> iterator() {\n        return tokens.iterator();\n    }\n\n    private TokenEntry get(int index) {\n        return tokens.get(index);\n    }\n\n    public int size() {\n        return tokens.size();\n    }\n\n    public int getLineCount(TokenEntry mark, Match match) {\n        TokenEntry endTok = get(mark.getIndex() + match.getTokenCount() - 1);\n        if (endTok == TokenEntry.EOF) {\n            endTok = get(mark.getIndex() + match.getTokenCount() - 2);\n        }\n        return endTok.getBeginLine() - mark.getBeginLine() + 1;\n    }\n\n    public List<TokenEntry> getTokens() {\n        return tokens;\n    }\n\n}\n",
        "filePathAfter": "pmd-core/src/main/java/net/sourceforge/pmd/cpd/Tokens.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.cpd;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class Tokens {\n\n    private List<TokenEntry> tokens = new ArrayList<>();\n\n    public void add(TokenEntry tokenEntry) {\n        this.tokens.add(tokenEntry);\n    }\n\n    public Iterator<TokenEntry> iterator() {\n        return tokens.iterator();\n    }\n\n    private TokenEntry get(int index) {\n        return tokens.get(index);\n    }\n\n    public int size() {\n        return tokens.size();\n    }\n\n    public TokenEntry getEndToken(TokenEntry mark, Match match) {\n        return get(mark.getIndex() + match.getTokenCount() - 1);\n    }\n\n    public int getLineCount(TokenEntry mark, Match match) {\n        TokenEntry endTok = getEndToken(mark, match);\n        if (endTok == TokenEntry.EOF) {\n            endTok = get(mark.getIndex() + match.getTokenCount() - 2);\n        }\n        return endTok.getBeginLine() - mark.getBeginLine() + 1;\n    }\n\n    public List<TokenEntry> getTokens() {\n        return tokens;\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "public TokenEntry getEndToken(TokenEntry mark, Match match) {\n        return get(mark.getIndex() + match.getTokenCount() - 1);\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.cpd.Tokens#get\n methodBody: private TokenEntry get(int index) {\nreturn tokens.get(index);\n}",
            "methodSignature: net.sourceforge.pmd.cpd.Mark#getBeginLine\n methodBody: public int getBeginLine() {\nreturn this.token.getBeginLine();\n}",
            "methodSignature: net.sourceforge.pmd.cpd.TokenEntry#getBeginLine\n methodBody: public int getBeginLine() {\nreturn beginLine;\n}",
            "methodSignature: net.sourceforge.pmd.cpd.TokenEntry#getIndex\n methodBody: public int getIndex() {\nreturn this.index;\n}"
        ],
        "sourceCodeAfterRefactoring": "public int getLineCount(TokenEntry mark, Match match) {\n        TokenEntry endTok = getEndToken(mark, match);\n        if (endTok == TokenEntry.EOF) {\n            endTok = get(mark.getIndex() + match.getTokenCount() - 2);\n        }\n        return endTok.getBeginLine() - mark.getBeginLine() + 1;\n    }\npublic TokenEntry getEndToken(TokenEntry mark, Match match) {\n        return get(mark.getIndex() + match.getTokenCount() - 1);\n    }",
        "diffSourceCode": "-   31:     public int getLineCount(TokenEntry mark, Match match) {\n-   32:         TokenEntry endTok = get(mark.getIndex() + match.getTokenCount() - 1);\n-   33:         if (endTok == TokenEntry.EOF) {\n-   34:             endTok = get(mark.getIndex() + match.getTokenCount() - 2);\n-   35:         }\n-   36:         return endTok.getBeginLine() - mark.getBeginLine() + 1;\n-   37:     }\n-   38: \n-   39:     public List<TokenEntry> getTokens() {\n-   40:         return tokens;\n+   31:     public TokenEntry getEndToken(TokenEntry mark, Match match) {\n+   32:         return get(mark.getIndex() + match.getTokenCount() - 1);\n+   33:     }\n+   34: \n+   35:     public int getLineCount(TokenEntry mark, Match match) {\n+   36:         TokenEntry endTok = getEndToken(mark, match);\n+   37:         if (endTok == TokenEntry.EOF) {\n+   38:             endTok = get(mark.getIndex() + match.getTokenCount() - 2);\n+   39:         }\n+   40:         return endTok.getBeginLine() - mark.getBeginLine() + 1;\n    41:     }\n",
        "uniqueId": "f79941e174911ddbf7edf977da813522ccffd7ab_31_37_31_33_35_41",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 10,
                "covered": 21
            },
            "BRANCH": {
                "missed": 1,
                "covered": 1
            },
            "LINE": {
                "missed": 1,
                "covered": 3
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Move Method",
        "description": "Move Method\tpackage setVarargs() : void from class net.sourceforge.pmd.lang.java.ast.ASTFormalParameter to package setVarargs() : void from class net.sourceforge.pmd.lang.java.ast.ASTArrayTypeDim",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTFormalParameter.java",
                "startLine": 38,
                "endLine": 40,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTArrayTypeDim.java",
                "startLine": 42,
                "endLine": 44,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "void setVarargs() {\n        isVarargs = true;\n    }",
        "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTFormalParameter.java",
        "isPureRefactoring": true,
        "commitId": "1eab9448e720a8bf88a70583b272cd3e84fc1af3",
        "packageNameBefore": "net.sourceforge.pmd.lang.java.ast",
        "classNameBefore": "net.sourceforge.pmd.lang.java.ast.ASTFormalParameter",
        "methodNameBefore": "net.sourceforge.pmd.lang.java.ast.ASTFormalParameter#setVarargs",
        "classSignatureBefore": "public class ASTFormalParameter extends AbstractJavaAccessTypeNode implements Dimensionable ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.ast.ASTFormalParameter#setVarargs"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.ast.ASTFormalParameter"
        ],
        "classSignatureBeforeSet": [
            "public class ASTFormalParameter extends AbstractJavaAccessTypeNode implements Dimensionable "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.ast;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.lang.java.typeresolution.typedefinition.JavaTypeDefinition;\n\n\n/**\n * Formal parameter node. Used in the {@link ASTFormalParameters}\n * production of {@link ASTMethodDeclarator} to represent a\n * method's formal parameter. Also used in the {@link ASTCatchClause}\n * production to represent the declared exception variable.\n * Also used in LambdaExpressions for the LambdaParameters.\n *\n * <pre class=\"grammar\">\n *\n * FormalParameter ::= ( \"final\" | {@link ASTAnnotation Annotation} )* {@link ASTType Type} ( \"|\" {@link ASTType Type} )* [ \"...\" ] {@link ASTVariableDeclaratorId VariableDeclaratorId}\n * </pre>\n */\npublic class ASTFormalParameter extends AbstractJavaAccessTypeNode implements Dimensionable {\n\n    private boolean isVarargs;\n\n    @InternalApi\n    @Deprecated\n    public ASTFormalParameter(int id) {\n        super(id);\n    }\n\n    ASTFormalParameter(JavaParser p, int id) {\n        super(p, id);\n    }\n\n\n    void setVarargs() {\n        isVarargs = true;\n    }\n\n\n    /**\n     * Returns true if this node is a varargs parameter.\n     */\n    public boolean isVarargs() {\n        return isVarargs;\n    }\n\n\n    /**\n     * If true, this formal parameter represents one without explit types.\n     * This can appear as part of a lambda expression with java11 using \"var\".\n     *\n     * @see ASTVariableDeclaratorId#isTypeInferred()\n     */\n    public boolean isTypeInferred() {\n        return getTypeNode() == null;\n    }\n\n    @Override\n    public Object jjtAccept(JavaParserVisitor visitor, Object data) {\n        return visitor.visit(this, data);\n    }\n\n\n    @Override\n    public <T> void jjtAccept(SideEffectingVisitor<T> visitor, T data) {\n        visitor.visit(this, data);\n    }\n\n\n    /**\n     * Returns the declarator ID of this formal parameter.\n     */\n    public ASTVariableDeclaratorId getVariableDeclaratorId() {\n        return getFirstChildOfType(ASTVariableDeclaratorId.class);\n    }\n\n\n    /**\n     * Returns true if this formal parameter is of an array type.\n     * This includes varargs parameters.\n     */\n    @Override\n    @Deprecated\n    public boolean isArray() {\n        return isVarargs()\n                || getTypeNode() != null && getTypeNode().isArrayType()\n                || getVariableDeclaratorId().isArray();\n    }\n\n    @Override\n    @Deprecated\n    public int getArrayDepth() {\n        if (!isArray()) {\n            return 0;\n        }\n        return getTypeNode().getArrayDepth() + getVariableDeclaratorId().getArrayDepth() + (isVarargs() ? 1 : 0);\n    }\n\n\n    /**\n     * Returns the type node of this formal parameter.\n     * The type of that node is not necessarily the type\n     * of the parameter itself, see {@link ASTVariableDeclaratorId#getType()}.\n     *\n     * <p>In particular, the type of the returned node\n     * doesn't take into account whether this formal\n     * parameter is varargs or not.\n     */\n    public ASTType getTypeNode() {\n        return getFirstChildOfType(ASTType.class);\n    }\n\n\n    /**\n     * @deprecated use {@link #getVariableDeclaratorId()}\n     */\n    @Deprecated\n    protected ASTVariableDeclaratorId getDecl() {\n        return getVariableDeclaratorId();\n    }\n\n    /**\n     * Returns the type of this formal parameter. That type\n     * is exactly that of the variable declarator id,\n     * which means that the declarator id's type takes into\n     * account whether this parameter is varargs or not.\n     */\n    @Override\n    public Class<?> getType() {\n        return getVariableDeclaratorId().getType();\n    }\n\n\n    @Override\n    public JavaTypeDefinition getTypeDefinition() {\n        return getVariableDeclaratorId().getTypeDefinition();\n    }\n\n\n    /**\n     * Noop, the type of this node is defined by the type\n     * of the declarator id.\n     */\n    @InternalApi\n    @Deprecated\n    @Override\n    public void setTypeDefinition(JavaTypeDefinition type) {\n        // see javadoc\n    }\n\n}\n",
        "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTArrayTypeDim.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.ast;\n\n/**\n * Represents an array dimension in an {@linkplain ASTArrayType array type},\n * or in an {@linkplain ASTArrayAllocation array allocation expression}.\n *\n * <p>{@linkplain ASTArrayDimExpr ArrayDimExpr} represents array dimensions\n * that are initialized with a length, in array allocation expressions.\n *\n * <pre class=\"grammar\">\n *\n * ArrayTypeDim ::= {@link ASTAnnotation TypeAnnotation}* \"[\" \"]\"\n *\n * </pre>\n */\npublic class ASTArrayTypeDim extends AbstractJavaNode implements Annotatable {\n\n    private boolean isVarargs;\n\n    ASTArrayTypeDim(int id) {\n        super(id);\n    }\n\n    ASTArrayTypeDim(JavaParser p, int id) {\n        super(p, id);\n    }\n\n    /**\n     * Returns true if this is a varargs dimension. Varargs parameters\n     * are represented as an array type whose last dimension has this\n     * attribute set to true. Querying {@link ASTFormalParameter#isVarargs()}\n     * is more convenient.\n     */\n    public boolean isVarargs() {\n        return isVarargs;\n    }\n\n    void setVarargs() {\n        isVarargs = true;\n    }\n\n    @Override\n    public Object jjtAccept(JavaParserVisitor visitor, Object data) {\n        return visitor.visit(this, data);\n    }\n\n\n    @Override\n    public <T> void jjtAccept(SideEffectingVisitor<T> visitor, T data) {\n        visitor.visit(this, data);\n    }\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "void setVarargs() {\n        isVarargs = true;\n    }",
        "diffSourceCode": "-   38:     void setVarargs() {\n-   39:         isVarargs = true;\n+   38:     public boolean isVarargs() {\n+   39:         return isVarargs;\n    40:     }\n-   42: \n-   43:     /**\n-   44:      * Returns true if this node is a varargs parameter.\n+   42:     void setVarargs() {\n+   43:         isVarargs = true;\n+   44:     }\n",
        "uniqueId": "1eab9448e720a8bf88a70583b272cd3e84fc1af3_38_40__42_44",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 4
            },
            "LINE": {
                "missed": 0,
                "covered": 2
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate checkSwitchLike(node ASTSwitchLike, ruleContext RuleContext) : void extracted from public visit(node ASTSwitchStatement, data Object) : Object in class net.sourceforge.pmd.lang.java.rule.errorprone.ImplicitSwitchFallThroughRule",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/ImplicitSwitchFallThroughRule.java",
                "startLine": 32,
                "endLine": 50,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/ImplicitSwitchFallThroughRule.java",
                "startLine": 33,
                "endLine": 37,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/ImplicitSwitchFallThroughRule.java",
                "startLine": 45,
                "endLine": 61,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n    public Object visit(ASTSwitchStatement node, Object data) {\n        DataflowResult dataflow = DataflowPass.getDataflowResult(node.getRoot());\n\n        for (ASTSwitchBranch branch : node.getBranches()) {\n            if (branch instanceof ASTSwitchFallthroughBranch && branch != node.getLastChild()) {\n                ASTSwitchFallthroughBranch fallthrough = (ASTSwitchFallthroughBranch) branch;\n                OptionalBool bool = dataflow.switchBranchFallsThrough(branch);\n                if (bool != OptionalBool.NO\n                    && fallthrough.getStatements().nonEmpty()\n                    && !nextBranchHasComment(branch)) {\n                    asCtx(data).addViolation(branch.getNextBranch().getLabel());\n                }\n            } else {\n                return null;\n            }\n        }\n        return null;\n    }",
        "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/ImplicitSwitchFallThroughRule.java",
        "isPureRefactoring": true,
        "commitId": "312d8e46aef97e7514e71ec30f43808baabd322e",
        "packageNameBefore": "net.sourceforge.pmd.lang.java.rule.errorprone",
        "classNameBefore": "net.sourceforge.pmd.lang.java.rule.errorprone.ImplicitSwitchFallThroughRule",
        "methodNameBefore": "net.sourceforge.pmd.lang.java.rule.errorprone.ImplicitSwitchFallThroughRule#visit",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.java.rule.errorprone.ImplicitSwitchFallThroughRule#nextBranchHasComment\n methodBody: boolean nextBranchHasComment(ASTSwitchBranch branch) {\nJavaNode nextBranch=branch.getNextBranch();\nif(nextBranch == null){return false;\n}for(JavaccToken special: GenericToken.previousSpecials(nextBranch.getFirstToken())){if(JavaAstUtils.isComment(special) && IGNORED_COMMENT.matcher(special.getImageCs()).find()){return true;\n}}return false;\n}",
        "classSignatureBefore": "public class ImplicitSwitchFallThroughRule extends AbstractJavaRulechainRule ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.rule.errorprone.ImplicitSwitchFallThroughRule#visit"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.rule.errorprone.ImplicitSwitchFallThroughRule"
        ],
        "classSignatureBeforeSet": [
            "public class ImplicitSwitchFallThroughRule extends AbstractJavaRulechainRule "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.rule.errorprone;\n\nimport java.util.regex.Pattern;\n\nimport net.sourceforge.pmd.lang.ast.GenericToken;\nimport net.sourceforge.pmd.lang.ast.impl.javacc.JavaccToken;\nimport net.sourceforge.pmd.lang.java.ast.ASTSwitchBranch;\nimport net.sourceforge.pmd.lang.java.ast.ASTSwitchFallthroughBranch;\nimport net.sourceforge.pmd.lang.java.ast.ASTSwitchStatement;\nimport net.sourceforge.pmd.lang.java.ast.JavaNode;\nimport net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils;\nimport net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;\nimport net.sourceforge.pmd.lang.java.rule.internal.DataflowPass;\nimport net.sourceforge.pmd.lang.java.rule.internal.DataflowPass.DataflowResult;\nimport net.sourceforge.pmd.util.OptionalBool;\n\npublic class ImplicitSwitchFallThroughRule extends AbstractJavaRulechainRule {\n\n    //todo should consider switch exprs\n\n    private static final Pattern IGNORED_COMMENT = Pattern.compile(\"/[/*].*\\\\bfalls?[ -]?thr(ough|u)\\\\b.*\",\n                                                                   Pattern.DOTALL | Pattern.CASE_INSENSITIVE);\n\n    public ImplicitSwitchFallThroughRule() {\n        super(ASTSwitchStatement.class);\n    }\n\n    @Override\n    public Object visit(ASTSwitchStatement node, Object data) {\n        DataflowResult dataflow = DataflowPass.getDataflowResult(node.getRoot());\n\n        for (ASTSwitchBranch branch : node.getBranches()) {\n            if (branch instanceof ASTSwitchFallthroughBranch && branch != node.getLastChild()) {\n                ASTSwitchFallthroughBranch fallthrough = (ASTSwitchFallthroughBranch) branch;\n                OptionalBool bool = dataflow.switchBranchFallsThrough(branch);\n                if (bool != OptionalBool.NO\n                    && fallthrough.getStatements().nonEmpty()\n                    && !nextBranchHasComment(branch)) {\n                    asCtx(data).addViolation(branch.getNextBranch().getLabel());\n                }\n            } else {\n                return null;\n            }\n        }\n        return null;\n    }\n\n    boolean nextBranchHasComment(ASTSwitchBranch branch) {\n        JavaNode nextBranch = branch.getNextBranch();\n        if (nextBranch == null) {\n            return false;\n        }\n        for (JavaccToken special : GenericToken.previousSpecials(nextBranch.getFirstToken())) {\n            if (JavaAstUtils.isComment(special)\n                && IGNORED_COMMENT.matcher(special.getImageCs()).find()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n}\n",
        "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/ImplicitSwitchFallThroughRule.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.rule.errorprone;\n\nimport java.util.regex.Pattern;\n\nimport net.sourceforge.pmd.lang.ast.GenericToken;\nimport net.sourceforge.pmd.lang.ast.impl.javacc.JavaccToken;\nimport net.sourceforge.pmd.lang.java.ast.ASTSwitchBranch;\nimport net.sourceforge.pmd.lang.java.ast.ASTSwitchExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTSwitchFallthroughBranch;\nimport net.sourceforge.pmd.lang.java.ast.ASTSwitchLike;\nimport net.sourceforge.pmd.lang.java.ast.ASTSwitchStatement;\nimport net.sourceforge.pmd.lang.java.ast.JavaNode;\nimport net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils;\nimport net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;\nimport net.sourceforge.pmd.lang.java.rule.internal.DataflowPass;\nimport net.sourceforge.pmd.lang.java.rule.internal.DataflowPass.DataflowResult;\nimport net.sourceforge.pmd.reporting.RuleContext;\nimport net.sourceforge.pmd.util.OptionalBool;\n\npublic class ImplicitSwitchFallThroughRule extends AbstractJavaRulechainRule {\n\n    private static final Pattern IGNORED_COMMENT = Pattern.compile(\"/[/*].*\\\\bfalls?[ -]?thr(ough|u)\\\\b.*\",\n                                                                   Pattern.DOTALL | Pattern.CASE_INSENSITIVE);\n\n    public ImplicitSwitchFallThroughRule() {\n        super(ASTSwitchStatement.class, ASTSwitchExpression.class);\n    }\n\n    @Override\n    public Object visit(ASTSwitchStatement node, Object data) {\n        checkSwitchLike(node, asCtx(data));\n        return null;\n    }\n\n    @Override\n    public Object visit(ASTSwitchExpression node, Object data) {\n        checkSwitchLike(node, asCtx(data));\n        return null;\n    }\n\n    private void checkSwitchLike(ASTSwitchLike node, RuleContext ruleContext) {\n        DataflowResult dataflow = DataflowPass.getDataflowResult(node.getRoot());\n\n        for (ASTSwitchBranch branch : node.getBranches()) {\n            if (branch instanceof ASTSwitchFallthroughBranch && branch != node.getLastChild()) {\n                ASTSwitchFallthroughBranch fallthrough = (ASTSwitchFallthroughBranch) branch;\n                OptionalBool bool = dataflow.switchBranchFallsThrough(branch);\n                if (bool != OptionalBool.NO\n                        && fallthrough.getStatements().nonEmpty()\n                        && !nextBranchHasComment(branch)) {\n                    ruleContext.addViolation(branch.getNextBranch().getLabel());\n                }\n            } else {\n                return;\n            }\n        }\n    }\n\n    boolean nextBranchHasComment(ASTSwitchBranch branch) {\n        JavaNode nextBranch = branch.getNextBranch();\n        if (nextBranch == null) {\n            return false;\n        }\n        for (JavaccToken special : GenericToken.previousSpecials(nextBranch.getFirstToken())) {\n            if (JavaAstUtils.isComment(special)\n                && IGNORED_COMMENT.matcher(special.getImageCs()).find()) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n",
        "diffSourceCodeSet": [
            "private void checkSwitchLike(ASTSwitchLike node, RuleContext ruleContext) {\n        DataflowResult dataflow = DataflowPass.getDataflowResult(node.getRoot());\n\n        for (ASTSwitchBranch branch : node.getBranches()) {\n            if (branch instanceof ASTSwitchFallthroughBranch && branch != node.getLastChild()) {\n                ASTSwitchFallthroughBranch fallthrough = (ASTSwitchFallthroughBranch) branch;\n                OptionalBool bool = dataflow.switchBranchFallsThrough(branch);\n                if (bool != OptionalBool.NO\n                        && fallthrough.getStatements().nonEmpty()\n                        && !nextBranchHasComment(branch)) {\n                    ruleContext.addViolation(branch.getNextBranch().getLabel());\n                }\n            } else {\n                return;\n            }\n        }\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.java.rule.errorprone.ImplicitSwitchFallThroughRule#nextBranchHasComment\n methodBody: boolean nextBranchHasComment(ASTSwitchBranch branch) {\nJavaNode nextBranch=branch.getNextBranch();\nif(nextBranch == null){return false;\n}for(JavaccToken special: GenericToken.previousSpecials(nextBranch.getFirstToken())){if(JavaAstUtils.isComment(special) && IGNORED_COMMENT.matcher(special.getImageCs()).find()){return true;\n}}return false;\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n    public Object visit(ASTSwitchStatement node, Object data) {\n        checkSwitchLike(node, asCtx(data));\n        return null;\n    }\nprivate void checkSwitchLike(ASTSwitchLike node, RuleContext ruleContext) {\n        DataflowResult dataflow = DataflowPass.getDataflowResult(node.getRoot());\n\n        for (ASTSwitchBranch branch : node.getBranches()) {\n            if (branch instanceof ASTSwitchFallthroughBranch && branch != node.getLastChild()) {\n                ASTSwitchFallthroughBranch fallthrough = (ASTSwitchFallthroughBranch) branch;\n                OptionalBool bool = dataflow.switchBranchFallsThrough(branch);\n                if (bool != OptionalBool.NO\n                        && fallthrough.getStatements().nonEmpty()\n                        && !nextBranchHasComment(branch)) {\n                    ruleContext.addViolation(branch.getNextBranch().getLabel());\n                }\n            } else {\n                return;\n            }\n        }\n    }",
        "diffSourceCode": "-   32:     @Override\n-   33:     public Object visit(ASTSwitchStatement node, Object data) {\n-   34:         DataflowResult dataflow = DataflowPass.getDataflowResult(node.getRoot());\n-   35: \n-   36:         for (ASTSwitchBranch branch : node.getBranches()) {\n-   37:             if (branch instanceof ASTSwitchFallthroughBranch && branch != node.getLastChild()) {\n-   38:                 ASTSwitchFallthroughBranch fallthrough = (ASTSwitchFallthroughBranch) branch;\n-   39:                 OptionalBool bool = dataflow.switchBranchFallsThrough(branch);\n-   40:                 if (bool != OptionalBool.NO\n-   41:                     && fallthrough.getStatements().nonEmpty()\n-   42:                     && !nextBranchHasComment(branch)) {\n-   43:                     asCtx(data).addViolation(branch.getNextBranch().getLabel());\n-   44:                 }\n-   45:             } else {\n-   46:                 return null;\n-   47:             }\n-   48:         }\n-   49:         return null;\n-   50:     }\n-   51: \n-   52:     boolean nextBranchHasComment(ASTSwitchBranch branch) {\n-   53:         JavaNode nextBranch = branch.getNextBranch();\n-   54:         if (nextBranch == null) {\n-   55:             return false;\n-   56:         }\n-   57:         for (JavaccToken special : GenericToken.previousSpecials(nextBranch.getFirstToken())) {\n-   58:             if (JavaAstUtils.isComment(special)\n-   59:                 && IGNORED_COMMENT.matcher(special.getImageCs()).find()) {\n-   60:                 return true;\n-   61:             }\n+   32: \n+   33:     @Override\n+   34:     public Object visit(ASTSwitchStatement node, Object data) {\n+   35:         checkSwitchLike(node, asCtx(data));\n+   36:         return null;\n+   37:     }\n+   38: \n+   39:     @Override\n+   40:     public Object visit(ASTSwitchExpression node, Object data) {\n+   41:         checkSwitchLike(node, asCtx(data));\n+   42:         return null;\n+   43:     }\n+   44: \n+   45:     private void checkSwitchLike(ASTSwitchLike node, RuleContext ruleContext) {\n+   46:         DataflowResult dataflow = DataflowPass.getDataflowResult(node.getRoot());\n+   47: \n+   48:         for (ASTSwitchBranch branch : node.getBranches()) {\n+   49:             if (branch instanceof ASTSwitchFallthroughBranch && branch != node.getLastChild()) {\n+   50:                 ASTSwitchFallthroughBranch fallthrough = (ASTSwitchFallthroughBranch) branch;\n+   51:                 OptionalBool bool = dataflow.switchBranchFallsThrough(branch);\n+   52:                 if (bool != OptionalBool.NO\n+   53:                         && fallthrough.getStatements().nonEmpty()\n+   54:                         && !nextBranchHasComment(branch)) {\n+   55:                     ruleContext.addViolation(branch.getNextBranch().getLabel());\n+   56:                 }\n+   57:             } else {\n+   58:                 return;\n+   59:             }\n+   60:         }\n+   61:     }\n",
        "uniqueId": "312d8e46aef97e7514e71ec30f43808baabd322e_32_50_45_61_33_37",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 53
            },
            "BRANCH": {
                "missed": 0,
                "covered": 12
            },
            "LINE": {
                "missed": 0,
                "covered": 13
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 7
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate newInputStreamFromJrtFilesystem(path Path) : InputStream extracted from public getResourceAsStream(name String) : InputStream in class net.sourceforge.pmd.internal.util.ClasspathClassLoader",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/internal/util/ClasspathClassLoader.java",
                "startLine": 201,
                "endLine": 234,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/internal/util/ClasspathClassLoader.java",
                "startLine": 218,
                "endLine": 252,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/internal/util/ClasspathClassLoader.java",
                "startLine": 254,
                "endLine": 264,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n    public InputStream getResourceAsStream(String name) {\n        // always first search in jrt-fs, if available\n        // note: we can't override just getResource(String) and return a jrt:/-URL, because the URL itself\n        // won't be connected to the correct JrtFileSystem and would just load using the system classloader.\n        if (fileSystem != null) {\n            int lastSlash = name.lastIndexOf('/');\n            String packageName = name.substring(0, Math.max(lastSlash, 0));\n            Set<String> moduleNames = packagesDirsToModules.get(packageName);\n            if (moduleNames != null) {\n                LOG.trace(\"Trying to find {} in jrt-fs with packageName={} and modules={}\",\n                        name, packageName, moduleNames);\n\n                for (String moduleCandidate : moduleNames) {\n                    Path candidate = fileSystem.getPath(\"modules\", moduleCandidate, name);\n                    if (Files.exists(candidate)) {\n                        LOG.trace(\"Found {}\", candidate);\n                        try {\n                            // Note: The input streams from JrtFileSystem are ByteArrayInputStreams and do not\n                            // need to be closed - we don't need to track these. The filesystem itself needs to be closed at the end.\n                            // See https://github.com/openjdk/jdk/blob/970cd202049f592946f9c1004ea92dbd58abf6fb/src/java.base/share/classes/jdk/internal/jrtfs/JrtFileSystem.java#L334\n                            return Files.newInputStream(candidate);\n                        } catch (IOException e) {\n                            throw new UncheckedIOException(e);\n                        }\n                    }\n                }\n            }\n        }\n\n        // search in the other jars of the aux classpath.\n        // this will call this.getResource, which will do a child-first search, see below.\n        return super.getResourceAsStream(name);\n    }",
        "filePathBefore": "pmd-core/src/main/java/net/sourceforge/pmd/internal/util/ClasspathClassLoader.java",
        "isPureRefactoring": true,
        "commitId": "47470b5d0c112b0d5b13b216569ae3bc211341fb",
        "packageNameBefore": "net.sourceforge.pmd.internal.util",
        "classNameBefore": "net.sourceforge.pmd.internal.util.ClasspathClassLoader",
        "methodNameBefore": "net.sourceforge.pmd.internal.util.ClasspathClassLoader#getResourceAsStream",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.internal.util.ClasspathClassLoader#getResourceAsStream\n methodBody: public InputStream getResourceAsStream(String name) {\nif(fileSystem != null){int lastSlash=name.lastIndexOf('/');\nString packageName=name.substring(0,Math.max(lastSlash,0));\nSet<String> moduleNames=packagesDirsToModules.get(packageName);\nif(moduleNames != null){LOG.trace(\"Trying to find {} in jrt-fs with packageName={} and modules={}\",name,packageName,moduleNames);\nfor(String moduleCandidate: moduleNames){Path candidate=fileSystem.getPath(\"modules\",moduleCandidate,name);\nif(Files.exists(candidate)){LOG.trace(\"Found {}\",candidate);\ntryreturn Files.newInputStream(candidate);\ncatch(IOException e)throw new UncheckedIOException(e);\n}}}}return super.getResourceAsStream(name);\n}",
        "classSignatureBefore": "public class ClasspathClassLoader extends URLClassLoader ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.internal.util.ClasspathClassLoader#getResourceAsStream"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.internal.util.ClasspathClassLoader"
        ],
        "classSignatureBeforeSet": [
            "public class ClasspathClassLoader extends URLClassLoader "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics",
                "description": "All the mappings are matched! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.internal.util;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.UncheckedIOException;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.nio.file.FileSystem;\nimport java.nio.file.FileSystems;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport net.sourceforge.pmd.util.AssertionUtil;\n\n/**\n * Create a ClassLoader which loads classes using a CLASSPATH like String. If\n * the String looks like a URL to a file (e.g. starts with <code>file://</code>)\n * the file will be read with each line representing an path on the classpath.\n *\n * @author Edwin Chan\n */\npublic class ClasspathClassLoader extends URLClassLoader {\n\n    private static final Logger LOG = LoggerFactory.getLogger(ClasspathClassLoader.class);\n\n    String javaHome;\n\n    private FileSystem fileSystem;\n    private Map<String, Set<String>> packagesDirsToModules;\n\n    static {\n        registerAsParallelCapable();\n\n        // Disable caching for jar files to prevent issues like #4899\n        try {\n            // Uses a pseudo URL to be able to call URLConnection#setDefaultUseCaches\n            // with Java9+ there is a static method for that per protocol:\n            // https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/net/URLConnection.html#setDefaultUseCaches(java.lang.String,boolean)\n            URI.create(\"jar:file:file.jar!/\").toURL().openConnection().setDefaultUseCaches(false);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public ClasspathClassLoader(List<File> files, ClassLoader parent) throws IOException {\n        super(new URL[0], parent);\n        for (URL url : fileToURL(files)) {\n            addURL(url);\n        }\n    }\n\n    public ClasspathClassLoader(String classpath, ClassLoader parent) throws IOException {\n        super(new URL[0], parent);\n        for (URL url : initURLs(classpath)) {\n            addURL(url);\n        }\n    }\n\n    private List<URL> fileToURL(List<File> files) throws IOException {\n        List<URL> urlList = new ArrayList<>();\n        for (File f : files) {\n            urlList.add(createURLFromPath(f.getAbsolutePath()));\n        }\n        return urlList;\n    }\n\n    private List<URL> initURLs(String classpath) {\n        AssertionUtil.requireParamNotNull(\"classpath\", classpath);\n        final List<URL> urls = new ArrayList<>();\n        try {\n            if (classpath.startsWith(\"file:\")) {\n                // Treat as file URL\n                addFileURLs(urls, new URL(classpath));\n            } else {\n                // Treat as classpath\n                addClasspathURLs(urls, classpath);\n            }\n        } catch (IOException e) {\n            throw new IllegalArgumentException(\"Cannot prepend classpath \" + classpath + \"\\n\" + e.getMessage(), e);\n        }\n        return urls;\n    }\n\n    private void addClasspathURLs(final List<URL> urls, final String classpath) throws MalformedURLException {\n        StringTokenizer toker = new StringTokenizer(classpath, File.pathSeparator);\n        while (toker.hasMoreTokens()) {\n            String token = toker.nextToken();\n            LOG.debug(\"Adding classpath entry: <{}>\", token);\n            urls.add(createURLFromPath(token));\n        }\n    }\n\n    private void addFileURLs(List<URL> urls, URL fileURL) throws IOException {\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(fileURL.openStream()))) {\n            String line;\n            while ((line = in.readLine()) != null) {\n                LOG.debug(\"Read classpath entry line: <{}>\", line);\n                line = line.trim();\n                if (line.length() > 0 && line.charAt(0) != '#') {\n                    LOG.debug(\"Adding classpath entry: <{}>\", line);\n                    urls.add(createURLFromPath(line));\n                }\n            }\n        }\n    }\n\n    private URL createURLFromPath(String path) throws MalformedURLException {\n        Path filePath = Paths.get(path).toAbsolutePath();\n        if (filePath.endsWith(Paths.get(\"lib\", \"jrt-fs.jar\"))) {\n            initializeJrtFilesystem(filePath);\n            // don't add jrt-fs.jar to the normal aux classpath\n            return null;\n        }\n\n        return filePath.toUri().normalize().toURL();\n    }\n\n    /**\n     * Initializes a Java Runtime Filesystem that will be used to load class files.\n     * This allows end users to provide in the aux classpath another Java Runtime version\n     * than the one used for executing PMD.\n     *\n     * @param filePath path to the file \"lib/jrt-fs.jar\" inside the java installation directory.\n     * @see <a href=\"https://openjdk.org/jeps/220\">JEP 220: Modular Run-Time Images</a>\n     */\n    private void initializeJrtFilesystem(Path filePath) {\n        try {\n            LOG.debug(\"Detected Java Runtime Filesystem Provider in {}\", filePath);\n\n            if (fileSystem != null) {\n                throw new IllegalStateException(\"There is already a jrt filesystem. Do you have multiple jrt-fs.jar files on the classpath?\");\n            }\n\n            if (filePath.getNameCount() < 2) {\n                throw new IllegalArgumentException(\"Can't determine java home from \" + filePath + \" - please provide a complete path.\");\n            }\n\n            try (URLClassLoader loader = new URLClassLoader(new URL[] { filePath.toUri().toURL() })) {\n                Map<String, String> env = new HashMap<>();\n                // note: providing java.home here is crucial, so that the correct runtime image is loaded.\n                // the class loader is only used to provide an implementation of JrtFileSystemProvider, if the current\n                // Java runtime doesn't provide one (e.g. if running in Java 8).\n                javaHome = filePath.getParent().getParent().toString();\n                env.put(\"java.home\", javaHome);\n                LOG.debug(\"Creating jrt-fs with env {}\", env);\n                fileSystem = FileSystems.newFileSystem(URI.create(\"jrt:/\"), env, loader);\n            }\n\n            packagesDirsToModules = new HashMap<>();\n            Path packages = fileSystem.getPath(\"packages\");\n            try (Stream<Path> packagesStream = Files.list(packages)) {\n                packagesStream.forEach(p -> {\n                    String packageName = p.getFileName().toString().replace('.', '/');\n                    try (Stream<Path> modulesStream = Files.list(p)) {\n                        Set<String> modules = modulesStream\n                                .map(Path::getFileName)\n                                .map(Path::toString)\n                                .collect(Collectors.toSet());\n                        packagesDirsToModules.put(packageName, modules);\n                    } catch (IOException e) {\n                        throw new UncheckedIOException(e);\n                    }\n                });\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    @Override\n    public String toString() {\n        return getClass().getSimpleName()\n            + \"[[\"\n            + StringUtils.join(getURLs(), \":\")\n            + \"] jrt-fs: \" + javaHome + \" parent: \" + getParent() + ']';\n    }\n\n    @Override\n    public InputStream getResourceAsStream(String name) {\n        // always first search in jrt-fs, if available\n        // note: we can't override just getResource(String) and return a jrt:/-URL, because the URL itself\n        // won't be connected to the correct JrtFileSystem and would just load using the system classloader.\n        if (fileSystem != null) {\n            int lastSlash = name.lastIndexOf('/');\n            String packageName = name.substring(0, Math.max(lastSlash, 0));\n            Set<String> moduleNames = packagesDirsToModules.get(packageName);\n            if (moduleNames != null) {\n                LOG.trace(\"Trying to find {} in jrt-fs with packageName={} and modules={}\",\n                        name, packageName, moduleNames);\n\n                for (String moduleCandidate : moduleNames) {\n                    Path candidate = fileSystem.getPath(\"modules\", moduleCandidate, name);\n                    if (Files.exists(candidate)) {\n                        LOG.trace(\"Found {}\", candidate);\n                        try {\n                            // Note: The input streams from JrtFileSystem are ByteArrayInputStreams and do not\n                            // need to be closed - we don't need to track these. The filesystem itself needs to be closed at the end.\n                            // See https://github.com/openjdk/jdk/blob/970cd202049f592946f9c1004ea92dbd58abf6fb/src/java.base/share/classes/jdk/internal/jrtfs/JrtFileSystem.java#L334\n                            return Files.newInputStream(candidate);\n                        } catch (IOException e) {\n                            throw new UncheckedIOException(e);\n                        }\n                    }\n                }\n            }\n        }\n\n        // search in the other jars of the aux classpath.\n        // this will call this.getResource, which will do a child-first search, see below.\n        return super.getResourceAsStream(name);\n    }\n\n    @Override\n    public URL getResource(String name) {\n        // Override to make it child-first. This is the method used by\n        // pmd-java's type resolution to fetch classes, instead of loadClass.\n        Objects.requireNonNull(name);\n\n        URL url = findResource(name);\n        if (url == null) {\n            // note this will actually call back into this.findResource, but\n            // we can't avoid this as the super implementation uses JDK internal\n            // stuff that we can't copy down here.\n            return super.getResource(name);\n        }\n        return url;\n    }\n\n    @Override\n    protected Class<?> loadClass(final String name, final boolean resolve) throws ClassNotFoundException {\n        throw new IllegalStateException(\"This class loader shouldn't be used to load classes\");\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (fileSystem != null) {\n            fileSystem.close();\n            // jrt created an own classloader to load the JrtFileSystemProvider class out of the\n            // jrt-fs.jar. This needs to be closed manually.\n            ClassLoader classLoader = fileSystem.getClass().getClassLoader();\n            if (classLoader instanceof URLClassLoader) {\n                ((URLClassLoader) classLoader).close();\n            }\n            packagesDirsToModules = null;\n            fileSystem = null;\n        }\n        super.close();\n    }\n}\n",
        "filePathAfter": "pmd-core/src/main/java/net/sourceforge/pmd/internal/util/ClasspathClassLoader.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.internal.util;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.UncheckedIOException;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.nio.file.FileSystem;\nimport java.nio.file.FileSystems;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.checkerframework.checker.nullness.qual.Nullable;\nimport org.objectweb.asm.ClassReader;\nimport org.objectweb.asm.ClassVisitor;\nimport org.objectweb.asm.ModuleVisitor;\nimport org.objectweb.asm.Opcodes;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport net.sourceforge.pmd.util.AssertionUtil;\n\n/**\n * Create a ClassLoader which loads classes using a CLASSPATH like String. If\n * the String looks like a URL to a file (e.g. starts with <code>file://</code>)\n * the file will be read with each line representing an path on the classpath.\n *\n * @author Edwin Chan\n */\npublic class ClasspathClassLoader extends URLClassLoader {\n\n    private static final Logger LOG = LoggerFactory.getLogger(ClasspathClassLoader.class);\n\n    String javaHome;\n\n    private FileSystem fileSystem;\n    private Map<String, Set<String>> packagesDirsToModules;\n\n    static {\n        registerAsParallelCapable();\n\n        // Disable caching for jar files to prevent issues like #4899\n        try {\n            // Uses a pseudo URL to be able to call URLConnection#setDefaultUseCaches\n            // with Java9+ there is a static method for that per protocol:\n            // https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/net/URLConnection.html#setDefaultUseCaches(java.lang.String,boolean)\n            URI.create(\"jar:file:file.jar!/\").toURL().openConnection().setDefaultUseCaches(false);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public ClasspathClassLoader(List<File> files, ClassLoader parent) throws IOException {\n        super(new URL[0], parent);\n        for (URL url : fileToURL(files)) {\n            addURL(url);\n        }\n    }\n\n    public ClasspathClassLoader(String classpath, ClassLoader parent) throws IOException {\n        super(new URL[0], parent);\n        for (URL url : initURLs(classpath)) {\n            addURL(url);\n        }\n    }\n\n    private List<URL> fileToURL(List<File> files) throws IOException {\n        List<URL> urlList = new ArrayList<>();\n        for (File f : files) {\n            urlList.add(createURLFromPath(f.getAbsolutePath()));\n        }\n        return urlList;\n    }\n\n    private List<URL> initURLs(String classpath) {\n        AssertionUtil.requireParamNotNull(\"classpath\", classpath);\n        final List<URL> urls = new ArrayList<>();\n        try {\n            if (classpath.startsWith(\"file:\")) {\n                // Treat as file URL\n                addFileURLs(urls, new URL(classpath));\n            } else {\n                // Treat as classpath\n                addClasspathURLs(urls, classpath);\n            }\n        } catch (IOException e) {\n            throw new IllegalArgumentException(\"Cannot prepend classpath \" + classpath + \"\\n\" + e.getMessage(), e);\n        }\n        return urls;\n    }\n\n    private void addClasspathURLs(final List<URL> urls, final String classpath) throws MalformedURLException {\n        StringTokenizer toker = new StringTokenizer(classpath, File.pathSeparator);\n        while (toker.hasMoreTokens()) {\n            String token = toker.nextToken();\n            LOG.debug(\"Adding classpath entry: <{}>\", token);\n            urls.add(createURLFromPath(token));\n        }\n    }\n\n    private void addFileURLs(List<URL> urls, URL fileURL) throws IOException {\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(fileURL.openStream()))) {\n            String line;\n            while ((line = in.readLine()) != null) {\n                LOG.debug(\"Read classpath entry line: <{}>\", line);\n                line = line.trim();\n                if (line.length() > 0 && line.charAt(0) != '#') {\n                    LOG.debug(\"Adding classpath entry: <{}>\", line);\n                    urls.add(createURLFromPath(line));\n                }\n            }\n        }\n    }\n\n    private URL createURLFromPath(String path) throws MalformedURLException {\n        Path filePath = Paths.get(path).toAbsolutePath();\n        if (filePath.endsWith(Paths.get(\"lib\", \"jrt-fs.jar\"))) {\n            initializeJrtFilesystem(filePath);\n            // don't add jrt-fs.jar to the normal aux classpath\n            return null;\n        }\n\n        return filePath.toUri().normalize().toURL();\n    }\n\n    /**\n     * Initializes a Java Runtime Filesystem that will be used to load class files.\n     * This allows end users to provide in the aux classpath another Java Runtime version\n     * than the one used for executing PMD.\n     *\n     * @param filePath path to the file \"lib/jrt-fs.jar\" inside the java installation directory.\n     * @see <a href=\"https://openjdk.org/jeps/220\">JEP 220: Modular Run-Time Images</a>\n     */\n    private void initializeJrtFilesystem(Path filePath) {\n        try {\n            LOG.debug(\"Detected Java Runtime Filesystem Provider in {}\", filePath);\n\n            if (fileSystem != null) {\n                throw new IllegalStateException(\"There is already a jrt filesystem. Do you have multiple jrt-fs.jar files on the classpath?\");\n            }\n\n            if (filePath.getNameCount() < 2) {\n                throw new IllegalArgumentException(\"Can't determine java home from \" + filePath + \" - please provide a complete path.\");\n            }\n\n            try (URLClassLoader loader = new URLClassLoader(new URL[] { filePath.toUri().toURL() })) {\n                Map<String, String> env = new HashMap<>();\n                // note: providing java.home here is crucial, so that the correct runtime image is loaded.\n                // the class loader is only used to provide an implementation of JrtFileSystemProvider, if the current\n                // Java runtime doesn't provide one (e.g. if running in Java 8).\n                javaHome = filePath.getParent().getParent().toString();\n                env.put(\"java.home\", javaHome);\n                LOG.debug(\"Creating jrt-fs with env {}\", env);\n                fileSystem = FileSystems.newFileSystem(URI.create(\"jrt:/\"), env, loader);\n            }\n\n            packagesDirsToModules = new HashMap<>();\n            Path packages = fileSystem.getPath(\"packages\");\n            try (Stream<Path> packagesStream = Files.list(packages)) {\n                packagesStream.forEach(p -> {\n                    String packageName = p.getFileName().toString().replace('.', '/');\n                    try (Stream<Path> modulesStream = Files.list(p)) {\n                        Set<String> modules = modulesStream\n                                .map(Path::getFileName)\n                                .map(Path::toString)\n                                .collect(Collectors.toSet());\n                        packagesDirsToModules.put(packageName, modules);\n                    } catch (IOException e) {\n                        throw new UncheckedIOException(e);\n                    }\n                });\n            }\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    @Override\n    public String toString() {\n        return getClass().getSimpleName()\n            + \"[[\"\n            + StringUtils.join(getURLs(), \":\")\n            + \"] jrt-fs: \" + javaHome + \" parent: \" + getParent() + ']';\n    }\n\n    private static final String MODULE_INFO_SUFFIX = \"module-info.class\";\n    private static final String MODULE_INFO_SUFFIX_SLASH = \"/\" + MODULE_INFO_SUFFIX;\n\n    @Nullable\n    private static String extractModuleName(String name) {\n        if (!name.endsWith(MODULE_INFO_SUFFIX_SLASH)) {\n            return null;\n        }\n        return name.substring(0, name.length() - MODULE_INFO_SUFFIX_SLASH.length());\n    }\n\n    @Override\n    public InputStream getResourceAsStream(String name) {\n        // always first search in jrt-fs, if available\n        // note: we can't override just getResource(String) and return a jrt:/-URL, because the URL itself\n        // won't be connected to the correct JrtFileSystem and would just load using the system classloader.\n        if (fileSystem != null) {\n            String moduleName = extractModuleName(name);\n            if (moduleName != null) {\n                LOG.trace(\"Trying to load module-info.class for module {} in jrt-fs\", moduleName);\n                Path candidate = fileSystem.getPath(\"modules\", moduleName, MODULE_INFO_SUFFIX);\n                if (Files.exists(candidate)) {\n                    return newInputStreamFromJrtFilesystem(candidate);\n                }\n            }\n\n            int lastSlash = name.lastIndexOf('/');\n            String packageName = name.substring(0, Math.max(lastSlash, 0));\n            Set<String> moduleNames = packagesDirsToModules.get(packageName);\n            if (moduleNames != null) {\n                LOG.trace(\"Trying to find {} in jrt-fs with packageName={} and modules={}\",\n                        name, packageName, moduleNames);\n\n                for (String moduleCandidate : moduleNames) {\n                    Path candidate = fileSystem.getPath(\"modules\", moduleCandidate, name);\n                    if (Files.exists(candidate)) {\n                        return newInputStreamFromJrtFilesystem(candidate);\n                    }\n                }\n            }\n        }\n\n        // search in the other jars of the aux classpath.\n        // this will call this.getResource, which will do a child-first search, see below.\n        return super.getResourceAsStream(name);\n    }\n\n    private static InputStream newInputStreamFromJrtFilesystem(Path path) {\n        LOG.trace(\"Found {}\", path);\n        try {\n            // Note: The input streams from JrtFileSystem are ByteArrayInputStreams and do not\n            // need to be closed - we don't need to track these. The filesystem itself needs to be closed at the end.\n            // See https://github.com/openjdk/jdk/blob/970cd202049f592946f9c1004ea92dbd58abf6fb/src/java.base/share/classes/jdk/internal/jrtfs/JrtFileSystem.java#L334\n            return Files.newInputStream(path);\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    private static class ModuleFinder extends ClassVisitor {\n        private String moduleName;\n\n        protected ModuleFinder() {\n            super(Opcodes.ASM9);\n        }\n\n        @Override\n        public ModuleVisitor visitModule(String name, int access, String version) {\n            moduleName = name;\n            return null;\n        }\n\n        public String getModuleName() {\n            return moduleName;\n        }\n    }\n\n    private URL findModule(Enumeration<URL> moduleInfoUrls, String moduleName) throws IOException {\n        while (moduleInfoUrls.hasMoreElements()) {\n            URL url = moduleInfoUrls.nextElement();\n\n            ModuleFinder finder = new ModuleFinder();\n            try (InputStream inputStream = url.openStream()) {\n                ClassReader classReader = new ClassReader(inputStream);\n                classReader.accept(finder, ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES);\n            }\n            if (moduleName.equals(finder.getModuleName())) {\n                return url;\n            }\n        }\n\n        return null;\n    }\n\n    @Override\n    public URL getResource(String name) {\n        // Override to make it child-first. This is the method used by\n        // pmd-java's type resolution to fetch classes, instead of loadClass.\n        Objects.requireNonNull(name);\n\n        String moduleName = extractModuleName(name);\n        if (moduleName != null) {\n            try {\n                Enumeration<URL> moduleInfoUrls = findResources(MODULE_INFO_SUFFIX);\n                URL moduleUrl = findModule(moduleInfoUrls, moduleName);\n\n                // no match in this classloader, search in parents\n                if (moduleUrl == null) {\n                    moduleInfoUrls = getParent().getResources(MODULE_INFO_SUFFIX);\n                    moduleUrl = findModule(moduleInfoUrls, moduleName);\n                }\n\n                return moduleUrl;\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        URL url = findResource(name);\n        if (url == null) {\n            // note this will actually call back into this.findResource, but\n            // we can't avoid this as the super implementation uses JDK internal\n            // stuff that we can't copy down here.\n            return super.getResource(name);\n        }\n        return url;\n    }\n\n    @Override\n    protected Class<?> loadClass(final String name, final boolean resolve) throws ClassNotFoundException {\n        throw new IllegalStateException(\"This class loader shouldn't be used to load classes\");\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (fileSystem != null) {\n            fileSystem.close();\n            // jrt created an own classloader to load the JrtFileSystemProvider class out of the\n            // jrt-fs.jar. This needs to be closed manually.\n            ClassLoader classLoader = fileSystem.getClass().getClassLoader();\n            if (classLoader instanceof URLClassLoader) {\n                ((URLClassLoader) classLoader).close();\n            }\n            packagesDirsToModules = null;\n            fileSystem = null;\n        }\n        super.close();\n    }\n}\n",
        "diffSourceCodeSet": [
            "private static InputStream newInputStreamFromJrtFilesystem(Path path) {\n        LOG.trace(\"Found {}\", path);\n        try {\n            // Note: The input streams from JrtFileSystem are ByteArrayInputStreams and do not\n            // need to be closed - we don't need to track these. The filesystem itself needs to be closed at the end.\n            // See https://github.com/openjdk/jdk/blob/970cd202049f592946f9c1004ea92dbd58abf6fb/src/java.base/share/classes/jdk/internal/jrtfs/JrtFileSystem.java#L334\n            return Files.newInputStream(path);\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.internal.util.ClasspathClassLoader#getResourceAsStream\n methodBody: public InputStream getResourceAsStream(String name) {\nif(fileSystem != null){int lastSlash=name.lastIndexOf('/');\nString packageName=name.substring(0,Math.max(lastSlash,0));\nSet<String> moduleNames=packagesDirsToModules.get(packageName);\nif(moduleNames != null){LOG.trace(\"Trying to find {} in jrt-fs with packageName={} and modules={}\",name,packageName,moduleNames);\nfor(String moduleCandidate: moduleNames){Path candidate=fileSystem.getPath(\"modules\",moduleCandidate,name);\nif(Files.exists(candidate)){LOG.trace(\"Found {}\",candidate);\ntryreturn Files.newInputStream(candidate);\ncatch(IOException e)throw new UncheckedIOException(e);\n}}}}return super.getResourceAsStream(name);\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n    public InputStream getResourceAsStream(String name) {\n        // always first search in jrt-fs, if available\n        // note: we can't override just getResource(String) and return a jrt:/-URL, because the URL itself\n        // won't be connected to the correct JrtFileSystem and would just load using the system classloader.\n        if (fileSystem != null) {\n            String moduleName = extractModuleName(name);\n            if (moduleName != null) {\n                LOG.trace(\"Trying to load module-info.class for module {} in jrt-fs\", moduleName);\n                Path candidate = fileSystem.getPath(\"modules\", moduleName, MODULE_INFO_SUFFIX);\n                if (Files.exists(candidate)) {\n                    return newInputStreamFromJrtFilesystem(candidate);\n                }\n            }\n\n            int lastSlash = name.lastIndexOf('/');\n            String packageName = name.substring(0, Math.max(lastSlash, 0));\n            Set<String> moduleNames = packagesDirsToModules.get(packageName);\n            if (moduleNames != null) {\n                LOG.trace(\"Trying to find {} in jrt-fs with packageName={} and modules={}\",\n                        name, packageName, moduleNames);\n\n                for (String moduleCandidate : moduleNames) {\n                    Path candidate = fileSystem.getPath(\"modules\", moduleCandidate, name);\n                    if (Files.exists(candidate)) {\n                        return newInputStreamFromJrtFilesystem(candidate);\n                    }\n                }\n            }\n        }\n\n        // search in the other jars of the aux classpath.\n        // this will call this.getResource, which will do a child-first search, see below.\n        return super.getResourceAsStream(name);\n    }\nprivate static InputStream newInputStreamFromJrtFilesystem(Path path) {\n        LOG.trace(\"Found {}\", path);\n        try {\n            // Note: The input streams from JrtFileSystem are ByteArrayInputStreams and do not\n            // need to be closed - we don't need to track these. The filesystem itself needs to be closed at the end.\n            // See https://github.com/openjdk/jdk/blob/970cd202049f592946f9c1004ea92dbd58abf6fb/src/java.base/share/classes/jdk/internal/jrtfs/JrtFileSystem.java#L334\n            return Files.newInputStream(path);\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }",
        "diffSourceCode": "-  201:     @Override\n-  202:     public InputStream getResourceAsStream(String name) {\n-  203:         // always first search in jrt-fs, if available\n-  204:         // note: we can't override just getResource(String) and return a jrt:/-URL, because the URL itself\n-  205:         // won't be connected to the correct JrtFileSystem and would just load using the system classloader.\n-  206:         if (fileSystem != null) {\n-  207:             int lastSlash = name.lastIndexOf('/');\n-  208:             String packageName = name.substring(0, Math.max(lastSlash, 0));\n-  209:             Set<String> moduleNames = packagesDirsToModules.get(packageName);\n-  210:             if (moduleNames != null) {\n-  211:                 LOG.trace(\"Trying to find {} in jrt-fs with packageName={} and modules={}\",\n-  212:                         name, packageName, moduleNames);\n-  213: \n-  214:                 for (String moduleCandidate : moduleNames) {\n-  215:                     Path candidate = fileSystem.getPath(\"modules\", moduleCandidate, name);\n-  216:                     if (Files.exists(candidate)) {\n-  217:                         LOG.trace(\"Found {}\", candidate);\n-  218:                         try {\n-  219:                             // Note: The input streams from JrtFileSystem are ByteArrayInputStreams and do not\n-  220:                             // need to be closed - we don't need to track these. The filesystem itself needs to be closed at the end.\n-  221:                             // See https://github.com/openjdk/jdk/blob/970cd202049f592946f9c1004ea92dbd58abf6fb/src/java.base/share/classes/jdk/internal/jrtfs/JrtFileSystem.java#L334\n-  222:                             return Files.newInputStream(candidate);\n-  223:                         } catch (IOException e) {\n-  224:                             throw new UncheckedIOException(e);\n-  225:                         }\n-  226:                     }\n-  227:                 }\n-  228:             }\n-  229:         }\n-  230: \n-  231:         // search in the other jars of the aux classpath.\n-  232:         // this will call this.getResource, which will do a child-first search, see below.\n-  233:         return super.getResourceAsStream(name);\n-  234:     }\n-  235: \n-  236:     @Override\n-  237:     public URL getResource(String name) {\n-  238:         // Override to make it child-first. This is the method used by\n-  239:         // pmd-java's type resolution to fetch classes, instead of loadClass.\n-  240:         Objects.requireNonNull(name);\n-  241: \n-  242:         URL url = findResource(name);\n-  243:         if (url == null) {\n-  244:             // note this will actually call back into this.findResource, but\n-  245:             // we can't avoid this as the super implementation uses JDK internal\n-  246:             // stuff that we can't copy down here.\n-  247:             return super.getResource(name);\n-  248:         }\n-  249:         return url;\n-  250:     }\n-  251: \n-  252:     @Override\n-  254:         throw new IllegalStateException(\"This class loader shouldn't be used to load classes\");\n-  255:     }\n-  256: \n-  257:     @Override\n-  258:     public void close() throws IOException {\n-  259:         if (fileSystem != null) {\n-  260:             fileSystem.close();\n-  261:             // jrt created an own classloader to load the JrtFileSystemProvider class out of the\n-  262:             // jrt-fs.jar. This needs to be closed manually.\n-  263:             ClassLoader classLoader = fileSystem.getClass().getClassLoader();\n-  264:             if (classLoader instanceof URLClassLoader) {\n+  201:         return getClass().getSimpleName()\n+  202:             + \"[[\"\n+  203:             + StringUtils.join(getURLs(), \":\")\n+  204:             + \"] jrt-fs: \" + javaHome + \" parent: \" + getParent() + ']';\n+  205:     }\n+  206: \n+  207:     private static final String MODULE_INFO_SUFFIX = \"module-info.class\";\n+  208:     private static final String MODULE_INFO_SUFFIX_SLASH = \"/\" + MODULE_INFO_SUFFIX;\n+  209: \n+  210:     @Nullable\n+  211:     private static String extractModuleName(String name) {\n+  212:         if (!name.endsWith(MODULE_INFO_SUFFIX_SLASH)) {\n+  213:             return null;\n+  214:         }\n+  215:         return name.substring(0, name.length() - MODULE_INFO_SUFFIX_SLASH.length());\n+  216:     }\n+  217: \n+  218:     @Override\n+  219:     public InputStream getResourceAsStream(String name) {\n+  220:         // always first search in jrt-fs, if available\n+  221:         // note: we can't override just getResource(String) and return a jrt:/-URL, because the URL itself\n+  222:         // won't be connected to the correct JrtFileSystem and would just load using the system classloader.\n+  223:         if (fileSystem != null) {\n+  224:             String moduleName = extractModuleName(name);\n+  225:             if (moduleName != null) {\n+  226:                 LOG.trace(\"Trying to load module-info.class for module {} in jrt-fs\", moduleName);\n+  227:                 Path candidate = fileSystem.getPath(\"modules\", moduleName, MODULE_INFO_SUFFIX);\n+  228:                 if (Files.exists(candidate)) {\n+  229:                     return newInputStreamFromJrtFilesystem(candidate);\n+  230:                 }\n+  231:             }\n+  232: \n+  233:             int lastSlash = name.lastIndexOf('/');\n+  234:             String packageName = name.substring(0, Math.max(lastSlash, 0));\n+  235:             Set<String> moduleNames = packagesDirsToModules.get(packageName);\n+  236:             if (moduleNames != null) {\n+  237:                 LOG.trace(\"Trying to find {} in jrt-fs with packageName={} and modules={}\",\n+  238:                         name, packageName, moduleNames);\n+  239: \n+  240:                 for (String moduleCandidate : moduleNames) {\n+  241:                     Path candidate = fileSystem.getPath(\"modules\", moduleCandidate, name);\n+  242:                     if (Files.exists(candidate)) {\n+  243:                         return newInputStreamFromJrtFilesystem(candidate);\n+  244:                     }\n+  245:                 }\n+  246:             }\n+  247:         }\n+  248: \n+  249:         // search in the other jars of the aux classpath.\n+  250:         // this will call this.getResource, which will do a child-first search, see below.\n+  251:         return super.getResourceAsStream(name);\n+  252:     }\n+  254:     private static InputStream newInputStreamFromJrtFilesystem(Path path) {\n+  255:         LOG.trace(\"Found {}\", path);\n+  256:         try {\n+  257:             // Note: The input streams from JrtFileSystem are ByteArrayInputStreams and do not\n+  258:             // need to be closed - we don't need to track these. The filesystem itself needs to be closed at the end.\n+  259:             // See https://github.com/openjdk/jdk/blob/970cd202049f592946f9c1004ea92dbd58abf6fb/src/java.base/share/classes/jdk/internal/jrtfs/JrtFileSystem.java#L334\n+  260:             return Files.newInputStream(path);\n+  261:         } catch (IOException e) {\n+  262:             throw new UncheckedIOException(e);\n+  263:         }\n+  264:     }\n",
        "uniqueId": "47470b5d0c112b0d5b13b216569ae3bc211341fb_201_234_254_264_218_252",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 82,
                "covered": 7
            },
            "BRANCH": {
                "missed": 7,
                "covered": 1
            },
            "LINE": {
                "missed": 13,
                "covered": 2
            },
            "COMPLEXITY": {
                "missed": 4,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate flatValue(value ASTMemberValue) : NodeStream<ASTMemberValue> extracted from public getFlatValue(attrName String) : NodeStream<ASTMemberValue> in class net.sourceforge.pmd.lang.java.ast.ASTAnnotation",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAnnotation.java",
                "startLine": 71,
                "endLine": 86,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAnnotation.java",
                "startLine": 71,
                "endLine": 85,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAnnotation.java",
                "startLine": 103,
                "endLine": 107,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Return the expression values for the attribute with the given name.\n     * This may flatten an array initializer. For example, for the attribute\n     * named \"value\":\n     * <pre>{@code\n     * - @SuppressWarnings -> returns empty node stream\n     * - @SuppressWarning(\"fallthrough\") -> returns [\"fallthrough\"]\n     * - @SuppressWarning(value={\"fallthrough\"}) -> returns [\"fallthrough\"]\n     * - @SuppressWarning({\"fallthrough\", \"rawtypes\"}) -> returns [\"fallthrough\", \"rawtypes\"]\n     * }</pre>\n     */\n    public NodeStream<ASTMemberValue> getFlatValue(String attrName) {\n        return NodeStream.of(getAttribute(attrName))\n                         .flatMap(v -> v instanceof ASTMemberValueArrayInitializer ? v.children(ASTMemberValue.class)\n                                                                                   : NodeStream.of(v));\n    }",
        "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAnnotation.java",
        "isPureRefactoring": true,
        "commitId": "cb1d1963a42582ac4fc4006fc9abab10bec280dc",
        "packageNameBefore": "net.sourceforge.pmd.lang.java.ast",
        "classNameBefore": "net.sourceforge.pmd.lang.java.ast.ASTAnnotation",
        "methodNameBefore": "net.sourceforge.pmd.lang.java.ast.ASTAnnotation#getFlatValue",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.java.ast.ASTAnnotation#getAttribute\n methodBody: public @Nullable ASTMemberValue getAttribute(String attrName) {\nreturn getMembers().filter(pair -> pair.getName().equals(attrName)).map(ASTMemberValuePair::getValue).first();\n}",
        "classSignatureBefore": "public final class ASTAnnotation extends AbstractJavaTypeNode implements ASTMemberValue, Iterable<ASTMemberValuePair> ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.ast.ASTAnnotation#getFlatValue"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.ast.ASTAnnotation"
        ],
        "classSignatureBeforeSet": [
            "public final class ASTAnnotation extends AbstractJavaTypeNode implements ASTMemberValue, Iterable<ASTMemberValuePair> "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Overlapped refactoring - can be identical by undoing the overlapped refactoring\n- Rename Variable-",
                "description": "Rename Variable on top of the extract method - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.ast;\n\nimport java.util.Iterator;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport net.sourceforge.pmd.lang.ast.NodeStream;\nimport net.sourceforge.pmd.lang.java.types.JClassType;\n\n/**\n * Represents an annotation.\n *\n * <pre class=\"grammar\">\n *\n * Annotation ::= \"@\" {@link ASTClassType ClassName} {@link ASTAnnotationMemberList AnnotationMemberList}?\n *\n * </pre>\n */\npublic final class ASTAnnotation extends AbstractJavaTypeNode implements ASTMemberValue, Iterable<ASTMemberValuePair> {\n\n    ASTAnnotation(int id) {\n        super(id);\n    }\n\n\n    /**\n     * Returns the node that represents the name of the annotation.\n     */\n    public ASTClassType getTypeNode() {\n        return (ASTClassType) getChild(0);\n    }\n\n    @Override\n    public @NonNull JClassType getTypeMirror() {\n        return (JClassType) super.getTypeMirror();\n    }\n\n    /**\n     * Returns the simple name of the annotation.\n     */\n    public String getSimpleName() {\n        return getTypeNode().getSimpleName();\n    }\n\n\n    /**\n     * Returns the list of members, or null if there is none.\n     */\n    public @Nullable ASTAnnotationMemberList getMemberList() {\n        return children().first(ASTAnnotationMemberList.class);\n    }\n\n    /**\n     * Returns the stream of explicit members for this annotation.\n     */\n    public NodeStream<ASTMemberValuePair> getMembers() {\n        return children(ASTAnnotationMemberList.class).children(ASTMemberValuePair.class);\n    }\n\n\n    @Override\n    public Iterator<ASTMemberValuePair> iterator() {\n        return children(ASTMemberValuePair.class).iterator();\n    }\n\n    /**\n     * Return the expression values for the attribute with the given name.\n     * This may flatten an array initializer. For example, for the attribute\n     * named \"value\":\n     * <pre>{@code\n     * - @SuppressWarnings -> returns empty node stream\n     * - @SuppressWarning(\"fallthrough\") -> returns [\"fallthrough\"]\n     * - @SuppressWarning(value={\"fallthrough\"}) -> returns [\"fallthrough\"]\n     * - @SuppressWarning({\"fallthrough\", \"rawtypes\"}) -> returns [\"fallthrough\", \"rawtypes\"]\n     * }</pre>\n     */\n    public NodeStream<ASTMemberValue> getFlatValue(String attrName) {\n        return NodeStream.of(getAttribute(attrName))\n                         .flatMap(v -> v instanceof ASTMemberValueArrayInitializer ? v.children(ASTMemberValue.class)\n                                                                                   : NodeStream.of(v));\n    }\n\n    /**\n     * Returns the value of the attribute with the given name, returns\n     * null if no such attribute was mentioned. For example, for the attribute\n     * named \"value\":\n     * <pre>{@code\n     * - @SuppressWarnings -> returns null\n     * - @SuppressWarning(\"fallthrough\") -> returns \"fallthrough\"\n     * - @SuppressWarning(value={\"fallthrough\"}) -> returns {\"fallthrough\"}\n     * - @SuppressWarning({\"fallthrough\", \"rawtypes\"}) -> returns {\"fallthrough\", \"rawtypes\"}\n     * }</pre>\n     *\n     * @param attrName Name of an attribute\n     */\n    public @Nullable ASTMemberValue getAttribute(String attrName) {\n        return getMembers().filter(pair -> pair.getName().equals(attrName))\n                           .map(ASTMemberValuePair::getValue)\n                           .first();\n    }\n\n\n    @Override\n    public <P, R> R acceptVisitor(JavaVisitor<? super P, ? extends R> visitor, P data) {\n        return visitor.visit(this, data);\n    }\n\n}\n",
        "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAnnotation.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.ast;\n\nimport java.util.Iterator;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport net.sourceforge.pmd.lang.ast.NodeStream;\nimport net.sourceforge.pmd.lang.java.types.JClassType;\n\n/**\n * Represents an annotation.\n *\n * <pre class=\"grammar\">\n *\n * Annotation ::= \"@\" {@link ASTClassType ClassName} {@link ASTAnnotationMemberList AnnotationMemberList}?\n *\n * </pre>\n */\npublic final class ASTAnnotation extends AbstractJavaTypeNode implements ASTMemberValue, Iterable<ASTMemberValuePair> {\n\n    ASTAnnotation(int id) {\n        super(id);\n    }\n\n\n    /**\n     * Returns the node that represents the name of the annotation.\n     */\n    public ASTClassType getTypeNode() {\n        return (ASTClassType) getChild(0);\n    }\n\n    @Override\n    public @NonNull JClassType getTypeMirror() {\n        return (JClassType) super.getTypeMirror();\n    }\n\n    /**\n     * Returns the simple name of the annotation.\n     */\n    public String getSimpleName() {\n        return getTypeNode().getSimpleName();\n    }\n\n\n    /**\n     * Returns the list of members, or null if there is none.\n     */\n    public @Nullable ASTAnnotationMemberList getMemberList() {\n        return children().first(ASTAnnotationMemberList.class);\n    }\n\n    /**\n     * Returns the stream of explicit members for this annotation.\n     */\n    public NodeStream<ASTMemberValuePair> getMembers() {\n        return children(ASTAnnotationMemberList.class).children(ASTMemberValuePair.class);\n    }\n\n\n    @Override\n    public Iterator<ASTMemberValuePair> iterator() {\n        return children(ASTMemberValuePair.class).iterator();\n    }\n\n    /**\n     * Return the expression values for the attribute with the given name.\n     * This may flatten an array initializer. For example, for the attribute\n     * named \"value\":\n     * <pre>{@code\n     * - @SuppressWarnings -> returns empty node stream\n     * - @SuppressWarning(\"fallthrough\") -> returns [\"fallthrough\"]\n     * - @SuppressWarning(value={\"fallthrough\"}) -> returns [\"fallthrough\"]\n     * - @SuppressWarning({\"fallthrough\", \"rawtypes\"}) -> returns [\"fallthrough\", \"rawtypes\"]\n     * }</pre>\n     */\n    public NodeStream<ASTMemberValue> getFlatValue(String attrName) {\n        return NodeStream.of(getAttribute(attrName))\n                         .flatMap(this::flatValue);\n    }\n\n    /**\n     * Return expression values for all attributes.\n     * This may flatten an array initializer. For example, for the attribute\n     * named \"value\":\n     * <pre>{@code\n     * - @SuppressWarnings -> returns empty node stream\n     * - @SuppressWarning(\"fallthrough\") -> returns [\"fallthrough\"]\n     * - @SuppressWarning(value={\"fallthrough\"}) -> returns [\"fallthrough\"]\n     * - @SuppressWarning({\"fallthrough\", \"rawtypes\"}) -> returns [\"fallthrough\", \"rawtypes\"]\n     * }</pre>\n     */\n    public NodeStream<ASTMemberValue> getFlatValues() {\n        return getMembers().map(ASTMemberValuePair::getValue)\n                           .flatMap(this::flatValue);\n    }\n\n    private NodeStream<ASTMemberValue> flatValue(ASTMemberValue value) {\n        return value instanceof ASTMemberValueArrayInitializer\n            ? value.children(ASTMemberValue.class)\n            : NodeStream.of(value);\n    }\n\n    /**\n     * Returns the value of the attribute with the given name, returns\n     * null if no such attribute was mentioned. For example, for the attribute\n     * named \"value\":\n     * <pre>{@code\n     * - @SuppressWarnings -> returns null\n     * - @SuppressWarning(\"fallthrough\") -> returns \"fallthrough\"\n     * - @SuppressWarning(value={\"fallthrough\"}) -> returns {\"fallthrough\"}\n     * - @SuppressWarning({\"fallthrough\", \"rawtypes\"}) -> returns {\"fallthrough\", \"rawtypes\"}\n     * }</pre>\n     *\n     * @param attrName Name of an attribute\n     */\n    public @Nullable ASTMemberValue getAttribute(String attrName) {\n        return getMembers().filter(pair -> pair.getName().equals(attrName))\n                           .map(ASTMemberValuePair::getValue)\n                           .first();\n    }\n\n\n    @Override\n    public <P, R> R acceptVisitor(JavaVisitor<? super P, ? extends R> visitor, P data) {\n        return visitor.visit(this, data);\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "private NodeStream<ASTMemberValue> flatValue(ASTMemberValue value) {\n        return value instanceof ASTMemberValueArrayInitializer\n            ? value.children(ASTMemberValue.class)\n            : NodeStream.of(value);\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.java.ast.ASTAnnotation#getAttribute\n methodBody: public @Nullable ASTMemberValue getAttribute(String attrName) {\nreturn getMembers().filter(pair -> pair.getName().equals(attrName)).map(ASTMemberValuePair::getValue).first();\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Return the expression values for the attribute with the given name.\n     * This may flatten an array initializer. For example, for the attribute\n     * named \"value\":\n     * <pre>{@code\n     * - @SuppressWarnings -> returns empty node stream\n     * - @SuppressWarning(\"fallthrough\") -> returns [\"fallthrough\"]\n     * - @SuppressWarning(value={\"fallthrough\"}) -> returns [\"fallthrough\"]\n     * - @SuppressWarning({\"fallthrough\", \"rawtypes\"}) -> returns [\"fallthrough\", \"rawtypes\"]\n     * }</pre>\n     */\n    public NodeStream<ASTMemberValue> getFlatValue(String attrName) {\n        return NodeStream.of(getAttribute(attrName))\n                         .flatMap(this::flatValue);\n    }\nprivate NodeStream<ASTMemberValue> flatValue(ASTMemberValue value) {\n        return value instanceof ASTMemberValueArrayInitializer\n            ? value.children(ASTMemberValue.class)\n            : NodeStream.of(value);\n    }",
        "diffSourceCode": "    71:     /**\n    72:      * Return the expression values for the attribute with the given name.\n    73:      * This may flatten an array initializer. For example, for the attribute\n    74:      * named \"value\":\n    75:      * <pre>{@code\n    76:      * - @SuppressWarnings -> returns empty node stream\n    77:      * - @SuppressWarning(\"fallthrough\") -> returns [\"fallthrough\"]\n    78:      * - @SuppressWarning(value={\"fallthrough\"}) -> returns [\"fallthrough\"]\n    79:      * - @SuppressWarning({\"fallthrough\", \"rawtypes\"}) -> returns [\"fallthrough\", \"rawtypes\"]\n    80:      * }</pre>\n    81:      */\n    82:     public NodeStream<ASTMemberValue> getFlatValue(String attrName) {\n    83:         return NodeStream.of(getAttribute(attrName))\n-   84:                          .flatMap(v -> v instanceof ASTMemberValueArrayInitializer ? v.children(ASTMemberValue.class)\n-   85:                                                                                    : NodeStream.of(v));\n-   86:     }\n-  103:                            .map(ASTMemberValuePair::getValue)\n-  104:                            .first();\n-  105:     }\n-  106: \n-  107: \n+   84:                          .flatMap(this::flatValue);\n+   85:     }\n+   86: \n+  103:     private NodeStream<ASTMemberValue> flatValue(ASTMemberValue value) {\n+  104:         return value instanceof ASTMemberValueArrayInitializer\n+  105:             ? value.children(ASTMemberValue.class)\n+  106:             : NodeStream.of(value);\n+  107:     }\n",
        "uniqueId": "cb1d1963a42582ac4fc4006fc9abab10bec280dc_71_86_103_107_71_85",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 7
            },
            "LINE": {
                "missed": 0,
                "covered": 2
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic getText() : CharSequence extracted from public getImage() : String in class net.sourceforge.pmd.lang.java.ast.ASTStringLiteral & moved to class net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTStringLiteral.java",
                "startLine": 33,
                "endLine": 39,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTStringLiteral.java",
                "startLine": 29,
                "endLine": 32,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTStringLiteral.java",
                "startLine": 43,
                "endLine": 46,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n    public String getImage() {\n        if (reconstructedImage == null) {\n            reconstructedImage = isTextBlock ? super.getImage() : getEscapedStringLiteral(super.getImage());\n        }\n        return reconstructedImage;\n    }",
        "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTStringLiteral.java",
        "isPureRefactoring": true,
        "commitId": "a70e70ad15995e87060380ee241e36c045d44883",
        "packageNameBefore": "net.sourceforge.pmd.lang.java.ast",
        "classNameBefore": "net.sourceforge.pmd.lang.java.ast.ASTStringLiteral",
        "methodNameBefore": "net.sourceforge.pmd.lang.java.ast.ASTStringLiteral#getImage",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.cpd.token.AntlrToken#getImage\n methodBody: public String getImage() {\nreturn token.getText();\n}\nmethodSignature: net.sourceforge.pmd.lang.java.ast.ASTStringLiteral#getEscapedStringLiteral\n methodBody: private String getEscapedStringLiteral(String javaccEscaped) {\nint fullLength=getEndColumn() - getBeginColumn();\nif(fullLength > javaccEscaped.length()){StringBuilder result=new StringBuilder(fullLength);\nfor(int i=0; i < javaccEscaped.length(); i++){char c=javaccEscaped.charAt(i);\nif(c < 0x20 || c > 0xff || javaccEscaped.length() == 1){String hex=\"0000\" + Integer.toHexString(c);\nresult.append(\"\\\\u\").append(hex.substring(hex.length() - 4));\n}{result.append(c);\n}}return result.toString();\n}return javaccEscaped;\n}\nmethodSignature: net.sourceforge.pmd.lang.ast.GenericToken#getImage\n methodBody: String getImage();\nmethodSignature: net.sourceforge.pmd.lang.java.ast.ASTStringLiteral#getImage\n methodBody: public String getImage() {\nif(reconstructedImage == null){reconstructedImage=isTextBlock ? super.getImage() : getEscapedStringLiteral(super.getImage());\n}return reconstructedImage;\n}",
        "classSignatureBefore": "public final class ASTStringLiteral extends AbstractLiteral implements ASTLiteral ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.ast.ASTStringLiteral#getImage"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.ast.ASTStringLiteral"
        ],
        "classSignatureBeforeSet": [
            "public final class ASTStringLiteral extends AbstractLiteral implements ASTLiteral "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.ast;\n\nimport org.apache.commons.lang3.StringEscapeUtils;\n\n\n/**\n * Represents a string literal. The image of this node can be the literal as it appeared\n * in the source, but JavaCC performs its own unescaping and some escapes may be lost.\n * At the very least it has delimiters. {@link #getUnescapedValue()} allows to recover\n * the actual runtime value.\n */\npublic final class ASTStringLiteral extends AbstractLiteral implements ASTLiteral {\n\n    private boolean isTextBlock;\n\n    ASTStringLiteral(int id) {\n        super(id);\n    }\n\n\n    ASTStringLiteral(JavaParser p, int id) {\n        super(p, id);\n    }\n\n\n    private String reconstructedImage = null;\n\n\n    @Override\n    public String getImage() {\n        if (reconstructedImage == null) {\n            reconstructedImage = isTextBlock ? super.getImage() : getEscapedStringLiteral(super.getImage());\n        }\n        return reconstructedImage;\n    }\n\n\n    /**\n     * Tries to reconstruct the original string literal. If the original length\n     * is greater than the parsed String literal, then probably some unicode\n     * escape sequences have been used.\n     */\n    private String getEscapedStringLiteral(String javaccEscaped) {\n        int fullLength = getEndColumn() - getBeginColumn();\n        if (fullLength > javaccEscaped.length()) {\n            StringBuilder result = new StringBuilder(fullLength);\n            for (int i = 0; i < javaccEscaped.length(); i++) {\n                char c = javaccEscaped.charAt(i);\n                if (c < 0x20 || c > 0xff || javaccEscaped.length() == 1) {\n                    String hex = \"0000\" + Integer.toHexString(c);\n                    result.append(\"\\\\u\").append(hex.substring(hex.length() - 4));\n                } else {\n                    result.append(c);\n                }\n            }\n            return result.toString();\n        }\n        return javaccEscaped;\n    }\n\n    void setTextBlock() {\n        this.isTextBlock = true;\n    }\n\n    /** Returns true if this is a text block (currently Java 13 preview feature). */\n    public boolean isTextBlock() {\n        return isTextBlock;\n    }\n\n    @Override\n    public Object jjtAccept(JavaParserVisitor visitor, Object data) {\n        return visitor.visit(this, data);\n    }\n\n\n    @Override\n    public <T> void jjtAccept(SideEffectingVisitor<T> visitor, T data) {\n        visitor.visit(this, data);\n    }\n\n\n    /**\n     * Returns the value without delimiters and unescaped.\n     */\n    public String getUnescapedValue() {\n        String image = getImage();\n        String woDelims = image.substring(1, image.length() - 1);\n        return StringEscapeUtils.unescapeJava(woDelims);\n    }\n\n}\n",
        "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTStringLiteral.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.ast;\n\nimport org.apache.commons.lang3.StringEscapeUtils;\n\n/**\n * Represents a string literal. The image of this node can be the literal as it appeared\n * in the source, but JavaCC performs its own unescaping and some escapes may be lost.\n * At the very least it has delimiters. {@link #getUnescapedValue()} allows to recover\n * the actual runtime value.\n */\npublic final class ASTStringLiteral extends AbstractLiteral implements ASTLiteral {\n\n    private boolean isTextBlock;\n\n    ASTStringLiteral(int id) {\n        super(id);\n    }\n\n\n    ASTStringLiteral(JavaParser p, int id) {\n        super(p, id);\n    }\n\n\n    @Override\n    public String getImage() {\n        return getText().toString();\n    }\n\n    void setTextBlock() {\n        this.isTextBlock = true;\n    }\n\n    /** Returns true if this is a text block (currently Java 13 preview feature). */\n    public boolean isTextBlock() {\n        return isTextBlock;\n    }\n\n    @Override\n    public Object jjtAccept(JavaParserVisitor visitor, Object data) {\n        return visitor.visit(this, data);\n    }\n\n\n    @Override\n    public <T> void jjtAccept(SideEffectingVisitor<T> visitor, T data) {\n        visitor.visit(this, data);\n    }\n\n\n    /**\n     * Returns the value without delimiters and unescaped.\n     */\n    public String getUnescapedValue() {\n        String image = super.getImage();\n        String woDelims = image.substring(1, image.length() - 1);\n        return StringEscapeUtils.unescapeJava(woDelims);\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "@Override\n    public Object jjtAccept(JavaParserVisitor visitor, Object data) {\n        return visitor.visit(this, data);\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.cpd.token.AntlrToken#getImage\n methodBody: public String getImage() {\nreturn token.getText();\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.ast.ASTStringLiteral#getEscapedStringLiteral\n methodBody: private String getEscapedStringLiteral(String javaccEscaped) {\nint fullLength=getEndColumn() - getBeginColumn();\nif(fullLength > javaccEscaped.length()){StringBuilder result=new StringBuilder(fullLength);\nfor(int i=0; i < javaccEscaped.length(); i++){char c=javaccEscaped.charAt(i);\nif(c < 0x20 || c > 0xff || javaccEscaped.length() == 1){String hex=\"0000\" + Integer.toHexString(c);\nresult.append(\"\\\\u\").append(hex.substring(hex.length() - 4));\n}{result.append(c);\n}}return result.toString();\n}return javaccEscaped;\n}",
            "methodSignature: net.sourceforge.pmd.lang.ast.GenericToken#getImage\n methodBody: String getImage();",
            "methodSignature: net.sourceforge.pmd.lang.java.ast.ASTStringLiteral#getImage\n methodBody: public String getImage() {\nif(reconstructedImage == null){reconstructedImage=isTextBlock ? super.getImage() : getEscapedStringLiteral(super.getImage());\n}return reconstructedImage;\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n    public String getImage() {\n        return getText().toString();\n    }\n@Override\n    public Object jjtAccept(JavaParserVisitor visitor, Object data) {\n        return visitor.visit(this, data);\n    }",
        "diffSourceCode": "-   29: \n-   30:     private String reconstructedImage = null;\n-   31: \n-   32: \n-   33:     @Override\n-   34:     public String getImage() {\n-   35:         if (reconstructedImage == null) {\n-   36:             reconstructedImage = isTextBlock ? super.getImage() : getEscapedStringLiteral(super.getImage());\n-   37:         }\n-   38:         return reconstructedImage;\n-   39:     }\n-   43:      * Tries to reconstruct the original string literal. If the original length\n-   44:      * is greater than the parsed String literal, then probably some unicode\n-   45:      * escape sequences have been used.\n-   46:      */\n+   29:     @Override\n+   30:     public String getImage() {\n+   31:         return getText().toString();\n+   32:     }\n+   33: \n+   34:     void setTextBlock() {\n+   35:         this.isTextBlock = true;\n+   36:     }\n+   37: \n+   38:     /** Returns true if this is a text block (currently Java 13 preview feature). */\n+   39:     public boolean isTextBlock() {\n+   43:     @Override\n+   44:     public Object jjtAccept(JavaParserVisitor visitor, Object data) {\n+   45:         return visitor.visit(this, data);\n+   46:     }\n",
        "uniqueId": "a70e70ad15995e87060380ee241e36c045d44883_33_39_43_46_29_32",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 18
            },
            "BRANCH": {
                "missed": 0,
                "covered": 4
            },
            "LINE": {
                "missed": 0,
                "covered": 3
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 3
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Move And Inline Method",
        "description": "Move And Inline Method\tpublic getFileExtensionOrDirectoryFilter(extensions String...) : Predicate<File> moved from class net.sourceforge.pmd.internal.util.PredicateUtil to class net.sourceforge.pmd.cpd.AbstractLanguage & inlined to public AbstractLanguage(name String, terseName String, tokenizer Tokenizer, extensions String...)",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/cpd/AbstractLanguage.java",
                "startLine": 21,
                "endLine": 27,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/cpd/AbstractLanguage.java",
                "startLine": 22,
                "endLine": 28,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/cpd/AbstractLanguage.java",
                "startLine": 65,
                "endLine": 75,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "",
        "filePathBefore": "pmd-core/src/main/java/net/sourceforge/pmd/cpd/AbstractLanguage.java",
        "isPureRefactoring": true,
        "commitId": "26bcbd839a79055a0ff037da3c8c54ad2bdfdead",
        "packageNameBefore": "net.sourceforge.pmd.internal.util",
        "classNameBefore": "net.sourceforge.pmd.internal.util.PredicateUtil",
        "methodNameBefore": "net.sourceforge.pmd.internal.util.PredicateUtil#getFileExtensionOrDirectoryFilter",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.internal.util.PredicateUtil#getFileExtensionFilter\n methodBody: public static Predicate<File> getFileExtensionFilter(String... extensions) {\nreturn new FileExtensionFilter(extensions);\n}",
        "classSignatureBefore": "public final class PredicateUtil ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.internal.util.PredicateUtil#getFileExtensionOrDirectoryFilter"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.internal.util.PredicateUtil"
        ],
        "classSignatureBeforeSet": [
            "public final class PredicateUtil "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.cpd;\n\nimport java.io.FilenameFilter;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Properties;\n\nimport net.sourceforge.pmd.internal.util.PredicateUtil;\n\npublic abstract class AbstractLanguage implements Language {\n    private final String name;\n    private final String terseName;\n    private final Tokenizer tokenizer;\n    private final FilenameFilter fileFilter;\n    private final List<String> extensions;\n\n    public AbstractLanguage(String name, String terseName, Tokenizer tokenizer, String... extensions) {\n        this.name = name;\n        this.terseName = terseName;\n        this.tokenizer = tokenizer;\n        fileFilter = PredicateUtil.toFilenameFilter(PredicateUtil.getFileExtensionOrDirectoryFilter(extensions));\n        this.extensions = Arrays.asList(extensions);\n    }\n\n    @Override\n    public FilenameFilter getFileFilter() {\n        return fileFilter;\n    }\n\n    @Override\n    public Tokenizer getTokenizer() {\n        return tokenizer;\n    }\n\n    @Override\n    public void setProperties(Properties properties) {\n        // needs to be implemented by subclasses.\n    }\n\n    @Override\n    public String getName() {\n        return name;\n    }\n\n    @Override\n    public String getTerseName() {\n        return terseName;\n    }\n\n    @Override\n    public List<String> getExtensions() {\n        return extensions;\n    }\n}\n",
        "filePathAfter": "pmd-core/src/main/java/net/sourceforge/pmd/cpd/AbstractLanguage.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.cpd;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Properties;\n\nimport net.sourceforge.pmd.internal.util.PredicateUtil;\n\npublic abstract class AbstractLanguage implements Language {\n    private final String name;\n    private final String terseName;\n    private final Tokenizer tokenizer;\n    private final FilenameFilter fileFilter;\n    private final List<String> extensions;\n\n    public AbstractLanguage(String name, String terseName, Tokenizer tokenizer, String... extensions) {\n        this.name = name;\n        this.terseName = terseName;\n        this.tokenizer = tokenizer;\n        fileFilter = PredicateUtil.toFilenameFilter(PredicateUtil.getFileExtensionFilter(extensions).or(File::isDirectory));\n        this.extensions = Arrays.asList(extensions);\n    }\n\n    @Override\n    public FilenameFilter getFileFilter() {\n        return fileFilter;\n    }\n\n    @Override\n    public Tokenizer getTokenizer() {\n        return tokenizer;\n    }\n\n    @Override\n    public void setProperties(Properties properties) {\n        // needs to be implemented by subclasses.\n    }\n\n    @Override\n    public String getName() {\n        return name;\n    }\n\n    @Override\n    public String getTerseName() {\n        return terseName;\n    }\n\n    @Override\n    public List<String> getExtensions() {\n        return extensions;\n    }\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.internal.util.PredicateUtil#getFileExtensionFilter\n methodBody: public static Predicate<File> getFileExtensionFilter(String... extensions) {\nreturn new FileExtensionFilter(extensions);\n}"
        ],
        "sourceCodeAfterRefactoring": "public AbstractLanguage(String name, String terseName, Tokenizer tokenizer, String... extensions) {\n        this.name = name;\n        this.terseName = terseName;\n        this.tokenizer = tokenizer;\n        fileFilter = PredicateUtil.toFilenameFilter(PredicateUtil.getFileExtensionFilter(extensions).or(File::isDirectory));\n        this.extensions = Arrays.asList(extensions);\n    }",
        "diffSourceCode": "-   21:     public AbstractLanguage(String name, String terseName, Tokenizer tokenizer, String... extensions) {\n-   22:         this.name = name;\n-   23:         this.terseName = terseName;\n-   24:         this.tokenizer = tokenizer;\n-   25:         fileFilter = PredicateUtil.toFilenameFilter(PredicateUtil.getFileExtensionOrDirectoryFilter(extensions));\n-   26:         this.extensions = Arrays.asList(extensions);\n-   27:     }\n-   28: \n+   21: \n+   22:     public AbstractLanguage(String name, String terseName, Tokenizer tokenizer, String... extensions) {\n+   23:         this.name = name;\n+   24:         this.terseName = terseName;\n+   25:         this.tokenizer = tokenizer;\n+   26:         fileFilter = PredicateUtil.toFilenameFilter(PredicateUtil.getFileExtensionFilter(extensions).or(File::isDirectory));\n+   27:         this.extensions = Arrays.asList(extensions);\n+   28:     }\n",
        "uniqueId": "26bcbd839a79055a0ff037da3c8c54ad2bdfdead_21_27__22_28_65_75",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 5
            },
            "LINE": {
                "missed": 0,
                "covered": 1
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic getCondition() : ASTExpression extracted from public getGuardExpressionNode() : ASTExpression in class net.sourceforge.pmd.lang.java.ast.ASTForStatement",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTForStatement.java",
                "startLine": 43,
                "endLine": 55,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTForStatement.java",
                "startLine": 43,
                "endLine": 55,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTForStatement.java",
                "startLine": 58,
                "endLine": 70,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Returns the node that represents the guard of this loop.\n     * This may be any expression of type boolean.\n     *\n     * <p>If this node represents a foreach loop, or if there is\n     * no specified guard, then returns null.\n     */\n    public ASTExpression getGuardExpressionNode() {\n        if (isForeach()) {\n            return null;\n        }\n        return getFirstChildOfType(ASTExpression.class);\n    }",
        "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTForStatement.java",
        "isPureRefactoring": true,
        "commitId": "0a0bb6e4bbd5be386ac139ccac3a9c474409d1e5",
        "packageNameBefore": "net.sourceforge.pmd.lang.java.ast",
        "classNameBefore": "net.sourceforge.pmd.lang.java.ast.ASTForStatement",
        "methodNameBefore": "net.sourceforge.pmd.lang.java.ast.ASTForStatement#getGuardExpressionNode",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.java.ast.ASTForStatement#isForeach\n methodBody: public boolean isForeach() {\nreturn jjtGetChild(0) instanceof ASTLocalVariableDeclaration;\n}",
        "classSignatureBefore": "public class ASTForStatement extends AbstractJavaNode ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.ast.ASTForStatement#getGuardExpressionNode"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.ast.ASTForStatement"
        ],
        "classSignatureBeforeSet": [
            "public class ASTForStatement extends AbstractJavaNode "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.ast;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\n\n/**\n * Represents a {@code for}-loop, or a foreach loop.\n *\n * <pre>\n *\n * ForStatement ::= \"for\" \"(\" {@linkplain ASTLocalVariableDeclaration LocalVariableDeclaration} \":\" {@linkplain ASTExpression Expression} \")\" {@linkplain ASTStatement Statement}\n *                | \"for\" \"(\" {@linkplain ASTForInit ForInit}? \";\" {@linkplain ASTExpression Expression}? \";\" {@linkplain ASTForUpdate ForUpdate}? \")\" {@linkplain ASTStatement Statement}\n *\n * </pre>\n */\n// TODO this should be split into two different nodes, otherwise\n// we can't enrich the API without returning null half the time\npublic class ASTForStatement extends AbstractJavaNode {\n\n    @InternalApi\n    @Deprecated\n    public ASTForStatement(int id) {\n        super(id);\n    }\n\n\n    @InternalApi\n    @Deprecated\n    public ASTForStatement(JavaParser p, int id) {\n        super(p, id);\n    }\n\n\n    @Override\n    public Object jjtAccept(JavaParserVisitor visitor, Object data) {\n        return visitor.visit(this, data);\n    }\n\n\n    /**\n     * Returns the node that represents the guard of this loop.\n     * This may be any expression of type boolean.\n     *\n     * <p>If this node represents a foreach loop, or if there is\n     * no specified guard, then returns null.\n     */\n    public ASTExpression getGuardExpressionNode() {\n        if (isForeach()) {\n            return null;\n        }\n        return getFirstChildOfType(ASTExpression.class);\n    }\n\n\n    /**\n     * Returns true if this node represents a foreach loop.\n     */\n    public boolean isForeach() {\n        return jjtGetChild(0) instanceof ASTLocalVariableDeclaration;\n    }\n\n\n    /**\n     * Returns the statement that represents the body of this\n     * loop.\n     */\n    public ASTStatement getBody() {\n        return (ASTStatement) jjtGetChild(jjtGetNumChildren() - 1);\n    }\n\n}\n",
        "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTForStatement.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.ast;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\n\n/**\n * Represents a {@code for}-loop, or a foreach loop.\n *\n * <pre>\n *\n * ForStatement ::= \"for\" \"(\" {@linkplain ASTLocalVariableDeclaration LocalVariableDeclaration} \":\" {@linkplain ASTExpression Expression} \")\" {@linkplain ASTStatement Statement}\n *                | \"for\" \"(\" {@linkplain ASTForInit ForInit}? \";\" {@linkplain ASTExpression Expression}? \";\" {@linkplain ASTForUpdate ForUpdate}? \")\" {@linkplain ASTStatement Statement}\n *\n * </pre>\n */\n// TODO this should be split into two different nodes, otherwise\n// we can't enrich the API without returning null half the time\npublic class ASTForStatement extends AbstractJavaNode {\n\n    @InternalApi\n    @Deprecated\n    public ASTForStatement(int id) {\n        super(id);\n    }\n\n\n    @InternalApi\n    @Deprecated\n    public ASTForStatement(JavaParser p, int id) {\n        super(p, id);\n    }\n\n\n    @Override\n    public Object jjtAccept(JavaParserVisitor visitor, Object data) {\n        return visitor.visit(this, data);\n    }\n\n\n    /**\n     * Returns the node that represents the guard of this loop.\n     * This may be any expression of type boolean.\n     *\n     * <p>If this node represents a foreach loop, or if there is\n     * no specified guard, then returns null.\n     *\n     * @deprecated Use {@link #getCondition()}\n     */\n    @Deprecated\n    public ASTExpression getGuardExpressionNode() {\n        return getCondition();\n    }\n\n\n    /**\n     * Returns the node that represents the guard of this loop.\n     * This may be any expression of type boolean.\n     *\n     * <p>If this node represents a foreach loop, or if there is\n     * no specified guard, then returns null.\n     */\n    public ASTExpression getCondition() {\n        if (isForeach()) {\n            return null;\n        }\n        return getFirstChildOfType(ASTExpression.class);\n    }\n\n\n    /**\n     * Returns true if this node represents a foreach loop.\n     */\n    public boolean isForeach() {\n        return jjtGetChild(0) instanceof ASTLocalVariableDeclaration;\n    }\n\n\n    /**\n     * Returns the statement that represents the body of this\n     * loop.\n     */\n    public ASTStatement getBody() {\n        return (ASTStatement) jjtGetChild(jjtGetNumChildren() - 1);\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * Returns the node that represents the guard of this loop.\n     * This may be any expression of type boolean.\n     *\n     * <p>If this node represents a foreach loop, or if there is\n     * no specified guard, then returns null.\n     */\n    public ASTExpression getCondition() {\n        if (isForeach()) {\n            return null;\n        }\n        return getFirstChildOfType(ASTExpression.class);\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.java.ast.ASTForStatement#isForeach\n methodBody: public boolean isForeach() {\nreturn jjtGetChild(0) instanceof ASTLocalVariableDeclaration;\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Returns the node that represents the guard of this loop.\n     * This may be any expression of type boolean.\n     *\n     * <p>If this node represents a foreach loop, or if there is\n     * no specified guard, then returns null.\n     *\n     * @deprecated Use {@link #getCondition()}\n     */\n    @Deprecated\n    public ASTExpression getGuardExpressionNode() {\n        return getCondition();\n    }\n/**\n     * Returns the node that represents the guard of this loop.\n     * This may be any expression of type boolean.\n     *\n     * <p>If this node represents a foreach loop, or if there is\n     * no specified guard, then returns null.\n     */\n    public ASTExpression getCondition() {\n        if (isForeach()) {\n            return null;\n        }\n        return getFirstChildOfType(ASTExpression.class);\n    }",
        "diffSourceCode": "    43:     /**\n    44:      * Returns the node that represents the guard of this loop.\n    45:      * This may be any expression of type boolean.\n    46:      *\n    47:      * <p>If this node represents a foreach loop, or if there is\n    48:      * no specified guard, then returns null.\n-   49:      */\n-   50:     public ASTExpression getGuardExpressionNode() {\n-   51:         if (isForeach()) {\n-   52:             return null;\n-   53:         }\n-   54:         return getFirstChildOfType(ASTExpression.class);\n+   49:      *\n+   50:      * @deprecated Use {@link #getCondition()}\n+   51:      */\n+   52:     @Deprecated\n+   53:     public ASTExpression getGuardExpressionNode() {\n+   54:         return getCondition();\n    55:     }\n    58:     /**\n-   59:      * Returns true if this node represents a foreach loop.\n-   60:      */\n-   61:     public boolean isForeach() {\n-   62:         return jjtGetChild(0) instanceof ASTLocalVariableDeclaration;\n-   63:     }\n-   64: \n-   65: \n-   66:     /**\n-   67:      * Returns the statement that represents the body of this\n-   68:      * loop.\n-   69:      */\n-   70:     public ASTStatement getBody() {\n+   59:      * Returns the node that represents the guard of this loop.\n+   60:      * This may be any expression of type boolean.\n+   61:      *\n+   62:      * <p>If this node represents a foreach loop, or if there is\n+   63:      * no specified guard, then returns null.\n+   64:      */\n+   65:     public ASTExpression getCondition() {\n+   66:         if (isForeach()) {\n+   67:             return null;\n+   68:         }\n+   69:         return getFirstChildOfType(ASTExpression.class);\n+   70:     }\n",
        "uniqueId": "0a0bb6e4bbd5be386ac139ccac3a9c474409d1e5_43_55_58_70_43_55",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 2,
                "covered": 8
            },
            "BRANCH": {
                "missed": 1,
                "covered": 1
            },
            "LINE": {
                "missed": 1,
                "covered": 2
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic createFactory(minimumPriority RulePriority, warnDeprecated boolean, enableCompatibility boolean) : RuleSetFactory extracted from private loadRuleSetWithDeprecationWarnings(ruleSetXml String) : RuleSet in class net.sourceforge.pmd.RuleSetFactoryTest & moved to class net.sourceforge.pmd.RulesetsFactoryUtils",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/RuleSetFactoryTest.java",
                "startLine": 1102,
                "endLine": 1105,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/RuleSetFactoryTest.java",
                "startLine": 1102,
                "endLine": 1105,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/RuleSetFactoryTest.java",
                "startLine": 154,
                "endLine": 172,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private RuleSet loadRuleSetWithDeprecationWarnings(String ruleSetXml) throws RuleSetNotFoundException {\n        RuleSetFactory rsf = new RuleSetFactory(new ResourceLoader(), RulePriority.LOW, true, false);\n        return rsf.createRuleSet(createRuleSetReferenceId(ruleSetXml));\n    }",
        "filePathBefore": "pmd-core/src/test/java/net/sourceforge/pmd/RuleSetFactoryTest.java",
        "isPureRefactoring": true,
        "commitId": "05870c98cc05805d6272d12f5080afad3a14e2b6",
        "packageNameBefore": "net.sourceforge.pmd",
        "classNameBefore": "net.sourceforge.pmd.RuleSetFactoryTest",
        "methodNameBefore": "net.sourceforge.pmd.RuleSetFactoryTest#loadRuleSetWithDeprecationWarnings",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.AbstractRuleSetFactoryTest#createRuleSetReferenceId\n methodBody: protected static RuleSetReferenceId createRuleSetReferenceId(final String ruleSetXml) {\nreturn new RuleSetReferenceId(null){\n  @Override public InputStream getInputStream(  ResourceLoader resourceLoader) throws RuleSetNotFoundException {\n    try {\n      return new ByteArrayInputStream(ruleSetXml.getBytes(\"UTF-8\"));\n    }\n catch (    UnsupportedEncodingException e) {\n      return null;\n    }\n  }\n}\n;\n}\nmethodSignature: net.sourceforge.pmd.RuleSetFactoryTest#createRuleSetReferenceId\n methodBody: private static RuleSetReferenceId createRuleSetReferenceId(final String ruleSetXml) {\nreturn new RuleSetReferenceId(null){\n  @Override public InputStream getInputStream(  ResourceLoader resourceLoader) throws RuleSetNotFoundException {\n    try {\n      return new ByteArrayInputStream(ruleSetXml.getBytes(\"UTF-8\"));\n    }\n catch (    UnsupportedEncodingException e) {\n      return null;\n    }\n  }\n}\n;\n}\nmethodSignature: net.sourceforge.pmd.RuleSetFactory#createRuleSet\n methodBody: private RuleSet createRuleSet(RuleSetReferenceId ruleSetReferenceId, boolean withDeprecatedRuleReferences)\n            throws RuleSetNotFoundException {\nreturn parseRuleSetNode(ruleSetReferenceId,withDeprecatedRuleReferences);\n}",
        "classSignatureBefore": "public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest \npublic class RuleSetFactoryTest ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.RuleSetFactoryTest#loadRuleSetWithDeprecationWarnings"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.RuleSetFactoryTest"
        ],
        "classSignatureBeforeSet": [
            "public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest ",
            "public class RuleSetFactoryTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNotSame;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.junit.Test;\nimport org.junit.rules.ExpectedException;\n\nimport net.sourceforge.pmd.junit.JavaUtilLoggingRule;\nimport net.sourceforge.pmd.junit.LocaleRule;\nimport net.sourceforge.pmd.lang.DummyLanguageModule;\nimport net.sourceforge.pmd.lang.LanguageRegistry;\nimport net.sourceforge.pmd.lang.rule.MockRule;\nimport net.sourceforge.pmd.lang.rule.RuleReference;\nimport net.sourceforge.pmd.properties.PropertyDescriptor;\nimport net.sourceforge.pmd.util.ResourceLoader;\n\npublic class RuleSetFactoryTest {\n\n    @org.junit.Rule\n    public ExpectedException ex = ExpectedException.none();\n\n    @org.junit.Rule\n    public LocaleRule localeRule = LocaleRule.en();\n\n    @Test\n    public void testRuleSetFileName() throws RuleSetNotFoundException {\n        RuleSet rs = loadRuleSet(EMPTY_RULESET);\n        assertNull(\"RuleSet file name not expected\", rs.getFileName());\n\n        RuleSetFactory rsf = new RuleSetFactory();\n        rs = rsf.createRuleSet(\"net/sourceforge/pmd/TestRuleset1.xml\");\n        assertEquals(\"wrong RuleSet file name\", rs.getFileName(), \"net/sourceforge/pmd/TestRuleset1.xml\");\n    }\n\n    @Test\n    public void testNoRuleSetFileName() throws RuleSetNotFoundException {\n        RuleSet rs = loadRuleSet(EMPTY_RULESET);\n        assertNull(\"RuleSet file name not expected\", rs.getFileName());\n    }\n\n    @Test\n    public void testRefs() throws Exception {\n        RuleSetFactory rsf = new RuleSetFactory();\n        RuleSet rs = rsf.createRuleSet(\"net/sourceforge/pmd/TestRuleset1.xml\");\n        assertNotNull(rs.getRuleByName(\"TestRuleRef\"));\n    }\n\n    @Test\n    public void testExtendedReferences() throws Exception {\n        InputStream in = new ResourceLoader().loadClassPathResourceAsStream(\"net/sourceforge/pmd/rulesets/reference-ruleset.xml\");\n        assertNotNull(\"Test ruleset not found - can't continue with test!\", in);\n        in.close();\n\n        RuleSetFactory rsf = new RuleSetFactory();\n        RuleSets rs = rsf.createRuleSets(\"net/sourceforge/pmd/rulesets/reference-ruleset.xml\");\n        // added by referencing a complete ruleset (TestRuleset1.xml)\n        assertNotNull(rs.getRuleByName(\"MockRule1\"));\n        assertNotNull(rs.getRuleByName(\"MockRule2\"));\n        assertNotNull(rs.getRuleByName(\"MockRule3\"));\n        assertNotNull(rs.getRuleByName(\"TestRuleRef\"));\n\n        // added by specific reference\n        assertNotNull(rs.getRuleByName(\"TestRule\"));\n        // this is from TestRuleset2.xml, but not referenced\n        assertNull(rs.getRuleByName(\"TestRule2Ruleset2\"));\n\n        Rule mockRule3 = rs.getRuleByName(\"MockRule3\");\n        assertEquals(\"Overridden message\", mockRule3.getMessage());\n        assertEquals(2, mockRule3.getPriority().getPriority());\n\n        Rule mockRule2 = rs.getRuleByName(\"MockRule2\");\n        assertEquals(\"Just combine them!\", mockRule2.getMessage());\n        // assert that MockRule2 is only once added to the ruleset, so that it\n        // really\n        // overwrites the configuration inherited from TestRuleset1.xml\n        assertEquals(1, countRule(rs, \"MockRule2\"));\n\n        Rule mockRule1 = rs.getRuleByName(\"MockRule1\");\n        assertNotNull(mockRule1);\n        PropertyDescriptor<?> prop = mockRule1.getPropertyDescriptor(\"testIntProperty\");\n        Object property = mockRule1.getProperty(prop);\n        assertEquals(\"5\", String.valueOf(property));\n\n        // included from TestRuleset3.xml\n        assertNotNull(rs.getRuleByName(\"Ruleset3Rule2\"));\n        // excluded from TestRuleset3.xml\n        assertNull(rs.getRuleByName(\"Ruleset3Rule1\"));\n\n        // overridden to 5\n        Rule ruleset4Rule1 = rs.getRuleByName(\"Ruleset4Rule1\");\n        assertNotNull(ruleset4Rule1);\n        assertEquals(5, ruleset4Rule1.getPriority().getPriority());\n        assertEquals(1, countRule(rs, \"Ruleset4Rule1\"));\n        // priority overridden for whole TestRuleset4 group\n        Rule ruleset4Rule2 = rs.getRuleByName(\"Ruleset4Rule2\");\n        assertNotNull(ruleset4Rule2);\n        assertEquals(2, ruleset4Rule2.getPriority().getPriority());\n    }\n\n    private int countRule(RuleSets rs, String ruleName) {\n        int count = 0;\n        for (Rule r : rs.getAllRules()) {\n            if (ruleName.equals(r.getName())) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    @Test(expected = RuleSetNotFoundException.class)\n    public void testRuleSetNotFound() throws RuleSetNotFoundException {\n        RuleSetFactory rsf = new RuleSetFactory();\n        rsf.createRuleSet(\"fooooo\");\n    }\n\n    @Test\n    public void testCreateEmptyRuleSet() throws RuleSetNotFoundException {\n        RuleSet rs = loadRuleSet(EMPTY_RULESET);\n        assertEquals(\"test\", rs.getName());\n        assertEquals(0, rs.size());\n    }\n\n    @Test\n    public void testSingleRule() throws RuleSetNotFoundException {\n        RuleSet rs = loadRuleSet(SINGLE_RULE);\n        assertEquals(1, rs.size());\n        Rule r = rs.getRules().iterator().next();\n        assertEquals(\"MockRuleName\", r.getName());\n        assertEquals(\"net.sourceforge.pmd.lang.rule.MockRule\", r.getRuleClass());\n        assertEquals(\"avoid the mock rule\", r.getMessage());\n    }\n\n    @Test\n    public void testMultipleRules() throws RuleSetNotFoundException {\n        RuleSet rs = loadRuleSet(MULTIPLE_RULES);\n        assertEquals(2, rs.size());\n        Set<String> expected = new HashSet<>();\n        expected.add(\"MockRuleName1\");\n        expected.add(\"MockRuleName2\");\n        for (Rule rule : rs.getRules()) {\n            assertTrue(expected.contains(rule.getName()));\n        }\n    }\n\n    @Test\n    public void testSingleRuleWithPriority() throws RuleSetNotFoundException {\n        assertEquals(RulePriority.MEDIUM, loadFirstRule(PRIORITY).getPriority());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testProps() throws RuleSetNotFoundException {\n        Rule r = loadFirstRule(PROPERTIES);\n        assertEquals(\"bar\", r.getProperty((PropertyDescriptor<String>) r.getPropertyDescriptor(\"fooString\")));\n        assertEquals(new Integer(3), r.getProperty((PropertyDescriptor<Integer>) r.getPropertyDescriptor(\"fooInt\")));\n        assertTrue(r.getProperty((PropertyDescriptor<Boolean>) r.getPropertyDescriptor(\"fooBoolean\")));\n        assertEquals(3.0d, r.getProperty((PropertyDescriptor<Double>) r.getPropertyDescriptor(\"fooDouble\")), 0.05);\n        assertNull(r.getPropertyDescriptor(\"BuggleFish\"));\n        assertNotSame(r.getDescription().indexOf(\"testdesc2\"), -1);\n    }\n\n    @Test\n    public void testStringMultiPropertyDefaultDelimiter() throws Exception {\n        Rule r = loadFirstRule(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n<ruleset name=\\\"the ruleset\\\">\\n  <description>Desc</description>\\n\"\n                                   + \"     <rule name=\\\"myRule\\\" message=\\\"Do not place to this package. Move to \\n{0} package/s instead.\\\" \\n\"\n                                   + \"class=\\\"net.sourceforge.pmd.lang.rule.XPathRule\\\" language=\\\"dummy\\\">\\n\"\n                                   + \"         <description>Please move your class to the right folder(rest \\nfolder)</description>\\n\"\n                                   + \"         <priority>2</priority>\\n         <properties>\\n             <property name=\\\"packageRegEx\\\"\"\n                                   + \" value=\\\"com.aptsssss|com.abc\\\" \\ntype=\\\"List[String]\\\" \"\n                                   + \"description=\\\"valid packages\\\"/>\\n         </properties></rule></ruleset>\");\n        PropertyDescriptor<List<String>> prop = (PropertyDescriptor<List<String>>) r.getPropertyDescriptor(\"packageRegEx\");\n        List<String> values = r.getProperty(prop);\n        assertEquals(Arrays.asList(\"com.aptsssss\", \"com.abc\"), values);\n    }\n\n    @Test\n    public void testStringMultiPropertyDelimiter() throws Exception {\n        Rule r = loadFirstRule(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" + \"<ruleset name=\\\"test\\\">\\n \"\n                                   + \" <description>ruleset desc</description>\\n     \"\n                                   + \"<rule name=\\\"myRule\\\" message=\\\"Do not place to this package. Move to \\n{0} package/s\"\n                                   + \" instead.\\\" \\n\" + \"class=\\\"net.sourceforge.pmd.lang.rule.XPathRule\\\" language=\\\"dummy\\\">\\n\"\n                                   + \"         <description>Please move your class to the right folder(rest \\nfolder)</description>\\n\"\n                                   + \"         <priority>2</priority>\\n         <properties>\\n             <property name=\\\"packageRegEx\\\"\"\n                                   + \" value=\\\"com.aptsssss,com.abc\\\" \\ntype=\\\"List[String]\\\" delimiter=\\\",\\\" \"\n                                   + \"description=\\\"valid packages\\\"/>\\n\"\n                                   + \"         </properties></rule>\" + \"</ruleset>\");\n        PropertyDescriptor<List<String>> prop = (PropertyDescriptor<List<String>>) r.getPropertyDescriptor(\"packageRegEx\");\n        List<String> values = r.getProperty(prop);\n        assertEquals(Arrays.asList(\"com.aptsssss\", \"com.abc\"), values);\n    }\n\n    @Test\n    public void testRuleSetWithDeprecatedRule() throws Exception {\n        RuleSet rs = loadRuleSet(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" + \"<ruleset name=\\\"ruleset\\\">\\n\"\n                + \"  <description>ruleset desc</description>\\n\"\n                + \"     <rule deprecated=\\\"true\\\" ref=\\\"rulesets/dummy/basic.xml/DummyBasicMockRule\\\"/>\"\n                + \"</ruleset>\");\n        assertEquals(1, rs.getRules().size());\n        Rule rule = rs.getRuleByName(\"DummyBasicMockRule\");\n        assertNotNull(rule);\n    }\n\n    /**\n     * This is an example of a category (built-in) ruleset, which contains a rule, that has been renamed.\n     * This means: a rule definition for \"NewName\" and a rule reference \"OldName\", that is deprecated\n     * and exists for backwards compatibility.\n     *\n     * <p>When loading this ruleset at a whole, we shouldn't get a deprecation warning. The deprecated\n     * rule reference should be ignored, so at the end, we only have the new rule name in the ruleset.\n     * This is because the deprecated reference points to a rule in the same ruleset.\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testRuleSetWithDeprecatedButRenamedRule() throws Exception {\n        RuleSet rs = loadRuleSetWithDeprecationWarnings(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" + \"<ruleset name=\\\"test\\\">\\n\"\n                + \"  <description>ruleset desc</description>\\n\"\n                + \"     <rule deprecated=\\\"true\\\" ref=\\\"NewName\\\" name=\\\"OldName\\\"/>\"\n                + \"     <rule name=\\\"NewName\\\" message=\\\"m\\\" class=\\\"net.sourceforge.pmd.lang.rule.XPathRule\\\" language=\\\"dummy\\\">\"\n                + \"         <description>d</description>\\n\" + \"         <priority>2</priority>\\n\" + \"     </rule>\"\n                + \"</ruleset>\");\n        assertEquals(1, rs.getRules().size());\n        Rule rule = rs.getRuleByName(\"NewName\");\n        assertNotNull(rule);\n        assertNull(rs.getRuleByName(\"OldName\"));\n\n        assertTrue(logging.getLog().isEmpty());\n    }\n\n    /**\n     * This is an example of a custom user ruleset, that references a rule, that has been renamed.\n     * The user should get a deprecation warning.\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testRuleSetReferencesADeprecatedRenamedRule() throws Exception {\n        RuleSet rs = loadRuleSetWithDeprecationWarnings(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" + \"<ruleset name=\\\"test\\\">\\n\"\n                + \"  <description>ruleset desc</description>\\n\"\n                + \"     <rule ref=\\\"rulesets/dummy/basic.xml/OldNameOfDummyBasicMockRule\\\"/>\" + \"</ruleset>\");\n        assertEquals(1, rs.getRules().size());\n        Rule rule = rs.getRuleByName(\"OldNameOfDummyBasicMockRule\");\n        assertNotNull(rule);\n\n        assertEquals(1,\n            StringUtils.countMatches(logging.getLog(),\n                \"WARNING: Use Rule name rulesets/dummy/basic.xml/DummyBasicMockRule instead of the deprecated Rule name rulesets/dummy/basic.xml/OldNameOfDummyBasicMockRule.\"));\n    }\n\n    /**\n     * This is an example of a custom user ruleset, that references a complete (e.g. category) ruleset,\n     * that contains a renamed (deprecated) rule and two normal rules and one deprecated rule.\n     *\n     * <p>\n     * The user should not get a deprecation warning for the whole ruleset,\n     * since not all rules are deprecated in the referenced ruleset. Although the referenced ruleset contains\n     * a deprecated rule, there should be no warning about it, because all deprecated rules are ignored,\n     * if a whole ruleset is referenced.\n     *\n     * <p>\n     * In the end, we should get all non-deprecated rules of the referenced ruleset.\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testRuleSetReferencesRulesetWithADeprecatedRenamedRule() throws Exception {\n        RuleSet rs = loadRuleSetWithDeprecationWarnings(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" + \"<ruleset name=\\\"test\\\">\\n\"\n                + \"  <description>ruleset desc</description>\\n\"\n                + \"     <rule ref=\\\"rulesets/dummy/basic.xml\\\"/>\" + \"</ruleset>\");\n        assertEquals(2, rs.getRules().size());\n        assertNotNull(rs.getRuleByName(\"DummyBasicMockRule\"));\n        assertNotNull(rs.getRuleByName(\"SampleXPathRule\"));\n\n        assertTrue(logging.getLog().isEmpty());\n    }\n\n    /**\n     * This is an example of a custom user ruleset, that references a complete (e.g. category) ruleset,\n     * that contains a renamed (deprecated) rule and two normal rules and one deprecated rule. The deprecated\n     * rule is excluded.\n     *\n     * <p>\n     * The user should not get a deprecation warning for the whole ruleset,\n     * since not all rules are deprecated in the referenced ruleset. Since the deprecated rule is excluded,\n     * there should be no deprecation warning at all, although the deprecated ruleset would have been\n     * excluded by default (without explictly excluding it).\n     *\n     * <p>\n     * In the end, we should get all non-deprecated rules of the referenced ruleset.\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testRuleSetReferencesRulesetWithAExcludedDeprecatedRule() throws Exception {\n        RuleSet rs = loadRuleSetWithDeprecationWarnings(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" + \"<ruleset name=\\\"test\\\">\\n\"\n                + \"  <description>ruleset desc</description>\\n\"\n                + \"     <rule ref=\\\"rulesets/dummy/basic.xml\\\"><exclude name=\\\"DeprecatedRule\\\"/></rule>\" + \"</ruleset>\");\n        assertEquals(2, rs.getRules().size());\n        assertNotNull(rs.getRuleByName(\"DummyBasicMockRule\"));\n        assertNotNull(rs.getRuleByName(\"SampleXPathRule\"));\n\n        assertTrue(logging.getLog().isEmpty());\n    }\n\n    /**\n     * This is an example of a custom user ruleset, that references a complete (e.g. category) ruleset,\n     * that contains a renamed (deprecated) rule and two normal rules and one deprecated rule.\n     * There is a exclusion of a rule, that no longer exists.\n     *\n     * <p>\n     * The user should not get a deprecation warning for the whole ruleset,\n     * since not all rules are deprecated in the referenced ruleset.\n     * Since the rule to be excluded doesn't exist, there should be a warning about that.\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testRuleSetReferencesRulesetWithAExcludedNonExistingRule() throws Exception {\n        RuleSet rs = loadRuleSetWithDeprecationWarnings(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" + \"<ruleset name=\\\"test\\\">\\n\"\n                + \"  <description>ruleset desc</description>\\n\"\n                + \"     <rule ref=\\\"rulesets/dummy/basic.xml\\\"><exclude name=\\\"NonExistingRule\\\"/></rule>\" + \"</ruleset>\");\n        assertEquals(2, rs.getRules().size());\n        assertNotNull(rs.getRuleByName(\"DummyBasicMockRule\"));\n        assertNotNull(rs.getRuleByName(\"SampleXPathRule\"));\n\n        assertEquals(0,\n                StringUtils.countMatches(logging.getLog(),\n                    \"WARNING: Discontinue using Rule rulesets/dummy/basic.xml/DeprecatedRule as it is scheduled for removal from PMD.\"));\n        assertEquals(1,\n                StringUtils.countMatches(logging.getLog(),\n                    \"WARNING: Unable to exclude rules [NonExistingRule] from ruleset reference rulesets/dummy/basic.xml; perhaps the rule name is mispelled or the rule doesn't exist anymore?\"));\n    }\n\n    /**\n     * When a custom ruleset references a ruleset that only contains deprecated rules, then this ruleset itself is\n     * considered deprecated and the user should get a deprecation warning for the ruleset.\n     */\n    @Test\n    public void testRuleSetReferencesDeprecatedRuleset() throws Exception {\n        RuleSet rs = loadRuleSetWithDeprecationWarnings(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" + \"<ruleset name=\\\"test\\\">\\n\"\n                + \"  <description>ruleset desc</description>\\n\"\n                + \"     <rule ref=\\\"rulesets/dummy/deprecated.xml\\\" />\" + \"</ruleset>\");\n        assertEquals(2, rs.getRules().size());\n        assertNotNull(rs.getRuleByName(\"DummyBasicMockRule\"));\n        assertNotNull(rs.getRuleByName(\"SampleXPathRule\"));\n\n        assertEquals(1,\n                StringUtils.countMatches(logging.getLog(),\n                    \"WARNING: The RuleSet rulesets/dummy/deprecated.xml has been deprecated and will be removed in PMD\"));\n    }\n\n    /**\n     * When a custom ruleset references a ruleset that contains both rules and rule references, that are left\n     * for backwards compatibility, because the rules have been moved to a different ruleset, then there should be\n     * no warning about deprecation - since the deprecated rules are not used.\n     */\n    @Test\n    public void testRuleSetReferencesRulesetWithAMovedRule() throws Exception {\n        RuleSet rs = loadRuleSetWithDeprecationWarnings(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" + \"<ruleset name=\\\"test\\\">\\n\"\n                + \"  <description>ruleset desc</description>\\n\"\n                + \"     <rule ref=\\\"rulesets/dummy/basic2.xml\\\" />\" + \"</ruleset>\");\n        assertEquals(1, rs.getRules().size());\n        assertNotNull(rs.getRuleByName(\"DummyBasic2MockRule\"));\n\n        assertEquals(0,\n                StringUtils.countMatches(logging.getLog(),\n                    \"WARNING: Use Rule name rulesets/dummy/basic.xml/DummyBasicMockRule instead of the deprecated Rule name rulesets/dummy/basic2.xml/DummyBasicMockRule. PMD\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testXPath() throws RuleSetNotFoundException {\n        Rule r = loadFirstRule(XPATH);\n        PropertyDescriptor<String> xpathProperty = (PropertyDescriptor<String>) r.getPropertyDescriptor(\"xpath\");\n        assertNotNull(\"xpath property descriptor\", xpathProperty);\n        assertNotSame(r.getProperty(xpathProperty).indexOf(\" //Block \"), -1);\n    }\n\n    @Test\n    public void testFacadesOffByDefault() throws RuleSetNotFoundException {\n        Rule r = loadFirstRule(XPATH);\n        assertFalse(r.isDfa());\n    }\n\n    @Test\n    public void testDFAFlag() throws RuleSetNotFoundException {\n        assertTrue(loadFirstRule(DFA).isDfa());\n    }\n\n    @Test\n    public void testExternalReferenceOverride() throws RuleSetNotFoundException {\n        Rule r = loadFirstRule(REF_OVERRIDE);\n        assertEquals(\"TestNameOverride\", r.getName());\n        assertEquals(\"Test message override\", r.getMessage());\n        assertEquals(\"Test description override\", r.getDescription());\n        assertEquals(\"Test that both example are stored\", 2, r.getExamples().size());\n        assertEquals(\"Test example override\", r.getExamples().get(1));\n        assertEquals(RulePriority.MEDIUM, r.getPriority());\n        PropertyDescriptor<?> test2Descriptor = r.getPropertyDescriptor(\"test2\");\n        assertNotNull(\"test2 descriptor\", test2Descriptor);\n        assertEquals(\"override2\", r.getProperty(test2Descriptor));\n        PropertyDescriptor<?> test3Descriptor = r.getPropertyDescriptor(\"test3\");\n        assertNotNull(\"test3 descriptor\", test3Descriptor);\n        assertEquals(\"override3\", r.getProperty(test3Descriptor));\n    }\n\n    @Test\n    public void testExternalReferenceOverrideNonExistent() throws RuleSetNotFoundException {\n        ex.expect(IllegalArgumentException.class);\n        ex.expectMessage(\"Cannot set non-existent property 'test4' on Rule TestNameOverride\");\n        loadFirstRule(REF_OVERRIDE_NONEXISTENT);\n    }\n\n    @Test\n    public void testReferenceInternalToInternal() throws RuleSetNotFoundException {\n        RuleSet ruleSet = loadRuleSet(REF_INTERNAL_TO_INTERNAL);\n\n        Rule rule = ruleSet.getRuleByName(\"MockRuleName\");\n        assertNotNull(\"Could not find Rule MockRuleName\", rule);\n\n        Rule ruleRef = ruleSet.getRuleByName(\"MockRuleNameRef\");\n        assertNotNull(\"Could not find Rule MockRuleNameRef\", ruleRef);\n    }\n\n    @Test\n    public void testReferenceInternalToInternalChain() throws RuleSetNotFoundException {\n        RuleSet ruleSet = loadRuleSet(REF_INTERNAL_TO_INTERNAL_CHAIN);\n\n        Rule rule = ruleSet.getRuleByName(\"MockRuleName\");\n        assertNotNull(\"Could not find Rule MockRuleName\", rule);\n\n        Rule ruleRef = ruleSet.getRuleByName(\"MockRuleNameRef\");\n        assertNotNull(\"Could not find Rule MockRuleNameRef\", ruleRef);\n\n        Rule ruleRefRef = ruleSet.getRuleByName(\"MockRuleNameRefRef\");\n        assertNotNull(\"Could not find Rule MockRuleNameRefRef\", ruleRefRef);\n    }\n\n    @Test\n    public void testReferenceInternalToExternal() throws RuleSetNotFoundException {\n        RuleSet ruleSet = loadRuleSet(REF_INTERNAL_TO_EXTERNAL);\n\n        Rule rule = ruleSet.getRuleByName(\"ExternalRefRuleName\");\n        assertNotNull(\"Could not find Rule ExternalRefRuleName\", rule);\n\n        Rule ruleRef = ruleSet.getRuleByName(\"ExternalRefRuleNameRef\");\n        assertNotNull(\"Could not find Rule ExternalRefRuleNameRef\", ruleRef);\n    }\n\n    @Test\n    public void testReferenceInternalToExternalChain() throws RuleSetNotFoundException {\n        RuleSet ruleSet = loadRuleSet(REF_INTERNAL_TO_EXTERNAL_CHAIN);\n\n        Rule rule = ruleSet.getRuleByName(\"ExternalRefRuleName\");\n        assertNotNull(\"Could not find Rule ExternalRefRuleName\", rule);\n\n        Rule ruleRef = ruleSet.getRuleByName(\"ExternalRefRuleNameRef\");\n        assertNotNull(\"Could not find Rule ExternalRefRuleNameRef\", ruleRef);\n\n        Rule ruleRefRef = ruleSet.getRuleByName(\"ExternalRefRuleNameRefRef\");\n        assertNotNull(\"Could not find Rule ExternalRefRuleNameRefRef\", ruleRefRef);\n    }\n\n    @Test\n    public void testReferencePriority() throws RuleSetNotFoundException {\n        ResourceLoader rl = new ResourceLoader();\n        RuleSetFactory rsf = new RuleSetFactory(rl, RulePriority.LOW, false, true);\n\n        RuleSet ruleSet = rsf.createRuleSet(createRuleSetReferenceId(REF_INTERNAL_TO_INTERNAL_CHAIN));\n        assertEquals(\"Number of Rules\", 3, ruleSet.getRules().size());\n        assertNotNull(ruleSet.getRuleByName(\"MockRuleName\"));\n        assertNotNull(ruleSet.getRuleByName(\"MockRuleNameRef\"));\n        assertNotNull(ruleSet.getRuleByName(\"MockRuleNameRefRef\"));\n\n        rsf = new RuleSetFactory(rl, RulePriority.MEDIUM_HIGH, false, true);\n        ruleSet = rsf.createRuleSet(createRuleSetReferenceId(REF_INTERNAL_TO_INTERNAL_CHAIN));\n        assertEquals(\"Number of Rules\", 2, ruleSet.getRules().size());\n        assertNotNull(ruleSet.getRuleByName(\"MockRuleNameRef\"));\n        assertNotNull(ruleSet.getRuleByName(\"MockRuleNameRefRef\"));\n\n        rsf = new RuleSetFactory(rl, RulePriority.HIGH, false, true);\n        ruleSet = rsf.createRuleSet(createRuleSetReferenceId(REF_INTERNAL_TO_INTERNAL_CHAIN));\n        assertEquals(\"Number of Rules\", 1, ruleSet.getRules().size());\n        assertNotNull(ruleSet.getRuleByName(\"MockRuleNameRefRef\"));\n\n        rsf = new RuleSetFactory(rl, RulePriority.LOW, false, true);\n        ruleSet = rsf.createRuleSet(createRuleSetReferenceId(REF_INTERNAL_TO_EXTERNAL_CHAIN));\n        assertEquals(\"Number of Rules\", 3, ruleSet.getRules().size());\n        assertNotNull(ruleSet.getRuleByName(\"ExternalRefRuleName\"));\n        assertNotNull(ruleSet.getRuleByName(\"ExternalRefRuleNameRef\"));\n        assertNotNull(ruleSet.getRuleByName(\"ExternalRefRuleNameRefRef\"));\n\n        rsf = new RuleSetFactory(rl, RulePriority.MEDIUM_HIGH, false, true);\n        ruleSet = rsf.createRuleSet(createRuleSetReferenceId(REF_INTERNAL_TO_EXTERNAL_CHAIN));\n        assertEquals(\"Number of Rules\", 2, ruleSet.getRules().size());\n        assertNotNull(ruleSet.getRuleByName(\"ExternalRefRuleNameRef\"));\n        assertNotNull(ruleSet.getRuleByName(\"ExternalRefRuleNameRefRef\"));\n\n        rsf = new RuleSetFactory(rl, RulePriority.HIGH, false, true);\n        ruleSet = rsf.createRuleSet(createRuleSetReferenceId(REF_INTERNAL_TO_EXTERNAL_CHAIN));\n        assertEquals(\"Number of Rules\", 1, ruleSet.getRules().size());\n        assertNotNull(ruleSet.getRuleByName(\"ExternalRefRuleNameRefRef\"));\n    }\n\n    @Test\n    public void testOverridePriorityLoadWithMinimum() throws RuleSetNotFoundException {\n        RuleSetFactory rsf = new RuleSetFactory(new ResourceLoader(), RulePriority.MEDIUM_LOW, true, true);\n        RuleSet ruleset = rsf.createRuleSet(\"net/sourceforge/pmd/rulesets/ruleset-minimum-priority.xml\");\n        // only one rule should remain, since we filter out the other rule by minimum priority\n        assertEquals(\"Number of Rules\", 1, ruleset.getRules().size());\n\n        // Priority is overridden and applied, rule is missing\n        assertNull(ruleset.getRuleByName(\"DummyBasicMockRule\"));\n\n        // this is the remaining rule\n        assertNotNull(ruleset.getRuleByName(\"SampleXPathRule\"));\n\n        // now, load with default minimum priority\n        rsf = new RuleSetFactory();\n        ruleset = rsf.createRuleSet(\"net/sourceforge/pmd/rulesets/ruleset-minimum-priority.xml\");\n        assertEquals(\"Number of Rules\", 2, ruleset.getRules().size());\n        Rule dummyBasicMockRule = ruleset.getRuleByName(\"DummyBasicMockRule\");\n        assertEquals(\"Wrong Priority\", RulePriority.LOW, dummyBasicMockRule.getPriority());\n    }\n\n    @Test\n    public void testExcludeWithMinimumPriority() throws RuleSetNotFoundException {\n        RuleSetFactory rsf = new RuleSetFactory(new ResourceLoader(), RulePriority.HIGH, true, true);\n        RuleSet ruleset = rsf.createRuleSet(\"net/sourceforge/pmd/rulesets/ruleset-minimum-priority-exclusion.xml\");\n        // no rules should be loaded\n        assertEquals(\"Number of Rules\", 0, ruleset.getRules().size());\n\n        // now, load with default minimum priority\n        rsf = new RuleSetFactory();\n        ruleset = rsf.createRuleSet(\"net/sourceforge/pmd/rulesets/ruleset-minimum-priority-exclusion.xml\");\n        // only one rule, we have excluded one...\n        assertEquals(\"Number of Rules\", 1, ruleset.getRules().size());\n        // rule is excluded\n        assertNull(ruleset.getRuleByName(\"DummyBasicMockRule\"));\n        // this is the remaining rule\n        assertNotNull(ruleset.getRuleByName(\"SampleXPathRule\"));\n    }\n\n    @Test\n    public void testOverrideMessage() throws RuleSetNotFoundException {\n        Rule r = loadFirstRule(REF_OVERRIDE_ORIGINAL_NAME);\n        assertEquals(\"TestMessageOverride\", r.getMessage());\n    }\n\n    @Test\n    public void testOverrideMessageOneElem() throws RuleSetNotFoundException {\n        Rule r = loadFirstRule(REF_OVERRIDE_ORIGINAL_NAME_ONE_ELEM);\n        assertEquals(\"TestMessageOverride\", r.getMessage());\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testIncorrectExternalRef() throws IllegalArgumentException, RuleSetNotFoundException {\n        loadFirstRule(REF_MISPELLED_XREF);\n    }\n\n    @Test\n    public void testSetPriority() throws RuleSetNotFoundException {\n        ResourceLoader rl = new ResourceLoader();\n        RuleSetFactory rsf = new RuleSetFactory(rl, RulePriority.MEDIUM_HIGH, false, true);\n        assertEquals(0, rsf.createRuleSet(createRuleSetReferenceId(SINGLE_RULE)).size());\n        rsf = new RuleSetFactory(rl, RulePriority.MEDIUM_LOW, false, true);\n        assertEquals(1, rsf.createRuleSet(createRuleSetReferenceId(SINGLE_RULE)).size());\n    }\n\n    @Test\n    public void testLanguage() throws RuleSetNotFoundException {\n        Rule r = loadFirstRule(LANGUAGE);\n        assertEquals(LanguageRegistry.getLanguage(DummyLanguageModule.NAME), r.getLanguage());\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testIncorrectLanguage() throws RuleSetNotFoundException {\n        loadFirstRule(INCORRECT_LANGUAGE);\n    }\n\n    @Test\n    public void testMinimumLanugageVersion() throws RuleSetNotFoundException {\n        Rule r = loadFirstRule(MINIMUM_LANGUAGE_VERSION);\n        assertEquals(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion(\"1.4\"),\n                r.getMinimumLanguageVersion());\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testIncorrectMinimumLanugageVersion() throws RuleSetNotFoundException {\n        loadFirstRule(INCORRECT_MINIMUM_LANGUAGE_VERSION);\n    }\n\n    @Test\n    public void testMaximumLanugageVersion() throws RuleSetNotFoundException {\n        Rule r = loadFirstRule(MAXIMUM_LANGUAGE_VERSION);\n        assertEquals(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion(\"1.7\"),\n                r.getMaximumLanguageVersion());\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testIncorrectMaximumLanugageVersion() throws RuleSetNotFoundException {\n        loadFirstRule(INCORRECT_MAXIMUM_LANGUAGE_VERSION);\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testInvertedMinimumMaximumLanugageVersions() throws RuleSetNotFoundException {\n        loadFirstRule(INVERTED_MINIMUM_MAXIMUM_LANGUAGE_VERSIONS);\n    }\n\n    @Test\n    public void testDirectDeprecatedRule() throws RuleSetNotFoundException {\n        Rule r = loadFirstRule(DIRECT_DEPRECATED_RULE);\n        assertNotNull(\"Direct Deprecated Rule\", r);\n        assertTrue(r.isDeprecated());\n    }\n\n    @Test\n    public void testReferenceToDeprecatedRule() throws RuleSetNotFoundException {\n        Rule r = loadFirstRule(REFERENCE_TO_DEPRECATED_RULE);\n        assertNotNull(\"Reference to Deprecated Rule\", r);\n        assertTrue(\"Rule Reference\", r instanceof RuleReference);\n        assertFalse(\"Not deprecated\", r.isDeprecated());\n        assertTrue(\"Original Rule Deprecated\", ((RuleReference) r).getRule().isDeprecated());\n        assertEquals(\"Rule name\", r.getName(), DEPRECATED_RULE_NAME);\n    }\n\n    @Test\n    public void testRuleSetReferenceWithDeprecatedRule() throws RuleSetNotFoundException {\n        RuleSet ruleSet = loadRuleSet(REFERENCE_TO_RULESET_WITH_DEPRECATED_RULE);\n        assertNotNull(\"RuleSet\", ruleSet);\n        assertFalse(\"RuleSet empty\", ruleSet.getRules().isEmpty());\n        // No deprecated Rules should be loaded when loading an entire RuleSet\n        // by reference - unless it contains only deprecated rules - then all rules would be added\n        Rule r = ruleSet.getRuleByName(DEPRECATED_RULE_NAME);\n        assertNull(\"Deprecated Rule Reference\", r);\n        for (Rule rule : ruleSet.getRules()) {\n            assertFalse(\"Rule not deprecated\", rule.isDeprecated());\n        }\n    }\n\n    @Test\n    public void testDeprecatedRuleSetReference() throws RuleSetNotFoundException {\n        RuleSetFactory ruleSetFactory = new RuleSetFactory();\n        RuleSet ruleSet = ruleSetFactory.createRuleSet(\"net/sourceforge/pmd/rulesets/ruleset-deprecated.xml\");\n        assertEquals(2, ruleSet.getRules().size());\n    }\n\n    @Test\n    public void testExternalReferences() throws RuleSetNotFoundException {\n        RuleSet rs = loadRuleSet(EXTERNAL_REFERENCE_RULE_SET);\n        assertEquals(1, rs.size());\n        assertEquals(MockRule.class.getName(), rs.getRuleByName(\"MockRule\").getRuleClass());\n    }\n\n    @Test\n    public void testIncludeExcludePatterns() throws RuleSetNotFoundException {\n        RuleSet ruleSet = loadRuleSet(INCLUDE_EXCLUDE_RULESET);\n\n        assertNotNull(\"Include patterns\", ruleSet.getIncludePatterns());\n        assertEquals(\"Include patterns size\", 2, ruleSet.getIncludePatterns().size());\n        assertEquals(\"Include pattern #1\", \"include1\", ruleSet.getIncludePatterns().get(0));\n        assertEquals(\"Include pattern #2\", \"include2\", ruleSet.getIncludePatterns().get(1));\n\n        assertNotNull(\"Exclude patterns\", ruleSet.getExcludePatterns());\n        assertEquals(\"Exclude patterns size\", 3, ruleSet.getExcludePatterns().size());\n        assertEquals(\"Exclude pattern #1\", \"exclude1\", ruleSet.getExcludePatterns().get(0));\n        assertEquals(\"Exclude pattern #2\", \"exclude2\", ruleSet.getExcludePatterns().get(1));\n        assertEquals(\"Exclude pattern #3\", \"exclude3\", ruleSet.getExcludePatterns().get(2));\n    }\n\n    /**\n     * Rule reference can't be resolved - ref is used instead of class and the\n     * class is old (pmd 4.3 and not pmd 5).\n     *\n     * @throws Exception\n     *             any error\n     */\n    @Test(expected = RuleSetNotFoundException.class)\n    public void testBug1202() throws Exception {\n        RuleSetReferenceId ref = createRuleSetReferenceId(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" + \"<ruleset>\\n\"\n                + \"  <rule ref=\\\"net.sourceforge.pmd.rules.XPathRule\\\">\\n\" + \"    <priority>1</priority>\\n\"\n                + \"    <properties>\\n\" + \"      <property name=\\\"xpath\\\" value=\\\"//TypeDeclaration\\\" />\\n\"\n                + \"      <property name=\\\"message\\\" value=\\\"Foo\\\" />\\n\" + \"    </properties>\\n\" + \"  </rule>\\n\"\n                + \"</ruleset>\\n\");\n        RuleSetFactory ruleSetFactory = new RuleSetFactory();\n        ruleSetFactory.createRuleSet(ref);\n    }\n\n    /**\n     * See https://sourceforge.net/p/pmd/bugs/1225/\n     *\n     * @throws Exception\n     *             any error\n     */\n    @Test\n    public void testEmptyRuleSetFile() throws Exception {\n        RuleSetReferenceId ref = createRuleSetReferenceId(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" + \"\\n\"\n                + \"<ruleset name=\\\"Custom ruleset\\\" xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                + \"    xmlns:xsi=\\\"http:www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                + \"    <description>PMD Ruleset.</description>\\n\" + \"\\n\"\n                + \"    <exclude-pattern>.*Test.*</exclude-pattern>\\n\" + \"\\n\" + \"</ruleset>\\n\");\n        RuleSetFactory ruleSetFactory = new RuleSetFactory();\n        RuleSet ruleset = ruleSetFactory.createRuleSet(ref);\n        assertEquals(0, ruleset.getRules().size());\n    }\n\n    /**\n     * See https://github.com/pmd/pmd/issues/782\n     * Empty ruleset should be interpreted as deprecated.\n     *\n     * @throws Exception\n     *             any error\n     */\n    @Test\n    public void testEmptyRuleSetReferencedShouldNotBeDeprecated() throws Exception {\n        RuleSetReferenceId ref = createRuleSetReferenceId(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" + \"\\n\"\n                + \"<ruleset name=\\\"Custom ruleset\\\" xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                + \"    xmlns:xsi=\\\"http:www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                + \"    <description>Ruleset which references a empty ruleset</description>\\n\" + \"\\n\"\n                + \"    <rule ref=\\\"rulesets/dummy/empty-ruleset.xml\\\" />\\n\"\n                + \"</ruleset>\\n\");\n        RuleSetFactory ruleSetFactory = new RuleSetFactory(new ResourceLoader(), RulePriority.LOW, true, true);\n        RuleSet ruleset = ruleSetFactory.createRuleSet(ref);\n        assertEquals(0, ruleset.getRules().size());\n\n        assertTrue(logging.getLog().isEmpty());\n    }\n\n    /**\n     * See https://sourceforge.net/p/pmd/bugs/1231/\n     *\n     * @throws Exception\n     *             any error\n     */\n    @Test(expected = IllegalArgumentException.class)\n    public void testWrongRuleNameReferenced() throws Exception {\n        RuleSetReferenceId ref = createRuleSetReferenceId(\"<?xml version=\\\"1.0\\\"?>\\n\"\n                + \"<ruleset name=\\\"Custom ruleset for tests\\\"\\n\"\n                + \"    xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                + \"    xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                + \"  <description>Custom ruleset for tests</description>\\n\"\n                + \"  <rule ref=\\\"net/sourceforge/pmd/TestRuleset1.xml/ThisRuleDoesNotExist\\\"/>\\n\" + \"</ruleset>\\n\");\n        RuleSetFactory ruleSetFactory = new RuleSetFactory();\n        ruleSetFactory.createRuleSet(ref);\n    }\n\n    /**\n     * Unit test for #1312 see https://sourceforge.net/p/pmd/bugs/1312/\n     *\n     * @throws Exception\n     *             any error\n     */\n    @Test\n    public void testRuleReferenceWithNameOverridden() throws Exception {\n        RuleSetReferenceId ref = createRuleSetReferenceId(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\"\n                + \"<ruleset xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                + \"         xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                + \"         name=\\\"pmd-eclipse\\\"\\n\"\n                + \"         xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                + \"   <description>PMD Plugin preferences rule set</description>\\n\" + \"\\n\"\n                + \"<rule name=\\\"OverriddenDummyBasicMockRule\\\"\\n\"\n                + \"    ref=\\\"rulesets/dummy/basic.xml/DummyBasicMockRule\\\">\\n\" + \"</rule>\\n\" + \"\\n\" + \"</ruleset>\");\n        RuleSetFactory ruleSetFactory = new RuleSetFactory();\n        RuleSet rs = ruleSetFactory.createRuleSet(ref);\n\n        Rule r = rs.getRules().toArray(new Rule[1])[0];\n        assertEquals(\"OverriddenDummyBasicMockRule\", r.getName());\n        RuleReference ruleRef = (RuleReference) r;\n        assertEquals(\"DummyBasicMockRule\", ruleRef.getRule().getName());\n    }\n\n    /**\n     * See https://sourceforge.net/p/pmd/bugs/1231/\n     *\n     * <p>See https://github.com/pmd/pmd/issues/1978 - with that, it should not be an error anymore.\n     *\n     * @throws Exception\n     *             any error\n     */\n    @Test\n    public void testWrongRuleNameExcluded() throws Exception {\n        RuleSetReferenceId ref = createRuleSetReferenceId(\n                \"<?xml version=\\\"1.0\\\"?>\\n\" + \"<ruleset name=\\\"Custom ruleset for tests\\\"\\n\"\n                        + \"    xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                        + \"    xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                        + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                        + \"  <description>Custom ruleset for tests</description>\\n\"\n                        + \"  <rule ref=\\\"net/sourceforge/pmd/TestRuleset1.xml\\\">\\n\"\n                        + \"    <exclude name=\\\"ThisRuleDoesNotExist\\\"/>\\n\" + \"  </rule>\\n\" + \"</ruleset>\\n\");\n        RuleSetFactory ruleSetFactory = new RuleSetFactory();\n        RuleSet ruleset = ruleSetFactory.createRuleSet(ref);\n        assertEquals(4, ruleset.getRules().size());\n    }\n\n    /**\n     * This unit test manifests the current behavior - which might change in the\n     * future. See #1537.\n     *\n     * Currently, if a ruleset is imported twice, the excludes of the first\n     * import are ignored. Duplicated rules are silently ignored.\n     *\n     * @throws Exception\n     *             any error\n     * @see <a href=\"https://sourceforge.net/p/pmd/bugs/1537/\">#1537 Implement\n     *      strict ruleset parsing</a>\n     * @see <a href=\n     *      \"http://stackoverflow.com/questions/40299075/custom-pmd-ruleset-not-working\">stackoverflow\n     *      - custom ruleset not working</a>\n     */\n    @Test\n    public void testExcludeAndImportTwice() throws Exception {\n        RuleSetReferenceId ref1 = createRuleSetReferenceId(\n                \"<?xml version=\\\"1.0\\\"?>\\n\" + \"<ruleset name=\\\"Custom ruleset for tests\\\"\\n\"\n                        + \"    xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                        + \"    xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                        + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                        + \"  <description>Custom ruleset for tests</description>\\n\"\n                        + \"  <rule ref=\\\"rulesets/dummy/basic.xml\\\">\\n\" + \"    <exclude name=\\\"DummyBasicMockRule\\\"/>\\n\"\n                        + \"  </rule>\\n\" + \"</ruleset>\\n\");\n        RuleSetFactory ruleSetFactory = new RuleSetFactory();\n        RuleSet ruleset = ruleSetFactory.createRuleSet(ref1);\n        assertNull(ruleset.getRuleByName(\"DummyBasicMockRule\"));\n\n        RuleSetReferenceId ref2 = createRuleSetReferenceId(\n                \"<?xml version=\\\"1.0\\\"?>\\n\" + \"<ruleset name=\\\"Custom ruleset for tests\\\"\\n\"\n                        + \"    xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                        + \"    xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                        + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                        + \"  <description>Custom ruleset for tests</description>\\n\"\n                        + \"  <rule ref=\\\"rulesets/dummy/basic.xml\\\">\\n\" + \"    <exclude name=\\\"DummyBasicMockRule\\\"/>\\n\"\n                        + \"  </rule>\\n\" + \"  <rule ref=\\\"rulesets/dummy/basic.xml\\\"/>\\n\" + \"</ruleset>\\n\");\n        RuleSetFactory ruleSetFactory2 = new RuleSetFactory();\n        RuleSet ruleset2 = ruleSetFactory2.createRuleSet(ref2);\n        assertNotNull(ruleset2.getRuleByName(\"DummyBasicMockRule\"));\n\n        RuleSetReferenceId ref3 = createRuleSetReferenceId(\n                \"<?xml version=\\\"1.0\\\"?>\\n\" + \"<ruleset name=\\\"Custom ruleset for tests\\\"\\n\"\n                        + \"    xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                        + \"    xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                        + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                        + \"  <description>Custom ruleset for tests</description>\\n\"\n                        + \"  <rule ref=\\\"rulesets/dummy/basic.xml\\\"/>\\n\" + \"  <rule ref=\\\"rulesets/dummy/basic.xml\\\">\\n\"\n                        + \"    <exclude name=\\\"DummyBasicMockRule\\\"/>\\n\" + \"  </rule>\\n\" + \"</ruleset>\\n\");\n        RuleSetFactory ruleSetFactory3 = new RuleSetFactory();\n        RuleSet ruleset3 = ruleSetFactory3.createRuleSet(ref3);\n        assertNotNull(ruleset3.getRuleByName(\"DummyBasicMockRule\"));\n    }\n\n    @org.junit.Rule\n    public JavaUtilLoggingRule logging = new JavaUtilLoggingRule(RuleSetFactory.class.getName());\n\n    @Test\n    public void testMissingRuleSetNameIsWarning() throws Exception {\n        RuleSetReferenceId ref = createRuleSetReferenceId(\n                \"<?xml version=\\\"1.0\\\"?>\\n\" + \"<ruleset \\n\"\n                        + \"    xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                        + \"    xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                        + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                        + \"  <description>Custom ruleset for tests</description>\\n\"\n                        + \"  <rule ref=\\\"rulesets/dummy/basic.xml\\\"/>\\n\"\n                        + \"  </ruleset>\\n\");\n        RuleSetFactory ruleSetFactory = new RuleSetFactory();\n        ruleSetFactory.createRuleSet(ref);\n\n        assertTrue(logging.getLog().contains(\"RuleSet name is missing.\"));\n    }\n\n    @Test\n    public void testMissingRuleSetDescriptionIsWarning() throws Exception {\n        RuleSetReferenceId ref = createRuleSetReferenceId(\n                \"<?xml version=\\\"1.0\\\"?>\\n\" + \"<ruleset name=\\\"then name\\\"\\n\"\n                        + \"    xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                        + \"    xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                        + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                        + \"  <rule ref=\\\"rulesets/dummy/basic.xml\\\"/>\\n\"\n                        + \"  </ruleset>\\n\");\n        RuleSetFactory ruleSetFactory = new RuleSetFactory();\n        ruleSetFactory.createRuleSet(ref);\n        assertTrue(logging.getLog().contains(\"RuleSet description is missing.\"));\n    }\n\n    private static final String REF_OVERRIDE_ORIGINAL_NAME = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL\n            + \"<ruleset name=\\\"test\\\">\" + PMD.EOL + \" <description>testdesc</description>\" + PMD.EOL + \" <rule \"\n            + PMD.EOL + \"  ref=\\\"net/sourceforge/pmd/TestRuleset1.xml/MockRule1\\\" message=\\\"TestMessageOverride\\\"> \"\n            + PMD.EOL + \" </rule>\" + PMD.EOL + \"</ruleset>\";\n\n    private static final String REF_MISPELLED_XREF = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL + \"<ruleset name=\\\"test\\\">\"\n            + PMD.EOL + \" <description>testdesc</description>\" + PMD.EOL + \" <rule \" + PMD.EOL\n            + \"  ref=\\\"net/sourceforge/pmd/TestRuleset1.xml/FooMockRule1\\\"> \" + PMD.EOL + \" </rule>\" + PMD.EOL\n            + \"</ruleset>\";\n\n    private static final String REF_OVERRIDE_ORIGINAL_NAME_ONE_ELEM = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL\n            + \"<ruleset name=\\\"test\\\">\" + PMD.EOL + \" <description>testdesc</description>\" + PMD.EOL\n            + \" <rule ref=\\\"net/sourceforge/pmd/TestRuleset1.xml/MockRule1\\\" message=\\\"TestMessageOverride\\\"/> \"\n            + PMD.EOL + \"</ruleset>\";\n\n    private static final String REF_OVERRIDE = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL + \"<ruleset name=\\\"test\\\">\" + PMD.EOL\n            + \" <description>testdesc</description>\" + PMD.EOL + \" <rule \" + PMD.EOL\n            + \"  ref=\\\"net/sourceforge/pmd/TestRuleset1.xml/MockRule4\\\" \" + PMD.EOL + \"  name=\\\"TestNameOverride\\\" \"\n            + PMD.EOL + \"  message=\\\"Test message override\\\"> \" + PMD.EOL\n            + \"  <description>Test description override</description>\" + PMD.EOL\n            + \"  <example>Test example override</example>\" + PMD.EOL + \"  <priority>3</priority>\" + PMD.EOL\n            + \"  <properties>\" + PMD.EOL\n            + \"   <property name=\\\"test2\\\" description=\\\"test2\\\" type=\\\"String\\\" value=\\\"override2\\\"/>\" + PMD.EOL\n            + \"   <property name=\\\"test3\\\" type=\\\"String\\\" description=\\\"test3\\\"><value>override3</value></property>\"\n            // + PMD.EOL + \"   <property name=\\\"test4\\\" description=\\\"test4\\\" type=\\\"String\\\" value=\\\"new property\\\"/>\" // Nonsense\n            + PMD.EOL + \"  </properties>\" + PMD.EOL + \" </rule>\" + PMD.EOL + \"</ruleset>\";\n\n    private static final String REF_OVERRIDE_NONEXISTENT = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL + \"<ruleset name=\\\"test\\\">\" + PMD.EOL\n                                                           + \" <description>testdesc</description>\" + PMD.EOL + \" <rule \" + PMD.EOL\n                                                           + \"  ref=\\\"net/sourceforge/pmd/TestRuleset1.xml/MockRule4\\\" \" + PMD.EOL + \"  name=\\\"TestNameOverride\\\" \"\n                                                           + PMD.EOL + \"  message=\\\"Test message override\\\"> \" + PMD.EOL\n                                                           + \"  <description>Test description override</description>\" + PMD.EOL\n                                                           + \"  <example>Test example override</example>\" + PMD.EOL + \"  <priority>3</priority>\" + PMD.EOL\n                                                           + \"  <properties>\" + PMD.EOL\n                                                           + \"   <property name=\\\"test4\\\" description=\\\"test4\\\" type=\\\"String\\\" value=\\\"new property\\\"/>\" + PMD.EOL // inexistent property\n                                                           + \"  </properties>\" + PMD.EOL + \" </rule>\" + PMD.EOL + \"</ruleset>\";\n    \n    private static final String REF_INTERNAL_TO_INTERNAL = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL\n            + \"<ruleset name=\\\"test\\\">\" + PMD.EOL + \" <description>testdesc</description>\" + PMD.EOL + \"<rule \"\n            + PMD.EOL + \"name=\\\"MockRuleName\\\" \" + PMD.EOL + \"message=\\\"avoid the mock rule\\\" \" + PMD.EOL\n            + \"class=\\\"net.sourceforge.pmd.lang.rule.MockRule\\\">\" + PMD.EOL + \"</rule>\"\n            + \" <rule ref=\\\"MockRuleName\\\" name=\\\"MockRuleNameRef\\\"/> \" + PMD.EOL + \"</ruleset>\";\n\n    private static final String REF_INTERNAL_TO_INTERNAL_CHAIN = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL\n            + \"<ruleset name=\\\"test\\\">\" + PMD.EOL + \" <description>testdesc</description>\" + PMD.EOL + \"<rule \"\n            + PMD.EOL + \"name=\\\"MockRuleName\\\" \" + PMD.EOL + \"message=\\\"avoid the mock rule\\\" \" + PMD.EOL\n            + \"class=\\\"net.sourceforge.pmd.lang.rule.MockRule\\\">\" + PMD.EOL + \"</rule>\"\n            + \" <rule ref=\\\"MockRuleName\\\" name=\\\"MockRuleNameRef\\\"><priority>2</priority></rule> \" + PMD.EOL\n            + \" <rule ref=\\\"MockRuleNameRef\\\" name=\\\"MockRuleNameRefRef\\\"><priority>1</priority></rule> \" + PMD.EOL\n            + \"</ruleset>\";\n\n    private static final String REF_INTERNAL_TO_EXTERNAL = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL\n            + \"<ruleset name=\\\"test\\\">\" + PMD.EOL + \" <description>testdesc</description>\" + PMD.EOL + \"<rule \"\n            + PMD.EOL + \"name=\\\"ExternalRefRuleName\\\" \" + PMD.EOL\n            + \"ref=\\\"net/sourceforge/pmd/TestRuleset1.xml/MockRule1\\\"/>\" + PMD.EOL\n            + \" <rule ref=\\\"ExternalRefRuleName\\\" name=\\\"ExternalRefRuleNameRef\\\"/> \" + PMD.EOL + \"</ruleset>\";\n\n    private static final String REF_INTERNAL_TO_EXTERNAL_CHAIN = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL\n            + \"<ruleset name=\\\"test\\\">\" + PMD.EOL + \" <description>testdesc</description>\" + PMD.EOL + \"<rule \"\n            + PMD.EOL + \"name=\\\"ExternalRefRuleName\\\" \" + PMD.EOL\n            + \"ref=\\\"net/sourceforge/pmd/TestRuleset2.xml/TestRule\\\"/>\" + PMD.EOL\n            + \" <rule ref=\\\"ExternalRefRuleName\\\" name=\\\"ExternalRefRuleNameRef\\\"><priority>2</priority></rule> \"\n            + PMD.EOL\n            + \" <rule ref=\\\"ExternalRefRuleNameRef\\\" name=\\\"ExternalRefRuleNameRefRef\\\"><priority>1</priority></rule> \"\n            + PMD.EOL + \"</ruleset>\";\n\n    private static final String EMPTY_RULESET = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL + \"<ruleset name=\\\"test\\\">\"\n            + PMD.EOL + \"<description>testdesc</description>\" + PMD.EOL + \"</ruleset>\";\n\n    private static final String SINGLE_RULE = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL + \"<ruleset name=\\\"test\\\">\" + PMD.EOL\n            + \"<description>testdesc</description>\" + PMD.EOL + \"<rule \" + PMD.EOL + \"name=\\\"MockRuleName\\\" \" + PMD.EOL\n            + \"message=\\\"avoid the mock rule\\\" \" + PMD.EOL + \"class=\\\"net.sourceforge.pmd.lang.rule.MockRule\\\">\"\n            + \"<priority>3</priority>\" + PMD.EOL + \"</rule></ruleset>\";\n\n    private static final String MULTIPLE_RULES = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL + \"<ruleset name=\\\"test\\\">\"\n            + PMD.EOL + \"<description>testdesc</description>\" + PMD.EOL + \"<rule name=\\\"MockRuleName1\\\" \" + PMD.EOL\n            + \"message=\\\"avoid the mock rule\\\" \" + PMD.EOL + \"class=\\\"net.sourceforge.pmd.lang.rule.MockRule\\\">\"\n            + PMD.EOL + \"</rule>\" + PMD.EOL + \"<rule name=\\\"MockRuleName2\\\" \" + PMD.EOL\n            + \"message=\\\"avoid the mock rule\\\" \" + PMD.EOL + \"class=\\\"net.sourceforge.pmd.lang.rule.MockRule\\\">\"\n            + PMD.EOL + \"</rule></ruleset>\";\n\n    private static final String PROPERTIES = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL + \"<ruleset name=\\\"test\\\">\" + PMD.EOL\n            + \"<description>testdesc</description>\" + PMD.EOL + \"<rule name=\\\"MockRuleName\\\" \" + PMD.EOL\n            + \"message=\\\"avoid the mock rule\\\" \" + PMD.EOL + \"class=\\\"net.sourceforge.pmd.lang.rule.MockRule\\\">\"\n            + PMD.EOL + \"<description>testdesc2</description>\" + PMD.EOL + \"<properties>\" + PMD.EOL\n            + \"<property name=\\\"fooBoolean\\\" description=\\\"test\\\" type=\\\"Boolean\\\" value=\\\"true\\\" />\" + PMD.EOL\n            + \"<property name=\\\"fooChar\\\" description=\\\"test\\\" type=\\\"Character\\\" value=\\\"B\\\" />\" + PMD.EOL\n            + \"<property name=\\\"fooInt\\\" description=\\\"test\\\" type=\\\"Integer\\\" min=\\\"1\\\" max=\\\"10\\\" value=\\\"3\\\" />\"\n            + PMD.EOL\n            + \"<property name=\\\"fooFloat\\\" description=\\\"test\\\" type=\\\"Float\\\" min=\\\"1.0\\\" max=\\\"1.0\\\" value=\\\"1.0\\\"  />\"\n            + PMD.EOL\n            + \"<property name=\\\"fooDouble\\\" description=\\\"test\\\" type=\\\"Double\\\" min=\\\"1.0\\\" max=\\\"9.0\\\" value=\\\"3.0\\\"  />\"\n            + PMD.EOL + \"<property name=\\\"fooString\\\" description=\\\"test\\\" type=\\\"String\\\" value=\\\"bar\\\" />\" + PMD.EOL\n            + \"</properties>\" + PMD.EOL + \"</rule></ruleset>\";\n\n    private static final String XPATH = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL + \"<ruleset name=\\\"test\\\">\" + PMD.EOL\n            + \"<description>testdesc</description>\" + PMD.EOL + \"<rule name=\\\"MockRuleName\\\" \" + PMD.EOL\n            + \"message=\\\"avoid the mock rule\\\" \" + PMD.EOL + \"class=\\\"net.sourceforge.pmd.lang.rule.MockRule\\\">\"\n            + \"<priority>3</priority>\" + PMD.EOL + PMD.EOL + \"<description>testdesc2</description>\" + PMD.EOL\n            + \"<properties>\" + PMD.EOL + \"<property name=\\\"xpath\\\" description=\\\"test\\\" type=\\\"String\\\">\" + PMD.EOL\n            + \"<value>\" + PMD.EOL + \"<![CDATA[ //Block ]]>\" + PMD.EOL + \"</value>\" + PMD.EOL + \"</property>\" + PMD.EOL\n            + \"</properties>\" + PMD.EOL + \"</rule></ruleset>\";\n\n    private static final String PRIORITY = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL + \"<ruleset name=\\\"test\\\">\" + PMD.EOL\n            + \"<description>testdesc</description>\" + PMD.EOL + \"<rule \" + PMD.EOL + \"name=\\\"MockRuleName\\\" \" + PMD.EOL\n            + \"message=\\\"avoid the mock rule\\\" \" + PMD.EOL + \"class=\\\"net.sourceforge.pmd.lang.rule.MockRule\\\">\"\n            + \"<priority>3</priority>\" + PMD.EOL + \"</rule></ruleset>\";\n\n    private static final String LANGUAGE = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL + \"<ruleset name=\\\"test\\\">\" + PMD.EOL\n            + \"<description>testdesc</description>\" + PMD.EOL + \"<rule \" + PMD.EOL + \"name=\\\"MockRuleName\\\" \" + PMD.EOL\n            + \"message=\\\"avoid the mock rule\\\" \" + PMD.EOL\n            + \"class=\\\"net.sourceforge.pmd.lang.rule.MockRule\\\" language=\\\"dummy\\\">\" + PMD.EOL + \"</rule></ruleset>\";\n\n    private static final String INCORRECT_LANGUAGE = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL + \"<ruleset name=\\\"test\\\">\"\n            + PMD.EOL + \"<description>testdesc</description>\" + PMD.EOL + \"<rule \" + PMD.EOL + \"name=\\\"MockRuleName\\\" \"\n            + PMD.EOL + \"message=\\\"avoid the mock rule\\\" \" + PMD.EOL\n            + \"class=\\\"net.sourceforge.pmd.lang.rule.MockRule\\\"\" + PMD.EOL + \" language=\\\"bogus\\\">\" + PMD.EOL\n            + \"</rule></ruleset>\";\n\n    private static final String MINIMUM_LANGUAGE_VERSION = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL\n            + \"<ruleset name=\\\"test\\\">\" + PMD.EOL + \"<description>testdesc</description>\" + PMD.EOL + \"<rule \" + PMD.EOL\n            + \"name=\\\"MockRuleName\\\" \" + PMD.EOL + \"message=\\\"avoid the mock rule\\\" \" + PMD.EOL\n            + \"class=\\\"net.sourceforge.pmd.lang.rule.MockRule\\\"\" + PMD.EOL + \" language=\\\"dummy\\\"\" + PMD.EOL\n            + \" minimumLanguageVersion=\\\"1.4\\\">\" + PMD.EOL + \"</rule></ruleset>\";\n\n    private static final String INCORRECT_MINIMUM_LANGUAGE_VERSION = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL\n            + \"<ruleset name=\\\"test\\\">\" + PMD.EOL + \"<description>testdesc</description>\" + PMD.EOL + \"<rule \" + PMD.EOL\n            + \"name=\\\"MockRuleName\\\" \" + PMD.EOL + \"message=\\\"avoid the mock rule\\\" \" + PMD.EOL\n            + \"class=\\\"net.sourceforge.pmd.lang.rule.MockRule\\\"\" + PMD.EOL + \" language=\\\"dummy\\\"\" + PMD.EOL\n            + \" minimumLanguageVersion=\\\"bogus\\\">\" + PMD.EOL + \"</rule></ruleset>\";\n\n    private static final String MAXIMUM_LANGUAGE_VERSION = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL\n            + \"<ruleset name=\\\"test\\\">\" + PMD.EOL + \"<description>testdesc</description>\" + PMD.EOL + \"<rule \" + PMD.EOL\n            + \"name=\\\"MockRuleName\\\" \" + PMD.EOL + \"message=\\\"avoid the mock rule\\\" \" + PMD.EOL\n            + \"class=\\\"net.sourceforge.pmd.lang.rule.MockRule\\\"\" + PMD.EOL + \" language=\\\"dummy\\\"\" + PMD.EOL\n            + \" maximumLanguageVersion=\\\"1.7\\\">\" + PMD.EOL + \"</rule></ruleset>\";\n\n    private static final String INCORRECT_MAXIMUM_LANGUAGE_VERSION = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL\n            + \"<ruleset name=\\\"test\\\">\" + PMD.EOL + \"<description>testdesc</description>\" + PMD.EOL + \"<rule \" + PMD.EOL\n            + \"name=\\\"MockRuleName\\\" \" + PMD.EOL + \"message=\\\"avoid the mock rule\\\" \" + PMD.EOL\n            + \"class=\\\"net.sourceforge.pmd.lang.rule.MockRule\\\"\" + PMD.EOL + \" language=\\\"dummy\\\"\" + PMD.EOL\n            + \" maximumLanguageVersion=\\\"bogus\\\">\" + PMD.EOL + \"</rule></ruleset>\";\n\n    private static final String INVERTED_MINIMUM_MAXIMUM_LANGUAGE_VERSIONS = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL\n            + \"<ruleset name=\\\"test\\\">\" + PMD.EOL + \"<description>testdesc</description>\" + PMD.EOL + \"<rule \" + PMD.EOL\n            + \"name=\\\"MockRuleName\\\" \" + PMD.EOL + \"message=\\\"avoid the mock rule\\\" \" + PMD.EOL\n            + \"class=\\\"net.sourceforge.pmd.lang.rule.MockRule\\\" \" + PMD.EOL + \"language=\\\"dummy\\\"\" + PMD.EOL\n            + \" minimumLanguageVersion=\\\"1.7\\\"\" + PMD.EOL + \"maximumLanguageVersion=\\\"1.4\\\">\" + PMD.EOL\n            + \"</rule></ruleset>\";\n\n    private static final String DIRECT_DEPRECATED_RULE = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL + \"<ruleset name=\\\"test\\\">\"\n            + PMD.EOL + \"<description>testdesc</description>\" + PMD.EOL + \"<rule \" + PMD.EOL + \"name=\\\"MockRuleName\\\" \"\n            + PMD.EOL + \"message=\\\"avoid the mock rule\\\" \" + PMD.EOL\n            + \"class=\\\"net.sourceforge.pmd.lang.rule.MockRule\\\" deprecated=\\\"true\\\">\" + PMD.EOL + \"</rule></ruleset>\";\n\n    // Note: Update this RuleSet name to a different RuleSet with deprecated\n    // Rules when the Rules are finally removed.\n    private static final String DEPRECATED_RULE_RULESET_NAME = \"net/sourceforge/pmd/TestRuleset1.xml\";\n\n    // Note: Update this Rule name to a different deprecated Rule when the one\n    // listed here is finally removed.\n    private static final String DEPRECATED_RULE_NAME = \"MockRule3\";\n\n    private static final String REFERENCE_TO_DEPRECATED_RULE = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL\n            + \"<ruleset name=\\\"test\\\">\" + PMD.EOL + \"<description>testdesc</description>\" + PMD.EOL + \"<rule \" + PMD.EOL\n            + \"ref=\\\"\" + DEPRECATED_RULE_RULESET_NAME + \"/\" + DEPRECATED_RULE_NAME + \"\\\">\" + PMD.EOL\n            + \"</rule></ruleset>\";\n\n    private static final String REFERENCE_TO_RULESET_WITH_DEPRECATED_RULE = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL\n            + \"<ruleset name=\\\"test\\\">\" + PMD.EOL + \"<description>testdesc</description>\" + PMD.EOL + \"<rule \" + PMD.EOL\n            + \"ref=\\\"\" + DEPRECATED_RULE_RULESET_NAME + \"\\\">\" + PMD.EOL + \"</rule></ruleset>\";\n\n    private static final String DFA = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL + \"<ruleset name=\\\"test\\\">\" + PMD.EOL\n            + \"<description>testdesc</description>\" + PMD.EOL + \"<rule \" + PMD.EOL + \"name=\\\"MockRuleName\\\" \" + PMD.EOL\n            + \"message=\\\"avoid the mock rule\\\" \" + PMD.EOL + \"dfa=\\\"true\\\" \" + PMD.EOL\n            + \"class=\\\"net.sourceforge.pmd.lang.rule.MockRule\\\">\" + \"<priority>3</priority>\" + PMD.EOL\n            + \"</rule></ruleset>\";\n\n    private static final String INCLUDE_EXCLUDE_RULESET = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL\n            + \"<ruleset name=\\\"test\\\">\" + PMD.EOL + \"<description>testdesc</description>\" + PMD.EOL\n            + \"<include-pattern>include1</include-pattern>\" + PMD.EOL + \"<include-pattern>include2</include-pattern>\"\n            + PMD.EOL + \"<exclude-pattern>exclude1</exclude-pattern>\" + PMD.EOL\n            + \"<exclude-pattern>exclude2</exclude-pattern>\" + PMD.EOL + \"<exclude-pattern>exclude3</exclude-pattern>\"\n            + PMD.EOL + \"</ruleset>\";\n\n    private static final String EXTERNAL_REFERENCE_RULE_SET = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL\n            + \"<ruleset name=\\\"test\\\">\" + PMD.EOL + \"<description>testdesc</description>\" + PMD.EOL\n            + \"<rule ref=\\\"net/sourceforge/pmd/external-reference-ruleset.xml/MockRule\\\"/>\" + PMD.EOL + \"</ruleset>\";\n\n    private Rule loadFirstRule(String ruleSetXml) throws RuleSetNotFoundException {\n        RuleSet rs = loadRuleSet(ruleSetXml);\n        return rs.getRules().iterator().next();\n    }\n\n    private RuleSet loadRuleSet(String ruleSetXml) throws RuleSetNotFoundException {\n        RuleSetFactory rsf = new RuleSetFactory();\n        return rsf.createRuleSet(createRuleSetReferenceId(ruleSetXml));\n    }\n\n    private RuleSet loadRuleSetWithDeprecationWarnings(String ruleSetXml) throws RuleSetNotFoundException {\n        RuleSetFactory rsf = new RuleSetFactory(new ResourceLoader(), RulePriority.LOW, true, false);\n        return rsf.createRuleSet(createRuleSetReferenceId(ruleSetXml));\n    }\n\n    private static RuleSetReferenceId createRuleSetReferenceId(final String ruleSetXml) {\n        return new RuleSetReferenceId(null) {\n            @Override\n            public InputStream getInputStream(ResourceLoader resourceLoader) throws RuleSetNotFoundException {\n                try {\n                    return new ByteArrayInputStream(ruleSetXml.getBytes(\"UTF-8\"));\n                } catch (UnsupportedEncodingException e) {\n                    return null;\n                }\n            }\n        };\n    }\n}\n",
        "filePathAfter": "pmd-core/src/test/java/net/sourceforge/pmd/RuleSetFactoryTest.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNotSame;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.junit.Test;\nimport org.junit.rules.ExpectedException;\n\nimport net.sourceforge.pmd.junit.JavaUtilLoggingRule;\nimport net.sourceforge.pmd.junit.LocaleRule;\nimport net.sourceforge.pmd.lang.DummyLanguageModule;\nimport net.sourceforge.pmd.lang.LanguageRegistry;\nimport net.sourceforge.pmd.lang.rule.MockRule;\nimport net.sourceforge.pmd.lang.rule.RuleReference;\nimport net.sourceforge.pmd.properties.PropertyDescriptor;\nimport net.sourceforge.pmd.util.ResourceLoader;\n\npublic class RuleSetFactoryTest {\n\n    @org.junit.Rule\n    public ExpectedException ex = ExpectedException.none();\n\n    @org.junit.Rule\n    public LocaleRule localeRule = LocaleRule.en();\n\n    @Test\n    public void testRuleSetFileName() throws RuleSetNotFoundException {\n        RuleSet rs = loadRuleSet(EMPTY_RULESET);\n        assertNull(\"RuleSet file name not expected\", rs.getFileName());\n\n        RuleSetFactory rsf = RulesetsFactoryUtils.defaultFactory();\n        rs = rsf.createRuleSet(\"net/sourceforge/pmd/TestRuleset1.xml\");\n        assertEquals(\"wrong RuleSet file name\", rs.getFileName(), \"net/sourceforge/pmd/TestRuleset1.xml\");\n    }\n\n    @Test\n    public void testNoRuleSetFileName() throws RuleSetNotFoundException {\n        RuleSet rs = loadRuleSet(EMPTY_RULESET);\n        assertNull(\"RuleSet file name not expected\", rs.getFileName());\n    }\n\n    @Test\n    public void testRefs() throws Exception {\n        RuleSetFactory rsf = RulesetsFactoryUtils.defaultFactory();\n        RuleSet rs = rsf.createRuleSet(\"net/sourceforge/pmd/TestRuleset1.xml\");\n        assertNotNull(rs.getRuleByName(\"TestRuleRef\"));\n    }\n\n    @Test\n    public void testExtendedReferences() throws Exception {\n        InputStream in = new ResourceLoader().loadClassPathResourceAsStream(\"net/sourceforge/pmd/rulesets/reference-ruleset.xml\");\n        assertNotNull(\"Test ruleset not found - can't continue with test!\", in);\n        in.close();\n\n        RuleSetFactory rsf = RulesetsFactoryUtils.defaultFactory();\n        RuleSets rs = rsf.createRuleSets(\"net/sourceforge/pmd/rulesets/reference-ruleset.xml\");\n        // added by referencing a complete ruleset (TestRuleset1.xml)\n        assertNotNull(rs.getRuleByName(\"MockRule1\"));\n        assertNotNull(rs.getRuleByName(\"MockRule2\"));\n        assertNotNull(rs.getRuleByName(\"MockRule3\"));\n        assertNotNull(rs.getRuleByName(\"TestRuleRef\"));\n\n        // added by specific reference\n        assertNotNull(rs.getRuleByName(\"TestRule\"));\n        // this is from TestRuleset2.xml, but not referenced\n        assertNull(rs.getRuleByName(\"TestRule2Ruleset2\"));\n\n        Rule mockRule3 = rs.getRuleByName(\"MockRule3\");\n        assertEquals(\"Overridden message\", mockRule3.getMessage());\n        assertEquals(2, mockRule3.getPriority().getPriority());\n\n        Rule mockRule2 = rs.getRuleByName(\"MockRule2\");\n        assertEquals(\"Just combine them!\", mockRule2.getMessage());\n        // assert that MockRule2 is only once added to the ruleset, so that it\n        // really\n        // overwrites the configuration inherited from TestRuleset1.xml\n        assertEquals(1, countRule(rs, \"MockRule2\"));\n\n        Rule mockRule1 = rs.getRuleByName(\"MockRule1\");\n        assertNotNull(mockRule1);\n        PropertyDescriptor<?> prop = mockRule1.getPropertyDescriptor(\"testIntProperty\");\n        Object property = mockRule1.getProperty(prop);\n        assertEquals(\"5\", String.valueOf(property));\n\n        // included from TestRuleset3.xml\n        assertNotNull(rs.getRuleByName(\"Ruleset3Rule2\"));\n        // excluded from TestRuleset3.xml\n        assertNull(rs.getRuleByName(\"Ruleset3Rule1\"));\n\n        // overridden to 5\n        Rule ruleset4Rule1 = rs.getRuleByName(\"Ruleset4Rule1\");\n        assertNotNull(ruleset4Rule1);\n        assertEquals(5, ruleset4Rule1.getPriority().getPriority());\n        assertEquals(1, countRule(rs, \"Ruleset4Rule1\"));\n        // priority overridden for whole TestRuleset4 group\n        Rule ruleset4Rule2 = rs.getRuleByName(\"Ruleset4Rule2\");\n        assertNotNull(ruleset4Rule2);\n        assertEquals(2, ruleset4Rule2.getPriority().getPriority());\n    }\n\n    private int countRule(RuleSets rs, String ruleName) {\n        int count = 0;\n        for (Rule r : rs.getAllRules()) {\n            if (ruleName.equals(r.getName())) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    @Test(expected = RuleSetNotFoundException.class)\n    public void testRuleSetNotFound() throws RuleSetNotFoundException {\n        RuleSetFactory rsf = RulesetsFactoryUtils.defaultFactory();\n        rsf.createRuleSet(\"fooooo\");\n    }\n\n    @Test\n    public void testCreateEmptyRuleSet() throws RuleSetNotFoundException {\n        RuleSet rs = loadRuleSet(EMPTY_RULESET);\n        assertEquals(\"test\", rs.getName());\n        assertEquals(0, rs.size());\n    }\n\n    @Test\n    public void testSingleRule() throws RuleSetNotFoundException {\n        RuleSet rs = loadRuleSet(SINGLE_RULE);\n        assertEquals(1, rs.size());\n        Rule r = rs.getRules().iterator().next();\n        assertEquals(\"MockRuleName\", r.getName());\n        assertEquals(\"net.sourceforge.pmd.lang.rule.MockRule\", r.getRuleClass());\n        assertEquals(\"avoid the mock rule\", r.getMessage());\n    }\n\n    @Test\n    public void testMultipleRules() throws RuleSetNotFoundException {\n        RuleSet rs = loadRuleSet(MULTIPLE_RULES);\n        assertEquals(2, rs.size());\n        Set<String> expected = new HashSet<>();\n        expected.add(\"MockRuleName1\");\n        expected.add(\"MockRuleName2\");\n        for (Rule rule : rs.getRules()) {\n            assertTrue(expected.contains(rule.getName()));\n        }\n    }\n\n    @Test\n    public void testSingleRuleWithPriority() throws RuleSetNotFoundException {\n        assertEquals(RulePriority.MEDIUM, loadFirstRule(PRIORITY).getPriority());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testProps() throws RuleSetNotFoundException {\n        Rule r = loadFirstRule(PROPERTIES);\n        assertEquals(\"bar\", r.getProperty((PropertyDescriptor<String>) r.getPropertyDescriptor(\"fooString\")));\n        assertEquals(new Integer(3), r.getProperty((PropertyDescriptor<Integer>) r.getPropertyDescriptor(\"fooInt\")));\n        assertTrue(r.getProperty((PropertyDescriptor<Boolean>) r.getPropertyDescriptor(\"fooBoolean\")));\n        assertEquals(3.0d, r.getProperty((PropertyDescriptor<Double>) r.getPropertyDescriptor(\"fooDouble\")), 0.05);\n        assertNull(r.getPropertyDescriptor(\"BuggleFish\"));\n        assertNotSame(r.getDescription().indexOf(\"testdesc2\"), -1);\n    }\n\n    @Test\n    public void testStringMultiPropertyDefaultDelimiter() throws Exception {\n        Rule r = loadFirstRule(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n<ruleset name=\\\"the ruleset\\\">\\n  <description>Desc</description>\\n\"\n                                   + \"     <rule name=\\\"myRule\\\" message=\\\"Do not place to this package. Move to \\n{0} package/s instead.\\\" \\n\"\n                                   + \"class=\\\"net.sourceforge.pmd.lang.rule.XPathRule\\\" language=\\\"dummy\\\">\\n\"\n                                   + \"         <description>Please move your class to the right folder(rest \\nfolder)</description>\\n\"\n                                   + \"         <priority>2</priority>\\n         <properties>\\n             <property name=\\\"packageRegEx\\\"\"\n                                   + \" value=\\\"com.aptsssss|com.abc\\\" \\ntype=\\\"List[String]\\\" \"\n                                   + \"description=\\\"valid packages\\\"/>\\n         </properties></rule></ruleset>\");\n        PropertyDescriptor<List<String>> prop = (PropertyDescriptor<List<String>>) r.getPropertyDescriptor(\"packageRegEx\");\n        List<String> values = r.getProperty(prop);\n        assertEquals(Arrays.asList(\"com.aptsssss\", \"com.abc\"), values);\n    }\n\n    @Test\n    public void testStringMultiPropertyDelimiter() throws Exception {\n        Rule r = loadFirstRule(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" + \"<ruleset name=\\\"test\\\">\\n \"\n                                   + \" <description>ruleset desc</description>\\n     \"\n                                   + \"<rule name=\\\"myRule\\\" message=\\\"Do not place to this package. Move to \\n{0} package/s\"\n                                   + \" instead.\\\" \\n\" + \"class=\\\"net.sourceforge.pmd.lang.rule.XPathRule\\\" language=\\\"dummy\\\">\\n\"\n                                   + \"         <description>Please move your class to the right folder(rest \\nfolder)</description>\\n\"\n                                   + \"         <priority>2</priority>\\n         <properties>\\n             <property name=\\\"packageRegEx\\\"\"\n                                   + \" value=\\\"com.aptsssss,com.abc\\\" \\ntype=\\\"List[String]\\\" delimiter=\\\",\\\" \"\n                                   + \"description=\\\"valid packages\\\"/>\\n\"\n                                   + \"         </properties></rule>\" + \"</ruleset>\");\n        PropertyDescriptor<List<String>> prop = (PropertyDescriptor<List<String>>) r.getPropertyDescriptor(\"packageRegEx\");\n        List<String> values = r.getProperty(prop);\n        assertEquals(Arrays.asList(\"com.aptsssss\", \"com.abc\"), values);\n    }\n\n    @Test\n    public void testRuleSetWithDeprecatedRule() throws Exception {\n        RuleSet rs = loadRuleSet(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" + \"<ruleset name=\\\"ruleset\\\">\\n\"\n                + \"  <description>ruleset desc</description>\\n\"\n                + \"     <rule deprecated=\\\"true\\\" ref=\\\"rulesets/dummy/basic.xml/DummyBasicMockRule\\\"/>\"\n                + \"</ruleset>\");\n        assertEquals(1, rs.getRules().size());\n        Rule rule = rs.getRuleByName(\"DummyBasicMockRule\");\n        assertNotNull(rule);\n    }\n\n    /**\n     * This is an example of a category (built-in) ruleset, which contains a rule, that has been renamed.\n     * This means: a rule definition for \"NewName\" and a rule reference \"OldName\", that is deprecated\n     * and exists for backwards compatibility.\n     *\n     * <p>When loading this ruleset at a whole, we shouldn't get a deprecation warning. The deprecated\n     * rule reference should be ignored, so at the end, we only have the new rule name in the ruleset.\n     * This is because the deprecated reference points to a rule in the same ruleset.\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testRuleSetWithDeprecatedButRenamedRule() throws Exception {\n        RuleSet rs = loadRuleSetWithDeprecationWarnings(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" + \"<ruleset name=\\\"test\\\">\\n\"\n                + \"  <description>ruleset desc</description>\\n\"\n                + \"     <rule deprecated=\\\"true\\\" ref=\\\"NewName\\\" name=\\\"OldName\\\"/>\"\n                + \"     <rule name=\\\"NewName\\\" message=\\\"m\\\" class=\\\"net.sourceforge.pmd.lang.rule.XPathRule\\\" language=\\\"dummy\\\">\"\n                + \"         <description>d</description>\\n\" + \"         <priority>2</priority>\\n\" + \"     </rule>\"\n                + \"</ruleset>\");\n        assertEquals(1, rs.getRules().size());\n        Rule rule = rs.getRuleByName(\"NewName\");\n        assertNotNull(rule);\n        assertNull(rs.getRuleByName(\"OldName\"));\n\n        assertTrue(logging.getLog().isEmpty());\n    }\n\n    /**\n     * This is an example of a custom user ruleset, that references a rule, that has been renamed.\n     * The user should get a deprecation warning.\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testRuleSetReferencesADeprecatedRenamedRule() throws Exception {\n        RuleSet rs = loadRuleSetWithDeprecationWarnings(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" + \"<ruleset name=\\\"test\\\">\\n\"\n                + \"  <description>ruleset desc</description>\\n\"\n                + \"     <rule ref=\\\"rulesets/dummy/basic.xml/OldNameOfDummyBasicMockRule\\\"/>\" + \"</ruleset>\");\n        assertEquals(1, rs.getRules().size());\n        Rule rule = rs.getRuleByName(\"OldNameOfDummyBasicMockRule\");\n        assertNotNull(rule);\n\n        assertEquals(1,\n            StringUtils.countMatches(logging.getLog(),\n                \"WARNING: Use Rule name rulesets/dummy/basic.xml/DummyBasicMockRule instead of the deprecated Rule name rulesets/dummy/basic.xml/OldNameOfDummyBasicMockRule.\"));\n    }\n\n    /**\n     * This is an example of a custom user ruleset, that references a complete (e.g. category) ruleset,\n     * that contains a renamed (deprecated) rule and two normal rules and one deprecated rule.\n     *\n     * <p>\n     * The user should not get a deprecation warning for the whole ruleset,\n     * since not all rules are deprecated in the referenced ruleset. Although the referenced ruleset contains\n     * a deprecated rule, there should be no warning about it, because all deprecated rules are ignored,\n     * if a whole ruleset is referenced.\n     *\n     * <p>\n     * In the end, we should get all non-deprecated rules of the referenced ruleset.\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testRuleSetReferencesRulesetWithADeprecatedRenamedRule() throws Exception {\n        RuleSet rs = loadRuleSetWithDeprecationWarnings(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" + \"<ruleset name=\\\"test\\\">\\n\"\n                + \"  <description>ruleset desc</description>\\n\"\n                + \"     <rule ref=\\\"rulesets/dummy/basic.xml\\\"/>\" + \"</ruleset>\");\n        assertEquals(2, rs.getRules().size());\n        assertNotNull(rs.getRuleByName(\"DummyBasicMockRule\"));\n        assertNotNull(rs.getRuleByName(\"SampleXPathRule\"));\n\n        assertTrue(logging.getLog().isEmpty());\n    }\n\n    /**\n     * This is an example of a custom user ruleset, that references a complete (e.g. category) ruleset,\n     * that contains a renamed (deprecated) rule and two normal rules and one deprecated rule. The deprecated\n     * rule is excluded.\n     *\n     * <p>\n     * The user should not get a deprecation warning for the whole ruleset,\n     * since not all rules are deprecated in the referenced ruleset. Since the deprecated rule is excluded,\n     * there should be no deprecation warning at all, although the deprecated ruleset would have been\n     * excluded by default (without explictly excluding it).\n     *\n     * <p>\n     * In the end, we should get all non-deprecated rules of the referenced ruleset.\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testRuleSetReferencesRulesetWithAExcludedDeprecatedRule() throws Exception {\n        RuleSet rs = loadRuleSetWithDeprecationWarnings(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" + \"<ruleset name=\\\"test\\\">\\n\"\n                + \"  <description>ruleset desc</description>\\n\"\n                + \"     <rule ref=\\\"rulesets/dummy/basic.xml\\\"><exclude name=\\\"DeprecatedRule\\\"/></rule>\" + \"</ruleset>\");\n        assertEquals(2, rs.getRules().size());\n        assertNotNull(rs.getRuleByName(\"DummyBasicMockRule\"));\n        assertNotNull(rs.getRuleByName(\"SampleXPathRule\"));\n\n        assertTrue(logging.getLog().isEmpty());\n    }\n\n    /**\n     * This is an example of a custom user ruleset, that references a complete (e.g. category) ruleset,\n     * that contains a renamed (deprecated) rule and two normal rules and one deprecated rule.\n     * There is a exclusion of a rule, that no longer exists.\n     *\n     * <p>\n     * The user should not get a deprecation warning for the whole ruleset,\n     * since not all rules are deprecated in the referenced ruleset.\n     * Since the rule to be excluded doesn't exist, there should be a warning about that.\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testRuleSetReferencesRulesetWithAExcludedNonExistingRule() throws Exception {\n        RuleSet rs = loadRuleSetWithDeprecationWarnings(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" + \"<ruleset name=\\\"test\\\">\\n\"\n                + \"  <description>ruleset desc</description>\\n\"\n                + \"     <rule ref=\\\"rulesets/dummy/basic.xml\\\"><exclude name=\\\"NonExistingRule\\\"/></rule>\" + \"</ruleset>\");\n        assertEquals(2, rs.getRules().size());\n        assertNotNull(rs.getRuleByName(\"DummyBasicMockRule\"));\n        assertNotNull(rs.getRuleByName(\"SampleXPathRule\"));\n\n        assertEquals(0,\n                StringUtils.countMatches(logging.getLog(),\n                    \"WARNING: Discontinue using Rule rulesets/dummy/basic.xml/DeprecatedRule as it is scheduled for removal from PMD.\"));\n        assertEquals(1,\n                StringUtils.countMatches(logging.getLog(),\n                    \"WARNING: Unable to exclude rules [NonExistingRule] from ruleset reference rulesets/dummy/basic.xml; perhaps the rule name is mispelled or the rule doesn't exist anymore?\"));\n    }\n\n    /**\n     * When a custom ruleset references a ruleset that only contains deprecated rules, then this ruleset itself is\n     * considered deprecated and the user should get a deprecation warning for the ruleset.\n     */\n    @Test\n    public void testRuleSetReferencesDeprecatedRuleset() throws Exception {\n        RuleSet rs = loadRuleSetWithDeprecationWarnings(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" + \"<ruleset name=\\\"test\\\">\\n\"\n                + \"  <description>ruleset desc</description>\\n\"\n                + \"     <rule ref=\\\"rulesets/dummy/deprecated.xml\\\" />\" + \"</ruleset>\");\n        assertEquals(2, rs.getRules().size());\n        assertNotNull(rs.getRuleByName(\"DummyBasicMockRule\"));\n        assertNotNull(rs.getRuleByName(\"SampleXPathRule\"));\n\n        assertEquals(1,\n                StringUtils.countMatches(logging.getLog(),\n                    \"WARNING: The RuleSet rulesets/dummy/deprecated.xml has been deprecated and will be removed in PMD\"));\n    }\n\n    /**\n     * When a custom ruleset references a ruleset that contains both rules and rule references, that are left\n     * for backwards compatibility, because the rules have been moved to a different ruleset, then there should be\n     * no warning about deprecation - since the deprecated rules are not used.\n     */\n    @Test\n    public void testRuleSetReferencesRulesetWithAMovedRule() throws Exception {\n        RuleSet rs = loadRuleSetWithDeprecationWarnings(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" + \"<ruleset name=\\\"test\\\">\\n\"\n                + \"  <description>ruleset desc</description>\\n\"\n                + \"     <rule ref=\\\"rulesets/dummy/basic2.xml\\\" />\" + \"</ruleset>\");\n        assertEquals(1, rs.getRules().size());\n        assertNotNull(rs.getRuleByName(\"DummyBasic2MockRule\"));\n\n        assertEquals(0,\n                StringUtils.countMatches(logging.getLog(),\n                    \"WARNING: Use Rule name rulesets/dummy/basic.xml/DummyBasicMockRule instead of the deprecated Rule name rulesets/dummy/basic2.xml/DummyBasicMockRule. PMD\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testXPath() throws RuleSetNotFoundException {\n        Rule r = loadFirstRule(XPATH);\n        PropertyDescriptor<String> xpathProperty = (PropertyDescriptor<String>) r.getPropertyDescriptor(\"xpath\");\n        assertNotNull(\"xpath property descriptor\", xpathProperty);\n        assertNotSame(r.getProperty(xpathProperty).indexOf(\" //Block \"), -1);\n    }\n\n    @Test\n    public void testFacadesOffByDefault() throws RuleSetNotFoundException {\n        Rule r = loadFirstRule(XPATH);\n        assertFalse(r.isDfa());\n    }\n\n    @Test\n    public void testDFAFlag() throws RuleSetNotFoundException {\n        assertTrue(loadFirstRule(DFA).isDfa());\n    }\n\n    @Test\n    public void testExternalReferenceOverride() throws RuleSetNotFoundException {\n        Rule r = loadFirstRule(REF_OVERRIDE);\n        assertEquals(\"TestNameOverride\", r.getName());\n        assertEquals(\"Test message override\", r.getMessage());\n        assertEquals(\"Test description override\", r.getDescription());\n        assertEquals(\"Test that both example are stored\", 2, r.getExamples().size());\n        assertEquals(\"Test example override\", r.getExamples().get(1));\n        assertEquals(RulePriority.MEDIUM, r.getPriority());\n        PropertyDescriptor<?> test2Descriptor = r.getPropertyDescriptor(\"test2\");\n        assertNotNull(\"test2 descriptor\", test2Descriptor);\n        assertEquals(\"override2\", r.getProperty(test2Descriptor));\n        PropertyDescriptor<?> test3Descriptor = r.getPropertyDescriptor(\"test3\");\n        assertNotNull(\"test3 descriptor\", test3Descriptor);\n        assertEquals(\"override3\", r.getProperty(test3Descriptor));\n    }\n\n    @Test\n    public void testExternalReferenceOverrideNonExistent() throws RuleSetNotFoundException {\n        ex.expect(IllegalArgumentException.class);\n        ex.expectMessage(\"Cannot set non-existent property 'test4' on Rule TestNameOverride\");\n        loadFirstRule(REF_OVERRIDE_NONEXISTENT);\n    }\n\n    @Test\n    public void testReferenceInternalToInternal() throws RuleSetNotFoundException {\n        RuleSet ruleSet = loadRuleSet(REF_INTERNAL_TO_INTERNAL);\n\n        Rule rule = ruleSet.getRuleByName(\"MockRuleName\");\n        assertNotNull(\"Could not find Rule MockRuleName\", rule);\n\n        Rule ruleRef = ruleSet.getRuleByName(\"MockRuleNameRef\");\n        assertNotNull(\"Could not find Rule MockRuleNameRef\", ruleRef);\n    }\n\n    @Test\n    public void testReferenceInternalToInternalChain() throws RuleSetNotFoundException {\n        RuleSet ruleSet = loadRuleSet(REF_INTERNAL_TO_INTERNAL_CHAIN);\n\n        Rule rule = ruleSet.getRuleByName(\"MockRuleName\");\n        assertNotNull(\"Could not find Rule MockRuleName\", rule);\n\n        Rule ruleRef = ruleSet.getRuleByName(\"MockRuleNameRef\");\n        assertNotNull(\"Could not find Rule MockRuleNameRef\", ruleRef);\n\n        Rule ruleRefRef = ruleSet.getRuleByName(\"MockRuleNameRefRef\");\n        assertNotNull(\"Could not find Rule MockRuleNameRefRef\", ruleRefRef);\n    }\n\n    @Test\n    public void testReferenceInternalToExternal() throws RuleSetNotFoundException {\n        RuleSet ruleSet = loadRuleSet(REF_INTERNAL_TO_EXTERNAL);\n\n        Rule rule = ruleSet.getRuleByName(\"ExternalRefRuleName\");\n        assertNotNull(\"Could not find Rule ExternalRefRuleName\", rule);\n\n        Rule ruleRef = ruleSet.getRuleByName(\"ExternalRefRuleNameRef\");\n        assertNotNull(\"Could not find Rule ExternalRefRuleNameRef\", ruleRef);\n    }\n\n    @Test\n    public void testReferenceInternalToExternalChain() throws RuleSetNotFoundException {\n        RuleSet ruleSet = loadRuleSet(REF_INTERNAL_TO_EXTERNAL_CHAIN);\n\n        Rule rule = ruleSet.getRuleByName(\"ExternalRefRuleName\");\n        assertNotNull(\"Could not find Rule ExternalRefRuleName\", rule);\n\n        Rule ruleRef = ruleSet.getRuleByName(\"ExternalRefRuleNameRef\");\n        assertNotNull(\"Could not find Rule ExternalRefRuleNameRef\", ruleRef);\n\n        Rule ruleRefRef = ruleSet.getRuleByName(\"ExternalRefRuleNameRefRef\");\n        assertNotNull(\"Could not find Rule ExternalRefRuleNameRefRef\", ruleRefRef);\n    }\n\n    @Test\n    public void testReferencePriority() throws RuleSetNotFoundException {\n        ResourceLoader rl = new ResourceLoader();\n        RuleSetFactory rsf = new RuleSetFactory(rl, RulePriority.LOW, false, true);\n\n        RuleSet ruleSet = rsf.createRuleSet(createRuleSetReferenceId(REF_INTERNAL_TO_INTERNAL_CHAIN));\n        assertEquals(\"Number of Rules\", 3, ruleSet.getRules().size());\n        assertNotNull(ruleSet.getRuleByName(\"MockRuleName\"));\n        assertNotNull(ruleSet.getRuleByName(\"MockRuleNameRef\"));\n        assertNotNull(ruleSet.getRuleByName(\"MockRuleNameRefRef\"));\n\n        rsf = new RuleSetFactory(rl, RulePriority.MEDIUM_HIGH, false, true);\n        ruleSet = rsf.createRuleSet(createRuleSetReferenceId(REF_INTERNAL_TO_INTERNAL_CHAIN));\n        assertEquals(\"Number of Rules\", 2, ruleSet.getRules().size());\n        assertNotNull(ruleSet.getRuleByName(\"MockRuleNameRef\"));\n        assertNotNull(ruleSet.getRuleByName(\"MockRuleNameRefRef\"));\n\n        rsf = new RuleSetFactory(rl, RulePriority.HIGH, false, true);\n        ruleSet = rsf.createRuleSet(createRuleSetReferenceId(REF_INTERNAL_TO_INTERNAL_CHAIN));\n        assertEquals(\"Number of Rules\", 1, ruleSet.getRules().size());\n        assertNotNull(ruleSet.getRuleByName(\"MockRuleNameRefRef\"));\n\n        rsf = new RuleSetFactory(rl, RulePriority.LOW, false, true);\n        ruleSet = rsf.createRuleSet(createRuleSetReferenceId(REF_INTERNAL_TO_EXTERNAL_CHAIN));\n        assertEquals(\"Number of Rules\", 3, ruleSet.getRules().size());\n        assertNotNull(ruleSet.getRuleByName(\"ExternalRefRuleName\"));\n        assertNotNull(ruleSet.getRuleByName(\"ExternalRefRuleNameRef\"));\n        assertNotNull(ruleSet.getRuleByName(\"ExternalRefRuleNameRefRef\"));\n\n        rsf = new RuleSetFactory(rl, RulePriority.MEDIUM_HIGH, false, true);\n        ruleSet = rsf.createRuleSet(createRuleSetReferenceId(REF_INTERNAL_TO_EXTERNAL_CHAIN));\n        assertEquals(\"Number of Rules\", 2, ruleSet.getRules().size());\n        assertNotNull(ruleSet.getRuleByName(\"ExternalRefRuleNameRef\"));\n        assertNotNull(ruleSet.getRuleByName(\"ExternalRefRuleNameRefRef\"));\n\n        rsf = new RuleSetFactory(rl, RulePriority.HIGH, false, true);\n        ruleSet = rsf.createRuleSet(createRuleSetReferenceId(REF_INTERNAL_TO_EXTERNAL_CHAIN));\n        assertEquals(\"Number of Rules\", 1, ruleSet.getRules().size());\n        assertNotNull(ruleSet.getRuleByName(\"ExternalRefRuleNameRefRef\"));\n    }\n\n    @Test\n    public void testOverridePriorityLoadWithMinimum() throws RuleSetNotFoundException {\n        RuleSetFactory rsf = new RuleSetFactory(new ResourceLoader(), RulePriority.MEDIUM_LOW, true, true);\n        RuleSet ruleset = rsf.createRuleSet(\"net/sourceforge/pmd/rulesets/ruleset-minimum-priority.xml\");\n        // only one rule should remain, since we filter out the other rule by minimum priority\n        assertEquals(\"Number of Rules\", 1, ruleset.getRules().size());\n\n        // Priority is overridden and applied, rule is missing\n        assertNull(ruleset.getRuleByName(\"DummyBasicMockRule\"));\n\n        // this is the remaining rule\n        assertNotNull(ruleset.getRuleByName(\"SampleXPathRule\"));\n\n        // now, load with default minimum priority\n        rsf = RulesetsFactoryUtils.defaultFactory();\n        ruleset = rsf.createRuleSet(\"net/sourceforge/pmd/rulesets/ruleset-minimum-priority.xml\");\n        assertEquals(\"Number of Rules\", 2, ruleset.getRules().size());\n        Rule dummyBasicMockRule = ruleset.getRuleByName(\"DummyBasicMockRule\");\n        assertEquals(\"Wrong Priority\", RulePriority.LOW, dummyBasicMockRule.getPriority());\n    }\n\n    @Test\n    public void testExcludeWithMinimumPriority() throws RuleSetNotFoundException {\n        RuleSetFactory rsf = RulesetsFactoryUtils.createFactory(RulePriority.HIGH, true, true);\n        RuleSet ruleset = rsf.createRuleSet(\"net/sourceforge/pmd/rulesets/ruleset-minimum-priority-exclusion.xml\");\n        // no rules should be loaded\n        assertEquals(\"Number of Rules\", 0, ruleset.getRules().size());\n\n        // now, load with default minimum priority\n        rsf = RulesetsFactoryUtils.defaultFactory();\n        ruleset = rsf.createRuleSet(\"net/sourceforge/pmd/rulesets/ruleset-minimum-priority-exclusion.xml\");\n        // only one rule, we have excluded one...\n        assertEquals(\"Number of Rules\", 1, ruleset.getRules().size());\n        // rule is excluded\n        assertNull(ruleset.getRuleByName(\"DummyBasicMockRule\"));\n        // this is the remaining rule\n        assertNotNull(ruleset.getRuleByName(\"SampleXPathRule\"));\n    }\n\n    @Test\n    public void testOverrideMessage() throws RuleSetNotFoundException {\n        Rule r = loadFirstRule(REF_OVERRIDE_ORIGINAL_NAME);\n        assertEquals(\"TestMessageOverride\", r.getMessage());\n    }\n\n    @Test\n    public void testOverrideMessageOneElem() throws RuleSetNotFoundException {\n        Rule r = loadFirstRule(REF_OVERRIDE_ORIGINAL_NAME_ONE_ELEM);\n        assertEquals(\"TestMessageOverride\", r.getMessage());\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testIncorrectExternalRef() throws IllegalArgumentException, RuleSetNotFoundException {\n        loadFirstRule(REF_MISPELLED_XREF);\n    }\n\n    @Test\n    public void testSetPriority() throws RuleSetNotFoundException {\n        ResourceLoader rl = new ResourceLoader();\n        RuleSetFactory rsf = new RuleSetFactory(rl, RulePriority.MEDIUM_HIGH, false, true);\n        assertEquals(0, rsf.createRuleSet(createRuleSetReferenceId(SINGLE_RULE)).size());\n        rsf = new RuleSetFactory(rl, RulePriority.MEDIUM_LOW, false, true);\n        assertEquals(1, rsf.createRuleSet(createRuleSetReferenceId(SINGLE_RULE)).size());\n    }\n\n    @Test\n    public void testLanguage() throws RuleSetNotFoundException {\n        Rule r = loadFirstRule(LANGUAGE);\n        assertEquals(LanguageRegistry.getLanguage(DummyLanguageModule.NAME), r.getLanguage());\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testIncorrectLanguage() throws RuleSetNotFoundException {\n        loadFirstRule(INCORRECT_LANGUAGE);\n    }\n\n    @Test\n    public void testMinimumLanugageVersion() throws RuleSetNotFoundException {\n        Rule r = loadFirstRule(MINIMUM_LANGUAGE_VERSION);\n        assertEquals(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion(\"1.4\"),\n                r.getMinimumLanguageVersion());\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testIncorrectMinimumLanugageVersion() throws RuleSetNotFoundException {\n        loadFirstRule(INCORRECT_MINIMUM_LANGUAGE_VERSION);\n    }\n\n    @Test\n    public void testMaximumLanugageVersion() throws RuleSetNotFoundException {\n        Rule r = loadFirstRule(MAXIMUM_LANGUAGE_VERSION);\n        assertEquals(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion(\"1.7\"),\n                r.getMaximumLanguageVersion());\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testIncorrectMaximumLanugageVersion() throws RuleSetNotFoundException {\n        loadFirstRule(INCORRECT_MAXIMUM_LANGUAGE_VERSION);\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testInvertedMinimumMaximumLanugageVersions() throws RuleSetNotFoundException {\n        loadFirstRule(INVERTED_MINIMUM_MAXIMUM_LANGUAGE_VERSIONS);\n    }\n\n    @Test\n    public void testDirectDeprecatedRule() throws RuleSetNotFoundException {\n        Rule r = loadFirstRule(DIRECT_DEPRECATED_RULE);\n        assertNotNull(\"Direct Deprecated Rule\", r);\n        assertTrue(r.isDeprecated());\n    }\n\n    @Test\n    public void testReferenceToDeprecatedRule() throws RuleSetNotFoundException {\n        Rule r = loadFirstRule(REFERENCE_TO_DEPRECATED_RULE);\n        assertNotNull(\"Reference to Deprecated Rule\", r);\n        assertTrue(\"Rule Reference\", r instanceof RuleReference);\n        assertFalse(\"Not deprecated\", r.isDeprecated());\n        assertTrue(\"Original Rule Deprecated\", ((RuleReference) r).getRule().isDeprecated());\n        assertEquals(\"Rule name\", r.getName(), DEPRECATED_RULE_NAME);\n    }\n\n    @Test\n    public void testRuleSetReferenceWithDeprecatedRule() throws RuleSetNotFoundException {\n        RuleSet ruleSet = loadRuleSet(REFERENCE_TO_RULESET_WITH_DEPRECATED_RULE);\n        assertNotNull(\"RuleSet\", ruleSet);\n        assertFalse(\"RuleSet empty\", ruleSet.getRules().isEmpty());\n        // No deprecated Rules should be loaded when loading an entire RuleSet\n        // by reference - unless it contains only deprecated rules - then all rules would be added\n        Rule r = ruleSet.getRuleByName(DEPRECATED_RULE_NAME);\n        assertNull(\"Deprecated Rule Reference\", r);\n        for (Rule rule : ruleSet.getRules()) {\n            assertFalse(\"Rule not deprecated\", rule.isDeprecated());\n        }\n    }\n\n    @Test\n    public void testDeprecatedRuleSetReference() throws RuleSetNotFoundException {\n        RuleSetFactory ruleSetFactory = RulesetsFactoryUtils.defaultFactory();\n        RuleSet ruleSet = ruleSetFactory.createRuleSet(\"net/sourceforge/pmd/rulesets/ruleset-deprecated.xml\");\n        assertEquals(2, ruleSet.getRules().size());\n    }\n\n    @Test\n    public void testExternalReferences() throws RuleSetNotFoundException {\n        RuleSet rs = loadRuleSet(EXTERNAL_REFERENCE_RULE_SET);\n        assertEquals(1, rs.size());\n        assertEquals(MockRule.class.getName(), rs.getRuleByName(\"MockRule\").getRuleClass());\n    }\n\n    @Test\n    public void testIncludeExcludePatterns() throws RuleSetNotFoundException {\n        RuleSet ruleSet = loadRuleSet(INCLUDE_EXCLUDE_RULESET);\n\n        assertNotNull(\"Include patterns\", ruleSet.getIncludePatterns());\n        assertEquals(\"Include patterns size\", 2, ruleSet.getIncludePatterns().size());\n        assertEquals(\"Include pattern #1\", \"include1\", ruleSet.getIncludePatterns().get(0));\n        assertEquals(\"Include pattern #2\", \"include2\", ruleSet.getIncludePatterns().get(1));\n\n        assertNotNull(\"Exclude patterns\", ruleSet.getExcludePatterns());\n        assertEquals(\"Exclude patterns size\", 3, ruleSet.getExcludePatterns().size());\n        assertEquals(\"Exclude pattern #1\", \"exclude1\", ruleSet.getExcludePatterns().get(0));\n        assertEquals(\"Exclude pattern #2\", \"exclude2\", ruleSet.getExcludePatterns().get(1));\n        assertEquals(\"Exclude pattern #3\", \"exclude3\", ruleSet.getExcludePatterns().get(2));\n    }\n\n    /**\n     * Rule reference can't be resolved - ref is used instead of class and the\n     * class is old (pmd 4.3 and not pmd 5).\n     *\n     * @throws Exception\n     *             any error\n     */\n    @Test(expected = RuleSetNotFoundException.class)\n    public void testBug1202() throws Exception {\n        RuleSetReferenceId ref = createRuleSetReferenceId(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" + \"<ruleset>\\n\"\n                + \"  <rule ref=\\\"net.sourceforge.pmd.rules.XPathRule\\\">\\n\" + \"    <priority>1</priority>\\n\"\n                + \"    <properties>\\n\" + \"      <property name=\\\"xpath\\\" value=\\\"//TypeDeclaration\\\" />\\n\"\n                + \"      <property name=\\\"message\\\" value=\\\"Foo\\\" />\\n\" + \"    </properties>\\n\" + \"  </rule>\\n\"\n                + \"</ruleset>\\n\");\n        RuleSetFactory ruleSetFactory = RulesetsFactoryUtils.defaultFactory();\n        ruleSetFactory.createRuleSet(ref);\n    }\n\n    /**\n     * See https://sourceforge.net/p/pmd/bugs/1225/\n     *\n     * @throws Exception\n     *             any error\n     */\n    @Test\n    public void testEmptyRuleSetFile() throws Exception {\n        RuleSetReferenceId ref = createRuleSetReferenceId(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" + \"\\n\"\n                + \"<ruleset name=\\\"Custom ruleset\\\" xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                + \"    xmlns:xsi=\\\"http:www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                + \"    <description>PMD Ruleset.</description>\\n\" + \"\\n\"\n                + \"    <exclude-pattern>.*Test.*</exclude-pattern>\\n\" + \"\\n\" + \"</ruleset>\\n\");\n        RuleSetFactory ruleSetFactory = RulesetsFactoryUtils.defaultFactory();\n        RuleSet ruleset = ruleSetFactory.createRuleSet(ref);\n        assertEquals(0, ruleset.getRules().size());\n    }\n\n    /**\n     * See https://github.com/pmd/pmd/issues/782\n     * Empty ruleset should be interpreted as deprecated.\n     *\n     * @throws Exception\n     *             any error\n     */\n    @Test\n    public void testEmptyRuleSetReferencedShouldNotBeDeprecated() throws Exception {\n        RuleSetReferenceId ref = createRuleSetReferenceId(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" + \"\\n\"\n                + \"<ruleset name=\\\"Custom ruleset\\\" xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                + \"    xmlns:xsi=\\\"http:www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                + \"    <description>Ruleset which references a empty ruleset</description>\\n\" + \"\\n\"\n                + \"    <rule ref=\\\"rulesets/dummy/empty-ruleset.xml\\\" />\\n\"\n                + \"</ruleset>\\n\");\n        RuleSetFactory ruleSetFactory = new RuleSetFactory(new ResourceLoader(), RulePriority.LOW, true, true);\n        RuleSet ruleset = ruleSetFactory.createRuleSet(ref);\n        assertEquals(0, ruleset.getRules().size());\n\n        assertTrue(logging.getLog().isEmpty());\n    }\n\n    /**\n     * See https://sourceforge.net/p/pmd/bugs/1231/\n     *\n     * @throws Exception\n     *             any error\n     */\n    @Test(expected = IllegalArgumentException.class)\n    public void testWrongRuleNameReferenced() throws Exception {\n        RuleSetReferenceId ref = createRuleSetReferenceId(\"<?xml version=\\\"1.0\\\"?>\\n\"\n                + \"<ruleset name=\\\"Custom ruleset for tests\\\"\\n\"\n                + \"    xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                + \"    xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                + \"  <description>Custom ruleset for tests</description>\\n\"\n                + \"  <rule ref=\\\"net/sourceforge/pmd/TestRuleset1.xml/ThisRuleDoesNotExist\\\"/>\\n\" + \"</ruleset>\\n\");\n        RuleSetFactory ruleSetFactory = RulesetsFactoryUtils.defaultFactory();\n        ruleSetFactory.createRuleSet(ref);\n    }\n\n    /**\n     * Unit test for #1312 see https://sourceforge.net/p/pmd/bugs/1312/\n     *\n     * @throws Exception\n     *             any error\n     */\n    @Test\n    public void testRuleReferenceWithNameOverridden() throws Exception {\n        RuleSetReferenceId ref = createRuleSetReferenceId(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\"\n                + \"<ruleset xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                + \"         xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                + \"         name=\\\"pmd-eclipse\\\"\\n\"\n                + \"         xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                + \"   <description>PMD Plugin preferences rule set</description>\\n\" + \"\\n\"\n                + \"<rule name=\\\"OverriddenDummyBasicMockRule\\\"\\n\"\n                + \"    ref=\\\"rulesets/dummy/basic.xml/DummyBasicMockRule\\\">\\n\" + \"</rule>\\n\" + \"\\n\" + \"</ruleset>\");\n        RuleSetFactory ruleSetFactory = RulesetsFactoryUtils.defaultFactory();\n        RuleSet rs = ruleSetFactory.createRuleSet(ref);\n\n        Rule r = rs.getRules().toArray(new Rule[1])[0];\n        assertEquals(\"OverriddenDummyBasicMockRule\", r.getName());\n        RuleReference ruleRef = (RuleReference) r;\n        assertEquals(\"DummyBasicMockRule\", ruleRef.getRule().getName());\n    }\n\n    /**\n     * See https://sourceforge.net/p/pmd/bugs/1231/\n     *\n     * <p>See https://github.com/pmd/pmd/issues/1978 - with that, it should not be an error anymore.\n     *\n     * @throws Exception\n     *             any error\n     */\n    @Test\n    public void testWrongRuleNameExcluded() throws Exception {\n        RuleSetReferenceId ref = createRuleSetReferenceId(\n                \"<?xml version=\\\"1.0\\\"?>\\n\" + \"<ruleset name=\\\"Custom ruleset for tests\\\"\\n\"\n                        + \"    xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                        + \"    xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                        + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                        + \"  <description>Custom ruleset for tests</description>\\n\"\n                        + \"  <rule ref=\\\"net/sourceforge/pmd/TestRuleset1.xml\\\">\\n\"\n                        + \"    <exclude name=\\\"ThisRuleDoesNotExist\\\"/>\\n\" + \"  </rule>\\n\" + \"</ruleset>\\n\");\n        RuleSetFactory ruleSetFactory = RulesetsFactoryUtils.defaultFactory();\n        RuleSet ruleset = ruleSetFactory.createRuleSet(ref);\n        assertEquals(4, ruleset.getRules().size());\n    }\n\n    /**\n     * This unit test manifests the current behavior - which might change in the\n     * future. See #1537.\n     *\n     * Currently, if a ruleset is imported twice, the excludes of the first\n     * import are ignored. Duplicated rules are silently ignored.\n     *\n     * @throws Exception\n     *             any error\n     * @see <a href=\"https://sourceforge.net/p/pmd/bugs/1537/\">#1537 Implement\n     *      strict ruleset parsing</a>\n     * @see <a href=\n     *      \"http://stackoverflow.com/questions/40299075/custom-pmd-ruleset-not-working\">stackoverflow\n     *      - custom ruleset not working</a>\n     */\n    @Test\n    public void testExcludeAndImportTwice() throws Exception {\n        RuleSetReferenceId ref1 = createRuleSetReferenceId(\n                \"<?xml version=\\\"1.0\\\"?>\\n\" + \"<ruleset name=\\\"Custom ruleset for tests\\\"\\n\"\n                        + \"    xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                        + \"    xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                        + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                        + \"  <description>Custom ruleset for tests</description>\\n\"\n                        + \"  <rule ref=\\\"rulesets/dummy/basic.xml\\\">\\n\" + \"    <exclude name=\\\"DummyBasicMockRule\\\"/>\\n\"\n                        + \"  </rule>\\n\" + \"</ruleset>\\n\");\n        RuleSetFactory ruleSetFactory = RulesetsFactoryUtils.defaultFactory();\n        RuleSet ruleset = ruleSetFactory.createRuleSet(ref1);\n        assertNull(ruleset.getRuleByName(\"DummyBasicMockRule\"));\n\n        RuleSetReferenceId ref2 = createRuleSetReferenceId(\n                \"<?xml version=\\\"1.0\\\"?>\\n\" + \"<ruleset name=\\\"Custom ruleset for tests\\\"\\n\"\n                        + \"    xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                        + \"    xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                        + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                        + \"  <description>Custom ruleset for tests</description>\\n\"\n                        + \"  <rule ref=\\\"rulesets/dummy/basic.xml\\\">\\n\" + \"    <exclude name=\\\"DummyBasicMockRule\\\"/>\\n\"\n                        + \"  </rule>\\n\" + \"  <rule ref=\\\"rulesets/dummy/basic.xml\\\"/>\\n\" + \"</ruleset>\\n\");\n        RuleSetFactory ruleSetFactory2 = RulesetsFactoryUtils.defaultFactory();\n        RuleSet ruleset2 = ruleSetFactory2.createRuleSet(ref2);\n        assertNotNull(ruleset2.getRuleByName(\"DummyBasicMockRule\"));\n\n        RuleSetReferenceId ref3 = createRuleSetReferenceId(\n                \"<?xml version=\\\"1.0\\\"?>\\n\" + \"<ruleset name=\\\"Custom ruleset for tests\\\"\\n\"\n                        + \"    xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                        + \"    xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                        + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                        + \"  <description>Custom ruleset for tests</description>\\n\"\n                        + \"  <rule ref=\\\"rulesets/dummy/basic.xml\\\"/>\\n\" + \"  <rule ref=\\\"rulesets/dummy/basic.xml\\\">\\n\"\n                        + \"    <exclude name=\\\"DummyBasicMockRule\\\"/>\\n\" + \"  </rule>\\n\" + \"</ruleset>\\n\");\n        RuleSetFactory ruleSetFactory3 = RulesetsFactoryUtils.defaultFactory();\n        RuleSet ruleset3 = ruleSetFactory3.createRuleSet(ref3);\n        assertNotNull(ruleset3.getRuleByName(\"DummyBasicMockRule\"));\n    }\n\n    @org.junit.Rule\n    public JavaUtilLoggingRule logging = new JavaUtilLoggingRule(RuleSetFactory.class.getName());\n\n    @Test\n    public void testMissingRuleSetNameIsWarning() throws Exception {\n        RuleSetReferenceId ref = createRuleSetReferenceId(\n                \"<?xml version=\\\"1.0\\\"?>\\n\" + \"<ruleset \\n\"\n                        + \"    xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                        + \"    xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                        + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                        + \"  <description>Custom ruleset for tests</description>\\n\"\n                        + \"  <rule ref=\\\"rulesets/dummy/basic.xml\\\"/>\\n\"\n                        + \"  </ruleset>\\n\");\n        RuleSetFactory ruleSetFactory = RulesetsFactoryUtils.defaultFactory();\n        ruleSetFactory.createRuleSet(ref);\n\n        assertTrue(logging.getLog().contains(\"RuleSet name is missing.\"));\n    }\n\n    @Test\n    public void testMissingRuleSetDescriptionIsWarning() throws Exception {\n        RuleSetReferenceId ref = createRuleSetReferenceId(\n                \"<?xml version=\\\"1.0\\\"?>\\n\" + \"<ruleset name=\\\"then name\\\"\\n\"\n                        + \"    xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                        + \"    xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                        + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                        + \"  <rule ref=\\\"rulesets/dummy/basic.xml\\\"/>\\n\"\n                        + \"  </ruleset>\\n\");\n        RuleSetFactory ruleSetFactory = RulesetsFactoryUtils.defaultFactory();\n        ruleSetFactory.createRuleSet(ref);\n        assertTrue(logging.getLog().contains(\"RuleSet description is missing.\"));\n    }\n\n    private static final String REF_OVERRIDE_ORIGINAL_NAME = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL\n            + \"<ruleset name=\\\"test\\\">\" + PMD.EOL + \" <description>testdesc</description>\" + PMD.EOL + \" <rule \"\n            + PMD.EOL + \"  ref=\\\"net/sourceforge/pmd/TestRuleset1.xml/MockRule1\\\" message=\\\"TestMessageOverride\\\"> \"\n            + PMD.EOL + \" </rule>\" + PMD.EOL + \"</ruleset>\";\n\n    private static final String REF_MISPELLED_XREF = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL + \"<ruleset name=\\\"test\\\">\"\n            + PMD.EOL + \" <description>testdesc</description>\" + PMD.EOL + \" <rule \" + PMD.EOL\n            + \"  ref=\\\"net/sourceforge/pmd/TestRuleset1.xml/FooMockRule1\\\"> \" + PMD.EOL + \" </rule>\" + PMD.EOL\n            + \"</ruleset>\";\n\n    private static final String REF_OVERRIDE_ORIGINAL_NAME_ONE_ELEM = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL\n            + \"<ruleset name=\\\"test\\\">\" + PMD.EOL + \" <description>testdesc</description>\" + PMD.EOL\n            + \" <rule ref=\\\"net/sourceforge/pmd/TestRuleset1.xml/MockRule1\\\" message=\\\"TestMessageOverride\\\"/> \"\n            + PMD.EOL + \"</ruleset>\";\n\n    private static final String REF_OVERRIDE = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL + \"<ruleset name=\\\"test\\\">\" + PMD.EOL\n            + \" <description>testdesc</description>\" + PMD.EOL + \" <rule \" + PMD.EOL\n            + \"  ref=\\\"net/sourceforge/pmd/TestRuleset1.xml/MockRule4\\\" \" + PMD.EOL + \"  name=\\\"TestNameOverride\\\" \"\n            + PMD.EOL + \"  message=\\\"Test message override\\\"> \" + PMD.EOL\n            + \"  <description>Test description override</description>\" + PMD.EOL\n            + \"  <example>Test example override</example>\" + PMD.EOL + \"  <priority>3</priority>\" + PMD.EOL\n            + \"  <properties>\" + PMD.EOL\n            + \"   <property name=\\\"test2\\\" description=\\\"test2\\\" type=\\\"String\\\" value=\\\"override2\\\"/>\" + PMD.EOL\n            + \"   <property name=\\\"test3\\\" type=\\\"String\\\" description=\\\"test3\\\"><value>override3</value></property>\"\n            // + PMD.EOL + \"   <property name=\\\"test4\\\" description=\\\"test4\\\" type=\\\"String\\\" value=\\\"new property\\\"/>\" // Nonsense\n            + PMD.EOL + \"  </properties>\" + PMD.EOL + \" </rule>\" + PMD.EOL + \"</ruleset>\";\n\n    private static final String REF_OVERRIDE_NONEXISTENT = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL + \"<ruleset name=\\\"test\\\">\" + PMD.EOL\n                                                           + \" <description>testdesc</description>\" + PMD.EOL + \" <rule \" + PMD.EOL\n                                                           + \"  ref=\\\"net/sourceforge/pmd/TestRuleset1.xml/MockRule4\\\" \" + PMD.EOL + \"  name=\\\"TestNameOverride\\\" \"\n                                                           + PMD.EOL + \"  message=\\\"Test message override\\\"> \" + PMD.EOL\n                                                           + \"  <description>Test description override</description>\" + PMD.EOL\n                                                           + \"  <example>Test example override</example>\" + PMD.EOL + \"  <priority>3</priority>\" + PMD.EOL\n                                                           + \"  <properties>\" + PMD.EOL\n                                                           + \"   <property name=\\\"test4\\\" description=\\\"test4\\\" type=\\\"String\\\" value=\\\"new property\\\"/>\" + PMD.EOL // inexistent property\n                                                           + \"  </properties>\" + PMD.EOL + \" </rule>\" + PMD.EOL + \"</ruleset>\";\n    \n    private static final String REF_INTERNAL_TO_INTERNAL = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL\n            + \"<ruleset name=\\\"test\\\">\" + PMD.EOL + \" <description>testdesc</description>\" + PMD.EOL + \"<rule \"\n            + PMD.EOL + \"name=\\\"MockRuleName\\\" \" + PMD.EOL + \"message=\\\"avoid the mock rule\\\" \" + PMD.EOL\n            + \"class=\\\"net.sourceforge.pmd.lang.rule.MockRule\\\">\" + PMD.EOL + \"</rule>\"\n            + \" <rule ref=\\\"MockRuleName\\\" name=\\\"MockRuleNameRef\\\"/> \" + PMD.EOL + \"</ruleset>\";\n\n    private static final String REF_INTERNAL_TO_INTERNAL_CHAIN = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL\n            + \"<ruleset name=\\\"test\\\">\" + PMD.EOL + \" <description>testdesc</description>\" + PMD.EOL + \"<rule \"\n            + PMD.EOL + \"name=\\\"MockRuleName\\\" \" + PMD.EOL + \"message=\\\"avoid the mock rule\\\" \" + PMD.EOL\n            + \"class=\\\"net.sourceforge.pmd.lang.rule.MockRule\\\">\" + PMD.EOL + \"</rule>\"\n            + \" <rule ref=\\\"MockRuleName\\\" name=\\\"MockRuleNameRef\\\"><priority>2</priority></rule> \" + PMD.EOL\n            + \" <rule ref=\\\"MockRuleNameRef\\\" name=\\\"MockRuleNameRefRef\\\"><priority>1</priority></rule> \" + PMD.EOL\n            + \"</ruleset>\";\n\n    private static final String REF_INTERNAL_TO_EXTERNAL = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL\n            + \"<ruleset name=\\\"test\\\">\" + PMD.EOL + \" <description>testdesc</description>\" + PMD.EOL + \"<rule \"\n            + PMD.EOL + \"name=\\\"ExternalRefRuleName\\\" \" + PMD.EOL\n            + \"ref=\\\"net/sourceforge/pmd/TestRuleset1.xml/MockRule1\\\"/>\" + PMD.EOL\n            + \" <rule ref=\\\"ExternalRefRuleName\\\" name=\\\"ExternalRefRuleNameRef\\\"/> \" + PMD.EOL + \"</ruleset>\";\n\n    private static final String REF_INTERNAL_TO_EXTERNAL_CHAIN = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL\n            + \"<ruleset name=\\\"test\\\">\" + PMD.EOL + \" <description>testdesc</description>\" + PMD.EOL + \"<rule \"\n            + PMD.EOL + \"name=\\\"ExternalRefRuleName\\\" \" + PMD.EOL\n            + \"ref=\\\"net/sourceforge/pmd/TestRuleset2.xml/TestRule\\\"/>\" + PMD.EOL\n            + \" <rule ref=\\\"ExternalRefRuleName\\\" name=\\\"ExternalRefRuleNameRef\\\"><priority>2</priority></rule> \"\n            + PMD.EOL\n            + \" <rule ref=\\\"ExternalRefRuleNameRef\\\" name=\\\"ExternalRefRuleNameRefRef\\\"><priority>1</priority></rule> \"\n            + PMD.EOL + \"</ruleset>\";\n\n    private static final String EMPTY_RULESET = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL + \"<ruleset name=\\\"test\\\">\"\n            + PMD.EOL + \"<description>testdesc</description>\" + PMD.EOL + \"</ruleset>\";\n\n    private static final String SINGLE_RULE = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL + \"<ruleset name=\\\"test\\\">\" + PMD.EOL\n            + \"<description>testdesc</description>\" + PMD.EOL + \"<rule \" + PMD.EOL + \"name=\\\"MockRuleName\\\" \" + PMD.EOL\n            + \"message=\\\"avoid the mock rule\\\" \" + PMD.EOL + \"class=\\\"net.sourceforge.pmd.lang.rule.MockRule\\\">\"\n            + \"<priority>3</priority>\" + PMD.EOL + \"</rule></ruleset>\";\n\n    private static final String MULTIPLE_RULES = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL + \"<ruleset name=\\\"test\\\">\"\n            + PMD.EOL + \"<description>testdesc</description>\" + PMD.EOL + \"<rule name=\\\"MockRuleName1\\\" \" + PMD.EOL\n            + \"message=\\\"avoid the mock rule\\\" \" + PMD.EOL + \"class=\\\"net.sourceforge.pmd.lang.rule.MockRule\\\">\"\n            + PMD.EOL + \"</rule>\" + PMD.EOL + \"<rule name=\\\"MockRuleName2\\\" \" + PMD.EOL\n            + \"message=\\\"avoid the mock rule\\\" \" + PMD.EOL + \"class=\\\"net.sourceforge.pmd.lang.rule.MockRule\\\">\"\n            + PMD.EOL + \"</rule></ruleset>\";\n\n    private static final String PROPERTIES = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL + \"<ruleset name=\\\"test\\\">\" + PMD.EOL\n            + \"<description>testdesc</description>\" + PMD.EOL + \"<rule name=\\\"MockRuleName\\\" \" + PMD.EOL\n            + \"message=\\\"avoid the mock rule\\\" \" + PMD.EOL + \"class=\\\"net.sourceforge.pmd.lang.rule.MockRule\\\">\"\n            + PMD.EOL + \"<description>testdesc2</description>\" + PMD.EOL + \"<properties>\" + PMD.EOL\n            + \"<property name=\\\"fooBoolean\\\" description=\\\"test\\\" type=\\\"Boolean\\\" value=\\\"true\\\" />\" + PMD.EOL\n            + \"<property name=\\\"fooChar\\\" description=\\\"test\\\" type=\\\"Character\\\" value=\\\"B\\\" />\" + PMD.EOL\n            + \"<property name=\\\"fooInt\\\" description=\\\"test\\\" type=\\\"Integer\\\" min=\\\"1\\\" max=\\\"10\\\" value=\\\"3\\\" />\"\n            + PMD.EOL\n            + \"<property name=\\\"fooFloat\\\" description=\\\"test\\\" type=\\\"Float\\\" min=\\\"1.0\\\" max=\\\"1.0\\\" value=\\\"1.0\\\"  />\"\n            + PMD.EOL\n            + \"<property name=\\\"fooDouble\\\" description=\\\"test\\\" type=\\\"Double\\\" min=\\\"1.0\\\" max=\\\"9.0\\\" value=\\\"3.0\\\"  />\"\n            + PMD.EOL + \"<property name=\\\"fooString\\\" description=\\\"test\\\" type=\\\"String\\\" value=\\\"bar\\\" />\" + PMD.EOL\n            + \"</properties>\" + PMD.EOL + \"</rule></ruleset>\";\n\n    private static final String XPATH = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL + \"<ruleset name=\\\"test\\\">\" + PMD.EOL\n            + \"<description>testdesc</description>\" + PMD.EOL + \"<rule name=\\\"MockRuleName\\\" \" + PMD.EOL\n            + \"message=\\\"avoid the mock rule\\\" \" + PMD.EOL + \"class=\\\"net.sourceforge.pmd.lang.rule.MockRule\\\">\"\n            + \"<priority>3</priority>\" + PMD.EOL + PMD.EOL + \"<description>testdesc2</description>\" + PMD.EOL\n            + \"<properties>\" + PMD.EOL + \"<property name=\\\"xpath\\\" description=\\\"test\\\" type=\\\"String\\\">\" + PMD.EOL\n            + \"<value>\" + PMD.EOL + \"<![CDATA[ //Block ]]>\" + PMD.EOL + \"</value>\" + PMD.EOL + \"</property>\" + PMD.EOL\n            + \"</properties>\" + PMD.EOL + \"</rule></ruleset>\";\n\n    private static final String PRIORITY = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL + \"<ruleset name=\\\"test\\\">\" + PMD.EOL\n            + \"<description>testdesc</description>\" + PMD.EOL + \"<rule \" + PMD.EOL + \"name=\\\"MockRuleName\\\" \" + PMD.EOL\n            + \"message=\\\"avoid the mock rule\\\" \" + PMD.EOL + \"class=\\\"net.sourceforge.pmd.lang.rule.MockRule\\\">\"\n            + \"<priority>3</priority>\" + PMD.EOL + \"</rule></ruleset>\";\n\n    private static final String LANGUAGE = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL + \"<ruleset name=\\\"test\\\">\" + PMD.EOL\n            + \"<description>testdesc</description>\" + PMD.EOL + \"<rule \" + PMD.EOL + \"name=\\\"MockRuleName\\\" \" + PMD.EOL\n            + \"message=\\\"avoid the mock rule\\\" \" + PMD.EOL\n            + \"class=\\\"net.sourceforge.pmd.lang.rule.MockRule\\\" language=\\\"dummy\\\">\" + PMD.EOL + \"</rule></ruleset>\";\n\n    private static final String INCORRECT_LANGUAGE = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL + \"<ruleset name=\\\"test\\\">\"\n            + PMD.EOL + \"<description>testdesc</description>\" + PMD.EOL + \"<rule \" + PMD.EOL + \"name=\\\"MockRuleName\\\" \"\n            + PMD.EOL + \"message=\\\"avoid the mock rule\\\" \" + PMD.EOL\n            + \"class=\\\"net.sourceforge.pmd.lang.rule.MockRule\\\"\" + PMD.EOL + \" language=\\\"bogus\\\">\" + PMD.EOL\n            + \"</rule></ruleset>\";\n\n    private static final String MINIMUM_LANGUAGE_VERSION = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL\n            + \"<ruleset name=\\\"test\\\">\" + PMD.EOL + \"<description>testdesc</description>\" + PMD.EOL + \"<rule \" + PMD.EOL\n            + \"name=\\\"MockRuleName\\\" \" + PMD.EOL + \"message=\\\"avoid the mock rule\\\" \" + PMD.EOL\n            + \"class=\\\"net.sourceforge.pmd.lang.rule.MockRule\\\"\" + PMD.EOL + \" language=\\\"dummy\\\"\" + PMD.EOL\n            + \" minimumLanguageVersion=\\\"1.4\\\">\" + PMD.EOL + \"</rule></ruleset>\";\n\n    private static final String INCORRECT_MINIMUM_LANGUAGE_VERSION = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL\n            + \"<ruleset name=\\\"test\\\">\" + PMD.EOL + \"<description>testdesc</description>\" + PMD.EOL + \"<rule \" + PMD.EOL\n            + \"name=\\\"MockRuleName\\\" \" + PMD.EOL + \"message=\\\"avoid the mock rule\\\" \" + PMD.EOL\n            + \"class=\\\"net.sourceforge.pmd.lang.rule.MockRule\\\"\" + PMD.EOL + \" language=\\\"dummy\\\"\" + PMD.EOL\n            + \" minimumLanguageVersion=\\\"bogus\\\">\" + PMD.EOL + \"</rule></ruleset>\";\n\n    private static final String MAXIMUM_LANGUAGE_VERSION = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL\n            + \"<ruleset name=\\\"test\\\">\" + PMD.EOL + \"<description>testdesc</description>\" + PMD.EOL + \"<rule \" + PMD.EOL\n            + \"name=\\\"MockRuleName\\\" \" + PMD.EOL + \"message=\\\"avoid the mock rule\\\" \" + PMD.EOL\n            + \"class=\\\"net.sourceforge.pmd.lang.rule.MockRule\\\"\" + PMD.EOL + \" language=\\\"dummy\\\"\" + PMD.EOL\n            + \" maximumLanguageVersion=\\\"1.7\\\">\" + PMD.EOL + \"</rule></ruleset>\";\n\n    private static final String INCORRECT_MAXIMUM_LANGUAGE_VERSION = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL\n            + \"<ruleset name=\\\"test\\\">\" + PMD.EOL + \"<description>testdesc</description>\" + PMD.EOL + \"<rule \" + PMD.EOL\n            + \"name=\\\"MockRuleName\\\" \" + PMD.EOL + \"message=\\\"avoid the mock rule\\\" \" + PMD.EOL\n            + \"class=\\\"net.sourceforge.pmd.lang.rule.MockRule\\\"\" + PMD.EOL + \" language=\\\"dummy\\\"\" + PMD.EOL\n            + \" maximumLanguageVersion=\\\"bogus\\\">\" + PMD.EOL + \"</rule></ruleset>\";\n\n    private static final String INVERTED_MINIMUM_MAXIMUM_LANGUAGE_VERSIONS = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL\n            + \"<ruleset name=\\\"test\\\">\" + PMD.EOL + \"<description>testdesc</description>\" + PMD.EOL + \"<rule \" + PMD.EOL\n            + \"name=\\\"MockRuleName\\\" \" + PMD.EOL + \"message=\\\"avoid the mock rule\\\" \" + PMD.EOL\n            + \"class=\\\"net.sourceforge.pmd.lang.rule.MockRule\\\" \" + PMD.EOL + \"language=\\\"dummy\\\"\" + PMD.EOL\n            + \" minimumLanguageVersion=\\\"1.7\\\"\" + PMD.EOL + \"maximumLanguageVersion=\\\"1.4\\\">\" + PMD.EOL\n            + \"</rule></ruleset>\";\n\n    private static final String DIRECT_DEPRECATED_RULE = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL + \"<ruleset name=\\\"test\\\">\"\n            + PMD.EOL + \"<description>testdesc</description>\" + PMD.EOL + \"<rule \" + PMD.EOL + \"name=\\\"MockRuleName\\\" \"\n            + PMD.EOL + \"message=\\\"avoid the mock rule\\\" \" + PMD.EOL\n            + \"class=\\\"net.sourceforge.pmd.lang.rule.MockRule\\\" deprecated=\\\"true\\\">\" + PMD.EOL + \"</rule></ruleset>\";\n\n    // Note: Update this RuleSet name to a different RuleSet with deprecated\n    // Rules when the Rules are finally removed.\n    private static final String DEPRECATED_RULE_RULESET_NAME = \"net/sourceforge/pmd/TestRuleset1.xml\";\n\n    // Note: Update this Rule name to a different deprecated Rule when the one\n    // listed here is finally removed.\n    private static final String DEPRECATED_RULE_NAME = \"MockRule3\";\n\n    private static final String REFERENCE_TO_DEPRECATED_RULE = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL\n            + \"<ruleset name=\\\"test\\\">\" + PMD.EOL + \"<description>testdesc</description>\" + PMD.EOL + \"<rule \" + PMD.EOL\n            + \"ref=\\\"\" + DEPRECATED_RULE_RULESET_NAME + \"/\" + DEPRECATED_RULE_NAME + \"\\\">\" + PMD.EOL\n            + \"</rule></ruleset>\";\n\n    private static final String REFERENCE_TO_RULESET_WITH_DEPRECATED_RULE = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL\n            + \"<ruleset name=\\\"test\\\">\" + PMD.EOL + \"<description>testdesc</description>\" + PMD.EOL + \"<rule \" + PMD.EOL\n            + \"ref=\\\"\" + DEPRECATED_RULE_RULESET_NAME + \"\\\">\" + PMD.EOL + \"</rule></ruleset>\";\n\n    private static final String DFA = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL + \"<ruleset name=\\\"test\\\">\" + PMD.EOL\n            + \"<description>testdesc</description>\" + PMD.EOL + \"<rule \" + PMD.EOL + \"name=\\\"MockRuleName\\\" \" + PMD.EOL\n            + \"message=\\\"avoid the mock rule\\\" \" + PMD.EOL + \"dfa=\\\"true\\\" \" + PMD.EOL\n            + \"class=\\\"net.sourceforge.pmd.lang.rule.MockRule\\\">\" + \"<priority>3</priority>\" + PMD.EOL\n            + \"</rule></ruleset>\";\n\n    private static final String INCLUDE_EXCLUDE_RULESET = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL\n            + \"<ruleset name=\\\"test\\\">\" + PMD.EOL + \"<description>testdesc</description>\" + PMD.EOL\n            + \"<include-pattern>include1</include-pattern>\" + PMD.EOL + \"<include-pattern>include2</include-pattern>\"\n            + PMD.EOL + \"<exclude-pattern>exclude1</exclude-pattern>\" + PMD.EOL\n            + \"<exclude-pattern>exclude2</exclude-pattern>\" + PMD.EOL + \"<exclude-pattern>exclude3</exclude-pattern>\"\n            + PMD.EOL + \"</ruleset>\";\n\n    private static final String EXTERNAL_REFERENCE_RULE_SET = \"<?xml version=\\\"1.0\\\"?>\" + PMD.EOL\n            + \"<ruleset name=\\\"test\\\">\" + PMD.EOL + \"<description>testdesc</description>\" + PMD.EOL\n            + \"<rule ref=\\\"net/sourceforge/pmd/external-reference-ruleset.xml/MockRule\\\"/>\" + PMD.EOL + \"</ruleset>\";\n\n    private Rule loadFirstRule(String ruleSetXml) throws RuleSetNotFoundException {\n        RuleSet rs = loadRuleSet(ruleSetXml);\n        return rs.getRules().iterator().next();\n    }\n\n    private RuleSet loadRuleSet(String ruleSetXml) throws RuleSetNotFoundException {\n        RuleSetFactory rsf = RulesetsFactoryUtils.defaultFactory();\n        return rsf.createRuleSet(createRuleSetReferenceId(ruleSetXml));\n    }\n\n    private RuleSet loadRuleSetWithDeprecationWarnings(String ruleSetXml) throws RuleSetNotFoundException {\n        RuleSetFactory rsf = RulesetsFactoryUtils.createFactory(RulePriority.LOW, true, false);\n        return rsf.createRuleSet(createRuleSetReferenceId(ruleSetXml));\n    }\n\n    private static RuleSetReferenceId createRuleSetReferenceId(final String ruleSetXml) {\n        return new RuleSetReferenceId(null) {\n            @Override\n            public InputStream getInputStream(ResourceLoader resourceLoader) throws RuleSetNotFoundException {\n                try {\n                    return new ByteArrayInputStream(ruleSetXml.getBytes(\"UTF-8\"));\n                } catch (UnsupportedEncodingException e) {\n                    return null;\n                }\n            }\n        };\n    }\n}\n",
        "diffSourceCodeSet": [
            "assertEquals(2, rs.size());\n        Set<String> expected = new HashSet<>();\n        expected.add(\"MockRuleName1\");\n        expected.add(\"MockRuleName2\");\n        for (Rule rule : rs.getRules()) {\n            assertTrue(expected.contains(rule.getName()));\n        }\n    }\n\n    @Test\n    public void testSingleRuleWithPriority() throws RuleSetNotFoundException {\n        assertEquals(RulePriority.MEDIUM, loadFirstRule(PRIORITY).getPriority());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testProps() throws RuleSetNotFoundException {\n        Rule r = loadFirstRule(PROPERTIES);\n        assertEquals(\"bar\", r.getProperty((PropertyDescriptor<String>) r.getPropertyDescriptor(\"fooString\")));"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.AbstractRuleSetFactoryTest#createRuleSetReferenceId\n methodBody: protected static RuleSetReferenceId createRuleSetReferenceId(final String ruleSetXml) {\nreturn new RuleSetReferenceId(null){\n  @Override public InputStream getInputStream(  ResourceLoader resourceLoader) throws RuleSetNotFoundException {\n    try {\n      return new ByteArrayInputStream(ruleSetXml.getBytes(\"UTF-8\"));\n    }\n catch (    UnsupportedEncodingException e) {\n      return null;\n    }\n  }\n}\n;\n}",
            "methodSignature: net.sourceforge.pmd.RuleSetFactoryTest#createRuleSetReferenceId\n methodBody: private static RuleSetReferenceId createRuleSetReferenceId(final String ruleSetXml) {\nreturn new RuleSetReferenceId(null){\n  @Override public InputStream getInputStream(  ResourceLoader resourceLoader) throws RuleSetNotFoundException {\n    try {\n      return new ByteArrayInputStream(ruleSetXml.getBytes(\"UTF-8\"));\n    }\n catch (    UnsupportedEncodingException e) {\n      return null;\n    }\n  }\n}\n;\n}",
            "methodSignature: net.sourceforge.pmd.RuleSetFactory#createRuleSet\n methodBody: private RuleSet createRuleSet(RuleSetReferenceId ruleSetReferenceId, boolean withDeprecatedRuleReferences)\n            throws RuleSetNotFoundException {\nreturn parseRuleSetNode(ruleSetReferenceId,withDeprecatedRuleReferences);\n}"
        ],
        "sourceCodeAfterRefactoring": "private RuleSet loadRuleSetWithDeprecationWarnings(String ruleSetXml) throws RuleSetNotFoundException {\n        RuleSetFactory rsf = RulesetsFactoryUtils.createFactory(RulePriority.LOW, true, false);\n        return rsf.createRuleSet(createRuleSetReferenceId(ruleSetXml));\n    }\nassertEquals(2, rs.size());\n        Set<String> expected = new HashSet<>();\n        expected.add(\"MockRuleName1\");\n        expected.add(\"MockRuleName2\");\n        for (Rule rule : rs.getRules()) {\n            assertTrue(expected.contains(rule.getName()));\n        }\n    }\n\n    @Test\n    public void testSingleRuleWithPriority() throws RuleSetNotFoundException {\n        assertEquals(RulePriority.MEDIUM, loadFirstRule(PRIORITY).getPriority());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testProps() throws RuleSetNotFoundException {\n        Rule r = loadFirstRule(PROPERTIES);\n        assertEquals(\"bar\", r.getProperty((PropertyDescriptor<String>) r.getPropertyDescriptor(\"fooString\")));",
        "diffSourceCode": "   154:         assertEquals(2, rs.size());\n   155:         Set<String> expected = new HashSet<>();\n   156:         expected.add(\"MockRuleName1\");\n   157:         expected.add(\"MockRuleName2\");\n   158:         for (Rule rule : rs.getRules()) {\n   159:             assertTrue(expected.contains(rule.getName()));\n   160:         }\n   161:     }\n   162: \n   163:     @Test\n   164:     public void testSingleRuleWithPriority() throws RuleSetNotFoundException {\n   165:         assertEquals(RulePriority.MEDIUM, loadFirstRule(PRIORITY).getPriority());\n   166:     }\n   167: \n   168:     @Test\n   169:     @SuppressWarnings(\"unchecked\")\n   170:     public void testProps() throws RuleSetNotFoundException {\n   171:         Rule r = loadFirstRule(PROPERTIES);\n   172:         assertEquals(\"bar\", r.getProperty((PropertyDescriptor<String>) r.getPropertyDescriptor(\"fooString\")));\n  1102:     private RuleSet loadRuleSetWithDeprecationWarnings(String ruleSetXml) throws RuleSetNotFoundException {\n- 1103:         RuleSetFactory rsf = new RuleSetFactory(new ResourceLoader(), RulePriority.LOW, true, false);\n+ 1103:         RuleSetFactory rsf = RulesetsFactoryUtils.createFactory(RulePriority.LOW, true, false);\n  1104:         return rsf.createRuleSet(createRuleSetReferenceId(ruleSetXml));\n  1105:     }\n",
        "uniqueId": "05870c98cc05805d6272d12f5080afad3a14e2b6_1102_1105_154_172_1102_1105",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic defaultFactory() : RuleSetFactory extracted from public testExclusionOfUselessParantheses() : void in class net.sourceforge.pmd.RuleSetFactoryTest & moved to class net.sourceforge.pmd.RulesetsFactoryUtils",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/test/java/net/sourceforge/pmd/RuleSetFactoryTest.java",
                "startLine": 16,
                "endLine": 30,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/test/java/net/sourceforge/pmd/RuleSetFactoryTest.java",
                "startLine": 16,
                "endLine": 30,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/test/java/net/sourceforge/pmd/RuleSetFactoryTest.java",
                "startLine": 101,
                "endLine": 111,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n    public void testExclusionOfUselessParantheses() throws RuleSetNotFoundException {\n        RuleSetReferenceId ref = createRuleSetReferenceId(\n                \"<?xml version=\\\"1.0\\\"?>\\n\" + \"<ruleset name=\\\"Custom ruleset for tests\\\"\\n\"\n                        + \"    xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                        + \"    xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                        + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                        + \"  <description>Custom ruleset for tests</description>\\n\"\n                        + \"  <rule ref=\\\"category/java/codestyle.xml\\\">\\n\"\n                        + \"    <exclude name=\\\"UselessParentheses\\\"/>\\n\" + \"  </rule>\\n\" + \"</ruleset>\\n\");\n        RuleSetFactory ruleSetFactory = new RuleSetFactory();\n        RuleSet ruleset = ruleSetFactory.createRuleSet(ref);\n        Rule rule = ruleset.getRuleByName(\"UselessParentheses\");\n        assertNull(rule);\n    }",
        "filePathBefore": "pmd-java/src/test/java/net/sourceforge/pmd/RuleSetFactoryTest.java",
        "isPureRefactoring": true,
        "commitId": "05870c98cc05805d6272d12f5080afad3a14e2b6",
        "packageNameBefore": "net.sourceforge.pmd",
        "classNameBefore": "net.sourceforge.pmd.RuleSetFactoryTest",
        "methodNameBefore": "net.sourceforge.pmd.RuleSetFactoryTest#testExclusionOfUselessParantheses",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.AbstractRuleSetFactoryTest#createRuleSetReferenceId\n methodBody: protected static RuleSetReferenceId createRuleSetReferenceId(final String ruleSetXml) {\nreturn new RuleSetReferenceId(null){\n  @Override public InputStream getInputStream(  ResourceLoader resourceLoader) throws RuleSetNotFoundException {\n    try {\n      return new ByteArrayInputStream(ruleSetXml.getBytes(\"UTF-8\"));\n    }\n catch (    UnsupportedEncodingException e) {\n      return null;\n    }\n  }\n}\n;\n}\nmethodSignature: net.sourceforge.pmd.RuleSetFactoryTest#createRuleSetReferenceId\n methodBody: private static RuleSetReferenceId createRuleSetReferenceId(final String ruleSetXml) {\nreturn new RuleSetReferenceId(null){\n  @Override public InputStream getInputStream(  ResourceLoader resourceLoader) throws RuleSetNotFoundException {\n    try {\n      return new ByteArrayInputStream(ruleSetXml.getBytes(\"UTF-8\"));\n    }\n catch (    UnsupportedEncodingException e) {\n      return null;\n    }\n  }\n}\n;\n}\nmethodSignature: net.sourceforge.pmd.RuleSetFactory#createRuleSet\n methodBody: private RuleSet createRuleSet(RuleSetReferenceId ruleSetReferenceId, boolean withDeprecatedRuleReferences)\n            throws RuleSetNotFoundException {\nreturn parseRuleSetNode(ruleSetReferenceId,withDeprecatedRuleReferences);\n}",
        "classSignatureBefore": "public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest \npublic class RuleSetFactoryTest ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.RuleSetFactoryTest#testExclusionOfUselessParantheses"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.RuleSetFactoryTest"
        ],
        "classSignatureBeforeSet": [
            "public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest ",
            "public class RuleSetFactoryTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd;\n\nimport static org.junit.Assert.assertNull;\n\nimport org.junit.Test;\n\n/**\n * Test java's rulesets\n */\npublic class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {\n\n    @Test\n    public void testExclusionOfUselessParantheses() throws RuleSetNotFoundException {\n        RuleSetReferenceId ref = createRuleSetReferenceId(\n                \"<?xml version=\\\"1.0\\\"?>\\n\" + \"<ruleset name=\\\"Custom ruleset for tests\\\"\\n\"\n                        + \"    xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                        + \"    xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                        + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                        + \"  <description>Custom ruleset for tests</description>\\n\"\n                        + \"  <rule ref=\\\"category/java/codestyle.xml\\\">\\n\"\n                        + \"    <exclude name=\\\"UselessParentheses\\\"/>\\n\" + \"  </rule>\\n\" + \"</ruleset>\\n\");\n        RuleSetFactory ruleSetFactory = new RuleSetFactory();\n        RuleSet ruleset = ruleSetFactory.createRuleSet(ref);\n        Rule rule = ruleset.getRuleByName(\"UselessParentheses\");\n        assertNull(rule);\n    }\n}\n",
        "filePathAfter": "pmd-java/src/test/java/net/sourceforge/pmd/RuleSetFactoryTest.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd;\n\nimport static org.junit.Assert.assertNull;\n\nimport org.junit.Test;\n\n/**\n * Test java's rulesets\n */\npublic class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {\n\n    @Test\n    public void testExclusionOfUselessParantheses() throws RuleSetNotFoundException {\n        RuleSetReferenceId ref = createRuleSetReferenceId(\n                \"<?xml version=\\\"1.0\\\"?>\\n\" + \"<ruleset name=\\\"Custom ruleset for tests\\\"\\n\"\n                        + \"    xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                        + \"    xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                        + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                        + \"  <description>Custom ruleset for tests</description>\\n\"\n                        + \"  <rule ref=\\\"category/java/codestyle.xml\\\">\\n\"\n                        + \"    <exclude name=\\\"UselessParentheses\\\"/>\\n\" + \"  </rule>\\n\" + \"</ruleset>\\n\");\n        RuleSetFactory ruleSetFactory = RulesetsFactoryUtils.defaultFactory();\n        RuleSet ruleset = ruleSetFactory.createRuleSet(ref);\n        Rule rule = ruleset.getRuleByName(\"UselessParentheses\");\n        assertNull(rule);\n    }\n}\n",
        "diffSourceCodeSet": [
            ""
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.AbstractRuleSetFactoryTest#createRuleSetReferenceId\n methodBody: protected static RuleSetReferenceId createRuleSetReferenceId(final String ruleSetXml) {\nreturn new RuleSetReferenceId(null){\n  @Override public InputStream getInputStream(  ResourceLoader resourceLoader) throws RuleSetNotFoundException {\n    try {\n      return new ByteArrayInputStream(ruleSetXml.getBytes(\"UTF-8\"));\n    }\n catch (    UnsupportedEncodingException e) {\n      return null;\n    }\n  }\n}\n;\n}",
            "methodSignature: net.sourceforge.pmd.RuleSetFactoryTest#createRuleSetReferenceId\n methodBody: private static RuleSetReferenceId createRuleSetReferenceId(final String ruleSetXml) {\nreturn new RuleSetReferenceId(null){\n  @Override public InputStream getInputStream(  ResourceLoader resourceLoader) throws RuleSetNotFoundException {\n    try {\n      return new ByteArrayInputStream(ruleSetXml.getBytes(\"UTF-8\"));\n    }\n catch (    UnsupportedEncodingException e) {\n      return null;\n    }\n  }\n}\n;\n}",
            "methodSignature: net.sourceforge.pmd.RuleSetFactory#createRuleSet\n methodBody: private RuleSet createRuleSet(RuleSetReferenceId ruleSetReferenceId, boolean withDeprecatedRuleReferences)\n            throws RuleSetNotFoundException {\nreturn parseRuleSetNode(ruleSetReferenceId,withDeprecatedRuleReferences);\n}"
        ],
        "sourceCodeAfterRefactoring": "@Test\n    public void testExclusionOfUselessParantheses() throws RuleSetNotFoundException {\n        RuleSetReferenceId ref = createRuleSetReferenceId(\n                \"<?xml version=\\\"1.0\\\"?>\\n\" + \"<ruleset name=\\\"Custom ruleset for tests\\\"\\n\"\n                        + \"    xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n                        + \"    xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n                        + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n                        + \"  <description>Custom ruleset for tests</description>\\n\"\n                        + \"  <rule ref=\\\"category/java/codestyle.xml\\\">\\n\"\n                        + \"    <exclude name=\\\"UselessParentheses\\\"/>\\n\" + \"  </rule>\\n\" + \"</ruleset>\\n\");\n        RuleSetFactory ruleSetFactory = RulesetsFactoryUtils.defaultFactory();\n        RuleSet ruleset = ruleSetFactory.createRuleSet(ref);\n        Rule rule = ruleset.getRuleByName(\"UselessParentheses\");\n        assertNull(rule);\n    }\n",
        "diffSourceCode": "    16:     @Test\n    17:     public void testExclusionOfUselessParantheses() throws RuleSetNotFoundException {\n    18:         RuleSetReferenceId ref = createRuleSetReferenceId(\n    19:                 \"<?xml version=\\\"1.0\\\"?>\\n\" + \"<ruleset name=\\\"Custom ruleset for tests\\\"\\n\"\n    20:                         + \"    xmlns=\\\"http://pmd.sourceforge.net/ruleset/2.0.0\\\"\\n\"\n    21:                         + \"    xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\"\n    22:                         + \"    xsi:schemaLocation=\\\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\\\">\\n\"\n    23:                         + \"  <description>Custom ruleset for tests</description>\\n\"\n    24:                         + \"  <rule ref=\\\"category/java/codestyle.xml\\\">\\n\"\n    25:                         + \"    <exclude name=\\\"UselessParentheses\\\"/>\\n\" + \"  </rule>\\n\" + \"</ruleset>\\n\");\n-   26:         RuleSetFactory ruleSetFactory = new RuleSetFactory();\n+   26:         RuleSetFactory ruleSetFactory = RulesetsFactoryUtils.defaultFactory();\n    27:         RuleSet ruleset = ruleSetFactory.createRuleSet(ref);\n    28:         Rule rule = ruleset.getRuleByName(\"UselessParentheses\");\n    29:         assertNull(rule);\n    30:     }\n",
        "uniqueId": "05870c98cc05805d6272d12f5080afad3a14e2b6_16_30_101_111_16_30",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic defaultFactory() : RuleSetFactory extracted from public resolveAllRulesets() : void in class net.sourceforge.pmd.docs.RuleSetResolverTest & moved to class net.sourceforge.pmd.RulesetsFactoryUtils",
        "diffLocations": [
            {
                "filePath": "pmd-doc/src/test/java/net/sourceforge/pmd/docs/RuleSetResolverTest.java",
                "startLine": 29,
                "endLine": 44,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-doc/src/test/java/net/sourceforge/pmd/docs/RuleSetResolverTest.java",
                "startLine": 30,
                "endLine": 45,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-doc/src/test/java/net/sourceforge/pmd/docs/RuleSetResolverTest.java",
                "startLine": 101,
                "endLine": 111,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n    public void resolveAllRulesets() {\n        Path basePath = FileSystems.getDefault().getPath(\".\").resolve(\"..\").toAbsolutePath().normalize();\n        List<String> additionalRulesets = GenerateRuleDocsCmd.findAdditionalRulesets(basePath);\n    \n        filterRuleSets(additionalRulesets);\n\n        RuleSetFactory ruleSetFactory = new RuleSetFactory();\n        for (String filename : additionalRulesets) {\n            try {\n                ruleSetFactory.createRuleSet(filename);\n            } catch (RuntimeException | RuleSetNotFoundException e) {\n                fail(\"Couldn't load ruleset \" + filename + \": \" + e.getMessage());\n            }\n        }\n    }",
        "filePathBefore": "pmd-doc/src/test/java/net/sourceforge/pmd/docs/RuleSetResolverTest.java",
        "isPureRefactoring": true,
        "commitId": "05870c98cc05805d6272d12f5080afad3a14e2b6",
        "packageNameBefore": "net.sourceforge.pmd.docs",
        "classNameBefore": "net.sourceforge.pmd.docs.RuleSetResolverTest",
        "methodNameBefore": "net.sourceforge.pmd.docs.RuleSetResolverTest#resolveAllRulesets",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.docs.RuleSetResolverTest#filterRuleSets\n methodBody: private void filterRuleSets(List<String> additionalRulesets) {\nIterator<String> it=additionalRulesets.iterator();\nwhile(it.hasNext()){String filename=it.next();\nfor(String exclusion: excludedRulesets){if(filename.endsWith(exclusion)){it.remove();\nbreak;\n}}}}\nmethodSignature: net.sourceforge.pmd.RuleSetFactory#createRuleSet\n methodBody: private RuleSet createRuleSet(RuleSetReferenceId ruleSetReferenceId, boolean withDeprecatedRuleReferences)\n            throws RuleSetNotFoundException {\nreturn parseRuleSetNode(ruleSetReferenceId,withDeprecatedRuleReferences);\n}\nmethodSignature: net.sourceforge.pmd.docs.GenerateRuleDocsCmd#findAdditionalRulesets\n methodBody: public static List<String> findAdditionalRulesets(Path basePath) {\ntryList<String> additionalRulesets=new ArrayList<>();\nPattern rulesetPattern=Pattern.compile(\"^.+\" + Pattern.quote(File.separator) + \"pmd-\\\\w+\" + Pattern.quote(FilenameUtils.normalize(\"/src/main/resources/rulesets/\")) + \"\\\\w+\" + Pattern.quote(File.separator) + \"\\\\w+.xml$\");\nFiles.walkFileTree(basePath,new SimpleFileVisitor<Path>(){\n  @Override public FileVisitResult visitFile(  Path file,  BasicFileAttributes attrs) throws IOException {\n    if (rulesetPattern.matcher(file.toString()).matches()) {\n      additionalRulesets.add(file.toString());\n    }\n    return FileVisitResult.CONTINUE;\n  }\n}\n);\nreturn additionalRulesets;\ncatch(IOException e)throw new RuntimeException(e);\n}",
        "classSignatureBefore": "public class RuleSetResolverTest ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.docs.RuleSetResolverTest#resolveAllRulesets"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.docs.RuleSetResolverTest"
        ],
        "classSignatureBeforeSet": [
            "public class RuleSetResolverTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.docs;\n\nimport static org.junit.Assert.fail;\n\nimport java.nio.file.FileSystems;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.apache.commons.io.FilenameUtils;\nimport org.junit.Test;\n\nimport net.sourceforge.pmd.RuleSetFactory;\nimport net.sourceforge.pmd.RuleSetNotFoundException;\n\npublic class RuleSetResolverTest {\n\n    private static List<String> excludedRulesets = new ArrayList<>();\n\n    static {\n        excludedRulesets.add(FilenameUtils.normalize(\"pmd-test/src/main/resources/rulesets/dummy/basic.xml\"));\n    }\n\n    @Test\n    public void resolveAllRulesets() {\n        Path basePath = FileSystems.getDefault().getPath(\".\").resolve(\"..\").toAbsolutePath().normalize();\n        List<String> additionalRulesets = GenerateRuleDocsCmd.findAdditionalRulesets(basePath);\n    \n        filterRuleSets(additionalRulesets);\n\n        RuleSetFactory ruleSetFactory = new RuleSetFactory();\n        for (String filename : additionalRulesets) {\n            try {\n                ruleSetFactory.createRuleSet(filename);\n            } catch (RuntimeException | RuleSetNotFoundException e) {\n                fail(\"Couldn't load ruleset \" + filename + \": \" + e.getMessage());\n            }\n        }\n    }\n\n    private void filterRuleSets(List<String> additionalRulesets) {\n        Iterator<String> it = additionalRulesets.iterator();\n        while (it.hasNext()) {\n            String filename = it.next();\n            for (String exclusion : excludedRulesets) {\n                if (filename.endsWith(exclusion)) {\n                    it.remove();\n                    break;\n                }\n            }\n        }\n    }\n}\n",
        "filePathAfter": "pmd-doc/src/test/java/net/sourceforge/pmd/docs/RuleSetResolverTest.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.docs;\n\nimport static org.junit.Assert.fail;\n\nimport java.nio.file.FileSystems;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.apache.commons.io.FilenameUtils;\nimport org.junit.Test;\n\nimport net.sourceforge.pmd.RuleSetFactory;\nimport net.sourceforge.pmd.RuleSetNotFoundException;\nimport net.sourceforge.pmd.RulesetsFactoryUtils;\n\npublic class RuleSetResolverTest {\n\n    private static List<String> excludedRulesets = new ArrayList<>();\n\n    static {\n        excludedRulesets.add(FilenameUtils.normalize(\"pmd-test/src/main/resources/rulesets/dummy/basic.xml\"));\n    }\n\n    @Test\n    public void resolveAllRulesets() {\n        Path basePath = FileSystems.getDefault().getPath(\".\").resolve(\"..\").toAbsolutePath().normalize();\n        List<String> additionalRulesets = GenerateRuleDocsCmd.findAdditionalRulesets(basePath);\n\n        filterRuleSets(additionalRulesets);\n\n        RuleSetFactory ruleSetFactory = RulesetsFactoryUtils.defaultFactory();\n        for (String filename : additionalRulesets) {\n            try {\n                ruleSetFactory.createRuleSet(filename);\n            } catch (RuntimeException | RuleSetNotFoundException e) {\n                fail(\"Couldn't load ruleset \" + filename + \": \" + e.getMessage());\n            }\n        }\n    }\n\n    private void filterRuleSets(List<String> additionalRulesets) {\n        Iterator<String> it = additionalRulesets.iterator();\n        while (it.hasNext()) {\n            String filename = it.next();\n            for (String exclusion : excludedRulesets) {\n                if (filename.endsWith(exclusion)) {\n                    it.remove();\n                    break;\n                }\n            }\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            ""
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.docs.RuleSetResolverTest#filterRuleSets\n methodBody: private void filterRuleSets(List<String> additionalRulesets) {\nIterator<String> it=additionalRulesets.iterator();\nwhile(it.hasNext()){String filename=it.next();\nfor(String exclusion: excludedRulesets){if(filename.endsWith(exclusion)){it.remove();\nbreak;\n}}}}",
            "methodSignature: net.sourceforge.pmd.RuleSetFactory#createRuleSet\n methodBody: private RuleSet createRuleSet(RuleSetReferenceId ruleSetReferenceId, boolean withDeprecatedRuleReferences)\n            throws RuleSetNotFoundException {\nreturn parseRuleSetNode(ruleSetReferenceId,withDeprecatedRuleReferences);\n}",
            "methodSignature: net.sourceforge.pmd.docs.GenerateRuleDocsCmd#findAdditionalRulesets\n methodBody: public static List<String> findAdditionalRulesets(Path basePath) {\ntryList<String> additionalRulesets=new ArrayList<>();\nPattern rulesetPattern=Pattern.compile(\"^.+\" + Pattern.quote(File.separator) + \"pmd-\\\\w+\" + Pattern.quote(FilenameUtils.normalize(\"/src/main/resources/rulesets/\")) + \"\\\\w+\" + Pattern.quote(File.separator) + \"\\\\w+.xml$\");\nFiles.walkFileTree(basePath,new SimpleFileVisitor<Path>(){\n  @Override public FileVisitResult visitFile(  Path file,  BasicFileAttributes attrs) throws IOException {\n    if (rulesetPattern.matcher(file.toString()).matches()) {\n      additionalRulesets.add(file.toString());\n    }\n    return FileVisitResult.CONTINUE;\n  }\n}\n);\nreturn additionalRulesets;\ncatch(IOException e)throw new RuntimeException(e);\n}"
        ],
        "sourceCodeAfterRefactoring": "@Test\n    public void resolveAllRulesets() {\n        Path basePath = FileSystems.getDefault().getPath(\".\").resolve(\"..\").toAbsolutePath().normalize();\n        List<String> additionalRulesets = GenerateRuleDocsCmd.findAdditionalRulesets(basePath);\n\n        filterRuleSets(additionalRulesets);\n\n        RuleSetFactory ruleSetFactory = RulesetsFactoryUtils.defaultFactory();\n        for (String filename : additionalRulesets) {\n            try {\n                ruleSetFactory.createRuleSet(filename);\n            } catch (RuntimeException | RuleSetNotFoundException e) {\n                fail(\"Couldn't load ruleset \" + filename + \": \" + e.getMessage());\n            }\n        }\n    }\n",
        "diffSourceCode": "-   29:     @Test\n-   30:     public void resolveAllRulesets() {\n-   31:         Path basePath = FileSystems.getDefault().getPath(\".\").resolve(\"..\").toAbsolutePath().normalize();\n-   32:         List<String> additionalRulesets = GenerateRuleDocsCmd.findAdditionalRulesets(basePath);\n-   33:     \n-   34:         filterRuleSets(additionalRulesets);\n-   35: \n-   36:         RuleSetFactory ruleSetFactory = new RuleSetFactory();\n-   37:         for (String filename : additionalRulesets) {\n-   38:             try {\n-   39:                 ruleSetFactory.createRuleSet(filename);\n-   40:             } catch (RuntimeException | RuleSetNotFoundException e) {\n-   41:                 fail(\"Couldn't load ruleset \" + filename + \": \" + e.getMessage());\n-   42:             }\n-   43:         }\n-   44:     }\n-   45: \n+   29: \n+   30:     @Test\n+   31:     public void resolveAllRulesets() {\n+   32:         Path basePath = FileSystems.getDefault().getPath(\".\").resolve(\"..\").toAbsolutePath().normalize();\n+   33:         List<String> additionalRulesets = GenerateRuleDocsCmd.findAdditionalRulesets(basePath);\n+   34: \n+   35:         filterRuleSets(additionalRulesets);\n+   36: \n+   37:         RuleSetFactory ruleSetFactory = RulesetsFactoryUtils.defaultFactory();\n+   38:         for (String filename : additionalRulesets) {\n+   39:             try {\n+   40:                 ruleSetFactory.createRuleSet(filename);\n+   41:             } catch (RuntimeException | RuleSetNotFoundException e) {\n+   42:                 fail(\"Couldn't load ruleset \" + filename + \": \" + e.getMessage());\n+   43:             }\n+   44:         }\n+   45:     }\n",
        "uniqueId": "05870c98cc05805d6272d12f5080afad3a14e2b6_29_44_101_111_30_45",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic defaultFactory() : RuleSetFactory extracted from public testSingleRuleset() : void in class net.sourceforge.pmd.docs.RuleDocGeneratorTest & moved to class net.sourceforge.pmd.RulesetsFactoryUtils",
        "diffLocations": [
            {
                "filePath": "pmd-doc/src/test/java/net/sourceforge/pmd/docs/RuleDocGeneratorTest.java",
                "startLine": 75,
                "endLine": 99,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-doc/src/test/java/net/sourceforge/pmd/docs/RuleDocGeneratorTest.java",
                "startLine": 76,
                "endLine": 100,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-doc/src/test/java/net/sourceforge/pmd/docs/RuleDocGeneratorTest.java",
                "startLine": 101,
                "endLine": 111,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n    public void testSingleRuleset() throws RuleSetNotFoundException, IOException {\n        RuleDocGenerator generator = new RuleDocGenerator(writer, root);\n\n        RuleSetFactory rsf = new RuleSetFactory();\n        RuleSet ruleset = rsf.createRuleSet(\"rulesets/ruledoctest/sample.xml\");\n\n        generator.generate(Arrays.asList(ruleset).iterator(),\n                Arrays.asList(\n                        \"rulesets/ruledoctest/sample-deprecated.xml\",\n                        \"rulesets/ruledoctest/other-ruleset.xml\"));\n\n        assertEquals(3, writer.getData().size());\n        FileEntry languageIndex = writer.getData().get(0);\n        assertTrue(FilenameUtils.normalize(languageIndex.getFilename(), true).endsWith(\"docs/pages/pmd/rules/java.md\"));\n        assertEquals(loadResource(\"/expected/java.md\"), languageIndex.getContent());\n\n        FileEntry ruleSetIndex = writer.getData().get(1);\n        assertTrue(FilenameUtils.normalize(ruleSetIndex.getFilename(), true).endsWith(\"docs/pages/pmd/rules/java/sample.md\"));\n        assertEquals(loadResource(\"/expected/sample.md\"), ruleSetIndex.getContent());\n\n        FileEntry sidebar = writer.getData().get(2);\n        assertTrue(FilenameUtils.normalize(sidebar.getFilename(), true).endsWith(\"docs/_data/sidebars/pmd_sidebar.yml\"));\n        assertEquals(loadResource(\"/expected/pmd_sidebar.yml\"), sidebar.getContent());\n    }",
        "filePathBefore": "pmd-doc/src/test/java/net/sourceforge/pmd/docs/RuleDocGeneratorTest.java",
        "isPureRefactoring": true,
        "commitId": "05870c98cc05805d6272d12f5080afad3a14e2b6",
        "packageNameBefore": "net.sourceforge.pmd.docs",
        "classNameBefore": "net.sourceforge.pmd.docs.RuleDocGeneratorTest",
        "methodNameBefore": "net.sourceforge.pmd.docs.RuleDocGeneratorTest#testSingleRuleset",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.docs.RuleDocGenerator#generate\n methodBody: public void generate(Iterator<RuleSet> registeredRulesets, List<String> additionalRulesets) {\nMap<Language,List<RuleSet>> sortedRulesets;\nMap<Language,List<RuleSet>> sortedAdditionalRulesets;\ntrysortedRulesets=sortRulesets(registeredRulesets);\nsortedAdditionalRulesets=sortRulesets(resolveAdditionalRulesets(additionalRulesets));\ngenerateLanguageIndex(sortedRulesets,sortedAdditionalRulesets);\ngenerateRuleSetIndex(sortedRulesets);\ngenerateSidebar(sortedRulesets);\ncatch(RuleSetNotFoundException|IOException e)throw new RuntimeException(e);\n}\nmethodSignature: net.sourceforge.pmd.docs.RuleDocGeneratorTest#loadResource\n methodBody: private static String loadResource(String name) throws IOException {\nreturn MockedFileWriter.normalizeLineSeparators(IOUtils.toString(RuleDocGeneratorTest.class.getResourceAsStream(name),StandardCharsets.UTF_8));\n}\nmethodSignature: net.sourceforge.pmd.RuleSetFactory#createRuleSet\n methodBody: private RuleSet createRuleSet(RuleSetReferenceId ruleSetReferenceId, boolean withDeprecatedRuleReferences)\n            throws RuleSetNotFoundException {\nreturn parseRuleSetNode(ruleSetReferenceId,withDeprecatedRuleReferences);\n}",
        "classSignatureBefore": "public class RuleDocGeneratorTest ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.docs.RuleDocGeneratorTest#testSingleRuleset"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.docs.RuleDocGeneratorTest"
        ],
        "classSignatureBeforeSet": [
            "public class RuleDocGeneratorTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.docs;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.SimpleFileVisitor;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.apache.commons.io.FilenameUtils;\nimport org.apache.commons.io.IOUtils;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport net.sourceforge.pmd.RuleSet;\nimport net.sourceforge.pmd.RuleSetFactory;\nimport net.sourceforge.pmd.RuleSetNotFoundException;\nimport net.sourceforge.pmd.docs.MockedFileWriter.FileEntry;\n\npublic class RuleDocGeneratorTest {\n\n    private MockedFileWriter writer = new MockedFileWriter();\n    private Path root;\n\n    @Before\n    public void setup() throws IOException {\n        writer.reset();\n\n        root = Files.createTempDirectory(\"pmd-ruledocgenerator-test\");\n        Files.createDirectories(root.resolve(\"docs/_data/sidebars\"));\n        List<String> mockedSidebar = Arrays.asList(\n                \"entries:\",\n                \"- title: sidebar\",\n                \"  folders:\",\n                \"  - title: 1\",\n                \"  - title: 2\",\n                \"  - title: 3\",\n                \"  - title: Rules\");\n        Files.write(root.resolve(\"docs/_data/sidebars/pmd_sidebar.yml\"), mockedSidebar);\n    }\n\n    @After\n    public void cleanup() throws IOException {\n        Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n            @Override\n            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n                Files.delete(file);\n                return FileVisitResult.CONTINUE;\n            }\n\n            @Override\n            public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n                Files.delete(dir);\n                return FileVisitResult.CONTINUE;\n            }\n        });\n    }\n\n    private static String loadResource(String name) throws IOException {\n        return MockedFileWriter.normalizeLineSeparators(\n                IOUtils.toString(RuleDocGeneratorTest.class.getResourceAsStream(name), StandardCharsets.UTF_8));\n    }\n\n    @Test\n    public void testSingleRuleset() throws RuleSetNotFoundException, IOException {\n        RuleDocGenerator generator = new RuleDocGenerator(writer, root);\n\n        RuleSetFactory rsf = new RuleSetFactory();\n        RuleSet ruleset = rsf.createRuleSet(\"rulesets/ruledoctest/sample.xml\");\n\n        generator.generate(Arrays.asList(ruleset).iterator(),\n                Arrays.asList(\n                        \"rulesets/ruledoctest/sample-deprecated.xml\",\n                        \"rulesets/ruledoctest/other-ruleset.xml\"));\n\n        assertEquals(3, writer.getData().size());\n        FileEntry languageIndex = writer.getData().get(0);\n        assertTrue(FilenameUtils.normalize(languageIndex.getFilename(), true).endsWith(\"docs/pages/pmd/rules/java.md\"));\n        assertEquals(loadResource(\"/expected/java.md\"), languageIndex.getContent());\n\n        FileEntry ruleSetIndex = writer.getData().get(1);\n        assertTrue(FilenameUtils.normalize(ruleSetIndex.getFilename(), true).endsWith(\"docs/pages/pmd/rules/java/sample.md\"));\n        assertEquals(loadResource(\"/expected/sample.md\"), ruleSetIndex.getContent());\n\n        FileEntry sidebar = writer.getData().get(2);\n        assertTrue(FilenameUtils.normalize(sidebar.getFilename(), true).endsWith(\"docs/_data/sidebars/pmd_sidebar.yml\"));\n        assertEquals(loadResource(\"/expected/pmd_sidebar.yml\"), sidebar.getContent());\n    }\n}\n",
        "filePathAfter": "pmd-doc/src/test/java/net/sourceforge/pmd/docs/RuleDocGeneratorTest.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.docs;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.SimpleFileVisitor;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.apache.commons.io.FilenameUtils;\nimport org.apache.commons.io.IOUtils;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport net.sourceforge.pmd.RuleSet;\nimport net.sourceforge.pmd.RuleSetFactory;\nimport net.sourceforge.pmd.RuleSetNotFoundException;\nimport net.sourceforge.pmd.RulesetsFactoryUtils;\nimport net.sourceforge.pmd.docs.MockedFileWriter.FileEntry;\n\npublic class RuleDocGeneratorTest {\n\n    private MockedFileWriter writer = new MockedFileWriter();\n    private Path root;\n\n    @Before\n    public void setup() throws IOException {\n        writer.reset();\n\n        root = Files.createTempDirectory(\"pmd-ruledocgenerator-test\");\n        Files.createDirectories(root.resolve(\"docs/_data/sidebars\"));\n        List<String> mockedSidebar = Arrays.asList(\n                \"entries:\",\n                \"- title: sidebar\",\n                \"  folders:\",\n                \"  - title: 1\",\n                \"  - title: 2\",\n                \"  - title: 3\",\n                \"  - title: Rules\");\n        Files.write(root.resolve(\"docs/_data/sidebars/pmd_sidebar.yml\"), mockedSidebar);\n    }\n\n    @After\n    public void cleanup() throws IOException {\n        Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n            @Override\n            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n                Files.delete(file);\n                return FileVisitResult.CONTINUE;\n            }\n\n            @Override\n            public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n                Files.delete(dir);\n                return FileVisitResult.CONTINUE;\n            }\n        });\n    }\n\n    private static String loadResource(String name) throws IOException {\n        return MockedFileWriter.normalizeLineSeparators(\n                IOUtils.toString(RuleDocGeneratorTest.class.getResourceAsStream(name), StandardCharsets.UTF_8));\n    }\n\n    @Test\n    public void testSingleRuleset() throws RuleSetNotFoundException, IOException {\n        RuleDocGenerator generator = new RuleDocGenerator(writer, root);\n\n        RuleSetFactory rsf = RulesetsFactoryUtils.defaultFactory();\n        RuleSet ruleset = rsf.createRuleSet(\"rulesets/ruledoctest/sample.xml\");\n\n        generator.generate(Arrays.asList(ruleset).iterator(),\n                Arrays.asList(\n                        \"rulesets/ruledoctest/sample-deprecated.xml\",\n                        \"rulesets/ruledoctest/other-ruleset.xml\"));\n\n        assertEquals(3, writer.getData().size());\n        FileEntry languageIndex = writer.getData().get(0);\n        assertTrue(FilenameUtils.normalize(languageIndex.getFilename(), true).endsWith(\"docs/pages/pmd/rules/java.md\"));\n        assertEquals(loadResource(\"/expected/java.md\"), languageIndex.getContent());\n\n        FileEntry ruleSetIndex = writer.getData().get(1);\n        assertTrue(FilenameUtils.normalize(ruleSetIndex.getFilename(), true).endsWith(\"docs/pages/pmd/rules/java/sample.md\"));\n        assertEquals(loadResource(\"/expected/sample.md\"), ruleSetIndex.getContent());\n\n        FileEntry sidebar = writer.getData().get(2);\n        assertTrue(FilenameUtils.normalize(sidebar.getFilename(), true).endsWith(\"docs/_data/sidebars/pmd_sidebar.yml\"));\n        assertEquals(loadResource(\"/expected/pmd_sidebar.yml\"), sidebar.getContent());\n    }\n}\n",
        "diffSourceCodeSet": [
            ""
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.docs.RuleDocGenerator#generate\n methodBody: public void generate(Iterator<RuleSet> registeredRulesets, List<String> additionalRulesets) {\nMap<Language,List<RuleSet>> sortedRulesets;\nMap<Language,List<RuleSet>> sortedAdditionalRulesets;\ntrysortedRulesets=sortRulesets(registeredRulesets);\nsortedAdditionalRulesets=sortRulesets(resolveAdditionalRulesets(additionalRulesets));\ngenerateLanguageIndex(sortedRulesets,sortedAdditionalRulesets);\ngenerateRuleSetIndex(sortedRulesets);\ngenerateSidebar(sortedRulesets);\ncatch(RuleSetNotFoundException|IOException e)throw new RuntimeException(e);\n}",
            "methodSignature: net.sourceforge.pmd.docs.RuleDocGeneratorTest#loadResource\n methodBody: private static String loadResource(String name) throws IOException {\nreturn MockedFileWriter.normalizeLineSeparators(IOUtils.toString(RuleDocGeneratorTest.class.getResourceAsStream(name),StandardCharsets.UTF_8));\n}",
            "methodSignature: net.sourceforge.pmd.RuleSetFactory#createRuleSet\n methodBody: private RuleSet createRuleSet(RuleSetReferenceId ruleSetReferenceId, boolean withDeprecatedRuleReferences)\n            throws RuleSetNotFoundException {\nreturn parseRuleSetNode(ruleSetReferenceId,withDeprecatedRuleReferences);\n}"
        ],
        "sourceCodeAfterRefactoring": "@Test\n    public void testSingleRuleset() throws RuleSetNotFoundException, IOException {\n        RuleDocGenerator generator = new RuleDocGenerator(writer, root);\n\n        RuleSetFactory rsf = RulesetsFactoryUtils.defaultFactory();\n        RuleSet ruleset = rsf.createRuleSet(\"rulesets/ruledoctest/sample.xml\");\n\n        generator.generate(Arrays.asList(ruleset).iterator(),\n                Arrays.asList(\n                        \"rulesets/ruledoctest/sample-deprecated.xml\",\n                        \"rulesets/ruledoctest/other-ruleset.xml\"));\n\n        assertEquals(3, writer.getData().size());\n        FileEntry languageIndex = writer.getData().get(0);\n        assertTrue(FilenameUtils.normalize(languageIndex.getFilename(), true).endsWith(\"docs/pages/pmd/rules/java.md\"));\n        assertEquals(loadResource(\"/expected/java.md\"), languageIndex.getContent());\n\n        FileEntry ruleSetIndex = writer.getData().get(1);\n        assertTrue(FilenameUtils.normalize(ruleSetIndex.getFilename(), true).endsWith(\"docs/pages/pmd/rules/java/sample.md\"));\n        assertEquals(loadResource(\"/expected/sample.md\"), ruleSetIndex.getContent());\n\n        FileEntry sidebar = writer.getData().get(2);\n        assertTrue(FilenameUtils.normalize(sidebar.getFilename(), true).endsWith(\"docs/_data/sidebars/pmd_sidebar.yml\"));\n        assertEquals(loadResource(\"/expected/pmd_sidebar.yml\"), sidebar.getContent());\n    }\n",
        "diffSourceCode": "-   75:     @Test\n-   76:     public void testSingleRuleset() throws RuleSetNotFoundException, IOException {\n-   77:         RuleDocGenerator generator = new RuleDocGenerator(writer, root);\n-   78: \n-   79:         RuleSetFactory rsf = new RuleSetFactory();\n-   80:         RuleSet ruleset = rsf.createRuleSet(\"rulesets/ruledoctest/sample.xml\");\n-   81: \n-   82:         generator.generate(Arrays.asList(ruleset).iterator(),\n-   83:                 Arrays.asList(\n-   84:                         \"rulesets/ruledoctest/sample-deprecated.xml\",\n-   85:                         \"rulesets/ruledoctest/other-ruleset.xml\"));\n-   86: \n-   87:         assertEquals(3, writer.getData().size());\n-   88:         FileEntry languageIndex = writer.getData().get(0);\n-   89:         assertTrue(FilenameUtils.normalize(languageIndex.getFilename(), true).endsWith(\"docs/pages/pmd/rules/java.md\"));\n-   90:         assertEquals(loadResource(\"/expected/java.md\"), languageIndex.getContent());\n-   91: \n-   92:         FileEntry ruleSetIndex = writer.getData().get(1);\n-   93:         assertTrue(FilenameUtils.normalize(ruleSetIndex.getFilename(), true).endsWith(\"docs/pages/pmd/rules/java/sample.md\"));\n-   94:         assertEquals(loadResource(\"/expected/sample.md\"), ruleSetIndex.getContent());\n-   95: \n-   96:         FileEntry sidebar = writer.getData().get(2);\n-   97:         assertTrue(FilenameUtils.normalize(sidebar.getFilename(), true).endsWith(\"docs/_data/sidebars/pmd_sidebar.yml\"));\n-   98:         assertEquals(loadResource(\"/expected/pmd_sidebar.yml\"), sidebar.getContent());\n-   99:     }\n-  100: }\n+   75: \n+   76:     @Test\n+   77:     public void testSingleRuleset() throws RuleSetNotFoundException, IOException {\n+   78:         RuleDocGenerator generator = new RuleDocGenerator(writer, root);\n+   79: \n+   80:         RuleSetFactory rsf = RulesetsFactoryUtils.defaultFactory();\n+   81:         RuleSet ruleset = rsf.createRuleSet(\"rulesets/ruledoctest/sample.xml\");\n+   82: \n+   83:         generator.generate(Arrays.asList(ruleset).iterator(),\n+   84:                 Arrays.asList(\n+   85:                         \"rulesets/ruledoctest/sample-deprecated.xml\",\n+   86:                         \"rulesets/ruledoctest/other-ruleset.xml\"));\n+   87: \n+   88:         assertEquals(3, writer.getData().size());\n+   89:         FileEntry languageIndex = writer.getData().get(0);\n+   90:         assertTrue(FilenameUtils.normalize(languageIndex.getFilename(), true).endsWith(\"docs/pages/pmd/rules/java.md\"));\n+   91:         assertEquals(loadResource(\"/expected/java.md\"), languageIndex.getContent());\n+   92: \n+   93:         FileEntry ruleSetIndex = writer.getData().get(1);\n+   94:         assertTrue(FilenameUtils.normalize(ruleSetIndex.getFilename(), true).endsWith(\"docs/pages/pmd/rules/java/sample.md\"));\n+   95:         assertEquals(loadResource(\"/expected/sample.md\"), ruleSetIndex.getContent());\n+   96: \n+   97:         FileEntry sidebar = writer.getData().get(2);\n+   98:         assertTrue(FilenameUtils.normalize(sidebar.getFilename(), true).endsWith(\"docs/_data/sidebars/pmd_sidebar.yml\"));\n+   99:         assertEquals(loadResource(\"/expected/pmd_sidebar.yml\"), sidebar.getContent());\n+  100:     }\n+  101: }\n",
        "uniqueId": "05870c98cc05805d6272d12f5080afad3a14e2b6_75_99_101_111_76_100",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic loadRuleFromClassPath(clazz String) : Rule extracted from public build() : Rule in class net.sourceforge.pmd.rules.RuleBuilder & moved to class net.sourceforge.pmd.util.ResourceLoader",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/rules/RuleBuilder.java",
                "startLine": 179,
                "endLine": 218,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/rules/RuleBuilder.java",
                "startLine": 182,
                "endLine": 221,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/rules/RuleBuilder.java",
                "startLine": 123,
                "endLine": 134,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public Rule build() throws ClassNotFoundException, IllegalAccessException, InstantiationException {\n        Rule rule = (Rule) RuleBuilder.class.getClassLoader().loadClass(clazz).newInstance();\n\n        rule.setName(name);\n        rule.setRuleClass(clazz);\n\n        if (rule.getLanguage() == null) {\n            rule.setLanguage(language);\n        }\n\n        loadLanguageMinMaxVersions(rule);\n        rule.setSince(since);\n        rule.setMessage(message);\n        rule.setExternalInfoUrl(externalInfoUrl);\n        rule.setDeprecated(isDeprecated);\n        rule.setDescription(description);\n        rule.setPriority(priority == null ? RulePriority.LOW : priority);\n\n        for (String example : examples) {\n            rule.addExample(example);\n        }\n\n        if (isUsesDfa) {\n            rule.setDfa(isUsesDfa);\n        }\n        if (isUsesMultifile) {\n            rule.setMultifile(isUsesMultifile);\n        }\n        if (isUsesTyperesolution) {\n            rule.setTypeResolution(isUsesTyperesolution);\n        }\n\n        for (PropertyDescriptor<?> descriptor : definedProperties) {\n            if (!rule.getPropertyDescriptors().contains(descriptor)) {\n                rule.definePropertyDescriptor(descriptor);\n            }\n        }\n\n        return rule;\n    }",
        "filePathBefore": "pmd-core/src/main/java/net/sourceforge/pmd/rules/RuleBuilder.java",
        "isPureRefactoring": true,
        "commitId": "5c36ee1eba5a08732d6fc53b0a69010a279a10de",
        "packageNameBefore": "net.sourceforge.pmd.rules",
        "classNameBefore": "net.sourceforge.pmd.rules.RuleBuilder",
        "methodNameBefore": "net.sourceforge.pmd.rules.RuleBuilder#build",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.rules.RuleBuilder#loadLanguageMinMaxVersions\n methodBody: private void loadLanguageMinMaxVersions(Rule rule) {\nif(minimumVersion != null){LanguageVersion minimumLanguageVersion=rule.getLanguage().getVersion(minimumVersion);\nif(minimumLanguageVersion == null){throwUnknownLanguageVersionException(\"minimum\",minimumVersion);\n}{rule.setMinimumLanguageVersion(minimumLanguageVersion);\n}}if(maximumVersion != null){LanguageVersion maximumLanguageVersion=rule.getLanguage().getVersion(maximumVersion);\nif(maximumLanguageVersion == null){throwUnknownLanguageVersionException(\"maximum\",maximumVersion);\n}{rule.setMaximumLanguageVersion(maximumLanguageVersion);\n}}checkLanguageVersionsAreOrdered(rule);\n}\nmethodSignature: net.sourceforge.pmd.rules.RuleBuilder#addExample\n methodBody: public void addExample(String example) {\nexamples.add(example);\n}\nmethodSignature: net.sourceforge.pmd.rules.RuleBuilder#setDeprecated\n methodBody: public void setDeprecated(boolean deprecated) {\nisDeprecated=deprecated;\n}",
        "classSignatureBefore": "public class RuleBuilder ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.rules.RuleBuilder#build"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.rules.RuleBuilder"
        ],
        "classSignatureBeforeSet": [
            "public class RuleBuilder "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Overlapped refactoring - can be identical by undoing the overlapped refactoring\n- Encapsulate Opposite-",
                "description": "Getter method got replaced with direct access or vice verca - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.w3c.dom.Element;\n\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RulePriority;\nimport net.sourceforge.pmd.RuleSetReference;\nimport net.sourceforge.pmd.lang.Language;\nimport net.sourceforge.pmd.lang.LanguageRegistry;\nimport net.sourceforge.pmd.lang.LanguageVersion;\nimport net.sourceforge.pmd.properties.PropertyDescriptor;\n\n\n/**\n * Builds a rule, validating its parameters throughout. The builder can define property descriptors, but not override\n * them. For that, use {@link RuleFactory#decorateRule(Rule, RuleSetReference, Element)}.\n *\n * @author Cl\u00e9ment Fournier\n * @since 6.0.0\n */\npublic class RuleBuilder {\n\n    private List<PropertyDescriptor<?>> definedProperties = new ArrayList<>();\n    private String name;\n    private String clazz;\n    private Language language;\n    private String minimumVersion;\n    private String maximumVersion;\n    private String since;\n    private String message;\n    private String externalInfoUrl;\n    private String description;\n    private List<String> examples = new ArrayList<>(1);\n    private RulePriority priority;\n    private boolean isDeprecated;\n    private boolean isUsesDfa;\n    private boolean isUsesMultifile;\n    private boolean isUsesTyperesolution;\n\n    public RuleBuilder(String name, String clazz, String language) {\n        this.name = name;\n        language(language);\n        className(clazz);\n    }\n\n    public void usesDFA(boolean usesDFA) {\n        isUsesDfa = usesDFA;\n    }\n\n    public void usesMultifile(boolean usesMultifile) {\n        isUsesMultifile = usesMultifile;\n    }\n\n    public void usesTyperesolution(boolean usesTyperesolution) {\n        isUsesTyperesolution = usesTyperesolution;\n    }\n\n    private void language(String languageName) {\n        if (StringUtils.isBlank(languageName)) {\n            // Some languages don't need the attribute because the rule's\n            // constructor calls setLanguage, see e.g. AbstractJavaRule\n            return;\n        }\n\n        Language lang = LanguageRegistry.findLanguageByTerseName(languageName);\n        if (lang == null) {\n            throw new IllegalArgumentException(\n                    \"Unknown Language '\" + languageName + \"' for rule\" + name + \", supported Languages are \"\n                    + LanguageRegistry.commaSeparatedTerseNamesForLanguage(LanguageRegistry.findWithRuleSupport()));\n        }\n        language = lang;\n    }\n\n    private void className(String className) {\n        if (StringUtils.isBlank(className)) {\n            throw new IllegalArgumentException(\"The 'class' field of rule can't be null, nor empty.\");\n        }\n\n        this.clazz = className;\n    }\n\n    public void minimumLanguageVersion(String minimum) {\n        minimumVersion = minimum;\n    }\n\n    public void maximumLanguageVersion(String maximum) {\n        maximumVersion = maximum;\n    }\n\n    private void checkLanguageVersionsAreOrdered(Rule rule) {\n        if (rule.getMinimumLanguageVersion() != null && rule.getMaximumLanguageVersion() != null\n            && rule.getMinimumLanguageVersion().compareTo(rule.getMaximumLanguageVersion()) > 0) {\n            throw new IllegalArgumentException(\n                    \"The minimum Language Version '\" + rule.getMinimumLanguageVersion().getTerseName()\n                    + \"' must be prior to the maximum Language Version '\"\n                    + rule.getMaximumLanguageVersion().getTerseName() + \"' for Rule '\" + name\n                    + \"'; perhaps swap them around?\");\n        }\n    }\n\n    public void since(String sinceStr) {\n        if (StringUtils.isNotBlank(sinceStr)) {\n            since = sinceStr;\n        }\n    }\n\n    public void externalInfoUrl(String externalInfoUrl) {\n        this.externalInfoUrl = externalInfoUrl;\n    }\n\n    public void message(String message) {\n        this.message = message;\n    }\n\n    public void defineProperty(PropertyDescriptor<?> descriptor) {\n        definedProperties.add(descriptor);\n    }\n\n\n    public void setDeprecated(boolean deprecated) {\n        isDeprecated = deprecated;\n    }\n\n\n    public void description(String description) {\n        this.description = description;\n    }\n\n\n    public void addExample(String example) {\n        examples.add(example);\n    }\n\n\n    public void priority(int priorityString) {\n        this.priority = RulePriority.valueOf(priorityString);\n    }\n\n    // Must be loaded after rule construction to know the Language\n    private void loadLanguageMinMaxVersions(Rule rule) {\n\n        if (minimumVersion != null) {\n            LanguageVersion minimumLanguageVersion = rule.getLanguage().getVersion(minimumVersion);\n            if (minimumLanguageVersion == null) {\n                throwUnknownLanguageVersionException(\"minimum\", minimumVersion);\n            } else {\n                rule.setMinimumLanguageVersion(minimumLanguageVersion);\n            }\n        }\n\n        if (maximumVersion != null) {\n            LanguageVersion maximumLanguageVersion = rule.getLanguage().getVersion(maximumVersion);\n            if (maximumLanguageVersion == null) {\n                throwUnknownLanguageVersionException(\"maximum\", maximumVersion);\n            } else {\n                rule.setMaximumLanguageVersion(maximumLanguageVersion);\n            }\n        }\n\n        checkLanguageVersionsAreOrdered(rule);\n    }\n\n    private void throwUnknownLanguageVersionException(String minOrMax, String unknownVersion) {\n        throw new IllegalArgumentException(\"Unknown \" + minOrMax + \" Language Version '\" + unknownVersion\n                                           + \"' for Language '\" + language.getTerseName()\n                                           + \"' for Rule \" + name\n                                           + \"; supported Language Versions are: \"\n                                           + LanguageRegistry.commaSeparatedTerseNamesForLanguageVersion(language.getVersions()));\n    }\n\n    public Rule build() throws ClassNotFoundException, IllegalAccessException, InstantiationException {\n        Rule rule = (Rule) RuleBuilder.class.getClassLoader().loadClass(clazz).newInstance();\n\n        rule.setName(name);\n        rule.setRuleClass(clazz);\n\n        if (rule.getLanguage() == null) {\n            rule.setLanguage(language);\n        }\n\n        loadLanguageMinMaxVersions(rule);\n        rule.setSince(since);\n        rule.setMessage(message);\n        rule.setExternalInfoUrl(externalInfoUrl);\n        rule.setDeprecated(isDeprecated);\n        rule.setDescription(description);\n        rule.setPriority(priority == null ? RulePriority.LOW : priority);\n\n        for (String example : examples) {\n            rule.addExample(example);\n        }\n\n        if (isUsesDfa) {\n            rule.setDfa(isUsesDfa);\n        }\n        if (isUsesMultifile) {\n            rule.setMultifile(isUsesMultifile);\n        }\n        if (isUsesTyperesolution) {\n            rule.setTypeResolution(isUsesTyperesolution);\n        }\n\n        for (PropertyDescriptor<?> descriptor : definedProperties) {\n            if (!rule.getPropertyDescriptors().contains(descriptor)) {\n                rule.definePropertyDescriptor(descriptor);\n            }\n        }\n\n        return rule;\n    }\n}\n",
        "filePathAfter": "pmd-core/src/main/java/net/sourceforge/pmd/rules/RuleBuilder.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.w3c.dom.Element;\n\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RulePriority;\nimport net.sourceforge.pmd.RuleSetReference;\nimport net.sourceforge.pmd.lang.Language;\nimport net.sourceforge.pmd.lang.LanguageRegistry;\nimport net.sourceforge.pmd.lang.LanguageVersion;\nimport net.sourceforge.pmd.properties.PropertyDescriptor;\nimport net.sourceforge.pmd.util.ResourceLoader;\n\n\n/**\n * Builds a rule, validating its parameters throughout. The builder can define property descriptors, but not override\n * them. For that, use {@link RuleFactory#decorateRule(Rule, RuleSetReference, Element)}.\n *\n * @author Cl\u00e9ment Fournier\n * @since 6.0.0\n */\npublic class RuleBuilder {\n\n    private List<PropertyDescriptor<?>> definedProperties = new ArrayList<>();\n    private String name;\n    private ResourceLoader resourceLoader;\n    private String clazz;\n    private Language language;\n    private String minimumVersion;\n    private String maximumVersion;\n    private String since;\n    private String message;\n    private String externalInfoUrl;\n    private String description;\n    private List<String> examples = new ArrayList<>(1);\n    private RulePriority priority;\n    private boolean isDeprecated;\n    private boolean isUsesDfa;\n    private boolean isUsesMultifile;\n    private boolean isUsesTyperesolution;\n\n    public RuleBuilder(String name, ResourceLoader resourceLoader, String clazz, String language) {\n        this.name = name;\n        this.resourceLoader = resourceLoader;\n        language(language);\n        className(clazz);\n    }\n\n    public void usesDFA(boolean usesDFA) {\n        isUsesDfa = usesDFA;\n    }\n\n    public void usesMultifile(boolean usesMultifile) {\n        isUsesMultifile = usesMultifile;\n    }\n\n    public void usesTyperesolution(boolean usesTyperesolution) {\n        isUsesTyperesolution = usesTyperesolution;\n    }\n\n    private void language(String languageName) {\n        if (StringUtils.isBlank(languageName)) {\n            // Some languages don't need the attribute because the rule's\n            // constructor calls setLanguage, see e.g. AbstractJavaRule\n            return;\n        }\n\n        Language lang = LanguageRegistry.findLanguageByTerseName(languageName);\n        if (lang == null) {\n            throw new IllegalArgumentException(\n                    \"Unknown Language '\" + languageName + \"' for rule\" + name + \", supported Languages are \"\n                    + LanguageRegistry.commaSeparatedTerseNamesForLanguage(LanguageRegistry.findWithRuleSupport()));\n        }\n        language = lang;\n    }\n\n    private void className(String className) {\n        if (StringUtils.isBlank(className)) {\n            throw new IllegalArgumentException(\"The 'class' field of rule can't be null, nor empty.\");\n        }\n\n        this.clazz = className;\n    }\n\n    public void minimumLanguageVersion(String minimum) {\n        minimumVersion = minimum;\n    }\n\n    public void maximumLanguageVersion(String maximum) {\n        maximumVersion = maximum;\n    }\n\n    private void checkLanguageVersionsAreOrdered(Rule rule) {\n        if (rule.getMinimumLanguageVersion() != null && rule.getMaximumLanguageVersion() != null\n            && rule.getMinimumLanguageVersion().compareTo(rule.getMaximumLanguageVersion()) > 0) {\n            throw new IllegalArgumentException(\n                    \"The minimum Language Version '\" + rule.getMinimumLanguageVersion().getTerseName()\n                    + \"' must be prior to the maximum Language Version '\"\n                    + rule.getMaximumLanguageVersion().getTerseName() + \"' for Rule '\" + name\n                    + \"'; perhaps swap them around?\");\n        }\n    }\n\n    public void since(String sinceStr) {\n        if (StringUtils.isNotBlank(sinceStr)) {\n            since = sinceStr;\n        }\n    }\n\n    public void externalInfoUrl(String externalInfoUrl) {\n        this.externalInfoUrl = externalInfoUrl;\n    }\n\n    public void message(String message) {\n        this.message = message;\n    }\n\n    public void defineProperty(PropertyDescriptor<?> descriptor) {\n        definedProperties.add(descriptor);\n    }\n\n\n    public void setDeprecated(boolean deprecated) {\n        isDeprecated = deprecated;\n    }\n\n\n    public void description(String description) {\n        this.description = description;\n    }\n\n\n    public void addExample(String example) {\n        examples.add(example);\n    }\n\n\n    public void priority(int priorityString) {\n        this.priority = RulePriority.valueOf(priorityString);\n    }\n\n    // Must be loaded after rule construction to know the Language\n    private void loadLanguageMinMaxVersions(Rule rule) {\n\n        if (minimumVersion != null) {\n            LanguageVersion minimumLanguageVersion = rule.getLanguage().getVersion(minimumVersion);\n            if (minimumLanguageVersion == null) {\n                throwUnknownLanguageVersionException(\"minimum\", minimumVersion);\n            } else {\n                rule.setMinimumLanguageVersion(minimumLanguageVersion);\n            }\n        }\n\n        if (maximumVersion != null) {\n            LanguageVersion maximumLanguageVersion = rule.getLanguage().getVersion(maximumVersion);\n            if (maximumLanguageVersion == null) {\n                throwUnknownLanguageVersionException(\"maximum\", maximumVersion);\n            } else {\n                rule.setMaximumLanguageVersion(maximumLanguageVersion);\n            }\n        }\n\n        checkLanguageVersionsAreOrdered(rule);\n    }\n\n    private void throwUnknownLanguageVersionException(String minOrMax, String unknownVersion) {\n        throw new IllegalArgumentException(\"Unknown \" + minOrMax + \" Language Version '\" + unknownVersion\n                                           + \"' for Language '\" + language.getTerseName()\n                                           + \"' for Rule \" + name\n                                           + \"; supported Language Versions are: \"\n                                           + LanguageRegistry.commaSeparatedTerseNamesForLanguageVersion(language.getVersions()));\n    }\n\n    public Rule build() throws ClassNotFoundException, IllegalAccessException, InstantiationException {\n        Rule rule = resourceLoader.loadRuleFromClassPath(clazz);\n\n        rule.setName(name);\n        rule.setRuleClass(clazz);\n\n        if (rule.getLanguage() == null) {\n            rule.setLanguage(language);\n        }\n\n        loadLanguageMinMaxVersions(rule);\n        rule.setSince(since);\n        rule.setMessage(message);\n        rule.setExternalInfoUrl(externalInfoUrl);\n        rule.setDeprecated(isDeprecated);\n        rule.setDescription(description);\n        rule.setPriority(priority == null ? RulePriority.LOW : priority);\n\n        for (String example : examples) {\n            rule.addExample(example);\n        }\n\n        if (isUsesDfa) {\n            rule.setDfa(isUsesDfa);\n        }\n        if (isUsesMultifile) {\n            rule.setMultifile(isUsesMultifile);\n        }\n        if (isUsesTyperesolution) {\n            rule.setTypeResolution(isUsesTyperesolution);\n        }\n\n        for (PropertyDescriptor<?> descriptor : definedProperties) {\n            if (!rule.getPropertyDescriptors().contains(descriptor)) {\n                rule.definePropertyDescriptor(descriptor);\n            }\n        }\n\n        return rule;\n    }\n}\n",
        "diffSourceCodeSet": [
            "this.message = message;\n    }\n\n    public void defineProperty(PropertyDescriptor<?> descriptor) {\n        definedProperties.add(descriptor);\n    }\n\n\n    public void setDeprecated(boolean deprecated) {\n        isDeprecated = deprecated;\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.rules.RuleBuilder#loadLanguageMinMaxVersions\n methodBody: private void loadLanguageMinMaxVersions(Rule rule) {\nif(minimumVersion != null){LanguageVersion minimumLanguageVersion=rule.getLanguage().getVersion(minimumVersion);\nif(minimumLanguageVersion == null){throwUnknownLanguageVersionException(\"minimum\",minimumVersion);\n}{rule.setMinimumLanguageVersion(minimumLanguageVersion);\n}}if(maximumVersion != null){LanguageVersion maximumLanguageVersion=rule.getLanguage().getVersion(maximumVersion);\nif(maximumLanguageVersion == null){throwUnknownLanguageVersionException(\"maximum\",maximumVersion);\n}{rule.setMaximumLanguageVersion(maximumLanguageVersion);\n}}checkLanguageVersionsAreOrdered(rule);\n}",
            "methodSignature: net.sourceforge.pmd.rules.RuleBuilder#addExample\n methodBody: public void addExample(String example) {\nexamples.add(example);\n}",
            "methodSignature: net.sourceforge.pmd.rules.RuleBuilder#setDeprecated\n methodBody: public void setDeprecated(boolean deprecated) {\nisDeprecated=deprecated;\n}"
        ],
        "sourceCodeAfterRefactoring": "public Rule build() throws ClassNotFoundException, IllegalAccessException, InstantiationException {\n        Rule rule = resourceLoader.loadRuleFromClassPath(clazz);\n\n        rule.setName(name);\n        rule.setRuleClass(clazz);\n\n        if (rule.getLanguage() == null) {\n            rule.setLanguage(language);\n        }\n\n        loadLanguageMinMaxVersions(rule);\n        rule.setSince(since);\n        rule.setMessage(message);\n        rule.setExternalInfoUrl(externalInfoUrl);\n        rule.setDeprecated(isDeprecated);\n        rule.setDescription(description);\n        rule.setPriority(priority == null ? RulePriority.LOW : priority);\n\n        for (String example : examples) {\n            rule.addExample(example);\n        }\n\n        if (isUsesDfa) {\n            rule.setDfa(isUsesDfa);\n        }\n        if (isUsesMultifile) {\n            rule.setMultifile(isUsesMultifile);\n        }\n        if (isUsesTyperesolution) {\n            rule.setTypeResolution(isUsesTyperesolution);\n        }\n\n        for (PropertyDescriptor<?> descriptor : definedProperties) {\n            if (!rule.getPropertyDescriptors().contains(descriptor)) {\n                rule.definePropertyDescriptor(descriptor);\n            }\n        }\n\n        return rule;\n    }\nthis.message = message;\n    }\n\n    public void defineProperty(PropertyDescriptor<?> descriptor) {\n        definedProperties.add(descriptor);\n    }\n\n\n    public void setDeprecated(boolean deprecated) {\n        isDeprecated = deprecated;\n    }",
        "diffSourceCode": "-  123:     public void defineProperty(PropertyDescriptor<?> descriptor) {\n-  124:         definedProperties.add(descriptor);\n-  125:     }\n-  126: \n-  127: \n-  128:     public void setDeprecated(boolean deprecated) {\n-  129:         isDeprecated = deprecated;\n-  130:     }\n-  131: \n-  132: \n-  133:     public void description(String description) {\n-  134:         this.description = description;\n-  179:     public Rule build() throws ClassNotFoundException, IllegalAccessException, InstantiationException {\n-  180:         Rule rule = (Rule) RuleBuilder.class.getClassLoader().loadClass(clazz).newInstance();\n+  123:         this.message = message;\n+  124:     }\n+  125: \n+  126:     public void defineProperty(PropertyDescriptor<?> descriptor) {\n+  127:         definedProperties.add(descriptor);\n+  128:     }\n+  129: \n+  130: \n+  131:     public void setDeprecated(boolean deprecated) {\n+  132:         isDeprecated = deprecated;\n+  133:     }\n+  134: \n+  179:                                            + LanguageRegistry.commaSeparatedTerseNamesForLanguageVersion(language.getVersions()));\n+  180:     }\n   181: \n-  182:         rule.setName(name);\n-  183:         rule.setRuleClass(clazz);\n+  182:     public Rule build() throws ClassNotFoundException, IllegalAccessException, InstantiationException {\n+  183:         Rule rule = resourceLoader.loadRuleFromClassPath(clazz);\n   184: \n-  185:         if (rule.getLanguage() == null) {\n-  186:             rule.setLanguage(language);\n-  187:         }\n-  188: \n-  189:         loadLanguageMinMaxVersions(rule);\n-  190:         rule.setSince(since);\n-  191:         rule.setMessage(message);\n-  192:         rule.setExternalInfoUrl(externalInfoUrl);\n-  193:         rule.setDeprecated(isDeprecated);\n-  194:         rule.setDescription(description);\n-  195:         rule.setPriority(priority == null ? RulePriority.LOW : priority);\n-  196: \n-  197:         for (String example : examples) {\n-  198:             rule.addExample(example);\n-  199:         }\n-  200: \n-  201:         if (isUsesDfa) {\n-  202:             rule.setDfa(isUsesDfa);\n-  203:         }\n-  204:         if (isUsesMultifile) {\n-  205:             rule.setMultifile(isUsesMultifile);\n+  185:         rule.setName(name);\n+  186:         rule.setRuleClass(clazz);\n+  187: \n+  188:         if (rule.getLanguage() == null) {\n+  189:             rule.setLanguage(language);\n+  190:         }\n+  191: \n+  192:         loadLanguageMinMaxVersions(rule);\n+  193:         rule.setSince(since);\n+  194:         rule.setMessage(message);\n+  195:         rule.setExternalInfoUrl(externalInfoUrl);\n+  196:         rule.setDeprecated(isDeprecated);\n+  197:         rule.setDescription(description);\n+  198:         rule.setPriority(priority == null ? RulePriority.LOW : priority);\n+  199: \n+  200:         for (String example : examples) {\n+  201:             rule.addExample(example);\n+  202:         }\n+  203: \n+  204:         if (isUsesDfa) {\n+  205:             rule.setDfa(isUsesDfa);\n   206:         }\n-  207:         if (isUsesTyperesolution) {\n-  208:             rule.setTypeResolution(isUsesTyperesolution);\n+  207:         if (isUsesMultifile) {\n+  208:             rule.setMultifile(isUsesMultifile);\n   209:         }\n-  210: \n-  211:         for (PropertyDescriptor<?> descriptor : definedProperties) {\n-  212:             if (!rule.getPropertyDescriptors().contains(descriptor)) {\n-  213:                 rule.definePropertyDescriptor(descriptor);\n-  214:             }\n-  215:         }\n-  216: \n-  217:         return rule;\n-  218:     }\n-  219: }\n+  210:         if (isUsesTyperesolution) {\n+  211:             rule.setTypeResolution(isUsesTyperesolution);\n+  212:         }\n+  213: \n+  214:         for (PropertyDescriptor<?> descriptor : definedProperties) {\n+  215:             if (!rule.getPropertyDescriptors().contains(descriptor)) {\n+  216:                 rule.definePropertyDescriptor(descriptor);\n+  217:             }\n+  218:         }\n+  219: \n+  220:         return rule;\n+  221:     }\n",
        "uniqueId": "5c36ee1eba5a08732d6fc53b0a69010a279a10de_179_218_123_134_182_221",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 8,
                "covered": 105
            },
            "BRANCH": {
                "missed": 3,
                "covered": 13
            },
            "LINE": {
                "missed": 2,
                "covered": 24
            },
            "COMPLEXITY": {
                "missed": 3,
                "covered": 6
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic getBody() : ASTBlock extracted from public getBlock() : ASTBlock in class net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTMethodDeclaration.java",
                "startLine": 127,
                "endLine": 133,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTMethodDeclaration.java",
                "startLine": 130,
                "endLine": 139,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTMethodDeclaration.java",
                "startLine": 141,
                "endLine": 147,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Returns the block defined by this method, or\n     * null if the method is abstract.\n     */\n    public ASTBlock getBlock() {\n        return getFirstChildOfType(ASTBlock.class);\n    }",
        "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTMethodDeclaration.java",
        "isPureRefactoring": true,
        "commitId": "04e5619fa884283a4fa024c871ca99b9f160d911",
        "packageNameBefore": "net.sourceforge.pmd.lang.java.ast",
        "classNameBefore": "net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration",
        "methodNameBefore": "net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration#getBlock",
        "classSignatureBefore": "public class ASTMethodDeclaration extends AbstractMethodOrConstructorDeclaration implements DFAGraphMethod ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration#getBlock"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration"
        ],
        "classSignatureBeforeSet": [
            "public class ASTMethodDeclaration extends AbstractMethodOrConstructorDeclaration implements DFAGraphMethod "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.ast;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.dfa.DFAGraphMethod;\n\n\n/**\n * Method declaration node.\n *\n * <pre>\n * MethodDeclaration := [ TypeParameters() ] (TypeAnnotation())* ResultType() MethodDeclarator() [ \"throws\" NameList() ] ( Block() | \";\" )\n * </pre>\n */\npublic class ASTMethodDeclaration extends AbstractMethodOrConstructorDeclaration implements DFAGraphMethod {\n\n\n    @InternalApi\n    @Deprecated\n    public ASTMethodDeclaration(int id) {\n        super(id);\n    }\n\n    @InternalApi\n    @Deprecated\n    public ASTMethodDeclaration(JavaParser p, int id) {\n        super(p, id);\n    }\n\n    @Override\n    public Object jjtAccept(JavaParserVisitor visitor, Object data) {\n        return visitor.visit(this, data);\n    }\n\n    /**\n     * Returns the simple name of the method.\n     */\n    public String getMethodName() {\n        return getFirstChildOfType(ASTMethodDeclarator.class).getImage();\n    }\n\n\n    @Override\n    public String getName() {\n        return getMethodName();\n    }\n\n\n    /**\n     * Returns true if this method is explicitly modified by\n     * the {@code public} modifier.\n     */\n    public boolean isSyntacticallyPublic() {\n        return super.isPublic();\n    }\n\n\n    /**\n     * Returns true if this method is explicitly modified by\n     * the {@code abstract} modifier.\n     */\n    public boolean isSyntacticallyAbstract() {\n        return super.isAbstract();\n    }\n\n\n    /**\n     * Returns true if this method has public visibility.\n     * Non-private interface members are implicitly public,\n     * whether they declare the {@code public} modifier or\n     * not.\n     */\n    @Override\n    public boolean isPublic() {\n        // interface methods are public by default, but could be private since java9\n        return isInterfaceMember() && !isPrivate() || super.isPublic();\n    }\n\n\n    /**\n     * Returns true if this method is abstract, so doesn't\n     * declare a body. Interface members are\n     * implicitly abstract, whether they declare the\n     * {@code abstract} modifier or not. Default interface\n     * methods are not abstract though, consistently with the\n     * standard reflection API.\n     */\n    @Override\n    public boolean isAbstract() {\n        return isInterfaceMember() && !isDefault() || super.isAbstract();\n    }\n\n\n    /**\n     * Returns true if this method declaration is a member of an interface type.\n     */\n    public boolean isInterfaceMember() {\n        // for a real class/interface the 3rd parent is a ClassOrInterfaceDeclaration,\n        // for anonymous classes, the parent is e.g. a AllocationExpression\n        Node potentialTypeDeclaration = getNthParent(3);\n\n        return potentialTypeDeclaration instanceof ASTClassOrInterfaceDeclaration\n            && ((ASTClassOrInterfaceDeclaration) potentialTypeDeclaration).isInterface();\n    }\n\n\n    /**\n     * Returns true if the result type of this method is {@code void}.\n     */\n    public boolean isVoid() {\n        return getResultType().isVoid();\n    }\n\n\n    /**\n     * Returns the result type node of the method.\n     */\n    public ASTResultType getResultType() {\n        return getFirstChildOfType(ASTResultType.class);\n    }\n\n\n    /**\n     * Returns the block defined by this method, or\n     * null if the method is abstract.\n     */\n    public ASTBlock getBlock() {\n        return getFirstChildOfType(ASTBlock.class);\n    }\n\n\n    /**\n     * Returns the exception names listed in the {@code throws} clause\n     * of this method declaration, or null if there are none.\n     */\n    public ASTNameList getThrows() {\n        return getFirstChildOfType(ASTNameList.class);\n    }\n\n\n    @Override\n    public MethodLikeKind getKind() {\n        return MethodLikeKind.METHOD;\n    }\n\n    //@Override // enable this with PMD 7.0.0 - see interface ASTMethodOrConstructorDeclaration\n    public ASTFormalParameters getFormalParameters() {\n        return getFirstChildOfType(ASTMethodDeclarator.class).getFirstChildOfType(ASTFormalParameters.class);\n    }\n\n\n    /**\n     * Returns the method declarator. Never null.\n     */\n    public ASTMethodDeclarator getMethodDeclarator() {\n        return getFirstChildOfType(ASTMethodDeclarator.class);\n    }\n}\n",
        "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTMethodDeclaration.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.ast;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.dfa.DFAGraphMethod;\n\n\n/**\n * Method declaration node.\n *\n * <pre>\n * MethodDeclaration := [ TypeParameters() ] (TypeAnnotation())* ResultType() MethodDeclarator() [ \"throws\" NameList() ] ( Block() | \";\" )\n * </pre>\n */\npublic class ASTMethodDeclaration extends AbstractMethodOrConstructorDeclaration implements DFAGraphMethod {\n\n\n    @InternalApi\n    @Deprecated\n    public ASTMethodDeclaration(int id) {\n        super(id);\n    }\n\n    @InternalApi\n    @Deprecated\n    public ASTMethodDeclaration(JavaParser p, int id) {\n        super(p, id);\n    }\n\n    @Override\n    public Object jjtAccept(JavaParserVisitor visitor, Object data) {\n        return visitor.visit(this, data);\n    }\n\n    /**\n     * Returns the simple name of the method.\n     *\n     * @deprecated Use {@link #getName()}\n     */\n    @Deprecated\n    public String getMethodName() {\n        return getName();\n    }\n\n    /** Returns the simple name of the method. */\n    @Override\n    public String getName() {\n        return getFirstChildOfType(ASTMethodDeclarator.class).getImage();\n    }\n\n\n    /**\n     * Returns true if this method is explicitly modified by\n     * the {@code public} modifier.\n     */\n    public boolean isSyntacticallyPublic() {\n        return super.isPublic();\n    }\n\n\n    /**\n     * Returns true if this method is explicitly modified by\n     * the {@code abstract} modifier.\n     */\n    public boolean isSyntacticallyAbstract() {\n        return super.isAbstract();\n    }\n\n\n    /**\n     * Returns true if this method has public visibility.\n     * Non-private interface members are implicitly public,\n     * whether they declare the {@code public} modifier or\n     * not.\n     */\n    @Override\n    public boolean isPublic() {\n        // interface methods are public by default, but could be private since java9\n        return isInterfaceMember() && !isPrivate() || super.isPublic();\n    }\n\n\n    /**\n     * Returns true if this method is abstract, so doesn't\n     * declare a body. Interface members are\n     * implicitly abstract, whether they declare the\n     * {@code abstract} modifier or not. Default interface\n     * methods are not abstract though, consistently with the\n     * standard reflection API.\n     */\n    @Override\n    public boolean isAbstract() {\n        return isInterfaceMember() && !isDefault() || super.isAbstract();\n    }\n\n\n    /**\n     * Returns true if this method declaration is a member of an interface type.\n     */\n    public boolean isInterfaceMember() {\n        // for a real class/interface the 3rd parent is a ClassOrInterfaceDeclaration,\n        // for anonymous classes, the parent is e.g. a AllocationExpression\n        Node potentialTypeDeclaration = getNthParent(3);\n\n        return potentialTypeDeclaration instanceof ASTClassOrInterfaceDeclaration\n            && ((ASTClassOrInterfaceDeclaration) potentialTypeDeclaration).isInterface();\n    }\n\n\n    /**\n     * Returns true if the result type of this method is {@code void}.\n     */\n    public boolean isVoid() {\n        return getResultType().isVoid();\n    }\n\n\n    /**\n     * Returns the result type node of the method.\n     */\n    public ASTResultType getResultType() {\n        return getFirstChildOfType(ASTResultType.class);\n    }\n\n\n    /**\n     * Returns the block defined by this method, or\n     * null if the method is abstract.\n     *\n     * @deprecated Use {@link #getBody()}\n     */\n    @Deprecated\n    public ASTBlock getBlock() {\n        return getBody();\n    }\n\n    /**\n     * Returns the block defined by this method, or\n     * null if the method is abstract.\n     */\n    public ASTBlock getBody() {\n        return getFirstChildOfType(ASTBlock.class);\n    }\n\n    /**\n     * Returns the number of formal parameters expected by this method\n     * (excluding any receiver parameter). A varargs parameter counts as one.\n     */\n    public int getArity() {\n        return getFormalParameters().getParameterCount();\n    }\n\n\n    /**\n     * Returns the exception names listed in the {@code throws} clause\n     * of this method declaration, or null if there are none.\n     */\n    public ASTNameList getThrows() {\n        return getFirstChildOfType(ASTNameList.class);\n    }\n\n\n    @Override\n    public MethodLikeKind getKind() {\n        return MethodLikeKind.METHOD;\n    }\n\n    //@Override // enable this with PMD 7.0.0 - see interface ASTMethodOrConstructorDeclaration\n    public ASTFormalParameters getFormalParameters() {\n        return getFirstChildOfType(ASTMethodDeclarator.class).getFirstChildOfType(ASTFormalParameters.class);\n    }\n\n\n    /**\n     * Returns the method declarator. Never null.\n     *\n     * @deprecated Method declarator nodes will be removed with 7.0.0\n     */\n    @Deprecated\n    public ASTMethodDeclarator getMethodDeclarator() {\n        return getFirstChildOfType(ASTMethodDeclarator.class);\n    }\n}\n",
        "diffSourceCodeSet": [
            "/**\n     * Returns the block defined by this method, or\n     * null if the method is abstract.\n     */\n    public ASTBlock getBody() {\n        return getFirstChildOfType(ASTBlock.class);\n    }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "/**\n     * Returns the block defined by this method, or\n     * null if the method is abstract.\n     *\n     * @deprecated Use {@link #getBody()}\n     */\n    @Deprecated\n    public ASTBlock getBlock() {\n        return getBody();\n    }\n/**\n     * Returns the block defined by this method, or\n     * null if the method is abstract.\n     */\n    public ASTBlock getBody() {\n        return getFirstChildOfType(ASTBlock.class);\n    }",
        "diffSourceCode": "-  127:     /**\n-  128:      * Returns the block defined by this method, or\n-  129:      * null if the method is abstract.\n-  130:      */\n-  131:     public ASTBlock getBlock() {\n-  132:         return getFirstChildOfType(ASTBlock.class);\n-  133:     }\n-  134: \n-  135: \n-  136:     /**\n-  137:      * Returns the exception names listed in the {@code throws} clause\n-  138:      * of this method declaration, or null if there are none.\n-  139:      */\n-  141:         return getFirstChildOfType(ASTNameList.class);\n-  142:     }\n-  143: \n-  144: \n-  145:     @Override\n-  146:     public MethodLikeKind getKind() {\n-  147:         return MethodLikeKind.METHOD;\n+  127:     }\n+  128: \n+  129: \n+  130:     /**\n+  131:      * Returns the block defined by this method, or\n+  132:      * null if the method is abstract.\n+  133:      *\n+  134:      * @deprecated Use {@link #getBody()}\n+  135:      */\n+  136:     @Deprecated\n+  137:     public ASTBlock getBlock() {\n+  138:         return getBody();\n+  139:     }\n+  141:     /**\n+  142:      * Returns the block defined by this method, or\n+  143:      * null if the method is abstract.\n+  144:      */\n+  145:     public ASTBlock getBody() {\n+  146:         return getFirstChildOfType(ASTBlock.class);\n+  147:     }\n",
        "uniqueId": "04e5619fa884283a4fa024c871ca99b9f160d911_127_133_141_147_130_139",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 5
            },
            "LINE": {
                "missed": 0,
                "covered": 1
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Move Method",
        "description": "Move Method\tprivate pathsOf(stream NodeStream<?>) : List<String> from class net.sourceforge.pmd.lang.ast.NodeStreamTest to public pathsOf(stream NodeStream<?>) : List<String> from class net.sourceforge.pmd.lang.ast.DummyTreeUtil",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/lang/ast/NodeStreamTest.java",
                "startLine": 315,
                "endLine": 317,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/lang/ast/DummyTreeUtil.java",
                "startLine": 84,
                "endLine": 87,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private static List<String> pathsOf(NodeStream<?> stream) {\n        return stream.toList(Node::getImage);\n    }",
        "filePathBefore": "pmd-core/src/test/java/net/sourceforge/pmd/lang/ast/NodeStreamTest.java",
        "isPureRefactoring": true,
        "commitId": "ccd9c19c7af6f58b97034997f1583d5c31a023fb",
        "packageNameBefore": "net.sourceforge.pmd.lang.ast",
        "classNameBefore": "net.sourceforge.pmd.lang.ast.NodeStreamTest",
        "methodNameBefore": "net.sourceforge.pmd.lang.ast.NodeStreamTest#pathsOf",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.ast.Node#getImage\n methodBody: String getImage();",
        "classSignatureBefore": "public class NodeStreamTest ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.ast.NodeStreamTest#pathsOf"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.ast.NodeStreamTest"
        ],
        "classSignatureBeforeSet": [
            "public class NodeStreamTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.ast;\n\nimport static net.sourceforge.pmd.lang.ast.DummyTreeUtil.followPath;\nimport static net.sourceforge.pmd.lang.ast.DummyTreeUtil.node;\nimport static net.sourceforge.pmd.lang.ast.DummyTreeUtil.tree;\nimport static org.hamcrest.CoreMatchers.equalTo;\nimport static org.hamcrest.collection.IsIterableContainingInOrder.contains;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertSame;\nimport static org.junit.Assert.assertThat;\nimport static org.junit.Assert.assertTrue;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Optional;\n\nimport org.apache.commons.lang3.mutable.MutableInt;\nimport org.junit.Test;\n\n\n/**\n * @author Cl\u00e9ment Fournier\n */\npublic class NodeStreamTest {\n\n\n    private final DummyNode tree1 = tree(\n        () ->\n            node(\n                node(\n                    node(),\n                    node(\n                        node()\n                    )\n                ),\n                node()\n            )\n    );\n\n\n    private final DummyNode tree2 = tree(\n        () ->\n            node(\n                node(),\n                node(),\n                node(\n                    node()\n                ),\n                node()\n            )\n    );\n\n\n    @Test\n    public void testStreamConstructionIsNullSafe() {\n        assertTrue(NodeStream.of((Node) null).isEmpty());\n        assertThat(NodeStream.of(null, null, tree1).count(), equalTo(1));\n        assertThat(NodeStream.fromIterable(Arrays.asList(tree1, null, null)).count(), equalTo(1));\n        assertThat(NodeStream.ofOptional(Optional.empty()).count(), equalTo(0));\n    }\n\n\n    @Test\n    public void testMapIsNullSafe() {\n        assertTrue(tree1.descendantsOrSelf().map(n -> null).isEmpty());\n    }\n\n\n    @Test\n    public void testFlatMapIsNullSafe() {\n        assertTrue(tree1.descendantsOrSelf().flatMap(n -> null).isEmpty());\n    }\n\n\n    @Test\n    public void testChildrenStream() {\n        assertThat(pathsOf(tree1.children()), contains(\"0\", \"1\"));\n        assertThat(pathsOf(tree1.asStream().children()), contains(\"0\", \"1\"));\n    }\n\n\n    @Test\n    public void testDescendantStream() {\n        assertThat(pathsOf(tree1.descendants()), contains(\"0\", \"00\", \"01\", \"010\", \"1\"));\n        assertThat(pathsOf(tree1.asStream().descendants()), contains(\"0\", \"00\", \"01\", \"010\", \"1\"));\n    }\n\n    @Test\n    public void testSingletonStream() {\n        assertThat(pathsOf(tree1.asStream()), contains(\"\"));\n        assertThat(pathsOf(NodeStream.of(tree1)), contains(\"\"));\n    }\n\n\n    @Test\n    public void testTreeStream() {\n        assertThat(pathsOf(tree1.descendantsOrSelf()), contains(\"\", \"0\", \"00\", \"01\", \"010\", \"1\"));\n        assertThat(pathsOf(NodeStream.of(tree1).descendantsOrSelf()), contains(\"\", \"0\", \"00\", \"01\", \"010\", \"1\"));\n    }\n\n    @Test\n    public void testAncestors() {\n        // 010\n        Node node = tree1.children().children().children().first();\n        assertEquals(\"010\", node.getImage());\n        assertThat(pathsOf(node.ancestors()), contains(\"01\", \"0\", \"\"));\n        assertThat(pathsOf(node.ancestorsOrSelf()), contains(\"010\", \"01\", \"0\", \"\"));\n\n        assertEquals(\"01\", node.getNthParent(1).getImage());\n        assertEquals(\"0\", node.getNthParent(2).getImage());\n        assertEquals(\"\", node.getNthParent(3).getImage());\n        assertNull(node.getNthParent(4));\n    }\n\n\n    @Test\n    public void testFollowingSiblings() {\n        assertThat(pathsOf(followPath(tree1, \"00\").asStream().followingSiblings()), contains(\"01\"));\n    }\n\n\n    @Test\n    public void testPrecedingSiblings() {\n        assertThat(pathsOf(followPath(tree1, \"01\").asStream().precedingSiblings()), contains(\"00\"));\n    }\n\n    @Test\n    public void testAncestorStream() {\n        assertThat(pathsOf(followPath(tree1, \"01\").ancestors()), contains(\"0\", \"\"));\n        assertThat(pathsOf(followPath(tree1, \"01\").asStream().ancestors()), contains(\"0\", \"\"));\n    }\n\n\n    @Test\n    public void testParentStream() {\n        assertThat(pathsOf(followPath(tree1, \"01\").asStream().parents()), contains(\"0\"));\n    }\n\n\n    @Test\n    public void testAncestorStreamUnion() {\n        assertThat(pathsOf(NodeStream.union(followPath(tree1, \"01\").ancestors(),\n                                            tree2.children().ancestors())), contains(\"0\", \"\", \"\", \"\", \"\", \"\"));\n    }\n\n\n    @Test\n    public void testDistinct() {\n        assertThat(pathsOf(NodeStream.union(followPath(tree1, \"01\").ancestors(),\n                                            tree2.children().ancestors()).distinct()), contains(\"0\", \"\", \"\")); // roots of both trees\n    }\n\n\n    @Test\n    public void testGet() {\n        // (\"0\", \"00\", \"01\", \"010\", \"1\")\n        assertEquals(\"0\", tree1.descendants().get(0).getImage());\n        assertEquals(\"00\", tree1.descendants().get(1).getImage());\n        assertEquals(\"010\", tree1.descendants().get(3).getImage());\n        assertEquals(\"1\", tree1.descendants().get(4).getImage());\n        assertNull(tree1.descendants().get(6));\n    }\n\n    @Test\n    public void testNodeStreamsCanBeIteratedSeveralTimes() {\n        NodeStream<Node> stream = tree1.descendants();\n\n        assertThat(stream.count(), equalTo(5));\n        assertThat(stream.count(), equalTo(5));\n\n        assertThat(pathsOf(stream), contains(\"0\", \"00\", \"01\", \"010\", \"1\"));\n        assertThat(pathsOf(stream.filter(n -> n.jjtGetNumChildren() == 0)), contains(\"00\", \"010\", \"1\"));\n    }\n\n\n    @Test\n    public void testNodeStreamPipelineIsLazy() {\n\n        MutableInt numEvals = new MutableInt();\n\n        tree1.descendants().filter(n -> {\n            numEvals.increment();\n            return true;\n        });\n\n        assertThat(numEvals.getValue(), equalTo(0));\n    }\n\n\n    @Test\n    public void testForkJoinUpstreamPipelineIsExecutedAtMostOnce() {\n\n        MutableInt numEvals = new MutableInt();\n        NodeStream<Node> stream =\n            hook(numEvals::increment, tree1.descendants())\n                .forkJoin(\n                    n -> NodeStream.of(n).filter(m -> m.hasImageEqualTo(\"0\")),\n                    n -> NodeStream.of(n).filter(m -> m.hasImageEqualTo(\"1\"))\n                );\n\n        assertThat(numEvals.getValue(), equalTo(0)); // not evaluated yet\n\n        assertThat(stream.count(), equalTo(2));\n\n        assertThat(numEvals.getValue(), equalTo(5)); // evaluated *once* every element of the upper stream\n\n        assertThat(stream.count(), equalTo(2));\n\n        assertThat(numEvals.getValue(), equalTo(5)); // not reevaluated\n    }\n\n\n    @Test\n    public void testCachedStreamUpstreamPipelineIsExecutedAtMostOnce() {\n\n        MutableInt upstreamEvals = new MutableInt();\n        MutableInt downstreamEvals = new MutableInt();\n\n        NodeStream<Node> stream =\n            tree1.descendants()\n                 .filter(n -> n.getImage().matches(\"0.*\"))\n                 .peek(n -> upstreamEvals.increment())\n                 .cached()\n                 .filter(n -> true)\n                 .peek(n -> downstreamEvals.increment());\n\n        assertThat(upstreamEvals.getValue(), equalTo(0));   // not evaluated yet\n\n        assertThat(stream.count(), equalTo(4));\n\n        assertThat(upstreamEvals.getValue(), equalTo(4));   // evaluated once\n        assertThat(downstreamEvals.getValue(), equalTo(4)); // evaluated once\n\n        assertThat(stream.count(), equalTo(4));\n\n        assertThat(upstreamEvals.getValue(), equalTo(4));   // upstream was not reevaluated\n        assertThat(downstreamEvals.getValue(), equalTo(8)); // downstream has been reevaluated\n    }\n\n\n    @Test\n    public void testUnionIsLazy() {\n\n        MutableInt tree1Evals = new MutableInt();\n        MutableInt tree2Evals = new MutableInt();\n\n        NodeStream<Node> unionStream = NodeStream.union(tree1.descendantsOrSelf().peek(n -> tree1Evals.increment()),\n                                                        tree2.descendantsOrSelf().peek(n -> tree2Evals.increment()));\n\n        assertThat(tree1Evals.getValue(), equalTo(0));   // not evaluated yet\n        assertThat(tree2Evals.getValue(), equalTo(0));   // not evaluated yet\n\n        assertSame(unionStream.first(), tree1);\n\n        assertThat(tree1Evals.getValue(), equalTo(1));   // evaluated once\n        assertThat(tree2Evals.getValue(), equalTo(0));   // not evaluated\n    }\n\n\n    @Test\n    public void testSomeOperationsAreLazy() {\n\n        MutableInt tree1Evals = new MutableInt();\n\n        NodeStream<Node> unionStream = tree1.descendantsOrSelf().peek(n -> tree1Evals.increment());\n\n        int i = 0;\n\n        assertThat(tree1Evals.getValue(), equalTo(i));      // not evaluated yet\n\n        unionStream.first();\n        assertThat(tree1Evals.getValue(), equalTo(++i));    // evaluated once\n\n        unionStream.nonEmpty();\n        assertThat(tree1Evals.getValue(), equalTo(i));     // not evaluated, because of optimised implementation\n\n        unionStream.isEmpty();\n        assertThat(tree1Evals.getValue(), equalTo(i));     // not evaluated, because of optimised implementation\n\n        // those don't trigger any evaluation\n\n        unionStream.map(p -> p);\n        unionStream.filter(p -> true);\n        unionStream.append(tree2.descendantsOrSelf());\n        unionStream.prepend(tree2.descendantsOrSelf());\n        unionStream.flatMap(Node::descendantsOrSelf);\n        unionStream.iterator();\n        unionStream.cached();\n        unionStream.descendants();\n        unionStream.ancestors();\n        unionStream.followingSiblings();\n        unionStream.precedingSiblings();\n        unionStream.children();\n        unionStream.distinct();\n        unionStream.take(4);\n        unionStream.drop(4);\n\n        assertThat(tree1Evals.getValue(), equalTo(i));      // not evaluated\n    }\n\n\n    private static <T extends Node> NodeStream<T> hook(Runnable hook, NodeStream<T> stream) {\n        return stream.filter(t -> {\n            hook.run();\n            return true;\n        });\n    }\n\n\n    private static List<String> pathsOf(NodeStream<?> stream) {\n        return stream.toList(Node::getImage);\n    }\n}\n",
        "filePathAfter": "pmd-core/src/test/java/net/sourceforge/pmd/lang/ast/DummyTreeUtil.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.ast;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\n\n\n/**\n * @author Cl\u00e9ment Fournier\n */\npublic final class DummyTreeUtil {\n\n\n    private DummyTreeUtil() {\n\n    }\n\n\n    /** Creates a dummy node with the given children. */\n    public static DummyNode node(DummyNode... children) {\n        DummyNode node = new DummyNode(0) {\n            @Override\n            public String toString() {\n                return getImage();\n            }\n        };\n        node.children = children;\n        for (int i = 0; i < children.length; i++) {\n            children[i].jjtSetParent(node);\n            children[i].jjtSetChildIndex(i);\n        }\n        return node;\n    }\n\n\n    public static DummyNode followPath(DummyNode root, String path) {\n        List<Integer> pathIndices = Arrays.stream(path.split(\"\")).map(Integer::valueOf).collect(Collectors.toList());\n\n        Node current = root;\n        for (int i : pathIndices) {\n            current = current.jjtGetChild(i);\n        }\n\n        return (DummyNode) current;\n    }\n\n\n    /**\n     * Must wrap the actual {@link #node(DummyNode...)} usages to assign each node the\n     * image of its path from the root (in indices). E.g.\n     *\n     * <pre>\n     * node(         \"\"\n     *   node(       \"0\"\n     *     node(),   \"00\"\n     *     node(     \"01\"\n     *       node()  \"010\n     *     )\n     *   ),\n     *   node()      \"1\"\n     * )\n     * </pre>\n     */\n    public static DummyNode tree(Supplier<DummyNode> supplier) {\n        DummyNode dummyNode = supplier.get();\n        assignPathImage(dummyNode, \"\");\n        return dummyNode;\n    }\n\n\n    private static void assignPathImage(Node node, String curPath) {\n        node.setImage(curPath);\n\n        for (int i = 0; i < node.jjtGetNumChildren(); i++) {\n            assignPathImage(node.jjtGetChild(i), curPath + i);\n        }\n    }\n\n    /** List of the images of the stream. */\n    public static List<String> pathsOf(NodeStream<?> stream) {\n        return stream.toList(Node::getImage);\n    }\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.ast.Node#getImage\n methodBody: String getImage();"
        ],
        "sourceCodeAfterRefactoring": "/** List of the images of the stream. */\n    public static List<String> pathsOf(NodeStream<?> stream) {\n        return stream.toList(Node::getImage);\n    }",
        "diffSourceCode": "-   84:     }\n-   85: \n-   86: \n-   87:     @Test\n-  315:     private static List<String> pathsOf(NodeStream<?> stream) {\n-  316:         return stream.toList(Node::getImage);\n-  317:     }\n+   84:     /** List of the images of the stream. */\n+   85:     public static List<String> pathsOf(NodeStream<?> stream) {\n+   86:         return stream.toList(Node::getImage);\n+   87:     }\n",
        "uniqueId": "ccd9c19c7af6f58b97034997f1583d5c31a023fb_315_317__84_87",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic filterNotNull(it Iterator<? extends T>) : Iterator<@NonNull T> extracted from public fromIterable(iterable Iterable<T>) : NodeStream<T> in class net.sourceforge.pmd.lang.ast.internal.StreamImpl & moved to class net.sourceforge.pmd.internal.util.IteratorUtil",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/StreamImpl.java",
                "startLine": 37,
                "endLine": 51,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/StreamImpl.java",
                "startLine": 46,
                "endLine": 61,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/StreamImpl.java",
                "startLine": 125,
                "endLine": 127,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public static <T extends Node> NodeStream<T> fromIterable(Iterable<T> iterable) {\n        return new IteratorBasedNStream<T>() {\n            @Override\n            public Iterator<T> iterator() {\n                return IteratorUtil.mapNotNull(iterable.iterator(), Function.identity());\n            }\n\n            @Override\n            public Spliterator<T> spliterator() {\n                Spliterator<T> spliter = iterable.spliterator();\n                return Spliterators.spliterator(iterator(), spliter.estimateSize(),\n                                                spliter.characteristics() & ~Spliterator.SIZED & ~Spliterator.SUBSIZED);\n            }\n        };\n    }",
        "filePathBefore": "pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/StreamImpl.java",
        "isPureRefactoring": true,
        "commitId": "bc25e58dfc8b3fe32c173e2cf213bf9e83869ce0",
        "packageNameBefore": "net.sourceforge.pmd.lang.ast.internal",
        "classNameBefore": "net.sourceforge.pmd.lang.ast.internal.StreamImpl",
        "methodNameBefore": "net.sourceforge.pmd.lang.ast.internal.StreamImpl#fromIterable",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.ast.internal.SingletonNodeStream#iterator\n methodBody: public Iterator<T> iterator() {\nreturn toList().iterator();\n}\nmethodSignature: net.sourceforge.pmd.lang.ast.internal.StreamImpl.FilteredChildrenStream#spliterator\n methodBody: public Spliterator<R> spliterator() {\nreturn Spliterators.spliterator(iterator(),count(),Spliterator.SIZED | Spliterator.ORDERED);\n}\nmethodSignature: net.sourceforge.pmd.lang.ast.internal.StreamImpl.AxisStream#iterator\n methodBody: public final Iterator<R> iterator() {\nreturn target.filterMap(baseIterator());\n}\nmethodSignature: net.sourceforge.pmd.internal.util.IteratorUtil#mapNotNull\n methodBody: public static <T, R> Iterator<@NonNull R> mapNotNull(Iterator<? extends T> it, Function<? super @NonNull T, ? extends @Nullable R> mapper) {\nreturn new Iterator<R>(){\n  private R next;\n  @Override public boolean hasNext(){\n    if (next != null) {\n      return true;\n    }\n    while (it.hasNext()) {\n      T next1=it.next();\n      if (next1 != null) {\n        R map=mapper.apply(next1);\n        if (map != null) {\n          this.next=map;\n          return true;\n        }\n      }\n    }\n    next=null;\n    return false;\n  }\n  @Override public R next(){\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    R r=next;\n    next=null;\n    return r;\n  }\n}\n;\n}\nmethodSignature: net.sourceforge.pmd.lang.ast.NodeStream#iterator\n methodBody: Iterator<T> iterator();\nmethodSignature: net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream#iterator\n methodBody: public abstract Iterator<R> iterator();\nmethodSignature: net.sourceforge.pmd.lang.ast.internal.StreamImpl.SlicedChildrenStream#spliterator\n methodBody: public Spliterator<Node> spliterator() {\nreturn Spliterators.spliterator(iterator(),count(),Spliterator.SIZED | Spliterator.ORDERED);\n}\nmethodSignature: net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream.IteratorMapping#iterator\n methodBody: public Iterator<S> iterator() {\nreturn fun.apply(IteratorBasedNStream.this.iterator());\n}\nmethodSignature: net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream#spliterator\n methodBody: public Spliterator<R> spliterator() {\nreturn Spliterators.spliteratorUnknownSize(iterator(),Spliterator.ORDERED);\n}\nmethodSignature: net.sourceforge.pmd.lang.ast.internal.StreamImpl.SlicedChildrenStream#iterator\n methodBody: public Iterator<Node> iterator() {\nreturn count() > 0 ? TraversalUtils.childrenIterator(node,low,high) : IteratorUtil.emptyIterator();\n}",
        "classSignatureBefore": "public final class StreamImpl ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.ast.internal.StreamImpl#fromIterable"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.ast.internal.StreamImpl"
        ],
        "classSignatureBeforeSet": [
            "public final class StreamImpl "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.ast.internal;\n\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Spliterator;\nimport java.util.Spliterators;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport net.sourceforge.pmd.internal.util.AssertionUtil;\nimport net.sourceforge.pmd.internal.util.Filtermap;\nimport net.sourceforge.pmd.internal.util.IteratorUtil;\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.ast.NodeStream;\n\npublic final class StreamImpl {\n\n    private StreamImpl() {\n        // utility class\n    }\n\n    public static <T extends Node> NodeStream<T> singleton(T node) {\n        return new SingletonNodeStream<>(node);\n    }\n\n    public static <T extends Node> NodeStream<T> fromIterable(Iterable<T> iterable) {\n        return new IteratorBasedNStream<T>() {\n            @Override\n            public Iterator<T> iterator() {\n                return IteratorUtil.mapNotNull(iterable.iterator(), Function.identity());\n            }\n\n            @Override\n            public Spliterator<T> spliterator() {\n                Spliterator<T> spliter = iterable.spliterator();\n                return Spliterators.spliterator(iterator(), spliter.estimateSize(),\n                                                spliter.characteristics() & ~Spliterator.SIZED & ~Spliterator.SUBSIZED);\n            }\n        };\n    }\n\n    @SafeVarargs\n    public static <T extends Node> NodeStream<T> union(NodeStream<? extends T>... streams) {\n        return new IteratorBasedNStream<T>() {\n            @Override\n            public Iterator<T> iterator() {\n                return IteratorUtil.flatMap(Arrays.asList(streams).iterator(), NodeStream::iterator);\n            }\n        };\n    }\n\n\n    public static <T extends Node> NodeStream<T> empty() {\n        return new IteratorBasedNStream<T>() {\n            @Override\n            public Iterator<T> iterator() {\n                return Collections.emptyIterator();\n            }\n        };\n    }\n\n    public static <R extends Node> NodeStream<R> children(Node node, Class<R> target) {\n        return new FilteredChildrenStream<>(node, Filtermap.isInstance(target));\n    }\n\n    public static NodeStream<Node> children(Node root) {\n        return new FilteredChildrenStream<>(root, Filtermap.NODE_IDENTITY);\n    }\n\n    public static NodeStream<Node> descendants(Node node) {\n        return new DescendantStream(node);\n    }\n\n    public static <R extends Node> NodeStream<R> descendants(Node node, Class<R> rClass) {\n        return new FilteredDescendantStream<>(node, Filtermap.isInstance(rClass));\n    }\n\n    public static NodeStream<Node> descendantsOrSelf(Node node) {\n        return new DescendantOrSelfStream(node);\n    }\n\n    public static NodeStream<Node> followingSiblings(Node node) {\n        Node parent = node.jjtGetParent();\n        return parent == null ? empty()\n                              : new SlicedChildrenStream(parent, node.jjtGetChildIndex() + 1, parent.jjtGetNumChildren());\n    }\n\n    public static NodeStream<Node> precedingSiblings(Node node) {\n        Node parent = node.jjtGetParent();\n        return parent == null ? empty()\n                              : new SlicedChildrenStream(parent, 0, node.jjtGetChildIndex());\n    }\n\n\n    public static NodeStream<Node> ancestorsOrSelf(@Nullable Node node) {\n        if (node == null) {\n            return empty();\n        } else if (node.jjtGetParent() == null) {\n            return singleton(node);\n        }\n        return new AncestorOrSelfStream(node);\n    }\n\n    private static <R extends Node> NodeStream<R> ancestorsOrSelf(@Nullable Node node, Filtermap<Node, R> target) {\n        if (node == null) {\n            return empty();\n        } else if (node.jjtGetParent() == null) {\n            R apply = target.apply(node);\n            return apply != null ? singleton(apply) : empty();\n        }\n        return new FilteredAncestorOrSelfStream<>(node, target);\n    }\n\n    public static NodeStream<Node> ancestors(@NonNull Node node) {\n        return ancestorsOrSelf(node.jjtGetParent());\n    }\n\n    private static <R extends Node> NodeStream<R> ancestors(@NonNull Node node, Filtermap<Node, R> target) {\n        return ancestorsOrSelf(node.jjtGetParent(), target);\n    }\n\n    public static <R extends Node> NodeStream<R> ancestors(@NonNull Node node, Class<R> target) {\n        return ancestorsOrSelf(node.jjtGetParent(), Filtermap.isInstance(target));\n    }\n\n\n    private abstract static class AxisStream<R extends Node> extends IteratorBasedNStream<R> {\n\n        protected final Node node;\n        protected final Filtermap<Node, R> target;\n\n        AxisStream(@NonNull Node root, Filtermap<Node, R> target) {\n            super();\n            this.node = root;\n            this.target = target;\n        }\n\n        @Override\n        public final Iterator<R> iterator() {\n            return target.filterMap(baseIterator());\n        }\n\n        protected abstract Iterator<Node> baseIterator();\n\n\n        @Override\n        public NodeStream<R> filter(Predicate<? super R> predicate) {\n            return copyWithFilter(target.then(Filtermap.filter(predicate)));\n        }\n\n        @Override\n        public <S extends Node> NodeStream<S> filterIs(Class<S> r1Class) {\n            return copyWithFilter(target.thenCast(r1Class));\n        }\n\n        protected abstract <S extends Node> NodeStream<S> copyWithFilter(Filtermap<Node, S> filterMap);\n\n    }\n\n    private static class FilteredAncestorOrSelfStream<R extends Node> extends AxisStream<R> {\n\n        private FilteredAncestorOrSelfStream(@NonNull Node node, Filtermap<Node, R> target) {\n            super(node, target);\n        }\n\n        @Override\n        protected Iterator<Node> baseIterator() {\n            return new AncestorOrSelfIterator(node);\n        }\n\n        @Override\n        public NodeStream<R> drop(int n) {\n            AssertionUtil.assertArgNonNegative(n);\n            switch (n) {\n            case 0:\n                return this;\n            case 1:\n                return StreamImpl.ancestors(node, target);\n            default:\n                // eg for NodeStream.of(a,b,c).drop(2)\n                Node nth = get(n); // get(2) == c\n                return nth == null ? NodeStream.empty() : copy(nth); // c.ancestorsOrSelf() == [c]\n            }\n        }\n\n        @Override\n        protected <S extends Node> NodeStream<S> copyWithFilter(Filtermap<Node, S> filterMap) {\n            return new FilteredAncestorOrSelfStream<>(node, filterMap);\n        }\n\n        @Override\n        public @Nullable R first() {\n            return TraversalUtils.getFirstParentOrSelfMatching(node, target);\n        }\n\n        protected NodeStream<R> copy(Node start) {\n            return StreamImpl.ancestorsOrSelf(start, target);\n        }\n    }\n\n\n    private static class AncestorOrSelfStream extends FilteredAncestorOrSelfStream<Node> {\n\n        private AncestorOrSelfStream(@NonNull Node node) {\n            super(node, Filtermap.NODE_IDENTITY);\n        }\n\n        @Nullable\n        @Override\n        public Node first() {\n            return node;\n        }\n\n        @Override\n        public boolean nonEmpty() {\n            return true;\n        }\n\n        @Override\n        public @Nullable Node last() {\n            Node last = node;\n            while (last.jjtGetParent() != null) {\n                last = last.jjtGetParent();\n            }\n            return last;\n        }\n\n        @Override\n        protected NodeStream<Node> copy(Node start) {\n            return StreamImpl.ancestorsOrSelf(start);\n        }\n    }\n\n    private static class FilteredDescendantStream<R extends Node> extends AxisStream<R> {\n\n        FilteredDescendantStream(Node node, Filtermap<Node, R> target) {\n            super(node, target);\n        }\n\n        @Override\n        protected Iterator<Node> baseIterator() {\n            DescendantOrSelfIterator iter = new DescendantOrSelfIterator(node);\n            iter.next(); // skip self\n            return iter;\n        }\n\n        @Override\n        protected <S extends Node> NodeStream<S> copyWithFilter(Filtermap<Node, S> filterMap) {\n            return new FilteredDescendantStream<>(node, filterMap);\n        }\n\n        @Override\n        public @Nullable R first() {\n            return TraversalUtils.getFirstDescendantOfType(node, target);\n        }\n\n        @Override\n        public boolean nonEmpty() {\n            return TraversalUtils.getFirstDescendantOfType(node, target) != null;\n        }\n\n        @Override\n        public List<R> toList() {\n            List<R> result = new ArrayList<>();\n            TraversalUtils.findDescendantsOfType(node, target, result, false);\n            return result;\n        }\n    }\n\n    private static class DescendantStream extends FilteredDescendantStream<Node> {\n\n        DescendantStream(Node node) {\n            super(node, Filtermap.NODE_IDENTITY);\n        }\n\n        @Override\n        public boolean nonEmpty() {\n            return node.jjtGetNumChildren() > 0;\n        }\n    }\n\n    private static class FilteredDescendantOrSelfStream<R extends Node> extends AxisStream<R> {\n\n        FilteredDescendantOrSelfStream(Node node, Filtermap<Node, R> filtermap) {\n            super(node, filtermap);\n        }\n\n        @Override\n        public Iterator<Node> baseIterator() {\n            return new DescendantOrSelfIterator(node);\n        }\n\n        @Override\n        protected <S extends Node> NodeStream<S> copyWithFilter(Filtermap<Node, S> filterMap) {\n            return new FilteredDescendantStream<>(node, filterMap);\n        }\n\n        @Override\n        public List<R> toList() {\n            List<R> result = new ArrayList<>();\n            R top = target.apply(node);\n            if (top != null) {\n                result.add(top);\n            }\n            TraversalUtils.findDescendantsOfType(node, target, result, false);\n            return result;\n        }\n    }\n\n    private static final class DescendantOrSelfStream extends FilteredDescendantOrSelfStream<Node> {\n\n        DescendantOrSelfStream(Node node) {\n            super(node, Filtermap.NODE_IDENTITY);\n        }\n\n        @Nullable\n        @Override\n        public Node first() {\n            return node;\n        }\n\n        @Override\n        public boolean nonEmpty() {\n            return true;\n        }\n    }\n\n    private static class FilteredChildrenStream<R extends Node> extends AxisStream<R> {\n\n        FilteredChildrenStream(@NonNull Node node, Filtermap<Node, R> target) {\n            super(node, target);\n        }\n\n        @Override\n        protected <S extends Node> NodeStream<S> copyWithFilter(Filtermap<Node, S> filterMap) {\n            return new FilteredChildrenStream<>(node, filterMap);\n        }\n\n        @Override\n        public Spliterator<R> spliterator() {\n            return Spliterators.spliterator(iterator(), count(), Spliterator.SIZED | Spliterator.ORDERED);\n        }\n\n        @Override\n        protected Iterator<Node> baseIterator() {\n            return TraversalUtils.childrenIterator(node);\n        }\n\n        @Override\n        public @Nullable R first() {\n            return TraversalUtils.getFirstChildMatching(node, target);\n        }\n\n        @Override\n        public @Nullable R last() {\n            return TraversalUtils.getLastChildMatching(node, target);\n        }\n\n\n        @Override\n        public <R extends Node> @Nullable R first(Class<R> rClass) {\n            return TraversalUtils.getFirstChildMatching(node, target.thenCast(rClass));\n        }\n\n        @Override\n        public <R extends Node> @Nullable R last(Class<R> rClass) {\n            return TraversalUtils.getLastChildMatching(node, target.thenCast(rClass));\n        }\n\n        @Override\n        public int count() {\n            return TraversalUtils.countChildrenMatching(node, target);\n        }\n\n        @Override\n        public boolean nonEmpty() {\n            return TraversalUtils.getFirstChildMatching(node, target) != null;\n        }\n\n        @Override\n        public List<R> toList() {\n            return TraversalUtils.findChildrenMatching(node, target);\n        }\n    }\n\n    /** Implements following/preceding sibling streams. */\n    private static class SlicedChildrenStream extends IteratorBasedNStream<Node> {\n\n        private final Node node;\n        private final int low; // inclusive\n        private final int high; // exclusive\n\n        SlicedChildrenStream(@NonNull Node root, int low, int high) {\n            this.node = root;\n            this.low = low;\n            this.high = high;\n        }\n\n\n        @Override\n        public Spliterator<Node> spliterator() {\n            return Spliterators.spliterator(iterator(), count(), Spliterator.SIZED | Spliterator.ORDERED);\n        }\n\n        @Override\n        public Iterator<Node> iterator() {\n            return count() > 0 ? TraversalUtils.childrenIterator(node, low, high)\n                               : IteratorUtil.emptyIterator();\n        }\n\n        @Nullable\n        @Override\n        public Node first() {\n            return low < high && low >= 0 ? node.jjtGetChild(low) : null;\n        }\n\n        @Nullable\n        @Override\n        public Node last() {\n            return low < high && high <= node.jjtGetNumChildren() ? node.jjtGetChild(high - 1) : null;\n        }\n\n        @Override\n        public NodeStream<Node> take(int maxSize) {\n            return new SlicedChildrenStream(node, low, high - maxSize);\n        }\n\n        @Override\n        public NodeStream<Node> drop(int n) {\n            return new SlicedChildrenStream(node, low + n, high);\n        }\n\n        @Override\n        public boolean nonEmpty() {\n            return count() > 0;\n        }\n\n        @Override\n        public int count() {\n            return Math.min(Math.max(high - low, 0), node.jjtGetNumChildren());\n        }\n    }\n}\n",
        "filePathAfter": "pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/StreamImpl.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.ast.internal;\n\n\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.Spliterator;\nimport java.util.Spliterators;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport net.sourceforge.pmd.internal.util.Filtermap;\nimport net.sourceforge.pmd.internal.util.IteratorUtil;\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.ast.NodeStream;\nimport net.sourceforge.pmd.lang.ast.internal.AxisStream.AncestorOrSelfStream;\nimport net.sourceforge.pmd.lang.ast.internal.AxisStream.ChildrenStream;\nimport net.sourceforge.pmd.lang.ast.internal.AxisStream.DescendantOrSelfStream;\nimport net.sourceforge.pmd.lang.ast.internal.AxisStream.DescendantStream;\nimport net.sourceforge.pmd.lang.ast.internal.AxisStream.FilteredAncestorOrSelfStream;\nimport net.sourceforge.pmd.lang.ast.internal.AxisStream.FilteredChildrenStream;\nimport net.sourceforge.pmd.lang.ast.internal.AxisStream.FilteredDescendantStream;\nimport net.sourceforge.pmd.lang.ast.internal.AxisStream.SlicedChildrenStream;\n\npublic final class StreamImpl {\n\n    private static final NodeStream EMPTY = new IteratorBasedNStream() {\n        @Override\n        public Iterator iterator() {\n            return Collections.emptyIterator();\n        }\n    };\n\n    private StreamImpl() {\n        // utility class\n    }\n\n    public static <T extends Node> NodeStream<T> singleton(@NonNull T node) {\n        return new SingletonNodeStream<>(node);\n    }\n\n    public static <T extends Node> NodeStream<T> fromIterable(Iterable<T> iterable) {\n        return new IteratorBasedNStream<T>() {\n            @Override\n            public Iterator<T> iterator() {\n                return IteratorUtil.filterNotNull(iterable.iterator());\n            }\n\n            @Override\n            public Spliterator<T> spliterator() {\n                Spliterator<T> spliter = iterable.spliterator();\n                return Spliterators.spliterator(iterator(), spliter.estimateSize(),\n                                                spliter.characteristics() & Spliterator.NONNULL & ~Spliterator.SIZED\n                                                    & ~Spliterator.SUBSIZED);\n            }\n        };\n    }\n\n    public static <T extends Node> NodeStream<T> union(Iterable<? extends @Nullable NodeStream<? extends T>> streams) {\n        return new IteratorBasedNStream<T>() {\n            @Override\n            public Iterator<T> iterator() {\n                return IteratorUtil.flatMap(streams.iterator(), NodeStream::iterator);\n            }\n        };\n    }\n\n\n    @SuppressWarnings(\"unchecked\")\n    public static <T extends Node> NodeStream<T> empty() {\n        return EMPTY;\n    }\n\n    public static <R extends Node> NodeStream<R> children(@NonNull Node node, Class<R> target) {\n        return new FilteredChildrenStream<>(node, Filtermap.isInstance(target));\n    }\n\n    public static NodeStream<Node> children(@NonNull Node root) {\n        return new ChildrenStream(root);\n    }\n\n    public static NodeStream<Node> descendants(@NonNull Node node) {\n        return new DescendantStream(node);\n    }\n\n    public static <R extends Node> NodeStream<R> descendants(@NonNull Node node, Class<R> rClass) {\n        return new FilteredDescendantStream<>(node, Filtermap.isInstance(rClass));\n    }\n\n    public static NodeStream<Node> descendantsOrSelf(@NonNull Node node) {\n        return new DescendantOrSelfStream(node);\n    }\n\n    public static NodeStream<Node> followingSiblings(@NonNull Node node) {\n        Node parent = node.jjtGetParent();\n        return parent == null ? empty()\n                              : new SlicedChildrenStream(parent, node.jjtGetChildIndex() + 1, parent.jjtGetNumChildren());\n    }\n\n    public static NodeStream<Node> precedingSiblings(@NonNull Node node) {\n        Node parent = node.jjtGetParent();\n        return parent == null ? empty()\n                              : new SlicedChildrenStream(parent, 0, node.jjtGetChildIndex());\n    }\n\n\n    static NodeStream<Node> ancestorsOrSelf(@Nullable Node node) {\n        if (node == null) {\n            return empty();\n        } else if (node.jjtGetParent() == null) {\n            return singleton(node);\n        }\n        return new AncestorOrSelfStream(node);\n    }\n\n    static <T extends Node> NodeStream<T> ancestorsOrSelf(@Nullable Node node, Filtermap<Node, T> target) {\n        if (node == null) {\n            return empty();\n        } else if (node.jjtGetParent() == null) {\n            T apply = target.apply(node);\n            return apply != null ? singleton(apply) : empty();\n        }\n        return new FilteredAncestorOrSelfStream<>(node, target);\n    }\n\n    public static NodeStream<Node> ancestors(@NonNull Node node) {\n        return ancestorsOrSelf(node.jjtGetParent());\n    }\n\n    static <R extends Node> NodeStream<R> ancestors(@NonNull Node node, Filtermap<Node, R> target) {\n        return ancestorsOrSelf(node.jjtGetParent(), target);\n    }\n\n    public static <R extends Node> NodeStream<R> ancestors(@NonNull Node node, Class<R> target) {\n        return ancestorsOrSelf(node.jjtGetParent(), Filtermap.isInstance(target));\n    }\n\n\n}\n",
        "diffSourceCodeSet": [
            "return apply != null ? singleton(apply) : empty();\n        }\n        return new FilteredAncestorOrSelfStream<>(node, target);"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.ast.internal.SingletonNodeStream#iterator\n methodBody: public Iterator<T> iterator() {\nreturn toList().iterator();\n}",
            "methodSignature: net.sourceforge.pmd.lang.ast.internal.StreamImpl.FilteredChildrenStream#spliterator\n methodBody: public Spliterator<R> spliterator() {\nreturn Spliterators.spliterator(iterator(),count(),Spliterator.SIZED | Spliterator.ORDERED);\n}",
            "methodSignature: net.sourceforge.pmd.lang.ast.internal.StreamImpl.AxisStream#iterator\n methodBody: public final Iterator<R> iterator() {\nreturn target.filterMap(baseIterator());\n}",
            "methodSignature: net.sourceforge.pmd.internal.util.IteratorUtil#mapNotNull\n methodBody: public static <T, R> Iterator<@NonNull R> mapNotNull(Iterator<? extends T> it, Function<? super @NonNull T, ? extends @Nullable R> mapper) {\nreturn new Iterator<R>(){\n  private R next;\n  @Override public boolean hasNext(){\n    if (next != null) {\n      return true;\n    }\n    while (it.hasNext()) {\n      T next1=it.next();\n      if (next1 != null) {\n        R map=mapper.apply(next1);\n        if (map != null) {\n          this.next=map;\n          return true;\n        }\n      }\n    }\n    next=null;\n    return false;\n  }\n  @Override public R next(){\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    R r=next;\n    next=null;\n    return r;\n  }\n}\n;\n}",
            "methodSignature: net.sourceforge.pmd.lang.ast.NodeStream#iterator\n methodBody: Iterator<T> iterator();",
            "methodSignature: net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream#iterator\n methodBody: public abstract Iterator<R> iterator();",
            "methodSignature: net.sourceforge.pmd.lang.ast.internal.StreamImpl.SlicedChildrenStream#spliterator\n methodBody: public Spliterator<Node> spliterator() {\nreturn Spliterators.spliterator(iterator(),count(),Spliterator.SIZED | Spliterator.ORDERED);\n}",
            "methodSignature: net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream.IteratorMapping#iterator\n methodBody: public Iterator<S> iterator() {\nreturn fun.apply(IteratorBasedNStream.this.iterator());\n}",
            "methodSignature: net.sourceforge.pmd.lang.ast.internal.IteratorBasedNStream#spliterator\n methodBody: public Spliterator<R> spliterator() {\nreturn Spliterators.spliteratorUnknownSize(iterator(),Spliterator.ORDERED);\n}",
            "methodSignature: net.sourceforge.pmd.lang.ast.internal.StreamImpl.SlicedChildrenStream#iterator\n methodBody: public Iterator<Node> iterator() {\nreturn count() > 0 ? TraversalUtils.childrenIterator(node,low,high) : IteratorUtil.emptyIterator();\n}"
        ],
        "sourceCodeAfterRefactoring": "public static <T extends Node> NodeStream<T> fromIterable(Iterable<T> iterable) {\n        return new IteratorBasedNStream<T>() {\n            @Override\n            public Iterator<T> iterator() {\n                return IteratorUtil.filterNotNull(iterable.iterator());\n            }\n\n            @Override\n            public Spliterator<T> spliterator() {\n                Spliterator<T> spliter = iterable.spliterator();\n                return Spliterators.spliterator(iterator(), spliter.estimateSize(),\n                                                spliter.characteristics() & Spliterator.NONNULL & ~Spliterator.SIZED\n                                                    & ~Spliterator.SUBSIZED);\n            }\n        };\n    }\nreturn apply != null ? singleton(apply) : empty();\n        }\n        return new FilteredAncestorOrSelfStream<>(node, target);",
        "diffSourceCode": "-   37:     public static <T extends Node> NodeStream<T> fromIterable(Iterable<T> iterable) {\n-   38:         return new IteratorBasedNStream<T>() {\n-   39:             @Override\n-   40:             public Iterator<T> iterator() {\n-   41:                 return IteratorUtil.mapNotNull(iterable.iterator(), Function.identity());\n-   42:             }\n-   43: \n-   44:             @Override\n-   45:             public Spliterator<T> spliterator() {\n-   46:                 Spliterator<T> spliter = iterable.spliterator();\n-   47:                 return Spliterators.spliterator(iterator(), spliter.estimateSize(),\n-   48:                                                 spliter.characteristics() & ~Spliterator.SIZED & ~Spliterator.SUBSIZED);\n-   49:             }\n-   50:         };\n-   51:     }\n+   37: \n+   38:     private StreamImpl() {\n+   39:         // utility class\n+   40:     }\n+   41: \n+   42:     public static <T extends Node> NodeStream<T> singleton(@NonNull T node) {\n+   43:         return new SingletonNodeStream<>(node);\n+   44:     }\n+   45: \n+   46:     public static <T extends Node> NodeStream<T> fromIterable(Iterable<T> iterable) {\n+   47:         return new IteratorBasedNStream<T>() {\n+   48:             @Override\n+   49:             public Iterator<T> iterator() {\n+   50:                 return IteratorUtil.filterNotNull(iterable.iterator());\n+   51:             }\n    52: \n-   53:     @SafeVarargs\n-   54:     public static <T extends Node> NodeStream<T> union(NodeStream<? extends T>... streams) {\n-   55:         return new IteratorBasedNStream<T>() {\n-   56:             @Override\n-   57:             public Iterator<T> iterator() {\n-   58:                 return IteratorUtil.flatMap(Arrays.asList(streams).iterator(), NodeStream::iterator);\n+   53:             @Override\n+   54:             public Spliterator<T> spliterator() {\n+   55:                 Spliterator<T> spliter = iterable.spliterator();\n+   56:                 return Spliterators.spliterator(iterator(), spliter.estimateSize(),\n+   57:                                                 spliter.characteristics() & Spliterator.NONNULL & ~Spliterator.SIZED\n+   58:                                                     & ~Spliterator.SUBSIZED);\n    59:             }\n    60:         };\n    61:     }\n-  125:     public static NodeStream<Node> ancestors(@NonNull Node node) {\n-  126:         return ancestorsOrSelf(node.jjtGetParent());\n-  127:     }\n+  125:             return apply != null ? singleton(apply) : empty();\n+  126:         }\n+  127:         return new FilteredAncestorOrSelfStream<>(node, target);\n",
        "uniqueId": "bc25e58dfc8b3fe32c173e2cf213bf9e83869ce0_37_51_125_127_46_61",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 5
            },
            "LINE": {
                "missed": 0,
                "covered": 1
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate isNullableComparisonWithStringLiteral(expression ASTPrimaryExpression) : boolean extracted from public visit(expression ASTPrimaryExpression, data Object) : Object in class net.sourceforge.pmd.lang.java.rule.bestpractices.LiteralsFirstInComparisonsRule",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/LiteralsFirstInComparisonsRule.java",
                "startLine": 32,
                "endLine": 43,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/LiteralsFirstInComparisonsRule.java",
                "startLine": 40,
                "endLine": 42,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/LiteralsFirstInComparisonsRule.java",
                "startLine": 50,
                "endLine": 55,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n    public Object visit(ASTPrimaryExpression expression, Object data) {\n        String opName = getOperationName(expression);\n        ASTPrimarySuffix primarySuffix = getSuffixOfArguments(expression);\n        if (opName == null || primarySuffix == null) {\n            return data;\n        }\n        if (isStringLiteralComparison(opName, primarySuffix) && !isWithinNullComparison(expression)) {\n            addViolation(data, expression);\n        }\n        return data;\n    }",
        "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/LiteralsFirstInComparisonsRule.java",
        "isPureRefactoring": true,
        "commitId": "c351314f3017acaafccce02334095f67944d4e29",
        "packageNameBefore": "net.sourceforge.pmd.lang.java.rule.bestpractices",
        "classNameBefore": "net.sourceforge.pmd.lang.java.rule.bestpractices.LiteralsFirstInComparisonsRule",
        "methodNameBefore": "net.sourceforge.pmd.lang.java.rule.bestpractices.LiteralsFirstInComparisonsRule#visit",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.java.rule.bestpractices.LiteralsFirstInComparisonsRule#getOperationName\n methodBody: private String getOperationName(ASTPrimaryExpression primaryExpression) {\nreturn isMethodsChain(primaryExpression) ? getOperationNameBySuffix(primaryExpression) : getOperationNameByPrefix(primaryExpression);\n}\nmethodSignature: net.sourceforge.pmd.lang.java.rule.bestpractices.LiteralsFirstInComparisonsRule#isStringLiteralComparison\n methodBody: private boolean isStringLiteralComparison(String opName, ASTPrimarySuffix argsSuffix) {\nreturn isComparisonOperation(opName) && isSingleStringLiteralArgument(argsSuffix);\n}\nmethodSignature: net.sourceforge.pmd.lang.java.rule.bestpractices.LiteralsFirstInComparisonsRule#isWithinNullComparison\n methodBody: private boolean isWithinNullComparison(ASTPrimaryExpression node) {\nfor(ASTExpression parentExpr: node.getParentsOfType(ASTExpression.class)){if(isNullComparison(parentExpr)){return true;\n}}return false;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.rule.bestpractices.LiteralsFirstInComparisonsRule#getSuffixOfArguments\n methodBody: private ASTPrimarySuffix getSuffixOfArguments(ASTPrimaryExpression primaryExpression) {\nreturn getPrimarySuffixAtIndexFromEnd(primaryExpression,0);\n}",
        "classSignatureBefore": "public class LiteralsFirstInComparisonsRule extends AbstractJavaRule ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.rule.bestpractices.LiteralsFirstInComparisonsRule#visit"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.rule.bestpractices.LiteralsFirstInComparisonsRule"
        ],
        "classSignatureBeforeSet": [
            "public class LiteralsFirstInComparisonsRule extends AbstractJavaRule "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics Severe changes",
                "description": "Return expression has been added within the Extract Method mechanics - with non-mapped leaves",
                "mappingState": 2
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.rule.bestpractices;\n\nimport java.util.List;\n\nimport net.sourceforge.pmd.lang.java.ast.ASTArgumentList;\nimport net.sourceforge.pmd.lang.java.ast.ASTArguments;\nimport net.sourceforge.pmd.lang.java.ast.ASTConditionalAndExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTConditionalOrExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTEqualityExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTName;\nimport net.sourceforge.pmd.lang.java.ast.ASTNullLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimarySuffix;\nimport net.sourceforge.pmd.lang.java.ast.JavaNode;\nimport net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;\n\npublic class LiteralsFirstInComparisonsRule extends AbstractJavaRule {\n\n    private static final String[] COMPARISON_OPS = {\".equals\", \".equalsIgnoreCase\", \".compareTo\", \".compareToIgnoreCase\", \".contentEquals\"};\n\n    public LiteralsFirstInComparisonsRule() {\n        addRuleChainVisit(ASTPrimaryExpression.class);\n    }\n\n    @Override\n    public Object visit(ASTPrimaryExpression expression, Object data) {\n        String opName = getOperationName(expression);\n        ASTPrimarySuffix primarySuffix = getSuffixOfArguments(expression);\n        if (opName == null || primarySuffix == null) {\n            return data;\n        }\n        if (isStringLiteralComparison(opName, primarySuffix) && !isWithinNullComparison(expression)) {\n            addViolation(data, expression);\n        }\n        return data;\n    }\n\n    private String getOperationName(ASTPrimaryExpression primaryExpression) {\n        return isMethodsChain(primaryExpression) ? getOperationNameBySuffix(primaryExpression)\n                : getOperationNameByPrefix(primaryExpression);\n    }\n\n    private boolean isMethodsChain(ASTPrimaryExpression primaryExpression) {\n        return primaryExpression.getNumChildren() > 2;\n    }\n\n    private String getOperationNameBySuffix(ASTPrimaryExpression primaryExpression) {\n        ASTPrimarySuffix opAsSuffix = getPrimarySuffixAtIndexFromEnd(primaryExpression, 1);\n        if (opAsSuffix != null) {\n            String opName = opAsSuffix.getImage(); // name of pattern \"operation\"\n            return \".\" + opName;\n        }\n        return null;\n    }\n\n    private String getOperationNameByPrefix(ASTPrimaryExpression primaryExpression) {\n        ASTPrimaryPrefix opAsPrefix = primaryExpression.getFirstChildOfType(ASTPrimaryPrefix.class);\n        if (opAsPrefix != null) {\n            ASTName opName = opAsPrefix.getFirstChildOfType(ASTName.class); // name of pattern \"*.operation\"\n            return opName != null ? opName.getImage() : null;\n        }\n        return null;\n    }\n\n    private ASTPrimarySuffix getSuffixOfArguments(ASTPrimaryExpression primaryExpression) {\n        return getPrimarySuffixAtIndexFromEnd(primaryExpression, 0);\n    }\n\n    private ASTPrimarySuffix getPrimarySuffixAtIndexFromEnd(ASTPrimaryExpression primaryExpression, int indexFromEnd) {\n        List<ASTPrimarySuffix> primarySuffixes = primaryExpression.findChildrenOfType(ASTPrimarySuffix.class);\n        if (!primarySuffixes.isEmpty()) {\n            int suffixIndex = primarySuffixes.size() - 1 - indexFromEnd;\n            return primarySuffixes.get(suffixIndex);\n        }\n        return null;\n    }\n\n    private boolean isStringLiteralComparison(String opName, ASTPrimarySuffix argsSuffix) {\n        return isComparisonOperation(opName) && isSingleStringLiteralArgument(argsSuffix);\n    }\n\n    private boolean isComparisonOperation(String op) {\n        for (String comparisonOp : COMPARISON_OPS) {\n            if (op.endsWith(comparisonOp)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /*\n     * This corresponds to the following XPath expression:\n     * (../PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Literal[@StringLiteral= true()])\n     *       and\n     * ( count(../PrimarySuffix/Arguments/ArgumentList/Expression) = 1 )\n     */\n    private boolean isSingleStringLiteralArgument(ASTPrimarySuffix primarySuffix) {\n        return isSingleArgumentSuffix(primarySuffix) && isStringLiteralFirstArgumentOfSuffix(primarySuffix);\n    }\n\n    private boolean isSingleArgumentSuffix(ASTPrimarySuffix primarySuffix) {\n        return primarySuffix.getArgumentCount() == 1;\n    }\n\n    private boolean isStringLiteralFirstArgumentOfSuffix(ASTPrimarySuffix primarySuffix) {\n        try {\n            JavaNode firstArg = getFirstArgument(primarySuffix);\n            return isStringLiteral(firstArg);\n        } catch (NullPointerException e) {\n            return false;\n        }\n    }\n\n    private JavaNode getFirstArgument(ASTPrimarySuffix primarySuffix) {\n        ASTArguments arguments = primarySuffix.getFirstChildOfType(ASTArguments.class);\n        ASTArgumentList argumentList = arguments.getFirstChildOfType(ASTArgumentList.class);\n        ASTExpression expression = argumentList.getFirstChildOfType(ASTExpression.class);\n        ASTPrimaryExpression primaryExpression = expression.getFirstChildOfType(ASTPrimaryExpression.class);\n        ASTPrimaryPrefix primaryPrefix = primaryExpression.getFirstChildOfType(ASTPrimaryPrefix.class);\n        return primaryPrefix.getFirstChildOfType(ASTLiteral.class);\n    }\n\n    private boolean isStringLiteral(JavaNode node) {\n        if (node instanceof ASTLiteral) {\n            ASTLiteral literal = (ASTLiteral) node;\n            return literal.isStringLiteral();\n        }\n        return false;\n    }\n\n    /*\n     * Expression/ConditionalAndExpression//EqualityExpression(@Image='!=']//NullLiteral\n     * Expression/ConditionalOrExpression//EqualityExpression(@Image='==']//NullLiteral\n     */\n    private boolean isWithinNullComparison(ASTPrimaryExpression node) {\n        for (ASTExpression parentExpr : node.getParentsOfType(ASTExpression.class)) {\n            if (isNullComparison(parentExpr)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean isNullComparison(ASTExpression expression) {\n        return isAndNotNullComparison(expression) || isOrNullComparison(expression);\n    }\n\n    private boolean isAndNotNullComparison(ASTExpression expression) {\n        ASTConditionalAndExpression andExpression = expression\n                .getFirstChildOfType(ASTConditionalAndExpression.class);\n        return andExpression != null && hasEqualityExpressionWithNullLiteral(andExpression, \"!=\");\n    }\n\n    private boolean isOrNullComparison(ASTExpression expression) {\n        ASTConditionalOrExpression orExpression = expression\n                .getFirstChildOfType(ASTConditionalOrExpression.class);\n        return orExpression != null && hasEqualityExpressionWithNullLiteral(orExpression, \"==\");\n    }\n\n    private boolean hasEqualityExpressionWithNullLiteral(JavaNode node, String equalityOp) {\n        ASTEqualityExpression equalityExpression = node.getFirstDescendantOfType(ASTEqualityExpression.class);\n        if (equalityExpression != null && equalityExpression.hasImageEqualTo(equalityOp)) {\n            return equalityExpression.hasDescendantOfType(ASTNullLiteral.class);\n        }\n        return false;\n    }\n}\n",
        "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/LiteralsFirstInComparisonsRule.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.rule.bestpractices;\n\nimport java.util.List;\n\nimport net.sourceforge.pmd.lang.java.ast.ASTArgumentList;\nimport net.sourceforge.pmd.lang.java.ast.ASTArguments;\nimport net.sourceforge.pmd.lang.java.ast.ASTConditionalAndExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTConditionalOrExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTEqualityExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTName;\nimport net.sourceforge.pmd.lang.java.ast.ASTNullLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimarySuffix;\nimport net.sourceforge.pmd.lang.java.ast.JavaNode;\nimport net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;\n\npublic class LiteralsFirstInComparisonsRule extends AbstractJavaRule {\n\n    private static final String[] COMPARISON_OPS = {\".equals\", \".equalsIgnoreCase\", \".compareTo\", \".compareToIgnoreCase\", \".contentEquals\"};\n\n    public LiteralsFirstInComparisonsRule() {\n        addRuleChainVisit(ASTPrimaryExpression.class);\n    }\n\n    @Override\n    public Object visit(ASTPrimaryExpression expression, Object data) {\n        if (violatesLiteralsFirstInComparisonsRule(expression)) {\n            addViolation(data, expression);\n        }\n        return data;\n    }\n\n    private boolean violatesLiteralsFirstInComparisonsRule(ASTPrimaryExpression expression) {\n        return !hasStringLiteralFirst(expression) && isNullableComparisonWithStringLiteral(expression);\n    }\n\n    private boolean hasStringLiteralFirst(ASTPrimaryExpression expression) {\n        ASTPrimaryPrefix primaryPrefix = expression.getFirstChildOfType(ASTPrimaryPrefix.class);\n        ASTLiteral firstLiteral = primaryPrefix.getFirstDescendantOfType(ASTLiteral.class);\n        return firstLiteral != null && firstLiteral.isStringLiteral();\n    }\n\n    private boolean isNullableComparisonWithStringLiteral(ASTPrimaryExpression expression) {\n        String opName = getOperationName(expression);\n        ASTPrimarySuffix argsSuffix = getSuffixOfArguments(expression);\n        return opName != null && argsSuffix != null && isStringLiteralComparison(opName, argsSuffix)\n                && isNotWithinNullComparison(expression);\n    }\n\n    private String getOperationName(ASTPrimaryExpression primaryExpression) {\n        return isMethodsChain(primaryExpression) ? getOperationNameBySuffix(primaryExpression)\n                : getOperationNameByPrefix(primaryExpression);\n    }\n\n    private boolean isMethodsChain(ASTPrimaryExpression primaryExpression) {\n        return primaryExpression.getNumChildren() > 2;\n    }\n\n    private String getOperationNameBySuffix(ASTPrimaryExpression primaryExpression) {\n        ASTPrimarySuffix opAsSuffix = getPrimarySuffixAtIndexFromEnd(primaryExpression, 1);\n        if (opAsSuffix != null) {\n            String opName = opAsSuffix.getImage(); // name of pattern \"operation\"\n            return \".\" + opName;\n        }\n        return null;\n    }\n\n    private String getOperationNameByPrefix(ASTPrimaryExpression primaryExpression) {\n        ASTPrimaryPrefix opAsPrefix = primaryExpression.getFirstChildOfType(ASTPrimaryPrefix.class);\n        if (opAsPrefix != null) {\n            ASTName opName = opAsPrefix.getFirstChildOfType(ASTName.class); // name of pattern \"*.operation\"\n            return opName != null ? opName.getImage() : null;\n        }\n        return null;\n    }\n\n    private ASTPrimarySuffix getSuffixOfArguments(ASTPrimaryExpression primaryExpression) {\n        return getPrimarySuffixAtIndexFromEnd(primaryExpression, 0);\n    }\n\n    private ASTPrimarySuffix getPrimarySuffixAtIndexFromEnd(ASTPrimaryExpression primaryExpression, int indexFromEnd) {\n        List<ASTPrimarySuffix> primarySuffixes = primaryExpression.findChildrenOfType(ASTPrimarySuffix.class);\n        if (!primarySuffixes.isEmpty()) {\n            int suffixIndex = primarySuffixes.size() - 1 - indexFromEnd;\n            return primarySuffixes.get(suffixIndex);\n        }\n        return null;\n    }\n\n    private boolean isStringLiteralComparison(String opName, ASTPrimarySuffix argsSuffix) {\n        return isComparisonOperation(opName) && isSingleStringLiteralArgument(argsSuffix);\n    }\n\n    private boolean isComparisonOperation(String op) {\n        for (String comparisonOp : COMPARISON_OPS) {\n            if (op.endsWith(comparisonOp)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /*\n     * This corresponds to the following XPath expression:\n     * (../PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Literal[@StringLiteral= true()])\n     *       and\n     * ( count(../PrimarySuffix/Arguments/ArgumentList/Expression) = 1 )\n     */\n    private boolean isSingleStringLiteralArgument(ASTPrimarySuffix primarySuffix) {\n        return isSingleArgumentSuffix(primarySuffix) && isStringLiteralFirstArgumentOfSuffix(primarySuffix);\n    }\n\n    private boolean isSingleArgumentSuffix(ASTPrimarySuffix primarySuffix) {\n        return primarySuffix.getArgumentCount() == 1;\n    }\n\n    private boolean isStringLiteralFirstArgumentOfSuffix(ASTPrimarySuffix primarySuffix) {\n        try {\n            JavaNode firstArg = getFirstArgument(primarySuffix);\n            return isStringLiteral(firstArg);\n        } catch (NullPointerException e) {\n            return false;\n        }\n    }\n\n    private JavaNode getFirstArgument(ASTPrimarySuffix primarySuffix) {\n        ASTArguments arguments = primarySuffix.getFirstChildOfType(ASTArguments.class);\n        ASTArgumentList argumentList = arguments.getFirstChildOfType(ASTArgumentList.class);\n        ASTExpression expression = argumentList.getFirstChildOfType(ASTExpression.class);\n        ASTPrimaryExpression primaryExpression = expression.getFirstChildOfType(ASTPrimaryExpression.class);\n        ASTPrimaryPrefix primaryPrefix = primaryExpression.getFirstChildOfType(ASTPrimaryPrefix.class);\n        return primaryPrefix.getFirstChildOfType(ASTLiteral.class);\n    }\n\n    private boolean isStringLiteral(JavaNode node) {\n        if (node instanceof ASTLiteral) {\n            ASTLiteral literal = (ASTLiteral) node;\n            return literal.isStringLiteral();\n        }\n        return false;\n    }\n\n    private boolean isNotWithinNullComparison(ASTPrimaryExpression node) {\n        return !isWithinNullComparison(node);\n    }\n\n    /*\n     * Expression/ConditionalAndExpression//EqualityExpression(@Image='!=']//NullLiteral\n     * Expression/ConditionalOrExpression//EqualityExpression(@Image='==']//NullLiteral\n     */\n    private boolean isWithinNullComparison(ASTPrimaryExpression node) {\n        for (ASTExpression parentExpr : node.getParentsOfType(ASTExpression.class)) {\n            if (isNullComparison(parentExpr)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean isNullComparison(ASTExpression expression) {\n        return isAndNotNullComparison(expression) || isOrNullComparison(expression);\n    }\n\n    private boolean isAndNotNullComparison(ASTExpression expression) {\n        ASTConditionalAndExpression andExpression = expression\n                .getFirstChildOfType(ASTConditionalAndExpression.class);\n        return andExpression != null && hasEqualityExpressionWithNullLiteral(andExpression, \"!=\");\n    }\n\n    private boolean isOrNullComparison(ASTExpression expression) {\n        ASTConditionalOrExpression orExpression = expression\n                .getFirstChildOfType(ASTConditionalOrExpression.class);\n        return orExpression != null && hasEqualityExpressionWithNullLiteral(orExpression, \"==\");\n    }\n\n    private boolean hasEqualityExpressionWithNullLiteral(JavaNode node, String equalityOp) {\n        ASTEqualityExpression equalityExpression = node.getFirstDescendantOfType(ASTEqualityExpression.class);\n        if (equalityExpression != null && equalityExpression.hasImageEqualTo(equalityOp)) {\n            return equalityExpression.hasDescendantOfType(ASTNullLiteral.class);\n        }\n        return false;\n    }\n}\n",
        "diffSourceCodeSet": [
            "private boolean isNullableComparisonWithStringLiteral(ASTPrimaryExpression expression) {\n        String opName = getOperationName(expression);\n        ASTPrimarySuffix argsSuffix = getSuffixOfArguments(expression);\n        return opName != null && argsSuffix != null && isStringLiteralComparison(opName, argsSuffix)\n                && isNotWithinNullComparison(expression);\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.java.rule.bestpractices.LiteralsFirstInComparisonsRule#getOperationName\n methodBody: private String getOperationName(ASTPrimaryExpression primaryExpression) {\nreturn isMethodsChain(primaryExpression) ? getOperationNameBySuffix(primaryExpression) : getOperationNameByPrefix(primaryExpression);\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.rule.bestpractices.LiteralsFirstInComparisonsRule#isStringLiteralComparison\n methodBody: private boolean isStringLiteralComparison(String opName, ASTPrimarySuffix argsSuffix) {\nreturn isComparisonOperation(opName) && isSingleStringLiteralArgument(argsSuffix);\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.rule.bestpractices.LiteralsFirstInComparisonsRule#isWithinNullComparison\n methodBody: private boolean isWithinNullComparison(ASTPrimaryExpression node) {\nfor(ASTExpression parentExpr: node.getParentsOfType(ASTExpression.class)){if(isNullComparison(parentExpr)){return true;\n}}return false;\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.rule.bestpractices.LiteralsFirstInComparisonsRule#getSuffixOfArguments\n methodBody: private ASTPrimarySuffix getSuffixOfArguments(ASTPrimaryExpression primaryExpression) {\nreturn getPrimarySuffixAtIndexFromEnd(primaryExpression,0);\n}"
        ],
        "sourceCodeAfterRefactoring": "private boolean violatesLiteralsFirstInComparisonsRule(ASTPrimaryExpression expression) {\n        return !hasStringLiteralFirst(expression) && isNullableComparisonWithStringLiteral(expression);\n    }\nprivate boolean isNullableComparisonWithStringLiteral(ASTPrimaryExpression expression) {\n        String opName = getOperationName(expression);\n        ASTPrimarySuffix argsSuffix = getSuffixOfArguments(expression);\n        return opName != null && argsSuffix != null && isStringLiteralComparison(opName, argsSuffix)\n                && isNotWithinNullComparison(expression);\n    }",
        "diffSourceCode": "    32:     @Override\n    33:     public Object visit(ASTPrimaryExpression expression, Object data) {\n-   34:         String opName = getOperationName(expression);\n-   35:         ASTPrimarySuffix primarySuffix = getSuffixOfArguments(expression);\n-   36:         if (opName == null || primarySuffix == null) {\n-   37:             return data;\n-   38:         }\n-   39:         if (isStringLiteralComparison(opName, primarySuffix) && !isWithinNullComparison(expression)) {\n-   40:             addViolation(data, expression);\n-   41:         }\n-   42:         return data;\n-   43:     }\n-   50:     private boolean isMethodsChain(ASTPrimaryExpression primaryExpression) {\n-   51:         return primaryExpression.getNumChildren() > 2;\n-   52:     }\n-   53: \n-   54:     private String getOperationNameBySuffix(ASTPrimaryExpression primaryExpression) {\n-   55:         ASTPrimarySuffix opAsSuffix = getPrimarySuffixAtIndexFromEnd(primaryExpression, 1);\n+   34:         if (violatesLiteralsFirstInComparisonsRule(expression)) {\n+   35:             addViolation(data, expression);\n+   36:         }\n+   37:         return data;\n+   38:     }\n+   39: \n+   40:     private boolean violatesLiteralsFirstInComparisonsRule(ASTPrimaryExpression expression) {\n+   41:         return !hasStringLiteralFirst(expression) && isNullableComparisonWithStringLiteral(expression);\n+   42:     }\n+   43: \n+   50:     private boolean isNullableComparisonWithStringLiteral(ASTPrimaryExpression expression) {\n+   51:         String opName = getOperationName(expression);\n+   52:         ASTPrimarySuffix argsSuffix = getSuffixOfArguments(expression);\n+   53:         return opName != null && argsSuffix != null && isStringLiteralComparison(opName, argsSuffix)\n+   54:                 && isNotWithinNullComparison(expression);\n+   55:     }\n",
        "uniqueId": "c351314f3017acaafccce02334095f67944d4e29_32_43_50_55_40_42",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 29
            },
            "BRANCH": {
                "missed": 0,
                "covered": 8
            },
            "LINE": {
                "missed": 0,
                "covered": 7
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 5
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Move Method",
        "description": "Move Method\tpublic testIncrement() : void from class net.sourceforge.pmd.cpd.DartTokenizerTest2 to public testIncrement() : void from class net.sourceforge.pmd.cpd.DartTokenizerTest",
        "diffLocations": [
            {
                "filePath": "pmd-dart/src/test/java/net/sourceforge/pmd/cpd/DartTokenizerTest2.java",
                "startLine": 43,
                "endLine": 46,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-dart/src/test/java/net/sourceforge/pmd/cpd/DartTokenizerTest.java",
                "startLine": 44,
                "endLine": 47,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n    public void testIncrement() {\n        doTest(\"increment\");\n    }",
        "filePathBefore": "pmd-dart/src/test/java/net/sourceforge/pmd/cpd/DartTokenizerTest2.java",
        "isPureRefactoring": true,
        "commitId": "1540ec6d9148fc14fc1673f4df1d33030d2ffcf7",
        "packageNameBefore": "net.sourceforge.pmd.cpd",
        "classNameBefore": "net.sourceforge.pmd.cpd.DartTokenizerTest2",
        "methodNameBefore": "net.sourceforge.pmd.cpd.DartTokenizerTest2#testIncrement",
        "classSignatureBefore": "public class DartTokenizerTest2 extends CpdTextComparisonTest ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.cpd.DartTokenizerTest2#testIncrement"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.cpd.DartTokenizerTest2"
        ],
        "classSignatureBeforeSet": [
            "public class DartTokenizerTest2 extends CpdTextComparisonTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.cpd;\n\nimport org.junit.Test;\n\nimport net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;\n\npublic class DartTokenizerTest2 extends CpdTextComparisonTest {\n\n    public DartTokenizerTest2() {\n        super(\".dart\");\n    }\n\n    @Override\n    protected String getResourcePrefix() {\n        return \"\";\n    }\n\n    @Override\n    public Tokenizer newTokenizer() {\n        return new DartTokenizer();\n    }\n\n    @Test\n    public void testComment() {\n        doTest(\"comment\");\n    }\n\n\n    @Test\n    public void testMultiline() {\n        doTest(\"string_multiline\");\n    }\n\n    @Test\n    public void testStringWithBackslashes() {\n        doTest(\"string_with_backslashes\");\n    }\n\n    @Test\n    public void testIncrement() {\n        doTest(\"increment\");\n    }\n\n\n\n}\n",
        "filePathAfter": "pmd-dart/src/test/java/net/sourceforge/pmd/cpd/DartTokenizerTest.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.cpd;\n\nimport org.junit.Test;\n\nimport net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;\n\npublic class DartTokenizerTest extends CpdTextComparisonTest {\n\n    public DartTokenizerTest() {\n        super(\".dart\");\n    }\n\n    @Override\n    public Tokenizer newTokenizer() {\n        return new DartTokenizer();\n    }\n\n\n    @Test\n    public void testComment() {\n        doTest(\"comment\");\n    }\n\n    @Test\n    public void testEscapeSequences() {\n        doTest(\"escape_sequences\");\n    }\n\n    @Test\n    public void testEscapedBackslash() {\n        doTest(\"escaped_backslash\");\n    }\n\n    @Test\n    public void testEscapedString() {\n        doTest(\"escaped_string\");\n    }\n\n\n    @Test\n    public void testIncrement() {\n        doTest(\"increment\");\n    }\n\n\n    @Test\n    public void testImports() {\n        doTest(\"imports\");\n    }\n\n\n\n    @Test\n    public void testRegex() {\n        doTest(\"regex\");\n    }\n\n\n    @Test\n    public void testRegex2() {\n        doTest(\"regex2\");\n    }\n\n    @Test\n    public void testRegex3() {\n        doTest(\"regex3\");\n    }\n\n    @Test\n    public void testStringWithBackslashes() {\n        doTest(\"string_with_backslashes\");\n    }\n\n    @Test\n    public void testMultiline() {\n        doTest(\"string_multiline\");\n    }\n\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "@Test\n    public void testIncrement() {\n        doTest(\"increment\");\n    }",
        "diffSourceCode": "-   43:     @Test\n-   44:     public void testIncrement() {\n-   45:         doTest(\"increment\");\n-   46:     }\n-   47: \n+   43: \n+   44:     @Test\n+   45:     public void testIncrement() {\n+   46:         doTest(\"increment\");\n+   47:     }\n",
        "uniqueId": "1540ec6d9148fc14fc1673f4df1d33030d2ffcf7_43_46__44_47",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate getOutputStream() : OutputStream extracted from public report(content String) : void in class net.sourceforge.pmd.cpd.FileReporter",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/cpd/FileReporter.java",
                "startLine": 39,
                "endLine": 48,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/cpd/FileReporter.java",
                "startLine": 40,
                "endLine": 46,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/cpd/FileReporter.java",
                "startLine": 48,
                "endLine": 50,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public void report(String content) throws ReportException {\n        try {\n            try (OutputStream outputStream = reportFile == null ? System.out : new FileOutputStream(reportFile);\n                 Writer writer = new BufferedWriter(new OutputStreamWriter(outputStream, encoding))) {\n                writer.write(content);\n            }\n        } catch (IOException ioe) {\n            throw new ReportException(ioe);\n        }\n    }",
        "filePathBefore": "pmd-core/src/main/java/net/sourceforge/pmd/cpd/FileReporter.java",
        "isPureRefactoring": true,
        "commitId": "0d9080abfd7ad43594562e35557b2298da899202",
        "packageNameBefore": "net.sourceforge.pmd.cpd",
        "classNameBefore": "net.sourceforge.pmd.cpd.FileReporter",
        "methodNameBefore": "net.sourceforge.pmd.cpd.FileReporter#report",
        "classSignatureBefore": "public class FileReporter ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.cpd.FileReporter#report"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.cpd.FileReporter"
        ],
        "classSignatureBeforeSet": [
            "public class FileReporter "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.cpd;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Writer;\n\nimport net.sourceforge.pmd.cpd.renderer.CPDRenderer;\n\n/**\n * @author Philippe T'Seyen\n * @deprecated {@link CPDRenderer} directly renders to a Writer\n */\n@Deprecated // to be removed with 7.0.0\npublic class FileReporter {\n    private File reportFile;\n    private String encoding;\n\n    public FileReporter(String encoding) {\n        this(null, encoding);\n    }\n\n    public FileReporter(File reportFile) {\n        this(reportFile, System.getProperty(\"file.encoding\"));\n    }\n\n    public FileReporter(File reportFile, String encoding) {\n        this.reportFile = reportFile;\n        this.encoding = encoding;\n    }\n\n    public void report(String content) throws ReportException {\n        try {\n            try (OutputStream outputStream = reportFile == null ? System.out : new FileOutputStream(reportFile);\n                 Writer writer = new BufferedWriter(new OutputStreamWriter(outputStream, encoding))) {\n                writer.write(content);\n            }\n        } catch (IOException ioe) {\n            throw new ReportException(ioe);\n        }\n    }\n}\n",
        "filePathAfter": "pmd-core/src/main/java/net/sourceforge/pmd/cpd/FileReporter.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.cpd;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Writer;\n\nimport net.sourceforge.pmd.cpd.renderer.CPDRenderer;\n\n/**\n * @author Philippe T'Seyen\n * @deprecated {@link CPDRenderer} directly renders to a Writer\n */\n@Deprecated // to be removed with 7.0.0\npublic class FileReporter {\n    private File reportFile;\n    private String encoding;\n\n    public FileReporter(String encoding) {\n        this(null, encoding);\n    }\n\n    public FileReporter(File reportFile) {\n        this(reportFile, System.getProperty(\"file.encoding\"));\n    }\n\n    public FileReporter(File reportFile, String encoding) {\n        this.reportFile = reportFile;\n        this.encoding = encoding;\n    }\n\n    public void report(String content) throws ReportException {\n        try (Writer writer = new BufferedWriter(new OutputStreamWriter(getOutputStream(), encoding))) {\n            writer.write(content);\n        } catch (IOException ioe) {\n            throw new ReportException(ioe);\n        }\n    }\n\n    private OutputStream getOutputStream() throws FileNotFoundException {\n        return reportFile == null ? System.out : new FileOutputStream(reportFile);\n    }\n}\n",
        "diffSourceCodeSet": [
            "private OutputStream getOutputStream() throws FileNotFoundException {\n        return reportFile == null ? System.out : new FileOutputStream(reportFile);\n    }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "public void report(String content) throws ReportException {\n        try (Writer writer = new BufferedWriter(new OutputStreamWriter(getOutputStream(), encoding))) {\n            writer.write(content);\n        } catch (IOException ioe) {\n            throw new ReportException(ioe);\n        }\n    }\nprivate OutputStream getOutputStream() throws FileNotFoundException {\n        return reportFile == null ? System.out : new FileOutputStream(reportFile);\n    }",
        "diffSourceCode": "-   39:     public void report(String content) throws ReportException {\n-   40:         try {\n-   41:             try (OutputStream outputStream = reportFile == null ? System.out : new FileOutputStream(reportFile);\n-   42:                  Writer writer = new BufferedWriter(new OutputStreamWriter(outputStream, encoding))) {\n-   43:                 writer.write(content);\n-   44:             }\n-   45:         } catch (IOException ioe) {\n-   46:             throw new ReportException(ioe);\n-   47:         }\n-   48:     }\n-   49: }\n+   39: \n+   40:     public void report(String content) throws ReportException {\n+   41:         try (Writer writer = new BufferedWriter(new OutputStreamWriter(getOutputStream(), encoding))) {\n+   42:             writer.write(content);\n+   43:         } catch (IOException ioe) {\n+   44:             throw new ReportException(ioe);\n+   45:         }\n+   46:     }\n+   47: \n+   48:     private OutputStream getOutputStream() throws FileNotFoundException {\n+   49:         return reportFile == null ? System.out : new FileOutputStream(reportFile);\n+   50:     }\n",
        "uniqueId": "0d9080abfd7ad43594562e35557b2298da899202_39_48_48_50_40_46",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 2,
                "covered": 30
            },
            "BRANCH": {
                "missed": 1,
                "covered": 1
            },
            "LINE": {
                "missed": 0,
                "covered": 7
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate parseAndTypeResolveForString(source String, version String) : ASTCompilationUnit extracted from private parseAndTypeResolveForClass(clazz Class<?>, version String) : ASTCompilationUnit in class net.sourceforge.pmd.typeresolution.ClassTypeResolverTest",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/test/java/net/sourceforge/pmd/typeresolution/ClassTypeResolverTest.java",
                "startLine": 508,
                "endLine": 519,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/test/java/net/sourceforge/pmd/typeresolution/ClassTypeResolverTest.java",
                "startLine": 546,
                "endLine": 559,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/test/java/net/sourceforge/pmd/typeresolution/ClassTypeResolverTest.java",
                "startLine": 561,
                "endLine": 567,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private ASTCompilationUnit parseAndTypeResolveForClass(Class<?> clazz, String version) {\n        String sourceFile = clazz.getName().replace('.', '/') + \".java\";\n        InputStream is = ClassTypeResolverTest.class.getClassLoader().getResourceAsStream(sourceFile);\n        if (is == null) {\n            throw new IllegalArgumentException(\"Unable to find source file \" + sourceFile + \" for \" + clazz);\n        }\n        LanguageVersionHandler languageVersionHandler = LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion(version).getLanguageVersionHandler();\n        ASTCompilationUnit acu = (ASTCompilationUnit) languageVersionHandler.getParser(languageVersionHandler.getDefaultParserOptions()).parse(null, new InputStreamReader(is));\n        languageVersionHandler.getSymbolFacade().start(acu);\n        languageVersionHandler.getTypeResolutionFacade(ClassTypeResolverTest.class.getClassLoader()).start(acu);\n        return acu;\n    }",
        "filePathBefore": "pmd-java/src/test/java/net/sourceforge/pmd/typeresolution/ClassTypeResolverTest.java",
        "isPureRefactoring": true,
        "commitId": "e6d67312e130b913c9beeb76948da4f4f3b8aa2a",
        "packageNameBefore": "net.sourceforge.pmd.typeresolution",
        "classNameBefore": "net.sourceforge.pmd.typeresolution.ClassTypeResolverTest",
        "methodNameBefore": "net.sourceforge.pmd.typeresolution.ClassTypeResolverTest#parseAndTypeResolveForClass",
        "classSignatureBefore": "public class ClassTypeResolverTest ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.typeresolution.ClassTypeResolverTest#parseAndTypeResolveForClass"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.typeresolution.ClassTypeResolverTest"
        ],
        "classSignatureBeforeSet": [
            "public class ClassTypeResolverTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\nOverlapped refactoring - can be identical by undoing the overlapped refactoring\n- Rename Variable-",
                "description": "Rename Variable on top of the extract method - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\npackage net.sourceforge.pmd.typeresolution;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNull;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.jaxen.JaxenException;\nimport org.junit.Test;\nimport net.sourceforge.pmd.lang.LanguageRegistry;\nimport net.sourceforge.pmd.lang.LanguageVersionHandler;\nimport net.sourceforge.pmd.lang.java.JavaLanguageModule;\nimport net.sourceforge.pmd.lang.java.ast.ASTAllocationExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTBooleanLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType;\nimport net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;\nimport net.sourceforge.pmd.lang.java.ast.ASTExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;\nimport net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTName;\nimport net.sourceforge.pmd.lang.java.ast.ASTNullLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTReferenceType;\nimport net.sourceforge.pmd.lang.java.ast.ASTStatementExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTType;\nimport net.sourceforge.pmd.lang.java.ast.ASTTypeDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableDeclarator;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;\nimport net.sourceforge.pmd.lang.java.ast.TypeNode;\nimport net.sourceforge.pmd.lang.java.typeresolution.ClassTypeResolver;\nimport net.sourceforge.pmd.typeresolution.testdata.AnonymousInnerClass;\nimport net.sourceforge.pmd.typeresolution.testdata.ArrayListFound;\nimport net.sourceforge.pmd.typeresolution.testdata.DefaultJavaLangImport;\nimport net.sourceforge.pmd.typeresolution.testdata.EnumWithAnonymousInnerClass;\nimport net.sourceforge.pmd.typeresolution.testdata.ExtraTopLevelClass;\nimport net.sourceforge.pmd.typeresolution.testdata.InnerClass;\nimport net.sourceforge.pmd.typeresolution.testdata.Literals;\nimport net.sourceforge.pmd.typeresolution.testdata.Operators;\nimport net.sourceforge.pmd.typeresolution.testdata.Promotion;\n\n\npublic class ClassTypeResolverTest {\n\n    @Test\n    public void testClassNameExists() {\n        ClassTypeResolver classTypeResolver = new ClassTypeResolver();\n        assertEquals(true, classTypeResolver.classNameExists(\"java.lang.System\"));\n        assertEquals(false, classTypeResolver.classNameExists(\"im.sure.that.this.does.not.Exist\"));\n        assertEquals(true, classTypeResolver.classNameExists(\"java.awt.List\"));\n    }\n\n    @Test\n    public void acceptanceTest() {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(ArrayListFound.class);\n        assertEquals(ArrayListFound.class, acu.getFirstDescendantOfType(ASTTypeDeclaration.class).getType());\n        assertEquals(ArrayListFound.class, acu.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());\n        ASTImportDeclaration id = acu.getFirstDescendantOfType(ASTImportDeclaration.class);\n        assertEquals(\"java.util\", id.getPackage().getName());\n        assertEquals(ArrayList.class, id.getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTClassOrInterfaceType.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTReferenceType.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTType.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTVariableDeclaratorId.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTVariableDeclarator.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTFieldDeclaration.class).getType());\n\n        acu = parseAndTypeResolveForClass15(DefaultJavaLangImport.class);\n        assertEquals(String.class, acu.getFirstDescendantOfType(ASTClassOrInterfaceType.class).getType());\n        assertEquals(Override.class, acu.findDescendantsOfType(ASTName.class).get(1).getType());\n    }\n\n    /**\n     * See bug #1138 Anonymous inner class in enum causes NPE\n     */\n    @Test\n    public void testEnumAnonymousInnerClass() {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(EnumWithAnonymousInnerClass.class);\n        Class<?> inner = acu.getFirstDescendantOfType(ASTAllocationExpression.class)\n                .getFirstDescendantOfType(ASTClassOrInterfaceType.class).getType();\n        assertEquals(\"net.sourceforge.pmd.typeresolution.testdata.EnumWithAnonymousInnerClass$1\",\n                inner.getName());\n    }\n\n    @Test\n    public void testExtraTopLevelClass() throws ClassNotFoundException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(ExtraTopLevelClass.class);\n        Class<?> theExtraTopLevelClass = Class.forName(\"net.sourceforge.pmd.typeresolution.testdata.TheExtraTopLevelClass\");\n        // First class\n        ASTTypeDeclaration typeDeclaration = (ASTTypeDeclaration) acu.jjtGetChild(1);\n        assertEquals(ExtraTopLevelClass.class, typeDeclaration.getType());\n        assertEquals(ExtraTopLevelClass.class,\n                typeDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());\n        // Second class\n        typeDeclaration = (ASTTypeDeclaration) acu.jjtGetChild(2);\n        assertEquals(theExtraTopLevelClass, typeDeclaration.getType());\n        assertEquals(theExtraTopLevelClass,\n                typeDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());\n    }\n\n    @Test\n    public void testInnerClass() throws ClassNotFoundException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(InnerClass.class);\n        Class<?> theInnerClass = Class.forName(\"net.sourceforge.pmd.typeresolution.testdata.InnerClass$TheInnerClass\");\n        // Outer class\n        ASTTypeDeclaration typeDeclaration = acu.getFirstDescendantOfType(ASTTypeDeclaration.class);\n        assertEquals(InnerClass.class, typeDeclaration.getType());\n        ASTClassOrInterfaceDeclaration outerClassDeclaration = typeDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class);\n        assertEquals(InnerClass.class, outerClassDeclaration.getType());\n        // Inner class\n        assertEquals(theInnerClass,\n                outerClassDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());\n        // Method parameter as inner class\n        ASTFormalParameter formalParameter = typeDeclaration.getFirstDescendantOfType(ASTFormalParameter.class);\n        assertEquals(theInnerClass, formalParameter.getTypeNode().getType());\n    }\n\n    @Test\n    public void testAnonymousInnerClass() throws ClassNotFoundException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(AnonymousInnerClass.class);\n        Class<?> theAnonymousInnerClass = Class.forName(\"net.sourceforge.pmd.typeresolution.testdata.AnonymousInnerClass$1\");\n        // Outer class\n        ASTTypeDeclaration typeDeclaration = acu.getFirstDescendantOfType(ASTTypeDeclaration.class);\n        assertEquals(AnonymousInnerClass.class, typeDeclaration.getType());\n        ASTClassOrInterfaceDeclaration outerClassDeclaration = typeDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class);\n        assertEquals(AnonymousInnerClass.class, outerClassDeclaration.getType());\n        // Anonymous Inner class\n        assertEquals(theAnonymousInnerClass,\n                outerClassDeclaration.getFirstDescendantOfType(ASTAllocationExpression.class).getType());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testLiterals() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Literals.class);\n        List<ASTLiteral> literals = acu.findChildNodesWithXPath(\"//Literal\");\n        int index = 0;\n\n        // String s = \"s\";\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(String.class, literals.get(index++).getType());\n\n        // boolean boolean1 = false;\n        assertEquals(Boolean.TYPE, literals.get(index).getFirstDescendantOfType(ASTBooleanLiteral.class).getType());\n        assertEquals(Boolean.TYPE, literals.get(index++).getType());\n\n        // boolean boolean2 = true;\n        assertEquals(Boolean.TYPE, literals.get(index).getFirstDescendantOfType(ASTBooleanLiteral.class).getType());\n        assertEquals(Boolean.TYPE, literals.get(index++).getType());\n\n        // Object obj = null;\n        assertNull(literals.get(index).getFirstDescendantOfType(ASTNullLiteral.class).getType());\n        assertNull(literals.get(index++).getType());\n\n        // byte byte1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // byte byte2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // byte byte3 = -007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // short short1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // short short2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // short short3 = -007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // char char1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // char char2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // char char3 = 007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // char char4 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // int int1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // int int2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // int int3 = -007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // int int4 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // long long1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // long long2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // long long3 = -007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // long long4 = 0L;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Long.TYPE, literals.get(index++).getType());\n\n        // long long5 = 0x0Fl;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Long.TYPE, literals.get(index++).getType());\n\n        // long long6 = -007L;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Long.TYPE, literals.get(index++).getType());\n\n        // long long7 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // float float1 = 0.0f;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Float.TYPE, literals.get(index++).getType());\n\n        // float float2 = -10e+01f;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Float.TYPE, literals.get(index++).getType());\n\n        // float float3 = 0x08.08p3f;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Float.TYPE, literals.get(index++).getType());\n\n        // float float4 = 0xFF;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // float float5 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // double double1 = 0.0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Double.TYPE, literals.get(index++).getType());\n\n        // double double2 = -10e+01;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Double.TYPE, literals.get(index++).getType());\n\n        // double double3 = 0x08.08p3;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Double.TYPE, literals.get(index++).getType());\n\n        // double double4 = 0xFF;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // double double5 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All literals not tested\", index, literals.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testUnaryNumericPromotion() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Promotion.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericPromotion']]//Expression[UnaryExpression]\");\n        int index = 0;\n\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBinaryNumericPromotion() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Promotion.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'binaryNumericPromotion']]//Expression[AdditiveExpression]\");\n        int index = 0;\n\n        // LHS = byte\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = short\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = char\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = int\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = long\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = float\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = double\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBinaryStringPromotion() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Promotion.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'binaryStringPromotion']]//Expression\");\n        int index = 0;\n\n        assertEquals(String.class, expressions.get(index++).getType());\n        assertEquals(String.class, expressions.get(index++).getType());\n        assertEquals(String.class, expressions.get(index++).getType());\n        assertEquals(String.class, expressions.get(index++).getType());\n        assertEquals(String.class, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testUnaryLogicalOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Operators.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryLogicalOperators']]//Expression\");\n        int index = 0;\n\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBinaryLogicalOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Operators.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'binaryLogicalOperators']]//Expression\");\n        int index = 0;\n\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testUnaryNumericOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Operators.class);\n        List<TypeNode> expressions = new ArrayList<TypeNode>();\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//Expression\"));\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//PostfixExpression\"));\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//PreIncrementExpression\"));\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//PreDecrementExpression\"));\n        int index = 0;\n\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBinaryNumericOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Operators.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'binaryNumericOperators']]//Expression\");\n        int index = 0;\n\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testAssignmentOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Operators.class);\n        List<ASTStatementExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'assignmentOperators']]//StatementExpression\");\n        int index = 0;\n\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    public static junit.framework.Test suite() {\n        return new junit.framework.JUnit4TestAdapter(ClassTypeResolverTest.class);\n    }\n\n    private ASTCompilationUnit parseAndTypeResolveForClass15(Class<?> clazz) {\n        return parseAndTypeResolveForClass(clazz, \"1.5\");\n    }\n\n    // Note: If you're using Eclipse or some other IDE to run this test, you _must_ have the regress folder in\n    // the classpath.  Normally the IDE doesn't put source directories themselves directly in the classpath, only\n    // the output directories are in the classpath.\n    private ASTCompilationUnit parseAndTypeResolveForClass(Class<?> clazz, String version) {\n        String sourceFile = clazz.getName().replace('.', '/') + \".java\";\n        InputStream is = ClassTypeResolverTest.class.getClassLoader().getResourceAsStream(sourceFile);\n        if (is == null) {\n            throw new IllegalArgumentException(\"Unable to find source file \" + sourceFile + \" for \" + clazz);\n        }\n        LanguageVersionHandler languageVersionHandler = LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion(version).getLanguageVersionHandler();\n        ASTCompilationUnit acu = (ASTCompilationUnit) languageVersionHandler.getParser(languageVersionHandler.getDefaultParserOptions()).parse(null, new InputStreamReader(is));\n        languageVersionHandler.getSymbolFacade().start(acu);\n        languageVersionHandler.getTypeResolutionFacade(ClassTypeResolverTest.class.getClassLoader()).start(acu);\n        return acu;\n    }\n}\n",
        "filePathAfter": "pmd-java/src/test/java/net/sourceforge/pmd/typeresolution/ClassTypeResolverTest.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\npackage net.sourceforge.pmd.typeresolution;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNull;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\nimport net.sourceforge.pmd.lang.LanguageRegistry;\nimport net.sourceforge.pmd.lang.LanguageVersionHandler;\nimport net.sourceforge.pmd.lang.java.JavaLanguageModule;\nimport net.sourceforge.pmd.lang.java.ast.ASTAllocationExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTBooleanLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType;\nimport net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;\nimport net.sourceforge.pmd.lang.java.ast.ASTExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;\nimport net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTName;\nimport net.sourceforge.pmd.lang.java.ast.ASTNullLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTReferenceType;\nimport net.sourceforge.pmd.lang.java.ast.ASTStatementExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTType;\nimport net.sourceforge.pmd.lang.java.ast.ASTTypeDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableDeclarator;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;\nimport net.sourceforge.pmd.lang.java.ast.TypeNode;\nimport net.sourceforge.pmd.lang.java.symboltable.VariableNameDeclaration;\nimport net.sourceforge.pmd.lang.java.typeresolution.ClassTypeResolver;\nimport net.sourceforge.pmd.typeresolution.testdata.AnonymousInnerClass;\nimport net.sourceforge.pmd.typeresolution.testdata.ArrayListFound;\nimport net.sourceforge.pmd.typeresolution.testdata.DefaultJavaLangImport;\nimport net.sourceforge.pmd.typeresolution.testdata.EnumWithAnonymousInnerClass;\nimport net.sourceforge.pmd.typeresolution.testdata.ExtraTopLevelClass;\nimport net.sourceforge.pmd.typeresolution.testdata.InnerClass;\nimport net.sourceforge.pmd.typeresolution.testdata.Literals;\nimport net.sourceforge.pmd.typeresolution.testdata.Operators;\nimport net.sourceforge.pmd.typeresolution.testdata.Promotion;\n\nimport org.apache.commons.io.IOUtils;\nimport org.jaxen.JaxenException;\nimport org.junit.Assert;\nimport org.junit.Test;\n\n\npublic class ClassTypeResolverTest {\n\n    @Test\n    public void testClassNameExists() {\n        ClassTypeResolver classTypeResolver = new ClassTypeResolver();\n        assertEquals(true, classTypeResolver.classNameExists(\"java.lang.System\"));\n        assertEquals(false, classTypeResolver.classNameExists(\"im.sure.that.this.does.not.Exist\"));\n        assertEquals(true, classTypeResolver.classNameExists(\"java.awt.List\"));\n    }\n\n    @Test\n    public void acceptanceTest() {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(ArrayListFound.class);\n        assertEquals(ArrayListFound.class, acu.getFirstDescendantOfType(ASTTypeDeclaration.class).getType());\n        assertEquals(ArrayListFound.class, acu.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());\n        ASTImportDeclaration id = acu.getFirstDescendantOfType(ASTImportDeclaration.class);\n        assertEquals(\"java.util\", id.getPackage().getName());\n        assertEquals(ArrayList.class, id.getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTClassOrInterfaceType.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTReferenceType.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTType.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTVariableDeclaratorId.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTVariableDeclarator.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTFieldDeclaration.class).getType());\n\n        acu = parseAndTypeResolveForClass15(DefaultJavaLangImport.class);\n        assertEquals(String.class, acu.getFirstDescendantOfType(ASTClassOrInterfaceType.class).getType());\n        assertEquals(Override.class, acu.findDescendantsOfType(ASTName.class).get(1).getType());\n    }\n\n    /**\n     * See bug #1138 Anonymous inner class in enum causes NPE\n     */\n    @Test\n    public void testEnumAnonymousInnerClass() {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(EnumWithAnonymousInnerClass.class);\n        Class<?> inner = acu.getFirstDescendantOfType(ASTAllocationExpression.class)\n                .getFirstDescendantOfType(ASTClassOrInterfaceType.class).getType();\n        assertEquals(\"net.sourceforge.pmd.typeresolution.testdata.EnumWithAnonymousInnerClass$1\",\n                inner.getName());\n    }\n\n    @Test\n    public void testExtraTopLevelClass() throws ClassNotFoundException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(ExtraTopLevelClass.class);\n        Class<?> theExtraTopLevelClass = Class.forName(\"net.sourceforge.pmd.typeresolution.testdata.TheExtraTopLevelClass\");\n        // First class\n        ASTTypeDeclaration typeDeclaration = (ASTTypeDeclaration) acu.jjtGetChild(1);\n        assertEquals(ExtraTopLevelClass.class, typeDeclaration.getType());\n        assertEquals(ExtraTopLevelClass.class,\n                typeDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());\n        // Second class\n        typeDeclaration = (ASTTypeDeclaration) acu.jjtGetChild(2);\n        assertEquals(theExtraTopLevelClass, typeDeclaration.getType());\n        assertEquals(theExtraTopLevelClass,\n                typeDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());\n    }\n\n    @Test\n    public void testInnerClass() throws ClassNotFoundException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(InnerClass.class);\n        Class<?> theInnerClass = Class.forName(\"net.sourceforge.pmd.typeresolution.testdata.InnerClass$TheInnerClass\");\n        // Outer class\n        ASTTypeDeclaration typeDeclaration = acu.getFirstDescendantOfType(ASTTypeDeclaration.class);\n        assertEquals(InnerClass.class, typeDeclaration.getType());\n        ASTClassOrInterfaceDeclaration outerClassDeclaration = typeDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class);\n        assertEquals(InnerClass.class, outerClassDeclaration.getType());\n        // Inner class\n        assertEquals(theInnerClass,\n                outerClassDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());\n        // Method parameter as inner class\n        ASTFormalParameter formalParameter = typeDeclaration.getFirstDescendantOfType(ASTFormalParameter.class);\n        assertEquals(theInnerClass, formalParameter.getTypeNode().getType());\n    }\n\n    @Test\n    public void testAnonymousInnerClass() throws ClassNotFoundException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(AnonymousInnerClass.class);\n        Class<?> theAnonymousInnerClass = Class.forName(\"net.sourceforge.pmd.typeresolution.testdata.AnonymousInnerClass$1\");\n        // Outer class\n        ASTTypeDeclaration typeDeclaration = acu.getFirstDescendantOfType(ASTTypeDeclaration.class);\n        assertEquals(AnonymousInnerClass.class, typeDeclaration.getType());\n        ASTClassOrInterfaceDeclaration outerClassDeclaration = typeDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class);\n        assertEquals(AnonymousInnerClass.class, outerClassDeclaration.getType());\n        // Anonymous Inner class\n        assertEquals(theAnonymousInnerClass,\n                outerClassDeclaration.getFirstDescendantOfType(ASTAllocationExpression.class).getType());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testLiterals() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Literals.class);\n        List<ASTLiteral> literals = acu.findChildNodesWithXPath(\"//Literal\");\n        int index = 0;\n\n        // String s = \"s\";\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(String.class, literals.get(index++).getType());\n\n        // boolean boolean1 = false;\n        assertEquals(Boolean.TYPE, literals.get(index).getFirstDescendantOfType(ASTBooleanLiteral.class).getType());\n        assertEquals(Boolean.TYPE, literals.get(index++).getType());\n\n        // boolean boolean2 = true;\n        assertEquals(Boolean.TYPE, literals.get(index).getFirstDescendantOfType(ASTBooleanLiteral.class).getType());\n        assertEquals(Boolean.TYPE, literals.get(index++).getType());\n\n        // Object obj = null;\n        assertNull(literals.get(index).getFirstDescendantOfType(ASTNullLiteral.class).getType());\n        assertNull(literals.get(index++).getType());\n\n        // byte byte1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // byte byte2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // byte byte3 = -007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // short short1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // short short2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // short short3 = -007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // char char1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // char char2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // char char3 = 007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // char char4 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // int int1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // int int2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // int int3 = -007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // int int4 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // long long1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // long long2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // long long3 = -007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // long long4 = 0L;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Long.TYPE, literals.get(index++).getType());\n\n        // long long5 = 0x0Fl;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Long.TYPE, literals.get(index++).getType());\n\n        // long long6 = -007L;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Long.TYPE, literals.get(index++).getType());\n\n        // long long7 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // float float1 = 0.0f;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Float.TYPE, literals.get(index++).getType());\n\n        // float float2 = -10e+01f;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Float.TYPE, literals.get(index++).getType());\n\n        // float float3 = 0x08.08p3f;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Float.TYPE, literals.get(index++).getType());\n\n        // float float4 = 0xFF;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // float float5 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // double double1 = 0.0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Double.TYPE, literals.get(index++).getType());\n\n        // double double2 = -10e+01;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Double.TYPE, literals.get(index++).getType());\n\n        // double double3 = 0x08.08p3;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Double.TYPE, literals.get(index++).getType());\n\n        // double double4 = 0xFF;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // double double5 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All literals not tested\", index, literals.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testUnaryNumericPromotion() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Promotion.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericPromotion']]//Expression[UnaryExpression]\");\n        int index = 0;\n\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBinaryNumericPromotion() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Promotion.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'binaryNumericPromotion']]//Expression[AdditiveExpression]\");\n        int index = 0;\n\n        // LHS = byte\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = short\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = char\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = int\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = long\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = float\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = double\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBinaryStringPromotion() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Promotion.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'binaryStringPromotion']]//Expression\");\n        int index = 0;\n\n        assertEquals(String.class, expressions.get(index++).getType());\n        assertEquals(String.class, expressions.get(index++).getType());\n        assertEquals(String.class, expressions.get(index++).getType());\n        assertEquals(String.class, expressions.get(index++).getType());\n        assertEquals(String.class, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testUnaryLogicalOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Operators.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryLogicalOperators']]//Expression\");\n        int index = 0;\n\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBinaryLogicalOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Operators.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'binaryLogicalOperators']]//Expression\");\n        int index = 0;\n\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testUnaryNumericOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Operators.class);\n        List<TypeNode> expressions = new ArrayList<TypeNode>();\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//Expression\"));\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//PostfixExpression\"));\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//PreIncrementExpression\"));\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//PreDecrementExpression\"));\n        int index = 0;\n\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBinaryNumericOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Operators.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'binaryNumericOperators']]//Expression\");\n        int index = 0;\n\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testAssignmentOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Operators.class);\n        List<ASTStatementExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'assignmentOperators']]//StatementExpression\");\n        int index = 0;\n\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    /**\n     * The type should be filled also on the ASTVariableDeclaratorId node,\n     * not only on the variable name declaration.\n     */\n    @Test\n    public void testFullyQualifiedType() {\n        String source = \"public class Foo {\\n\" +\n                \"    public void bar() {\\n\" +\n                \"        java.util.StringTokenizer st = new StringTokenizer(\\\"a.b.c.d\\\", \\\".\\\");\\n\" +\n                \"        while (st.hasMoreTokens()) {\\n\" + \n                \"            System.out.println(st.nextToken());\\n\" + \n                \"        }\\n\" +\n                \"    }\\n\" +\n                \"}\";\n        ASTCompilationUnit acu = parseAndTypeResolveForString(source, \"1.5\");\n        List<ASTName> names = acu.findDescendantsOfType(ASTName.class);\n        ASTName theStringTokenizer = null;\n        for (ASTName name : names) {\n            if (name.hasImageEqualTo(\"st.hasMoreTokens\")) {\n                theStringTokenizer = name;\n                break;\n            }\n        }\n        Assert.assertNotNull(theStringTokenizer);\n        VariableNameDeclaration declaration = (VariableNameDeclaration)theStringTokenizer.getNameDeclaration();\n        Assert.assertNotNull(declaration);\n        Assert.assertEquals(\"java.util.StringTokenizer\", declaration.getTypeImage());\n        Assert.assertNotNull(declaration.getType());\n        Assert.assertSame(StringTokenizer.class, declaration.getType());\n        ASTVariableDeclaratorId id = (ASTVariableDeclaratorId)declaration.getNode();\n        Assert.assertNotNull(id.getType());\n        Assert.assertSame(StringTokenizer.class, id.getType());\n    }\n\n    private ASTCompilationUnit parseAndTypeResolveForClass15(Class<?> clazz) {\n        return parseAndTypeResolveForClass(clazz, \"1.5\");\n    }\n\n    // Note: If you're using Eclipse or some other IDE to run this test, you _must_ have the src/test/java folder in\n    // the classpath.  Normally the IDE doesn't put source directories themselves directly in the classpath, only\n    // the output directories are in the classpath.\n    private ASTCompilationUnit parseAndTypeResolveForClass(Class<?> clazz, String version) {\n        String sourceFile = clazz.getName().replace('.', '/') + \".java\";\n        InputStream is = ClassTypeResolverTest.class.getClassLoader().getResourceAsStream(sourceFile);\n        if (is == null) {\n            throw new IllegalArgumentException(\"Unable to find source file \" + sourceFile + \" for \" + clazz);\n        }\n        String source;\n        try {\n            source = IOUtils.toString(is);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        return parseAndTypeResolveForString(source, version);\n    }\n\n    private ASTCompilationUnit parseAndTypeResolveForString(String source, String version) {\n        LanguageVersionHandler languageVersionHandler = LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion(version).getLanguageVersionHandler();\n        ASTCompilationUnit acu = (ASTCompilationUnit) languageVersionHandler.getParser(languageVersionHandler.getDefaultParserOptions()).parse(null, new StringReader(source));\n        languageVersionHandler.getSymbolFacade().start(acu);\n        languageVersionHandler.getTypeResolutionFacade(ClassTypeResolverTest.class.getClassLoader()).start(acu);\n        return acu;\n    }\n}\n",
        "diffSourceCodeSet": [
            "private ASTCompilationUnit parseAndTypeResolveForString(String source, String version) {\n        LanguageVersionHandler languageVersionHandler = LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion(version).getLanguageVersionHandler();\n        ASTCompilationUnit acu = (ASTCompilationUnit) languageVersionHandler.getParser(languageVersionHandler.getDefaultParserOptions()).parse(null, new StringReader(source));\n        languageVersionHandler.getSymbolFacade().start(acu);\n        languageVersionHandler.getTypeResolutionFacade(ClassTypeResolverTest.class.getClassLoader()).start(acu);\n        return acu;\n    }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "private ASTCompilationUnit parseAndTypeResolveForClass(Class<?> clazz, String version) {\n        String sourceFile = clazz.getName().replace('.', '/') + \".java\";\n        InputStream is = ClassTypeResolverTest.class.getClassLoader().getResourceAsStream(sourceFile);\n        if (is == null) {\n            throw new IllegalArgumentException(\"Unable to find source file \" + sourceFile + \" for \" + clazz);\n        }\n        String source;\n        try {\n            source = IOUtils.toString(is);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        return parseAndTypeResolveForString(source, version);\n    }\nprivate ASTCompilationUnit parseAndTypeResolveForString(String source, String version) {\n        LanguageVersionHandler languageVersionHandler = LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion(version).getLanguageVersionHandler();\n        ASTCompilationUnit acu = (ASTCompilationUnit) languageVersionHandler.getParser(languageVersionHandler.getDefaultParserOptions()).parse(null, new StringReader(source));\n        languageVersionHandler.getSymbolFacade().start(acu);\n        languageVersionHandler.getTypeResolutionFacade(ClassTypeResolverTest.class.getClassLoader()).start(acu);\n        return acu;\n    }",
        "diffSourceCode": "-  508:     private ASTCompilationUnit parseAndTypeResolveForClass(Class<?> clazz, String version) {\n-  509:         String sourceFile = clazz.getName().replace('.', '/') + \".java\";\n-  510:         InputStream is = ClassTypeResolverTest.class.getClassLoader().getResourceAsStream(sourceFile);\n-  511:         if (is == null) {\n-  512:             throw new IllegalArgumentException(\"Unable to find source file \" + sourceFile + \" for \" + clazz);\n-  513:         }\n-  514:         LanguageVersionHandler languageVersionHandler = LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion(version).getLanguageVersionHandler();\n-  515:         ASTCompilationUnit acu = (ASTCompilationUnit) languageVersionHandler.getParser(languageVersionHandler.getDefaultParserOptions()).parse(null, new InputStreamReader(is));\n-  516:         languageVersionHandler.getSymbolFacade().start(acu);\n-  517:         languageVersionHandler.getTypeResolutionFacade(ClassTypeResolverTest.class.getClassLoader()).start(acu);\n-  518:         return acu;\n-  519:     }\n+  508:      */\n+  509:     @Test\n+  510:     public void testFullyQualifiedType() {\n+  511:         String source = \"public class Foo {\\n\" +\n+  512:                 \"    public void bar() {\\n\" +\n+  513:                 \"        java.util.StringTokenizer st = new StringTokenizer(\\\"a.b.c.d\\\", \\\".\\\");\\n\" +\n+  514:                 \"        while (st.hasMoreTokens()) {\\n\" + \n+  515:                 \"            System.out.println(st.nextToken());\\n\" + \n+  516:                 \"        }\\n\" +\n+  517:                 \"    }\\n\" +\n+  518:                 \"}\";\n+  519:         ASTCompilationUnit acu = parseAndTypeResolveForString(source, \"1.5\");\n+  546:     private ASTCompilationUnit parseAndTypeResolveForClass(Class<?> clazz, String version) {\n+  547:         String sourceFile = clazz.getName().replace('.', '/') + \".java\";\n+  548:         InputStream is = ClassTypeResolverTest.class.getClassLoader().getResourceAsStream(sourceFile);\n+  549:         if (is == null) {\n+  550:             throw new IllegalArgumentException(\"Unable to find source file \" + sourceFile + \" for \" + clazz);\n+  551:         }\n+  552:         String source;\n+  553:         try {\n+  554:             source = IOUtils.toString(is);\n+  555:         } catch (IOException e) {\n+  556:             throw new RuntimeException(e);\n+  557:         }\n+  558:         return parseAndTypeResolveForString(source, version);\n+  559:     }\n+  561:     private ASTCompilationUnit parseAndTypeResolveForString(String source, String version) {\n+  562:         LanguageVersionHandler languageVersionHandler = LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion(version).getLanguageVersionHandler();\n+  563:         ASTCompilationUnit acu = (ASTCompilationUnit) languageVersionHandler.getParser(languageVersionHandler.getDefaultParserOptions()).parse(null, new StringReader(source));\n+  564:         languageVersionHandler.getSymbolFacade().start(acu);\n+  565:         languageVersionHandler.getTypeResolutionFacade(ClassTypeResolverTest.class.getClassLoader()).start(acu);\n+  566:         return acu;\n+  567:     }\n",
        "uniqueId": "e6d67312e130b913c9beeb76948da4f4f3b8aa2a_508_519_561_567_546_559",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 1.8
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate parseAndTypeResolveForClass15(clazz Class<?>) : ASTCompilationUnit extracted from public testAssignmentOperators() : void in class net.sourceforge.pmd.typeresolution.ClassTypeResolverTest",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/test/java/net/sourceforge/pmd/typeresolution/ClassTypeResolverTest.java",
                "startLine": 473,
                "endLine": 495,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/test/java/net/sourceforge/pmd/typeresolution/ClassTypeResolverTest.java",
                "startLine": 473,
                "endLine": 495,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/test/java/net/sourceforge/pmd/typeresolution/ClassTypeResolverTest.java",
                "startLine": 501,
                "endLine": 503,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n    @SuppressWarnings(\"unchecked\")\n    public void testAssignmentOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(Operators.class);\n        List<ASTStatementExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'assignmentOperators']]//StatementExpression\");\n        int index = 0;\n\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }",
        "filePathBefore": "pmd-java/src/test/java/net/sourceforge/pmd/typeresolution/ClassTypeResolverTest.java",
        "isPureRefactoring": true,
        "commitId": "18f393da3c8dc4aa426b27307baf55c3f700e6f1",
        "packageNameBefore": "net.sourceforge.pmd.typeresolution",
        "classNameBefore": "net.sourceforge.pmd.typeresolution.ClassTypeResolverTest",
        "methodNameBefore": "net.sourceforge.pmd.typeresolution.ClassTypeResolverTest#testAssignmentOperators",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.typeresolution.ClassTypeResolverTest#parseAndTypeResolveForClass\n methodBody: private ASTCompilationUnit parseAndTypeResolveForClass(Class<?> clazz) {\nString sourceFile=clazz.getName().replace('.','/') + \".java\";\nInputStream is=ClassTypeResolverTest.class.getClassLoader().getResourceAsStream(sourceFile);\nif(is == null){throw new IllegalArgumentException(\"Unable to find source file \" + sourceFile + \" for \" + clazz);\n}LanguageVersionHandler languageVersionHandler=LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion(\"1.5\").getLanguageVersionHandler();\nASTCompilationUnit acu=(ASTCompilationUnit)languageVersionHandler.getParser(languageVersionHandler.getDefaultParserOptions()).parse(null,new InputStreamReader(is));\nlanguageVersionHandler.getSymbolFacade().start(acu);\nlanguageVersionHandler.getTypeResolutionFacade(ClassTypeResolverTest.class.getClassLoader()).start(acu);\nreturn acu;\n}",
        "classSignatureBefore": "public class ClassTypeResolverTest ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.typeresolution.ClassTypeResolverTest#testAssignmentOperators"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.typeresolution.ClassTypeResolverTest"
        ],
        "classSignatureBeforeSet": [
            "public class ClassTypeResolverTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics\nOverlapped refactoring - can be identical by undoing the overlapped refactoring\n- Add Parameter-",
                "description": "Parametrization or Add Parameter on top of the extract method (relax mode) - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\npackage net.sourceforge.pmd.typeresolution;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNull;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.jaxen.JaxenException;\nimport org.junit.Test;\nimport net.sourceforge.pmd.lang.LanguageRegistry;\nimport net.sourceforge.pmd.lang.LanguageVersionHandler;\nimport net.sourceforge.pmd.lang.java.JavaLanguageModule;\nimport net.sourceforge.pmd.lang.java.ast.ASTAllocationExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTBooleanLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType;\nimport net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;\nimport net.sourceforge.pmd.lang.java.ast.ASTExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;\nimport net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTName;\nimport net.sourceforge.pmd.lang.java.ast.ASTNullLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTReferenceType;\nimport net.sourceforge.pmd.lang.java.ast.ASTStatementExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTType;\nimport net.sourceforge.pmd.lang.java.ast.ASTTypeDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableDeclarator;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;\nimport net.sourceforge.pmd.lang.java.ast.TypeNode;\nimport net.sourceforge.pmd.lang.java.typeresolution.ClassTypeResolver;\nimport net.sourceforge.pmd.typeresolution.testdata.AnonymousInnerClass;\nimport net.sourceforge.pmd.typeresolution.testdata.ArrayListFound;\nimport net.sourceforge.pmd.typeresolution.testdata.DefaultJavaLangImport;\nimport net.sourceforge.pmd.typeresolution.testdata.EnumWithAnonymousInnerClass;\nimport net.sourceforge.pmd.typeresolution.testdata.ExtraTopLevelClass;\nimport net.sourceforge.pmd.typeresolution.testdata.InnerClass;\nimport net.sourceforge.pmd.typeresolution.testdata.Literals;\nimport net.sourceforge.pmd.typeresolution.testdata.Operators;\nimport net.sourceforge.pmd.typeresolution.testdata.Promotion;\n\n\npublic class ClassTypeResolverTest {\n\n    @Test\n    public void testClassNameExists() {\n        ClassTypeResolver classTypeResolver = new ClassTypeResolver();\n        assertEquals(true, classTypeResolver.classNameExists(\"java.lang.System\"));\n        assertEquals(false, classTypeResolver.classNameExists(\"im.sure.that.this.does.not.Exist\"));\n        assertEquals(true, classTypeResolver.classNameExists(\"java.awt.List\"));\n    }\n\n    @Test\n    public void acceptanceTest() {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(ArrayListFound.class);\n        assertEquals(ArrayListFound.class, acu.getFirstDescendantOfType(ASTTypeDeclaration.class).getType());\n        assertEquals(ArrayListFound.class, acu.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());\n        ASTImportDeclaration id = acu.getFirstDescendantOfType(ASTImportDeclaration.class);\n        assertEquals(\"java.util\", id.getPackage().getName());\n        assertEquals(ArrayList.class, id.getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTClassOrInterfaceType.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTReferenceType.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTType.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTVariableDeclaratorId.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTVariableDeclarator.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTFieldDeclaration.class).getType());\n\n        acu = parseAndTypeResolveForClass(DefaultJavaLangImport.class);\n        assertEquals(String.class, acu.getFirstDescendantOfType(ASTClassOrInterfaceType.class).getType());\n        assertEquals(Override.class, acu.findDescendantsOfType(ASTName.class).get(1).getType());\n    }\n\n    /**\n     * See bug #1138 Anonymous inner class in enum causes NPE\n     */\n    @Test\n    public void testEnumAnonymousInnerClass() {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(EnumWithAnonymousInnerClass.class);\n        Class<?> inner = acu.getFirstDescendantOfType(ASTAllocationExpression.class)\n                .getFirstDescendantOfType(ASTClassOrInterfaceType.class).getType();\n        assertEquals(\"net.sourceforge.pmd.typeresolution.testdata.EnumWithAnonymousInnerClass$1\",\n                inner.getName());\n    }\n\n    @Test\n    public void testExtraTopLevelClass() throws ClassNotFoundException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(ExtraTopLevelClass.class);\n        Class<?> theExtraTopLevelClass = Class.forName(\"net.sourceforge.pmd.typeresolution.testdata.TheExtraTopLevelClass\");\n        // First class\n        ASTTypeDeclaration typeDeclaration = (ASTTypeDeclaration) acu.jjtGetChild(1);\n        assertEquals(ExtraTopLevelClass.class, typeDeclaration.getType());\n        assertEquals(ExtraTopLevelClass.class,\n                typeDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());\n        // Second class\n        typeDeclaration = (ASTTypeDeclaration) acu.jjtGetChild(2);\n        assertEquals(theExtraTopLevelClass, typeDeclaration.getType());\n        assertEquals(theExtraTopLevelClass,\n                typeDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());\n    }\n\n    @Test\n    public void testInnerClass() throws ClassNotFoundException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(InnerClass.class);\n        Class<?> theInnerClass = Class.forName(\"net.sourceforge.pmd.typeresolution.testdata.InnerClass$TheInnerClass\");\n        // Outer class\n        ASTTypeDeclaration typeDeclaration = acu.getFirstDescendantOfType(ASTTypeDeclaration.class);\n        assertEquals(InnerClass.class, typeDeclaration.getType());\n        ASTClassOrInterfaceDeclaration outerClassDeclaration = typeDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class);\n        assertEquals(InnerClass.class, outerClassDeclaration.getType());\n        // Inner class\n        assertEquals(theInnerClass,\n                outerClassDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());\n        // Method parameter as inner class\n        ASTFormalParameter formalParameter = typeDeclaration.getFirstDescendantOfType(ASTFormalParameter.class);\n        assertEquals(theInnerClass, formalParameter.getTypeNode().getType());\n    }\n\n    @Test\n    public void testAnonymousInnerClass() throws ClassNotFoundException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(AnonymousInnerClass.class);\n        Class<?> theAnonymousInnerClass = Class.forName(\"net.sourceforge.pmd.typeresolution.testdata.AnonymousInnerClass$1\");\n        // Outer class\n        ASTTypeDeclaration typeDeclaration = acu.getFirstDescendantOfType(ASTTypeDeclaration.class);\n        assertEquals(AnonymousInnerClass.class, typeDeclaration.getType());\n        ASTClassOrInterfaceDeclaration outerClassDeclaration = typeDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class);\n        assertEquals(AnonymousInnerClass.class, outerClassDeclaration.getType());\n        // Anonymous Inner class\n        assertEquals(theAnonymousInnerClass,\n                outerClassDeclaration.getFirstDescendantOfType(ASTAllocationExpression.class).getType());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testLiterals() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(Literals.class);\n        List<ASTLiteral> literals = acu.findChildNodesWithXPath(\"//Literal\");\n        int index = 0;\n\n        // String s = \"s\";\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(String.class, literals.get(index++).getType());\n\n        // boolean boolean1 = false;\n        assertEquals(Boolean.TYPE, literals.get(index).getFirstDescendantOfType(ASTBooleanLiteral.class).getType());\n        assertEquals(Boolean.TYPE, literals.get(index++).getType());\n\n        // boolean boolean2 = true;\n        assertEquals(Boolean.TYPE, literals.get(index).getFirstDescendantOfType(ASTBooleanLiteral.class).getType());\n        assertEquals(Boolean.TYPE, literals.get(index++).getType());\n\n        // Object obj = null;\n        assertNull(literals.get(index).getFirstDescendantOfType(ASTNullLiteral.class).getType());\n        assertNull(literals.get(index++).getType());\n\n        // byte byte1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // byte byte2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // byte byte3 = -007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // short short1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // short short2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // short short3 = -007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // char char1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // char char2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // char char3 = 007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // char char4 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // int int1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // int int2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // int int3 = -007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // int int4 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // long long1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // long long2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // long long3 = -007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // long long4 = 0L;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Long.TYPE, literals.get(index++).getType());\n\n        // long long5 = 0x0Fl;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Long.TYPE, literals.get(index++).getType());\n\n        // long long6 = -007L;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Long.TYPE, literals.get(index++).getType());\n\n        // long long7 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // float float1 = 0.0f;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Float.TYPE, literals.get(index++).getType());\n\n        // float float2 = -10e+01f;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Float.TYPE, literals.get(index++).getType());\n\n        // float float3 = 0x08.08p3f;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Float.TYPE, literals.get(index++).getType());\n\n        // float float4 = 0xFF;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // float float5 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // double double1 = 0.0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Double.TYPE, literals.get(index++).getType());\n\n        // double double2 = -10e+01;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Double.TYPE, literals.get(index++).getType());\n\n        // double double3 = 0x08.08p3;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Double.TYPE, literals.get(index++).getType());\n\n        // double double4 = 0xFF;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // double double5 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All literals not tested\", index, literals.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testUnaryNumericPromotion() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(Promotion.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericPromotion']]//Expression[UnaryExpression]\");\n        int index = 0;\n\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBinaryNumericPromotion() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(Promotion.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'binaryNumericPromotion']]//Expression[AdditiveExpression]\");\n        int index = 0;\n\n        // LHS = byte\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = short\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = char\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = int\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = long\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = float\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = double\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBinaryStringPromotion() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(Promotion.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'binaryStringPromotion']]//Expression\");\n        int index = 0;\n\n        assertEquals(String.class, expressions.get(index++).getType());\n        assertEquals(String.class, expressions.get(index++).getType());\n        assertEquals(String.class, expressions.get(index++).getType());\n        assertEquals(String.class, expressions.get(index++).getType());\n        assertEquals(String.class, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testUnaryLogicalOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(Operators.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryLogicalOperators']]//Expression\");\n        int index = 0;\n\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBinaryLogicalOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(Operators.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'binaryLogicalOperators']]//Expression\");\n        int index = 0;\n\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testUnaryNumericOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(Operators.class);\n        List<TypeNode> expressions = new ArrayList<TypeNode>();\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//Expression\"));\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//PostfixExpression\"));\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//PreIncrementExpression\"));\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//PreDecrementExpression\"));\n        int index = 0;\n\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBinaryNumericOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(Operators.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'binaryNumericOperators']]//Expression\");\n        int index = 0;\n\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testAssignmentOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass(Operators.class);\n        List<ASTStatementExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'assignmentOperators']]//StatementExpression\");\n        int index = 0;\n\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    public static junit.framework.Test suite() {\n        return new junit.framework.JUnit4TestAdapter(ClassTypeResolverTest.class);\n    }\n\n    // Note: If you're using Eclipse or some other IDE to run this test, you _must_ have the regress folder in\n    // the classpath.  Normally the IDE doesn't put source directories themselves directly in the classpath, only\n    // the output directories are in the classpath.\n    private ASTCompilationUnit parseAndTypeResolveForClass(Class<?> clazz) {\n        String sourceFile = clazz.getName().replace('.', '/') + \".java\";\n        InputStream is = ClassTypeResolverTest.class.getClassLoader().getResourceAsStream(sourceFile);\n        if (is == null) {\n            throw new IllegalArgumentException(\"Unable to find source file \" + sourceFile + \" for \" + clazz);\n        }\n        LanguageVersionHandler languageVersionHandler = LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion(\"1.5\").getLanguageVersionHandler();\n        ASTCompilationUnit acu = (ASTCompilationUnit) languageVersionHandler.getParser(languageVersionHandler.getDefaultParserOptions()).parse(null, new InputStreamReader(is));\n        languageVersionHandler.getSymbolFacade().start(acu);\n        languageVersionHandler.getTypeResolutionFacade(ClassTypeResolverTest.class.getClassLoader()).start(acu);\n        return acu;\n    }\n}\n",
        "filePathAfter": "pmd-java/src/test/java/net/sourceforge/pmd/typeresolution/ClassTypeResolverTest.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\npackage net.sourceforge.pmd.typeresolution;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNull;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.jaxen.JaxenException;\nimport org.junit.Test;\nimport net.sourceforge.pmd.lang.LanguageRegistry;\nimport net.sourceforge.pmd.lang.LanguageVersionHandler;\nimport net.sourceforge.pmd.lang.java.JavaLanguageModule;\nimport net.sourceforge.pmd.lang.java.ast.ASTAllocationExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTBooleanLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType;\nimport net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;\nimport net.sourceforge.pmd.lang.java.ast.ASTExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;\nimport net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTName;\nimport net.sourceforge.pmd.lang.java.ast.ASTNullLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTReferenceType;\nimport net.sourceforge.pmd.lang.java.ast.ASTStatementExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTType;\nimport net.sourceforge.pmd.lang.java.ast.ASTTypeDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableDeclarator;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;\nimport net.sourceforge.pmd.lang.java.ast.TypeNode;\nimport net.sourceforge.pmd.lang.java.typeresolution.ClassTypeResolver;\nimport net.sourceforge.pmd.typeresolution.testdata.AnonymousInnerClass;\nimport net.sourceforge.pmd.typeresolution.testdata.ArrayListFound;\nimport net.sourceforge.pmd.typeresolution.testdata.DefaultJavaLangImport;\nimport net.sourceforge.pmd.typeresolution.testdata.EnumWithAnonymousInnerClass;\nimport net.sourceforge.pmd.typeresolution.testdata.ExtraTopLevelClass;\nimport net.sourceforge.pmd.typeresolution.testdata.InnerClass;\nimport net.sourceforge.pmd.typeresolution.testdata.Literals;\nimport net.sourceforge.pmd.typeresolution.testdata.Operators;\nimport net.sourceforge.pmd.typeresolution.testdata.Promotion;\n\n\npublic class ClassTypeResolverTest {\n\n    @Test\n    public void testClassNameExists() {\n        ClassTypeResolver classTypeResolver = new ClassTypeResolver();\n        assertEquals(true, classTypeResolver.classNameExists(\"java.lang.System\"));\n        assertEquals(false, classTypeResolver.classNameExists(\"im.sure.that.this.does.not.Exist\"));\n        assertEquals(true, classTypeResolver.classNameExists(\"java.awt.List\"));\n    }\n\n    @Test\n    public void acceptanceTest() {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(ArrayListFound.class);\n        assertEquals(ArrayListFound.class, acu.getFirstDescendantOfType(ASTTypeDeclaration.class).getType());\n        assertEquals(ArrayListFound.class, acu.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());\n        ASTImportDeclaration id = acu.getFirstDescendantOfType(ASTImportDeclaration.class);\n        assertEquals(\"java.util\", id.getPackage().getName());\n        assertEquals(ArrayList.class, id.getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTClassOrInterfaceType.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTReferenceType.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTType.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTVariableDeclaratorId.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTVariableDeclarator.class).getType());\n        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTFieldDeclaration.class).getType());\n\n        acu = parseAndTypeResolveForClass15(DefaultJavaLangImport.class);\n        assertEquals(String.class, acu.getFirstDescendantOfType(ASTClassOrInterfaceType.class).getType());\n        assertEquals(Override.class, acu.findDescendantsOfType(ASTName.class).get(1).getType());\n    }\n\n    /**\n     * See bug #1138 Anonymous inner class in enum causes NPE\n     */\n    @Test\n    public void testEnumAnonymousInnerClass() {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(EnumWithAnonymousInnerClass.class);\n        Class<?> inner = acu.getFirstDescendantOfType(ASTAllocationExpression.class)\n                .getFirstDescendantOfType(ASTClassOrInterfaceType.class).getType();\n        assertEquals(\"net.sourceforge.pmd.typeresolution.testdata.EnumWithAnonymousInnerClass$1\",\n                inner.getName());\n    }\n\n    @Test\n    public void testExtraTopLevelClass() throws ClassNotFoundException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(ExtraTopLevelClass.class);\n        Class<?> theExtraTopLevelClass = Class.forName(\"net.sourceforge.pmd.typeresolution.testdata.TheExtraTopLevelClass\");\n        // First class\n        ASTTypeDeclaration typeDeclaration = (ASTTypeDeclaration) acu.jjtGetChild(1);\n        assertEquals(ExtraTopLevelClass.class, typeDeclaration.getType());\n        assertEquals(ExtraTopLevelClass.class,\n                typeDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());\n        // Second class\n        typeDeclaration = (ASTTypeDeclaration) acu.jjtGetChild(2);\n        assertEquals(theExtraTopLevelClass, typeDeclaration.getType());\n        assertEquals(theExtraTopLevelClass,\n                typeDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());\n    }\n\n    @Test\n    public void testInnerClass() throws ClassNotFoundException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(InnerClass.class);\n        Class<?> theInnerClass = Class.forName(\"net.sourceforge.pmd.typeresolution.testdata.InnerClass$TheInnerClass\");\n        // Outer class\n        ASTTypeDeclaration typeDeclaration = acu.getFirstDescendantOfType(ASTTypeDeclaration.class);\n        assertEquals(InnerClass.class, typeDeclaration.getType());\n        ASTClassOrInterfaceDeclaration outerClassDeclaration = typeDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class);\n        assertEquals(InnerClass.class, outerClassDeclaration.getType());\n        // Inner class\n        assertEquals(theInnerClass,\n                outerClassDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());\n        // Method parameter as inner class\n        ASTFormalParameter formalParameter = typeDeclaration.getFirstDescendantOfType(ASTFormalParameter.class);\n        assertEquals(theInnerClass, formalParameter.getTypeNode().getType());\n    }\n\n    @Test\n    public void testAnonymousInnerClass() throws ClassNotFoundException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(AnonymousInnerClass.class);\n        Class<?> theAnonymousInnerClass = Class.forName(\"net.sourceforge.pmd.typeresolution.testdata.AnonymousInnerClass$1\");\n        // Outer class\n        ASTTypeDeclaration typeDeclaration = acu.getFirstDescendantOfType(ASTTypeDeclaration.class);\n        assertEquals(AnonymousInnerClass.class, typeDeclaration.getType());\n        ASTClassOrInterfaceDeclaration outerClassDeclaration = typeDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class);\n        assertEquals(AnonymousInnerClass.class, outerClassDeclaration.getType());\n        // Anonymous Inner class\n        assertEquals(theAnonymousInnerClass,\n                outerClassDeclaration.getFirstDescendantOfType(ASTAllocationExpression.class).getType());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testLiterals() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Literals.class);\n        List<ASTLiteral> literals = acu.findChildNodesWithXPath(\"//Literal\");\n        int index = 0;\n\n        // String s = \"s\";\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(String.class, literals.get(index++).getType());\n\n        // boolean boolean1 = false;\n        assertEquals(Boolean.TYPE, literals.get(index).getFirstDescendantOfType(ASTBooleanLiteral.class).getType());\n        assertEquals(Boolean.TYPE, literals.get(index++).getType());\n\n        // boolean boolean2 = true;\n        assertEquals(Boolean.TYPE, literals.get(index).getFirstDescendantOfType(ASTBooleanLiteral.class).getType());\n        assertEquals(Boolean.TYPE, literals.get(index++).getType());\n\n        // Object obj = null;\n        assertNull(literals.get(index).getFirstDescendantOfType(ASTNullLiteral.class).getType());\n        assertNull(literals.get(index++).getType());\n\n        // byte byte1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // byte byte2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // byte byte3 = -007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // short short1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // short short2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // short short3 = -007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // char char1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // char char2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // char char3 = 007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // char char4 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // int int1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // int int2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // int int3 = -007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // int int4 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // long long1 = 0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // long long2 = 0x0F;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // long long3 = -007;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // long long4 = 0L;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Long.TYPE, literals.get(index++).getType());\n\n        // long long5 = 0x0Fl;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Long.TYPE, literals.get(index++).getType());\n\n        // long long6 = -007L;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Long.TYPE, literals.get(index++).getType());\n\n        // long long7 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // float float1 = 0.0f;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Float.TYPE, literals.get(index++).getType());\n\n        // float float2 = -10e+01f;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Float.TYPE, literals.get(index++).getType());\n\n        // float float3 = 0x08.08p3f;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Float.TYPE, literals.get(index++).getType());\n\n        // float float4 = 0xFF;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // float float5 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // double double1 = 0.0;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Double.TYPE, literals.get(index++).getType());\n\n        // double double2 = -10e+01;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Double.TYPE, literals.get(index++).getType());\n\n        // double double3 = 0x08.08p3;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Double.TYPE, literals.get(index++).getType());\n\n        // double double4 = 0xFF;\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Integer.TYPE, literals.get(index++).getType());\n\n        // double double5 = 'a';\n        assertEquals(0, literals.get(index).jjtGetNumChildren());\n        assertEquals(Character.TYPE, literals.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All literals not tested\", index, literals.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testUnaryNumericPromotion() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Promotion.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericPromotion']]//Expression[UnaryExpression]\");\n        int index = 0;\n\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBinaryNumericPromotion() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Promotion.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'binaryNumericPromotion']]//Expression[AdditiveExpression]\");\n        int index = 0;\n\n        // LHS = byte\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = short\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = char\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = int\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = long\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = float\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Float.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        // LHS = double\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBinaryStringPromotion() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Promotion.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'binaryStringPromotion']]//Expression\");\n        int index = 0;\n\n        assertEquals(String.class, expressions.get(index++).getType());\n        assertEquals(String.class, expressions.get(index++).getType());\n        assertEquals(String.class, expressions.get(index++).getType());\n        assertEquals(String.class, expressions.get(index++).getType());\n        assertEquals(String.class, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testUnaryLogicalOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Operators.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryLogicalOperators']]//Expression\");\n        int index = 0;\n\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBinaryLogicalOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Operators.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'binaryLogicalOperators']]//Expression\");\n        int index = 0;\n\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n        assertEquals(Boolean.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testUnaryNumericOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Operators.class);\n        List<TypeNode> expressions = new ArrayList<TypeNode>();\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//Expression\"));\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//PostfixExpression\"));\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//PreIncrementExpression\"));\n        expressions.addAll(acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]//PreDecrementExpression\"));\n        int index = 0;\n\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n        assertEquals(Double.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBinaryNumericOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Operators.class);\n        List<ASTExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'binaryNumericOperators']]//Expression\");\n        int index = 0;\n\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n        assertEquals(Integer.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testAssignmentOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Operators.class);\n        List<ASTStatementExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'assignmentOperators']]//StatementExpression\");\n        int index = 0;\n\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\n\n    public static junit.framework.Test suite() {\n        return new junit.framework.JUnit4TestAdapter(ClassTypeResolverTest.class);\n    }\n\n    private ASTCompilationUnit parseAndTypeResolveForClass15(Class<?> clazz) {\n        return parseAndTypeResolveForClass(clazz, \"1.5\");\n    }\n\n    // Note: If you're using Eclipse or some other IDE to run this test, you _must_ have the regress folder in\n    // the classpath.  Normally the IDE doesn't put source directories themselves directly in the classpath, only\n    // the output directories are in the classpath.\n    private ASTCompilationUnit parseAndTypeResolveForClass(Class<?> clazz, String version) {\n        String sourceFile = clazz.getName().replace('.', '/') + \".java\";\n        InputStream is = ClassTypeResolverTest.class.getClassLoader().getResourceAsStream(sourceFile);\n        if (is == null) {\n            throw new IllegalArgumentException(\"Unable to find source file \" + sourceFile + \" for \" + clazz);\n        }\n        LanguageVersionHandler languageVersionHandler = LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion(version).getLanguageVersionHandler();\n        ASTCompilationUnit acu = (ASTCompilationUnit) languageVersionHandler.getParser(languageVersionHandler.getDefaultParserOptions()).parse(null, new InputStreamReader(is));\n        languageVersionHandler.getSymbolFacade().start(acu);\n        languageVersionHandler.getTypeResolutionFacade(ClassTypeResolverTest.class.getClassLoader()).start(acu);\n        return acu;\n    }\n}\n",
        "diffSourceCodeSet": [
            "private ASTCompilationUnit parseAndTypeResolveForClass15(Class<?> clazz) {\n        return parseAndTypeResolveForClass(clazz, \"1.5\");\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.typeresolution.ClassTypeResolverTest#parseAndTypeResolveForClass\n methodBody: private ASTCompilationUnit parseAndTypeResolveForClass(Class<?> clazz) {\nString sourceFile=clazz.getName().replace('.','/') + \".java\";\nInputStream is=ClassTypeResolverTest.class.getClassLoader().getResourceAsStream(sourceFile);\nif(is == null){throw new IllegalArgumentException(\"Unable to find source file \" + sourceFile + \" for \" + clazz);\n}LanguageVersionHandler languageVersionHandler=LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion(\"1.5\").getLanguageVersionHandler();\nASTCompilationUnit acu=(ASTCompilationUnit)languageVersionHandler.getParser(languageVersionHandler.getDefaultParserOptions()).parse(null,new InputStreamReader(is));\nlanguageVersionHandler.getSymbolFacade().start(acu);\nlanguageVersionHandler.getTypeResolutionFacade(ClassTypeResolverTest.class.getClassLoader()).start(acu);\nreturn acu;\n}"
        ],
        "sourceCodeAfterRefactoring": "@Test\n    @SuppressWarnings(\"unchecked\")\n    public void testAssignmentOperators() throws JaxenException {\n        ASTCompilationUnit acu = parseAndTypeResolveForClass15(Operators.class);\n        List<ASTStatementExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'assignmentOperators']]//StatementExpression\");\n        int index = 0;\n\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n        assertEquals(Long.TYPE, expressions.get(index++).getType());\n\n        // Make sure we got them all.\n        assertEquals(\"All expressions not tested\", index, expressions.size());\n    }\nprivate ASTCompilationUnit parseAndTypeResolveForClass15(Class<?> clazz) {\n        return parseAndTypeResolveForClass(clazz, \"1.5\");\n    }",
        "diffSourceCode": "   473:     @Test\n   474:     @SuppressWarnings(\"unchecked\")\n   475:     public void testAssignmentOperators() throws JaxenException {\n-  476:         ASTCompilationUnit acu = parseAndTypeResolveForClass(Operators.class);\n+  476:         ASTCompilationUnit acu = parseAndTypeResolveForClass15(Operators.class);\n   477:         List<ASTStatementExpression> expressions = acu.findChildNodesWithXPath(\"//Block[preceding-sibling::MethodDeclarator[@Image = 'assignmentOperators']]//StatementExpression\");\n   478:         int index = 0;\n   479: \n   480:         assertEquals(Long.TYPE, expressions.get(index++).getType());\n   481:         assertEquals(Long.TYPE, expressions.get(index++).getType());\n   482:         assertEquals(Long.TYPE, expressions.get(index++).getType());\n   483:         assertEquals(Long.TYPE, expressions.get(index++).getType());\n   484:         assertEquals(Long.TYPE, expressions.get(index++).getType());\n   485:         assertEquals(Long.TYPE, expressions.get(index++).getType());\n   486:         assertEquals(Long.TYPE, expressions.get(index++).getType());\n   487:         assertEquals(Long.TYPE, expressions.get(index++).getType());\n   488:         assertEquals(Long.TYPE, expressions.get(index++).getType());\n   489:         assertEquals(Long.TYPE, expressions.get(index++).getType());\n   490:         assertEquals(Long.TYPE, expressions.get(index++).getType());\n   491:         assertEquals(Long.TYPE, expressions.get(index++).getType());\n   492: \n   493:         // Make sure we got them all.\n   494:         assertEquals(\"All expressions not tested\", index, expressions.size());\n   495:     }\n-  501:     // Note: If you're using Eclipse or some other IDE to run this test, you _must_ have the regress folder in\n-  502:     // the classpath.  Normally the IDE doesn't put source directories themselves directly in the classpath, only\n-  503:     // the output directories are in the classpath.\n+  501:     private ASTCompilationUnit parseAndTypeResolveForClass15(Class<?> clazz) {\n+  502:         return parseAndTypeResolveForClass(clazz, \"1.5\");\n+  503:     }\n",
        "uniqueId": "18f393da3c8dc4aa426b27307baf55c3f700e6f1_473_495_501_503_473_495",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 1.8
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate getBooleanProperty(properties Properties, property String) : boolean extracted from public setProperties(properties Properties) : void in class net.sourceforge.pmd.cpd.CsTokenizer",
        "diffLocations": [
            {
                "filePath": "pmd-cs/src/main/java/net/sourceforge/pmd/cpd/CsTokenizer.java",
                "startLine": 24,
                "endLine": 35,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-cs/src/main/java/net/sourceforge/pmd/cpd/CsTokenizer.java",
                "startLine": 25,
                "endLine": 37,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-cs/src/main/java/net/sourceforge/pmd/cpd/CsTokenizer.java",
                "startLine": 39,
                "endLine": 41,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Sets the possible options for the C# tokenizer.\n     *\n     * @param properties the properties\n     * @see #IGNORE_USINGS\n     * @see #OPTION_IGNORE_LITERAL_SEQUENCES\n     */\n    public void setProperties(Properties properties) {\n        ignoreUsings = Boolean.parseBoolean(properties.getProperty(IGNORE_USINGS, Boolean.FALSE.toString()));\n        ignoreLiteralSequences = Boolean.parseBoolean(properties.getProperty(OPTION_IGNORE_LITERAL_SEQUENCES,\n            Boolean.FALSE.toString()));\n    }",
        "filePathBefore": "pmd-cs/src/main/java/net/sourceforge/pmd/cpd/CsTokenizer.java",
        "isPureRefactoring": true,
        "commitId": "7921e836b193df860a1866ac0415497711c4e531",
        "packageNameBefore": "net.sourceforge.pmd.cpd",
        "classNameBefore": "net.sourceforge.pmd.cpd.CsTokenizer",
        "methodNameBefore": "net.sourceforge.pmd.cpd.CsTokenizer#setProperties",
        "classSignatureBefore": "public class CsTokenizer extends AntlrTokenizer ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.cpd.CsTokenizer#setProperties"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.cpd.CsTokenizer"
        ],
        "classSignatureBeforeSet": [
            "public class CsTokenizer extends AntlrTokenizer "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.cpd;\n\nimport java.util.Properties;\n\nimport org.antlr.v4.runtime.CharStream;\n\nimport net.sourceforge.pmd.cpd.token.AntlrToken;\nimport net.sourceforge.pmd.cpd.token.AntlrTokenFilter;\nimport net.sourceforge.pmd.lang.antlr.AntlrTokenManager;\nimport net.sourceforge.pmd.lang.cs.antlr4.CSharpLexer;\n\n/**\n * The C# tokenizer.\n */\npublic class CsTokenizer extends AntlrTokenizer {\n\n    private boolean ignoreUsings = false;\n    private boolean ignoreLiteralSequences = false;\n\n    /**\n     * Sets the possible options for the C# tokenizer.\n     *\n     * @param properties the properties\n     * @see #IGNORE_USINGS\n     * @see #OPTION_IGNORE_LITERAL_SEQUENCES\n     */\n    public void setProperties(Properties properties) {\n        ignoreUsings = Boolean.parseBoolean(properties.getProperty(IGNORE_USINGS, Boolean.FALSE.toString()));\n        ignoreLiteralSequences = Boolean.parseBoolean(properties.getProperty(OPTION_IGNORE_LITERAL_SEQUENCES,\n            Boolean.FALSE.toString()));\n    }\n\n    public void setIgnoreUsings(boolean ignoreUsings) {\n        this.ignoreUsings = ignoreUsings;\n    }\n\n    public void setIgnoreLiteralSequences(boolean ignoreLiteralSequences) {\n        this.ignoreLiteralSequences = ignoreLiteralSequences;\n    }\n\n    @Override\n    protected AntlrTokenManager getLexerForSource(final SourceCode sourceCode) {\n        final CharStream charStream = AntlrTokenizer.getCharStreamFromSourceCode(sourceCode);\n        return new AntlrTokenManager(new CSharpLexer(charStream), sourceCode.getFileName());\n    }\n\n    @Override\n    protected AntlrTokenFilter getTokenFilter(final AntlrTokenManager tokenManager) {\n        return new CsTokenFilter(tokenManager, ignoreUsings, ignoreLiteralSequences);\n    }\n\n    /**\n     * The {@link CsTokenFilter} extends the {@link AntlrTokenFilter} to discard\n     * C#-specific tokens.\n     * <p>\n     * By default, it enables annotation-based CPD suppression.\n     * If the --ignoreUsings flag is provided, using directives are filtered out.\n     * </p>\n     */\n    private static class CsTokenFilter extends AntlrTokenFilter {\n        private enum UsingState {\n            KEYWORD, // just encountered the using keyword\n            IDENTIFIER, // just encountered an identifier or var keyword\n        }\n\n        private final boolean ignoreUsings;\n        private final boolean ignoreLiteralSequences;\n        private boolean discardingUsings = false;\n        private boolean discardingNL = false;\n        private AntlrToken discardingLiteralsUntil = null;\n        private boolean discardCurrent = false;\n\n        CsTokenFilter(final AntlrTokenManager tokenManager, boolean ignoreUsings, boolean ignoreLiteralSequences) {\n            super(tokenManager);\n            this.ignoreUsings = ignoreUsings;\n            this.ignoreLiteralSequences = ignoreLiteralSequences;\n        }\n\n        @Override\n        protected void analyzeToken(final AntlrToken currentToken) {\n            skipNewLines(currentToken);\n        }\n\n        @Override\n        protected void analyzeTokens(final AntlrToken currentToken, final Iterable<AntlrToken> remainingTokens) {\n            discardCurrent = false;\n            skipUsingDirectives(currentToken, remainingTokens);\n            skipLiteralSequences(currentToken, remainingTokens);\n        }\n\n        private void skipUsingDirectives(final AntlrToken currentToken, final Iterable<AntlrToken> remainingTokens) {\n            if (ignoreUsings) {\n                final int type = currentToken.getKind();\n                if (type == CSharpLexer.USING && isUsingDirective(remainingTokens)) {\n                    discardingUsings = true;\n                } else if (type == CSharpLexer.SEMICOLON && discardingUsings) {\n                    discardingUsings = false;\n                    discardCurrent = true;\n                }\n            }\n        }\n\n        private boolean isUsingDirective(final Iterable<AntlrToken> remainingTokens) {\n            UsingState usingState = UsingState.KEYWORD;\n            for (final AntlrToken token : remainingTokens) {\n                final int type = token.getKind();\n                if (usingState == UsingState.KEYWORD) {\n                    // The previous token was a using keyword.\n                    switch (type) {\n                    case CSharpLexer.STATIC:\n                        // Definitely a using directive.\n                        // Example: using static System.Math;\n                        return true;\n                    case CSharpLexer.VAR:\n                        // Definitely a using statement.\n                        // Example: using var font1 = new Font(\"Arial\", 10.0f);\n                        return false;\n                    case CSharpLexer.OPEN_PARENS:\n                        // Definitely a using statement.\n                        // Example: using (var font1 = new Font(\"Arial\", 10.0f);\n                        return false;\n                    case CSharpLexer.IDENTIFIER:\n                        // This is either a type for a using statement or an alias for a using directive.\n                        // Example (directive): using Project = PC.MyCompany.Project;\n                        // Example (statement): using Font font1 = new Font(\"Arial\", 10.0f);\n                        usingState = UsingState.IDENTIFIER;\n                        break;\n                    default:\n                        // Some unknown construct?\n                        return false;\n                    }\n                } else if (usingState == UsingState.IDENTIFIER) {\n                    // The previous token was an identifier.\n                    switch (type) {\n                    case CSharpLexer.ASSIGNMENT:\n                        // Definitely a using directive.\n                        // Example: using Project = PC.MyCompany.Project;\n                        return true;\n                    case CSharpLexer.IDENTIFIER:\n                        // Definitely a using statement.\n                        // Example: using Font font1 = new Font(\"Arial\", 10.0f);\n                        return false;\n                    case CSharpLexer.DOT:\n                        // This should be considered part of the same type; revert to previous state.\n                        // Example (directive): using System.Text;\n                        // Example (statement): using System.Drawing.Font font1 = new Font(\"Arial\", 10.0f);\n                        usingState = UsingState.KEYWORD;\n                        break;\n                    case CSharpLexer.SEMICOLON:\n                        // End of using directive.\n                        return true;\n                    default:\n                        // Some unknown construct?\n                        return false;\n                    }\n                }\n            }\n            return false;\n        }\n\n        private void skipNewLines(final AntlrToken currentToken) {\n            discardingNL = currentToken.getKind() == CSharpLexer.NL;\n        }\n\n        private void skipLiteralSequences(final AntlrToken currentToken, final Iterable<AntlrToken> remainingTokens) {\n            if (ignoreLiteralSequences) {\n                final int type = currentToken.getKind();\n                if (isDiscardingLiterals()) {\n                    if (currentToken == discardingLiteralsUntil) { // NOPMD - intentional check for reference equality\n                        discardingLiteralsUntil = null;\n                        discardCurrent = true;\n                    }\n                } else if (type == CSharpLexer.OPEN_BRACE) {\n                    final AntlrToken finalToken = findEndOfSequenceOfLiterals(remainingTokens);\n                    discardingLiteralsUntil = finalToken;\n                }\n            }\n        }\n\n        private AntlrToken findEndOfSequenceOfLiterals(final Iterable<AntlrToken> remainingTokens) {\n            boolean seenLiteral = false;\n            int braceCount = 0;\n            for (final AntlrToken token : remainingTokens) {\n                switch (token.getKind()) {\n                case CSharpLexer.BIN_INTEGER_LITERAL:\n                case CSharpLexer.CHARACTER_LITERAL:\n                case CSharpLexer.HEX_INTEGER_LITERAL:\n                case CSharpLexer.INTEGER_LITERAL:\n                case CSharpLexer.REAL_LITERAL:\n                    seenLiteral = true;\n                    break; // can be skipped; continue to the next token\n                case CSharpLexer.COMMA:\n                    break; // can be skipped; continue to the next token\n                case CSharpLexer.OPEN_BRACE:\n                    braceCount++;\n                    break; // curly braces are allowed, as long as they're balanced\n                case CSharpLexer.CLOSE_BRACE:\n                    braceCount--;\n                    if (braceCount < 0) {\n                        // end of the list; skip all contents\n                        return seenLiteral ? token : null;\n                    } else {\n                        // curly braces are not yet balanced; continue to the next token\n                        break;\n                    }\n                default:\n                    // some other token than the expected ones; this is not a sequence of literals\n                    return null;\n                }\n            }\n            return null;\n        }\n\n        public boolean isDiscardingLiterals() {\n            return discardingLiteralsUntil != null;\n        }\n\n        @Override\n        protected boolean isLanguageSpecificDiscarding() {\n            return discardingUsings || discardingNL || isDiscardingLiterals() || discardCurrent;\n        }\n    }\n}\n",
        "filePathAfter": "pmd-cs/src/main/java/net/sourceforge/pmd/cpd/CsTokenizer.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.cpd;\n\nimport java.util.Properties;\n\nimport org.antlr.v4.runtime.CharStream;\n\nimport net.sourceforge.pmd.cpd.token.AntlrToken;\nimport net.sourceforge.pmd.cpd.token.AntlrTokenFilter;\nimport net.sourceforge.pmd.lang.antlr.AntlrTokenManager;\nimport net.sourceforge.pmd.lang.cs.antlr4.CSharpLexer;\n\n/**\n * The C# tokenizer.\n */\npublic class CsTokenizer extends AntlrTokenizer {\n\n    private boolean ignoreUsings = false;\n    private boolean ignoreLiteralSequences = false;\n    private boolean ignoreAttributes = false;\n\n    /**\n     * Sets the possible options for the C# tokenizer.\n     *\n     * @param properties the properties\n     * @see #IGNORE_USINGS\n     * @see #OPTION_IGNORE_LITERAL_SEQUENCES\n     * @see #IGNORE_ANNOTATIONS\n     */\n    public void setProperties(Properties properties) {\n        ignoreUsings = getBooleanProperty(properties, IGNORE_USINGS);\n        ignoreLiteralSequences = getBooleanProperty(properties, OPTION_IGNORE_LITERAL_SEQUENCES);\n        ignoreAttributes = getBooleanProperty(properties, IGNORE_ANNOTATIONS);\n    }\n\n    private boolean getBooleanProperty(final Properties properties, final String property) {\n        return Boolean.parseBoolean(properties.getProperty(property, Boolean.FALSE.toString()));\n    }\n\n    @Override\n    protected AntlrTokenManager getLexerForSource(final SourceCode sourceCode) {\n        final CharStream charStream = AntlrTokenizer.getCharStreamFromSourceCode(sourceCode);\n        return new AntlrTokenManager(new CSharpLexer(charStream), sourceCode.getFileName());\n    }\n\n    @Override\n    protected AntlrTokenFilter getTokenFilter(final AntlrTokenManager tokenManager) {\n        return new CsTokenFilter(tokenManager, ignoreUsings, ignoreLiteralSequences, ignoreAttributes);\n    }\n\n    /**\n     * The {@link CsTokenFilter} extends the {@link AntlrTokenFilter} to discard\n     * C#-specific tokens.\n     * <p>\n     * By default, it enables annotation-based CPD suppression.\n     * If the --ignoreUsings flag is provided, using directives are filtered out.\n     * </p>\n     */\n    private static class CsTokenFilter extends AntlrTokenFilter {\n        private enum UsingState {\n            KEYWORD, // just encountered the using keyword\n            IDENTIFIER, // just encountered an identifier or var keyword\n        }\n\n        private final boolean ignoreUsings;\n        private final boolean ignoreLiteralSequences;\n        private final boolean ignoreAttributes;\n        private boolean discardingUsings = false;\n        private boolean discardingNL = false;\n        private boolean isDiscardingAttribute = false;\n        private AntlrToken discardingLiteralsUntil = null;\n        private boolean discardCurrent = false;\n\n        CsTokenFilter(final AntlrTokenManager tokenManager, boolean ignoreUsings, boolean ignoreLiteralSequences, boolean ignoreAttributes) {\n            super(tokenManager);\n            this.ignoreUsings = ignoreUsings;\n            this.ignoreLiteralSequences = ignoreLiteralSequences;\n            this.ignoreAttributes = ignoreAttributes;\n        }\n\n        @Override\n        protected void analyzeToken(final AntlrToken currentToken) {\n            skipNewLines(currentToken);\n        }\n\n        @Override\n        protected void analyzeTokens(final AntlrToken currentToken, final Iterable<AntlrToken> remainingTokens) {\n            discardCurrent = false;\n            skipUsingDirectives(currentToken, remainingTokens);\n            skipLiteralSequences(currentToken, remainingTokens);\n            skipAttributes(currentToken);\n        }\n\n        private void skipUsingDirectives(final AntlrToken currentToken, final Iterable<AntlrToken> remainingTokens) {\n            if (ignoreUsings) {\n                final int type = currentToken.getKind();\n                if (type == CSharpLexer.USING && isUsingDirective(remainingTokens)) {\n                    discardingUsings = true;\n                } else if (type == CSharpLexer.SEMICOLON && discardingUsings) {\n                    discardingUsings = false;\n                    discardCurrent = true;\n                }\n            }\n        }\n\n        private boolean isUsingDirective(final Iterable<AntlrToken> remainingTokens) {\n            UsingState usingState = UsingState.KEYWORD;\n            for (final AntlrToken token : remainingTokens) {\n                final int type = token.getKind();\n                if (usingState == UsingState.KEYWORD) {\n                    // The previous token was a using keyword.\n                    switch (type) {\n                    case CSharpLexer.STATIC:\n                        // Definitely a using directive.\n                        // Example: using static System.Math;\n                        return true;\n                    case CSharpLexer.VAR:\n                        // Definitely a using statement.\n                        // Example: using var font1 = new Font(\"Arial\", 10.0f);\n                        return false;\n                    case CSharpLexer.OPEN_PARENS:\n                        // Definitely a using statement.\n                        // Example: using (var font1 = new Font(\"Arial\", 10.0f);\n                        return false;\n                    case CSharpLexer.IDENTIFIER:\n                        // This is either a type for a using statement or an alias for a using directive.\n                        // Example (directive): using Project = PC.MyCompany.Project;\n                        // Example (statement): using Font font1 = new Font(\"Arial\", 10.0f);\n                        usingState = UsingState.IDENTIFIER;\n                        break;\n                    default:\n                        // Some unknown construct?\n                        return false;\n                    }\n                } else if (usingState == UsingState.IDENTIFIER) {\n                    // The previous token was an identifier.\n                    switch (type) {\n                    case CSharpLexer.ASSIGNMENT:\n                        // Definitely a using directive.\n                        // Example: using Project = PC.MyCompany.Project;\n                        return true;\n                    case CSharpLexer.IDENTIFIER:\n                        // Definitely a using statement.\n                        // Example: using Font font1 = new Font(\"Arial\", 10.0f);\n                        return false;\n                    case CSharpLexer.DOT:\n                        // This should be considered part of the same type; revert to previous state.\n                        // Example (directive): using System.Text;\n                        // Example (statement): using System.Drawing.Font font1 = new Font(\"Arial\", 10.0f);\n                        usingState = UsingState.KEYWORD;\n                        break;\n                    case CSharpLexer.SEMICOLON:\n                        // End of using directive.\n                        return true;\n                    default:\n                        // Some unknown construct?\n                        return false;\n                    }\n                }\n            }\n            return false;\n        }\n\n        private void skipNewLines(final AntlrToken currentToken) {\n            discardingNL = currentToken.getKind() == CSharpLexer.NL;\n        }\n\n        private void skipAttributes(final AntlrToken currentToken) {\n            if (ignoreAttributes) {\n                switch (currentToken.getKind()) {\n                case CSharpLexer.OPEN_BRACKET:\n                    // Start of an attribute.\n                    isDiscardingAttribute = true;\n                    break;\n                case CSharpLexer.CLOSE_BRACKET:\n                    // End of an attribute.\n                    isDiscardingAttribute = false;\n                    discardCurrent = true;\n                    break;\n                default:\n                    // Skip any other token.\n                    break;\n                }\n            }\n        }\n\n        private void skipLiteralSequences(final AntlrToken currentToken, final Iterable<AntlrToken> remainingTokens) {\n            if (ignoreLiteralSequences) {\n                final int type = currentToken.getKind();\n                if (isDiscardingLiterals()) {\n                    if (currentToken == discardingLiteralsUntil) { // NOPMD - intentional check for reference equality\n                        discardingLiteralsUntil = null;\n                        discardCurrent = true;\n                    }\n                } else if (type == CSharpLexer.OPEN_BRACE) {\n                    final AntlrToken finalToken = findEndOfSequenceOfLiterals(remainingTokens);\n                    discardingLiteralsUntil = finalToken;\n                }\n            }\n        }\n\n        private AntlrToken findEndOfSequenceOfLiterals(final Iterable<AntlrToken> remainingTokens) {\n            boolean seenLiteral = false;\n            int braceCount = 0;\n            for (final AntlrToken token : remainingTokens) {\n                switch (token.getKind()) {\n                case CSharpLexer.BIN_INTEGER_LITERAL:\n                case CSharpLexer.CHARACTER_LITERAL:\n                case CSharpLexer.HEX_INTEGER_LITERAL:\n                case CSharpLexer.INTEGER_LITERAL:\n                case CSharpLexer.REAL_LITERAL:\n                    seenLiteral = true;\n                    break; // can be skipped; continue to the next token\n                case CSharpLexer.COMMA:\n                    break; // can be skipped; continue to the next token\n                case CSharpLexer.OPEN_BRACE:\n                    braceCount++;\n                    break; // curly braces are allowed, as long as they're balanced\n                case CSharpLexer.CLOSE_BRACE:\n                    braceCount--;\n                    if (braceCount < 0) {\n                        // end of the list; skip all contents\n                        return seenLiteral ? token : null;\n                    } else {\n                        // curly braces are not yet balanced; continue to the next token\n                        break;\n                    }\n                default:\n                    // some other token than the expected ones; this is not a sequence of literals\n                    return null;\n                }\n            }\n            return null;\n        }\n\n        public boolean isDiscardingLiterals() {\n            return discardingLiteralsUntil != null;\n        }\n\n        @Override\n        protected boolean isLanguageSpecificDiscarding() {\n            return discardingUsings || discardingNL || isDiscardingAttribute || isDiscardingLiterals() || discardCurrent;\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            "private boolean getBooleanProperty(final Properties properties, final String property) {\n        return Boolean.parseBoolean(properties.getProperty(property, Boolean.FALSE.toString()));\n    }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "/**\n     * Sets the possible options for the C# tokenizer.\n     *\n     * @param properties the properties\n     * @see #IGNORE_USINGS\n     * @see #OPTION_IGNORE_LITERAL_SEQUENCES\n     * @see #IGNORE_ANNOTATIONS\n     */\n    public void setProperties(Properties properties) {\n        ignoreUsings = getBooleanProperty(properties, IGNORE_USINGS);\n        ignoreLiteralSequences = getBooleanProperty(properties, OPTION_IGNORE_LITERAL_SEQUENCES);\n        ignoreAttributes = getBooleanProperty(properties, IGNORE_ANNOTATIONS);\n    }\nprivate boolean getBooleanProperty(final Properties properties, final String property) {\n        return Boolean.parseBoolean(properties.getProperty(property, Boolean.FALSE.toString()));\n    }",
        "diffSourceCode": "-   24:     /**\n-   25:      * Sets the possible options for the C# tokenizer.\n-   26:      *\n-   27:      * @param properties the properties\n-   28:      * @see #IGNORE_USINGS\n-   29:      * @see #OPTION_IGNORE_LITERAL_SEQUENCES\n-   30:      */\n-   31:     public void setProperties(Properties properties) {\n-   32:         ignoreUsings = Boolean.parseBoolean(properties.getProperty(IGNORE_USINGS, Boolean.FALSE.toString()));\n-   33:         ignoreLiteralSequences = Boolean.parseBoolean(properties.getProperty(OPTION_IGNORE_LITERAL_SEQUENCES,\n-   34:             Boolean.FALSE.toString()));\n-   35:     }\n-   36: \n-   37:     public void setIgnoreUsings(boolean ignoreUsings) {\n-   39:     }\n-   40: \n-   41:     public void setIgnoreLiteralSequences(boolean ignoreLiteralSequences) {\n+   24: \n+   25:     /**\n+   26:      * Sets the possible options for the C# tokenizer.\n+   27:      *\n+   28:      * @param properties the properties\n+   29:      * @see #IGNORE_USINGS\n+   30:      * @see #OPTION_IGNORE_LITERAL_SEQUENCES\n+   31:      * @see #IGNORE_ANNOTATIONS\n+   32:      */\n+   33:     public void setProperties(Properties properties) {\n+   34:         ignoreUsings = getBooleanProperty(properties, IGNORE_USINGS);\n+   35:         ignoreLiteralSequences = getBooleanProperty(properties, OPTION_IGNORE_LITERAL_SEQUENCES);\n+   36:         ignoreAttributes = getBooleanProperty(properties, IGNORE_ANNOTATIONS);\n+   37:     }\n+   39:     private boolean getBooleanProperty(final Properties properties, final String property) {\n+   40:         return Boolean.parseBoolean(properties.getProperty(property, Boolean.FALSE.toString()));\n+   41:     }\n",
        "uniqueId": "7921e836b193df860a1866ac0415497711c4e531_24_35_39_41_25_37",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 17
            },
            "LINE": {
                "missed": 0,
                "covered": 4
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Move Method",
        "description": "Move Method\tprivate normalizeForwardSlashes(path String) : String from class net.sourceforge.pmd.docs.RuleDocGenerator to public normalizeForwardSlashes(path String) : String from class net.sourceforge.pmd.docs.RuleSetUtils",
        "diffLocations": [
            {
                "filePath": "pmd-doc/src/main/java/net/sourceforge/pmd/docs/RuleDocGenerator.java",
                "startLine": 663,
                "endLine": 671,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-doc/src/main/java/net/sourceforge/pmd/docs/RuleSetUtils.java",
                "startLine": 67,
                "endLine": 75,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private static String normalizeForwardSlashes(String path) {\n        String normalized = IOUtil.normalizePath(path);\n        if (SystemUtils.IS_OS_WINDOWS) {\n            // Note: windows path separators are changed to forward slashes,\n            // so that the editme link works\n            normalized = normalized.replaceAll(Pattern.quote(File.separator), \"/\");\n        }\n        return normalized;\n    }",
        "filePathBefore": "pmd-doc/src/main/java/net/sourceforge/pmd/docs/RuleDocGenerator.java",
        "isPureRefactoring": true,
        "commitId": "8addd05369b60e5169a7db304fc92fff6c08c018",
        "packageNameBefore": "net.sourceforge.pmd.docs",
        "classNameBefore": "net.sourceforge.pmd.docs.RuleDocGenerator",
        "methodNameBefore": "net.sourceforge.pmd.docs.RuleDocGenerator#normalizeForwardSlashes",
        "classSignatureBefore": "public class RuleDocGenerator ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.docs.RuleDocGenerator#normalizeForwardSlashes"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.docs.RuleDocGenerator"
        ],
        "classSignatureBeforeSet": [
            "public class RuleDocGenerator "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.docs;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.SimpleFileVisitor;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.SystemUtils;\nimport org.apache.commons.text.StringEscapeUtils;\n\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RuleSet;\nimport net.sourceforge.pmd.RuleSetLoadException;\nimport net.sourceforge.pmd.RuleSetLoader;\nimport net.sourceforge.pmd.lang.Language;\nimport net.sourceforge.pmd.lang.rule.RuleReference;\nimport net.sourceforge.pmd.lang.rule.XPathRule;\nimport net.sourceforge.pmd.properties.MultiValuePropertyDescriptor;\nimport net.sourceforge.pmd.properties.PropertyDescriptor;\nimport net.sourceforge.pmd.util.IOUtil;\n\npublic class RuleDocGenerator {\n    private static final Logger LOG = Logger.getLogger(RuleDocGenerator.class.getName());\n\n    private static final String GENERATED_WARNING = \"<!-- DO NOT EDIT THIS FILE. This file is generated from file ${source}. -->\";\n    private static final String GENERATED_WARNING_NO_SOURCE = \"<!-- DO NOT EDIT THIS FILE. This file is generated. -->\";\n\n    private static final String LANGUAGE_INDEX_FILENAME_PATTERN = \"docs/pages/pmd/rules/${language.tersename}.md\";\n    private static final String LANGUAGE_INDEX_PERMALINK_PATTERN = \"pmd_rules_${language.tersename}.html\";\n    private static final String RULESET_INDEX_FILENAME_PATTERN = \"docs/pages/pmd/rules/${language.tersename}/${ruleset.name}.md\";\n    private static final String RULESET_INDEX_PERMALINK_PATTERN = \"pmd_rules_${language.tersename}_${ruleset.name}.html\";\n\n    private static final String DEPRECATION_LABEL_SMALL = \"<span style=\\\"border-radius: 0.25em; color: #fff; padding: 0.2em 0.6em 0.3em; display: inline; background-color: #d9534f; font-size: 75%;\\\">Deprecated</span> \";\n    private static final String DEPRECATION_LABEL = \"<span style=\\\"border-radius: 0.25em; color: #fff; padding: 0.2em 0.6em 0.3em; display: inline; background-color: #d9534f;\\\">Deprecated</span> \";\n    private static final String DEPRECATED_RULE_PROPERTY_MARKER = \"deprecated!\";\n\n    private static final String GITHUB_SOURCE_LINK = \"https://github.com/pmd/pmd/blob/master/\";\n\n    /** Maintains mapping from pmd terse language name to rouge highlighter language. */\n    private static final Map<String, String> LANGUAGE_HIGHLIGHT_MAPPER = new HashMap<>();\n\n    static {\n        LANGUAGE_HIGHLIGHT_MAPPER.put(\"ecmascript\", \"javascript\");\n        LANGUAGE_HIGHLIGHT_MAPPER.put(\"pom\", \"xml\");\n        LANGUAGE_HIGHLIGHT_MAPPER.put(\"apex\", \"java\");\n        LANGUAGE_HIGHLIGHT_MAPPER.put(\"plsql\", \"sql\");\n    }\n\n    private final Path root;\n    private final FileWriter writer;\n\n    /** Caches rule class name to java source file mapping. */\n    private final Map<String, String> allRules = new HashMap<>();\n    /** Caches ruleset to ruleset xml file mapping. */\n    private final Map<String, String> allRulesets = new HashMap<>();\n\n\n    public RuleDocGenerator(FileWriter writer, Path root) {\n        this.writer = Objects.requireNonNull(writer, \"A file writer must be provided\");\n        this.root = Objects.requireNonNull(root, \"Root directory must be provided\");\n\n        Path docsDir = root.resolve(\"docs\");\n        if (!Files.exists(docsDir) || !Files.isDirectory(docsDir)) {\n            throw new IllegalArgumentException(\"Couldn't find \\\"docs\\\" subdirectory\");\n        }\n    }\n\n    public void generate(List<RuleSet> registeredRulesets, List<String> additionalRulesets) throws IOException {\n        Map<Language, List<RuleSet>> sortedRulesets;\n        Map<Language, List<RuleSet>> sortedAdditionalRulesets;\n        sortedRulesets = sortRulesets(registeredRulesets);\n        sortedAdditionalRulesets = sortRulesets(resolveAdditionalRulesets(additionalRulesets));\n        determineRuleClassSourceFiles(sortedRulesets);\n        generateLanguageIndex(sortedRulesets, sortedAdditionalRulesets);\n        generateRuleSetIndex(sortedRulesets);\n\n        generateSidebar(sortedRulesets);\n    }\n\n    private void generateSidebar(Map<Language, List<RuleSet>> sortedRulesets) throws IOException {\n        SidebarGenerator generator = new SidebarGenerator(writer, root);\n        generator.generateSidebar(sortedRulesets);\n    }\n\n    private List<RuleSet> resolveAdditionalRulesets(List<String> additionalRulesets) {\n        if (additionalRulesets == null) {\n            return Collections.emptyList();\n        }\n\n        List<RuleSet> rulesets = new ArrayList<>();\n        RuleSetLoader ruleSetLoader = new RuleSetLoader();\n        for (String filename : additionalRulesets) {\n            try {\n                // do not take rulesets from pmd-test or pmd-core\n                if (!filename.contains(\"pmd-test\") && !filename.contains(\"pmd-core\")) {\n                    rulesets.add(ruleSetLoader.loadFromResource(filename));\n                } else {\n                    LOG.fine(\"Ignoring ruleset \" + filename);\n                }\n            } catch (RuleSetLoadException e) {\n                // ignore rulesets, we can't read\n                LOG.log(Level.WARNING, \"ruleset file \" + filename + \" ignored (\" + e.getMessage() + \")\", e);\n            }\n        }\n        return rulesets;\n    }\n\n    private Path getAbsoluteOutputPath(String filename) {\n        return root.resolve(IOUtil.normalizePath(filename));\n    }\n\n    private Map<Language, List<RuleSet>> sortRulesets(List<RuleSet> rulesets) {\n        SortedMap<Language, List<RuleSet>> rulesetsByLanguage = rulesets.stream().collect(Collectors.groupingBy(RuleDocGenerator::getRuleSetLanguage,\n                                                                                                                TreeMap::new,\n                                                                                                                Collectors.toCollection(ArrayList::new)));\n\n        for (List<RuleSet> rulesetsOfOneLanguage : rulesetsByLanguage.values()) {\n            rulesetsOfOneLanguage.sort((o1, o2) -> o1.getName().compareToIgnoreCase(o2.getName()));\n        }\n        return rulesetsByLanguage;\n    }\n\n    /**\n     * Rulesets could potentially contain rules from various languages.\n     * But for built-in rulesets, all rules within one ruleset belong to\n     * one language. So we take the language of the first rule.\n     * @param ruleset\n     * @return the terse name of the ruleset's language\n     */\n    private static Language getRuleSetLanguage(RuleSet ruleset) {\n        Collection<Rule> rules = ruleset.getRules();\n        if (rules.isEmpty()) {\n            throw new RuntimeException(\"Ruleset \" + ruleset.getFileName() + \" is empty!\");\n        }\n        return rules.iterator().next().getLanguage();\n    }\n\n    /**\n     * Writes for each language an index file, which lists the rulesets, the rules\n     * and links to the ruleset pages.\n     * @param rulesets all registered/built-in rulesets\n     * @param sortedAdditionalRulesets additional rulesets\n     * @throws IOException\n     */\n    private void generateLanguageIndex(Map<Language, List<RuleSet>> rulesets, Map<Language, List<RuleSet>> sortedAdditionalRulesets) throws IOException {\n        for (Map.Entry<Language, List<RuleSet>> entry : rulesets.entrySet()) {\n            String languageTersename = entry.getKey().getTerseName();\n            String filename = LANGUAGE_INDEX_FILENAME_PATTERN\n                    .replace(\"${language.tersename}\", languageTersename);\n            Path path = getAbsoluteOutputPath(filename);\n\n            List<String> lines = new LinkedList<>();\n            lines.add(\"---\");\n            lines.add(\"title: \" + entry.getKey().getName() + \" Rules\");\n            lines.add(\"tags: [rule_references, \" + languageTersename + \"]\");\n            lines.add(\"summary: Index of all built-in rules available for \" + entry.getKey().getName());\n            lines.add(\"language_name: \" + entry.getKey().getName());\n            lines.add(\"permalink: \" + LANGUAGE_INDEX_PERMALINK_PATTERN.replace(\"${language.tersename}\", languageTersename));\n            lines.add(\"folder: pmd/rules\");\n            lines.add(\"editmepath: false\");\n            lines.add(\"---\");\n            lines.add(GENERATED_WARNING_NO_SOURCE);\n\n            for (RuleSet ruleset : entry.getValue()) {\n                lines.add(\"## \" + ruleset.getName());\n                lines.add(\"\");\n                lines.add(\"{% include callout.html content=\\\"\" + getRuleSetDescriptionSingleLine(ruleset) + \"\\\" %}\");\n                lines.add(\"\");\n\n                for (Rule rule : getSortedRules(ruleset)) {\n                    String link = RULESET_INDEX_PERMALINK_PATTERN\n                            .replace(\"${language.tersename}\", languageTersename)\n                            .replace(\"${ruleset.name}\", RuleSetUtils.getRuleSetFilename(ruleset));\n                    if (rule instanceof RuleReference) {\n                        RuleReference ref = (RuleReference) rule;\n                        if (ruleset.getFileName().equals(ref.getRuleSetReference().getRuleSetFileName())) {\n                            // rule renamed within same ruleset\n                            lines.add(\"*   [\" + rule.getName() + \"](\" + link + \"#\" + rule.getName().toLowerCase(Locale.ROOT) + \"): \"\n                                    + DEPRECATION_LABEL_SMALL\n                                    + \"The rule has been renamed. Use instead \"\n                                    + \"[\" + ref.getRule().getName() + \"](\" + link + \"#\" + ref.getRule().getName().toLowerCase(Locale.ROOT) + \").\");\n                        } else {\n                            // rule moved to another ruleset...\n                            String otherLink = RULESET_INDEX_PERMALINK_PATTERN\n                                    .replace(\"${language.tersename}\", languageTersename)\n                                    .replace(\"${ruleset.name}\", RuleSetUtils.getRuleSetFilename(ref.getRuleSetReference().getRuleSetFileName()));\n                            lines.add(\"*   [\" + rule.getName() + \"](\" + link + \"#\" + rule.getName().toLowerCase(Locale.ROOT) + \"): \"\n                                    + DEPRECATION_LABEL_SMALL\n                                    + \"The rule has been moved to another ruleset. Use instead \"\n                                    + \"[\" + ref.getRule().getName() + \"](\" + otherLink + \"#\" + ref.getRule().getName().toLowerCase(Locale.ROOT) + \").\");\n                        }\n                    } else {\n                        link += \"#\" + rule.getName().toLowerCase(Locale.ROOT);\n                        lines.add(\"*   [\" + rule.getName() + \"](\" + link + \"): \"\n                                + (rule.isDeprecated() ? DEPRECATION_LABEL_SMALL : \"\")\n                                + getShortRuleDescription(rule));\n                    }\n                }\n                lines.add(\"\");\n            }\n\n            List<RuleSet> additionalRulesetsForLanguage = sortedAdditionalRulesets.get(entry.getKey());\n            if (additionalRulesetsForLanguage != null) {\n                lines.add(\"## Additional rulesets\");\n                lines.add(\"\");\n\n                for (RuleSet ruleset : additionalRulesetsForLanguage) {\n                    boolean deprecated = RuleSetUtils.isRuleSetDeprecated(ruleset);\n\n                    String rulesetName = ruleset.getName() + \" (`\" + RuleSetUtils.getRuleSetClasspath(ruleset) + \"`)\";\n\n                    if (!deprecated) {\n                        lines.add(\"*   \" + rulesetName + \":\");\n                        lines.add(\"\");\n                        lines.add(\"    \" + getRuleSetDescriptionSingleLine(ruleset));\n                        lines.add(\"\");\n                    } else {\n                        lines.add(\"*   \" + rulesetName + \":\");\n                        lines.add(\"\");\n                        lines.add(\"    \" + DEPRECATION_LABEL_SMALL + \" This ruleset is for backwards compatibility.\");\n                        lines.add(\"\");\n                    }\n\n                    lines.add(\"    It contains the following rules:\");\n                    lines.add(\"\");\n                    StringBuilder rules = new StringBuilder();\n                    for (Rule rule : getSortedRules(ruleset)) {\n                        if (rules.length() == 0) {\n                            rules.append(\"    \");\n                        } else {\n                            rules.append(\", \");\n                        }\n\n                        Rule resolvedRule = RuleSetUtils.resolveRuleReferences(rule);\n                        if (resolvedRule instanceof RuleReference) {\n                            // Note: deprecated rulesets contain by definition only rule references\n                            RuleReference ref = (RuleReference) resolvedRule;\n                            String otherLink = RULESET_INDEX_PERMALINK_PATTERN\n                                    .replace(\"${language.tersename}\", languageTersename)\n                                    .replace(\"${ruleset.name}\", RuleSetUtils.getRuleSetFilename(ref.getRuleSetReference().getRuleSetFileName()));\n\n                            rules.append(\"[\").append(ref.getName()).append(\"](\");\n                            rules.append(otherLink).append(\"#\").append(ref.getRule().getName().toLowerCase(Locale.ROOT)).append(\")\");\n                        } else {\n                            rules.append(rule.getName());\n                        }\n                    }\n                    lines.add(rules.toString());\n                    lines.add(\"\");\n                }\n                lines.add(\"\");\n            }\n\n            System.out.println(\"Generated \" + path);\n            writer.write(path, lines);\n        }\n    }\n\n    /**\n     * Shortens and escapes (for markdown) some special characters. Otherwise the shortened text\n     * could contain some unfinished sequences.\n     * @param rule\n     * @return\n     */\n    private static String getShortRuleDescription(Rule rule) {\n        String htmlEscaped = StringEscapeUtils.escapeHtml4(\n            StringUtils.abbreviate(\n                StringUtils.stripToEmpty(\n                    rule.getDescription()\n                        .replaceAll(\"\\n+|\\r+\", \" \")\n                        .replaceAll(\"\\\\|\", \"\\\\\\\\|\")\n                        .replaceAll(\"`\", \"'\")\n                        .replaceAll(\"\\\\*\", \"\")),\n                100));\n        return EscapeUtils.preserveRuleTagQuotes(htmlEscaped);\n    }\n\n    private static String getRuleSetDescriptionSingleLine(RuleSet ruleset) {\n        String description = ruleset.getDescription();\n        description = StringEscapeUtils.escapeHtml4(description);\n        description = description.replaceAll(\"\\\\n|\\\\r\", \" \");\n        description = StringUtils.stripToEmpty(description);\n        return EscapeUtils.preserveRuleTagQuotes(description);\n    }\n\n    private static List<String> toLines(String s) {\n        return Arrays.asList(s.split(\"\\r\\n|\\n\"));\n    }\n\n    /**\n     * Generates for each ruleset a page. The page contains the details for each rule.\n     *\n     * @param rulesets all rulesets\n     * @throws IOException\n     */\n    private void generateRuleSetIndex(Map<Language, List<RuleSet>> rulesets) throws IOException {\n        for (Map.Entry<Language, List<RuleSet>> entry : rulesets.entrySet()) {\n            Language language = entry.getKey();\n            String languageTersename = language.getTerseName();\n            String languageName = language.getName();\n            for (RuleSet ruleset : entry.getValue()) {\n                String rulesetFilename = RuleSetUtils.getRuleSetFilename(ruleset);\n                String filename = RULESET_INDEX_FILENAME_PATTERN\n                    .replace(\"${language.tersename}\", languageTersename)\n                    .replace(\"${ruleset.name}\", rulesetFilename);\n\n                Path path = getAbsoluteOutputPath(filename);\n\n                String permalink = RULESET_INDEX_PERMALINK_PATTERN\n                        .replace(\"${language.tersename}\", languageTersename)\n                        .replace(\"${ruleset.name}\", rulesetFilename);\n                String ruleSetSourceFilepath = \"../\" + allRulesets.get(ruleset.getFileName());\n\n                List<String> lines = new LinkedList<>();\n                lines.add(\"---\");\n                lines.add(\"title: \" + ruleset.getName());\n                lines.add(\"summary: \" + getRuleSetDescriptionSingleLine(ruleset));\n                lines.add(\"permalink: \" + permalink);\n                lines.add(\"folder: pmd/rules/\" + languageTersename);\n                lines.add(\"sidebaractiveurl: /\" + LANGUAGE_INDEX_PERMALINK_PATTERN.replace(\"${language.tersename}\", languageTersename));\n                lines.add(\"editmepath: \" + ruleSetSourceFilepath);\n                lines.add(\"keywords: \" + getRuleSetKeywords(ruleset));\n                lines.add(\"language: \" + languageName);\n                lines.add(\"---\");\n                lines.add(GENERATED_WARNING.replace(\"${source}\", ruleSetSourceFilepath));\n\n                for (Rule rule : getSortedRules(ruleset)) {\n                    lines.add(\"## \" + rule.getName());\n                    lines.add(\"\");\n\n                    if (rule instanceof RuleReference) {\n                        RuleReference ref = (RuleReference) rule;\n                        if (ruleset.getFileName().equals(ref.getRuleSetReference().getRuleSetFileName())) {\n                            // rule renamed within same ruleset\n                            lines.add(DEPRECATION_LABEL);\n                            lines.add(\"\");\n                            lines.add(\"This rule has been renamed. Use instead: [\"\n                                    + ref.getRule().getName() + \"](\" + \"#\" + ref.getRule().getName().toLowerCase(Locale.ROOT) + \")\");\n                            lines.add(\"\");\n                        } else {\n                            // rule moved to another ruleset\n                            String otherLink = RULESET_INDEX_PERMALINK_PATTERN\n                                    .replace(\"${language.tersename}\", languageTersename)\n                                    .replace(\"${ruleset.name}\", RuleSetUtils.getRuleSetFilename(ref.getRuleSetReference().getRuleSetFileName()));\n                            lines.add(DEPRECATION_LABEL);\n                            lines.add(\"\");\n                            lines.add(\"The rule has been moved to another ruleset. Use instead: [\"\n                                    + ref.getRule().getName() + \"](\" + otherLink + \"#\" + ref.getRule().getName().toLowerCase(Locale.ROOT) + \")\");\n                            lines.add(\"\");\n                        }\n                    }\n\n                    if (rule.isDeprecated()) {\n                        lines.add(DEPRECATION_LABEL);\n                        lines.add(\"\");\n                    }\n                    if (rule.getSince() != null) {\n                        lines.add(\"**Since:** PMD \" + rule.getSince());\n                        lines.add(\"\");\n                    }\n                    lines.add(\"**Priority:** \" + rule.getPriority() + \" (\" + rule.getPriority().getPriority() + \")\");\n                    lines.add(\"\");\n\n                    if (rule.getMinimumLanguageVersion() != null) {\n                        lines.add(\"**Minimum Language Version:** \"\n                                + rule.getLanguage().getName() + \" \" + rule.getMinimumLanguageVersion().getVersion());\n                        lines.add(\"\");\n                    }\n\n                    lines.addAll(EscapeUtils.escapeLines(toLines(stripIndentation(rule.getDescription()))));\n                    lines.add(\"\");\n\n                    XPathRule xpathRule = asXPathRule(rule);\n                    if (xpathRule != null) {\n                        lines.add(\"**This rule is defined by the following XPath expression:**\");\n                        lines.add(\"``` xpath\");\n                        lines.addAll(toLines(StringUtils.stripToEmpty(xpathRule.getXPathExpression())));\n                        lines.add(\"```\");\n                    } else {\n                        lines.add(\"**This rule is defined by the following Java class:** \"\n                                + \"[\" + rule.getRuleClass() + \"](\"\n                                + GITHUB_SOURCE_LINK + allRules.get(rule.getRuleClass())\n                                + \")\");\n                    }\n                    lines.add(\"\");\n\n                    if (!rule.getExamples().isEmpty()) {\n                        lines.add(\"**Example(s):**\");\n                        lines.add(\"\");\n                        for (String example : rule.getExamples()) {\n                            lines.add(\"``` \" + mapLanguageForHighlighting(languageTersename));\n                            lines.addAll(toLines(\"{%raw%}\" + StringUtils.stripToEmpty(example) + \"{%endraw%}\"));\n                            lines.add(\"```\");\n                            lines.add(\"\");\n                        }\n                    }\n\n                    List<PropertyDescriptor<?>> properties = new ArrayList<>(rule.getPropertyDescriptors());\n                    // filter out standard properties\n                    properties.remove(Rule.VIOLATION_SUPPRESS_REGEX_DESCRIPTOR);\n                    properties.remove(Rule.VIOLATION_SUPPRESS_XPATH_DESCRIPTOR);\n                    properties.remove(XPathRule.XPATH_DESCRIPTOR);\n                    properties.remove(XPathRule.VERSION_DESCRIPTOR);\n\n                    if (!properties.isEmpty()) {\n                        lines.add(\"**This rule has the following properties:**\");\n                        lines.add(\"\");\n                        lines.add(\"|Name|Default Value|Description|Multivalued|\");\n                        lines.add(\"|----|-------------|-----------|-----------|\");\n                        for (PropertyDescriptor<?> propertyDescriptor : properties) {\n                            String description = propertyDescriptor.description();\n                            final boolean isDeprecated = isDeprecated(propertyDescriptor);\n                            if (isDeprecated) {\n                                description = description.substring(DEPRECATED_RULE_PROPERTY_MARKER.length());\n                            }\n\n                            String defaultValue = determineDefaultValueAsString(propertyDescriptor, rule, true);\n\n                            String multiValued = \"no\";\n                            if (propertyDescriptor.isMultiValue()) {\n                                MultiValuePropertyDescriptor<?> multiValuePropertyDescriptor =\n                                        (MultiValuePropertyDescriptor<?>) propertyDescriptor;\n                                multiValued = \"yes. Delimiter is '\"\n                                        + multiValuePropertyDescriptor.multiValueDelimiter() + \"'.\";\n                            }\n\n                            lines.add(\"|\" + EscapeUtils.escapeMarkdown(StringEscapeUtils.escapeHtml4(propertyDescriptor.name()))\n                                    + \"|\" + EscapeUtils.escapeMarkdown(StringEscapeUtils.escapeHtml4(defaultValue)) + \"|\"\n                                    + EscapeUtils.escapeMarkdown((isDeprecated ? DEPRECATION_LABEL_SMALL : \"\")\n                                            + StringEscapeUtils.escapeHtml4(description))\n                                    + \"|\" + EscapeUtils.escapeMarkdown(StringEscapeUtils.escapeHtml4(multiValued)) + \"|\");\n                        }\n                        lines.add(\"\");\n                    }\n\n                    if (properties.isEmpty()) {\n                        lines.add(\"**Use this rule by referencing it:**\");\n                    } else {\n                        lines.add(\"**Use this rule with the default properties by just referencing it:**\");\n                    }\n                    lines.add(\"``` xml\");\n                    lines.add(\"<rule ref=\\\"category/\" + languageTersename + \"/\" + rulesetFilename + \".xml/\" + rule.getName() + \"\\\" />\");\n                    lines.add(\"```\");\n                    lines.add(\"\");\n\n                    if (properties.stream().anyMatch(it -> !isDeprecated(it))) {\n                        lines.add(\"**Use this rule and customize it:**\");\n                        lines.add(\"``` xml\");\n                        lines.add(\"<rule ref=\\\"category/\" + languageTersename + \"/\" + rulesetFilename + \".xml/\" + rule.getName() + \"\\\">\");\n                        lines.add(\"    <properties>\");\n                        for (PropertyDescriptor<?> propertyDescriptor : properties) {\n                            if (!isDeprecated(propertyDescriptor)) {\n                                String defaultValue = determineDefaultValueAsString(propertyDescriptor, rule, false);\n                                lines.add(\"        <property name=\\\"\" + propertyDescriptor.name() + \"\\\" value=\\\"\"\n                                              + defaultValue + \"\\\" />\");\n                            }\n                        }\n                        lines.add(\"    </properties>\");\n                        lines.add(\"</rule>\");\n                        lines.add(\"```\");\n                        lines.add(\"\");\n                    }\n                }\n\n                writer.write(path, lines);\n                System.out.println(\"Generated \" + path);\n            }\n        }\n    }\n\n    private XPathRule asXPathRule(Rule rule) {\n        if (rule instanceof XPathRule) {\n            return (XPathRule) rule;\n        } else if (rule instanceof RuleReference && ((RuleReference) rule).getRule() instanceof XPathRule) {\n            return (XPathRule) ((RuleReference) rule).getRule();\n        }\n        return null;\n    }\n\n    private static boolean isDeprecated(PropertyDescriptor<?> propertyDescriptor) {\n        return propertyDescriptor.description() != null\n            && propertyDescriptor.description().toLowerCase(Locale.ROOT).startsWith(DEPRECATED_RULE_PROPERTY_MARKER);\n    }\n\n    private String determineDefaultValueAsString(PropertyDescriptor<?> propertyDescriptor, Rule rule, boolean pad) {\n        String defaultValue = \"\";\n        Object realDefaultValue = rule.getProperty(propertyDescriptor);\n        @SuppressWarnings(\"unchecked\") // just force it, we know it's the right type\n        PropertyDescriptor<Object> captured = (PropertyDescriptor<Object>) propertyDescriptor;\n\n        if (realDefaultValue != null) {\n            defaultValue = captured.asDelimitedString(realDefaultValue);\n\n            if (pad && propertyDescriptor.isMultiValue()) {\n                @SuppressWarnings(\"unchecked\") // multi valued properties are using a List\n                MultiValuePropertyDescriptor<List<?>> multiPropertyDescriptor = (MultiValuePropertyDescriptor<List<?>>) propertyDescriptor;\n\n                // surround the delimiter with spaces, so that the browser can wrap\n                // the value nicely\n                defaultValue = defaultValue.replaceAll(Pattern.quote(\n                        String.valueOf(multiPropertyDescriptor.multiValueDelimiter())),\n                        \" \" + multiPropertyDescriptor.multiValueDelimiter() + \" \");\n            }\n        }\n        return defaultValue;\n    }\n\n    private static String stripIndentation(String description) {\n        if (description == null || description.isEmpty()) {\n            return \"\";\n        }\n\n        String stripped = StringUtils.stripStart(description, \"\\n\\r\");\n        stripped = StringUtils.stripEnd(stripped, \"\\n\\r \");\n\n        int indentation = 0;\n        int strLen = stripped.length();\n        while (Character.isWhitespace(stripped.charAt(indentation)) && indentation < strLen) {\n            indentation++;\n        }\n\n        String[] lines = stripped.split(\"\\\\n\");\n        String prefix = StringUtils.repeat(' ', indentation);\n        StringBuilder result = new StringBuilder(stripped.length());\n\n        if (StringUtils.isNotEmpty(prefix)) {\n            for (int i = 0; i < lines.length; i++) {\n                String line = lines[i];\n                if (i > 0) {\n                    result.append(StringUtils.LF);\n                }\n                result.append(StringUtils.removeStart(line, prefix));\n            }\n        } else {\n            result.append(stripped);\n        }\n        return result.toString();\n    }\n\n    /**\n     * Simply maps PMD languages to rouge languages\n     *\n     * @param languageTersename\n     * @return\n     * @see <a href=\"https://github.com/jneen/rouge/wiki/List-of-supported-languages-and-lexers\">List of supported languages</a>\n     */\n    private static String mapLanguageForHighlighting(String languageTersename) {\n        if (LANGUAGE_HIGHLIGHT_MAPPER.containsKey(languageTersename)) {\n            return LANGUAGE_HIGHLIGHT_MAPPER.get(languageTersename);\n        }\n        return languageTersename;\n    }\n\n    private String getRuleSetKeywords(RuleSet ruleset) {\n        List<String> ruleNames = new LinkedList<>();\n        for (Rule rule : ruleset.getRules()) {\n            ruleNames.add(rule.getName());\n        }\n        return ruleset.getName() + \", \" + StringUtils.join(ruleNames, \", \");\n    }\n\n    private List<Rule> getSortedRules(RuleSet ruleset) {\n        List<Rule> sortedRules = new ArrayList<>(ruleset.getRules());\n        Collections.sort(sortedRules, new Comparator<Rule>() {\n            @Override\n            public int compare(Rule o1, Rule o2) {\n                return o1.getName().compareToIgnoreCase(o2.getName());\n            }\n        });\n        return sortedRules;\n    }\n\n    /**\n     * Walks through the root directory once to get all rule source file path names and ruleset names.\n     * This provides the information for the \"editme\" links.\n     *\n     * @param sortedRulesets all the rulesets and rules\n     */\n    private void determineRuleClassSourceFiles(Map<Language, List<RuleSet>> sortedRulesets) {\n        // first collect all the classes, we need to resolve and the rulesets\n        // this also provides a default fallback path, which is used in unit tests.\n        // if the actual file is found during walkFileTree, then the default fallback path\n        // is replaced by a correct path.\n        for (List<RuleSet> rulesets : sortedRulesets.values()) {\n            for (RuleSet ruleset : rulesets) {\n                String rulesetFilename = normalizeForwardSlashes(StringUtils.chomp(ruleset.getFileName()));\n                allRulesets.put(ruleset.getFileName(), rulesetFilename);\n                for (Rule rule : ruleset.getRules()) {\n                    String ruleClass = rule.getRuleClass();\n                    String relativeSourceFilename = ruleClass.replaceAll(\"\\\\.\", Matcher.quoteReplacement(File.separator))\n                            + \".java\";\n                    allRules.put(ruleClass, normalizeForwardSlashes(relativeSourceFilename));\n                }\n            }\n        }\n\n        // then go and search the actual files\n        try {\n            Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n                @Override\n                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {\n                    String path = file.toString();\n\n                    if (path.contains(\"src\")) {\n                        String foundRuleClass = null;\n                        for (Map.Entry<String, String> entry : allRules.entrySet()) {\n                            if (path.endsWith(entry.getValue())) {\n                                foundRuleClass = entry.getKey();\n                                break;\n                            }\n                        }\n                        if (foundRuleClass != null) {\n                            Path foundPath = root.relativize(file);\n                            allRules.put(foundRuleClass, normalizeForwardSlashes(foundPath.toString()));\n                        }\n\n                        String foundRuleset = null;\n                        for (Map.Entry<String, String> entry : allRulesets.entrySet()) {\n                            if (path.endsWith(entry.getValue())) {\n                                foundRuleset = entry.getKey();\n                                break;\n                            }\n                        }\n                        if (foundRuleset != null) {\n                            Path foundPath = root.relativize(file);\n                            allRulesets.put(foundRuleset, normalizeForwardSlashes(foundPath.toString()));\n                        }\n                    }\n                    return FileVisitResult.CONTINUE;\n                }\n            });\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private static String normalizeForwardSlashes(String path) {\n        String normalized = IOUtil.normalizePath(path);\n        if (SystemUtils.IS_OS_WINDOWS) {\n            // Note: windows path separators are changed to forward slashes,\n            // so that the editme link works\n            normalized = normalized.replaceAll(Pattern.quote(File.separator), \"/\");\n        }\n        return normalized;\n    }\n}\n",
        "filePathAfter": "pmd-doc/src/main/java/net/sourceforge/pmd/docs/RuleSetUtils.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.docs;\n\nimport java.io.File;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.SystemUtils;\n\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RuleSet;\nimport net.sourceforge.pmd.lang.rule.RuleReference;\nimport net.sourceforge.pmd.util.IOUtil;\n\npublic final class RuleSetUtils {\n\n    private RuleSetUtils() {\n        // Utility class\n    }\n\n    /**\n     * Gets the sanitized base name of the ruleset.\n     * For some reason, the filename might contain some newlines, which are removed.\n     * @param ruleset\n     * @return\n     */\n    public static String getRuleSetFilename(RuleSet ruleset) {\n        return getRuleSetFilename(ruleset.getFileName());\n    }\n\n    public static String getRuleSetFilename(String rulesetFileName) {\n        return IOUtil.getFilenameBase(StringUtils.chomp(rulesetFileName));\n    }\n\n    /**\n     * A ruleset is considered deprecated, if it only contains rule references\n     * and all rule references are deprecated.\n     *\n     * @param ruleset\n     * @return\n     */\n    public static boolean isRuleSetDeprecated(RuleSet ruleset) {\n        boolean result = true;\n        for (Rule rule : ruleset.getRules()) {\n            if (!(rule instanceof RuleReference) || !rule.isDeprecated()) {\n                result = false;\n                break;\n            }\n        }\n        return result;\n    }\n\n    public static String getRuleSetClasspath(RuleSet ruleset) {\n        final String RESOURCES_PATH = \"/resources/\";\n        String filename = normalizeForwardSlashes(StringUtils.chomp(ruleset.getFileName()));\n        int startIndex = filename.lastIndexOf(RESOURCES_PATH);\n        if (startIndex > -1) {\n            return filename.substring(startIndex + RESOURCES_PATH.length());\n        } else {\n            return filename;\n        }\n    }\n\n    public static String normalizeForwardSlashes(String path) {\n        String normalized = IOUtil.normalizePath(path);\n        if (SystemUtils.IS_OS_WINDOWS) {\n            // Note: windows path separators are changed to forward slashes,\n            // so that the editme link works\n            normalized = normalized.replaceAll(Pattern.quote(File.separator), \"/\");\n        }\n        return normalized;\n    }\n\n    /**\n     * Recursively resolves rule references until the last reference.\n     * The last reference is returned.\n     * If the given rule not a reference, the rule is returned.\n     *\n     * @param rule\n     * @return\n     */\n    public static Rule resolveRuleReferences(Rule rule) {\n        Rule result = rule;\n        Rule ref = rule;\n        while (ref instanceof RuleReference) {\n            // remember the last reference\n            result = ref;\n            ref = ((RuleReference) ref).getRule();\n        }\n        return result;\n    }\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "public static String normalizeForwardSlashes(String path) {\n        String normalized = IOUtil.normalizePath(path);\n        if (SystemUtils.IS_OS_WINDOWS) {\n            // Note: windows path separators are changed to forward slashes,\n            // so that the editme link works\n            normalized = normalized.replaceAll(Pattern.quote(File.separator), \"/\");\n        }\n        return normalized;\n    }",
        "diffSourceCode": "-   67: \n-   68:     static {\n-   69:         LANGUAGE_HIGHLIGHT_MAPPER.put(\"ecmascript\", \"javascript\");\n-   70:         LANGUAGE_HIGHLIGHT_MAPPER.put(\"pom\", \"xml\");\n-   71:         LANGUAGE_HIGHLIGHT_MAPPER.put(\"apex\", \"java\");\n-   72:         LANGUAGE_HIGHLIGHT_MAPPER.put(\"plsql\", \"sql\");\n-   73:     }\n-   74: \n-   75:     private final Path root;\n-  663:     private static String normalizeForwardSlashes(String path) {\n-  664:         String normalized = IOUtil.normalizePath(path);\n-  665:         if (SystemUtils.IS_OS_WINDOWS) {\n-  666:             // Note: windows path separators are changed to forward slashes,\n-  667:             // so that the editme link works\n-  668:             normalized = normalized.replaceAll(Pattern.quote(File.separator), \"/\");\n-  669:         }\n-  670:         return normalized;\n-  671:     }\n+   67:     public static String normalizeForwardSlashes(String path) {\n+   68:         String normalized = IOUtil.normalizePath(path);\n+   69:         if (SystemUtils.IS_OS_WINDOWS) {\n+   70:             // Note: windows path separators are changed to forward slashes,\n+   71:             // so that the editme link works\n+   72:             normalized = normalized.replaceAll(Pattern.quote(File.separator), \"/\");\n+   73:         }\n+   74:         return normalized;\n+   75:     }\n",
        "uniqueId": "8addd05369b60e5169a7db304fc92fff6c08c018_663_671__67_75",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 6,
                "covered": 7
            },
            "BRANCH": {
                "missed": 1,
                "covered": 1
            },
            "LINE": {
                "missed": 1,
                "covered": 3
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Move And Rename Method",
        "description": "Move And Rename Method\tpublic getVersionWithParserThatReportsSemanticError() : LanguageVersion from class net.sourceforge.pmd.lang.DummyLanguageModule to public versionWithParserThatReportsSemanticError() : LanguageVersion from class net.sourceforge.pmd.processor.PmdRunnableTest",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/lang/DummyLanguageModule.java",
                "startLine": 54,
                "endLine": 56,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/test/java/net/sourceforge/pmd/processor/PmdRunnableTest.java",
                "startLine": 164,
                "endLine": 166,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public LanguageVersion getVersionWithParserThatReportsSemanticError() {\n        return getVersion(PARSER_REPORTS_SEMANTIC_ERROR);\n    }",
        "filePathBefore": "pmd-core/src/test/java/net/sourceforge/pmd/lang/DummyLanguageModule.java",
        "isPureRefactoring": true,
        "commitId": "ff2f5ef93c1b3150583e9611b2a8fd8159e3aa66",
        "packageNameBefore": "net.sourceforge.pmd.lang",
        "classNameBefore": "net.sourceforge.pmd.lang.DummyLanguageModule",
        "methodNameBefore": "net.sourceforge.pmd.lang.DummyLanguageModule#getVersionWithParserThatReportsSemanticError",
        "classSignatureBefore": "public class DummyLanguageModule extends BaseLanguageModule ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.DummyLanguageModule#getVersionWithParserThatReportsSemanticError"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.DummyLanguageModule"
        ],
        "classSignatureBeforeSet": [
            "public class DummyLanguageModule extends BaseLanguageModule "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Move Method refactoring mechanics\n",
                "description": "Move Method specific changes - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\n\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RuleViolation;\nimport net.sourceforge.pmd.lang.ast.DummyNode;\nimport net.sourceforge.pmd.lang.ast.DummyNode.DummyRootNode;\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.ast.ParseException;\nimport net.sourceforge.pmd.lang.ast.Parser;\nimport net.sourceforge.pmd.lang.ast.RootNode;\nimport net.sourceforge.pmd.lang.ast.SourceCodePositioner;\nimport net.sourceforge.pmd.lang.rule.ParametricRuleViolation;\nimport net.sourceforge.pmd.lang.rule.impl.DefaultRuleViolationFactory;\n\n/**\n * Dummy language used for testing PMD.\n */\npublic class DummyLanguageModule extends BaseLanguageModule {\n\n    public static final String NAME = \"Dummy\";\n    public static final String TERSE_NAME = \"dummy\";\n    private static final String PARSER_REPORTS_SEMANTIC_ERROR = \"1.9-semantic_error\";\n    private static final String THROWS_SEMANTIC_ERROR = \"1.9-throws_semantic_error\";\n    private static final String THROWS_ASSERTION_ERROR = \"1.9-throws\";\n\n    public DummyLanguageModule() {\n        super(NAME, null, TERSE_NAME, \"dummy\");\n        addVersion(\"1.0\", new Handler());\n        addVersion(\"1.1\", new Handler());\n        addVersion(\"1.2\", new Handler());\n        addVersion(\"1.3\", new Handler());\n        addVersion(\"1.4\", new Handler());\n        addVersion(\"1.5\", new Handler(), \"5\");\n        addVersion(\"1.6\", new Handler(), \"6\");\n        addDefaultVersion(\"1.7\", new Handler(), \"7\");\n        addVersion(\"1.8\", new Handler(), \"8\");\n        addVersion(THROWS_ASSERTION_ERROR, new HandlerWithParserThatThrows());\n        addVersion(PARSER_REPORTS_SEMANTIC_ERROR, new HandlerWithParserThatReportsSemanticError());\n        addVersion(THROWS_SEMANTIC_ERROR, new HandlerWithParserThatThrowsSemanticError());\n    }\n\n    public LanguageVersion getVersionWithParserThatThrowsAssertionError() {\n        return getVersion(THROWS_ASSERTION_ERROR);\n    }\n    public LanguageVersion getVersionWithParserThatThrowsSemanticError() {\n        return getVersion(THROWS_SEMANTIC_ERROR);\n    }\n    public LanguageVersion getVersionWithParserThatReportsSemanticError() {\n        return getVersion(PARSER_REPORTS_SEMANTIC_ERROR);\n    }\n\n    public static DummyLanguageModule getInstance() {\n        return (DummyLanguageModule) LanguageRegistry.getLanguage(NAME);\n    }\n\n    public static DummyRootNode parse(String code) {\n        return parse(code, \"nofilename\");\n    }\n\n    public static DummyRootNode parse(String code, String filename) {\n        DummyRootNode rootNode = readLispNode(code);\n        rootNode.withFileName(filename);\n        return rootNode;\n    }\n\n\n    public static class Handler extends AbstractPmdLanguageVersionHandler {\n        @Override\n        public RuleViolationFactory getRuleViolationFactory() {\n            return new RuleViolationFactory();\n        }\n\n        @Override\n        public Parser getParser() {\n            return task -> {\n                DummyRootNode rootNode = readLispNode(task.getSourceText());\n                rootNode.withFileName(task.getFileDisplayName());\n                rootNode.withLanguage(task.getLanguageVersion());\n                rootNode.withSourceText(task.getSourceText());\n                return rootNode;\n            };\n        }\n    }\n\n    public static class HandlerWithParserThatThrows extends Handler {\n        @Override\n        public Parser getParser() {\n            return task -> {\n                throw new AssertionError(\"test error while parsing\");\n            };\n        }\n    }\n\n    public static class HandlerWithParserThatReportsSemanticError extends Handler {\n        @Override\n        public Parser getParser() {\n            return task -> {\n                RootNode root = super.getParser().parse(task);\n                task.getReporter().error(root, \"An error occurred!\");\n                return root;\n            };\n        }\n    }\n\n    public static class HandlerWithParserThatThrowsSemanticError extends Handler {\n        @Override\n        public Parser getParser() {\n            return task -> {\n                RootNode root = super.getParser().parse(task);\n                throw task.getReporter().error(root, \"An error occurred!\");\n            };\n        }\n    }\n\n    /**\n     * Creates a tree of nodes that corresponds to the nesting structures\n     * of parentheses in the text. The image of each node is also populated.\n     * This is useful to create non-trivial trees with all the relevant\n     * data (eg coordinates) set properly.\n     *\n     * Eg {@code (a(b)x(c))} will create a tree with a node \"a\", with two\n     * children \"b\" and \"c\". \"x\" is ignored. The node \"a\" is not the root\n     * node, it has a {@link DummyRootNode} as parent, whose image is \"\".\n     */\n    private static DummyRootNode readLispNode(String text) {\n        final DummyRootNode root = new DummyRootNode().withSourceText(text);\n        DummyNode top = root;\n        SourceCodePositioner positioner = new SourceCodePositioner(text);\n        top.setCoords(1, 1, positioner.getLastLine(), positioner.getLastLineColumn());\n        int lastNodeStart = 0;\n        for (int i = 0; i < text.length(); i++) {\n            char c = text.charAt(i);\n            if (c == '(') {\n                DummyNode node = new DummyNode();\n                node.setParent(top);\n                top.addChild(node, top.getNumChildren());\n                // setup coordinates\n                int bline = positioner.lineNumberFromOffset(i);\n                int bcol = positioner.columnFromOffset(bline, i);\n                node.setCoords(bline, bcol, bline, bcol);\n                // cut out image\n                if (top.getImage() == null) {\n                    // image may be non null if this is not the first child of 'top'\n                    // eg in (a(b)x(c)), the image of the parent is set to \"a\".\n                    // When we're processing \"(c\", we ignore \"x\".\n                    String image = text.substring(lastNodeStart, i);\n                    top.setImage(image);\n                }\n                lastNodeStart = i + 1;\n                // node is the top of the stack now\n                top = node;\n            } else if (c == ')') {\n                if (top == null) {\n                    throw new ParseException(\"Unbalanced parentheses: \" + text);\n                }\n                // setup coordinates\n                int eline = positioner.lineNumberFromOffset(i);\n                int ecol = positioner.columnFromOffset(eline, i);\n                top.setCoords(top.getBeginLine(), top.getBeginColumn(), eline, ecol);\n\n                if (top.getImage() == null) {\n                    // cut out image (if node doesn't have children it hasn't been populated yet)\n                    String image = text.substring(lastNodeStart, i);\n                    top.setImage(image);\n                    lastNodeStart = i + 1;\n                }\n                top = top.getParent();\n            }\n        }\n        if (top != root) {\n            throw new ParseException(\"Unbalanced parentheses: \" + text);\n        }\n        return root;\n    }\n\n    public static class RuleViolationFactory extends DefaultRuleViolationFactory {\n\n        @Override\n        public RuleViolation createViolation(Rule rule, @NonNull Node location, @NonNull String formattedMessage) {\n            return new ParametricRuleViolation<Node>(rule, location, formattedMessage) {\n                {\n                    this.packageName = \"foo\"; // just for testing variable expansion\n                }\n            };\n        }\n    }\n}\n",
        "filePathAfter": "pmd-core/src/test/java/net/sourceforge/pmd/processor/PmdRunnableTest.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.processor;\n\nimport static org.hamcrest.CoreMatchers.instanceOf;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.hasSize;\nimport static org.mockito.Mockito.contains;\nimport static org.mockito.Mockito.eq;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.spy;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\n\nimport java.util.List;\nimport java.util.function.BiConsumer;\n\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.contrib.java.lang.system.RestoreSystemProperties;\nimport org.junit.rules.TestRule;\nimport org.mockito.Mockito;\nimport org.slf4j.event.Level;\n\nimport net.sourceforge.pmd.PMDConfiguration;\nimport net.sourceforge.pmd.Report;\nimport net.sourceforge.pmd.Report.GlobalReportBuilderListener;\nimport net.sourceforge.pmd.Report.ProcessingError;\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RuleContext;\nimport net.sourceforge.pmd.RuleSet;\nimport net.sourceforge.pmd.RuleSets;\nimport net.sourceforge.pmd.internal.SystemProps;\nimport net.sourceforge.pmd.internal.util.ContextedAssertionError;\nimport net.sourceforge.pmd.lang.DummyLanguageModule;\nimport net.sourceforge.pmd.lang.DummyLanguageModule.Handler;\nimport net.sourceforge.pmd.lang.Language;\nimport net.sourceforge.pmd.lang.LanguageRegistry;\nimport net.sourceforge.pmd.lang.LanguageVersion;\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.ast.Parser;\nimport net.sourceforge.pmd.lang.ast.RootNode;\nimport net.sourceforge.pmd.lang.rule.AbstractRule;\nimport net.sourceforge.pmd.processor.MonoThreadProcessor.MonothreadRunnable;\nimport net.sourceforge.pmd.util.datasource.DataSource;\nimport net.sourceforge.pmd.util.log.MessageReporter;\n\npublic class PmdRunnableTest {\n\n    public static final String TEST_MESSAGE_SEMANTIC_ERROR = \"An error occurred!\";\n    private static final String PARSER_REPORTS_SEMANTIC_ERROR = \"1.9-semantic_error\";\n    private static final String THROWS_SEMANTIC_ERROR = \"1.9-throws_semantic_error\";\n    private static final String THROWS_ASSERTION_ERROR = \"1.9-throws\";\n\n\n    @org.junit.Rule\n    public TestRule restoreSystemProperties = new RestoreSystemProperties();\n\n\n    private final DummyLanguageModule dummyLang = DummyLanguageModule.getInstance();\n\n    private PMDConfiguration configuration;\n    private PmdRunnable pmdRunnable;\n    private GlobalReportBuilderListener reportBuilder;\n    private MessageReporter reporter;\n    private Rule rule;\n\n    @Before\n    public void prepare() {\n        DataSource dataSource = DataSource.forString(\"test\", \"test.dummy\");\n\n\n        rule = spy(new RuleThatThrows());\n        configuration = new PMDConfiguration();\n        reportBuilder = new GlobalReportBuilderListener();\n        reporter = mock(MessageReporter.class);\n        configuration.setReporter(reporter);\n        pmdRunnable = new MonothreadRunnable(new RuleSets(RuleSet.forSingleRule(rule)),\n                                             dataSource,\n                                             reportBuilder,\n                                             configuration);\n\n    }\n\n    @Test\n    public void inErrorRecoveryModeErrorsShouldBeLoggedByParser() {\n        System.setProperty(SystemProps.PMD_ERROR_RECOVERY, \"\");\n        configuration.setDefaultLanguageVersion(versionWithParserThatThrowsAssertionError());\n\n        pmdRunnable.run();\n        reportBuilder.close();\n        Assert.assertEquals(1, reportBuilder.getResult().getProcessingErrors().size());\n    }\n\n    @Test\n    public void inErrorRecoveryModeErrorsShouldBeLoggedByRule() {\n        System.setProperty(SystemProps.PMD_ERROR_RECOVERY, \"\");\n        configuration.setDefaultLanguageVersion(dummyLang.getDefaultVersion());\n\n        pmdRunnable.run();\n        reportBuilder.close();\n        Report report = reportBuilder.getResult();\n        List<ProcessingError> errors = report.getProcessingErrors();\n        assertThat(errors, hasSize(1));\n        assertThat(errors.get(0).getError(), instanceOf(ContextedAssertionError.class));\n    }\n\n    @Test\n    public void withoutErrorRecoveryModeProcessingShouldBeAbortedByParser() {\n        Assert.assertNull(System.getProperty(SystemProps.PMD_ERROR_RECOVERY));\n        configuration.setDefaultLanguageVersion(versionWithParserThatThrowsAssertionError());\n\n        Assert.assertThrows(AssertionError.class, pmdRunnable::run);\n    }\n\n    @Test\n    public void withoutErrorRecoveryModeProcessingShouldBeAbortedByRule() {\n        Assert.assertNull(System.getProperty(SystemProps.PMD_ERROR_RECOVERY));\n        configuration.setDefaultLanguageVersion(dummyLang.getDefaultVersion());\n\n        Assert.assertThrows(AssertionError.class, pmdRunnable::run);\n    }\n\n\n    @Test\n    public void semanticErrorShouldAbortTheRun() {\n        configuration.setDefaultLanguageVersion(versionWithParserThatReportsSemanticError());\n\n        pmdRunnable.run();\n\n        verify(reporter).log(eq(Level.INFO), contains(\"skipping rule analysis\"));\n        verify(rule, never()).apply(Mockito.any(), Mockito.any());\n    }\n\n    @Test\n    public void semanticErrorThrownShouldAbortTheRun() {\n        configuration.setDefaultLanguageVersion(getVersionWithParserThatThrowsSemanticError());\n\n        pmdRunnable.run();\n\n        verify(reporter, times(1)).log(eq(Level.ERROR), contains(TEST_MESSAGE_SEMANTIC_ERROR));\n        verify(rule, never()).apply(Mockito.any(), Mockito.any());\n    }\n\n    public static void registerCustomVersions(BiConsumer<String, Handler> addVersion) {\n        addVersion.accept(THROWS_ASSERTION_ERROR, new HandlerWithParserThatThrows());\n        addVersion.accept(PARSER_REPORTS_SEMANTIC_ERROR, new HandlerWithParserThatReportsSemanticError());\n        addVersion.accept(THROWS_SEMANTIC_ERROR, new HandlerWithParserThatThrowsSemanticError());\n\n    }\n\n    public LanguageVersion versionWithParserThatThrowsAssertionError() {\n        return dummyLang.getVersion(THROWS_ASSERTION_ERROR);\n    }\n\n    public LanguageVersion getVersionWithParserThatThrowsSemanticError() {\n        return dummyLang.getVersion(THROWS_SEMANTIC_ERROR);\n    }\n\n    public LanguageVersion versionWithParserThatReportsSemanticError() {\n        return dummyLang.getVersion(PARSER_REPORTS_SEMANTIC_ERROR);\n    }\n\n    private static class RuleThatThrows extends AbstractRule {\n\n        RuleThatThrows() {\n            Language dummyLanguage = LanguageRegistry.findLanguageByTerseName(DummyLanguageModule.TERSE_NAME);\n            setLanguage(dummyLanguage);\n        }\n\n        @Override\n        public void apply(Node target, RuleContext ctx) {\n            throw new AssertionError(\"test\");\n        }\n    }\n\n    public static class HandlerWithParserThatThrowsSemanticError extends Handler {\n\n        @Override\n        public Parser getParser() {\n            return task -> {\n                RootNode root = super.getParser().parse(task);\n                throw task.getReporter().error(root, TEST_MESSAGE_SEMANTIC_ERROR);\n            };\n        }\n    }\n\n    public static class HandlerWithParserThatThrows extends Handler {\n\n        @Override\n        public Parser getParser() {\n            return task -> {\n                throw new AssertionError(\"test error while parsing\");\n            };\n        }\n    }\n\n    public static class HandlerWithParserThatReportsSemanticError extends Handler {\n\n        @Override\n        public Parser getParser() {\n            return task -> {\n                RootNode root = super.getParser().parse(task);\n                task.getReporter().error(root, TEST_MESSAGE_SEMANTIC_ERROR);\n                return root;\n            };\n        }\n    }\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "public LanguageVersion versionWithParserThatReportsSemanticError() {\n        return dummyLang.getVersion(PARSER_REPORTS_SEMANTIC_ERROR);\n    }",
        "diffSourceCode": "-   54:     public LanguageVersion getVersionWithParserThatReportsSemanticError() {\n-   55:         return getVersion(PARSER_REPORTS_SEMANTIC_ERROR);\n-   56:     }\n-  164:                 int ecol = positioner.columnFromOffset(eline, i);\n-  165:                 top.setCoords(top.getBeginLine(), top.getBeginColumn(), eline, ecol);\n-  166: \n+   54:     public static final String TEST_MESSAGE_SEMANTIC_ERROR = \"An error occurred!\";\n+   55:     private static final String PARSER_REPORTS_SEMANTIC_ERROR = \"1.9-semantic_error\";\n+   56:     private static final String THROWS_SEMANTIC_ERROR = \"1.9-throws_semantic_error\";\n+  164:     public LanguageVersion versionWithParserThatReportsSemanticError() {\n+  165:         return dummyLang.getVersion(PARSER_REPORTS_SEMANTIC_ERROR);\n+  166:     }\n",
        "uniqueId": "ff2f5ef93c1b3150583e9611b2a8fd8159e3aa66_54_56__164_166",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Inline Method",
        "description": "Inline Method\tpackage isMethodName(m MethodCallExpression, methodName String) : boolean inlined to public isMethodName(m ASTMethodCallExpression, methodName String) : boolean in class net.sourceforge.pmd.lang.apex.rule.internal.Helper",
        "diffLocations": [
            {
                "filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/internal/Helper.java",
                "startLine": 104,
                "endLine": 106,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/internal/Helper.java",
                "startLine": 95,
                "endLine": 97,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/internal/Helper.java",
                "startLine": 108,
                "endLine": 110,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "static boolean isMethodName(final MethodCallExpression m, final String methodName) {\n        return m.getMethodName().equalsIgnoreCase(methodName);\n    }",
        "filePathBefore": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/internal/Helper.java",
        "isPureRefactoring": true,
        "commitId": "56ab75bfd175e0fa1bd5311e581475def4989c25",
        "packageNameBefore": "net.sourceforge.pmd.lang.apex.rule.internal",
        "classNameBefore": "net.sourceforge.pmd.lang.apex.rule.internal.Helper",
        "methodNameBefore": "net.sourceforge.pmd.lang.apex.rule.internal.Helper#isMethodName",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.apex.ast.ASTMethodCallExpression#getMethodName\n methodBody: public String getMethodName() {\nreturn node.getMethodName();\n}",
        "classSignatureBefore": "public final class Helper ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.apex.rule.internal.Helper#isMethodName"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.apex.rule.internal.Helper"
        ],
        "classSignatureBeforeSet": [
            "public final class Helper "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex.rule.internal;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.stream.Collectors;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlDeleteStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlInsertStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlMergeStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlUndeleteStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlUpdateStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlUpsertStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTField;\nimport net.sourceforge.pmd.lang.apex.ast.ASTFieldDeclaration;\nimport net.sourceforge.pmd.lang.apex.ast.ASTMethodCallExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTModifierNode;\nimport net.sourceforge.pmd.lang.apex.ast.ASTNewKeyValueObjectExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTParameter;\nimport net.sourceforge.pmd.lang.apex.ast.ASTReferenceExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTSoqlExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTSoslExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTUserClass;\nimport net.sourceforge.pmd.lang.apex.ast.ASTVariableDeclaration;\nimport net.sourceforge.pmd.lang.apex.ast.ASTVariableExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ApexNode;\n\nimport apex.jorje.data.Identifier;\nimport apex.jorje.data.ast.TypeRef;\nimport apex.jorje.semantic.ast.expression.MethodCallExpression;\nimport apex.jorje.semantic.ast.expression.VariableExpression;\nimport apex.jorje.semantic.ast.member.Field;\nimport apex.jorje.semantic.ast.member.Parameter;\nimport apex.jorje.semantic.ast.statement.VariableDeclaration;\n\n/**\n * Helper methods\n *\n * @author sergey.gorbaty\n *\n */\n@InternalApi\npublic final class Helper {\n    public static final String ANY_METHOD = \"*\";\n\n    private Helper() {\n        throw new AssertionError(\"Can't instantiate helper classes\");\n    }\n\n    public static boolean isTestMethodOrClass(final ApexNode<?> node) {\n        final List<ASTModifierNode> modifierNode = node.findChildrenOfType(ASTModifierNode.class);\n        for (final ASTModifierNode m : modifierNode) {\n            if (m.isTest()) {\n                return true;\n            }\n        }\n\n        final String className = node.getNode().getDefiningType().getApexName();\n        return className.endsWith(\"Test\");\n    }\n\n    public static boolean foundAnySOQLorSOSL(final ApexNode<?> node) {\n        final List<ASTSoqlExpression> dmlSoqlExpression = node.findDescendantsOfType(ASTSoqlExpression.class);\n        final List<ASTSoslExpression> dmlSoslExpression = node.findDescendantsOfType(ASTSoslExpression.class);\n\n        return !dmlSoqlExpression.isEmpty() || !dmlSoslExpression.isEmpty();\n    }\n\n    /**\n     * Finds DML operations in a given node descendants' path\n     *\n     * @param node\n     *\n     * @return true if found DML operations in node descendants\n     */\n    public static boolean foundAnyDML(final ApexNode<?> node) {\n\n        final List<ASTDmlUpsertStatement> dmlUpsertStatement = node.findDescendantsOfType(ASTDmlUpsertStatement.class);\n        final List<ASTDmlUpdateStatement> dmlUpdateStatement = node.findDescendantsOfType(ASTDmlUpdateStatement.class);\n        final List<ASTDmlUndeleteStatement> dmlUndeleteStatement = node\n                .findDescendantsOfType(ASTDmlUndeleteStatement.class);\n        final List<ASTDmlMergeStatement> dmlMergeStatement = node.findDescendantsOfType(ASTDmlMergeStatement.class);\n        final List<ASTDmlInsertStatement> dmlInsertStatement = node.findDescendantsOfType(ASTDmlInsertStatement.class);\n        final List<ASTDmlDeleteStatement> dmlDeleteStatement = node.findDescendantsOfType(ASTDmlDeleteStatement.class);\n\n        return !dmlUpsertStatement.isEmpty() || !dmlUpdateStatement.isEmpty() || !dmlUndeleteStatement.isEmpty()\n                || !dmlMergeStatement.isEmpty() || !dmlInsertStatement.isEmpty() || !dmlDeleteStatement.isEmpty();\n    }\n\n    public static boolean isMethodName(final ASTMethodCallExpression methodNode, final String className,\n            final String methodName) {\n        final ASTReferenceExpression reference = methodNode.getFirstChildOfType(ASTReferenceExpression.class);\n\n        return reference != null && reference.getNode().getNames().size() == 1\n                && reference.getNode().getNames().get(0).getValue().equalsIgnoreCase(className)\n                && (methodName.equals(ANY_METHOD) || isMethodName(methodNode, methodName));\n    }\n\n    public static boolean isMethodName(final ASTMethodCallExpression m, final String methodName) {\n        return isMethodName(m.getNode(), methodName);\n    }\n\n    static boolean isMethodName(final MethodCallExpression m, final String methodName) {\n        return m.getMethodName().equalsIgnoreCase(methodName);\n    }\n\n    public static boolean isMethodCallChain(final ASTMethodCallExpression methodNode, final String... methodNames) {\n        String methodName = methodNames[methodNames.length - 1];\n        if (Helper.isMethodName(methodNode, methodName)) {\n            final ASTReferenceExpression reference = methodNode.getFirstChildOfType(ASTReferenceExpression.class);\n            if (reference != null) {\n                final ASTMethodCallExpression nestedMethod = reference\n                        .getFirstChildOfType(ASTMethodCallExpression.class);\n                if (nestedMethod != null) {\n                    String[] newMethodNames = Arrays.copyOf(methodNames, methodNames.length - 1);\n                    return isMethodCallChain(nestedMethod, newMethodNames);\n                } else {\n                    String[] newClassName = Arrays.copyOf(methodNames, methodNames.length - 1);\n                    if (newClassName.length == 1) {\n                        return Helper.isMethodName(methodNode, newClassName[0], methodName);\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public static String getFQVariableName(final ASTVariableExpression variable) {\n        final ASTReferenceExpression ref = variable.getFirstChildOfType(ASTReferenceExpression.class);\n        String objectName = \"\";\n        if (ref != null && ref.getNode().getNames().size() == 1) {\n            objectName = ref.getNode().getNames().get(0).getValue() + \".\";\n        }\n\n        VariableExpression n = variable.getNode();\n        StringBuilder sb = new StringBuilder().append(n.getDefiningType().getApexName()).append(\":\").append(objectName)\n                .append(n.getIdentifier().getValue());\n        return sb.toString();\n    }\n\n    public static String getFQVariableName(final ASTVariableDeclaration variable) {\n        VariableDeclaration n = variable.getNode();\n        StringBuilder sb = new StringBuilder().append(n.getDefiningType().getApexName()).append(\":\")\n                .append(n.getLocalInfo().getName());\n        return sb.toString();\n    }\n\n    public static String getFQVariableName(final ASTField variable) {\n        Field n = variable.getNode();\n        StringBuilder sb = new StringBuilder()\n                .append(n.getDefiningType().getApexName()).append(\":\")\n                .append(n.getFieldInfo().getName());\n        return sb.toString();\n    }\n\n    static String getVariableType(final ASTField variable) {\n        Field n = variable.getNode();\n        StringBuilder sb = new StringBuilder().append(n.getDefiningType().getApexName()).append(\":\")\n                .append(n.getFieldInfo().getName());\n        return sb.toString();\n    }\n\n    public static String getFQVariableName(final ASTFieldDeclaration variable) {\n        StringBuilder sb = new StringBuilder()\n                .append(variable.getNode().getDefiningType().getApexName()).append(\":\")\n                .append(variable.getImage());\n        return sb.toString();\n    }\n\n    public static String getFQVariableName(final ASTNewKeyValueObjectExpression variable) {\n        StringBuilder sb = new StringBuilder()\n                .append(variable.getNode().getDefiningType().getApexName()).append(\":\")\n                .append(variable.getType());\n        return sb.toString();\n    }\n\n    public static boolean isSystemLevelClass(ASTUserClass node) {\n        List<TypeRef> interfaces = node.getNode().getDefiningType().getCodeUnitDetails().getInterfaceTypeRefs();\n\n        for (TypeRef intObject : interfaces) {\n            if (isWhitelisted(intObject.getNames())) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private static boolean isWhitelisted(List<Identifier> ids) {\n        String identifier = ids.stream().map(Identifier::getValue).collect(Collectors.joining(\".\"));\n\n        switch (identifier.toLowerCase(Locale.ROOT)) {\n        case \"queueable\":\n        case \"database.batchable\":\n        case \"installhandler\":\n            return true;\n        default:\n            break;\n        }\n        return false;\n    }\n\n    public static String getFQVariableName(Parameter p) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(p.getDefiningType()).append(\":\").append(p.getName().getValue());\n        return sb.toString();\n    }\n\n    public static String getFQVariableName(ASTParameter p) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(p.getNode().getDefiningType()).append(\":\").append(p.getImage());\n        return sb.toString();\n    }\n\n}\n",
        "filePathAfter": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/internal/Helper.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex.rule.internal;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlDeleteStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlInsertStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlMergeStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlUndeleteStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlUpdateStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTDmlUpsertStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTField;\nimport net.sourceforge.pmd.lang.apex.ast.ASTFieldDeclaration;\nimport net.sourceforge.pmd.lang.apex.ast.ASTMethodCallExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTModifierNode;\nimport net.sourceforge.pmd.lang.apex.ast.ASTNewKeyValueObjectExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTParameter;\nimport net.sourceforge.pmd.lang.apex.ast.ASTReferenceExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTSoqlExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTSoslExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTUserClass;\nimport net.sourceforge.pmd.lang.apex.ast.ASTVariableDeclaration;\nimport net.sourceforge.pmd.lang.apex.ast.ASTVariableExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ApexNode;\n\n/**\n * Helper methods\n *\n * @author sergey.gorbaty\n *\n */\n@InternalApi\npublic final class Helper {\n    public static final String ANY_METHOD = \"*\";\n\n    private Helper() {\n        throw new AssertionError(\"Can't instantiate helper classes\");\n    }\n\n    public static boolean isTestMethodOrClass(final ApexNode<?> node) {\n        final List<ASTModifierNode> modifierNode = node.findChildrenOfType(ASTModifierNode.class);\n        for (final ASTModifierNode m : modifierNode) {\n            if (m.isTest()) {\n                return true;\n            }\n        }\n\n        final String className = node.getDefiningType();\n        return className.endsWith(\"Test\");\n    }\n\n    public static boolean foundAnySOQLorSOSL(final ApexNode<?> node) {\n        final List<ASTSoqlExpression> dmlSoqlExpression = node.findDescendantsOfType(ASTSoqlExpression.class);\n        final List<ASTSoslExpression> dmlSoslExpression = node.findDescendantsOfType(ASTSoslExpression.class);\n\n        return !dmlSoqlExpression.isEmpty() || !dmlSoslExpression.isEmpty();\n    }\n\n    /**\n     * Finds DML operations in a given node descendants' path\n     *\n     * @param node\n     *\n     * @return true if found DML operations in node descendants\n     */\n    public static boolean foundAnyDML(final ApexNode<?> node) {\n\n        final List<ASTDmlUpsertStatement> dmlUpsertStatement = node.findDescendantsOfType(ASTDmlUpsertStatement.class);\n        final List<ASTDmlUpdateStatement> dmlUpdateStatement = node.findDescendantsOfType(ASTDmlUpdateStatement.class);\n        final List<ASTDmlUndeleteStatement> dmlUndeleteStatement = node\n                .findDescendantsOfType(ASTDmlUndeleteStatement.class);\n        final List<ASTDmlMergeStatement> dmlMergeStatement = node.findDescendantsOfType(ASTDmlMergeStatement.class);\n        final List<ASTDmlInsertStatement> dmlInsertStatement = node.findDescendantsOfType(ASTDmlInsertStatement.class);\n        final List<ASTDmlDeleteStatement> dmlDeleteStatement = node.findDescendantsOfType(ASTDmlDeleteStatement.class);\n\n        return !dmlUpsertStatement.isEmpty() || !dmlUpdateStatement.isEmpty() || !dmlUndeleteStatement.isEmpty()\n                || !dmlMergeStatement.isEmpty() || !dmlInsertStatement.isEmpty() || !dmlDeleteStatement.isEmpty();\n    }\n\n    public static boolean isMethodName(final ASTMethodCallExpression methodNode, final String className,\n            final String methodName) {\n        final ASTReferenceExpression reference = methodNode.getFirstChildOfType(ASTReferenceExpression.class);\n\n        return reference != null && reference.getNames().size() == 1\n                && reference.getNames().get(0).equalsIgnoreCase(className)\n                && (methodName.equals(ANY_METHOD) || isMethodName(methodNode, methodName));\n    }\n\n    public static boolean isMethodName(final ASTMethodCallExpression m, final String methodName) {\n        return m.getMethodName().equalsIgnoreCase(methodName);\n    }\n\n    public static boolean isMethodCallChain(final ASTMethodCallExpression methodNode, final String... methodNames) {\n        String methodName = methodNames[methodNames.length - 1];\n        if (Helper.isMethodName(methodNode, methodName)) {\n            final ASTReferenceExpression reference = methodNode.getFirstChildOfType(ASTReferenceExpression.class);\n            if (reference != null) {\n                final ASTMethodCallExpression nestedMethod = reference\n                        .getFirstChildOfType(ASTMethodCallExpression.class);\n                if (nestedMethod != null) {\n                    String[] newMethodNames = Arrays.copyOf(methodNames, methodNames.length - 1);\n                    return isMethodCallChain(nestedMethod, newMethodNames);\n                } else {\n                    String[] newClassName = Arrays.copyOf(methodNames, methodNames.length - 1);\n                    if (newClassName.length == 1) {\n                        return Helper.isMethodName(methodNode, newClassName[0], methodName);\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public static String getFQVariableName(final ASTVariableExpression variable) {\n        final ASTReferenceExpression ref = variable.getFirstChildOfType(ASTReferenceExpression.class);\n        String objectName = \"\";\n        if (ref != null && ref.getNames().size() == 1) {\n            objectName = ref.getNames().get(0) + \".\";\n        }\n\n        StringBuilder sb = new StringBuilder().append(variable.getDefiningType()).append(\":\").append(objectName)\n                .append(variable.getImage());\n        return sb.toString();\n    }\n\n    public static String getFQVariableName(final ASTVariableDeclaration variable) {\n        StringBuilder sb = new StringBuilder().append(variable.getDefiningType()).append(\":\")\n                .append(variable.getImage());\n        return sb.toString();\n    }\n\n    public static String getFQVariableName(final ASTField variable) {\n        StringBuilder sb = new StringBuilder()\n                .append(variable.getDefiningType()).append(\":\")\n                .append(variable.getName());\n        return sb.toString();\n    }\n\n    static String getVariableType(final ASTField variable) {\n        StringBuilder sb = new StringBuilder().append(variable.getDefiningType()).append(\":\")\n                .append(variable.getName());\n        return sb.toString();\n    }\n\n    public static String getFQVariableName(final ASTFieldDeclaration variable) {\n        StringBuilder sb = new StringBuilder()\n                .append(variable.getDefiningType()).append(\":\")\n                .append(variable.getImage());\n        return sb.toString();\n    }\n\n    public static String getFQVariableName(final ASTNewKeyValueObjectExpression variable) {\n        StringBuilder sb = new StringBuilder()\n                .append(variable.getDefiningType()).append(\":\")\n                .append(variable.getType());\n        return sb.toString();\n    }\n\n    public static boolean isSystemLevelClass(ASTUserClass node) {\n        List<String> interfaces = node.getInterfaceNames();\n        return interfaces.stream().anyMatch(Helper::isWhitelisted);\n    }\n\n    private static boolean isWhitelisted(String identifier) {\n        switch (identifier.toLowerCase(Locale.ROOT)) {\n        case \"queueable\":\n        case \"database.batchable\":\n        case \"installhandler\":\n            return true;\n        default:\n            break;\n        }\n        return false;\n    }\n\n    public static String getFQVariableName(ASTParameter p) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(p.getDefiningType()).append(\":\").append(p.getImage());\n        return sb.toString();\n    }\n\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.apex.ast.ASTMethodCallExpression#getMethodName\n methodBody: public String getMethodName() {\nreturn node.getMethodName();\n}"
        ],
        "sourceCodeAfterRefactoring": "public static boolean isMethodName(final ASTMethodCallExpression m, final String methodName) {\n        return m.getMethodName().equalsIgnoreCase(methodName);\n    }",
        "diffSourceCode": "-   95:     public static boolean isMethodName(final ASTMethodCallExpression methodNode, final String className,\n-   96:             final String methodName) {\n-   97:         final ASTReferenceExpression reference = methodNode.getFirstChildOfType(ASTReferenceExpression.class);\n-  104:     public static boolean isMethodName(final ASTMethodCallExpression m, final String methodName) {\n-  105:         return isMethodName(m.getNode(), methodName);\n-  106:     }\n-  108:     static boolean isMethodName(final MethodCallExpression m, final String methodName) {\n-  109:         return m.getMethodName().equalsIgnoreCase(methodName);\n-  110:     }\n+   95:     public static boolean isMethodName(final ASTMethodCallExpression m, final String methodName) {\n+   96:         return m.getMethodName().equalsIgnoreCase(methodName);\n+   97:     }\n+  104:                 final ASTMethodCallExpression nestedMethod = reference\n+  105:                         .getFirstChildOfType(ASTMethodCallExpression.class);\n+  106:                 if (nestedMethod != null) {\n+  108:                     return isMethodCallChain(nestedMethod, newMethodNames);\n+  109:                 } else {\n+  110:                     String[] newClassName = Arrays.copyOf(methodNames, methodNames.length - 1);\n",
        "uniqueId": "56ab75bfd175e0fa1bd5311e581475def4989c25_104_106__95_97_108_110",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 5
            },
            "LINE": {
                "missed": 0,
                "covered": 1
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprotected filter(axisIterator AxisIterator, nodeTest NodeTest) : AxisIterator extracted from public iterateAxis(axisNumber byte, nodeTest NodeTest) : AxisIterator in class net.sourceforge.pmd.lang.ast.xpath.saxon.AbstractNodeInfo",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/xpath/saxon/AbstractNodeInfo.java",
                "startLine": 254,
                "endLine": 268,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/xpath/saxon/AbstractNodeInfo.java",
                "startLine": 254,
                "endLine": 264,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/xpath/saxon/AbstractNodeInfo.java",
                "startLine": 266,
                "endLine": 268,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * This implementation calls {@link #iterateAxis(byte)} to get an\n     * {@link AxisIterator} which is then optionally filtered using\n     * {@link AxisFilter}.\n     *\n     * {@inheritDoc}\n     */\n    @Override\n    public AxisIterator iterateAxis(byte axisNumber, NodeTest nodeTest) {\n        AxisIterator axisIterator = iterateAxis(axisNumber);\n        if (nodeTest != null) {\n            axisIterator = new AxisFilter(axisIterator, nodeTest);\n        }\n        return axisIterator;\n    }",
        "filePathBefore": "pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/xpath/saxon/AbstractNodeInfo.java",
        "isPureRefactoring": true,
        "commitId": "dde5b29da8f62bc4b2047bd1c4e5b582289441cc",
        "packageNameBefore": "net.sourceforge.pmd.lang.ast.xpath.saxon",
        "classNameBefore": "net.sourceforge.pmd.lang.ast.xpath.saxon.AbstractNodeInfo",
        "methodNameBefore": "net.sourceforge.pmd.lang.ast.xpath.saxon.AbstractNodeInfo#iterateAxis",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.ast.xpath.saxon.ElementNode#iterateAxis\n methodBody: public AxisIterator iterateAxis(byte axisNumber) {\nswitch(axisNumber)case Axis.ANCESTOR:return new Navigator.AncestorEnumeration(this,false);\ncase Axis.ANCESTOR_OR_SELF:return new Navigator.AncestorEnumeration(this,true);\ncase Axis.ATTRIBUTE:return new AttributeAxisIterator(this);\ncase Axis.CHILD:if(children == null){return EmptyIterator.getInstance();\n}{return new NodeArrayIterator(children);\n}case Axis.DESCENDANT:return new Navigator.DescendantEnumeration(this,false,true);\ncase Axis.DESCENDANT_OR_SELF:return new Navigator.DescendantEnumeration(this,true,true);\ncase Axis.FOLLOWING:return new Navigator.FollowingEnumeration(this);\ncase Axis.FOLLOWING_SIBLING:if(parent == null || siblingPosition == parent.children.length - 1){return EmptyIterator.getInstance();\n}{return new NodeArrayIterator(parent.children,siblingPosition + 1,parent.children.length);\n}case Axis.NAMESPACE:return super.iterateAxis(axisNumber);\ncase Axis.PARENT:return SingleNodeIterator.makeIterator(parent);\ncase Axis.PRECEDING:return new Navigator.PrecedingEnumeration(this,false);\ncase Axis.PRECEDING_SIBLING:if(parent == null || siblingPosition == 0){return EmptyIterator.getInstance();\n}{return new NodeArrayIterator(parent.children,0,siblingPosition);\n}case Axis.SELF:return SingleNodeIterator.makeIterator(this);\ncase Axis.PRECEDING_OR_ANCESTOR:return new Navigator.PrecedingEnumeration(this,true);\ndefault:return super.iterateAxis(axisNumber);\n}\nmethodSignature: net.sourceforge.pmd.lang.ast.xpath.saxon.AbstractNodeInfo#iterateAxis\n methodBody: public AxisIterator iterateAxis(byte axisNumber, NodeTest nodeTest) {\nAxisIterator axisIterator=iterateAxis(axisNumber);\nif(nodeTest != null){axisIterator=new AxisFilter(axisIterator,nodeTest);\n}return axisIterator;\n}",
        "classSignatureBefore": "public class AbstractNodeInfo implements VirtualNode, SiblingCountingNode ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.ast.xpath.saxon.AbstractNodeInfo#iterateAxis"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.ast.xpath.saxon.AbstractNodeInfo"
        ],
        "classSignatureBeforeSet": [
            "public class AbstractNodeInfo implements VirtualNode, SiblingCountingNode "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics",
                "description": "All the mappings are matched! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.ast.xpath.saxon;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\n\nimport net.sf.saxon.Configuration;\nimport net.sf.saxon.event.Receiver;\nimport net.sf.saxon.om.Axis;\nimport net.sf.saxon.om.AxisIterator;\nimport net.sf.saxon.om.DocumentInfo;\nimport net.sf.saxon.om.FastStringBuffer;\nimport net.sf.saxon.om.NamePool;\nimport net.sf.saxon.om.Navigator.AxisFilter;\nimport net.sf.saxon.om.NodeInfo;\nimport net.sf.saxon.om.SequenceIterator;\nimport net.sf.saxon.om.SiblingCountingNode;\nimport net.sf.saxon.om.VirtualNode;\nimport net.sf.saxon.pattern.NodeTest;\nimport net.sf.saxon.trans.XPathException;\nimport net.sf.saxon.value.Value;\n\n/**\n * This is a basic implementation of the Saxon NodeInfo and related interfaces.\n * Most methods are trivial implementations which immediately throw\n * {@link UnsupportedOperationException}. A few of the methods actually have\n * useful implementations, such as {@link #iterateAxis(byte, NodeTest)} and\n * {@link #isSameNodeInfo(NodeInfo)}.\n */\n@Deprecated\n@InternalApi\npublic class AbstractNodeInfo implements VirtualNode, SiblingCountingNode {\n    @Override\n    public String getSystemId() {\n        throw createUnsupportedOperationException(\"Source.getSystemId()\");\n    }\n\n    @Override\n    public void setSystemId(String systemId) {\n        throw createUnsupportedOperationException(\"Source.setSystemId(String)\");\n    }\n\n    @Override\n    public String getStringValue() {\n        throw createUnsupportedOperationException(\"ValueRepresentation.getStringValue()\");\n    }\n\n    @Override\n    public CharSequence getStringValueCS() {\n        throw createUnsupportedOperationException(\"ValueRepresentation.getStringValueCS()\");\n    }\n\n    @Override\n    public SequenceIterator getTypedValue() throws XPathException {\n        throw createUnsupportedOperationException(\"Item.getTypedValue()\");\n    }\n\n    @Override\n    public Object getUnderlyingNode() {\n        throw createUnsupportedOperationException(\"VirtualNode.getUnderlyingNode()\");\n    }\n\n    @Override\n    public int getSiblingPosition() {\n        throw createUnsupportedOperationException(\"SiblingCountingNode.getSiblingPosition()\");\n    }\n\n    @Override\n    public Value atomize() throws XPathException {\n        throw createUnsupportedOperationException(\"NodeInfo.atomize()\");\n    }\n\n    @Override\n    public int compareOrder(NodeInfo other) {\n        throw createUnsupportedOperationException(\"NodeInfo.compareOrder(NodeInfo)\");\n    }\n\n    @Override\n    public void copy(Receiver receiver, int whichNamespaces, boolean copyAnnotations, int locationId)\n            throws XPathException {\n        throw createUnsupportedOperationException(\"ValueRepresentation.copy(Receiver, int, boolean, int)\");\n    }\n\n    /**\n     * This implementation considers to NodeInfo objects to be equal, if their\n     * underlying nodes are equal.\n     *\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean equals(Object other) {\n        if (this == other) {\n            return true;\n        }\n        if (other instanceof ElementNode) {\n            return this.getUnderlyingNode() == ((ElementNode) other).getUnderlyingNode();\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        if (this.getUnderlyingNode() != null) {\n            return super.hashCode() + 31 * this.getUnderlyingNode().hashCode();\n        } else {\n            return super.hashCode();\n        }\n    }\n\n    @Override\n    public void generateId(FastStringBuffer buffer) {\n        throw createUnsupportedOperationException(\"NodeInfo.generateId(FastStringBuffer)\");\n    }\n\n    @Override\n    public String getAttributeValue(int fingerprint) {\n        throw createUnsupportedOperationException(\"NodeInfo.getAttributeValue(int)\");\n    }\n\n    @Override\n    public String getBaseURI() {\n        throw createUnsupportedOperationException(\"NodeInfo.getBaseURI()\");\n    }\n\n    @Override\n    public int getColumnNumber() {\n        throw createUnsupportedOperationException(\"NodeInfo.getColumnNumber()\");\n    }\n\n    @Override\n    public Configuration getConfiguration() {\n        throw createUnsupportedOperationException(\"NodeInfo.getConfiguration()\");\n    }\n\n    @Override\n    public int[] getDeclaredNamespaces(int[] buffer) {\n        throw createUnsupportedOperationException(\"NodeInfo.getDeclaredNamespaces(int[])\");\n    }\n\n    @Override\n    public String getDisplayName() {\n        throw createUnsupportedOperationException(\"NodeInfo.getDisplayName()\");\n    }\n\n    /**\n     * This implementation always returns 0.\n     *\n     * {@inheritDoc}\n     */\n    @Override\n    public int getDocumentNumber() {\n        return 0;\n    }\n\n    @Override\n    public DocumentInfo getDocumentRoot() {\n        throw createUnsupportedOperationException(\"NodeInfo.getDocumentRoot()\");\n    }\n\n    @Override\n    public int getFingerprint() {\n        throw createUnsupportedOperationException(\"NodeInfo.getFingerprint()\");\n    }\n\n    @Override\n    public int getLineNumber() {\n        throw createUnsupportedOperationException(\"NodeInfo.getLineNumber()\");\n    }\n\n    @Override\n    public String getLocalPart() {\n        throw createUnsupportedOperationException(\"NodeInfo.getLocalPart()\");\n    }\n\n    @Override\n    public int getNameCode() {\n        throw createUnsupportedOperationException(\"NodeInfo.getNameCode()\");\n    }\n\n    @Override\n    public NamePool getNamePool() {\n        throw createUnsupportedOperationException(\"NodeInfo.getNamePool()\");\n    }\n\n    @Override\n    public int getNodeKind() {\n        throw createUnsupportedOperationException(\"NodeInfo.getNodeKind()\");\n    }\n\n    @Override\n    public NodeInfo getParent() {\n        throw createUnsupportedOperationException(\"NodeInfo.getParent()\");\n    }\n\n    @Override\n    public String getPrefix() {\n        throw createUnsupportedOperationException(\"NodeInfo.getPrefix()\");\n    }\n\n    @Override\n    public NodeInfo getRoot() {\n        throw createUnsupportedOperationException(\"NodeInfo.getRoot()\");\n    }\n\n    @Override\n    public int getTypeAnnotation() {\n        throw createUnsupportedOperationException(\"NodeInfo.getTypeAnnotation()\");\n    }\n\n    @Override\n    public String getURI() {\n        throw createUnsupportedOperationException(\"NodeInfo.getURI()\");\n    }\n\n    @Override\n    public boolean hasChildNodes() {\n        throw createUnsupportedOperationException(\"NodeInfo.hasChildNodes()\");\n    }\n\n    @Override\n    public boolean isId() {\n        throw createUnsupportedOperationException(\"NodeInfo.isId()\");\n    }\n\n    @Override\n    public boolean isIdref() {\n        throw createUnsupportedOperationException(\"NodeInfo.isIdref()\");\n    }\n\n    @Override\n    public boolean isNilled() {\n        throw createUnsupportedOperationException(\"NodeInfo.isNilled()\");\n    }\n\n    /**\n     * This implementation delegates to {@link #equals(Object)}, per the Saxon\n     * documentation's description of this method's behavior.\n     *\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isSameNodeInfo(NodeInfo other) {\n        return this.equals(other);\n    }\n\n    @Override\n    public AxisIterator iterateAxis(byte axisNumber) {\n        throw createUnsupportedOperationException(\n                \"NodeInfo.iterateAxis(byte) for axis '\" + Axis.axisName[axisNumber] + \"'\");\n    }\n\n    /**\n     * This implementation calls {@link #iterateAxis(byte)} to get an\n     * {@link AxisIterator} which is then optionally filtered using\n     * {@link AxisFilter}.\n     *\n     * {@inheritDoc}\n     */\n    @Override\n    public AxisIterator iterateAxis(byte axisNumber, NodeTest nodeTest) {\n        AxisIterator axisIterator = iterateAxis(axisNumber);\n        if (nodeTest != null) {\n            axisIterator = new AxisFilter(axisIterator, nodeTest);\n        }\n        return axisIterator;\n    }\n\n    /**\n     * Used to create a customized instance of UnsupportedOperationException.\n     * The caller of this method is intended to <code>throw</code> the\n     * exception.\n     *\n     * @param name\n     *            Method name that is not supported.\n     * @return A UnsupportedOperationException indicated the method is not\n     *         supported by the implementation class.\n     */\n    protected UnsupportedOperationException createUnsupportedOperationException(String name) {\n        return new UnsupportedOperationException(name + \" is not implemented by \" + this.getClass().getName());\n    }\n}\n",
        "filePathAfter": "pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/xpath/saxon/AbstractNodeInfo.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.ast.xpath.saxon;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\n\nimport net.sf.saxon.Configuration;\nimport net.sf.saxon.event.Receiver;\nimport net.sf.saxon.om.Axis;\nimport net.sf.saxon.om.AxisIterator;\nimport net.sf.saxon.om.DocumentInfo;\nimport net.sf.saxon.om.FastStringBuffer;\nimport net.sf.saxon.om.NamePool;\nimport net.sf.saxon.om.Navigator.AxisFilter;\nimport net.sf.saxon.om.NodeInfo;\nimport net.sf.saxon.om.SequenceIterator;\nimport net.sf.saxon.om.SiblingCountingNode;\nimport net.sf.saxon.om.VirtualNode;\nimport net.sf.saxon.pattern.NodeTest;\nimport net.sf.saxon.trans.XPathException;\nimport net.sf.saxon.value.Value;\n\n/**\n * This is a basic implementation of the Saxon NodeInfo and related interfaces.\n * Most methods are trivial implementations which immediately throw\n * {@link UnsupportedOperationException}. A few of the methods actually have\n * useful implementations, such as {@link #iterateAxis(byte, NodeTest)} and\n * {@link #isSameNodeInfo(NodeInfo)}.\n */\n@Deprecated\n@InternalApi\npublic class AbstractNodeInfo implements VirtualNode, SiblingCountingNode {\n    @Override\n    public String getSystemId() {\n        throw createUnsupportedOperationException(\"Source.getSystemId()\");\n    }\n\n    @Override\n    public void setSystemId(String systemId) {\n        throw createUnsupportedOperationException(\"Source.setSystemId(String)\");\n    }\n\n    @Override\n    public String getStringValue() {\n        throw createUnsupportedOperationException(\"ValueRepresentation.getStringValue()\");\n    }\n\n    @Override\n    public CharSequence getStringValueCS() {\n        throw createUnsupportedOperationException(\"ValueRepresentation.getStringValueCS()\");\n    }\n\n    @Override\n    public SequenceIterator getTypedValue() throws XPathException {\n        throw createUnsupportedOperationException(\"Item.getTypedValue()\");\n    }\n\n    @Override\n    public Object getUnderlyingNode() {\n        throw createUnsupportedOperationException(\"VirtualNode.getUnderlyingNode()\");\n    }\n\n    @Override\n    public int getSiblingPosition() {\n        throw createUnsupportedOperationException(\"SiblingCountingNode.getSiblingPosition()\");\n    }\n\n    @Override\n    public Value atomize() throws XPathException {\n        throw createUnsupportedOperationException(\"NodeInfo.atomize()\");\n    }\n\n    @Override\n    public int compareOrder(NodeInfo other) {\n        throw createUnsupportedOperationException(\"NodeInfo.compareOrder(NodeInfo)\");\n    }\n\n    @Override\n    public void copy(Receiver receiver, int whichNamespaces, boolean copyAnnotations, int locationId)\n            throws XPathException {\n        throw createUnsupportedOperationException(\"ValueRepresentation.copy(Receiver, int, boolean, int)\");\n    }\n\n    /**\n     * This implementation considers to NodeInfo objects to be equal, if their\n     * underlying nodes are equal.\n     *\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean equals(Object other) {\n        if (this == other) {\n            return true;\n        }\n        if (other instanceof ElementNode) {\n            return this.getUnderlyingNode() == ((ElementNode) other).getUnderlyingNode();\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        if (this.getUnderlyingNode() != null) {\n            return super.hashCode() + 31 * this.getUnderlyingNode().hashCode();\n        } else {\n            return super.hashCode();\n        }\n    }\n\n    @Override\n    public void generateId(FastStringBuffer buffer) {\n        throw createUnsupportedOperationException(\"NodeInfo.generateId(FastStringBuffer)\");\n    }\n\n    @Override\n    public String getAttributeValue(int fingerprint) {\n        throw createUnsupportedOperationException(\"NodeInfo.getAttributeValue(int)\");\n    }\n\n    @Override\n    public String getBaseURI() {\n        throw createUnsupportedOperationException(\"NodeInfo.getBaseURI()\");\n    }\n\n    @Override\n    public int getColumnNumber() {\n        throw createUnsupportedOperationException(\"NodeInfo.getColumnNumber()\");\n    }\n\n    @Override\n    public Configuration getConfiguration() {\n        throw createUnsupportedOperationException(\"NodeInfo.getConfiguration()\");\n    }\n\n    @Override\n    public int[] getDeclaredNamespaces(int[] buffer) {\n        throw createUnsupportedOperationException(\"NodeInfo.getDeclaredNamespaces(int[])\");\n    }\n\n    @Override\n    public String getDisplayName() {\n        throw createUnsupportedOperationException(\"NodeInfo.getDisplayName()\");\n    }\n\n    /**\n     * This implementation always returns 0.\n     *\n     * {@inheritDoc}\n     */\n    @Override\n    public int getDocumentNumber() {\n        return 0;\n    }\n\n    @Override\n    public DocumentInfo getDocumentRoot() {\n        throw createUnsupportedOperationException(\"NodeInfo.getDocumentRoot()\");\n    }\n\n    @Override\n    public int getFingerprint() {\n        throw createUnsupportedOperationException(\"NodeInfo.getFingerprint()\");\n    }\n\n    @Override\n    public int getLineNumber() {\n        throw createUnsupportedOperationException(\"NodeInfo.getLineNumber()\");\n    }\n\n    @Override\n    public String getLocalPart() {\n        throw createUnsupportedOperationException(\"NodeInfo.getLocalPart()\");\n    }\n\n    @Override\n    public int getNameCode() {\n        throw createUnsupportedOperationException(\"NodeInfo.getNameCode()\");\n    }\n\n    @Override\n    public NamePool getNamePool() {\n        throw createUnsupportedOperationException(\"NodeInfo.getNamePool()\");\n    }\n\n    @Override\n    public int getNodeKind() {\n        throw createUnsupportedOperationException(\"NodeInfo.getNodeKind()\");\n    }\n\n    @Override\n    public NodeInfo getParent() {\n        throw createUnsupportedOperationException(\"NodeInfo.getParent()\");\n    }\n\n    @Override\n    public String getPrefix() {\n        throw createUnsupportedOperationException(\"NodeInfo.getPrefix()\");\n    }\n\n    @Override\n    public NodeInfo getRoot() {\n        throw createUnsupportedOperationException(\"NodeInfo.getRoot()\");\n    }\n\n    @Override\n    public int getTypeAnnotation() {\n        throw createUnsupportedOperationException(\"NodeInfo.getTypeAnnotation()\");\n    }\n\n    @Override\n    public String getURI() {\n        throw createUnsupportedOperationException(\"NodeInfo.getURI()\");\n    }\n\n    @Override\n    public boolean hasChildNodes() {\n        throw createUnsupportedOperationException(\"NodeInfo.hasChildNodes()\");\n    }\n\n    @Override\n    public boolean isId() {\n        throw createUnsupportedOperationException(\"NodeInfo.isId()\");\n    }\n\n    @Override\n    public boolean isIdref() {\n        throw createUnsupportedOperationException(\"NodeInfo.isIdref()\");\n    }\n\n    @Override\n    public boolean isNilled() {\n        throw createUnsupportedOperationException(\"NodeInfo.isNilled()\");\n    }\n\n    /**\n     * This implementation delegates to {@link #equals(Object)}, per the Saxon\n     * documentation's description of this method's behavior.\n     *\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isSameNodeInfo(NodeInfo other) {\n        return this.equals(other);\n    }\n\n    @Override\n    public AxisIterator iterateAxis(byte axisNumber) {\n        throw createUnsupportedOperationException(\n                \"NodeInfo.iterateAxis(byte) for axis '\" + Axis.axisName[axisNumber] + \"'\");\n    }\n\n    /**\n     * This implementation calls {@link #iterateAxis(byte)} to get an\n     * {@link AxisIterator} which is then optionally filtered using\n     * {@link AxisFilter}.\n     *\n     * {@inheritDoc}\n     */\n    @Override\n    public AxisIterator iterateAxis(byte axisNumber, NodeTest nodeTest) {\n        return filter(iterateAxis(axisNumber), nodeTest);\n    }\n\n    protected static AxisIterator filter(AxisIterator axisIterator, NodeTest nodeTest) {\n        return nodeTest != null ? new AxisFilter(axisIterator, nodeTest) : axisIterator;\n    }\n\n    /**\n     * Used to create a customized instance of UnsupportedOperationException.\n     * The caller of this method is intended to <code>throw</code> the\n     * exception.\n     *\n     * @param name\n     *            Method name that is not supported.\n     * @return A UnsupportedOperationException indicated the method is not\n     *         supported by the implementation class.\n     */\n    protected UnsupportedOperationException createUnsupportedOperationException(String name) {\n        return new UnsupportedOperationException(name + \" is not implemented by \" + this.getClass().getName());\n    }\n}\n",
        "diffSourceCodeSet": [
            "protected static AxisIterator filter(AxisIterator axisIterator, NodeTest nodeTest) {\n        return nodeTest != null ? new AxisFilter(axisIterator, nodeTest) : axisIterator;\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.ast.xpath.saxon.ElementNode#iterateAxis\n methodBody: public AxisIterator iterateAxis(byte axisNumber) {\nswitch(axisNumber)case Axis.ANCESTOR:return new Navigator.AncestorEnumeration(this,false);\ncase Axis.ANCESTOR_OR_SELF:return new Navigator.AncestorEnumeration(this,true);\ncase Axis.ATTRIBUTE:return new AttributeAxisIterator(this);\ncase Axis.CHILD:if(children == null){return EmptyIterator.getInstance();\n}{return new NodeArrayIterator(children);\n}case Axis.DESCENDANT:return new Navigator.DescendantEnumeration(this,false,true);\ncase Axis.DESCENDANT_OR_SELF:return new Navigator.DescendantEnumeration(this,true,true);\ncase Axis.FOLLOWING:return new Navigator.FollowingEnumeration(this);\ncase Axis.FOLLOWING_SIBLING:if(parent == null || siblingPosition == parent.children.length - 1){return EmptyIterator.getInstance();\n}{return new NodeArrayIterator(parent.children,siblingPosition + 1,parent.children.length);\n}case Axis.NAMESPACE:return super.iterateAxis(axisNumber);\ncase Axis.PARENT:return SingleNodeIterator.makeIterator(parent);\ncase Axis.PRECEDING:return new Navigator.PrecedingEnumeration(this,false);\ncase Axis.PRECEDING_SIBLING:if(parent == null || siblingPosition == 0){return EmptyIterator.getInstance();\n}{return new NodeArrayIterator(parent.children,0,siblingPosition);\n}case Axis.SELF:return SingleNodeIterator.makeIterator(this);\ncase Axis.PRECEDING_OR_ANCESTOR:return new Navigator.PrecedingEnumeration(this,true);\ndefault:return super.iterateAxis(axisNumber);\n}",
            "methodSignature: net.sourceforge.pmd.lang.ast.xpath.saxon.AbstractNodeInfo#iterateAxis\n methodBody: public AxisIterator iterateAxis(byte axisNumber, NodeTest nodeTest) {\nAxisIterator axisIterator=iterateAxis(axisNumber);\nif(nodeTest != null){axisIterator=new AxisFilter(axisIterator,nodeTest);\n}return axisIterator;\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * This implementation calls {@link #iterateAxis(byte)} to get an\n     * {@link AxisIterator} which is then optionally filtered using\n     * {@link AxisFilter}.\n     *\n     * {@inheritDoc}\n     */\n    @Override\n    public AxisIterator iterateAxis(byte axisNumber, NodeTest nodeTest) {\n        return filter(iterateAxis(axisNumber), nodeTest);\n    }\nprotected static AxisIterator filter(AxisIterator axisIterator, NodeTest nodeTest) {\n        return nodeTest != null ? new AxisFilter(axisIterator, nodeTest) : axisIterator;\n    }",
        "diffSourceCode": "   254:     /**\n   255:      * This implementation calls {@link #iterateAxis(byte)} to get an\n   256:      * {@link AxisIterator} which is then optionally filtered using\n   257:      * {@link AxisFilter}.\n   258:      *\n   259:      * {@inheritDoc}\n   260:      */\n   261:     @Override\n   262:     public AxisIterator iterateAxis(byte axisNumber, NodeTest nodeTest) {\n-  263:         AxisIterator axisIterator = iterateAxis(axisNumber);\n-  264:         if (nodeTest != null) {\n-  265:             axisIterator = new AxisFilter(axisIterator, nodeTest);\n-  266:         }\n-  267:         return axisIterator;\n+  263:         return filter(iterateAxis(axisNumber), nodeTest);\n+  264:     }\n+  265: \n+  266:     protected static AxisIterator filter(AxisIterator axisIterator, NodeTest nodeTest) {\n+  267:         return nodeTest != null ? new AxisFilter(axisIterator, nodeTest) : axisIterator;\n   268:     }\n",
        "uniqueId": "dde5b29da8f62bc4b2047bd1c4e5b582289441cc_254_268_266_268_254_264",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 14
            },
            "BRANCH": {
                "missed": 1,
                "covered": 1
            },
            "LINE": {
                "missed": 0,
                "covered": 4
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic getRecordComponents() : ASTRecordComponentList extracted from public getComponentList() : ASTRecordComponentList in class net.sourceforge.pmd.lang.java.ast.ASTRecordDeclaration",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTRecordDeclaration.java",
                "startLine": 60,
                "endLine": 62,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTRecordDeclaration.java",
                "startLine": 60,
                "endLine": 66,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTRecordDeclaration.java",
                "startLine": 68,
                "endLine": 73,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public ASTRecordComponentList getComponentList() {\n        return getFirstChildOfType(ASTRecordComponentList.class);\n    }",
        "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTRecordDeclaration.java",
        "isPureRefactoring": true,
        "commitId": "ea532e6d2df36d1bd59c9a5a9c9c8761f9cb1cd2",
        "packageNameBefore": "net.sourceforge.pmd.lang.java.ast",
        "classNameBefore": "net.sourceforge.pmd.lang.java.ast.ASTRecordDeclaration",
        "methodNameBefore": "net.sourceforge.pmd.lang.java.ast.ASTRecordDeclaration#getComponentList",
        "classSignatureBefore": "public final class ASTRecordDeclaration extends AbstractAnyTypeDeclaration ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.ast.ASTRecordDeclaration#getComponentList"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.ast.ASTRecordDeclaration"
        ],
        "classSignatureBeforeSet": [
            "public final class ASTRecordDeclaration extends AbstractAnyTypeDeclaration "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\n\npackage net.sourceforge.pmd.lang.java.ast;\n\nimport java.util.List;\n\nimport net.sourceforge.pmd.annotation.Experimental;\nimport net.sourceforge.pmd.lang.ast.Node;\n\n/**\n * A record declaration is a special data class type (JDK 14 preview feature).\n * This is a {@linkplain Node#isFindBoundary() find boundary} for tree traversal methods.\n *\n * <pre class=\"grammar\">\n *\n * RecordDeclaration ::= \"record\"\n *                       &lt;IDENTIFIER&gt;\n *                       {@linkplain ASTTypeParameters TypeParameters}?\n *                       {@linkplain ASTRecordComponentList RecordComponents}\n *                       {@linkplain ASTImplementsList ImplementsList}?\n *                       {@linkplain ASTRecordBody RecordBody}\n *\n * </pre>\n *\n * @see <a href=\"https://openjdk.java.net/jeps/359\">JEP 359: Records (Preview)</a>\n */\n@Experimental\npublic final class ASTRecordDeclaration extends AbstractAnyTypeDeclaration {\n    ASTRecordDeclaration(int id) {\n        super(id);\n    }\n\n    ASTRecordDeclaration(JavaParser p, int id) {\n        super(p, id);\n    }\n\n    @Override\n    public Object jjtAccept(JavaParserVisitor visitor, Object data) {\n        return visitor.visit(this, data);\n    }\n\n    @Override\n    public TypeKind getTypeKind() {\n        return TypeKind.RECORD;\n    }\n\n    @Override\n    public List<ASTAnyTypeBodyDeclaration> getDeclarations() {\n        return getFirstChildOfType(ASTRecordBody.class).findChildrenOfType(ASTAnyTypeBodyDeclaration.class);\n    }\n\n    @Override\n    public boolean isFindBoundary() {\n        return isNested();\n    }\n\n    public ASTRecordComponentList getComponentList() {\n        return getFirstChildOfType(ASTRecordComponentList.class);\n    }\n}\n",
        "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTRecordDeclaration.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\n\npackage net.sourceforge.pmd.lang.java.ast;\n\nimport java.util.List;\n\nimport net.sourceforge.pmd.annotation.Experimental;\nimport net.sourceforge.pmd.lang.ast.Node;\n\n/**\n * A record declaration is a special data class type (JDK 14 preview feature).\n * This is a {@linkplain Node#isFindBoundary() find boundary} for tree traversal methods.\n *\n * <pre class=\"grammar\">\n *\n * RecordDeclaration ::= \"record\"\n *                       &lt;IDENTIFIER&gt;\n *                       {@linkplain ASTTypeParameters TypeParameters}?\n *                       {@linkplain ASTRecordComponentList RecordComponents}\n *                       {@linkplain ASTImplementsList ImplementsList}?\n *                       {@linkplain ASTRecordBody RecordBody}\n *\n * </pre>\n *\n * @see <a href=\"https://openjdk.java.net/jeps/359\">JEP 359: Records (Preview)</a>\n */\n@Experimental\npublic final class ASTRecordDeclaration extends AbstractAnyTypeDeclaration {\n    ASTRecordDeclaration(int id) {\n        super(id);\n    }\n\n    ASTRecordDeclaration(JavaParser p, int id) {\n        super(p, id);\n    }\n\n    @Override\n    public Object jjtAccept(JavaParserVisitor visitor, Object data) {\n        return visitor.visit(this, data);\n    }\n\n    @Override\n    public TypeKind getTypeKind() {\n        return TypeKind.RECORD;\n    }\n\n    @Override\n    public List<ASTAnyTypeBodyDeclaration> getDeclarations() {\n        return getFirstChildOfType(ASTRecordBody.class).findChildrenOfType(ASTAnyTypeBodyDeclaration.class);\n    }\n\n    @Override\n    public boolean isFindBoundary() {\n        return isNested();\n    }\n\n    /**\n     * @deprecated Renamed to {@link #getRecordComponents()}\n     */\n    @Deprecated\n    public ASTRecordComponentList getComponentList() {\n        return getRecordComponents();\n    }\n\n    /** Returns the record component list. */\n    // @NonNull\n    @Override\n    public ASTRecordComponentList getRecordComponents() {\n        return getFirstChildOfType(ASTRecordComponentList.class);\n    }\n}\n",
        "diffSourceCodeSet": [
            "/** Returns the record component list. */\n    // @NonNull\n    @Override\n    public ASTRecordComponentList getRecordComponents() {\n        return getFirstChildOfType(ASTRecordComponentList.class);\n    }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "/**\n     * @deprecated Renamed to {@link #getRecordComponents()}\n     */\n    @Deprecated\n    public ASTRecordComponentList getComponentList() {\n        return getRecordComponents();\n    }\n/** Returns the record component list. */\n    // @NonNull\n    @Override\n    public ASTRecordComponentList getRecordComponents() {\n        return getFirstChildOfType(ASTRecordComponentList.class);\n    }",
        "diffSourceCode": "-   60:     public ASTRecordComponentList getComponentList() {\n-   61:         return getFirstChildOfType(ASTRecordComponentList.class);\n-   62:     }\n-   63: }\n+   60:     /**\n+   61:      * @deprecated Renamed to {@link #getRecordComponents()}\n+   62:      */\n+   63:     @Deprecated\n+   64:     public ASTRecordComponentList getComponentList() {\n+   65:         return getRecordComponents();\n+   66:     }\n+   68:     /** Returns the record component list. */\n+   69:     // @NonNull\n+   70:     @Override\n+   71:     public ASTRecordComponentList getRecordComponents() {\n+   72:         return getFirstChildOfType(ASTRecordComponentList.class);\n+   73:     }\n",
        "uniqueId": "ea532e6d2df36d1bd59c9a5a9c9c8761f9cb1cd2_60_62_68_73_60_66",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 5
            },
            "LINE": {
                "missed": 0,
                "covered": 1
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic disambig(processor JavaAstProcessor, nodes NodeStream<? extends JavaNode>) : void extracted from public earlyDisambig(nodes NodeStream<? extends JavaNode>) : void in class net.sourceforge.pmd.lang.java.symbols.table.internal.SymbolTableHelper & moved to class net.sourceforge.pmd.lang.java.ast.InternalApiBridge",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/SymbolTableHelper.java",
                "startLine": 40,
                "endLine": 42,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/SymbolTableHelper.java",
                "startLine": 40,
                "endLine": 42,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/SymbolTableHelper.java",
                "startLine": 57,
                "endLine": 59,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public void earlyDisambig(NodeStream<? extends JavaNode> nodes) {\n        AstDisambiguationPass.disambig(processor, nodes);\n    }",
        "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/SymbolTableHelper.java",
        "isPureRefactoring": true,
        "commitId": "396567636fa1dbef2f7766f8c9ef57b4c095773e",
        "packageNameBefore": "net.sourceforge.pmd.lang.java.symbols.table.internal",
        "classNameBefore": "net.sourceforge.pmd.lang.java.symbols.table.internal.SymbolTableHelper",
        "methodNameBefore": "net.sourceforge.pmd.lang.java.symbols.table.internal.SymbolTableHelper#earlyDisambig",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.java.ast.AstDisambiguationPass#disambig\n methodBody: public static void disambig(JavaAstProcessor processor, NodeStream<? extends JavaNode> nodes) {\nJavaAstProcessor.bench(\"AST disambiguation\",() -> nodes.forEach(it -> it.jjtAccept(DisambigVisitor.INSTANCE,processor)));\n}",
        "classSignatureBefore": "final class SymbolTableHelper ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.symbols.table.internal.SymbolTableHelper#earlyDisambig"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.symbols.table.internal.SymbolTableHelper"
        ],
        "classSignatureBeforeSet": [
            "final class SymbolTableHelper "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.symbols.table.internal;\n\nimport java.util.ArrayDeque;\n\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport net.sourceforge.pmd.lang.ast.NodeStream;\nimport net.sourceforge.pmd.lang.java.ast.AstDisambiguationPass;\nimport net.sourceforge.pmd.lang.java.ast.JavaNode;\nimport net.sourceforge.pmd.lang.java.internal.JavaAstProcessor;\nimport net.sourceforge.pmd.lang.java.symbols.JClassSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.SymbolResolver;\n\n\n/**\n * Object passing around config for {@link AbstractSymbolTable}.\n *\n * @since 7.0.0\n */\nfinal class SymbolTableHelper {\n\n    private final String thisPackage;\n    private final JavaAstProcessor processor;\n\n    // this will be used later\n    private final ArrayDeque<JClassSymbol> contextType = new ArrayDeque<>(2);\n\n\n    SymbolTableHelper(String thisPackage, JavaAstProcessor processor) {\n        assert thisPackage != null;\n        assert processor != null;\n        this.thisPackage = thisPackage;\n        this.processor = processor;\n    }\n\n    public void earlyDisambig(NodeStream<? extends JavaNode> nodes) {\n        AstDisambiguationPass.disambig(processor, nodes);\n    }\n\n    void pushCtxType(JClassSymbol t) {\n        assert !t.isArray() && !t.isPrimitive();\n        contextType.push(t);\n    }\n\n    void popCtxType() {\n        contextType.pop();\n    }\n\n    /** Prepend the package name, handling empty package. */\n    String prependPackageName(String name) {\n        return thisPackage.isEmpty() ? name : thisPackage + \".\" + name;\n    }\n\n\n    public JClassSymbol findSymbolCannotFail(String name) {\n        JClassSymbol found = processor.getSymResolver().resolveClassFromCanonicalName(name);\n        return found == null ? processor.makeUnresolvedReference(name, 0)\n                             : found;\n    }\n\n    /** @see SymbolResolver#resolveClassFromCanonicalName(String) */\n    @Nullable\n    JClassSymbol loadClassOrFail(String fqcn) {\n        return processor.getSymResolver().resolveClassFromCanonicalName(fqcn);\n    }\n\n    SemanticChecksLogger getLogger() {\n        return processor.getLogger();\n    }\n\n    public String getThisPackage() {\n        return thisPackage;\n    }\n}\n",
        "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symbols/table/internal/SymbolTableHelper.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.symbols.table.internal;\n\nimport java.util.ArrayDeque;\n\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport net.sourceforge.pmd.lang.ast.NodeStream;\nimport net.sourceforge.pmd.lang.java.ast.InternalApiBridge;\nimport net.sourceforge.pmd.lang.java.ast.JavaNode;\nimport net.sourceforge.pmd.lang.java.internal.JavaAstProcessor;\nimport net.sourceforge.pmd.lang.java.symbols.JClassSymbol;\nimport net.sourceforge.pmd.lang.java.symbols.SymbolResolver;\n\n\n/**\n * Object passing around config for {@link AbstractSymbolTable}.\n *\n * @since 7.0.0\n */\nfinal class SymbolTableHelper {\n\n    private final String thisPackage;\n    private final JavaAstProcessor processor;\n\n    // this will be used later\n    private final ArrayDeque<JClassSymbol> contextType = new ArrayDeque<>(2);\n\n\n    SymbolTableHelper(String thisPackage, JavaAstProcessor processor) {\n        assert thisPackage != null;\n        assert processor != null;\n        this.thisPackage = thisPackage;\n        this.processor = processor;\n    }\n\n    public void earlyDisambig(NodeStream<? extends JavaNode> nodes) {\n        InternalApiBridge.disambig(processor, nodes);\n    }\n\n    void pushCtxType(JClassSymbol t) {\n        assert !t.isArray() && !t.isPrimitive();\n        contextType.push(t);\n    }\n\n    void popCtxType() {\n        contextType.pop();\n    }\n\n    /** Prepend the package name, handling empty package. */\n    String prependPackageName(String name) {\n        return thisPackage.isEmpty() ? name : thisPackage + \".\" + name;\n    }\n\n\n    public JClassSymbol findSymbolCannotFail(String name) {\n        JClassSymbol found = processor.getSymResolver().resolveClassFromCanonicalName(name);\n        return found == null ? processor.makeUnresolvedReference(name, 0)\n                             : found;\n    }\n\n    /** @see SymbolResolver#resolveClassFromCanonicalName(String) */\n    @Nullable\n    JClassSymbol loadClassOrFail(String fqcn) {\n        return processor.getSymResolver().resolveClassFromCanonicalName(fqcn);\n    }\n\n    SemanticChecksLogger getLogger() {\n        return processor.getLogger();\n    }\n\n    public String getThisPackage() {\n        return thisPackage;\n    }\n}\n",
        "diffSourceCodeSet": [
            "public JClassSymbol findSymbolCannotFail(String name) {"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.java.ast.AstDisambiguationPass#disambig\n methodBody: public static void disambig(JavaAstProcessor processor, NodeStream<? extends JavaNode> nodes) {\nJavaAstProcessor.bench(\"AST disambiguation\",() -> nodes.forEach(it -> it.jjtAccept(DisambigVisitor.INSTANCE,processor)));\n}"
        ],
        "sourceCodeAfterRefactoring": "public void earlyDisambig(NodeStream<? extends JavaNode> nodes) {\n        InternalApiBridge.disambig(processor, nodes);\n    }\npublic JClassSymbol findSymbolCannotFail(String name) {",
        "diffSourceCode": "    40:     public void earlyDisambig(NodeStream<? extends JavaNode> nodes) {\n-   41:         AstDisambiguationPass.disambig(processor, nodes);\n+   41:         InternalApiBridge.disambig(processor, nodes);\n    42:     }\n    57: \n    58: \n    59:     public JClassSymbol findSymbolCannotFail(String name) {\n",
        "uniqueId": "396567636fa1dbef2f7766f8c9ef57b4c095773e_40_42_57_59_40_42",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 5
            },
            "LINE": {
                "missed": 0,
                "covered": 2
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic apply(iter Iterator<? extends I>, filtermap Filtermap<? super I,? extends O>) : Iterator<O> extracted from public filterMap(iter Iterator<? extends I>) : Iterator<O> in class net.sourceforge.pmd.lang.ast.internal.Filtermap",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/Filtermap.java",
                "startLine": 42,
                "endLine": 45,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/Filtermap.java",
                "startLine": 45,
                "endLine": 48,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/Filtermap.java",
                "startLine": 50,
                "endLine": 52,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/** Filter an iterator. */\n    default Iterator<O> filterMap(Iterator<? extends I> iter) {\n        return IteratorUtil.mapNotNull(iter, this);\n    }",
        "filePathBefore": "pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/Filtermap.java",
        "isPureRefactoring": true,
        "commitId": "f3d4cd81ed0ce60bcc0a062b57793ca645036236",
        "packageNameBefore": "net.sourceforge.pmd.lang.ast.internal",
        "classNameBefore": "net.sourceforge.pmd.lang.ast.internal.Filtermap",
        "methodNameBefore": "net.sourceforge.pmd.lang.ast.internal.Filtermap#filterMap",
        "classSignatureBefore": "interface Filtermap<I, O> extends Function<@NonNull I, @Nullable O>, Predicate<@NonNull I> ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.ast.internal.Filtermap#filterMap"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.ast.internal.Filtermap"
        ],
        "classSignatureBeforeSet": [
            "interface Filtermap<I, O> extends Function<@NonNull I, @Nullable O>, Predicate<@NonNull I> "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics",
                "description": "All the mappings are matched! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.ast.internal;\n\n\nimport java.util.Iterator;\nimport java.util.Objects;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport net.sourceforge.pmd.internal.util.IteratorUtil;\nimport net.sourceforge.pmd.lang.ast.Node;\n\n/**\n * Combined filter/map predicate. Cannot accept null values.\n */\n@FunctionalInterface\ninterface Filtermap<I, O> extends Function<@NonNull I, @Nullable O>, Predicate<@NonNull I> {\n\n\n    Filtermap<Node, Node> NODE_IDENTITY = identityFilter();\n\n\n    /**\n     * Returns a null value if the filter accepts the value. Otherwise\n     * returns the transformed value. MUST return null for null parameter.\n     */\n    @Override\n    @Nullable O apply(@Nullable I i);\n\n\n    @Override\n    default boolean test(@Nullable I i) {\n        return apply(i) != null;\n    }\n\n    /** Filter an iterator. */\n    default Iterator<O> filterMap(Iterator<? extends I> iter) {\n        return IteratorUtil.mapNotNull(iter, this);\n    }\n\n\n    /** Compose a new Filtermap, coalescing null values. */\n    default <R> Filtermap<I, R> thenApply(Function<@NonNull ? super O, @Nullable ? extends R> then) {\n        Objects.requireNonNull(then);\n        return i -> {\n            if (i == null) {\n                return null;\n            }\n            O o = this.apply(i);\n            return o == null ? null : then.apply(o);\n        };\n    }\n\n\n    default <R> Filtermap<I, R> thenCast(Class<R> rClass) {\n        return thenApply(isInstance(rClass));\n    }\n\n\n    default Filtermap<I, O> thenFilter(Predicate<? super O> rClass) {\n        return thenApply(filter(rClass));\n    }\n\n\n    static <I> Filtermap<I, I> identityFilter() {\n        return new Filtermap<I, I>() {\n            @Override\n            public I apply(@Nullable I i) {\n                return i;\n            }\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public <R> Filtermap<I, R> thenApply(Function<@NonNull ? super I, @Nullable ? extends R> then) {\n                return then instanceof Filtermap ? (Filtermap<I, R>) then : Filtermap.super.thenApply(then);\n            }\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public Iterator<I> filterMap(Iterator<? extends I> iter) {\n                return (Iterator<I>) iter;\n            }\n\n            @Override\n            public String toString() {\n                return \"IdentityFilter\";\n            }\n        };\n    }\n\n\n    static <I> Filtermap<I, I> filter(Predicate<? super @NonNull I> pred) {\n        return i -> i != null && pred.test(i) ? i : null;\n    }\n\n\n    static <I, O> Filtermap<I, O> isInstance(Class<O> oClass) {\n        if (oClass == Node.class) {\n            return (Filtermap<I, O>) NODE_IDENTITY;\n        }\n\n        return new Filtermap<I, O>() {\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public @Nullable O apply(@Nullable I i) {\n                return oClass.isInstance(i) ? (O) i : null;\n            }\n\n            @Override\n            public String toString() {\n                return \"IsInstance[\" + oClass + \"]\";\n            }\n        };\n    }\n\n}\n",
        "filePathAfter": "pmd-core/src/main/java/net/sourceforge/pmd/lang/ast/internal/Filtermap.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.ast.internal;\n\n\nimport java.util.Iterator;\nimport java.util.Objects;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\n\nimport org.checkerframework.checker.nullness.qual.NonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport net.sourceforge.pmd.internal.util.IteratorUtil;\nimport net.sourceforge.pmd.lang.ast.Node;\n\n/**\n * Combined filter/map predicate. Cannot accept null values.\n *\n * @param <I> Input type, contravariant\n * @param <O> Output type, covariant\n */\n@FunctionalInterface\ninterface Filtermap<I, O> extends Function<@NonNull I, @Nullable O>, Predicate<@NonNull I> {\n\n\n    Filtermap<Node, Node> NODE_IDENTITY = identityFilter();\n\n\n    /**\n     * Returns a null value if the filter accepts the value. Otherwise\n     * returns the transformed value. MUST return null for null parameter.\n     */\n    @Override\n    @Nullable O apply(@Nullable I i);\n\n\n    @Override\n    default boolean test(@Nullable I i) {\n        return apply(i) != null;\n    }\n\n    /** Filter an iterator. */\n    default Iterator<O> filterMap(Iterator<? extends I> iter) {\n        return apply(iter, this);\n    }\n\n    static <I, O> Iterator<O> apply(Iterator<? extends I> iter, Filtermap<? super I, ? extends O> filtermap) {\n        return IteratorUtil.mapNotNull(iter, filtermap);\n    }\n\n\n    /** Compose a new Filtermap, coalescing null values. */\n    default <R> Filtermap<I, R> thenApply(Function<@NonNull ? super O, @Nullable ? extends R> then) {\n        Objects.requireNonNull(then);\n        return i -> {\n            if (i == null) {\n                return null;\n            }\n            O o = this.apply(i);\n            return o == null ? null : then.apply(o);\n        };\n    }\n\n\n    default <R> Filtermap<I, R> thenCast(Class<? extends R> rClass) {\n        return thenApply(isInstance(rClass));\n    }\n\n\n    default Filtermap<I, O> thenFilter(Predicate<? super O> rClass) {\n        return thenApply(filter(rClass));\n    }\n\n\n    static <I> Filtermap<I, I> identityFilter() {\n        return new Filtermap<I, I>() {\n            @Override\n            public I apply(@Nullable I i) {\n                return i;\n            }\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public <R> Filtermap<I, R> thenApply(Function<@NonNull ? super I, @Nullable ? extends R> then) {\n                return then instanceof Filtermap ? (Filtermap<I, R>) then : Filtermap.super.thenApply(then);\n            }\n\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public Iterator<I> filterMap(Iterator<? extends I> iter) {\n                return (Iterator<I>) iter;\n            }\n\n            @Override\n            public String toString() {\n                return \"IdentityFilter\";\n            }\n        };\n    }\n\n\n    static <I extends O, O> Filtermap<I, O> filter(Predicate<? super @NonNull I> pred) {\n        return i -> i != null && pred.test(i) ? i : null;\n    }\n\n\n    static <I, O> Filtermap<I, O> isInstance(Class<? extends O> oClass) {\n        if (oClass == Node.class) {\n            return (Filtermap<I, O>) NODE_IDENTITY;\n        }\n\n        return new Filtermap<I, O>() {\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public @Nullable O apply(@Nullable I i) {\n                return oClass.isInstance(i) ? (O) i : null;\n            }\n\n            @Override\n            public String toString() {\n                return \"IsInstance[\" + oClass + \"]\";\n            }\n        };\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "static <I, O> Iterator<O> apply(Iterator<? extends I> iter, Filtermap<? super I, ? extends O> filtermap) {\n        return IteratorUtil.mapNotNull(iter, filtermap);\n    }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "/** Filter an iterator. */\n    default Iterator<O> filterMap(Iterator<? extends I> iter) {\n        return apply(iter, this);\n    }\nstatic <I, O> Iterator<O> apply(Iterator<? extends I> iter, Filtermap<? super I, ? extends O> filtermap) {\n        return IteratorUtil.mapNotNull(iter, filtermap);\n    }",
        "diffSourceCode": "-   42:     /** Filter an iterator. */\n-   43:     default Iterator<O> filterMap(Iterator<? extends I> iter) {\n-   44:         return IteratorUtil.mapNotNull(iter, this);\n-   45:     }\n-   46: \n-   47: \n-   48:     /** Compose a new Filtermap, coalescing null values. */\n-   50:         Objects.requireNonNull(then);\n-   51:         return i -> {\n-   52:             if (i == null) {\n+   42:         return apply(i) != null;\n+   43:     }\n+   44: \n+   45:     /** Filter an iterator. */\n+   46:     default Iterator<O> filterMap(Iterator<? extends I> iter) {\n+   47:         return apply(iter, this);\n+   48:     }\n+   50:     static <I, O> Iterator<O> apply(Iterator<? extends I> iter, Filtermap<? super I, ? extends O> filtermap) {\n+   51:         return IteratorUtil.mapNotNull(iter, filtermap);\n+   52:     }\n",
        "uniqueId": "f3d4cd81ed0ce60bcc0a062b57793ca645036236_42_45_50_52_45_48",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 4
            },
            "LINE": {
                "missed": 0,
                "covered": 1
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpackage forceTypeResolution() : void extracted from public getOverloadSelectionInfo() : OverloadSelectionResult in class net.sourceforge.pmd.lang.java.ast.AbstractInvocationExpr & moved to class net.sourceforge.pmd.lang.java.ast.AbstractJavaTypeNode",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractInvocationExpr.java",
                "startLine": 25,
                "endLine": 30,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractInvocationExpr.java",
                "startLine": 25,
                "endLine": 29,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractInvocationExpr.java",
                "startLine": 26,
                "endLine": 28,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n    public OverloadSelectionResult getOverloadSelectionInfo() {\n        getTypeMirror(); // force evaluation\n        assert result != null : \"Something went wrong during overload resolution for \" + this;\n        return result;\n    }",
        "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractInvocationExpr.java",
        "isPureRefactoring": true,
        "commitId": "6253b696ea9b04ecf4a0c832473a178ade97f32d",
        "packageNameBefore": "net.sourceforge.pmd.lang.java.ast",
        "classNameBefore": "net.sourceforge.pmd.lang.java.ast.AbstractInvocationExpr",
        "methodNameBefore": "net.sourceforge.pmd.lang.java.ast.AbstractInvocationExpr#getOverloadSelectionInfo",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.java.ast.AbstractJavaTypeNode#getTypeMirror\n methodBody: public @NonNull JTypeMirror getTypeMirror() {\nif(typeMirror == null){tryLazyTypeResolver resolver=getRoot().getLazyTypeResolver();\ntypeMirror=this.acceptVisitor(resolver,null);\nassert typeMirror != null : \"LazyTypeResolver returned null\";\ncatch(Exception|AssertionError e)throw addContextValue(e,\"Resolving type of\",this);\n}return typeMirror;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.ast.ASTLambdaExpression#getTypeMirror\n methodBody: public @NonNull JTypeMirror getTypeMirror() {\nreturn super.getTypeMirror();\n}\nmethodSignature: net.sourceforge.pmd.lang.java.ast.ASTMethodReference#getTypeMirror\n methodBody: public @NonNull JTypeMirror getTypeMirror() {\nreturn super.getTypeMirror();\n}",
        "classSignatureBefore": "abstract class AbstractInvocationExpr extends AbstractJavaExpr implements InvocationNode ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.ast.AbstractInvocationExpr#getOverloadSelectionInfo"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.ast.AbstractInvocationExpr"
        ],
        "classSignatureBeforeSet": [
            "abstract class AbstractInvocationExpr extends AbstractJavaExpr implements InvocationNode "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.ast;\n\nimport net.sourceforge.pmd.lang.java.types.OverloadSelectionResult;\n\n/**\n *\n */\nabstract class AbstractInvocationExpr extends AbstractJavaExpr implements InvocationNode {\n\n    private OverloadSelectionResult result;\n\n    AbstractInvocationExpr(int i) {\n        super(i);\n    }\n\n    void setOverload(OverloadSelectionResult result) {\n        assert result != null;\n        this.result = result;\n    }\n\n    @Override\n    public OverloadSelectionResult getOverloadSelectionInfo() {\n        getTypeMirror(); // force evaluation\n        assert result != null : \"Something went wrong during overload resolution for \" + this;\n        return result;\n    }\n}\n",
        "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/AbstractInvocationExpr.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.ast;\n\nimport net.sourceforge.pmd.lang.java.types.OverloadSelectionResult;\n\n/**\n *\n */\nabstract class AbstractInvocationExpr extends AbstractJavaExpr implements InvocationNode {\n\n    private OverloadSelectionResult result;\n\n    AbstractInvocationExpr(int i) {\n        super(i);\n    }\n\n    void setOverload(OverloadSelectionResult result) {\n        assert result != null;\n        this.result = result;\n    }\n\n    @Override\n    public OverloadSelectionResult getOverloadSelectionInfo() {\n        forceTypeResolution();\n        return assertNonNullAfterTypeRes(result);\n    }\n}\n",
        "diffSourceCodeSet": [
            "public OverloadSelectionResult getOverloadSelectionInfo() {\n        forceTypeResolution();\n        return assertNonNullAfterTypeRes(result);"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.java.ast.AbstractJavaTypeNode#getTypeMirror\n methodBody: public @NonNull JTypeMirror getTypeMirror() {\nif(typeMirror == null){tryLazyTypeResolver resolver=getRoot().getLazyTypeResolver();\ntypeMirror=this.acceptVisitor(resolver,null);\nassert typeMirror != null : \"LazyTypeResolver returned null\";\ncatch(Exception|AssertionError e)throw addContextValue(e,\"Resolving type of\",this);\n}return typeMirror;\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.ast.ASTLambdaExpression#getTypeMirror\n methodBody: public @NonNull JTypeMirror getTypeMirror() {\nreturn super.getTypeMirror();\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.ast.ASTMethodReference#getTypeMirror\n methodBody: public @NonNull JTypeMirror getTypeMirror() {\nreturn super.getTypeMirror();\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n    public OverloadSelectionResult getOverloadSelectionInfo() {\n        forceTypeResolution();\n        return assertNonNullAfterTypeRes(result);\n    }\npublic OverloadSelectionResult getOverloadSelectionInfo() {\n        forceTypeResolution();\n        return assertNonNullAfterTypeRes(result);",
        "diffSourceCode": "    25:     @Override\n    26:     public OverloadSelectionResult getOverloadSelectionInfo() {\n-   27:         getTypeMirror(); // force evaluation\n-   28:         assert result != null : \"Something went wrong during overload resolution for \" + this;\n-   29:         return result;\n-   30:     }\n+   27:         forceTypeResolution();\n+   28:         return assertNonNullAfterTypeRes(result);\n+   29:     }\n+   30: }\n",
        "uniqueId": "6253b696ea9b04ecf4a0c832473a178ade97f32d_25_30_26_28_25_29",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 12,
                "covered": 11
            },
            "BRANCH": {
                "missed": 2,
                "covered": 2
            },
            "LINE": {
                "missed": 0,
                "covered": 3
            },
            "COMPLEXITY": {
                "missed": 2,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic throwingExceptions() : RuleContext extracted from private getViolations(rule Rule, code String) : Iterator<RuleViolation> in class net.sourceforge.pmd.lang.java.rule.xpath.internal.XPathMetricFunctionTest & moved to class net.sourceforge.pmd.RuleContext",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/test/java/net/sourceforge/pmd/lang/java/rule/xpath/internal/XPathMetricFunctionTest.java",
                "startLine": 50,
                "endLine": 60,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/test/java/net/sourceforge/pmd/lang/java/rule/xpath/internal/XPathMetricFunctionTest.java",
                "startLine": 53,
                "endLine": 63,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/test/java/net/sourceforge/pmd/lang/java/rule/xpath/internal/XPathMetricFunctionTest.java",
                "startLine": 183,
                "endLine": 187,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private Iterator<RuleViolation> getViolations(Rule rule, String code) throws PMDException {\n        PMD p = new PMD();\n        RuleContext ctx = new RuleContext();\n        Report report = new Report();\n        ctx.setReport(report);\n        ctx.setSourceCodeFile(new File(\"n/a\"));\n        ctx.setIgnoreExceptions(false); // for test, we want immediate exceptions thrown and not collect them\n        RuleSet rules = RulesetsFactoryUtils.defaultFactory().createSingleRuleRuleSet(rule);\n        p.getSourceCodeProcessor().processSourceCode(new StringReader(code), new RuleSets(rules), ctx);\n        return report.getViolations().iterator();\n    }",
        "filePathBefore": "pmd-java/src/test/java/net/sourceforge/pmd/lang/java/rule/xpath/internal/XPathMetricFunctionTest.java",
        "isPureRefactoring": true,
        "commitId": "08b19dbcdde5d6258515cf2620a855e7775d46ef",
        "packageNameBefore": "net.sourceforge.pmd.lang.java.rule.xpath.internal",
        "classNameBefore": "net.sourceforge.pmd.lang.java.rule.xpath.internal.XPathMetricFunctionTest",
        "methodNameBefore": "net.sourceforge.pmd.lang.java.rule.xpath.internal.XPathMetricFunctionTest#getViolations",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.RuleContext#setIgnoreExceptions\n methodBody: public void setIgnoreExceptions(boolean ignoreExceptions) {\nthis.ignoreExceptions=ignoreExceptions;\n}\nmethodSignature: net.sourceforge.pmd.RuleContext#setSourceCodeFile\n methodBody: public void setSourceCodeFile(File sourceCodeFile) {\nthis.sourceCodeFile=sourceCodeFile;\n}\nmethodSignature: net.sourceforge.pmd.PMD#getSourceCodeProcessor\n methodBody: public SourceCodeProcessor getSourceCodeProcessor() {\nreturn rulesetsFileProcessor;\n}\nmethodSignature: net.sourceforge.pmd.SourceCodeProcessor#processSourceCode\n methodBody: public void processSourceCode(Reader sourceCode, RuleSets ruleSets, RuleContext ctx) throws PMDException {\ndetermineLanguage(ctx);\nif(ruleSets.applies(ctx.getSourceCodeFile())){if(isCacheUpToDate(ctx)){reportCachedRuleViolations(ctx);\n}{processSourceCodeWithoutCache(sourceCode,ruleSets,ctx);\n}}}\nmethodSignature: net.sourceforge.pmd.RuleContext#setReport\n methodBody: public void setReport(Report report) {\nthis.report=report;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.rule.xpath.internal.XPathMetricFunctionTest#getViolations\n methodBody: private Iterator<RuleViolation> getViolations(Rule rule, String code) throws PMDException {\nPMD p=new PMD();\nRuleContext ctx=new RuleContext();\nReport report=new Report();\nctx.setReport(report);\nctx.setSourceCodeFile(new File(\"n/a\"));\nctx.setIgnoreExceptions(false);\nRuleSet rules=RulesetsFactoryUtils.defaultFactory().createSingleRuleRuleSet(rule);\np.getSourceCodeProcessor().processSourceCode(new StringReader(code),new RuleSets(rules),ctx);\nreturn report.getViolations().iterator();\n}",
        "classSignatureBefore": "public class XPathMetricFunctionTest ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.rule.xpath.internal.XPathMetricFunctionTest#getViolations"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.rule.xpath.internal.XPathMetricFunctionTest"
        ],
        "classSignatureBeforeSet": [
            "public class XPathMetricFunctionTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics Severe changes",
                "description": "Return expression has been added within the Extract Method mechanics - with non-mapped leaves",
                "mappingState": 2
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.rule.xpath.internal;\n\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.File;\nimport java.io.StringReader;\nimport java.util.Iterator;\n\nimport org.junit.Test;\nimport org.junit.rules.ExpectedException;\n\nimport net.sourceforge.pmd.PMD;\nimport net.sourceforge.pmd.PMDException;\nimport net.sourceforge.pmd.Report;\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RuleContext;\nimport net.sourceforge.pmd.RuleSet;\nimport net.sourceforge.pmd.RuleSets;\nimport net.sourceforge.pmd.RuleViolation;\nimport net.sourceforge.pmd.RulesetsFactoryUtils;\nimport net.sourceforge.pmd.lang.LanguageRegistry;\nimport net.sourceforge.pmd.lang.java.JavaLanguageModule;\nimport net.sourceforge.pmd.lang.rule.XPathRule;\nimport net.sourceforge.pmd.lang.rule.xpath.XPathVersion;\n\n/**\n * @author Cl\u00e9ment Fournier\n * @since 6.0.0\n */\npublic class XPathMetricFunctionTest {\n\n    private static final String VIOLATION_MESSAGE = \"violation\";\n\n    @org.junit.Rule\n    public ExpectedException expected = ExpectedException.none();\n\n\n    private Rule makeXpathRuleFromXPath(String xpath) {\n        XPathRule rule = new XPathRule(XPathVersion.XPATH_1_0, xpath);\n        rule.setMessage(VIOLATION_MESSAGE);\n        rule.setLanguage(LanguageRegistry.getLanguage(JavaLanguageModule.NAME));\n        return rule;\n    }\n\n\n    private Iterator<RuleViolation> getViolations(Rule rule, String code) throws PMDException {\n        PMD p = new PMD();\n        RuleContext ctx = new RuleContext();\n        Report report = new Report();\n        ctx.setReport(report);\n        ctx.setSourceCodeFile(new File(\"n/a\"));\n        ctx.setIgnoreExceptions(false); // for test, we want immediate exceptions thrown and not collect them\n        RuleSet rules = RulesetsFactoryUtils.defaultFactory().createSingleRuleRuleSet(rule);\n        p.getSourceCodeProcessor().processSourceCode(new StringReader(code), new RuleSets(rules), ctx);\n        return report.getViolations().iterator();\n    }\n\n\n    @Test\n    public void testWellFormedClassMetricRule() throws PMDException {\n        Rule rule = makeXpathRuleFromXPath(\"//ClassOrInterfaceDeclaration[pmd-java:metric('NCSS') > 0]\");\n        final String code = \"class Foo { Foo() {} void bar() {}}\";\n\n        Iterator<RuleViolation> violations = getViolations(rule, code);\n        assertTrue(violations.hasNext());\n    }\n\n\n    @Test\n    public void testWellFormedOperationMetricRule() throws PMDException {\n        Rule rule = makeXpathRuleFromXPath(\"//ConstructorDeclaration[pmd-java:metric('CYCLO') > 1]\");\n        final String code = \"class Goo { Goo() {if(true){}} }\";\n\n        Iterator<RuleViolation> violations = getViolations(rule, code);\n        assertTrue(violations.hasNext());\n    }\n\n\n    @Test\n    public void testBadCase() throws PMDException {\n        Rule rule = makeXpathRuleFromXPath(\"//ConstructorDeclaration[pmd-java:metric('cYclo') > 1]\");\n        final String code = \"class Hoo { Hoo() {if(true){}} }\";\n\n        Iterator<RuleViolation> violations = getViolations(rule, code);\n        assertTrue(violations.hasNext());\n    }\n\n\n    @Test\n    public void testNonexistentMetric() throws Exception {\n        testWithExpectedException(\"//ConstructorDeclaration[pmd-java:metric('FOOBAR') > 1]\",\n                                  \"class Joo { Joo() {if(true){}} }\",\n                                  IllegalArgumentException.class,\n                                  MetricFunction.badOperationMetricKeyMessage());\n    }\n\n\n    @Test\n    public void testWrongNodeTypeGeneric() throws Exception {\n        testWithExpectedException(\"//IfStatement[pmd-java:metric('NCSS') > 1]\",\n                                  \"class Koo { Koo() {if(true){}} }\",\n                                  IllegalStateException.class,\n                                  MetricFunction.genericBadNodeMessage());\n    }\n\n\n    @Test\n    public void testWrongMetricKeyForTypeDeclaration() throws Exception {\n        testWithExpectedException(\"//EnumDeclaration[pmd-java:metric('CYCLO') > 1]\",\n                                  \"enum Loo { FOO; }\",\n                                  IllegalArgumentException.class,\n                                  MetricFunction.badClassMetricKeyMessage());\n    }\n\n\n    @Test\n    public void testWrongMetricKeyForOperationDeclaration() throws Exception {\n        testWithExpectedException(\"//MethodDeclaration[pmd-java:metric('WMC') > 1]\",\n                                  \"class Moo { void foo() {if(true){}} }\",\n                                  IllegalArgumentException.class,\n                                  MetricFunction.badOperationMetricKeyMessage());\n    }\n\n\n    private void testWithExpectedException(String xpath, String code,\n                                           Class<? extends Exception> expectedThrowable,\n                                           String expectedMessage) throws Exception {\n\n        Rule rule = makeXpathRuleFromXPath(xpath);\n\n        expected.expect(expectedThrowable);\n        expected.expectMessage(expectedMessage);\n\n        try {\n            getViolations(rule, code);\n        } catch (PMDException pmdE) {\n            throw (Exception) pmdE.getCause();\n        }\n\n    }\n\n\n}\n",
        "filePathAfter": "pmd-java/src/test/java/net/sourceforge/pmd/lang/java/rule/xpath/internal/XPathMetricFunctionTest.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.rule.xpath.internal;\n\nimport static net.sourceforge.pmd.util.CollectionUtil.listOf;\nimport static org.junit.Assert.assertTrue;\n\nimport java.util.Collections;\nimport java.util.Iterator;\n\nimport org.hamcrest.CoreMatchers;\nimport org.hamcrest.Matchers;\nimport org.junit.Test;\nimport org.junit.rules.ExpectedException;\n\nimport net.sourceforge.pmd.PMDConfiguration;\nimport net.sourceforge.pmd.PMDException;\nimport net.sourceforge.pmd.Rule;\nimport net.sourceforge.pmd.RuleContext;\nimport net.sourceforge.pmd.RuleSet;\nimport net.sourceforge.pmd.RuleViolation;\nimport net.sourceforge.pmd.RulesetsFactoryUtils;\nimport net.sourceforge.pmd.lang.LanguageRegistry;\nimport net.sourceforge.pmd.lang.ast.FileAnalysisException;\nimport net.sourceforge.pmd.lang.java.JavaLanguageModule;\nimport net.sourceforge.pmd.lang.rule.XPathRule;\nimport net.sourceforge.pmd.lang.rule.xpath.XPathVersion;\nimport net.sourceforge.pmd.processor.PmdRunnable;\nimport net.sourceforge.pmd.util.datasource.DataSource;\n\n/**\n * @author Cl\u00e9ment Fournier\n * @since 6.0.0\n */\npublic class XPathMetricFunctionTest {\n\n    private static final String VIOLATION_MESSAGE = \"violation\";\n\n    @org.junit.Rule\n    public ExpectedException expected = ExpectedException.none();\n\n\n    private Rule makeXpathRuleFromXPath(String xpath) {\n        XPathRule rule = new XPathRule(XPathVersion.XPATH_1_0, xpath);\n        rule.setMessage(VIOLATION_MESSAGE);\n        rule.setLanguage(LanguageRegistry.getLanguage(JavaLanguageModule.NAME));\n        return rule;\n    }\n\n\n    private Iterator<RuleViolation> getViolations(Rule rule, String code) {\n        RuleSet rules = RulesetsFactoryUtils.defaultFactory().createSingleRuleRuleSet(rule);\n\n        return new PmdRunnable(\n            DataSource.forString(code, \"test.java\"),\n            Collections.emptyList(),\n            RuleContext.throwingExceptions(),\n            listOf(rules),\n            new PMDConfiguration()\n        ).call().getViolations().iterator();\n    }\n\n\n    @Test\n    public void testWellFormedClassMetricRule() throws PMDException {\n        Rule rule = makeXpathRuleFromXPath(\"//ClassOrInterfaceDeclaration[pmd-java:metric('NCSS') > 0]\");\n        final String code = \"class Foo { Foo() {} void bar() {}}\";\n\n        Iterator<RuleViolation> violations = getViolations(rule, code);\n        assertTrue(violations.hasNext());\n    }\n\n\n    @Test\n    public void testWellFormedOperationMetricRule() throws PMDException {\n        Rule rule = makeXpathRuleFromXPath(\"//ConstructorDeclaration[pmd-java:metric('CYCLO') > 1]\");\n        final String code = \"class Goo { Goo() {if(true){}} }\";\n\n        Iterator<RuleViolation> violations = getViolations(rule, code);\n        assertTrue(violations.hasNext());\n    }\n\n\n    @Test\n    public void testBadCase() throws PMDException {\n        Rule rule = makeXpathRuleFromXPath(\"//ConstructorDeclaration[pmd-java:metric('cYclo') > 1]\");\n        final String code = \"class Hoo { Hoo() {if(true){}} }\";\n\n        Iterator<RuleViolation> violations = getViolations(rule, code);\n        assertTrue(violations.hasNext());\n    }\n\n\n    @Test\n    public void testNonexistentMetric() throws Exception {\n        testWithExpectedException(\"//ConstructorDeclaration[pmd-java:metric('FOOBAR') > 1]\",\n                                  \"class Joo { Joo() {if(true){}} }\",\n                                  IllegalArgumentException.class,\n                                  MetricFunction.badOperationMetricKeyMessage());\n    }\n\n\n    @Test\n    public void testWrongNodeTypeGeneric() throws Exception {\n        testWithExpectedException(\"//IfStatement[pmd-java:metric('NCSS') > 1]\",\n                                  \"class Koo { Koo() {if(true){}} }\",\n                                  IllegalStateException.class,\n                                  MetricFunction.genericBadNodeMessage());\n    }\n\n\n    @Test\n    public void testWrongMetricKeyForTypeDeclaration() throws Exception {\n        testWithExpectedException(\"//EnumDeclaration[pmd-java:metric('CYCLO') > 1]\",\n                                  \"enum Loo { FOO; }\",\n                                  IllegalArgumentException.class,\n                                  MetricFunction.badClassMetricKeyMessage());\n    }\n\n\n    @Test\n    public void testWrongMetricKeyForOperationDeclaration() throws Exception {\n        testWithExpectedException(\"//MethodDeclaration[pmd-java:metric('WMC') > 1]\",\n                                  \"class Moo { void foo() {if(true){}} }\",\n                                  IllegalArgumentException.class,\n                                  MetricFunction.badOperationMetricKeyMessage());\n    }\n\n\n    private void testWithExpectedException(String xpath, String code,\n                                           Class<? extends Exception> expectedThrowable,\n                                           String expectedMessage) throws Exception {\n\n        Rule rule = makeXpathRuleFromXPath(xpath);\n\n        expected.expect(FileAnalysisException.class);\n        expected.expectCause(Matchers.allOf(CoreMatchers.instanceOf(expectedThrowable),\n                                            Matchers.hasProperty(\"message\", Matchers.equalTo(expectedMessage))));\n\n        getViolations(rule, code);\n    }\n\n\n}\n",
        "diffSourceCodeSet": [
            ""
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.RuleContext#setIgnoreExceptions\n methodBody: public void setIgnoreExceptions(boolean ignoreExceptions) {\nthis.ignoreExceptions=ignoreExceptions;\n}",
            "methodSignature: net.sourceforge.pmd.RuleContext#setSourceCodeFile\n methodBody: public void setSourceCodeFile(File sourceCodeFile) {\nthis.sourceCodeFile=sourceCodeFile;\n}",
            "methodSignature: net.sourceforge.pmd.PMD#getSourceCodeProcessor\n methodBody: public SourceCodeProcessor getSourceCodeProcessor() {\nreturn rulesetsFileProcessor;\n}",
            "methodSignature: net.sourceforge.pmd.SourceCodeProcessor#processSourceCode\n methodBody: public void processSourceCode(Reader sourceCode, RuleSets ruleSets, RuleContext ctx) throws PMDException {\ndetermineLanguage(ctx);\nif(ruleSets.applies(ctx.getSourceCodeFile())){if(isCacheUpToDate(ctx)){reportCachedRuleViolations(ctx);\n}{processSourceCodeWithoutCache(sourceCode,ruleSets,ctx);\n}}}",
            "methodSignature: net.sourceforge.pmd.RuleContext#setReport\n methodBody: public void setReport(Report report) {\nthis.report=report;\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.rule.xpath.internal.XPathMetricFunctionTest#getViolations\n methodBody: private Iterator<RuleViolation> getViolations(Rule rule, String code) throws PMDException {\nPMD p=new PMD();\nRuleContext ctx=new RuleContext();\nReport report=new Report();\nctx.setReport(report);\nctx.setSourceCodeFile(new File(\"n/a\"));\nctx.setIgnoreExceptions(false);\nRuleSet rules=RulesetsFactoryUtils.defaultFactory().createSingleRuleRuleSet(rule);\np.getSourceCodeProcessor().processSourceCode(new StringReader(code),new RuleSets(rules),ctx);\nreturn report.getViolations().iterator();\n}"
        ],
        "sourceCodeAfterRefactoring": "private Iterator<RuleViolation> getViolations(Rule rule, String code) {\n        RuleSet rules = RulesetsFactoryUtils.defaultFactory().createSingleRuleRuleSet(rule);\n\n        return new PmdRunnable(\n            DataSource.forString(code, \"test.java\"),\n            Collections.emptyList(),\n            RuleContext.throwingExceptions(),\n            listOf(rules),\n            new PMDConfiguration()\n        ).call().getViolations().iterator();\n    }\n",
        "diffSourceCode": "-   50:     private Iterator<RuleViolation> getViolations(Rule rule, String code) throws PMDException {\n-   51:         PMD p = new PMD();\n-   52:         RuleContext ctx = new RuleContext();\n-   53:         Report report = new Report();\n-   54:         ctx.setReport(report);\n-   55:         ctx.setSourceCodeFile(new File(\"n/a\"));\n-   56:         ctx.setIgnoreExceptions(false); // for test, we want immediate exceptions thrown and not collect them\n-   57:         RuleSet rules = RulesetsFactoryUtils.defaultFactory().createSingleRuleRuleSet(rule);\n-   58:         p.getSourceCodeProcessor().processSourceCode(new StringReader(code), new RuleSets(rules), ctx);\n-   59:         return report.getViolations().iterator();\n-   60:     }\n-   61: \n-   62: \n-   63:     @Test\n+   50:     }\n+   51: \n+   52: \n+   53:     private Iterator<RuleViolation> getViolations(Rule rule, String code) {\n+   54:         RuleSet rules = RulesetsFactoryUtils.defaultFactory().createSingleRuleRuleSet(rule);\n+   55: \n+   56:         return new PmdRunnable(\n+   57:             DataSource.forString(code, \"test.java\"),\n+   58:             Collections.emptyList(),\n+   59:             RuleContext.throwingExceptions(),\n+   60:             listOf(rules),\n+   61:             new PMDConfiguration()\n+   62:         ).call().getViolations().iterator();\n+   63:     }\n",
        "uniqueId": "08b19dbcdde5d6258515cf2620a855e7775d46ef_50_60_183_187_53_63",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate getExplicitTypeNode() : TypeNode extracted from private getTypeNode() : TypeNode in class net.sourceforge.pmd.lang.java.symboltable.VariableNameDeclaration",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/VariableNameDeclaration.java",
                "startLine": 114,
                "endLine": 125,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/VariableNameDeclaration.java",
                "startLine": 114,
                "endLine": 117,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/VariableNameDeclaration.java",
                "startLine": 119,
                "endLine": 130,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private TypeNode getTypeNode() {\n        if (isRecordComponent()) {\n            return (TypeNode) node.getParent().getFirstChildOfType(ASTType.class).getChild(0);\n        }\n        if (isPrimitiveType()) {\n            return (TypeNode) getAccessNodeParent().getFirstChildOfType(ASTType.class).getChild(0);\n        }\n        if (!isTypeInferred()) {\n            return (TypeNode) getAccessNodeParent().getFirstChildOfType(ASTType.class).getChild(0).getChild(0);\n        }\n        return null;\n    }",
        "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/VariableNameDeclaration.java",
        "isPureRefactoring": true,
        "commitId": "30b76285e3d65ecc946ebeb7315e95abfda451b9",
        "packageNameBefore": "net.sourceforge.pmd.lang.java.symboltable",
        "classNameBefore": "net.sourceforge.pmd.lang.java.symboltable.VariableNameDeclaration",
        "methodNameBefore": "net.sourceforge.pmd.lang.java.symboltable.VariableNameDeclaration#getTypeNode",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.java.symboltable.VariableNameDeclaration#getAccessNodeParent\n methodBody: public AccessNode getAccessNodeParent() {\nif(isRecordComponent()){return null;\n}if(node.getParent() instanceof ASTFormalParameter || node.getParent() instanceof ASTLambdaExpression){return (AccessNode)node.getParent();\n}return (AccessNode)node.getParent().getParent();\n}\nmethodSignature: net.sourceforge.pmd.lang.java.rule.performance.InefficientStringBufferingRule#isPrimitiveType\n methodBody: private boolean isPrimitiveType(ASTName name) {\nASTType type=getTypeNode(name);\nreturn type != null && !type.findChildrenOfType(ASTPrimitiveType.class).isEmpty();\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symboltable.VariableNameDeclaration#isPrimitiveType\n methodBody: public boolean isPrimitiveType() {\nreturn !isTypeInferred() && getAccessNodeParent().getFirstChildOfType(ASTType.class).getChild(0) instanceof ASTPrimitiveType;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symboltable.VariableNameDeclaration#isTypeInferred\n methodBody: public boolean isTypeInferred() {\nreturn getDeclaratorId().isTypeInferred();\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symboltable.ClassNameDeclaration#getAccessNodeParent\n methodBody: public Node getAccessNodeParent() {\nreturn node;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.symboltable.VariableNameDeclaration#isRecordComponent\n methodBody: private boolean isRecordComponent() {\nreturn node.getParent() instanceof ASTRecordComponent;\n}",
        "classSignatureBefore": "public class VariableNameDeclaration extends AbstractNameDeclaration implements TypedNameDeclaration ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.symboltable.VariableNameDeclaration#getTypeNode"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.symboltable.VariableNameDeclaration"
        ],
        "classSignatureBeforeSet": [
            "public class VariableNameDeclaration extends AbstractNameDeclaration implements TypedNameDeclaration "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.symboltable;\n\nimport net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;\nimport net.sourceforge.pmd.lang.java.ast.ASTLambdaExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimitiveType;\nimport net.sourceforge.pmd.lang.java.ast.ASTRecordComponent;\nimport net.sourceforge.pmd.lang.java.ast.ASTReferenceType;\nimport net.sourceforge.pmd.lang.java.ast.ASTType;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;\nimport net.sourceforge.pmd.lang.java.ast.AccessNode;\nimport net.sourceforge.pmd.lang.java.ast.Dimensionable;\nimport net.sourceforge.pmd.lang.java.ast.TypeNode;\nimport net.sourceforge.pmd.lang.symboltable.AbstractNameDeclaration;\nimport net.sourceforge.pmd.lang.symboltable.Scope;\n\npublic class VariableNameDeclaration extends AbstractNameDeclaration implements TypedNameDeclaration {\n\n    public VariableNameDeclaration(ASTVariableDeclaratorId node) {\n        super(node);\n    }\n\n    @Override\n    public Scope getScope() {\n        return node.getScope().getEnclosingScope(ClassScope.class);\n    }\n\n    public boolean isArray() {\n        ASTVariableDeclaratorId astVariableDeclaratorId = (ASTVariableDeclaratorId) node;\n        ASTType typeNode = astVariableDeclaratorId.getTypeNode();\n        if (typeNode != null) {\n            return ((Dimensionable) typeNode.getParent()).isArray();\n        } else {\n            return false;\n        }\n    }\n\n    public int getArrayDepth() {\n        ASTVariableDeclaratorId astVariableDeclaratorId = (ASTVariableDeclaratorId) node;\n        ASTType typeNode = astVariableDeclaratorId.getTypeNode();\n        if (typeNode != null) {\n            return ((Dimensionable) typeNode.getParent()).getArrayDepth();\n        } else {\n            return 0;\n        }\n    }\n\n    public boolean isVarargs() {\n        ASTVariableDeclaratorId astVariableDeclaratorId = (ASTVariableDeclaratorId) node;\n        ASTFormalParameter parameter = astVariableDeclaratorId.getFirstParentOfType(ASTFormalParameter.class);\n        return parameter != null && parameter.isVarargs();\n    }\n\n    public boolean isExceptionBlockParameter() {\n        return getDeclaratorId().isExceptionBlockParameter();\n    }\n\n    /**\n     * @deprecated use {@link #isTypeInferred()}\n     */\n    @Deprecated\n    public boolean isLambdaTypelessParameter() {\n        return isTypeInferred();\n    }\n\n    public boolean isTypeInferred() {\n        return getDeclaratorId().isTypeInferred();\n    }\n\n    public boolean isPrimitiveType() {\n        return !isTypeInferred()\n                && getAccessNodeParent().getFirstChildOfType(ASTType.class).getChild(0) instanceof ASTPrimitiveType;\n    }\n\n    @Override\n    public String getTypeImage() {\n        TypeNode typeNode = getTypeNode();\n        if (typeNode != null) {\n            return typeNode.getImage();\n        }\n        return null;\n    }\n\n    /**\n     * Note that an array of primitive types (int[]) is a reference type.\n     */\n    public boolean isReferenceType() {\n        return !isTypeInferred()\n                && getAccessNodeParent().getFirstChildOfType(ASTType.class).getChild(0) instanceof ASTReferenceType;\n    }\n\n    private boolean isRecordComponent() {\n        return node.getParent() instanceof ASTRecordComponent;\n    }\n\n    public AccessNode getAccessNodeParent() {\n        if (isRecordComponent()) {\n            return null;\n        }\n\n        if (node.getParent() instanceof ASTFormalParameter || node.getParent() instanceof ASTLambdaExpression) {\n            return (AccessNode) node.getParent();\n        }\n        return (AccessNode) node.getParent().getParent();\n    }\n\n    public ASTVariableDeclaratorId getDeclaratorId() {\n        return (ASTVariableDeclaratorId) node;\n    }\n\n    private TypeNode getTypeNode() {\n        if (isRecordComponent()) {\n            return (TypeNode) node.getParent().getFirstChildOfType(ASTType.class).getChild(0);\n        }\n        if (isPrimitiveType()) {\n            return (TypeNode) getAccessNodeParent().getFirstChildOfType(ASTType.class).getChild(0);\n        }\n        if (!isTypeInferred()) {\n            return (TypeNode) getAccessNodeParent().getFirstChildOfType(ASTType.class).getChild(0).getChild(0);\n        }\n        return null;\n    }\n\n    @Override\n    public Class<?> getType() {\n        TypeNode typeNode = getTypeNode();\n        if (typeNode != null) {\n            return typeNode.getType();\n        }\n        // if there is no type node, then return the type of the declarator id.\n        // this might be a inferred type\n        return getDeclaratorId().getType();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (!(o instanceof VariableNameDeclaration)) {\n            return false;\n        }\n        VariableNameDeclaration n = (VariableNameDeclaration) o;\n        return n.node.getImage().equals(node.getImage());\n    }\n\n    @Override\n    public int hashCode() {\n        return node.getImage().hashCode();\n    }\n\n    @Override\n    public String toString() {\n        return \"Variable: image = '\" + node.getImage() + \"', line = \" + node.getBeginLine();\n    }\n}\n",
        "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/symboltable/VariableNameDeclaration.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.symboltable;\n\nimport net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;\nimport net.sourceforge.pmd.lang.java.ast.ASTLambdaExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimitiveType;\nimport net.sourceforge.pmd.lang.java.ast.ASTRecordComponent;\nimport net.sourceforge.pmd.lang.java.ast.ASTReferenceType;\nimport net.sourceforge.pmd.lang.java.ast.ASTType;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;\nimport net.sourceforge.pmd.lang.java.ast.AccessNode;\nimport net.sourceforge.pmd.lang.java.ast.Dimensionable;\nimport net.sourceforge.pmd.lang.java.ast.TypeNode;\nimport net.sourceforge.pmd.lang.symboltable.AbstractNameDeclaration;\nimport net.sourceforge.pmd.lang.symboltable.Scope;\n\npublic class VariableNameDeclaration extends AbstractNameDeclaration implements TypedNameDeclaration {\n\n    public VariableNameDeclaration(ASTVariableDeclaratorId node) {\n        super(node);\n    }\n\n    @Override\n    public Scope getScope() {\n        return node.getScope().getEnclosingScope(ClassScope.class);\n    }\n\n    public boolean isArray() {\n        ASTVariableDeclaratorId astVariableDeclaratorId = (ASTVariableDeclaratorId) node;\n        ASTType typeNode = astVariableDeclaratorId.getTypeNode();\n        if (typeNode != null) {\n            return ((Dimensionable) typeNode.getParent()).isArray();\n        } else {\n            return false;\n        }\n    }\n\n    public int getArrayDepth() {\n        ASTVariableDeclaratorId astVariableDeclaratorId = (ASTVariableDeclaratorId) node;\n        ASTType typeNode = astVariableDeclaratorId.getTypeNode();\n        if (typeNode != null) {\n            return ((Dimensionable) typeNode.getParent()).getArrayDepth();\n        } else {\n            return 0;\n        }\n    }\n\n    public boolean isVarargs() {\n        ASTVariableDeclaratorId astVariableDeclaratorId = (ASTVariableDeclaratorId) node;\n        ASTFormalParameter parameter = astVariableDeclaratorId.getFirstParentOfType(ASTFormalParameter.class);\n        return parameter != null && parameter.isVarargs();\n    }\n\n    public boolean isExceptionBlockParameter() {\n        return getDeclaratorId().isExceptionBlockParameter();\n    }\n\n    /**\n     * @deprecated use {@link #isTypeInferred()}\n     */\n    @Deprecated\n    public boolean isLambdaTypelessParameter() {\n        return isTypeInferred();\n    }\n\n    public boolean isTypeInferred() {\n        return getDeclaratorId().isTypeInferred();\n    }\n\n    public boolean isPrimitiveType() {\n        return !isTypeInferred()\n                && getAccessNodeParent().getFirstChildOfType(ASTType.class).getChild(0) instanceof ASTPrimitiveType;\n    }\n\n    @Override\n    public String getTypeImage() {\n        TypeNode typeNode = getExplicitTypeNode();\n        if (typeNode != null) {\n            return typeNode.getImage();\n        }\n        return null;\n    }\n\n    /**\n     * Note that an array of primitive types (int[]) is a reference type.\n     */\n    public boolean isReferenceType() {\n        return !isTypeInferred()\n                && getAccessNodeParent().getFirstChildOfType(ASTType.class).getChild(0) instanceof ASTReferenceType;\n    }\n\n    private boolean isRecordComponent() {\n        return node.getParent() instanceof ASTRecordComponent;\n    }\n\n    public AccessNode getAccessNodeParent() {\n        if (isRecordComponent()) {\n            return null;\n        }\n\n        if (node.getParent() instanceof ASTFormalParameter || node.getParent() instanceof ASTLambdaExpression) {\n            return (AccessNode) node.getParent();\n        }\n        return (AccessNode) node.getParent().getParent();\n    }\n\n    public ASTVariableDeclaratorId getDeclaratorId() {\n        return (ASTVariableDeclaratorId) node;\n    }\n\n    @Override\n    public TypeNode getTypeNode() {\n        return getDeclaratorId();\n    }\n\n    private TypeNode getExplicitTypeNode() {\n        if (isRecordComponent()) {\n            return (TypeNode) node.getParent().getFirstChildOfType(ASTType.class).getChild(0);\n        }\n        if (isPrimitiveType()) {\n            return (TypeNode) getAccessNodeParent().getFirstChildOfType(ASTType.class).getChild(0);\n        }\n        if (!isTypeInferred()) {\n            return (TypeNode) getAccessNodeParent().getFirstChildOfType(ASTType.class).getChild(0).getChild(0);\n        }\n        return null;\n    }\n\n    @Override\n    public Class<?> getType() {\n        TypeNode typeNode = getExplicitTypeNode();\n        if (typeNode != null) {\n            return typeNode.getType();\n        }\n        // if there is no type node, then return the type of the declarator id.\n        // this might be a inferred type\n        return getDeclaratorId().getType();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (!(o instanceof VariableNameDeclaration)) {\n            return false;\n        }\n        VariableNameDeclaration n = (VariableNameDeclaration) o;\n        return n.node.getImage().equals(node.getImage());\n    }\n\n    @Override\n    public int hashCode() {\n        return node.getImage().hashCode();\n    }\n\n    @Override\n    public String toString() {\n        return \"Variable: image = '\" + node.getImage() + \"', line = \" + node.getBeginLine();\n    }\n}\n",
        "diffSourceCodeSet": [
            "private TypeNode getExplicitTypeNode() {\n        if (isRecordComponent()) {\n            return (TypeNode) node.getParent().getFirstChildOfType(ASTType.class).getChild(0);\n        }\n        if (isPrimitiveType()) {\n            return (TypeNode) getAccessNodeParent().getFirstChildOfType(ASTType.class).getChild(0);\n        }\n        if (!isTypeInferred()) {\n            return (TypeNode) getAccessNodeParent().getFirstChildOfType(ASTType.class).getChild(0).getChild(0);\n        }\n        return null;\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.java.symboltable.VariableNameDeclaration#getAccessNodeParent\n methodBody: public AccessNode getAccessNodeParent() {\nif(isRecordComponent()){return null;\n}if(node.getParent() instanceof ASTFormalParameter || node.getParent() instanceof ASTLambdaExpression){return (AccessNode)node.getParent();\n}return (AccessNode)node.getParent().getParent();\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.rule.performance.InefficientStringBufferingRule#isPrimitiveType\n methodBody: private boolean isPrimitiveType(ASTName name) {\nASTType type=getTypeNode(name);\nreturn type != null && !type.findChildrenOfType(ASTPrimitiveType.class).isEmpty();\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.symboltable.VariableNameDeclaration#isPrimitiveType\n methodBody: public boolean isPrimitiveType() {\nreturn !isTypeInferred() && getAccessNodeParent().getFirstChildOfType(ASTType.class).getChild(0) instanceof ASTPrimitiveType;\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.symboltable.VariableNameDeclaration#isTypeInferred\n methodBody: public boolean isTypeInferred() {\nreturn getDeclaratorId().isTypeInferred();\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.symboltable.ClassNameDeclaration#getAccessNodeParent\n methodBody: public Node getAccessNodeParent() {\nreturn node;\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.symboltable.VariableNameDeclaration#isRecordComponent\n methodBody: private boolean isRecordComponent() {\nreturn node.getParent() instanceof ASTRecordComponent;\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n    public TypeNode getTypeNode() {\n        return getDeclaratorId();\n    }\nprivate TypeNode getExplicitTypeNode() {\n        if (isRecordComponent()) {\n            return (TypeNode) node.getParent().getFirstChildOfType(ASTType.class).getChild(0);\n        }\n        if (isPrimitiveType()) {\n            return (TypeNode) getAccessNodeParent().getFirstChildOfType(ASTType.class).getChild(0);\n        }\n        if (!isTypeInferred()) {\n            return (TypeNode) getAccessNodeParent().getFirstChildOfType(ASTType.class).getChild(0).getChild(0);\n        }\n        return null;\n    }",
        "diffSourceCode": "-  114:     private TypeNode getTypeNode() {\n-  115:         if (isRecordComponent()) {\n-  116:             return (TypeNode) node.getParent().getFirstChildOfType(ASTType.class).getChild(0);\n-  117:         }\n-  118:         if (isPrimitiveType()) {\n-  119:             return (TypeNode) getAccessNodeParent().getFirstChildOfType(ASTType.class).getChild(0);\n-  120:         }\n-  121:         if (!isTypeInferred()) {\n-  122:             return (TypeNode) getAccessNodeParent().getFirstChildOfType(ASTType.class).getChild(0).getChild(0);\n-  123:         }\n-  124:         return null;\n-  125:     }\n-  126: \n-  127:     @Override\n-  128:     public Class<?> getType() {\n-  129:         TypeNode typeNode = getTypeNode();\n-  130:         if (typeNode != null) {\n+  114:     @Override\n+  115:     public TypeNode getTypeNode() {\n+  116:         return getDeclaratorId();\n+  117:     }\n+  118: \n+  119:     private TypeNode getExplicitTypeNode() {\n+  120:         if (isRecordComponent()) {\n+  121:             return (TypeNode) node.getParent().getFirstChildOfType(ASTType.class).getChild(0);\n+  122:         }\n+  123:         if (isPrimitiveType()) {\n+  124:             return (TypeNode) getAccessNodeParent().getFirstChildOfType(ASTType.class).getChild(0);\n+  125:         }\n+  126:         if (!isTypeInferred()) {\n+  127:             return (TypeNode) getAccessNodeParent().getFirstChildOfType(ASTType.class).getChild(0).getChild(0);\n+  128:         }\n+  129:         return null;\n+  130:     }\n",
        "uniqueId": "30b76285e3d65ecc946ebeb7315e95abfda451b9_114_125_119_130_114_117",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 42
            },
            "BRANCH": {
                "missed": 0,
                "covered": 6
            },
            "LINE": {
                "missed": 0,
                "covered": 7
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 4
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate getInfoAboutForIndexVar(init ASTForInit) : Entry<VariableNameDeclaration,List<NameOccurrence>> extracted from private getIndexVarDeclaration(init ASTForInit, update ASTForUpdate) : Entry<VariableNameDeclaration,List<NameOccurrence>> in class net.sourceforge.pmd.lang.java.rule.bestpractices.ForLoopCanBeForeachRule",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/ForLoopCanBeForeachRule.java",
                "startLine": 114,
                "endLine": 143,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/ForLoopCanBeForeachRule.java",
                "startLine": 104,
                "endLine": 112,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/ForLoopCanBeForeachRule.java",
                "startLine": 165,
                "endLine": 177,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private Entry<VariableNameDeclaration, List<NameOccurrence>> getIndexVarDeclaration(ASTForInit init, ASTForUpdate update) {\n        if (init == null) {\n            return guessIndexVarFromUpdate(update);\n        }\n\n        ASTLocalVariableDeclaration decl = init.getFirstChildOfType(ASTLocalVariableDeclaration.class);\n        if (decl == null) {\n            return null;\n        }\n\n        int numDeclaredVars = decl.findChildrenOfType(ASTVariableDeclarator.class).size();\n        if (numDeclaredVars > 1) {\n            return null; // will abort in the calling function\n        }\n\n        Map<VariableNameDeclaration, List<NameOccurrence>> decls = init.getScope().getDeclarations(VariableNameDeclaration.class);\n        Entry<VariableNameDeclaration, List<NameOccurrence>> indexVarAndOccurrences = null;\n\n        for (Entry<VariableNameDeclaration, List<NameOccurrence>> e : decls.entrySet()) {\n\n            ASTForInit declInit = e.getKey().getNode().getFirstParentOfType(ASTForInit.class);\n            if (Objects.equals(declInit, init)) {\n                indexVarAndOccurrences = e;\n                break;\n            }\n        }\n\n        return indexVarAndOccurrences;\n\n    }",
        "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/ForLoopCanBeForeachRule.java",
        "isPureRefactoring": true,
        "commitId": "7af212fcde976c431640003c4692d3ccf589a335",
        "packageNameBefore": "net.sourceforge.pmd.lang.java.rule.bestpractices",
        "classNameBefore": "net.sourceforge.pmd.lang.java.rule.bestpractices.ForLoopCanBeForeachRule",
        "methodNameBefore": "net.sourceforge.pmd.lang.java.rule.bestpractices.ForLoopCanBeForeachRule#getIndexVarDeclaration",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.java.rule.bestpractices.ForLoopCanBeForeachRule#guessIndexVarFromUpdate\n methodBody: private Entry<VariableNameDeclaration, List<NameOccurrence>> guessIndexVarFromUpdate(ASTForUpdate update) {\nNode name=null;\ntryList<Node> match=update.findChildNodesWithXPath(getSimpleForUpdateXpath(null));\nif(!match.isEmpty()){name=match.get(0);\n}catch(JaxenException je)throw new RuntimeException(je);\nif(name == null || name.getImage() == null){return null;\n}return findDeclaration(name.getImage(),update.getScope().getParent());\n}",
        "classSignatureBefore": "public class ForLoopCanBeForeachRule extends AbstractJavaRule ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.rule.bestpractices.ForLoopCanBeForeachRule#getIndexVarDeclaration"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.rule.bestpractices.ForLoopCanBeForeachRule"
        ],
        "classSignatureBeforeSet": [
            "public class ForLoopCanBeForeachRule extends AbstractJavaRule "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.rule.bestpractices;\n\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.Optional;\n\nimport org.jaxen.JaxenException;\n\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.ast.NodeStream;\nimport net.sourceforge.pmd.lang.java.ast.ASTAdditiveExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTForInit;\nimport net.sourceforge.pmd.lang.java.ast.ASTForStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTForUpdate;\nimport net.sourceforge.pmd.lang.java.ast.ASTLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTLocalVariableDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTName;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimarySuffix;\nimport net.sourceforge.pmd.lang.java.ast.ASTRelationalExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableDeclarator;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableInitializer;\nimport net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;\nimport net.sourceforge.pmd.lang.java.symboltable.VariableNameDeclaration;\nimport net.sourceforge.pmd.lang.java.typeresolution.TypeHelper;\nimport net.sourceforge.pmd.lang.symboltable.NameOccurrence;\nimport net.sourceforge.pmd.lang.symboltable.Scope;\nimport net.sourceforge.pmd.lang.symboltable.ScopedNode;\n\n/**\n * @author Cl\u00e9ment Fournier\n * @since 6.0.0\n */\npublic class ForLoopCanBeForeachRule extends AbstractJavaRule {\n\n    public ForLoopCanBeForeachRule() {\n        addRuleChainVisit(ASTForStatement.class);\n    }\n\n    @Override\n    public Object visit(ASTForStatement node, Object data) {\n\n        final ASTForInit init = node.getFirstChildOfType(ASTForInit.class);\n        final ASTForUpdate update = node.getFirstChildOfType(ASTForUpdate.class);\n        final ASTExpression guardCondition = node.getFirstChildOfType(ASTExpression.class);\n\n        if (init == null && update == null || guardCondition == null) {\n            return data;\n        }\n\n        Entry<VariableNameDeclaration, List<NameOccurrence>> indexDecl = getIndexVarDeclaration(init, update);\n\n        if (indexDecl == null) {\n            return data;\n        }\n\n\n        List<NameOccurrence> occurrences = indexDecl.getValue();\n        VariableNameDeclaration index = indexDecl.getKey();\n\n        if (TypeHelper.isExactlyAny(index, Iterator.class)) {\n            Entry<VariableNameDeclaration, List<NameOccurrence>> iterableInfo = getIterableDeclOfIteratorLoop(index, node.getScope());\n\n            if (iterableInfo != null && isReplaceableIteratorLoop(indexDecl, guardCondition, iterableInfo, node)) {\n                addViolation(data, node);\n            }\n            return data;\n        }\n\n\n        if (occurrences == null || !\"int\".equals(index.getTypeImage()) || !indexStartsAtZero(index)) {\n            return data;\n        }\n\n\n        String itName = index.getName();\n        Optional<String> iterableName = getIterableNameOrEmptyToAbort(guardCondition, itName);\n\n\n        if (!isForUpdateSimpleEnough(update, itName) || iterableName.map(String::isEmpty).orElse(true)) {\n            return data;\n        }\n\n        Entry<VariableNameDeclaration, List<NameOccurrence>> iterableInfo = findDeclaration(iterableName.get(), node.getScope());\n        VariableNameDeclaration iterableDeclaration = iterableInfo == null ? null : iterableInfo.getKey();\n\n        if (iterableDeclaration == null) {\n            return data;\n        }\n\n        if (iterableDeclaration.isArray() && isReplaceableArrayLoop(node, occurrences, iterableDeclaration)) {\n            addViolation(data, node);\n        } else if (iterableDeclaration.getTypeImage() != null && iterableDeclaration.getTypeImage()\n                                                                                    .matches(\"List|ArrayList|LinkedList\")\n            && isReplaceableListLoop(node, occurrences, iterableDeclaration)) {\n            addViolation(data, node);\n        }\n\n        return data;\n    }\n\n\n    /* Finds the declaration of the index variable and its occurrences, null to abort */\n    private Entry<VariableNameDeclaration, List<NameOccurrence>> getIndexVarDeclaration(ASTForInit init, ASTForUpdate update) {\n        if (init == null) {\n            return guessIndexVarFromUpdate(update);\n        }\n\n        ASTLocalVariableDeclaration decl = init.getFirstChildOfType(ASTLocalVariableDeclaration.class);\n        if (decl == null) {\n            return null;\n        }\n\n        int numDeclaredVars = decl.findChildrenOfType(ASTVariableDeclarator.class).size();\n        if (numDeclaredVars > 1) {\n            return null; // will abort in the calling function\n        }\n\n        Map<VariableNameDeclaration, List<NameOccurrence>> decls = init.getScope().getDeclarations(VariableNameDeclaration.class);\n        Entry<VariableNameDeclaration, List<NameOccurrence>> indexVarAndOccurrences = null;\n\n        for (Entry<VariableNameDeclaration, List<NameOccurrence>> e : decls.entrySet()) {\n\n            ASTForInit declInit = e.getKey().getNode().getFirstParentOfType(ASTForInit.class);\n            if (Objects.equals(declInit, init)) {\n                indexVarAndOccurrences = e;\n                break;\n            }\n        }\n\n        return indexVarAndOccurrences;\n\n    }\n\n\n    /** Does a best guess to find the index variable, gives up if the update has several statements */\n    private Entry<VariableNameDeclaration, List<NameOccurrence>> guessIndexVarFromUpdate(ASTForUpdate update) {\n\n        Node name = null;\n        try {\n            List<Node> match = update.findChildNodesWithXPath(getSimpleForUpdateXpath(null));\n            if (!match.isEmpty()) {\n                name = match.get(0);\n            }\n        } catch (JaxenException je) {\n            throw new RuntimeException(je);\n        }\n\n        if (name == null || name.getImage() == null) {\n            return null;\n        }\n\n        return findDeclaration(name.getImage(), update.getScope().getParent());\n    }\n\n\n    /**\n     * @return true if there's only one update statement of the form i++ or ++i.\n     */\n    private boolean isForUpdateSimpleEnough(ASTForUpdate update, String itName) {\n        return update != null && update.hasDescendantMatchingXPath(getSimpleForUpdateXpath(itName));\n    }\n\n\n    private String getSimpleForUpdateXpath(String itName) {\n        return \"./StatementExpressionList[count(*)=1]\"\n            + \"/StatementExpression\"\n            + \"/*[self::PostfixExpression and @Image='++' or self::PreIncrementExpression]\"\n            + \"/PrimaryExpression\"\n            + \"/PrimaryPrefix\"\n            + \"/Name\"\n            + (itName == null ? \"\" : \"[@Image='\" + itName + \"']\");\n    }\n\n\n    /* We only report loops with int initializers starting at zero. */\n    private boolean indexStartsAtZero(VariableNameDeclaration index) {\n        ASTVariableDeclaratorId name = (ASTVariableDeclaratorId) index.getNode();\n        ASTVariableDeclarator declarator = name.getFirstParentOfType(ASTVariableDeclarator.class);\n\n        if (declarator == null) {\n            return false;\n        }\n\n        try {\n            List<Node> zeroLiteral = declarator.findChildNodesWithXPath(\n                \"./VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/Literal[@Image='0' and \"\n                    + \"@StringLiteral='false']\");\n            if (!zeroLiteral.isEmpty()) {\n                return true;\n            }\n        } catch (JaxenException je) {\n            throw new RuntimeException(je);\n        }\n\n        return false;\n\n    }\n\n\n    /**\n     * Gets the name of the iterable array or list.\n     *\n     * @param itName The name of the iterator variable\n     *\n     * @return The name, or null if it couldn't be found or the guard condition is not safe to refactor (then abort)\n     */\n    private Optional<String> getIterableNameOrEmptyToAbort(ASTExpression guardCondition, String itName) {\n\n\n        if (guardCondition.jjtGetNumChildren() > 0\n            && guardCondition.jjtGetChild(0) instanceof ASTRelationalExpression) {\n\n            ASTRelationalExpression relationalExpression = (ASTRelationalExpression) guardCondition.jjtGetChild(0);\n\n            if (relationalExpression.hasImageEqualTo(\"<\") || relationalExpression.hasImageEqualTo(\"<=\")) {\n\n                boolean leftIsIndexVarName =\n                    guardCondition\n                        .singletonStream()\n                        .children(ASTRelationalExpression.class)\n                        .children(ASTPrimaryExpression.class)\n                        .children(ASTPrimaryPrefix.class)\n                        .children(ASTName.class)\n                        .withImage(itName)\n                        .any();\n\n                if (!leftIsIndexVarName) {\n                    return Optional.empty();\n                }\n\n                return guardCondition.singletonStream()\n                                     .children(ASTRelationalExpression.class)\n                                     .forkJoin(\n                                         rel -> NodeStream.of(rel).withImage(\"<\"),\n                                         rel -> NodeStream.of(rel)\n                                                          .withImage(\"<=\")\n                                                          .children(ASTAdditiveExpression.class)\n                                                          .filter(expr ->\n                                                               expr.jjtGetNumChildren() == 2\n                                                                   && expr.getOperator().equals(\"-\")\n                                                                   && expr.singletonStream()\n                                                                          .children(ASTPrimaryExpression.class)\n                                                                          .children(ASTPrimaryPrefix.class)\n                                                                          .children(ASTLiteral.class)\n                                                                          .withImage(\"1\")\n                                                                          .any()\n                                                   )\n                                     )\n                                     .children(ASTPrimaryExpression.class)\n                                     .children(ASTPrimaryPrefix.class)\n                                     .children(ASTName.class)\n                                     .imageMatching(\"\\\\w+\\\\.(size|length)\")\n                                     .findFirst()\n                                     .map(astName -> astName.getImage().split(\"\\\\.\")[0]);\n\n            }\n        }\n        return Optional.empty();\n    }\n\n\n    private Entry<VariableNameDeclaration, List<NameOccurrence>> getIterableDeclOfIteratorLoop(VariableNameDeclaration indexDecl, Scope scope) {\n        Node initializer = indexDecl.getNode().getFirstParentOfType(ASTVariableDeclarator.class)\n                                    .getFirstChildOfType(ASTVariableInitializer.class);\n\n        if (initializer == null) {\n            return null;\n        }\n\n        ASTName nameNode = initializer.getFirstDescendantOfType(ASTName.class);\n        if (nameNode == null) {\n            // TODO : This can happen if we are calling a local / statically imported method that returns the iterable - currently unhandled\n            return null;\n        }\n\n        String name = nameNode.getImage();\n        int dotIndex = name.indexOf('.');\n\n        if (dotIndex > 0) {\n            name = name.substring(0, dotIndex);\n        }\n\n        return findDeclaration(name, scope);\n    }\n\n\n    private boolean isReplaceableArrayLoop(ASTForStatement stmt, List<NameOccurrence> occurrences,\n                                           VariableNameDeclaration arrayDeclaration) {\n        String arrayName = arrayDeclaration.getName();\n\n\n        for (NameOccurrence occ : occurrences) {\n\n            if (occ.getLocation().getFirstParentOfType(ASTForUpdate.class) == null\n                && occ.getLocation().getFirstParentOfType(ASTExpression.class)\n                != stmt.getFirstChildOfType(ASTExpression.class)\n                && !occurenceIsArrayAccess(occ, arrayName)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n\n    private boolean occurenceIsArrayAccess(NameOccurrence occ, String arrayName) {\n        if (occ.getLocation() instanceof ASTName) {\n            ASTPrimarySuffix suffix = occ.getLocation().getFirstParentOfType(ASTPrimarySuffix.class);\n\n            if (suffix == null || !suffix.isArrayDereference()) {\n                return false;\n            }\n\n            return suffix.hasDescendantMatchingXPath(\"./Expression/PrimaryExpression[count(*)\"\n                                                         + \"=1]/PrimaryPrefix/Name[@Image='\" + occ.getImage() + \"']\")\n                && suffix.hasDescendantMatchingXPath(\"../PrimaryPrefix/Name[@Image='\" + arrayName + \"']\")\n                && !suffix.hasDescendantMatchingXPath(\"../../AssignmentOperator\");\n        }\n        return false;\n    }\n\n\n    private boolean isReplaceableListLoop(ASTForStatement stmt, List<NameOccurrence> occurrences,\n                                          VariableNameDeclaration listDeclaration) {\n\n        String listName = listDeclaration.getName();\n\n\n        for (NameOccurrence occ : occurrences) {\n\n            if (occ.getLocation().getFirstParentOfType(ASTForUpdate.class) == null\n                && occ.getLocation().getFirstParentOfType(ASTExpression.class)\n                != stmt.getFirstChildOfType(ASTExpression.class)\n                && !occurenceIsListGet(occ, listName)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n\n    /** @return true if this occurence is as an argument to List.get on the correct list */\n    private boolean occurenceIsListGet(NameOccurrence occ, String listName) {\n        if (occ.getLocation() instanceof ASTName) {\n            ASTPrimarySuffix suffix = occ.getLocation().getFirstParentOfType(ASTPrimarySuffix.class);\n\n            if (suffix == null) {\n                return false;\n            }\n\n            Node prefix = suffix.jjtGetParent().jjtGetChild(0);\n\n            if (!(prefix instanceof ASTPrimaryPrefix) || prefix.jjtGetNumChildren() != 1\n                || !(prefix.jjtGetChild(0) instanceof ASTName)) {\n                // it's either not a primary prefix, doesn't have children (can happen with this./super.)\n                // or first child is not a name\n                return false;\n            }\n\n            String callImage = prefix.jjtGetChild(0).getImage();\n\n            return (listName + \".get\").equals(callImage);\n\n        }\n        return false;\n    }\n\n\n    private Entry<VariableNameDeclaration, List<NameOccurrence>> findDeclaration(String varName, Scope innermost) {\n        Scope currentScope = innermost;\n\n        while (currentScope != null) {\n            for (Entry<VariableNameDeclaration, List<NameOccurrence>> e : currentScope.getDeclarations(VariableNameDeclaration.class).entrySet()) {\n                if (e.getKey().getName().equals(varName)) {\n                    return e;\n                }\n            }\n            currentScope = currentScope.getParent();\n        }\n\n        return null;\n    }\n\n\n    private boolean isReplaceableIteratorLoop(Entry<VariableNameDeclaration, List<NameOccurrence>> indexInfo,\n                                              ASTExpression guardCondition,\n                                              Entry<VariableNameDeclaration, List<NameOccurrence>> iterableInfo,\n                                              ASTForStatement stmt) {\n\n        if (isIterableModifiedInsideLoop(iterableInfo, stmt)) {\n            return false;\n        }\n\n\n        String indexName = indexInfo.getKey().getName();\n\n        if (indexName == null) {\n            return false;\n        }\n\n        if (!guardCondition.hasDescendantMatchingXPath(\n            \"./PrimaryExpression/PrimaryPrefix/Name[@Image='\" + indexName + \".hasNext']\")) {\n            return false;\n        }\n\n        List<NameOccurrence> occurrences = indexInfo.getValue();\n\n        if (occurrences.size() > 2) {\n            return false;\n        }\n\n        for (NameOccurrence occ : indexInfo.getValue()) {\n            ScopedNode location = occ.getLocation();\n            boolean isCallingNext = location instanceof ASTName\n                    && (location.hasImageEqualTo(indexName + \".hasNext\")\n                            || location.hasImageEqualTo(indexName + \".next\"));\n\n            if (!isCallingNext) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean isIterableModifiedInsideLoop(Entry<VariableNameDeclaration, List<NameOccurrence>> iterableInfo,\n                                                 ASTForStatement stmt) {\n\n        String iterableName = iterableInfo.getKey().getName();\n        for (NameOccurrence occ : iterableInfo.getValue()) {\n            ASTForStatement forParent = occ.getLocation().getFirstParentOfType(ASTForStatement.class);\n            if (Objects.equals(forParent, stmt)) {\n                String image = occ.getLocation().getImage();\n                if (image.startsWith(iterableName + \".remove\")) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n\n}\n",
        "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/ForLoopCanBeForeachRule.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.rule.bestpractices;\n\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.Optional;\n\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.ast.NodeStream;\nimport net.sourceforge.pmd.lang.java.ast.ASTAdditiveExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTAssignmentOperator;\nimport net.sourceforge.pmd.lang.java.ast.ASTExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTForInit;\nimport net.sourceforge.pmd.lang.java.ast.ASTForStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTForUpdate;\nimport net.sourceforge.pmd.lang.java.ast.ASTLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTLocalVariableDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.ASTName;\nimport net.sourceforge.pmd.lang.java.ast.ASTPostfixExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTPreIncrementExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimarySuffix;\nimport net.sourceforge.pmd.lang.java.ast.ASTRelationalExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTStatementExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTStatementExpressionList;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableDeclarator;\nimport net.sourceforge.pmd.lang.java.ast.ASTVariableInitializer;\nimport net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;\nimport net.sourceforge.pmd.lang.java.symboltable.VariableNameDeclaration;\nimport net.sourceforge.pmd.lang.java.typeresolution.TypeHelper;\nimport net.sourceforge.pmd.lang.symboltable.NameOccurrence;\nimport net.sourceforge.pmd.lang.symboltable.Scope;\n\n/**\n * @author Cl\u00e9ment Fournier\n * @since 6.0.0\n */\npublic class ForLoopCanBeForeachRule extends AbstractJavaRule {\n\n    public ForLoopCanBeForeachRule() {\n        addRuleChainVisit(ASTForStatement.class);\n    }\n\n    @Override\n    public Object visit(ASTForStatement node, Object data) {\n\n        if (node.isForeach()) {\n            return data;\n        }\n\n        final ASTForInit init = node.getFirstChildOfType(ASTForInit.class);\n        final ASTForUpdate update = node.getFirstChildOfType(ASTForUpdate.class);\n        final ASTExpression guardCondition = node.getFirstChildOfType(ASTExpression.class);\n\n        if (init == null && update == null || guardCondition == null) {\n            return data;\n        }\n\n        Optional<Entry<VariableNameDeclaration, List<NameOccurrence>>> indexDecl = getIndexVarDeclaration(init, update);\n\n        if (!indexDecl.isPresent()) {\n            return data;\n        }\n\n        final List<NameOccurrence> occurrences = indexDecl.get().getValue();\n        final VariableNameDeclaration index = indexDecl.get().getKey();\n\n        if (TypeHelper.isExactlyAny(index, Iterator.class)) {\n            getIterableDeclOfIteratorLoop(index, node.getScope())\n                .filter(iterableInfo -> isReplaceableIteratorLoop(indexDecl.get(), guardCondition, iterableInfo, node))\n                .ifPresent(ignored -> addViolation(data, node));\n\n            return data;\n        }\n\n        if (occurrences == null\n            || !\"int\".equals(index.getTypeImage())\n            || !indexStartsAtZero(index)\n            || !isForUpdateSimpleEnough(update)) {\n\n            return data;\n        }\n\n        findIterableName(guardCondition, index.getName())\n            .flatMap(iterableName -> findDeclaration(iterableName, node.getScope()))\n            .map(Entry::getKey)\n            .filter(iterableDecl ->\n                        isReplaceableArrayLoop(node, occurrences, iterableDecl)\n                            || isReplaceableListLoop(node, occurrences, iterableDecl))\n            .ifPresent(decl -> addViolation(data, node));\n\n        return data;\n    }\n\n\n    /* Finds the declaration of the index variable and its occurrences, null to abort */\n    private Optional<Entry<VariableNameDeclaration, List<NameOccurrence>>> getIndexVarDeclaration(ASTForInit init, ASTForUpdate update) {\n        if (init == null) {\n            return guessIndexVarFromUpdate(update);\n        }\n\n        return init.children(ASTLocalVariableDeclaration.class)\n                   .first(it -> it.children(ASTVariableDeclarator.class).count() == 1)\n                   .map(decl -> getInfoAboutForIndexVar(init));\n    }\n\n\n\n    /** Does a best guess to find the index variable, gives up if the update has several statements */\n    private Optional<Entry<VariableNameDeclaration, List<NameOccurrence>>> guessIndexVarFromUpdate(ASTForUpdate update) {\n        return simpleForUpdateVarName(update).flatMap(name -> findDeclaration(name, update.getScope().getParent()));\n    }\n\n\n    private boolean isForUpdateSimpleEnough(ASTForUpdate update) {\n        return simpleForUpdateVarName(update).isPresent();\n    }\n\n\n    /**\n     * @return the variable name if there's only one update statement of the form i++ or ++i.\n     */\n    private Optional<String> simpleForUpdateVarName(ASTForUpdate base) {\n        return NodeStream.of(base)\n                         .children(ASTStatementExpressionList.class)\n                         .filter(it -> it.jjtGetNumChildren() == 1)\n                         .children(ASTStatementExpression.class)\n                         .children()\n                         .filter(\n                             it -> it instanceof ASTPostfixExpression && it.hasImageEqualTo(\"++\")\n                                 || it instanceof ASTPreIncrementExpression\n                         )\n                         .children(ASTPrimaryExpression.class)\n                         .children(ASTPrimaryPrefix.class)\n                         .children(ASTName.class)\n                         .first()\n                         .map(Node::getImage);\n    }\n\n\n    /* We only report loops with int initializers starting at zero. */\n    private boolean indexStartsAtZero(VariableNameDeclaration index) {\n\n        return NodeStream.of(index.getNode())\n                         .parents()\n                         .filterIs(ASTVariableDeclarator.class)\n                         .children(ASTVariableInitializer.class)\n                         .children(ASTExpression.class)\n                         .children(ASTPrimaryExpression.class)\n                         .children(ASTPrimaryPrefix.class)\n                         .children(ASTLiteral.class)\n                         .withImage(\"0\")\n                         .filterNot(ASTLiteral::isStringLiteral)\n                         .any();\n    }\n\n\n    private static Entry<VariableNameDeclaration, List<NameOccurrence>> getInfoAboutForIndexVar(ASTForInit init) {\n        Map<VariableNameDeclaration, List<NameOccurrence>> decls = init.getScope().getDeclarations(VariableNameDeclaration.class);\n\n        for (Entry<VariableNameDeclaration, List<NameOccurrence>> e : decls.entrySet()) {\n\n            ASTForInit declInit = e.getKey().getNode().getFirstParentOfType(ASTForInit.class);\n            if (Objects.equals(declInit, init)) {\n                return e;\n            }\n        }\n\n        return null;\n    }\n\n\n    /**\n     * Gets the name of the iterable array or list.\n     *\n     * @param itName The name of the iterator variable\n     *\n     * @return The name, or null if it couldn't be found or the guard condition is not safe to refactor (then abort)\n     */\n    private Optional<String> findIterableName(ASTExpression guardCondition, String itName) {\n\n\n        if (guardCondition.jjtGetNumChildren() > 0\n            && guardCondition.jjtGetChild(0) instanceof ASTRelationalExpression) {\n\n            ASTRelationalExpression relationalExpression = (ASTRelationalExpression) guardCondition.jjtGetChild(0);\n\n            if (relationalExpression.hasImageEqualTo(\"<\") || relationalExpression.hasImageEqualTo(\"<=\")) {\n\n                boolean leftIsIndexVarName =\n                    guardCondition\n                        .singletonStream()\n                        .children(ASTRelationalExpression.class)\n                        .children(ASTPrimaryExpression.class)\n                        .children(ASTPrimaryPrefix.class)\n                        .children(ASTName.class)\n                        .withImage(itName)\n                        .any();\n\n                if (!leftIsIndexVarName) {\n                    return Optional.empty();\n                }\n\n                return guardCondition.singletonStream()\n                                     .children(ASTRelationalExpression.class)\n                                     .forkJoin(\n                                         rel -> NodeStream.of(rel).withImage(\"<\"),\n                                         rel -> NodeStream.of(rel)\n                                                          .withImage(\"<=\")\n                                                          .children(ASTAdditiveExpression.class)\n                                                          .filter(expr ->\n                                                               expr.jjtGetNumChildren() == 2\n                                                                   && expr.getOperator().equals(\"-\")\n                                                                   && expr.singletonStream()\n                                                                          .children(ASTPrimaryExpression.class)\n                                                                          .children(ASTPrimaryPrefix.class)\n                                                                          .children(ASTLiteral.class)\n                                                                          .withImage(\"1\")\n                                                                          .any()\n                                                   )\n                                     )\n                                     .children(ASTPrimaryExpression.class)\n                                     .children(ASTPrimaryPrefix.class)\n                                     .children(ASTName.class)\n                                     .imageMatching(\"\\\\w+\\\\.(size|length)\")\n                                     .first()\n                                     .map(astName -> astName.getImage().split(\"\\\\.\")[0]);\n\n            }\n        }\n        return Optional.empty();\n    }\n\n\n    private Optional<Entry<VariableNameDeclaration, List<NameOccurrence>>> getIterableDeclOfIteratorLoop(VariableNameDeclaration indexDecl, Scope scope) {\n\n        return NodeStream.of(indexDecl.getNode())\n                         .followingSiblings()\n                         .filterIs(ASTVariableInitializer.class)\n                         .descendants(ASTName.class)\n                         .first()             // TODO : This can return null if we are calling a local / statically imported method that returns the iterable - currently unhandled\n                         .flatMap(nameNode -> {\n\n                             String name = nameNode.getImage();\n                             int dotIndex = name.indexOf('.');\n\n                             if (dotIndex > 0) {\n                                 name = name.substring(0, dotIndex);\n                             }\n\n                             return findDeclaration(name, scope);\n                         });\n    }\n\n\n    private boolean isReplaceableArrayLoop(ASTForStatement stmt, List<NameOccurrence> occurrences,\n                                           VariableNameDeclaration arrayDeclaration) {\n\n        if (!arrayDeclaration.isArray()) {\n            return false;\n        }\n\n        String arrayName = arrayDeclaration.getName();\n\n\n        for (NameOccurrence occ : occurrences) {\n\n            if (occ.getLocation().getFirstParentOfType(ASTForUpdate.class) == null\n                && occ.getLocation().getFirstParentOfType(ASTExpression.class)\n                != stmt.getFirstChildOfType(ASTExpression.class)\n                && !occurenceIsArrayAccess(occ, arrayName)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n\n    private boolean occurenceIsArrayAccess(NameOccurrence occ, String arrayName) {\n        if (occ.getLocation() instanceof ASTName) {\n            ASTPrimarySuffix suffix = occ.getLocation().getFirstParentOfType(ASTPrimarySuffix.class);\n\n            if (suffix == null || !suffix.isArrayDereference()) {\n                return false;\n            }\n\n            return suffix.descendants(ASTExpression.class)\n                         .children(ASTPrimaryExpression.class)\n                         .filter(it -> it.jjtGetNumChildren() == 1)\n                         .children(ASTPrimaryPrefix.class)\n                         .children(ASTName.class)\n                         .withImage(occ.getImage())\n                         .any()\n                && suffix.singletonStream()\n                         .precedingSiblings()\n                         .filterIs(ASTPrimaryPrefix.class)\n                         .children(ASTName.class)\n                         .withImage(arrayName)\n                         .any()\n\n                && suffix.jjtGetParent()\n                         .jjtGetParent()\n                         .singletonStream()\n                         .children(ASTAssignmentOperator.class)\n                         .none();\n        }\n        return false;\n    }\n\n\n    private boolean isReplaceableListLoop(ASTForStatement stmt, List<NameOccurrence> occurrences,\n                                          VariableNameDeclaration listDeclaration) {\n\n        if (listDeclaration.getTypeImage() == null\n            || !listDeclaration.getTypeImage().matches(\"List|ArrayList|LinkedList\")) {\n            return false;\n        }\n\n        String listName = listDeclaration.getName();\n\n\n        for (NameOccurrence occ : occurrences) {\n\n            if (occ.getLocation().getFirstParentOfType(ASTForUpdate.class) == null\n                && occ.getLocation().getFirstParentOfType(ASTExpression.class)\n                != stmt.getFirstChildOfType(ASTExpression.class)\n                && !occurenceIsListGet(occ, listName)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n\n    /** @return true if this occurence is as an argument to List.get on the correct list */\n    private static boolean occurenceIsListGet(NameOccurrence occ, String listName) {\n        if (occ.getLocation() instanceof ASTName) {\n            ASTPrimarySuffix suffix = occ.getLocation().getFirstParentOfType(ASTPrimarySuffix.class);\n\n            if (suffix == null) {\n                return false;\n            }\n\n            Node prefix = suffix.jjtGetParent().jjtGetChild(0);\n\n            if (!(prefix instanceof ASTPrimaryPrefix) || prefix.jjtGetNumChildren() != 1\n                || !(prefix.jjtGetChild(0) instanceof ASTName)) {\n                // it's either not a primary prefix, doesn't have children (can happen with this./super.)\n                // or first child is not a name\n                return false;\n            }\n\n            String callImage = prefix.jjtGetChild(0).getImage();\n\n            return (listName + \".get\").equals(callImage);\n\n        }\n        return false;\n    }\n\n\n    private static Optional<Entry<VariableNameDeclaration, List<NameOccurrence>>> findDeclaration(String varName, Scope innermost) {\n        Scope currentScope = innermost;\n\n        while (currentScope != null) {\n            for (Entry<VariableNameDeclaration, List<NameOccurrence>> e : currentScope.getDeclarations(VariableNameDeclaration.class).entrySet()) {\n                if (e.getKey().getName().equals(varName)) {\n                    return Optional.of(e);\n                }\n            }\n            currentScope = currentScope.getParent();\n        }\n\n        return Optional.empty();\n    }\n\n\n    private static boolean isReplaceableIteratorLoop(Entry<VariableNameDeclaration, List<NameOccurrence>> indexInfo,\n                                                     ASTExpression guardCondition,\n                                                     Entry<VariableNameDeclaration, List<NameOccurrence>> iterableInfo,\n                                                     ASTForStatement stmt) {\n\n        List<NameOccurrence> occurrences = indexInfo.getValue();\n\n        if (isIterableModifiedInsideLoop(iterableInfo, stmt) || occurrences.size() > 2) {\n            return false;\n        }\n\n        return Optional.ofNullable(indexInfo.getKey().getName())\n                       .filter(indexName -> guardCondition.children(ASTPrimaryExpression.class)\n                                                          .children(ASTPrimaryPrefix.class)\n                                                          .children(ASTName.class)\n                                                          .withImage(indexName + \".hasNext\")\n                                                          .any())\n                       .map(indexName -> occurrences.stream()\n                                                    .map(NameOccurrence::getLocation)\n                                                    .allMatch(n -> isCallingNext(n, indexName)))\n                       .orElse(false);\n    }\n\n\n    private static boolean isCallingNext(Node node, String indexName) {\n        return node instanceof ASTName\n            && (node.hasImageEqualTo(indexName + \".hasNext\")\n            || node.hasImageEqualTo(indexName + \".next\"));\n    }\n\n\n    private static boolean isIterableModifiedInsideLoop(Entry<VariableNameDeclaration, List<NameOccurrence>> iterableInfo,\n                                                        ASTForStatement stmt) {\n\n        return iterableInfo.getValue().stream()\n                           .map(NameOccurrence::getLocation)\n                           .filter(n -> n.ancestorStream()\n                                         .first(ASTForStatement.class)\n                                         .filter(forParent -> Objects.equals(forParent, stmt))\n                                         .isPresent())\n                           .filter(it -> it.hasImageEqualTo(iterableInfo.getKey().getName() + \".remove\"))\n                           .findAny()\n                           .isPresent();\n    }\n\n\n}\n",
        "diffSourceCodeSet": [
            "private static Entry<VariableNameDeclaration, List<NameOccurrence>> getInfoAboutForIndexVar(ASTForInit init) {\n        Map<VariableNameDeclaration, List<NameOccurrence>> decls = init.getScope().getDeclarations(VariableNameDeclaration.class);\n\n        for (Entry<VariableNameDeclaration, List<NameOccurrence>> e : decls.entrySet()) {\n\n            ASTForInit declInit = e.getKey().getNode().getFirstParentOfType(ASTForInit.class);\n            if (Objects.equals(declInit, init)) {\n                return e;\n            }\n        }\n\n        return null;\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.java.rule.bestpractices.ForLoopCanBeForeachRule#guessIndexVarFromUpdate\n methodBody: private Entry<VariableNameDeclaration, List<NameOccurrence>> guessIndexVarFromUpdate(ASTForUpdate update) {\nNode name=null;\ntryList<Node> match=update.findChildNodesWithXPath(getSimpleForUpdateXpath(null));\nif(!match.isEmpty()){name=match.get(0);\n}catch(JaxenException je)throw new RuntimeException(je);\nif(name == null || name.getImage() == null){return null;\n}return findDeclaration(name.getImage(),update.getScope().getParent());\n}"
        ],
        "sourceCodeAfterRefactoring": "private Optional<Entry<VariableNameDeclaration, List<NameOccurrence>>> getIndexVarDeclaration(ASTForInit init, ASTForUpdate update) {\n        if (init == null) {\n            return guessIndexVarFromUpdate(update);\n        }\n\n        return init.children(ASTLocalVariableDeclaration.class)\n                   .first(it -> it.children(ASTVariableDeclarator.class).count() == 1)\n                   .map(decl -> getInfoAboutForIndexVar(init));\n    }\nprivate static Entry<VariableNameDeclaration, List<NameOccurrence>> getInfoAboutForIndexVar(ASTForInit init) {\n        Map<VariableNameDeclaration, List<NameOccurrence>> decls = init.getScope().getDeclarations(VariableNameDeclaration.class);\n\n        for (Entry<VariableNameDeclaration, List<NameOccurrence>> e : decls.entrySet()) {\n\n            ASTForInit declInit = e.getKey().getNode().getFirstParentOfType(ASTForInit.class);\n            if (Objects.equals(declInit, init)) {\n                return e;\n            }\n        }\n\n        return null;\n    }",
        "diffSourceCode": "-  104:                                                                                     .matches(\"List|ArrayList|LinkedList\")\n-  105:             && isReplaceableListLoop(node, occurrences, iterableDeclaration)) {\n-  106:             addViolation(data, node);\n+  104:     private Optional<Entry<VariableNameDeclaration, List<NameOccurrence>>> getIndexVarDeclaration(ASTForInit init, ASTForUpdate update) {\n+  105:         if (init == null) {\n+  106:             return guessIndexVarFromUpdate(update);\n   107:         }\n   108: \n-  109:         return data;\n-  110:     }\n-  111: \n-  112: \n-  114:     private Entry<VariableNameDeclaration, List<NameOccurrence>> getIndexVarDeclaration(ASTForInit init, ASTForUpdate update) {\n-  115:         if (init == null) {\n-  116:             return guessIndexVarFromUpdate(update);\n-  117:         }\n-  118: \n-  119:         ASTLocalVariableDeclaration decl = init.getFirstChildOfType(ASTLocalVariableDeclaration.class);\n-  120:         if (decl == null) {\n-  121:             return null;\n-  122:         }\n-  123: \n-  124:         int numDeclaredVars = decl.findChildrenOfType(ASTVariableDeclarator.class).size();\n-  125:         if (numDeclaredVars > 1) {\n-  126:             return null; // will abort in the calling function\n-  127:         }\n-  128: \n-  129:         Map<VariableNameDeclaration, List<NameOccurrence>> decls = init.getScope().getDeclarations(VariableNameDeclaration.class);\n-  130:         Entry<VariableNameDeclaration, List<NameOccurrence>> indexVarAndOccurrences = null;\n-  131: \n-  132:         for (Entry<VariableNameDeclaration, List<NameOccurrence>> e : decls.entrySet()) {\n-  133: \n-  134:             ASTForInit declInit = e.getKey().getNode().getFirstParentOfType(ASTForInit.class);\n-  135:             if (Objects.equals(declInit, init)) {\n-  136:                 indexVarAndOccurrences = e;\n-  137:                 break;\n-  138:             }\n-  139:         }\n-  140: \n-  141:         return indexVarAndOccurrences;\n-  142: \n-  143:     }\n-  165: \n-  166: \n-  167:     /**\n-  168:      * @return true if there's only one update statement of the form i++ or ++i.\n-  169:      */\n-  170:     private boolean isForUpdateSimpleEnough(ASTForUpdate update, String itName) {\n-  171:         return update != null && update.hasDescendantMatchingXPath(getSimpleForUpdateXpath(itName));\n-  172:     }\n-  173: \n-  174: \n-  175:     private String getSimpleForUpdateXpath(String itName) {\n-  176:         return \"./StatementExpressionList[count(*)=1]\"\n-  177:             + \"/StatementExpression\"\n+  109:         return init.children(ASTLocalVariableDeclaration.class)\n+  110:                    .first(it -> it.children(ASTVariableDeclarator.class).count() == 1)\n+  111:                    .map(decl -> getInfoAboutForIndexVar(init));\n+  112:     }\n+  114: \n+  115: \n+  116:     /** Does a best guess to find the index variable, gives up if the update has several statements */\n+  117:     private Optional<Entry<VariableNameDeclaration, List<NameOccurrence>>> guessIndexVarFromUpdate(ASTForUpdate update) {\n+  118:         return simpleForUpdateVarName(update).flatMap(name -> findDeclaration(name, update.getScope().getParent()));\n+  119:     }\n+  120: \n+  121: \n+  122:     private boolean isForUpdateSimpleEnough(ASTForUpdate update) {\n+  123:         return simpleForUpdateVarName(update).isPresent();\n+  124:     }\n+  125: \n+  126: \n+  127:     /**\n+  128:      * @return the variable name if there's only one update statement of the form i++ or ++i.\n+  129:      */\n+  130:     private Optional<String> simpleForUpdateVarName(ASTForUpdate base) {\n+  131:         return NodeStream.of(base)\n+  132:                          .children(ASTStatementExpressionList.class)\n+  133:                          .filter(it -> it.jjtGetNumChildren() == 1)\n+  134:                          .children(ASTStatementExpression.class)\n+  135:                          .children()\n+  136:                          .filter(\n+  137:                              it -> it instanceof ASTPostfixExpression && it.hasImageEqualTo(\"++\")\n+  138:                                  || it instanceof ASTPreIncrementExpression\n+  139:                          )\n+  140:                          .children(ASTPrimaryExpression.class)\n+  141:                          .children(ASTPrimaryPrefix.class)\n+  142:                          .children(ASTName.class)\n+  143:                          .first()\n+  165:     private static Entry<VariableNameDeclaration, List<NameOccurrence>> getInfoAboutForIndexVar(ASTForInit init) {\n+  166:         Map<VariableNameDeclaration, List<NameOccurrence>> decls = init.getScope().getDeclarations(VariableNameDeclaration.class);\n+  167: \n+  168:         for (Entry<VariableNameDeclaration, List<NameOccurrence>> e : decls.entrySet()) {\n+  169: \n+  170:             ASTForInit declInit = e.getKey().getNode().getFirstParentOfType(ASTForInit.class);\n+  171:             if (Objects.equals(declInit, init)) {\n+  172:                 return e;\n+  173:             }\n+  174:         }\n+  175: \n+  176:         return null;\n+  177:     }\n",
        "uniqueId": "7af212fcde976c431640003c4692d3ccf589a335_114_143_165_177_104_112",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 1,
                "covered": 60
            },
            "BRANCH": {
                "missed": 2,
                "covered": 8
            },
            "LINE": {
                "missed": 1,
                "covered": 16
            },
            "COMPLEXITY": {
                "missed": 2,
                "covered": 4
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprotected processToken(tokenEntries Tokens, currentToken GenericToken, filename String) : TokenEntry extracted from public tokenize(sourceCode SourceCode, tokenEntries Tokens) : void in class net.sourceforge.pmd.cpd.JavaCCTokenizer",
        "diffLocations": [
            {
                "filePath": "pmd-cpp/src/main/java/net/sourceforge/pmd/cpd/CPPTokenizer.java",
                "startLine": 51,
                "endLine": 70,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/cpd/JavaCCTokenizer.java",
                "startLine": 26,
                "endLine": 41,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/cpd/JavaCCTokenizer.java",
                "startLine": 22,
                "endLine": 24,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n    public void tokenize(SourceCode sourceCode, Tokens tokenEntries) {\n        StringBuilder buffer = sourceCode.getCodeBuffer();\n        try (Reader reader = IOUtil.skipBOM(new StringReader(maybeSkipBlocks(buffer.toString())))) {\n            CppTokenManager tokenManager = new CppTokenManager(reader);\n            tokenManager.setFileName(sourceCode.getFileName());\n            final TokenFilter tokenFilter = new JavaCCTokenFilter(tokenManager);\n\n            GenericToken currentToken = tokenFilter.getNextToken();\n            while (currentToken != null) {\n                tokenEntries.add(new TokenEntry(currentToken.getImage(), sourceCode.getFileName(), currentToken.getBeginLine()));\n                currentToken = tokenFilter.getNextToken();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.err.println(\"Error parsing \" + sourceCode.getFileName());\n        } finally {\n            tokenEntries.add(TokenEntry.getEOF());\n        }\n    }",
        "filePathBefore": "pmd-cpp/src/main/java/net/sourceforge/pmd/cpd/CPPTokenizer.java",
        "isPureRefactoring": true,
        "commitId": "08b7dd49dda043f3ac0078c8e071dc7e86e27ada",
        "packageNameBefore": "net.sourceforge.pmd.cpd",
        "classNameBefore": "net.sourceforge.pmd.cpd.CPPTokenizer",
        "methodNameBefore": "net.sourceforge.pmd.cpd.CPPTokenizer#tokenize",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.cpd.CPPTokenizer#maybeSkipBlocks\n methodBody: private String maybeSkipBlocks(String test) throws IOException {\nif(!skipBlocks){return test;\n}BufferedReader reader=new BufferedReader(new StringReader(test));\nStringBuilder filtered=new StringBuilder(test.length());\nString line;\nboolean skip=false;\nwhile((line=reader.readLine()) != null){if(skipBlocksStart.equalsIgnoreCase(line.trim())){skip=true;\n}if(skip && skipBlocksEnd.equalsIgnoreCase(line.trim())){skip=false;\n}if(!skip){filtered.append(line);\n}filtered.append(PMD.EOL);\n}return filtered.toString();\n}",
        "classSignatureBefore": "public class CPPTokenizer implements Tokenizer ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.cpd.CPPTokenizer#tokenize"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.cpd.CPPTokenizer"
        ],
        "classSignatureBeforeSet": [
            "public class CPPTokenizer implements Tokenizer "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics\n",
                "description": "Argument replaced with return expression - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.cpd;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.Properties;\n\nimport net.sourceforge.pmd.PMD;\nimport net.sourceforge.pmd.cpd.token.JavaCCTokenFilter;\nimport net.sourceforge.pmd.cpd.token.TokenFilter;\nimport net.sourceforge.pmd.lang.ast.GenericToken;\nimport net.sourceforge.pmd.lang.cpp.CppTokenManager;\nimport net.sourceforge.pmd.util.IOUtil;\n\n/**\n * The C++ tokenizer.\n */\npublic class CPPTokenizer implements Tokenizer {\n\n    private boolean skipBlocks = true;\n    private String skipBlocksStart;\n    private String skipBlocksEnd;\n\n    /**\n     * Sets the possible options for the C++ tokenizer.\n     * \n     * @param properties\n     *            the properties\n     * @see #OPTION_SKIP_BLOCKS\n     * @see #OPTION_SKIP_BLOCKS_PATTERN\n     */\n    public void setProperties(Properties properties) {\n        skipBlocks = Boolean.parseBoolean(properties.getProperty(OPTION_SKIP_BLOCKS, Boolean.TRUE.toString()));\n        if (skipBlocks) {\n            String skipBlocksPattern = properties.getProperty(OPTION_SKIP_BLOCKS_PATTERN, DEFAULT_SKIP_BLOCKS_PATTERN);\n            String[] split = skipBlocksPattern.split(\"\\\\|\", 2);\n            skipBlocksStart = split[0];\n            if (split.length == 1) {\n                skipBlocksEnd = split[0];\n            } else {\n                skipBlocksEnd = split[1];\n            }\n        }\n    }\n\n    @Override\n    public void tokenize(SourceCode sourceCode, Tokens tokenEntries) {\n        StringBuilder buffer = sourceCode.getCodeBuffer();\n        try (Reader reader = IOUtil.skipBOM(new StringReader(maybeSkipBlocks(buffer.toString())))) {\n            CppTokenManager tokenManager = new CppTokenManager(reader);\n            tokenManager.setFileName(sourceCode.getFileName());\n            final TokenFilter tokenFilter = new JavaCCTokenFilter(tokenManager);\n\n            GenericToken currentToken = tokenFilter.getNextToken();\n            while (currentToken != null) {\n                tokenEntries.add(new TokenEntry(currentToken.getImage(), sourceCode.getFileName(), currentToken.getBeginLine()));\n                currentToken = tokenFilter.getNextToken();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.err.println(\"Error parsing \" + sourceCode.getFileName());\n        } finally {\n            tokenEntries.add(TokenEntry.getEOF());\n        }\n    }\n\n    private String maybeSkipBlocks(String test) throws IOException {\n        if (!skipBlocks) {\n            return test;\n        }\n\n        BufferedReader reader = new BufferedReader(new StringReader(test));\n        StringBuilder filtered = new StringBuilder(test.length());\n        String line;\n        boolean skip = false;\n        while ((line = reader.readLine()) != null) {\n            if (skipBlocksStart.equalsIgnoreCase(line.trim())) {\n                skip = true;\n            } else if (skip && skipBlocksEnd.equalsIgnoreCase(line.trim())) {\n                skip = false;\n            }\n            if (!skip) {\n                filtered.append(line);\n            }\n            // always add a new line to keep the line-numbering\n            filtered.append(PMD.EOL); \n        }\n        return filtered.toString();\n    }\n}\n",
        "filePathAfter": "pmd-core/src/main/java/net/sourceforge/pmd/cpd/JavaCCTokenizer.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.cpd;\n\nimport java.io.IOException;\n\nimport net.sourceforge.pmd.cpd.token.JavaCCTokenFilter;\nimport net.sourceforge.pmd.cpd.token.TokenFilter;\nimport net.sourceforge.pmd.lang.TokenManager;\nimport net.sourceforge.pmd.lang.ast.GenericToken;\n\npublic abstract class JavaCCTokenizer implements Tokenizer {\n\n    protected abstract TokenManager getLexerForSource(SourceCode sourceCode);\n\n    protected TokenFilter getTokenFilter(TokenManager tokenManager) {\n        return new JavaCCTokenFilter(tokenManager);\n    }\n\n    protected TokenEntry processToken(Tokens tokenEntries, GenericToken currentToken, String filename) {\n        return new TokenEntry(currentToken.getImage(), filename, currentToken.getBeginLine());\n    }\n    \n    @Override\n    public void tokenize(SourceCode sourceCode, Tokens tokenEntries) throws IOException {\n        TokenManager tokenManager = getLexerForSource(sourceCode);\n        tokenManager.setFileName(sourceCode.getFileName());\n        try {\n            final TokenFilter tokenFilter = getTokenFilter(tokenManager);\n\n            GenericToken currentToken = tokenFilter.getNextToken();\n            while (currentToken != null) {\n                tokenEntries.add(processToken(tokenEntries, currentToken, sourceCode.getFileName()));\n                currentToken = tokenFilter.getNextToken();\n            }\n        } finally {\n            tokenEntries.add(TokenEntry.getEOF());\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            "protected TokenEntry processToken(Tokens tokenEntries, GenericToken currentToken, String filename) {\n        return new TokenEntry(currentToken.getImage(), filename, currentToken.getBeginLine());\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.cpd.CPPTokenizer#maybeSkipBlocks\n methodBody: private String maybeSkipBlocks(String test) throws IOException {\nif(!skipBlocks){return test;\n}BufferedReader reader=new BufferedReader(new StringReader(test));\nStringBuilder filtered=new StringBuilder(test.length());\nString line;\nboolean skip=false;\nwhile((line=reader.readLine()) != null){if(skipBlocksStart.equalsIgnoreCase(line.trim())){skip=true;\n}if(skip && skipBlocksEnd.equalsIgnoreCase(line.trim())){skip=false;\n}if(!skip){filtered.append(line);\n}filtered.append(PMD.EOL);\n}return filtered.toString();\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n    public void tokenize(SourceCode sourceCode, Tokens tokenEntries) throws IOException {\n        TokenManager tokenManager = getLexerForSource(sourceCode);\n        tokenManager.setFileName(sourceCode.getFileName());\n        try {\n            final TokenFilter tokenFilter = getTokenFilter(tokenManager);\n\n            GenericToken currentToken = tokenFilter.getNextToken();\n            while (currentToken != null) {\n                tokenEntries.add(processToken(tokenEntries, currentToken, sourceCode.getFileName()));\n                currentToken = tokenFilter.getNextToken();\n            }\n        } finally {\n            tokenEntries.add(TokenEntry.getEOF());\n        }\n    }\nprotected TokenEntry processToken(Tokens tokenEntries, GenericToken currentToken, String filename) {\n        return new TokenEntry(currentToken.getImage(), filename, currentToken.getBeginLine());\n    }",
        "diffSourceCode": "-   22:  */\n-   23: public class CPPTokenizer implements Tokenizer {\n-   24: \n-   26:     private String skipBlocksStart;\n-   27:     private String skipBlocksEnd;\n-   28: \n-   29:     /**\n-   30:      * Sets the possible options for the C++ tokenizer.\n-   31:      * \n-   32:      * @param properties\n-   33:      *            the properties\n-   34:      * @see #OPTION_SKIP_BLOCKS\n-   35:      * @see #OPTION_SKIP_BLOCKS_PATTERN\n-   36:      */\n-   37:     public void setProperties(Properties properties) {\n-   38:         skipBlocks = Boolean.parseBoolean(properties.getProperty(OPTION_SKIP_BLOCKS, Boolean.TRUE.toString()));\n-   39:         if (skipBlocks) {\n-   40:             String skipBlocksPattern = properties.getProperty(OPTION_SKIP_BLOCKS_PATTERN, DEFAULT_SKIP_BLOCKS_PATTERN);\n-   41:             String[] split = skipBlocksPattern.split(\"\\\\|\", 2);\n-   51:     @Override\n-   52:     public void tokenize(SourceCode sourceCode, Tokens tokenEntries) {\n-   53:         StringBuilder buffer = sourceCode.getCodeBuffer();\n-   54:         try (Reader reader = IOUtil.skipBOM(new StringReader(maybeSkipBlocks(buffer.toString())))) {\n-   55:             CppTokenManager tokenManager = new CppTokenManager(reader);\n-   56:             tokenManager.setFileName(sourceCode.getFileName());\n-   57:             final TokenFilter tokenFilter = new JavaCCTokenFilter(tokenManager);\n-   58: \n-   59:             GenericToken currentToken = tokenFilter.getNextToken();\n-   60:             while (currentToken != null) {\n-   61:                 tokenEntries.add(new TokenEntry(currentToken.getImage(), sourceCode.getFileName(), currentToken.getBeginLine()));\n-   62:                 currentToken = tokenFilter.getNextToken();\n-   63:             }\n-   64:         } catch (IOException e) {\n-   65:             e.printStackTrace();\n-   66:             System.err.println(\"Error parsing \" + sourceCode.getFileName());\n-   67:         } finally {\n-   68:             tokenEntries.add(TokenEntry.getEOF());\n-   69:         }\n-   70:     }\n+   22:     protected TokenEntry processToken(Tokens tokenEntries, GenericToken currentToken, String filename) {\n+   23:         return new TokenEntry(currentToken.getImage(), filename, currentToken.getBeginLine());\n+   24:     }\n+   26:     @Override\n+   27:     public void tokenize(SourceCode sourceCode, Tokens tokenEntries) throws IOException {\n+   28:         TokenManager tokenManager = getLexerForSource(sourceCode);\n+   29:         tokenManager.setFileName(sourceCode.getFileName());\n+   30:         try {\n+   31:             final TokenFilter tokenFilter = getTokenFilter(tokenManager);\n+   32: \n+   33:             GenericToken currentToken = tokenFilter.getNextToken();\n+   34:             while (currentToken != null) {\n+   35:                 tokenEntries.add(processToken(tokenEntries, currentToken, sourceCode.getFileName()));\n+   36:                 currentToken = tokenFilter.getNextToken();\n+   37:             }\n+   38:         } finally {\n+   39:             tokenEntries.add(TokenEntry.getEOF());\n+   40:         }\n+   41:     }\n",
        "uniqueId": "08b7dd49dda043f3ac0078c8e071dc7e86e27ada_51_70_22_24_26_41",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 14,
                "covered": 50
            },
            "BRANCH": {
                "missed": 0,
                "covered": 2
            },
            "LINE": {
                "missed": 3,
                "covered": 11
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 2
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate isInitializerMethod(name String) : boolean extracted from private checkForCSRF(node ASTMethod, data Object) : void in class net.sourceforge.pmd.lang.apex.rule.errorprone.ApexCSRFRule",
        "diffLocations": [
            {
                "filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/errorprone/ApexCSRFRule.java",
                "startLine": 58,
                "endLine": 77,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/errorprone/ApexCSRFRule.java",
                "startLine": 55,
                "endLine": 64,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/errorprone/ApexCSRFRule.java",
                "startLine": 66,
                "endLine": 68,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * @param node\n     * @param data\n     */\n    private void checkForCSRF(ASTMethod node, Object data) {\n        if (node.isConstructor()) {\n            if (Helper.foundAnyDML(node)) {\n                addViolation(data, node);\n            }\n\n        }\n\n        String name = node.getImage();\n        if (INIT.equalsIgnoreCase(name) || STATIC_INITIALIZER.equals(name)) {\n            if (Helper.foundAnyDML(node)) {\n                addViolation(data, node);\n            }\n        }\n\n    }",
        "filePathBefore": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/errorprone/ApexCSRFRule.java",
        "isPureRefactoring": true,
        "commitId": "0d9fe56ec3a7e9665679429df7bd3c9133fbce06",
        "packageNameBefore": "net.sourceforge.pmd.lang.apex.rule.errorprone",
        "classNameBefore": "net.sourceforge.pmd.lang.apex.rule.errorprone.ApexCSRFRule",
        "methodNameBefore": "net.sourceforge.pmd.lang.apex.rule.errorprone.ApexCSRFRule#checkForCSRF",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.apex.rule.internal.Helper#foundAnyDML\n methodBody: public static boolean foundAnyDML(final ApexNode<?> node) {\nfinal List<ASTDmlUpsertStatement> dmlUpsertStatement=node.findDescendantsOfType(ASTDmlUpsertStatement.class);\nfinal List<ASTDmlUpdateStatement> dmlUpdateStatement=node.findDescendantsOfType(ASTDmlUpdateStatement.class);\nfinal List<ASTDmlUndeleteStatement> dmlUndeleteStatement=node.findDescendantsOfType(ASTDmlUndeleteStatement.class);\nfinal List<ASTDmlMergeStatement> dmlMergeStatement=node.findDescendantsOfType(ASTDmlMergeStatement.class);\nfinal List<ASTDmlInsertStatement> dmlInsertStatement=node.findDescendantsOfType(ASTDmlInsertStatement.class);\nfinal List<ASTDmlDeleteStatement> dmlDeleteStatement=node.findDescendantsOfType(ASTDmlDeleteStatement.class);\nreturn !dmlUpsertStatement.isEmpty() || !dmlUpdateStatement.isEmpty() || !dmlUndeleteStatement.isEmpty() || !dmlMergeStatement.isEmpty() || !dmlInsertStatement.isEmpty() || !dmlDeleteStatement.isEmpty();\n}",
        "classSignatureBefore": "public class ApexCSRFRule extends AbstractApexRule ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.apex.rule.errorprone.ApexCSRFRule#checkForCSRF"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.apex.rule.errorprone.ApexCSRFRule"
        ],
        "classSignatureBeforeSet": [
            "public class ApexCSRFRule extends AbstractApexRule "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex.rule.errorprone;\n\nimport net.sourceforge.pmd.lang.apex.ast.ASTBlockStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTMethod;\nimport net.sourceforge.pmd.lang.apex.ast.ASTUserClass;\nimport net.sourceforge.pmd.lang.apex.rule.AbstractApexRule;\nimport net.sourceforge.pmd.lang.apex.rule.internal.Helper;\n\n/**\n * Constructor and init method might contain DML, which constitutes a CSRF\n * vulnerability\n * \n * @author sergey.gorbaty\n *\n */\npublic class ApexCSRFRule extends AbstractApexRule {\n    public static final String INIT = \"init\";\n    private static final String STATIC_INITIALIZER = \"<clinit>\";\n\n    public ApexCSRFRule() {\n        setProperty(CODECLIMATE_CATEGORIES, \"Security\");\n        setProperty(CODECLIMATE_REMEDIATION_MULTIPLIER, 100);\n        setProperty(CODECLIMATE_BLOCK_HIGHLIGHTING, false);\n    }\n\n    @Override\n    public Object visit(ASTUserClass node, Object data) {\n        if (Helper.isTestMethodOrClass(node) || Helper.isSystemLevelClass(node)) {\n            return data; // stops all the rules\n        }\n\n        return super.visit(node, data);\n    }\n\n    @Override\n    public Object visit(ASTMethod node, Object data) {\n        if (!Helper.isTestMethodOrClass(node)) {\n            checkForCSRF(node, data);\n        }\n        return data;\n    }\n\n    @Override\n    public Object visit(ASTBlockStatement node, Object data) {\n        if (node.jjtGetParent() instanceof ASTUserClass) {\n            // initializer block\n            if (Helper.foundAnyDML(node)) {\n                addViolation(data, node);\n            }\n        }\n        return data;\n    }\n\n    /**\n     * @param node\n     * @param data\n     */\n    private void checkForCSRF(ASTMethod node, Object data) {\n        if (node.isConstructor()) {\n            if (Helper.foundAnyDML(node)) {\n                addViolation(data, node);\n            }\n\n        }\n\n        String name = node.getImage();\n        if (INIT.equalsIgnoreCase(name) || STATIC_INITIALIZER.equals(name)) {\n            if (Helper.foundAnyDML(node)) {\n                addViolation(data, node);\n            }\n        }\n\n    }\n}\n",
        "filePathAfter": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/errorprone/ApexCSRFRule.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex.rule.errorprone;\n\nimport net.sourceforge.pmd.lang.apex.ast.ASTBlockStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTMethod;\nimport net.sourceforge.pmd.lang.apex.ast.ASTUserClass;\nimport net.sourceforge.pmd.lang.apex.rule.AbstractApexRule;\nimport net.sourceforge.pmd.lang.apex.rule.internal.Helper;\n\n/**\n * Constructor and init method might contain DML, which constitutes a CSRF\n * vulnerability\n * \n * @author sergey.gorbaty\n *\n */\npublic class ApexCSRFRule extends AbstractApexRule {\n    public static final String INIT = \"init\";\n    private static final String STATIC_INITIALIZER = \"<clinit>\";\n\n    public ApexCSRFRule() {\n        setProperty(CODECLIMATE_CATEGORIES, \"Security\");\n        setProperty(CODECLIMATE_REMEDIATION_MULTIPLIER, 100);\n        setProperty(CODECLIMATE_BLOCK_HIGHLIGHTING, false);\n    }\n\n    @Override\n    public Object visit(ASTUserClass node, Object data) {\n        if (Helper.isTestMethodOrClass(node) || Helper.isSystemLevelClass(node)) {\n            return data; // stops all the rules\n        }\n\n        return super.visit(node, data);\n    }\n\n    @Override\n    public Object visit(ASTMethod node, Object data) {\n        if (!Helper.isTestMethodOrClass(node)) {\n            checkForCSRF(node, data);\n        }\n        return data;\n    }\n\n    @Override\n    public Object visit(ASTBlockStatement node, Object data) {\n        if (node.jjtGetParent() instanceof ASTUserClass && Helper.foundAnyDML(node)) {\n            addViolation(data, node);\n        }\n        return data;\n    }\n\n    private void checkForCSRF(ASTMethod node, Object data) {\n        if (node.isConstructor() && Helper.foundAnyDML(node)) {\n            addViolation(data, node);\n        }\n\n        String name = node.getImage();\n        if (isInitializerMethod(name) && Helper.foundAnyDML(node)) {\n            addViolation(data, node);\n        }\n    }\n\n    private boolean isInitializerMethod(String name) {\n        return INIT.equalsIgnoreCase(name) || STATIC_INITIALIZER.equals(name);\n    }\n}\n",
        "diffSourceCodeSet": [
            "private boolean isInitializerMethod(String name) {\n        return INIT.equalsIgnoreCase(name) || STATIC_INITIALIZER.equals(name);\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.apex.rule.internal.Helper#foundAnyDML\n methodBody: public static boolean foundAnyDML(final ApexNode<?> node) {\nfinal List<ASTDmlUpsertStatement> dmlUpsertStatement=node.findDescendantsOfType(ASTDmlUpsertStatement.class);\nfinal List<ASTDmlUpdateStatement> dmlUpdateStatement=node.findDescendantsOfType(ASTDmlUpdateStatement.class);\nfinal List<ASTDmlUndeleteStatement> dmlUndeleteStatement=node.findDescendantsOfType(ASTDmlUndeleteStatement.class);\nfinal List<ASTDmlMergeStatement> dmlMergeStatement=node.findDescendantsOfType(ASTDmlMergeStatement.class);\nfinal List<ASTDmlInsertStatement> dmlInsertStatement=node.findDescendantsOfType(ASTDmlInsertStatement.class);\nfinal List<ASTDmlDeleteStatement> dmlDeleteStatement=node.findDescendantsOfType(ASTDmlDeleteStatement.class);\nreturn !dmlUpsertStatement.isEmpty() || !dmlUpdateStatement.isEmpty() || !dmlUndeleteStatement.isEmpty() || !dmlMergeStatement.isEmpty() || !dmlInsertStatement.isEmpty() || !dmlDeleteStatement.isEmpty();\n}"
        ],
        "sourceCodeAfterRefactoring": "private void checkForCSRF(ASTMethod node, Object data) {\n        if (node.isConstructor() && Helper.foundAnyDML(node)) {\n            addViolation(data, node);\n        }\n\n        String name = node.getImage();\n        if (isInitializerMethod(name) && Helper.foundAnyDML(node)) {\n            addViolation(data, node);\n        }\n    }\nprivate boolean isInitializerMethod(String name) {\n        return INIT.equalsIgnoreCase(name) || STATIC_INITIALIZER.equals(name);\n    }",
        "diffSourceCode": "-   55:         return data;\n-   56:     }\n-   57: \n-   58:     /**\n-   59:      * @param node\n-   60:      * @param data\n-   61:      */\n-   62:     private void checkForCSRF(ASTMethod node, Object data) {\n-   63:         if (node.isConstructor()) {\n-   64:             if (Helper.foundAnyDML(node)) {\n-   65:                 addViolation(data, node);\n-   66:             }\n-   67: \n-   68:         }\n-   69: \n-   70:         String name = node.getImage();\n-   71:         if (INIT.equalsIgnoreCase(name) || STATIC_INITIALIZER.equals(name)) {\n-   72:             if (Helper.foundAnyDML(node)) {\n-   73:                 addViolation(data, node);\n-   74:             }\n-   75:         }\n-   76: \n-   77:     }\n+   55:     private void checkForCSRF(ASTMethod node, Object data) {\n+   56:         if (node.isConstructor() && Helper.foundAnyDML(node)) {\n+   57:             addViolation(data, node);\n+   58:         }\n+   59: \n+   60:         String name = node.getImage();\n+   61:         if (isInitializerMethod(name) && Helper.foundAnyDML(node)) {\n+   62:             addViolation(data, node);\n+   63:         }\n+   64:     }\n+   65: \n+   66:     private boolean isInitializerMethod(String name) {\n+   67:         return INIT.equalsIgnoreCase(name) || STATIC_INITIALIZER.equals(name);\n+   68:     }\n+   69: }\n",
        "uniqueId": "0d9fe56ec3a7e9665679429df7bd3c9133fbce06_58_77_66_68_55_64",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 29
            },
            "BRANCH": {
                "missed": 0,
                "covered": 10
            },
            "LINE": {
                "missed": 0,
                "covered": 8
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 6
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate processSourceCodeWithoutCache(sourceCode Reader, ruleSets RuleSets, ctx RuleContext) : void extracted from public processSourceCode(sourceCode Reader, ruleSets RuleSets, ctx RuleContext) : void in class net.sourceforge.pmd.SourceCodeProcessor",
        "diffLocations": [
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/SourceCodeProcessor.java",
                "startLine": 57,
                "endLine": 107,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/SourceCodeProcessor.java",
                "startLine": 57,
                "endLine": 92,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-core/src/main/java/net/sourceforge/pmd/SourceCodeProcessor.java",
                "startLine": 104,
                "endLine": 117,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n     * Processes the input stream against a rule set using the given input\n     * encoding. If the LanguageVersion is <code>null</code> on the RuleContext,\n     * it will be automatically determined. Any code which wishes to process\n     * files for different Languages, will need to be sure to either properly\n     * set the Language on the RuleContext, or set it to <code>null</code>\n     * first.\n     *\n     * @see RuleContext#setLanguageVersion(net.sourceforge.pmd.lang.LanguageVersion)\n     * @see PMDConfiguration#getLanguageVersionOfFile(String)\n     *\n     * @param sourceCode\n     *            The Reader to analyze.\n     * @param ruleSets\n     *            The collection of rules to process against the file.\n     * @param ctx\n     *            The context in which PMD is operating.\n     * @throws PMDException\n     *             if the input encoding is unsupported, the input stream could\n     *             not be parsed, or other error is encountered.\n     */\n    public void processSourceCode(Reader sourceCode, RuleSets ruleSets, RuleContext ctx) throws PMDException {\n        determineLanguage(ctx);\n\n        // make sure custom XPath functions are initialized\n        Initializer.initialize();\n\n        // Coarse check to see if any RuleSet applies to file, will need to do a finer RuleSet specific check later\n        if (ruleSets.applies(ctx.getSourceCodeFile())) {\n            // Is the cache up to date?\n            if (configuration.getAnalysisCache().isUpToDate(ctx.getSourceCodeFile())) {\n                for (final RuleViolation rv : configuration.getAnalysisCache().getCachedViolations(ctx.getSourceCodeFile())) {\n                    ctx.getReport().addRuleViolation(rv);\n                }\n                return;\n            }\n\n            try {\n                ruleSets.start(ctx);\n                processSource(sourceCode, ruleSets, ctx);\n            } catch (ParseException pe) {\n                configuration.getAnalysisCache().analysisFailed(ctx.getSourceCodeFile());\n                throw new PMDException(\"Error while parsing \" + ctx.getSourceCodeFile(), pe);\n            } catch (Exception e) {\n                configuration.getAnalysisCache().analysisFailed(ctx.getSourceCodeFile());\n                throw new PMDException(\"Error while processing \" + ctx.getSourceCodeFile(), e);\n            } finally {\n                ruleSets.end(ctx);\n            }\n        }\n    }",
        "filePathBefore": "pmd-core/src/main/java/net/sourceforge/pmd/SourceCodeProcessor.java",
        "isPureRefactoring": true,
        "commitId": "b84dfe80b597862ef5ee468a708b7c2dc4db7749",
        "packageNameBefore": "net.sourceforge.pmd",
        "classNameBefore": "net.sourceforge.pmd.SourceCodeProcessor",
        "methodNameBefore": "net.sourceforge.pmd.SourceCodeProcessor#processSourceCode",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.SourceCodeProcessor#processSource\n methodBody: private void processSource(Reader sourceCode, RuleSets ruleSets, RuleContext ctx) {\nLanguageVersion languageVersion=ctx.getLanguageVersion();\nLanguageVersionHandler languageVersionHandler=languageVersion.getLanguageVersionHandler();\nParser parser=PMD.parserFor(languageVersion,configuration);\nNode rootNode=parse(ctx,sourceCode,parser);\nresolveQualifiedNames(rootNode,languageVersionHandler);\nsymbolFacade(rootNode,languageVersionHandler);\nLanguage language=languageVersion.getLanguage();\nusesDFA(languageVersion,rootNode,ruleSets,language);\nusesTypeResolution(languageVersion,rootNode,ruleSets,language);\nusesMultifile(rootNode,languageVersionHandler,ruleSets,language);\nList<Node> acus=Collections.singletonList(rootNode);\nruleSets.apply(acus,ctx,language);\n}\nmethodSignature: net.sourceforge.pmd.SourceCodeProcessor#determineLanguage\n methodBody: private void determineLanguage(RuleContext ctx) {\nif(ctx.getLanguageVersion() == null){LanguageVersion languageVersion=configuration.getLanguageVersionOfFile(ctx.getSourceCodeFilename());\nctx.setLanguageVersion(languageVersion);\n}}",
        "classSignatureBefore": "public class SourceCodeProcessor ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.SourceCodeProcessor#processSourceCode"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.SourceCodeProcessor"
        ],
        "classSignatureBeforeSet": [
            "public class SourceCodeProcessor "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.Collections;\nimport java.util.List;\n\nimport net.sourceforge.pmd.benchmark.TimeTracker;\nimport net.sourceforge.pmd.benchmark.TimedOperation;\nimport net.sourceforge.pmd.benchmark.TimedOperationCategory;\nimport net.sourceforge.pmd.lang.Language;\nimport net.sourceforge.pmd.lang.LanguageVersion;\nimport net.sourceforge.pmd.lang.LanguageVersionHandler;\nimport net.sourceforge.pmd.lang.Parser;\nimport net.sourceforge.pmd.lang.VisitorStarter;\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.ast.ParseException;\nimport net.sourceforge.pmd.lang.xpath.Initializer;\n\npublic class SourceCodeProcessor {\n\n    private final PMDConfiguration configuration;\n\n    public SourceCodeProcessor(PMDConfiguration configuration) {\n        this.configuration = configuration;\n    }\n\n    /**\n     * Processes the input stream against a rule set using the given input\n     * encoding.\n     *\n     * @param sourceCode\n     *            The InputStream to analyze.\n     * @param ruleSets\n     *            The collection of rules to process against the file.\n     * @param ctx\n     *            The context in which PMD is operating.\n     * @throws PMDException\n     *             if the input encoding is unsupported, the input stream could\n     *             not be parsed, or other error is encountered.\n     * @see #processSourceCode(Reader, RuleSets, RuleContext)\n     */\n    public void processSourceCode(InputStream sourceCode, RuleSets ruleSets, RuleContext ctx) throws PMDException {\n        try (Reader streamReader = new InputStreamReader(sourceCode, configuration.getSourceEncoding())) {\n            processSourceCode(streamReader, ruleSets, ctx);\n        } catch (IOException e) {\n            throw new PMDException(\"IO exception: \" + e.getMessage(), e);\n        }\n    }\n\n    /**\n     * Processes the input stream against a rule set using the given input\n     * encoding. If the LanguageVersion is <code>null</code> on the RuleContext,\n     * it will be automatically determined. Any code which wishes to process\n     * files for different Languages, will need to be sure to either properly\n     * set the Language on the RuleContext, or set it to <code>null</code>\n     * first.\n     *\n     * @see RuleContext#setLanguageVersion(net.sourceforge.pmd.lang.LanguageVersion)\n     * @see PMDConfiguration#getLanguageVersionOfFile(String)\n     *\n     * @param sourceCode\n     *            The Reader to analyze.\n     * @param ruleSets\n     *            The collection of rules to process against the file.\n     * @param ctx\n     *            The context in which PMD is operating.\n     * @throws PMDException\n     *             if the input encoding is unsupported, the input stream could\n     *             not be parsed, or other error is encountered.\n     */\n    public void processSourceCode(Reader sourceCode, RuleSets ruleSets, RuleContext ctx) throws PMDException {\n        determineLanguage(ctx);\n\n        // make sure custom XPath functions are initialized\n        Initializer.initialize();\n\n        // Coarse check to see if any RuleSet applies to file, will need to do a finer RuleSet specific check later\n        if (ruleSets.applies(ctx.getSourceCodeFile())) {\n            // Is the cache up to date?\n            if (configuration.getAnalysisCache().isUpToDate(ctx.getSourceCodeFile())) {\n                for (final RuleViolation rv : configuration.getAnalysisCache().getCachedViolations(ctx.getSourceCodeFile())) {\n                    ctx.getReport().addRuleViolation(rv);\n                }\n                return;\n            }\n\n            try {\n                ruleSets.start(ctx);\n                processSource(sourceCode, ruleSets, ctx);\n            } catch (ParseException pe) {\n                configuration.getAnalysisCache().analysisFailed(ctx.getSourceCodeFile());\n                throw new PMDException(\"Error while parsing \" + ctx.getSourceCodeFile(), pe);\n            } catch (Exception e) {\n                configuration.getAnalysisCache().analysisFailed(ctx.getSourceCodeFile());\n                throw new PMDException(\"Error while processing \" + ctx.getSourceCodeFile(), e);\n            } finally {\n                ruleSets.end(ctx);\n            }\n        }\n    }\n\n    private Node parse(RuleContext ctx, Reader sourceCode, Parser parser) {\n        try (TimedOperation to = TimeTracker.startOperation(TimedOperationCategory.PARSER)) {\n            Node rootNode = parser.parse(String.valueOf(ctx.getSourceCodeFile()), sourceCode);\n            ctx.getReport().suppress(parser.getSuppressMap());\n            return rootNode;\n        }\n    }\n\n    private void symbolFacade(Node rootNode, LanguageVersionHandler languageVersionHandler) {\n        try (TimedOperation to = TimeTracker.startOperation(TimedOperationCategory.SYMBOL_TABLE)) {\n            languageVersionHandler.getSymbolFacade(configuration.getClassLoader()).start(rootNode);\n        }\n    }\n\n    private void resolveQualifiedNames(Node rootNode, LanguageVersionHandler handler) {\n        try (TimedOperation to = TimeTracker.startOperation(TimedOperationCategory.QUALIFIED_NAME_RESOLUTION)) {\n            handler.getQualifiedNameResolutionFacade(configuration.getClassLoader()).start(rootNode);\n        }\n    }\n\n    // private ParserOptions getParserOptions(final LanguageVersionHandler\n    // languageVersionHandler) {\n    // // TODO Handle Rules having different parser options.\n    // ParserOptions parserOptions =\n    // languageVersionHandler.getDefaultParserOptions();\n    // parserOptions.setSuppressMarker(configuration.getSuppressMarker());\n    // return parserOptions;\n    // }\n\n    private void usesDFA(LanguageVersion languageVersion, Node rootNode, RuleSets ruleSets, Language language) {\n        if (ruleSets.usesDFA(language)) {\n            try (TimedOperation to = TimeTracker.startOperation(TimedOperationCategory.DFA)) {\n                VisitorStarter dataFlowFacade = languageVersion.getLanguageVersionHandler().getDataFlowFacade();\n                dataFlowFacade.start(rootNode);\n            }\n        }\n    }\n\n    private void usesTypeResolution(LanguageVersion languageVersion, Node rootNode, RuleSets ruleSets,\n            Language language) {\n\n        if (ruleSets.usesTypeResolution(language)) {\n            try (TimedOperation to = TimeTracker.startOperation(TimedOperationCategory.TYPE_RESOLUTION)) {\n                languageVersion.getLanguageVersionHandler().getTypeResolutionFacade(configuration.getClassLoader())\n                        .start(rootNode);\n            }\n        }\n    }\n\n\n    private void usesMultifile(Node rootNode, LanguageVersionHandler languageVersionHandler, RuleSets ruleSets,\n                               Language language) {\n\n        if (ruleSets.usesMultifile(language)) {\n            try (TimedOperation to = TimeTracker.startOperation(TimedOperationCategory.MULTIFILE_ANALYSIS)) {\n                languageVersionHandler.getMultifileFacade().start(rootNode);\n            }\n        }\n    }\n\n\n    private void processSource(Reader sourceCode, RuleSets ruleSets, RuleContext ctx) {\n        LanguageVersion languageVersion = ctx.getLanguageVersion();\n        LanguageVersionHandler languageVersionHandler = languageVersion.getLanguageVersionHandler();\n        Parser parser = PMD.parserFor(languageVersion, configuration);\n\n        Node rootNode = parse(ctx, sourceCode, parser);\n        resolveQualifiedNames(rootNode, languageVersionHandler);\n        symbolFacade(rootNode, languageVersionHandler);\n        Language language = languageVersion.getLanguage();\n        usesDFA(languageVersion, rootNode, ruleSets, language);\n        usesTypeResolution(languageVersion, rootNode, ruleSets, language);\n        usesMultifile(rootNode, languageVersionHandler, ruleSets, language);\n\n        List<Node> acus = Collections.singletonList(rootNode);\n        ruleSets.apply(acus, ctx, language);\n    }\n\n    private void determineLanguage(RuleContext ctx) {\n        // If LanguageVersion of the source file is not known, make a\n        // determination\n        if (ctx.getLanguageVersion() == null) {\n            LanguageVersion languageVersion = configuration.getLanguageVersionOfFile(ctx.getSourceCodeFilename());\n            ctx.setLanguageVersion(languageVersion);\n        }\n    }\n}\n",
        "filePathAfter": "pmd-core/src/main/java/net/sourceforge/pmd/SourceCodeProcessor.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.Collections;\nimport java.util.List;\n\nimport net.sourceforge.pmd.benchmark.TimeTracker;\nimport net.sourceforge.pmd.benchmark.TimedOperation;\nimport net.sourceforge.pmd.benchmark.TimedOperationCategory;\nimport net.sourceforge.pmd.lang.Language;\nimport net.sourceforge.pmd.lang.LanguageVersion;\nimport net.sourceforge.pmd.lang.LanguageVersionHandler;\nimport net.sourceforge.pmd.lang.Parser;\nimport net.sourceforge.pmd.lang.VisitorStarter;\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.ast.ParseException;\nimport net.sourceforge.pmd.lang.xpath.Initializer;\n\npublic class SourceCodeProcessor {\n\n    private final PMDConfiguration configuration;\n\n    public SourceCodeProcessor(PMDConfiguration configuration) {\n        this.configuration = configuration;\n    }\n\n    /**\n     * Processes the input stream against a rule set using the given input\n     * encoding.\n     *\n     * @param sourceCode\n     *            The InputStream to analyze.\n     * @param ruleSets\n     *            The collection of rules to process against the file.\n     * @param ctx\n     *            The context in which PMD is operating.\n     * @throws PMDException\n     *             if the input encoding is unsupported, the input stream could\n     *             not be parsed, or other error is encountered.\n     * @see #processSourceCode(Reader, RuleSets, RuleContext)\n     */\n    public void processSourceCode(InputStream sourceCode, RuleSets ruleSets, RuleContext ctx) throws PMDException {\n        try (Reader streamReader = new InputStreamReader(sourceCode, configuration.getSourceEncoding())) {\n            processSourceCode(streamReader, ruleSets, ctx);\n        } catch (IOException e) {\n            throw new PMDException(\"IO exception: \" + e.getMessage(), e);\n        }\n    }\n\n    /**\n     * Processes the input stream against a rule set using the given input\n     * encoding. If the LanguageVersion is <code>null</code> on the RuleContext,\n     * it will be automatically determined. Any code which wishes to process\n     * files for different Languages, will need to be sure to either properly\n     * set the Language on the RuleContext, or set it to <code>null</code>\n     * first.\n     *\n     * @see RuleContext#setLanguageVersion(net.sourceforge.pmd.lang.LanguageVersion)\n     * @see PMDConfiguration#getLanguageVersionOfFile(String)\n     *\n     * @param sourceCode\n     *            The Reader to analyze.\n     * @param ruleSets\n     *            The collection of rules to process against the file.\n     * @param ctx\n     *            The context in which PMD is operating.\n     * @throws PMDException\n     *             if the input encoding is unsupported, the input stream could\n     *             not be parsed, or other error is encountered.\n     */\n    public void processSourceCode(Reader sourceCode, RuleSets ruleSets, RuleContext ctx) throws PMDException {\n        determineLanguage(ctx);\n\n        // make sure custom XPath functions are initialized\n        Initializer.initialize();\n\n        // Coarse check to see if any RuleSet applies to file, will need to do a finer RuleSet specific check later\n        if (ruleSets.applies(ctx.getSourceCodeFile())) {\n            if (isCacheUpToDate(ctx)) {\n                reportCachedRuleViolations(ctx);\n            } else {\n                processSourceCodeWithoutCache(sourceCode, ruleSets, ctx);\n            }\n        }\n    }\n\n    private boolean isCacheUpToDate(final RuleContext ctx) {\n        return configuration.getAnalysisCache().isUpToDate(ctx.getSourceCodeFile());\n    }\n\n    private void reportCachedRuleViolations(final RuleContext ctx) {\n        for (final RuleViolation rv : configuration.getAnalysisCache().getCachedViolations(ctx.getSourceCodeFile())) {\n            ctx.getReport().addRuleViolation(rv);\n        }\n    }\n\n    private void processSourceCodeWithoutCache(final Reader sourceCode, final RuleSets ruleSets, final RuleContext ctx) throws PMDException {\n        try {\n            ruleSets.start(ctx);\n            processSource(sourceCode, ruleSets, ctx);\n        } catch (ParseException pe) {\n            configuration.getAnalysisCache().analysisFailed(ctx.getSourceCodeFile());\n            throw new PMDException(\"Error while parsing \" + ctx.getSourceCodeFile(), pe);\n        } catch (Exception e) {\n            configuration.getAnalysisCache().analysisFailed(ctx.getSourceCodeFile());\n            throw new PMDException(\"Error while processing \" + ctx.getSourceCodeFile(), e);\n        } finally {\n            ruleSets.end(ctx);\n        }\n    }\n\n    private Node parse(RuleContext ctx, Reader sourceCode, Parser parser) {\n        try (TimedOperation to = TimeTracker.startOperation(TimedOperationCategory.PARSER)) {\n            Node rootNode = parser.parse(String.valueOf(ctx.getSourceCodeFile()), sourceCode);\n            ctx.getReport().suppress(parser.getSuppressMap());\n            return rootNode;\n        }\n    }\n\n    private void symbolFacade(Node rootNode, LanguageVersionHandler languageVersionHandler) {\n        try (TimedOperation to = TimeTracker.startOperation(TimedOperationCategory.SYMBOL_TABLE)) {\n            languageVersionHandler.getSymbolFacade(configuration.getClassLoader()).start(rootNode);\n        }\n    }\n\n    private void resolveQualifiedNames(Node rootNode, LanguageVersionHandler handler) {\n        try (TimedOperation to = TimeTracker.startOperation(TimedOperationCategory.QUALIFIED_NAME_RESOLUTION)) {\n            handler.getQualifiedNameResolutionFacade(configuration.getClassLoader()).start(rootNode);\n        }\n    }\n\n    // private ParserOptions getParserOptions(final LanguageVersionHandler\n    // languageVersionHandler) {\n    // // TODO Handle Rules having different parser options.\n    // ParserOptions parserOptions =\n    // languageVersionHandler.getDefaultParserOptions();\n    // parserOptions.setSuppressMarker(configuration.getSuppressMarker());\n    // return parserOptions;\n    // }\n\n    private void usesDFA(LanguageVersion languageVersion, Node rootNode, RuleSets ruleSets, Language language) {\n        if (ruleSets.usesDFA(language)) {\n            try (TimedOperation to = TimeTracker.startOperation(TimedOperationCategory.DFA)) {\n                VisitorStarter dataFlowFacade = languageVersion.getLanguageVersionHandler().getDataFlowFacade();\n                dataFlowFacade.start(rootNode);\n            }\n        }\n    }\n\n    private void usesTypeResolution(LanguageVersion languageVersion, Node rootNode, RuleSets ruleSets,\n            Language language) {\n\n        if (ruleSets.usesTypeResolution(language)) {\n            try (TimedOperation to = TimeTracker.startOperation(TimedOperationCategory.TYPE_RESOLUTION)) {\n                languageVersion.getLanguageVersionHandler().getTypeResolutionFacade(configuration.getClassLoader())\n                        .start(rootNode);\n            }\n        }\n    }\n\n\n    private void usesMultifile(Node rootNode, LanguageVersionHandler languageVersionHandler, RuleSets ruleSets,\n                               Language language) {\n\n        if (ruleSets.usesMultifile(language)) {\n            try (TimedOperation to = TimeTracker.startOperation(TimedOperationCategory.MULTIFILE_ANALYSIS)) {\n                languageVersionHandler.getMultifileFacade().start(rootNode);\n            }\n        }\n    }\n\n\n    private void processSource(Reader sourceCode, RuleSets ruleSets, RuleContext ctx) {\n        LanguageVersion languageVersion = ctx.getLanguageVersion();\n        LanguageVersionHandler languageVersionHandler = languageVersion.getLanguageVersionHandler();\n        Parser parser = PMD.parserFor(languageVersion, configuration);\n\n        Node rootNode = parse(ctx, sourceCode, parser);\n        resolveQualifiedNames(rootNode, languageVersionHandler);\n        symbolFacade(rootNode, languageVersionHandler);\n        Language language = languageVersion.getLanguage();\n        usesDFA(languageVersion, rootNode, ruleSets, language);\n        usesTypeResolution(languageVersion, rootNode, ruleSets, language);\n        usesMultifile(rootNode, languageVersionHandler, ruleSets, language);\n\n        List<Node> acus = Collections.singletonList(rootNode);\n        ruleSets.apply(acus, ctx, language);\n    }\n\n    private void determineLanguage(RuleContext ctx) {\n        // If LanguageVersion of the source file is not known, make a\n        // determination\n        if (ctx.getLanguageVersion() == null) {\n            LanguageVersion languageVersion = configuration.getLanguageVersionOfFile(ctx.getSourceCodeFilename());\n            ctx.setLanguageVersion(languageVersion);\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            "private void processSourceCodeWithoutCache(final Reader sourceCode, final RuleSets ruleSets, final RuleContext ctx) throws PMDException {\n        try {\n            ruleSets.start(ctx);\n            processSource(sourceCode, ruleSets, ctx);\n        } catch (ParseException pe) {\n            configuration.getAnalysisCache().analysisFailed(ctx.getSourceCodeFile());\n            throw new PMDException(\"Error while parsing \" + ctx.getSourceCodeFile(), pe);\n        } catch (Exception e) {\n            configuration.getAnalysisCache().analysisFailed(ctx.getSourceCodeFile());\n            throw new PMDException(\"Error while processing \" + ctx.getSourceCodeFile(), e);\n        } finally {\n            ruleSets.end(ctx);\n        }\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.SourceCodeProcessor#processSource\n methodBody: private void processSource(Reader sourceCode, RuleSets ruleSets, RuleContext ctx) {\nLanguageVersion languageVersion=ctx.getLanguageVersion();\nLanguageVersionHandler languageVersionHandler=languageVersion.getLanguageVersionHandler();\nParser parser=PMD.parserFor(languageVersion,configuration);\nNode rootNode=parse(ctx,sourceCode,parser);\nresolveQualifiedNames(rootNode,languageVersionHandler);\nsymbolFacade(rootNode,languageVersionHandler);\nLanguage language=languageVersion.getLanguage();\nusesDFA(languageVersion,rootNode,ruleSets,language);\nusesTypeResolution(languageVersion,rootNode,ruleSets,language);\nusesMultifile(rootNode,languageVersionHandler,ruleSets,language);\nList<Node> acus=Collections.singletonList(rootNode);\nruleSets.apply(acus,ctx,language);\n}",
            "methodSignature: net.sourceforge.pmd.SourceCodeProcessor#determineLanguage\n methodBody: private void determineLanguage(RuleContext ctx) {\nif(ctx.getLanguageVersion() == null){LanguageVersion languageVersion=configuration.getLanguageVersionOfFile(ctx.getSourceCodeFilename());\nctx.setLanguageVersion(languageVersion);\n}}"
        ],
        "sourceCodeAfterRefactoring": "/**\n     * Processes the input stream against a rule set using the given input\n     * encoding. If the LanguageVersion is <code>null</code> on the RuleContext,\n     * it will be automatically determined. Any code which wishes to process\n     * files for different Languages, will need to be sure to either properly\n     * set the Language on the RuleContext, or set it to <code>null</code>\n     * first.\n     *\n     * @see RuleContext#setLanguageVersion(net.sourceforge.pmd.lang.LanguageVersion)\n     * @see PMDConfiguration#getLanguageVersionOfFile(String)\n     *\n     * @param sourceCode\n     *            The Reader to analyze.\n     * @param ruleSets\n     *            The collection of rules to process against the file.\n     * @param ctx\n     *            The context in which PMD is operating.\n     * @throws PMDException\n     *             if the input encoding is unsupported, the input stream could\n     *             not be parsed, or other error is encountered.\n     */\n    public void processSourceCode(Reader sourceCode, RuleSets ruleSets, RuleContext ctx) throws PMDException {\n        determineLanguage(ctx);\n\n        // make sure custom XPath functions are initialized\n        Initializer.initialize();\n\n        // Coarse check to see if any RuleSet applies to file, will need to do a finer RuleSet specific check later\n        if (ruleSets.applies(ctx.getSourceCodeFile())) {\n            if (isCacheUpToDate(ctx)) {\n                reportCachedRuleViolations(ctx);\n            } else {\n                processSourceCodeWithoutCache(sourceCode, ruleSets, ctx);\n            }\n        }\n    }\nprivate void processSourceCodeWithoutCache(final Reader sourceCode, final RuleSets ruleSets, final RuleContext ctx) throws PMDException {\n        try {\n            ruleSets.start(ctx);\n            processSource(sourceCode, ruleSets, ctx);\n        } catch (ParseException pe) {\n            configuration.getAnalysisCache().analysisFailed(ctx.getSourceCodeFile());\n            throw new PMDException(\"Error while parsing \" + ctx.getSourceCodeFile(), pe);\n        } catch (Exception e) {\n            configuration.getAnalysisCache().analysisFailed(ctx.getSourceCodeFile());\n            throw new PMDException(\"Error while processing \" + ctx.getSourceCodeFile(), e);\n        } finally {\n            ruleSets.end(ctx);\n        }\n    }",
        "diffSourceCode": "    57:     /**\n    58:      * Processes the input stream against a rule set using the given input\n    59:      * encoding. If the LanguageVersion is <code>null</code> on the RuleContext,\n    60:      * it will be automatically determined. Any code which wishes to process\n    61:      * files for different Languages, will need to be sure to either properly\n    62:      * set the Language on the RuleContext, or set it to <code>null</code>\n    63:      * first.\n    64:      *\n    65:      * @see RuleContext#setLanguageVersion(net.sourceforge.pmd.lang.LanguageVersion)\n    66:      * @see PMDConfiguration#getLanguageVersionOfFile(String)\n    67:      *\n    68:      * @param sourceCode\n    69:      *            The Reader to analyze.\n    70:      * @param ruleSets\n    71:      *            The collection of rules to process against the file.\n    72:      * @param ctx\n    73:      *            The context in which PMD is operating.\n    74:      * @throws PMDException\n    75:      *             if the input encoding is unsupported, the input stream could\n    76:      *             not be parsed, or other error is encountered.\n    77:      */\n    78:     public void processSourceCode(Reader sourceCode, RuleSets ruleSets, RuleContext ctx) throws PMDException {\n    79:         determineLanguage(ctx);\n    80: \n    81:         // make sure custom XPath functions are initialized\n    82:         Initializer.initialize();\n    83: \n    84:         // Coarse check to see if any RuleSet applies to file, will need to do a finer RuleSet specific check later\n    85:         if (ruleSets.applies(ctx.getSourceCodeFile())) {\n-   86:             // Is the cache up to date?\n-   87:             if (configuration.getAnalysisCache().isUpToDate(ctx.getSourceCodeFile())) {\n-   88:                 for (final RuleViolation rv : configuration.getAnalysisCache().getCachedViolations(ctx.getSourceCodeFile())) {\n-   89:                     ctx.getReport().addRuleViolation(rv);\n-   90:                 }\n-   91:                 return;\n-   92:             }\n+   86:             if (isCacheUpToDate(ctx)) {\n+   87:                 reportCachedRuleViolations(ctx);\n+   88:             } else {\n+   89:                 processSourceCodeWithoutCache(sourceCode, ruleSets, ctx);\n+   90:             }\n+   91:         }\n+   92:     }\n    93: \n-   94:             try {\n-   95:                 ruleSets.start(ctx);\n-   96:                 processSource(sourceCode, ruleSets, ctx);\n-   97:             } catch (ParseException pe) {\n-   98:                 configuration.getAnalysisCache().analysisFailed(ctx.getSourceCodeFile());\n-   99:                 throw new PMDException(\"Error while parsing \" + ctx.getSourceCodeFile(), pe);\n-  100:             } catch (Exception e) {\n-  101:                 configuration.getAnalysisCache().analysisFailed(ctx.getSourceCodeFile());\n-  102:                 throw new PMDException(\"Error while processing \" + ctx.getSourceCodeFile(), e);\n-  103:             } finally {\n-  104:                 ruleSets.end(ctx);\n-  105:             }\n-  106:         }\n-  107:     }\n-  108: \n-  109:     private Node parse(RuleContext ctx, Reader sourceCode, Parser parser) {\n-  110:         try (TimedOperation to = TimeTracker.startOperation(TimedOperationCategory.PARSER)) {\n-  111:             Node rootNode = parser.parse(String.valueOf(ctx.getSourceCodeFile()), sourceCode);\n-  112:             ctx.getReport().suppress(parser.getSuppressMap());\n-  113:             return rootNode;\n-  114:         }\n-  115:     }\n-  116: \n-  117:     private void symbolFacade(Node rootNode, LanguageVersionHandler languageVersionHandler) {\n+   94:     private boolean isCacheUpToDate(final RuleContext ctx) {\n+   95:         return configuration.getAnalysisCache().isUpToDate(ctx.getSourceCodeFile());\n+   96:     }\n+   97: \n+   98:     private void reportCachedRuleViolations(final RuleContext ctx) {\n+   99:         for (final RuleViolation rv : configuration.getAnalysisCache().getCachedViolations(ctx.getSourceCodeFile())) {\n+  100:             ctx.getReport().addRuleViolation(rv);\n+  101:         }\n+  102:     }\n+  103: \n+  104:     private void processSourceCodeWithoutCache(final Reader sourceCode, final RuleSets ruleSets, final RuleContext ctx) throws PMDException {\n+  105:         try {\n+  106:             ruleSets.start(ctx);\n+  107:             processSource(sourceCode, ruleSets, ctx);\n+  108:         } catch (ParseException pe) {\n+  109:             configuration.getAnalysisCache().analysisFailed(ctx.getSourceCodeFile());\n+  110:             throw new PMDException(\"Error while parsing \" + ctx.getSourceCodeFile(), pe);\n+  111:         } catch (Exception e) {\n+  112:             configuration.getAnalysisCache().analysisFailed(ctx.getSourceCodeFile());\n+  113:             throw new PMDException(\"Error while processing \" + ctx.getSourceCodeFile(), e);\n+  114:         } finally {\n+  115:             ruleSets.end(ctx);\n+  116:         }\n+  117:     }\n",
        "uniqueId": "b84dfe80b597862ef5ee468a708b7c2dc4db7749_57_107_104_117_57_92",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 63,
                "covered": 28
            },
            "BRANCH": {
                "missed": 4,
                "covered": 2
            },
            "LINE": {
                "missed": 10,
                "covered": 8
            },
            "COMPLEXITY": {
                "missed": 3,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Move Method",
        "description": "Move Method\tpublic testStringWithBackslashes() : void from class net.sourceforge.pmd.cpd.DartTokenizerTest2 to public testStringWithBackslashes() : void from class net.sourceforge.pmd.cpd.DartTokenizerTest",
        "diffLocations": [
            {
                "filePath": "pmd-dart/src/test/java/net/sourceforge/pmd/cpd/DartTokenizerTest2.java",
                "startLine": 38,
                "endLine": 41,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-dart/src/test/java/net/sourceforge/pmd/cpd/DartTokenizerTest.java",
                "startLine": 73,
                "endLine": 76,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n    public void testStringWithBackslashes() {\n        doTest(\"string_with_backslashes\");\n    }",
        "filePathBefore": "pmd-dart/src/test/java/net/sourceforge/pmd/cpd/DartTokenizerTest2.java",
        "isPureRefactoring": true,
        "commitId": "1540ec6d9148fc14fc1673f4df1d33030d2ffcf7",
        "packageNameBefore": "net.sourceforge.pmd.cpd",
        "classNameBefore": "net.sourceforge.pmd.cpd.DartTokenizerTest2",
        "methodNameBefore": "net.sourceforge.pmd.cpd.DartTokenizerTest2#testStringWithBackslashes",
        "classSignatureBefore": "public class DartTokenizerTest2 extends CpdTextComparisonTest ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.cpd.DartTokenizerTest2#testStringWithBackslashes"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.cpd.DartTokenizerTest2"
        ],
        "classSignatureBeforeSet": [
            "public class DartTokenizerTest2 extends CpdTextComparisonTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.cpd;\n\nimport org.junit.Test;\n\nimport net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;\n\npublic class DartTokenizerTest2 extends CpdTextComparisonTest {\n\n    public DartTokenizerTest2() {\n        super(\".dart\");\n    }\n\n    @Override\n    protected String getResourcePrefix() {\n        return \"\";\n    }\n\n    @Override\n    public Tokenizer newTokenizer() {\n        return new DartTokenizer();\n    }\n\n    @Test\n    public void testComment() {\n        doTest(\"comment\");\n    }\n\n\n    @Test\n    public void testMultiline() {\n        doTest(\"string_multiline\");\n    }\n\n    @Test\n    public void testStringWithBackslashes() {\n        doTest(\"string_with_backslashes\");\n    }\n\n    @Test\n    public void testIncrement() {\n        doTest(\"increment\");\n    }\n\n\n\n}\n",
        "filePathAfter": "pmd-dart/src/test/java/net/sourceforge/pmd/cpd/DartTokenizerTest.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.cpd;\n\nimport org.junit.Test;\n\nimport net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;\n\npublic class DartTokenizerTest extends CpdTextComparisonTest {\n\n    public DartTokenizerTest() {\n        super(\".dart\");\n    }\n\n    @Override\n    public Tokenizer newTokenizer() {\n        return new DartTokenizer();\n    }\n\n\n    @Test\n    public void testComment() {\n        doTest(\"comment\");\n    }\n\n    @Test\n    public void testEscapeSequences() {\n        doTest(\"escape_sequences\");\n    }\n\n    @Test\n    public void testEscapedBackslash() {\n        doTest(\"escaped_backslash\");\n    }\n\n    @Test\n    public void testEscapedString() {\n        doTest(\"escaped_string\");\n    }\n\n\n    @Test\n    public void testIncrement() {\n        doTest(\"increment\");\n    }\n\n\n    @Test\n    public void testImports() {\n        doTest(\"imports\");\n    }\n\n\n\n    @Test\n    public void testRegex() {\n        doTest(\"regex\");\n    }\n\n\n    @Test\n    public void testRegex2() {\n        doTest(\"regex2\");\n    }\n\n    @Test\n    public void testRegex3() {\n        doTest(\"regex3\");\n    }\n\n    @Test\n    public void testStringWithBackslashes() {\n        doTest(\"string_with_backslashes\");\n    }\n\n    @Test\n    public void testMultiline() {\n        doTest(\"string_multiline\");\n    }\n\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "@Test\n    public void testStringWithBackslashes() {\n        doTest(\"string_with_backslashes\");\n    }",
        "diffSourceCode": "    38:     @Test\n-   39:     public void testStringWithBackslashes() {\n-   40:         doTest(\"string_with_backslashes\");\n+   39:     public void testEscapedString() {\n+   40:         doTest(\"escaped_string\");\n    41:     }\n+   73:     @Test\n+   74:     public void testStringWithBackslashes() {\n+   75:         doTest(\"string_with_backslashes\");\n+   76:     }\n",
        "uniqueId": "1540ec6d9148fc14fc1673f4df1d33030d2ffcf7_38_41__73_76",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Move Method",
        "description": "Move Method\tpublic testMultiline() : void from class net.sourceforge.pmd.cpd.DartTokenizerTest2 to public testMultiline() : void from class net.sourceforge.pmd.cpd.DartTokenizerTest",
        "diffLocations": [
            {
                "filePath": "pmd-dart/src/test/java/net/sourceforge/pmd/cpd/DartTokenizerTest2.java",
                "startLine": 33,
                "endLine": 36,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-dart/src/test/java/net/sourceforge/pmd/cpd/DartTokenizerTest.java",
                "startLine": 78,
                "endLine": 81,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n    public void testMultiline() {\n        doTest(\"string_multiline\");\n    }",
        "filePathBefore": "pmd-dart/src/test/java/net/sourceforge/pmd/cpd/DartTokenizerTest2.java",
        "isPureRefactoring": true,
        "commitId": "1540ec6d9148fc14fc1673f4df1d33030d2ffcf7",
        "packageNameBefore": "net.sourceforge.pmd.cpd",
        "classNameBefore": "net.sourceforge.pmd.cpd.DartTokenizerTest2",
        "methodNameBefore": "net.sourceforge.pmd.cpd.DartTokenizerTest2#testMultiline",
        "classSignatureBefore": "public class DartTokenizerTest2 extends CpdTextComparisonTest ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.cpd.DartTokenizerTest2#testMultiline"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.cpd.DartTokenizerTest2"
        ],
        "classSignatureBeforeSet": [
            "public class DartTokenizerTest2 extends CpdTextComparisonTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.cpd;\n\nimport org.junit.Test;\n\nimport net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;\n\npublic class DartTokenizerTest2 extends CpdTextComparisonTest {\n\n    public DartTokenizerTest2() {\n        super(\".dart\");\n    }\n\n    @Override\n    protected String getResourcePrefix() {\n        return \"\";\n    }\n\n    @Override\n    public Tokenizer newTokenizer() {\n        return new DartTokenizer();\n    }\n\n    @Test\n    public void testComment() {\n        doTest(\"comment\");\n    }\n\n\n    @Test\n    public void testMultiline() {\n        doTest(\"string_multiline\");\n    }\n\n    @Test\n    public void testStringWithBackslashes() {\n        doTest(\"string_with_backslashes\");\n    }\n\n    @Test\n    public void testIncrement() {\n        doTest(\"increment\");\n    }\n\n\n\n}\n",
        "filePathAfter": "pmd-dart/src/test/java/net/sourceforge/pmd/cpd/DartTokenizerTest.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.cpd;\n\nimport org.junit.Test;\n\nimport net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;\n\npublic class DartTokenizerTest extends CpdTextComparisonTest {\n\n    public DartTokenizerTest() {\n        super(\".dart\");\n    }\n\n    @Override\n    public Tokenizer newTokenizer() {\n        return new DartTokenizer();\n    }\n\n\n    @Test\n    public void testComment() {\n        doTest(\"comment\");\n    }\n\n    @Test\n    public void testEscapeSequences() {\n        doTest(\"escape_sequences\");\n    }\n\n    @Test\n    public void testEscapedBackslash() {\n        doTest(\"escaped_backslash\");\n    }\n\n    @Test\n    public void testEscapedString() {\n        doTest(\"escaped_string\");\n    }\n\n\n    @Test\n    public void testIncrement() {\n        doTest(\"increment\");\n    }\n\n\n    @Test\n    public void testImports() {\n        doTest(\"imports\");\n    }\n\n\n\n    @Test\n    public void testRegex() {\n        doTest(\"regex\");\n    }\n\n\n    @Test\n    public void testRegex2() {\n        doTest(\"regex2\");\n    }\n\n    @Test\n    public void testRegex3() {\n        doTest(\"regex3\");\n    }\n\n    @Test\n    public void testStringWithBackslashes() {\n        doTest(\"string_with_backslashes\");\n    }\n\n    @Test\n    public void testMultiline() {\n        doTest(\"string_multiline\");\n    }\n\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "@Test\n    public void testMultiline() {\n        doTest(\"string_multiline\");\n    }",
        "diffSourceCode": "    33:     @Test\n-   34:     public void testMultiline() {\n-   35:         doTest(\"string_multiline\");\n+   34:     public void testEscapedBackslash() {\n+   35:         doTest(\"escaped_backslash\");\n    36:     }\n+   78:     @Test\n+   79:     public void testMultiline() {\n+   80:         doTest(\"string_multiline\");\n+   81:     }\n",
        "uniqueId": "1540ec6d9148fc14fc1673f4df1d33030d2ffcf7_33_36__78_81",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Move Method",
        "description": "Move Method\tpublic testComment() : void from class net.sourceforge.pmd.cpd.DartTokenizerTest2 to public testComment() : void from class net.sourceforge.pmd.cpd.DartTokenizerTest",
        "diffLocations": [
            {
                "filePath": "pmd-dart/src/test/java/net/sourceforge/pmd/cpd/DartTokenizerTest2.java",
                "startLine": 27,
                "endLine": 30,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-dart/src/test/java/net/sourceforge/pmd/cpd/DartTokenizerTest.java",
                "startLine": 23,
                "endLine": 26,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n    public void testComment() {\n        doTest(\"comment\");\n    }",
        "filePathBefore": "pmd-dart/src/test/java/net/sourceforge/pmd/cpd/DartTokenizerTest2.java",
        "isPureRefactoring": true,
        "commitId": "1540ec6d9148fc14fc1673f4df1d33030d2ffcf7",
        "packageNameBefore": "net.sourceforge.pmd.cpd",
        "classNameBefore": "net.sourceforge.pmd.cpd.DartTokenizerTest2",
        "methodNameBefore": "net.sourceforge.pmd.cpd.DartTokenizerTest2#testComment",
        "classSignatureBefore": "public class DartTokenizerTest2 extends CpdTextComparisonTest ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.cpd.DartTokenizerTest2#testComment"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.cpd.DartTokenizerTest2"
        ],
        "classSignatureBeforeSet": [
            "public class DartTokenizerTest2 extends CpdTextComparisonTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.cpd;\n\nimport org.junit.Test;\n\nimport net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;\n\npublic class DartTokenizerTest2 extends CpdTextComparisonTest {\n\n    public DartTokenizerTest2() {\n        super(\".dart\");\n    }\n\n    @Override\n    protected String getResourcePrefix() {\n        return \"\";\n    }\n\n    @Override\n    public Tokenizer newTokenizer() {\n        return new DartTokenizer();\n    }\n\n    @Test\n    public void testComment() {\n        doTest(\"comment\");\n    }\n\n\n    @Test\n    public void testMultiline() {\n        doTest(\"string_multiline\");\n    }\n\n    @Test\n    public void testStringWithBackslashes() {\n        doTest(\"string_with_backslashes\");\n    }\n\n    @Test\n    public void testIncrement() {\n        doTest(\"increment\");\n    }\n\n\n\n}\n",
        "filePathAfter": "pmd-dart/src/test/java/net/sourceforge/pmd/cpd/DartTokenizerTest.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.cpd;\n\nimport org.junit.Test;\n\nimport net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;\n\npublic class DartTokenizerTest extends CpdTextComparisonTest {\n\n    public DartTokenizerTest() {\n        super(\".dart\");\n    }\n\n    @Override\n    public Tokenizer newTokenizer() {\n        return new DartTokenizer();\n    }\n\n\n    @Test\n    public void testComment() {\n        doTest(\"comment\");\n    }\n\n    @Test\n    public void testEscapeSequences() {\n        doTest(\"escape_sequences\");\n    }\n\n    @Test\n    public void testEscapedBackslash() {\n        doTest(\"escaped_backslash\");\n    }\n\n    @Test\n    public void testEscapedString() {\n        doTest(\"escaped_string\");\n    }\n\n\n    @Test\n    public void testIncrement() {\n        doTest(\"increment\");\n    }\n\n\n    @Test\n    public void testImports() {\n        doTest(\"imports\");\n    }\n\n\n\n    @Test\n    public void testRegex() {\n        doTest(\"regex\");\n    }\n\n\n    @Test\n    public void testRegex2() {\n        doTest(\"regex2\");\n    }\n\n    @Test\n    public void testRegex3() {\n        doTest(\"regex3\");\n    }\n\n    @Test\n    public void testStringWithBackslashes() {\n        doTest(\"string_with_backslashes\");\n    }\n\n    @Test\n    public void testMultiline() {\n        doTest(\"string_multiline\");\n    }\n\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "@Test\n    public void testComment() {\n        doTest(\"comment\");\n    }",
        "diffSourceCode": "-   23:     public Tokenizer newTokenizer() {\n-   24:         return new DartTokenizer();\n-   25:     }\n-   26: \n-   27:     @Test\n-   28:     public void testComment() {\n-   29:         doTest(\"comment\");\n-   30:     }\n+   23:     @Test\n+   24:     public void testComment() {\n+   25:         doTest(\"comment\");\n+   26:     }\n+   27: \n+   28:     @Test\n+   29:     public void testEscapeSequences() {\n+   30:         doTest(\"escape_sequences\");\n",
        "uniqueId": "1540ec6d9148fc14fc1673f4df1d33030d2ffcf7_27_30__23_26",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Move Method",
        "description": "Move Method\tpublic newTokenizer() : Tokenizer from class net.sourceforge.pmd.cpd.DartTokenizerTest2 to public newTokenizer() : Tokenizer from class net.sourceforge.pmd.cpd.DartTokenizerTest",
        "diffLocations": [
            {
                "filePath": "pmd-dart/src/test/java/net/sourceforge/pmd/cpd/DartTokenizerTest2.java",
                "startLine": 22,
                "endLine": 25,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-dart/src/test/java/net/sourceforge/pmd/cpd/DartTokenizerTest.java",
                "startLine": 17,
                "endLine": 20,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n    public Tokenizer newTokenizer() {\n        return new DartTokenizer();\n    }",
        "filePathBefore": "pmd-dart/src/test/java/net/sourceforge/pmd/cpd/DartTokenizerTest2.java",
        "isPureRefactoring": true,
        "commitId": "1540ec6d9148fc14fc1673f4df1d33030d2ffcf7",
        "packageNameBefore": "net.sourceforge.pmd.cpd",
        "classNameBefore": "net.sourceforge.pmd.cpd.DartTokenizerTest2",
        "methodNameBefore": "net.sourceforge.pmd.cpd.DartTokenizerTest2#newTokenizer",
        "classSignatureBefore": "public class DartTokenizerTest2 extends CpdTextComparisonTest ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.cpd.DartTokenizerTest2#newTokenizer"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.cpd.DartTokenizerTest2"
        ],
        "classSignatureBeforeSet": [
            "public class DartTokenizerTest2 extends CpdTextComparisonTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.cpd;\n\nimport org.junit.Test;\n\nimport net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;\n\npublic class DartTokenizerTest2 extends CpdTextComparisonTest {\n\n    public DartTokenizerTest2() {\n        super(\".dart\");\n    }\n\n    @Override\n    protected String getResourcePrefix() {\n        return \"\";\n    }\n\n    @Override\n    public Tokenizer newTokenizer() {\n        return new DartTokenizer();\n    }\n\n    @Test\n    public void testComment() {\n        doTest(\"comment\");\n    }\n\n\n    @Test\n    public void testMultiline() {\n        doTest(\"string_multiline\");\n    }\n\n    @Test\n    public void testStringWithBackslashes() {\n        doTest(\"string_with_backslashes\");\n    }\n\n    @Test\n    public void testIncrement() {\n        doTest(\"increment\");\n    }\n\n\n\n}\n",
        "filePathAfter": "pmd-dart/src/test/java/net/sourceforge/pmd/cpd/DartTokenizerTest.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.cpd;\n\nimport org.junit.Test;\n\nimport net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;\n\npublic class DartTokenizerTest extends CpdTextComparisonTest {\n\n    public DartTokenizerTest() {\n        super(\".dart\");\n    }\n\n    @Override\n    public Tokenizer newTokenizer() {\n        return new DartTokenizer();\n    }\n\n\n    @Test\n    public void testComment() {\n        doTest(\"comment\");\n    }\n\n    @Test\n    public void testEscapeSequences() {\n        doTest(\"escape_sequences\");\n    }\n\n    @Test\n    public void testEscapedBackslash() {\n        doTest(\"escaped_backslash\");\n    }\n\n    @Test\n    public void testEscapedString() {\n        doTest(\"escaped_string\");\n    }\n\n\n    @Test\n    public void testIncrement() {\n        doTest(\"increment\");\n    }\n\n\n    @Test\n    public void testImports() {\n        doTest(\"imports\");\n    }\n\n\n\n    @Test\n    public void testRegex() {\n        doTest(\"regex\");\n    }\n\n\n    @Test\n    public void testRegex2() {\n        doTest(\"regex2\");\n    }\n\n    @Test\n    public void testRegex3() {\n        doTest(\"regex3\");\n    }\n\n    @Test\n    public void testStringWithBackslashes() {\n        doTest(\"string_with_backslashes\");\n    }\n\n    @Test\n    public void testMultiline() {\n        doTest(\"string_multiline\");\n    }\n\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "@Override\n    public Tokenizer newTokenizer() {\n        return new DartTokenizer();\n    }",
        "diffSourceCode": "    17:     @Override\n-   18:     protected String getResourcePrefix() {\n-   19:         return \"\";\n+   18:     public Tokenizer newTokenizer() {\n+   19:         return new DartTokenizer();\n    20:     }\n-   22:     @Override\n-   23:     public Tokenizer newTokenizer() {\n-   24:         return new DartTokenizer();\n-   25:     }\n+   22: \n+   23:     @Test\n+   24:     public void testComment() {\n+   25:         doTest(\"comment\");\n",
        "uniqueId": "1540ec6d9148fc14fc1673f4df1d33030d2ffcf7_22_25__17_20",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Move And Rename Method",
        "description": "Move And Rename Method\tpublic DartTokenizerTest2() from class net.sourceforge.pmd.cpd.DartTokenizerTest2 to public DartTokenizerTest() from class net.sourceforge.pmd.cpd.DartTokenizerTest",
        "diffLocations": [
            {
                "filePath": "pmd-dart/src/test/java/net/sourceforge/pmd/cpd/DartTokenizerTest2.java",
                "startLine": 13,
                "endLine": 15,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-dart/src/test/java/net/sourceforge/pmd/cpd/DartTokenizerTest.java",
                "startLine": 13,
                "endLine": 15,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public DartTokenizerTest2() {\n        super(\".dart\");\n    }",
        "filePathBefore": "pmd-dart/src/test/java/net/sourceforge/pmd/cpd/DartTokenizerTest2.java",
        "isPureRefactoring": true,
        "commitId": "1540ec6d9148fc14fc1673f4df1d33030d2ffcf7",
        "packageNameBefore": "net.sourceforge.pmd.cpd",
        "classNameBefore": "net.sourceforge.pmd.cpd.DartTokenizerTest2",
        "methodNameBefore": "net.sourceforge.pmd.cpd.DartTokenizerTest2#DartTokenizerTest2",
        "classSignatureBefore": "public class DartTokenizerTest2 extends CpdTextComparisonTest ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.cpd.DartTokenizerTest2#DartTokenizerTest2"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.cpd.DartTokenizerTest2"
        ],
        "classSignatureBeforeSet": [
            "public class DartTokenizerTest2 extends CpdTextComparisonTest "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.cpd;\n\nimport org.junit.Test;\n\nimport net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;\n\npublic class DartTokenizerTest2 extends CpdTextComparisonTest {\n\n    public DartTokenizerTest2() {\n        super(\".dart\");\n    }\n\n    @Override\n    protected String getResourcePrefix() {\n        return \"\";\n    }\n\n    @Override\n    public Tokenizer newTokenizer() {\n        return new DartTokenizer();\n    }\n\n    @Test\n    public void testComment() {\n        doTest(\"comment\");\n    }\n\n\n    @Test\n    public void testMultiline() {\n        doTest(\"string_multiline\");\n    }\n\n    @Test\n    public void testStringWithBackslashes() {\n        doTest(\"string_with_backslashes\");\n    }\n\n    @Test\n    public void testIncrement() {\n        doTest(\"increment\");\n    }\n\n\n\n}\n",
        "filePathAfter": "pmd-dart/src/test/java/net/sourceforge/pmd/cpd/DartTokenizerTest.java",
        "sourceCodeAfterForWhole": "/*\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.cpd;\n\nimport org.junit.Test;\n\nimport net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;\n\npublic class DartTokenizerTest extends CpdTextComparisonTest {\n\n    public DartTokenizerTest() {\n        super(\".dart\");\n    }\n\n    @Override\n    public Tokenizer newTokenizer() {\n        return new DartTokenizer();\n    }\n\n\n    @Test\n    public void testComment() {\n        doTest(\"comment\");\n    }\n\n    @Test\n    public void testEscapeSequences() {\n        doTest(\"escape_sequences\");\n    }\n\n    @Test\n    public void testEscapedBackslash() {\n        doTest(\"escaped_backslash\");\n    }\n\n    @Test\n    public void testEscapedString() {\n        doTest(\"escaped_string\");\n    }\n\n\n    @Test\n    public void testIncrement() {\n        doTest(\"increment\");\n    }\n\n\n    @Test\n    public void testImports() {\n        doTest(\"imports\");\n    }\n\n\n\n    @Test\n    public void testRegex() {\n        doTest(\"regex\");\n    }\n\n\n    @Test\n    public void testRegex2() {\n        doTest(\"regex2\");\n    }\n\n    @Test\n    public void testRegex3() {\n        doTest(\"regex3\");\n    }\n\n    @Test\n    public void testStringWithBackslashes() {\n        doTest(\"string_with_backslashes\");\n    }\n\n    @Test\n    public void testMultiline() {\n        doTest(\"string_multiline\");\n    }\n\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "public DartTokenizerTest() {\n        super(\".dart\");\n    }",
        "diffSourceCode": "-   13:     public DartTokenizerTest2() {\n+   13:     public DartTokenizerTest() {\n    14:         super(\".dart\");\n    15:     }\n",
        "uniqueId": "1540ec6d9148fc14fc1673f4df1d33030d2ffcf7_13_15__13_15",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        }
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate isForeignGetterSetterCall(methodOrAttributeName String) : boolean extracted from private isForeignGetterSetterCall(node ASTPrimaryExpression) : boolean in class net.sourceforge.pmd.lang.java.metrics.impl.visitors.AtfdBaseVisitor",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/impl/visitors/AtfdBaseVisitor.java",
                "startLine": 44,
                "endLine": 49,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/impl/visitors/AtfdBaseVisitor.java",
                "startLine": 46,
                "endLine": 49,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/impl/visitors/AtfdBaseVisitor.java",
                "startLine": 52,
                "endLine": 54,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private boolean isForeignGetterSetterCall(ASTPrimaryExpression node) {\n\n        String methodOrAttributeName = getMethodOrAttributeName(node);\n\n        return methodOrAttributeName != null && StringUtils.startsWithAny(methodOrAttributeName, \"get\", \"is\", \"set\");\n    }",
        "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/impl/visitors/AtfdBaseVisitor.java",
        "isPureRefactoring": true,
        "commitId": "1ef5079b29401bdb0df6e773f0160fa54f779018",
        "packageNameBefore": "net.sourceforge.pmd.lang.java.metrics.impl.visitors",
        "classNameBefore": "net.sourceforge.pmd.lang.java.metrics.impl.visitors.AtfdBaseVisitor",
        "methodNameBefore": "net.sourceforge.pmd.lang.java.metrics.impl.visitors.AtfdBaseVisitor#isForeignGetterSetterCall",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.java.metrics.impl.visitors.AtfdBaseVisitor#getMethodOrAttributeName\n methodBody: private String getMethodOrAttributeName(ASTPrimaryExpression node) {\nASTPrimaryPrefix prefix=node.getFirstDescendantOfType(ASTPrimaryPrefix.class);\nASTName name=prefix.getFirstDescendantOfType(ASTName.class);\nString methodOrAttributeName=null;\nif(name != null){int dotIndex=name.getImage().indexOf(\".\");\nif(dotIndex > -1){methodOrAttributeName=name.getImage().substring(dotIndex + 1);\n}}return methodOrAttributeName;\n}",
        "classSignatureBefore": "public class AtfdBaseVisitor extends JavaParserVisitorAdapter ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.metrics.impl.visitors.AtfdBaseVisitor#isForeignGetterSetterCall"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.metrics.impl.visitors.AtfdBaseVisitor"
        ],
        "classSignatureBeforeSet": [
            "public class AtfdBaseVisitor extends JavaParserVisitorAdapter "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.metrics.impl.visitors;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.mutable.MutableInt;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.lang.java.ast.ASTAllocationExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTName;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimarySuffix;\nimport net.sourceforge.pmd.lang.java.ast.JavaParserVisitorAdapter;\n\n/**\n * Computes Atfd.\n *\n * @author Cl\u00e9ment Fournier\n * @since 6.0.0\n * @deprecated Is internal API, will be moved in 7.0.0\n */\n@Deprecated\n@InternalApi\npublic class AtfdBaseVisitor extends JavaParserVisitorAdapter {\n\n\n    @Override\n    public Object visit(ASTPrimaryExpression node, Object data) {\n        if (isForeignAttributeOrMethod(node) && (isAttributeAccess(node)\n            || isMethodCall(node) && isForeignGetterSetterCall(node))) {\n\n            ((MutableInt) data).increment();\n        }\n        return super.visit(node, data);\n    }\n\n\n    private boolean isForeignGetterSetterCall(ASTPrimaryExpression node) {\n\n        String methodOrAttributeName = getMethodOrAttributeName(node);\n\n        return methodOrAttributeName != null && StringUtils.startsWithAny(methodOrAttributeName, \"get\", \"is\", \"set\");\n    }\n\n\n    private boolean isMethodCall(ASTPrimaryExpression node) {\n        boolean result = false;\n        List<ASTPrimarySuffix> suffixes = node.findDescendantsOfType(ASTPrimarySuffix.class);\n        if (suffixes.size() == 1) {\n            result = suffixes.get(0).isArguments();\n        }\n        return result;\n    }\n\n\n    private boolean isForeignAttributeOrMethod(ASTPrimaryExpression node) {\n        boolean result;\n        String nameImage = getNameImage(node);\n\n        if (nameImage != null && (!nameImage.contains(\".\") || nameImage.startsWith(\"this.\"))) {\n            result = false;\n        } else if (nameImage == null && node.getFirstDescendantOfType(ASTPrimaryPrefix.class).usesThisModifier()) {\n            result = false;\n        } else if (nameImage == null && node.hasDescendantOfAnyType(ASTLiteral.class, ASTAllocationExpression.class)) {\n            result = false;\n        } else {\n            result = true;\n        }\n\n        return result;\n    }\n\n\n    private String getNameImage(ASTPrimaryExpression node) {\n        ASTPrimaryPrefix prefix = node.getFirstDescendantOfType(ASTPrimaryPrefix.class);\n        ASTName name = prefix.getFirstDescendantOfType(ASTName.class);\n\n        String image = null;\n        if (name != null) {\n            image = name.getImage();\n        }\n        return image;\n    }\n\n\n    private String getMethodOrAttributeName(ASTPrimaryExpression node) {\n        ASTPrimaryPrefix prefix = node.getFirstDescendantOfType(ASTPrimaryPrefix.class);\n        ASTName name = prefix.getFirstDescendantOfType(ASTName.class);\n\n        String methodOrAttributeName = null;\n\n        if (name != null) {\n            int dotIndex = name.getImage().indexOf(\".\");\n            if (dotIndex > -1) {\n                methodOrAttributeName = name.getImage().substring(dotIndex + 1);\n            }\n        }\n\n        return methodOrAttributeName;\n    }\n\n\n    private boolean isAttributeAccess(ASTPrimaryExpression node) {\n        return !node.hasDescendantOfType(ASTPrimarySuffix.class);\n    }\n\n}\n",
        "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/impl/visitors/AtfdBaseVisitor.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.metrics.impl.visitors;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.mutable.MutableInt;\n\nimport net.sourceforge.pmd.annotation.InternalApi;\nimport net.sourceforge.pmd.lang.java.ast.ASTAllocationExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTLiteral;\nimport net.sourceforge.pmd.lang.java.ast.ASTName;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;\nimport net.sourceforge.pmd.lang.java.ast.ASTPrimarySuffix;\nimport net.sourceforge.pmd.lang.java.ast.JavaParserVisitorAdapter;\n\n/**\n * Computes Atfd.\n *\n * @author Cl\u00e9ment Fournier\n * @since 6.0.0\n * @deprecated Is internal API, will be moved in 7.0.0\n */\n@Deprecated\n@InternalApi\npublic class AtfdBaseVisitor extends JavaParserVisitorAdapter {\n\n\n    @Override\n    public Object visit(ASTPrimaryExpression node, Object data) {\n        if (isForeignAttributeOrMethod(node)) {\n            if (isAttributeAccess(node)) {\n                ((MutableInt) data).increment();\n            } else {\n                ((MutableInt) data).add(countForeignGetterSetterCalls(node));\n            }\n        }\n        return super.visit(node, data);\n    }\n\n\n    private boolean isForeignGetterSetterCall(ASTPrimaryExpression node) {\n        String methodOrAttributeName = getMethodOrAttributeName(node);\n        return isForeignGetterSetterCall(methodOrAttributeName);\n    }\n\n\n    private boolean isForeignGetterSetterCall(String methodOrAttributeName) {\n        return methodOrAttributeName != null && StringUtils.startsWithAny(methodOrAttributeName, \"get\", \"is\", \"set\");\n    }\n\n\n    private int countForeignGetterSetterCalls(ASTPrimaryExpression node) {\n        if (!isForeignGetterSetterCall(node) || !isForeignAttributeOrMethod(node)) {\n            return 0;\n        }\n\n        List<ASTPrimarySuffix> suffixes = node.findDescendantsOfType(ASTPrimarySuffix.class);\n        int result = 0;\n        for (ASTPrimarySuffix suffix : suffixes) {\n            if (suffix.isArguments()) {\n                result++;\n            } else {\n                String methodOrAttributeName = getMethodOrAttributeName(suffix);\n                if (!isForeignGetterSetterCall(methodOrAttributeName)) {\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n\n\n    private boolean isForeignAttributeOrMethod(ASTPrimaryExpression node) {\n        boolean result;\n        String nameImage = getNameImage(node);\n\n        if (nameImage != null && (!nameImage.contains(\".\") || nameImage.startsWith(\"this.\"))) {\n            result = false;\n        } else if (nameImage == null && node.getFirstDescendantOfType(ASTPrimaryPrefix.class).usesThisModifier()) {\n            result = false;\n        } else if (nameImage == null && node.hasDescendantOfAnyType(ASTLiteral.class, ASTAllocationExpression.class)) {\n            result = false;\n        } else {\n            result = true;\n        }\n\n        return result;\n    }\n\n\n    private String getNameImage(ASTPrimaryExpression node) {\n        ASTPrimaryPrefix prefix = node.getFirstDescendantOfType(ASTPrimaryPrefix.class);\n        ASTName name = prefix.getFirstDescendantOfType(ASTName.class);\n\n        String image = null;\n        if (name != null) {\n            image = name.getImage();\n        }\n        return image;\n    }\n\n\n    private String getMethodOrAttributeName(ASTPrimaryExpression node) {\n        ASTPrimaryPrefix prefix = node.getFirstDescendantOfType(ASTPrimaryPrefix.class);\n        ASTName name = prefix.getFirstDescendantOfType(ASTName.class);\n\n        String methodOrAttributeName = null;\n\n        if (name != null) {\n            int dotIndex = name.getImage().indexOf(\".\");\n            if (dotIndex > -1) {\n                methodOrAttributeName = name.getImage().substring(dotIndex + 1);\n            }\n        }\n\n        return methodOrAttributeName;\n    }\n\n\n    private String getMethodOrAttributeName(ASTPrimarySuffix node) {\n        return node.getImage();\n    }\n\n\n    private boolean isAttributeAccess(ASTPrimaryExpression node) {\n        return !node.hasDescendantOfType(ASTPrimarySuffix.class);\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "private boolean isForeignGetterSetterCall(String methodOrAttributeName) {\n        return methodOrAttributeName != null && StringUtils.startsWithAny(methodOrAttributeName, \"get\", \"is\", \"set\");\n    }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.java.metrics.impl.visitors.AtfdBaseVisitor#getMethodOrAttributeName\n methodBody: private String getMethodOrAttributeName(ASTPrimaryExpression node) {\nASTPrimaryPrefix prefix=node.getFirstDescendantOfType(ASTPrimaryPrefix.class);\nASTName name=prefix.getFirstDescendantOfType(ASTName.class);\nString methodOrAttributeName=null;\nif(name != null){int dotIndex=name.getImage().indexOf(\".\");\nif(dotIndex > -1){methodOrAttributeName=name.getImage().substring(dotIndex + 1);\n}}return methodOrAttributeName;\n}"
        ],
        "sourceCodeAfterRefactoring": "private boolean isForeignGetterSetterCall(ASTPrimaryExpression node) {\n        String methodOrAttributeName = getMethodOrAttributeName(node);\n        return isForeignGetterSetterCall(methodOrAttributeName);\n    }\nprivate boolean isForeignGetterSetterCall(String methodOrAttributeName) {\n        return methodOrAttributeName != null && StringUtils.startsWithAny(methodOrAttributeName, \"get\", \"is\", \"set\");\n    }",
        "diffSourceCode": "-   44:     private boolean isForeignGetterSetterCall(ASTPrimaryExpression node) {\n+   44: \n    45: \n-   46:         String methodOrAttributeName = getMethodOrAttributeName(node);\n-   47: \n-   48:         return methodOrAttributeName != null && StringUtils.startsWithAny(methodOrAttributeName, \"get\", \"is\", \"set\");\n+   46:     private boolean isForeignGetterSetterCall(ASTPrimaryExpression node) {\n+   47:         String methodOrAttributeName = getMethodOrAttributeName(node);\n+   48:         return isForeignGetterSetterCall(methodOrAttributeName);\n    49:     }\n-   52:     private boolean isMethodCall(ASTPrimaryExpression node) {\n-   53:         boolean result = false;\n-   54:         List<ASTPrimarySuffix> suffixes = node.findDescendantsOfType(ASTPrimarySuffix.class);\n+   52:     private boolean isForeignGetterSetterCall(String methodOrAttributeName) {\n+   53:         return methodOrAttributeName != null && StringUtils.startsWithAny(methodOrAttributeName, \"get\", \"is\", \"set\");\n+   54:     }\n",
        "uniqueId": "1ef5079b29401bdb0df6e773f0160fa54f779018_44_49_52_54_46_49",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 27
            },
            "BRANCH": {
                "missed": 1,
                "covered": 3
            },
            "LINE": {
                "missed": 0,
                "covered": 2
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 2
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Move Method",
        "description": "Move Method\tprotected displayName(name String) : String from class net.sourceforge.pmd.lang.apex.rule.codestyle.MethodRegexNamingConventionsRule to protected displayName(name String) : String from class net.sourceforge.pmd.lang.apex.rule.codestyle.ClassNamingConventionsRule",
        "diffLocations": [
            {
                "filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/codestyle/MethodRegexNamingConventionsRule.java",
                "startLine": 61,
                "endLine": 64,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/codestyle/ClassNamingConventionsRule.java",
                "startLine": 78,
                "endLine": 81,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n    protected String displayName(String name) {\n        return DESCRIPTOR_TO_DISPLAY_NAME.get(name);\n    }",
        "filePathBefore": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/codestyle/MethodRegexNamingConventionsRule.java",
        "isPureRefactoring": true,
        "commitId": "6e937ed1a9f5bc601b3206920c84f395b9875452",
        "packageNameBefore": "net.sourceforge.pmd.lang.apex.rule.codestyle",
        "classNameBefore": "net.sourceforge.pmd.lang.apex.rule.codestyle.MethodRegexNamingConventionsRule",
        "methodNameBefore": "net.sourceforge.pmd.lang.apex.rule.codestyle.MethodRegexNamingConventionsRule#displayName",
        "classSignatureBefore": "public class MethodRegexNamingConventionsRule extends AbstractRegexNamingConventionsRule ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.apex.rule.codestyle.MethodRegexNamingConventionsRule#displayName"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.apex.rule.codestyle.MethodRegexNamingConventionsRule"
        ],
        "classSignatureBeforeSet": [
            "public class MethodRegexNamingConventionsRule extends AbstractRegexNamingConventionsRule "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex.rule.codestyle;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Pattern;\n\nimport net.sourceforge.pmd.lang.apex.ast.ASTMethod;\nimport net.sourceforge.pmd.lang.apex.ast.ASTProperty;\nimport net.sourceforge.pmd.lang.apex.ast.ASTUserEnum;\nimport net.sourceforge.pmd.properties.PropertyDescriptor;\n\npublic class MethodRegexNamingConventionsRule extends AbstractRegexNamingConventionsRule {\n    private static final Map<String, String> DESCRIPTOR_TO_DISPLAY_NAME = new HashMap<>();\n\n    private static final PropertyDescriptor<Pattern> TEST_REGEX = prop(\"testPattern\", \"test method\",\n            DESCRIPTOR_TO_DISPLAY_NAME).defaultValue(CAMEL_CASE).build();\n\n    private static final PropertyDescriptor<Pattern> STATIC_REGEX = prop(\"staticPattern\", \"static method\",\n            DESCRIPTOR_TO_DISPLAY_NAME).defaultValue(CAMEL_CASE).build();\n\n    private static final PropertyDescriptor<Pattern> INSTANCE_REGEX = prop(\"instancePattern\", \"instance method\",\n            DESCRIPTOR_TO_DISPLAY_NAME).defaultValue(CAMEL_CASE).build();\n\n    public MethodRegexNamingConventionsRule() {\n        definePropertyDescriptor(TEST_REGEX);\n        definePropertyDescriptor(STATIC_REGEX);\n        definePropertyDescriptor(INSTANCE_REGEX);\n\n        addRuleChainVisit(ASTMethod.class);\n    }\n\n    @Override\n    public Object visit(ASTMethod node, Object data) {\n        if (isOverriddenMethod(node) || isPropertyAccessor(node) || isConstructor(node)) {\n            return data;\n        }\n\n        if (\"<clinit>\".equals(node.getImage()) || \"clone\".equals(node.getImage())) {\n            return data;\n        }\n\n        if (node.getFirstParentOfType(ASTUserEnum.class) != null) {\n            return data;\n        }\n\n        if (node.getModifiers().isTest()) {\n            checkMatches(TEST_REGEX, node, data);\n        } else if (node.getModifiers().isStatic()) {\n            checkMatches(STATIC_REGEX, node, data);\n        } else {\n            checkMatches(INSTANCE_REGEX, node, data);\n        }\n\n        return data;\n    }\n\n    @Override\n    protected String displayName(String name) {\n        return DESCRIPTOR_TO_DISPLAY_NAME.get(name);\n    }\n\n    private boolean isOverriddenMethod(ASTMethod node) {\n        return node.getModifiers().isOverride();\n    }\n\n    private boolean isPropertyAccessor(ASTMethod node) {\n        return !node.getParentsOfType(ASTProperty.class).isEmpty();\n    }\n\n    private boolean isConstructor(ASTMethod node) {\n        return node.isConstructor();\n    }\n}\n",
        "filePathAfter": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/codestyle/ClassNamingConventionsRule.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex.rule.codestyle;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Pattern;\n\nimport net.sourceforge.pmd.lang.apex.ast.ASTUserClass;\nimport net.sourceforge.pmd.lang.apex.ast.ASTUserEnum;\nimport net.sourceforge.pmd.lang.apex.ast.ASTUserInterface;\nimport net.sourceforge.pmd.properties.PropertyDescriptor;\n\npublic class ClassNamingConventionsRule extends AbstractNamingConventionsRule {\n    private static final Map<String, String> DESCRIPTOR_TO_DISPLAY_NAME = new HashMap<>();\n\n    private static final PropertyDescriptor<Pattern> TEST_CLASS_REGEX = prop(\"testClassPattern\", \"test class\",\n            DESCRIPTOR_TO_DISPLAY_NAME).defaultValue(PASCAL_CASE_WITH_UNDERSCORES).build();\n\n    private static final PropertyDescriptor<Pattern> ABSTRACT_CLASS_REGEX = prop(\"abstractClassPattern\", \"abstract class\",\n            DESCRIPTOR_TO_DISPLAY_NAME).defaultValue(PASCAL_CASE_WITH_UNDERSCORES).build();\n\n    private static final PropertyDescriptor<Pattern> CLASS_REGEX = prop(\"classPattern\", \"class\",\n            DESCRIPTOR_TO_DISPLAY_NAME).defaultValue(PASCAL_CASE_WITH_UNDERSCORES).build();\n\n    private static final PropertyDescriptor<Pattern> INTERFACE_REGEX = prop(\"interfacePattern\", \"interface\",\n            DESCRIPTOR_TO_DISPLAY_NAME).defaultValue(PASCAL_CASE_WITH_UNDERSCORES).build();\n\n    private static final PropertyDescriptor<Pattern> ENUM_REGEX = prop(\"enumPattern\", \"enum\",\n            DESCRIPTOR_TO_DISPLAY_NAME).defaultValue(PASCAL_CASE_WITH_UNDERSCORES).build();\n\n    public ClassNamingConventionsRule() {\n        definePropertyDescriptor(TEST_CLASS_REGEX);\n        definePropertyDescriptor(ABSTRACT_CLASS_REGEX);\n        definePropertyDescriptor(CLASS_REGEX);\n        definePropertyDescriptor(INTERFACE_REGEX);\n        definePropertyDescriptor(ENUM_REGEX);\n\n        setProperty(CODECLIMATE_CATEGORIES, \"Style\");\n        // Note: x10 as Apex has not automatic refactoring\n        setProperty(CODECLIMATE_REMEDIATION_MULTIPLIER, 5);\n        setProperty(CODECLIMATE_BLOCK_HIGHLIGHTING, false);\n\n        addRuleChainVisit(ASTUserClass.class);\n        addRuleChainVisit(ASTUserInterface.class);\n        addRuleChainVisit(ASTUserEnum.class);\n    }\n\n    @Override\n    public Object visit(ASTUserClass node, Object data) {\n        if (node.getModifiers().isTest()) {\n            checkMatches(TEST_CLASS_REGEX, node, data);\n        } else if (node.getModifiers().isAbstract()) {\n            checkMatches(ABSTRACT_CLASS_REGEX, node, data);\n        } else {\n            checkMatches(CLASS_REGEX, node, data);\n        }\n\n        return data;\n    }\n\n    @Override\n    public Object visit(ASTUserInterface node, Object data) {\n        checkMatches(INTERFACE_REGEX, node, data);\n\n        return data;\n    }\n\n    @Override\n    public Object visit(ASTUserEnum node, Object data) {\n        checkMatches(ENUM_REGEX, node, data);\n\n        return data;\n    }\n\n    @Override\n    protected String displayName(String name) {\n        return DESCRIPTOR_TO_DISPLAY_NAME.get(name);\n    }\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "@Override\n    protected String displayName(String name) {\n        return DESCRIPTOR_TO_DISPLAY_NAME.get(name);\n    }",
        "diffSourceCode": "-   61:     @Override\n-   62:     protected String displayName(String name) {\n-   63:         return DESCRIPTOR_TO_DISPLAY_NAME.get(name);\n-   64:     }\n+   61:         return data;\n+   62:     }\n+   63: \n+   64:     @Override\n+   78:     @Override\n+   79:     protected String displayName(String name) {\n+   80:         return DESCRIPTOR_TO_DISPLAY_NAME.get(name);\n+   81:     }\n",
        "uniqueId": "6e937ed1a9f5bc601b3206920c84f395b9875452_61_64__78_81",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 5
            },
            "LINE": {
                "missed": 0,
                "covered": 1
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic visit(node ASTExpression, data Object) : Object extracted from public visit(node ASTSwitchStatement, data Object) : Object in class net.sourceforge.pmd.lang.java.rule.design.SwitchDensityRule & moved to class net.sourceforge.pmd.lang.java.rule.design.SwitchDensityRule.SwitchDensityVisitor",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/SwitchDensityRule.java",
                "startLine": 58,
                "endLine": 81,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/SwitchDensityRule.java",
                "startLine": 43,
                "endLine": 50,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/SwitchDensityRule.java",
                "startLine": 72,
                "endLine": 76,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n    public Object visit(ASTSwitchStatement node, Object data) {\n        SwitchDensity oldData = null;\n\n        if (data instanceof SwitchDensity) {\n            oldData = (SwitchDensity) data;\n        }\n\n        SwitchDensity density = new SwitchDensity();\n\n        node.childrenAccept(this, density);\n\n        DataPoint point = new DataPoint();\n        point.setNode(node);\n        point.setScore(density.getDensity());\n        point.setMessage(getMessage());\n\n        addDataPoint(point);\n\n        if (data instanceof SwitchDensity) {\n            ((SwitchDensity) data).addStatements(density.getStatementCount());\n        }\n        return oldData;\n    }",
        "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/SwitchDensityRule.java",
        "isPureRefactoring": true,
        "commitId": "2995f156caf2b55369ef28108f0b6077e4186eb2",
        "packageNameBefore": "net.sourceforge.pmd.lang.java.rule.design",
        "classNameBefore": "net.sourceforge.pmd.lang.java.rule.design.SwitchDensityRule",
        "methodNameBefore": "net.sourceforge.pmd.lang.java.rule.design.SwitchDensityRule#visit",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.java.rule.design.SwitchDensityRule.SwitchDensity#addStatements\n methodBody: public void addStatements(int stmtCount) {\nstmts+=stmtCount;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.rule.design.SwitchDensityRule.SwitchDensity#getStatementCount\n methodBody: public int getStatementCount() {\nreturn stmts;\n}\nmethodSignature: net.sourceforge.pmd.lang.java.rule.design.SwitchDensityRule.SwitchDensity#getDensity\n methodBody: public double getDensity() {\nif(labels == 0){return 0;\n}return (double)stmts / (double)labels;\n}",
        "classSignatureBefore": "public class SwitchDensityRule extends AbstractStatisticalJavaRule ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.rule.design.SwitchDensityRule#visit"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.rule.design.SwitchDensityRule"
        ],
        "classSignatureBeforeSet": [
            "public class SwitchDensityRule extends AbstractStatisticalJavaRule "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.rule.design;\n\nimport net.sourceforge.pmd.lang.java.ast.ASTStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTSwitchLabel;\nimport net.sourceforge.pmd.lang.java.ast.ASTSwitchStatement;\nimport net.sourceforge.pmd.lang.java.rule.AbstractStatisticalJavaRule;\nimport net.sourceforge.pmd.stat.DataPoint;\n\n/**\n * Switch Density - This is the number of statements over the number of\n * cases within a switch. The higher the value, the more work each case\n * is doing.\n *\n * <p>Its my theory, that when the Switch Density is high, you should start\n * looking at Subclasses or State Pattern to alleviate the problem.</p>\n *\n * @author David Dixon-Peugh\n */\npublic class SwitchDensityRule extends AbstractStatisticalJavaRule {\n\n    private static class SwitchDensity {\n        private int labels = 0;\n        private int stmts = 0;\n\n        public void addSwitchLabel() {\n            labels++;\n        }\n\n        public void addStatement() {\n            stmts++;\n        }\n\n        public void addStatements(int stmtCount) {\n            stmts += stmtCount;\n        }\n\n        public int getStatementCount() {\n            return stmts;\n        }\n\n        public double getDensity() {\n            if (labels == 0) {\n                return 0;\n            }\n            return (double) stmts / (double) labels;\n        }\n    }\n\n    public SwitchDensityRule() {\n        super();\n        setProperty(MINIMUM_DESCRIPTOR, 10d);\n    }\n\n    @Override\n    public Object visit(ASTSwitchStatement node, Object data) {\n        SwitchDensity oldData = null;\n\n        if (data instanceof SwitchDensity) {\n            oldData = (SwitchDensity) data;\n        }\n\n        SwitchDensity density = new SwitchDensity();\n\n        node.childrenAccept(this, density);\n\n        DataPoint point = new DataPoint();\n        point.setNode(node);\n        point.setScore(density.getDensity());\n        point.setMessage(getMessage());\n\n        addDataPoint(point);\n\n        if (data instanceof SwitchDensity) {\n            ((SwitchDensity) data).addStatements(density.getStatementCount());\n        }\n        return oldData;\n    }\n\n    @Override\n    public Object visit(ASTStatement statement, Object data) {\n        if (data instanceof SwitchDensity) {\n            ((SwitchDensity) data).addStatement();\n        }\n\n        statement.childrenAccept(this, data);\n\n        return data;\n    }\n\n    @Override\n    public Object visit(ASTSwitchLabel switchLabel, Object data) {\n        if (data instanceof SwitchDensity) {\n            ((SwitchDensity) data).addSwitchLabel();\n        }\n\n        switchLabel.childrenAccept(this, data);\n        return data;\n    }\n}\n",
        "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/design/SwitchDensityRule.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.rule.design;\n\nimport static net.sourceforge.pmd.properties.constraints.NumericConstraints.positive;\n\nimport net.sourceforge.pmd.lang.java.ast.ASTExpression;\nimport net.sourceforge.pmd.lang.java.ast.ASTStatement;\nimport net.sourceforge.pmd.lang.java.ast.ASTSwitchLabel;\nimport net.sourceforge.pmd.lang.java.ast.ASTSwitchStatement;\nimport net.sourceforge.pmd.lang.java.ast.JavaParserVisitorAdapter;\nimport net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;\nimport net.sourceforge.pmd.properties.PropertyDescriptor;\nimport net.sourceforge.pmd.properties.PropertyFactory;\n\n/**\n * Switch Density - This is the number of statements over the number of\n * cases within a switch. The higher the value, the more work each case\n * is doing.\n *\n * <p>Its my theory, that when the Switch Density is high, you should start\n * looking at Subclasses or State Pattern to alleviate the problem.</p>\n *\n * @author David Dixon-Peugh\n */\npublic class SwitchDensityRule extends AbstractJavaRulechainRule {\n\n    private static final PropertyDescriptor<Double> REPORT_LEVEL =\n        // can't use CommonPropertyDescriptors because we need a double property\n        PropertyFactory.doubleProperty(\"minimum\")\n                       .desc(\"Threshold above which a node is reported\")\n                       .require(positive())\n                       .defaultValue(10d)\n                       .build();\n\n    public SwitchDensityRule() {\n        super(ASTSwitchStatement.class);\n        definePropertyDescriptor(REPORT_LEVEL);\n    }\n\n    @Override\n    public Object visit(ASTSwitchStatement node, Object data) {\n        double density = new SwitchDensityVisitor().compute(node);\n        if (density >= getProperty(REPORT_LEVEL)) {\n            addViolation(data, node);\n        }\n        return super.visit(node, data);\n    }\n\n    private static class SwitchDensityVisitor extends JavaParserVisitorAdapter {\n\n        private int labels = 0;\n        private int stmts = 0;\n        private ASTSwitchStatement root;\n\n\n        double compute(ASTSwitchStatement root) {\n            this.root = root;\n            root.jjtAccept(this, null);\n            return labels == 0 ? 0 : ((double) stmts) / labels;\n        }\n\n\n        @Override\n        public Object visit(ASTStatement statement, Object data) {\n            stmts++;\n            return super.visit(statement, data);\n        }\n\n        @Override\n        public Object visit(ASTExpression node, Object data) {\n            // don't recurse on anonymous class, etc\n            return data;\n        }\n\n        @Override\n        public Object visit(ASTSwitchLabel switchLabel, Object data) {\n            if (switchLabel.jjtGetParent() == root) {\n                labels++;\n            }\n            return super.visit(switchLabel, data);\n        }\n    }\n}\n",
        "diffSourceCodeSet": [
            "@Override\n        public Object visit(ASTExpression node, Object data) {\n            // don't recurse on anonymous class, etc\n            return data;\n        }"
        ],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.java.rule.design.SwitchDensityRule.SwitchDensity#addStatements\n methodBody: public void addStatements(int stmtCount) {\nstmts+=stmtCount;\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.rule.design.SwitchDensityRule.SwitchDensity#getStatementCount\n methodBody: public int getStatementCount() {\nreturn stmts;\n}",
            "methodSignature: net.sourceforge.pmd.lang.java.rule.design.SwitchDensityRule.SwitchDensity#getDensity\n methodBody: public double getDensity() {\nif(labels == 0){return 0;\n}return (double)stmts / (double)labels;\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n    public Object visit(ASTSwitchStatement node, Object data) {\n        double density = new SwitchDensityVisitor().compute(node);\n        if (density >= getProperty(REPORT_LEVEL)) {\n            addViolation(data, node);\n        }\n        return super.visit(node, data);\n    }\n@Override\n        public Object visit(ASTExpression node, Object data) {\n            // don't recurse on anonymous class, etc\n            return data;\n        }",
        "diffSourceCode": "-   43:         }\n-   44: \n-   45:         public double getDensity() {\n-   46:             if (labels == 0) {\n-   47:                 return 0;\n-   48:             }\n-   49:             return (double) stmts / (double) labels;\n-   50:         }\n-   58:     @Override\n-   59:     public Object visit(ASTSwitchStatement node, Object data) {\n-   60:         SwitchDensity oldData = null;\n-   61: \n-   62:         if (data instanceof SwitchDensity) {\n-   63:             oldData = (SwitchDensity) data;\n-   64:         }\n+   43:     @Override\n+   44:     public Object visit(ASTSwitchStatement node, Object data) {\n+   45:         double density = new SwitchDensityVisitor().compute(node);\n+   46:         if (density >= getProperty(REPORT_LEVEL)) {\n+   47:             addViolation(data, node);\n+   48:         }\n+   49:         return super.visit(node, data);\n+   50:     }\n+   58: \n+   59:         double compute(ASTSwitchStatement root) {\n+   60:             this.root = root;\n+   61:             root.jjtAccept(this, null);\n+   62:             return labels == 0 ? 0 : ((double) stmts) / labels;\n+   63:         }\n+   64: \n    65: \n-   66:         SwitchDensity density = new SwitchDensity();\n-   67: \n-   68:         node.childrenAccept(this, density);\n-   69: \n-   70:         DataPoint point = new DataPoint();\n-   71:         point.setNode(node);\n-   72:         point.setScore(density.getDensity());\n-   73:         point.setMessage(getMessage());\n-   74: \n-   75:         addDataPoint(point);\n-   76: \n-   77:         if (data instanceof SwitchDensity) {\n-   78:             ((SwitchDensity) data).addStatements(density.getStatementCount());\n-   79:         }\n-   80:         return oldData;\n-   81:     }\n+   66:         @Override\n+   67:         public Object visit(ASTStatement statement, Object data) {\n+   68:             stmts++;\n+   69:             return super.visit(statement, data);\n+   70:         }\n+   71: \n+   72:         @Override\n+   73:         public Object visit(ASTExpression node, Object data) {\n+   74:             // don't recurse on anonymous class, etc\n+   75:             return data;\n+   76:         }\n+   77: \n+   78:         @Override\n+   79:         public Object visit(ASTSwitchLabel switchLabel, Object data) {\n+   80:             if (switchLabel.jjtGetParent() == root) {\n+   81:                 labels++;\n",
        "uniqueId": "2995f156caf2b55369ef28108f0b6077e4186eb2_58_81_72_76_43_50",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 13
            },
            "BRANCH": {
                "missed": 0,
                "covered": 2
            },
            "LINE": {
                "missed": 0,
                "covered": 4
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 2
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Move Method",
        "description": "Move Method\tpublic visit(node ASTUserEnum, data Object) : Object from class net.sourceforge.pmd.lang.apex.rule.design.NcssTypeCountRule to public visit(node ASTUserEnum, data Object) : Object from class net.sourceforge.pmd.lang.apex.rule.design.AbstractNcssCountRule.NcssVisitor",
        "diffLocations": [
            {
                "filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/design/NcssTypeCountRule.java",
                "startLine": 51,
                "endLine": 54,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/design/AbstractNcssCountRule.java",
                "startLine": 152,
                "endLine": 155,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n    public Object visit(ASTUserEnum node, Object data) {\n        return countNodeChildren(node, data);\n    }",
        "filePathBefore": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/design/NcssTypeCountRule.java",
        "isPureRefactoring": true,
        "commitId": "a64b757699a0c66bf01fa0b02a1dc092aaa58caf",
        "packageNameBefore": "net.sourceforge.pmd.lang.apex.rule.design",
        "classNameBefore": "net.sourceforge.pmd.lang.apex.rule.design.NcssTypeCountRule",
        "methodNameBefore": "net.sourceforge.pmd.lang.apex.rule.design.NcssTypeCountRule#visit",
        "invokedMethod": "methodSignature: net.sourceforge.pmd.lang.apex.rule.design.AbstractNcssCountRule#countNodeChildren\n methodBody: protected Integer countNodeChildren(Node node, Object data) {\nInteger nodeCount;\nint lineCount=0;\nfor(int i=0; i < node.jjtGetNumChildren(); i++){nodeCount=(Integer)((AbstractApexNodeBase)node.jjtGetChild(i)).jjtAccept(this,data);\nlineCount+=nodeCount.intValue();\n}return ++lineCount;\n}",
        "classSignatureBefore": "public class NcssTypeCountRule extends AbstractNcssCountRule ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.apex.rule.design.NcssTypeCountRule#visit"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.apex.rule.design.NcssTypeCountRule"
        ],
        "classSignatureBeforeSet": [
            "public class NcssTypeCountRule extends AbstractNcssCountRule "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex.rule.design;\n\nimport net.sourceforge.pmd.lang.apex.ast.ASTFieldDeclaration;\nimport net.sourceforge.pmd.lang.apex.ast.ASTMethod;\nimport net.sourceforge.pmd.lang.apex.ast.ASTUserClass;\nimport net.sourceforge.pmd.lang.apex.ast.ASTUserEnum;\nimport net.sourceforge.pmd.lang.apex.ast.ASTUserInterface;\nimport net.sourceforge.pmd.stat.DataPoint;\nimport net.sourceforge.pmd.util.NumericConstants;\n\n/**\n * Non-commented source statement counter for type declarations.\n * \n * @author ported from Java original of Jason Bennett\n */\npublic class NcssTypeCountRule extends AbstractNcssCountRule {\n\n    /**\n     * Count type declarations. This includes classes as well as enums and\n     * annotations.\n     */\n    public NcssTypeCountRule() {\n        super(ASTUserClass.class);\n        setProperty(MINIMUM_DESCRIPTOR, 500d);\n    }\n\n    @Override\n    public Object visit(ASTUserClass node, Object data) {\n\n        if (!node.hasDescendantOfAnyType(ASTUserClass.class)) {\n            return super.visit(node, data);\n        }\n\n        return countNodeChildren(node, data);\n    }\n\n    @Override\n    public Object visit(ASTUserInterface node, Object data) {\n\n        if (!node.hasDescendantOfAnyType(ASTUserClass.class)) {\n            return super.visit(node, data);\n        }\n\n        return countNodeChildren(node, data);\n    }\n\n    @Override\n    public Object visit(ASTUserEnum node, Object data) {\n        return countNodeChildren(node, data);\n    }\n\n    @Override\n    public Object visit(ASTMethod node, Object data) {\n        if (!node.getImage().matches(\"<clinit>|<init>|clone\")) {\n            return countNodeChildren(node, data);\n        }\n\n        return NumericConstants.ZERO;\n    }\n\n    @Override\n    public Object visit(ASTFieldDeclaration node, Object data) {\n        return NumericConstants.ONE;\n    }\n\n    @Override\n    public Object[] getViolationParameters(DataPoint point) {\n        return new String[] { String.valueOf((int) point.getScore()) };\n    }\n}\n",
        "filePathAfter": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/design/AbstractNcssCountRule.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex.rule.design;\n\nimport net.sourceforge.pmd.lang.apex.ast.ASTBreakStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTContinueStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTDoLoopStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTFieldDeclaration;\nimport net.sourceforge.pmd.lang.apex.ast.ASTForEachStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTForLoopStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTIfBlockStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTIfElseBlockStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTMethod;\nimport net.sourceforge.pmd.lang.apex.ast.ASTMethodCallExpression;\nimport net.sourceforge.pmd.lang.apex.ast.ASTReturnStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTThrowStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTTryCatchFinallyBlockStatement;\nimport net.sourceforge.pmd.lang.apex.ast.ASTUserClass;\nimport net.sourceforge.pmd.lang.apex.ast.ASTUserEnum;\nimport net.sourceforge.pmd.lang.apex.ast.ASTUserInterface;\nimport net.sourceforge.pmd.lang.apex.ast.ASTWhileLoopStatement;\nimport net.sourceforge.pmd.lang.apex.ast.AbstractApexNodeBase;\nimport net.sourceforge.pmd.lang.apex.ast.ApexNode;\nimport net.sourceforge.pmd.lang.apex.ast.ApexParserVisitorAdapter;\nimport net.sourceforge.pmd.lang.ast.Node;\n\n/**\n * Abstract superclass for NCSS counting methods. Counts tokens according to\n * <a href=\"http://www.kclee.de/clemens/java/javancss/\">JavaNCSS rules</a>.\n *\n * @author ported from Java original of Jason Bennett\n */\npublic abstract class AbstractNcssCountRule<T extends ApexNode<?>> extends AbstractCounterCheckRule<T> {\n\n\n    /**\n     * Count the nodes of the given type using NCSS rules.\n     *\n     * @param nodeClass class of node to count\n     */\n    protected AbstractNcssCountRule(Class<T> nodeClass) {\n        super(nodeClass);\n    }\n\n    @Override\n    protected boolean isViolation(T node, int reportLevel) {\n        return (Integer) new NcssVisitor().visit(node, null) + 1 >= reportLevel;\n    }\n\n    private static class NcssVisitor extends ApexParserVisitorAdapter {\n\n        @Override\n        public Object visit(AbstractApexNodeBase node, Object data) {\n            return countNodeChildren(node, data);\n        }\n\n        /**\n         * Count the number of children of the given node. Adds one to count the\n         * node itself.\n         *\n         * @param node node having children counted\n         * @param data node data\n         *\n         * @return count of the number of children of the node, plus one\n         */\n        protected Integer countNodeChildren(Node node, Object data) {\n            int nodeCount = 0;\n            for (int i = 0; i < node.jjtGetNumChildren(); i++) {\n                nodeCount += (Integer) ((AbstractApexNodeBase) node.jjtGetChild(i)).jjtAccept(this, data);\n            }\n            return nodeCount;\n        }\n\n        @Override\n        public Object visit(ASTForLoopStatement node, Object data) {\n            return countNodeChildren(node, data) + 1;\n        }\n\n        @Override\n        public Object visit(ASTForEachStatement node, Object data) {\n            return countNodeChildren(node, data) + 1;\n        }\n\n        @Override\n        public Object visit(ASTDoLoopStatement node, Object data) {\n            return countNodeChildren(node, data) + 1;\n        }\n\n        @Override\n        public Object visit(ASTIfBlockStatement node, Object data) {\n            return countNodeChildren(node, data) + 1;\n        }\n\n        @Override\n        public Object visit(ASTIfElseBlockStatement node, Object data) {\n            return countNodeChildren(node, data) + 2;\n        }\n\n        @Override\n        public Object visit(ASTWhileLoopStatement node, Object data) {\n            return countNodeChildren(node, data) + 1;\n        }\n\n        @Override\n        public Object visit(ASTBreakStatement node, Object data) {\n            return 1;\n        }\n\n        @Override\n        public Object visit(ASTTryCatchFinallyBlockStatement node, Object data) {\n            return countNodeChildren(node, data) + 1;\n        }\n\n        @Override\n        public Object visit(ASTContinueStatement node, Object data) {\n            return 1;\n        }\n\n        @Override\n        public Object visit(ASTReturnStatement node, Object data) {\n            return countNodeChildren(node, data) + 1;\n        }\n\n        @Override\n        public Object visit(ASTThrowStatement node, Object data) {\n            return countNodeChildren(node, data) + 1;\n        }\n\n        @Override\n        public Object visit(ASTStatement node, Object data) {\n            return 1;\n        }\n\n        @Override\n        public Object visit(ASTMethodCallExpression node, Object data) {\n            return 1;\n        }\n\n        @Override\n        public Object visit(ASTMethod node, Object data) {\n            return node.isSynthetic() ? 0 : countNodeChildren(node, data);\n        }\n\n        @Override\n        public Object visit(ASTUserClass node, Object data) {\n            return countNodeChildren(node, data) + 1;\n        }\n\n        @Override\n        public Object visit(ASTUserEnum node, Object data) {\n            return countNodeChildren(node, data) + 1;\n        }\n\n        @Override\n        public Object visit(ASTUserInterface node, Object data) {\n            return countNodeChildren(node, data) + 1;\n        }\n\n        @Override\n        public Object visit(ASTFieldDeclaration node, Object data) {\n            return 1;\n        }\n    }\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [
            "methodSignature: net.sourceforge.pmd.lang.apex.rule.design.AbstractNcssCountRule#countNodeChildren\n methodBody: protected Integer countNodeChildren(Node node, Object data) {\nInteger nodeCount;\nint lineCount=0;\nfor(int i=0; i < node.jjtGetNumChildren(); i++){nodeCount=(Integer)((AbstractApexNodeBase)node.jjtGetChild(i)).jjtAccept(this,data);\nlineCount+=nodeCount.intValue();\n}return ++lineCount;\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n        public Object visit(ASTUserEnum node, Object data) {\n            return countNodeChildren(node, data) + 1;\n        }",
        "diffSourceCode": "-   51:     @Override\n-   52:     public Object visit(ASTUserEnum node, Object data) {\n-   53:         return countNodeChildren(node, data);\n-   54:     }\n+   51:     }\n+   52: \n+   53:     private static class NcssVisitor extends ApexParserVisitorAdapter {\n+   54: \n+  152:         @Override\n+  153:         public Object visit(ASTUserEnum node, Object data) {\n+  154:             return countNodeChildren(node, data) + 1;\n+  155:         }\n",
        "uniqueId": "a64b757699a0c66bf01fa0b02a1dc092aaa58caf_51_54__152_155",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 2
            },
            "LINE": {
                "missed": 0,
                "covered": 1
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic getInstance() : ApexMetricsComputer extracted from protected getLanguageSpecificComputer() : MetricsComputer<ASTUserClassOrInterface<?>,ASTMethod> in class net.sourceforge.pmd.lang.apex.metrics.ApexMetricsFacade & moved to class net.sourceforge.pmd.lang.apex.metrics.ApexMetricsComputer",
        "diffLocations": [
            {
                "filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/ApexMetricsFacade.java",
                "startLine": 28,
                "endLine": 31,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/ApexMetricsFacade.java",
                "startLine": 28,
                "endLine": 31,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/ApexMetricsFacade.java",
                "startLine": 25,
                "endLine": 28,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n    protected MetricsComputer<ASTUserClassOrInterface<?>, ASTMethod> getLanguageSpecificComputer() {\n        return ApexMetricsComputer.INSTANCE;\n    }",
        "filePathBefore": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/ApexMetricsFacade.java",
        "isPureRefactoring": true,
        "commitId": "0fec3640a30bd92e6a2d2a0f31888365edaa36e7",
        "packageNameBefore": "net.sourceforge.pmd.lang.apex.metrics",
        "classNameBefore": "net.sourceforge.pmd.lang.apex.metrics.ApexMetricsFacade",
        "methodNameBefore": "net.sourceforge.pmd.lang.apex.metrics.ApexMetricsFacade#getLanguageSpecificComputer",
        "classSignatureBefore": "public class ApexMetricsFacade extends AbstractMetricsFacade<ASTUserClassOrInterface<?>, ASTMethod> ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.apex.metrics.ApexMetricsFacade#getLanguageSpecificComputer"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.apex.metrics.ApexMetricsFacade"
        ],
        "classSignatureBeforeSet": [
            "public class ApexMetricsFacade extends AbstractMetricsFacade<ASTUserClassOrInterface<?>, ASTMethod> "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex.metrics;\n\nimport net.sourceforge.pmd.lang.apex.ast.ASTMethod;\nimport net.sourceforge.pmd.lang.apex.ast.ASTUserClassOrInterface;\nimport net.sourceforge.pmd.lang.metrics.AbstractMetricsFacade;\nimport net.sourceforge.pmd.lang.metrics.MetricsComputer;\n\n/**\n * Backs the static fa\u00e7ade.\n *\n * @author Cl\u00e9ment Fournier\n */\npublic class ApexMetricsFacade extends AbstractMetricsFacade<ASTUserClassOrInterface<?>, ASTMethod> {\n\n    private final ApexProjectMemoizer memoizer = new ApexProjectMemoizer();\n\n\n    /** Resets the entire project mirror. Used for tests. */\n    void reset() {\n        memoizer.reset();\n    }\n\n\n    @Override\n    protected MetricsComputer<ASTUserClassOrInterface<?>, ASTMethod> getLanguageSpecificComputer() {\n        return ApexMetricsComputer.INSTANCE;\n    }\n\n\n    @Override\n    protected ApexProjectMemoizer getLanguageSpecificProjectMemoizer() {\n        return memoizer;\n    }\n}\n",
        "filePathAfter": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/metrics/ApexMetricsFacade.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.apex.metrics;\n\nimport net.sourceforge.pmd.lang.apex.ast.ASTMethod;\nimport net.sourceforge.pmd.lang.apex.ast.ASTUserClassOrInterface;\nimport net.sourceforge.pmd.lang.metrics.AbstractMetricsFacade;\nimport net.sourceforge.pmd.lang.metrics.MetricsComputer;\n\n/**\n * Backs the static fa\u00e7ade.\n *\n * @author Cl\u00e9ment Fournier\n */\npublic class ApexMetricsFacade extends AbstractMetricsFacade<ASTUserClassOrInterface<?>, ASTMethod> {\n\n    private final ApexProjectMemoizer memoizer = new ApexProjectMemoizer();\n\n\n    /** Resets the entire project mirror. Used for tests. */\n    void reset() {\n        memoizer.reset();\n    }\n\n\n    @Override\n    protected MetricsComputer<ASTUserClassOrInterface<?>, ASTMethod> getLanguageSpecificComputer() {\n        return ApexMetricsComputer.getInstance();\n    }\n\n\n    @Override\n    protected ApexProjectMemoizer getLanguageSpecificProjectMemoizer() {\n        return memoizer;\n    }\n}\n",
        "diffSourceCodeSet": [
            "}\n\n\n    @Override"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "@Override\n    protected MetricsComputer<ASTUserClassOrInterface<?>, ASTMethod> getLanguageSpecificComputer() {\n        return ApexMetricsComputer.getInstance();\n    }\n}\n\n\n    @Override",
        "diffSourceCode": "    25:     }\n    26: \n    27: \n    28:     @Override\n    29:     protected MetricsComputer<ASTUserClassOrInterface<?>, ASTMethod> getLanguageSpecificComputer() {\n-   30:         return ApexMetricsComputer.INSTANCE;\n+   30:         return ApexMetricsComputer.getInstance();\n    31:     }\n",
        "uniqueId": "0fec3640a30bd92e6a2d2a0f31888365edaa36e7_28_31_25_28_28_31",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 2
            },
            "LINE": {
                "missed": 0,
                "covered": 1
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract And Move Method",
        "description": "Extract And Move Method\tpublic getInstance() : JavaMetricsComputer extracted from protected getLanguageSpecificComputer() : MetricsComputer<ASTAnyTypeDeclaration,MethodLikeNode> in class net.sourceforge.pmd.lang.java.metrics.JavaMetricsFacade & moved to class net.sourceforge.pmd.lang.java.metrics.JavaMetricsComputer",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/JavaMetricsFacade.java",
                "startLine": 34,
                "endLine": 37,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/JavaMetricsFacade.java",
                "startLine": 34,
                "endLine": 37,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/JavaMetricsFacade.java",
                "startLine": 31,
                "endLine": 34,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n    protected MetricsComputer<ASTAnyTypeDeclaration, MethodLikeNode> getLanguageSpecificComputer() {\n        return JavaMetricsComputer.INSTANCE;\n    }",
        "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/JavaMetricsFacade.java",
        "isPureRefactoring": true,
        "commitId": "5f2a5bb67813ac5acb38a8bac6d335181d79fd9f",
        "packageNameBefore": "net.sourceforge.pmd.lang.java.metrics",
        "classNameBefore": "net.sourceforge.pmd.lang.java.metrics.JavaMetricsFacade",
        "methodNameBefore": "net.sourceforge.pmd.lang.java.metrics.JavaMetricsFacade#getLanguageSpecificComputer",
        "classSignatureBefore": "class JavaMetricsFacade extends AbstractMetricsFacade<ASTAnyTypeDeclaration, MethodLikeNode> ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.metrics.JavaMetricsFacade#getLanguageSpecificComputer"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.metrics.JavaMetricsFacade"
        ],
        "classSignatureBeforeSet": [
            "class JavaMetricsFacade extends AbstractMetricsFacade<ASTAnyTypeDeclaration, MethodLikeNode> "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.metrics;\n\nimport net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.MethodLikeNode;\nimport net.sourceforge.pmd.lang.metrics.AbstractMetricsFacade;\nimport net.sourceforge.pmd.lang.metrics.MetricsComputer;\n\n/**\n * Inner fa\u00e7ade of the Java metrics framework. The static fa\u00e7ade delegates to an instance of this class.\n *\n * @author Cl\u00e9ment Fournier\n */\nclass JavaMetricsFacade extends AbstractMetricsFacade<ASTAnyTypeDeclaration, MethodLikeNode> {\n\n    private final JavaProjectMemoizer memoizer = new JavaProjectMemoizer();\n\n\n    /** Resets the entire data structure. Used for tests. */\n    void reset() {\n        memoizer.reset();\n    }\n\n\n    @Override\n    public JavaProjectMemoizer getLanguageSpecificProjectMemoizer() {\n        return memoizer;\n    }\n\n\n    @Override\n    protected MetricsComputer<ASTAnyTypeDeclaration, MethodLikeNode> getLanguageSpecificComputer() {\n        return JavaMetricsComputer.INSTANCE;\n    }\n\n}\n",
        "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/metrics/JavaMetricsFacade.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.metrics;\n\nimport net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration;\nimport net.sourceforge.pmd.lang.java.ast.MethodLikeNode;\nimport net.sourceforge.pmd.lang.metrics.AbstractMetricsFacade;\nimport net.sourceforge.pmd.lang.metrics.MetricsComputer;\n\n/**\n * Inner fa\u00e7ade of the Java metrics framework. The static fa\u00e7ade delegates to an instance of this class.\n *\n * @author Cl\u00e9ment Fournier\n */\nclass JavaMetricsFacade extends AbstractMetricsFacade<ASTAnyTypeDeclaration, MethodLikeNode> {\n\n    private final JavaProjectMemoizer memoizer = new JavaProjectMemoizer();\n\n\n    /** Resets the entire data structure. Used for tests. */\n    void reset() {\n        memoizer.reset();\n    }\n\n\n    @Override\n    public JavaProjectMemoizer getLanguageSpecificProjectMemoizer() {\n        return memoizer;\n    }\n\n\n    @Override\n    protected MetricsComputer<ASTAnyTypeDeclaration, MethodLikeNode> getLanguageSpecificComputer() {\n        return JavaMetricsComputer.getInstance();\n    }\n\n}\n",
        "diffSourceCodeSet": [
            "}\n\n\n    @Override"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "@Override\n    protected MetricsComputer<ASTAnyTypeDeclaration, MethodLikeNode> getLanguageSpecificComputer() {\n        return JavaMetricsComputer.getInstance();\n    }\n}\n\n\n    @Override",
        "diffSourceCode": "    31:     }\n    32: \n    33: \n    34:     @Override\n    35:     protected MetricsComputer<ASTAnyTypeDeclaration, MethodLikeNode> getLanguageSpecificComputer() {\n-   36:         return JavaMetricsComputer.INSTANCE;\n+   36:         return JavaMetricsComputer.getInstance();\n    37:     }\n",
        "uniqueId": "5f2a5bb67813ac5acb38a8bac6d335181d79fd9f_34_37_31_34_34_37",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 2
            },
            "LINE": {
                "missed": 0,
                "covered": 1
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate loadClass(nullableClassLoader ClassLoader, clazzName String) : Class<?> extracted from private loadClassWithNodeClassloader(n TypeNode, clazzName String) : Class<?> in class net.sourceforge.pmd.lang.java.typeresolution.TypeHelper",
        "diffLocations": [
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/typeresolution/TypeHelper.java",
                "startLine": 55,
                "endLine": 77,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/typeresolution/TypeHelper.java",
                "startLine": 55,
                "endLine": 61,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/typeresolution/TypeHelper.java",
                "startLine": 63,
                "endLine": 83,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private static Class<?> loadClassWithNodeClassloader(final TypeNode n, final String clazzName) {\n        if (n.getType() != null) {\n            try {\n                ClassLoader classLoader = n.getType().getClassLoader();\n                if (classLoader == null) {\n                    // Using the system classloader then\n                    classLoader = ClassLoader.getSystemClassLoader();\n                }\n    \n                // If the requested type is in the classpath, using the same classloader should work\n                return ClassUtils.getClass(classLoader, clazzName);\n            } catch (final ClassNotFoundException ignored) {\n                // The requested type is not on the auxclasspath. This might happen, if the type node\n                // is probed for a specific type (e.g. is is a JUnit5 Test Annotation class).\n                // Failing to resolve clazzName does not necessarily indicate an incomplete auxclasspath.\n            } catch (final LinkageError expected) {\n                // We found the class but it's invalid / incomplete. This may be an incomplete auxclasspath\n                // if it was a NoClassDefFoundError. TODO : Report it?\n            }\n        }\n        \n        return null;\n    }",
        "filePathBefore": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/typeresolution/TypeHelper.java",
        "isPureRefactoring": true,
        "commitId": "cc8181edc9f9c8f9676c78aba66428040120c17a",
        "packageNameBefore": "net.sourceforge.pmd.lang.java.typeresolution",
        "classNameBefore": "net.sourceforge.pmd.lang.java.typeresolution.TypeHelper",
        "methodNameBefore": "net.sourceforge.pmd.lang.java.typeresolution.TypeHelper#loadClassWithNodeClassloader",
        "classSignatureBefore": "public final class TypeHelper ",
        "methodNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.typeresolution.TypeHelper#loadClassWithNodeClassloader"
        ],
        "classNameBeforeSet": [
            "net.sourceforge.pmd.lang.java.typeresolution.TypeHelper"
        ],
        "classSignatureBeforeSet": [
            "public final class TypeHelper "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics \n Severe changes",
                "description": "Return expression has been added within the Extract Method mechanics - with non-mapped leaves",
                "mappingState": 2
            }
        ],
        "sourceCodeBeforeForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.typeresolution;\n\nimport org.apache.commons.lang3.ClassUtils;\n\nimport net.sourceforge.pmd.lang.java.ast.TypeNode;\nimport net.sourceforge.pmd.lang.java.symboltable.TypedNameDeclaration;\n\npublic final class TypeHelper {\n\n    private TypeHelper() {\n        // utility class\n    }\n\n    /**\n     * Checks whether the resolved type of the given {@link TypeNode} n is of the type\n     * given by the clazzName. If the clazzName is on the auxclasspath, then also subclasses\n     * are considered.\n     *\n     * @param n the type node to check\n     * @param clazzName the class name to compare to\n     * @return <code>true</code> if type node n is of type clazzName or a subtype of clazzName\n     */\n    public static boolean isA(final TypeNode n, final String clazzName) {\n        final Class<?> clazz = loadClassWithNodeClassloader(n, clazzName);\n\n        if (clazz != null) {\n            return isA(n, clazz);\n        }\n\n        return clazzName.equals(n.getImage()) || clazzName.endsWith(\".\" + n.getImage());\n    }\n    \n    /**\n     * Checks whether the resolved type of the given {@link TypeNode} n is exactly of the type\n     * given by the clazzName.\n     *\n     * @param n the type node to check\n     * @param clazzName the class name to compare to\n     * @return <code>true</code> if type node n is exactly of type clazzName.\n     */\n    public static boolean isExactlyA(final TypeNode n, final String clazzName) {\n        final Class<?> clazz = loadClassWithNodeClassloader(n, clazzName);\n\n        if (clazz != null) {\n            return n.getType() == clazz;\n        }\n\n        return clazzName.equals(n.getImage()) || clazzName.endsWith(\".\" + n.getImage());\n    }\n    \n    private static Class<?> loadClassWithNodeClassloader(final TypeNode n, final String clazzName) {\n        if (n.getType() != null) {\n            try {\n                ClassLoader classLoader = n.getType().getClassLoader();\n                if (classLoader == null) {\n                    // Using the system classloader then\n                    classLoader = ClassLoader.getSystemClassLoader();\n                }\n    \n                // If the requested type is in the classpath, using the same classloader should work\n                return ClassUtils.getClass(classLoader, clazzName);\n            } catch (final ClassNotFoundException ignored) {\n                // The requested type is not on the auxclasspath. This might happen, if the type node\n                // is probed for a specific type (e.g. is is a JUnit5 Test Annotation class).\n                // Failing to resolve clazzName does not necessarily indicate an incomplete auxclasspath.\n            } catch (final LinkageError expected) {\n                // We found the class but it's invalid / incomplete. This may be an incomplete auxclasspath\n                // if it was a NoClassDefFoundError. TODO : Report it?\n            }\n        }\n        \n        return null;\n    }\n\n    /** @see #isA(TypeNode, String) */\n    public static boolean isA(TypeNode n, Class<?> clazz) {\n        return subclasses(n, clazz);\n    }\n\n    public static boolean isEither(TypeNode n, Class<?> class1, Class<?> class2) {\n        return subclasses(n, class1) || subclasses(n, class2);\n    }\n\n    public static boolean isExactlyAny(TypedNameDeclaration vnd, Class<?>... clazzes) {\n        Class<?> type = vnd.getType();\n        for (final Class<?> clazz : clazzes) {\n            if (type != null && type.equals(clazz) || type == null\n                    && (clazz.getSimpleName().equals(vnd.getTypeImage()) || clazz.getName().equals(vnd.getTypeImage()))) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    public static boolean isExactlyNone(TypedNameDeclaration vnd, Class<?>... clazzes) {\n        return !isExactlyAny(vnd, clazzes);\n    }\n    \n    /**\n     * @deprecated use {@link #isExactlyAny(TypedNameDeclaration, Class...)}\n     */\n    @Deprecated\n    public static boolean isA(TypedNameDeclaration vnd, Class<?> clazz) {\n        return isExactlyAny(vnd, clazz);\n    }\n\n    /**\n     * @deprecated use {@link #isExactlyAny(TypedNameDeclaration, Class...)}\n     */\n    @Deprecated\n    public static boolean isEither(TypedNameDeclaration vnd, Class<?> class1, Class<?> class2) {\n        return isExactlyAny(vnd, class1, class2);\n    }\n\n    /**\n     * @deprecated use {@link #isExactlyNone(TypedNameDeclaration, Class...)}\n     */\n    @Deprecated\n    public static boolean isNeither(TypedNameDeclaration vnd, Class<?> class1, Class<?> class2) {\n        return !isA(vnd, class1) && !isA(vnd, class2);\n    }\n\n    public static boolean subclasses(TypeNode n, Class<?> clazz) {\n        Class<?> type = n.getType();\n        if (type == null) {\n            return n.hasImageEqualTo(clazz.getSimpleName()) || n.hasImageEqualTo(clazz.getName());\n        }\n\n        return clazz.isAssignableFrom(type);\n    }\n}\n",
        "filePathAfter": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/typeresolution/TypeHelper.java",
        "sourceCodeAfterForWhole": "/**\n * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n */\n\npackage net.sourceforge.pmd.lang.java.typeresolution;\n\nimport org.apache.commons.lang3.ClassUtils;\n\nimport net.sourceforge.pmd.lang.java.ast.TypeNode;\nimport net.sourceforge.pmd.lang.java.symboltable.TypedNameDeclaration;\n\npublic final class TypeHelper {\n\n    private TypeHelper() {\n        // utility class\n    }\n\n    /**\n     * Checks whether the resolved type of the given {@link TypeNode} n is of the type\n     * given by the clazzName. If the clazzName is on the auxclasspath, then also subclasses\n     * are considered.\n     *\n     * @param n the type node to check\n     * @param clazzName the class name to compare to\n     * @return <code>true</code> if type node n is of type clazzName or a subtype of clazzName\n     */\n    public static boolean isA(final TypeNode n, final String clazzName) {\n        final Class<?> clazz = loadClassWithNodeClassloader(n, clazzName);\n\n        if (clazz != null) {\n            return isA(n, clazz);\n        }\n\n        return clazzName.equals(n.getImage()) || clazzName.endsWith(\".\" + n.getImage());\n    }\n    \n    /**\n     * Checks whether the resolved type of the given {@link TypeNode} n is exactly of the type\n     * given by the clazzName.\n     *\n     * @param n the type node to check\n     * @param clazzName the class name to compare to\n     * @return <code>true</code> if type node n is exactly of type clazzName.\n     */\n    public static boolean isExactlyA(final TypeNode n, final String clazzName) {\n        final Class<?> clazz = loadClassWithNodeClassloader(n, clazzName);\n\n        if (clazz != null) {\n            return n.getType() == clazz;\n        }\n\n        return clazzName.equals(n.getImage()) || clazzName.endsWith(\".\" + n.getImage());\n    }\n    \n    private static Class<?> loadClassWithNodeClassloader(final TypeNode n, final String clazzName) {\n        if (n.getType() != null) {\n            return loadClass(n.getType().getClassLoader(), clazzName);\n        }\n\n        return null;\n    }\n\n    private static Class<?> loadClass(final ClassLoader nullableClassLoader, final String clazzName) {\n        try {\n            ClassLoader classLoader = nullableClassLoader;\n            if (classLoader == null) {\n                // Using the system classloader then\n                classLoader = ClassLoader.getSystemClassLoader();\n            }\n\n            // If the requested type is in the classpath, using the same classloader should work\n            return ClassUtils.getClass(classLoader, clazzName);\n        } catch (ClassNotFoundException ignored) {\n            // The requested type is not on the auxclasspath. This might happen, if the type node\n            // is probed for a specific type (e.g. is is a JUnit5 Test Annotation class).\n            // Failing to resolve clazzName does not necessarily indicate an incomplete auxclasspath.\n        } catch (final LinkageError expected) {\n            // We found the class but it's invalid / incomplete. This may be an incomplete auxclasspath\n            // if it was a NoClassDefFoundError. TODO : Report it?\n        }\n        \n        return null;\n    }\n\n    /** @see #isA(TypeNode, String) */\n    public static boolean isA(TypeNode n, Class<?> clazz) {\n        return subclasses(n, clazz);\n    }\n\n    public static boolean isEither(TypeNode n, Class<?> class1, Class<?> class2) {\n        return subclasses(n, class1) || subclasses(n, class2);\n    }\n\n    public static boolean isExactlyAny(TypedNameDeclaration vnd, Class<?>... clazzes) {\n        Class<?> type = vnd.getType();\n        for (final Class<?> clazz : clazzes) {\n            if (type != null && type.equals(clazz) || type == null\n                    && (clazz.getSimpleName().equals(vnd.getTypeImage()) || clazz.getName().equals(vnd.getTypeImage()))) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    public static boolean isExactlyNone(TypedNameDeclaration vnd, Class<?>... clazzes) {\n        return !isExactlyAny(vnd, clazzes);\n    }\n    \n    /**\n     * @deprecated use {@link #isExactlyAny(TypedNameDeclaration, Class...)}\n     */\n    @Deprecated\n    public static boolean isA(TypedNameDeclaration vnd, Class<?> clazz) {\n        return isExactlyAny(vnd, clazz);\n    }\n\n    /**\n     * @deprecated use {@link #isExactlyAny(TypedNameDeclaration, Class...)}\n     */\n    @Deprecated\n    public static boolean isEither(TypedNameDeclaration vnd, Class<?> class1, Class<?> class2) {\n        return isExactlyAny(vnd, class1, class2);\n    }\n\n    /**\n     * @deprecated use {@link #isExactlyNone(TypedNameDeclaration, Class...)}\n     */\n    @Deprecated\n    public static boolean isNeither(TypedNameDeclaration vnd, Class<?> class1, Class<?> class2) {\n        return !isA(vnd, class1) && !isA(vnd, class2);\n    }\n\n    public static boolean subclasses(TypeNode n, Class<?> clazz) {\n        Class<?> type = n.getType();\n        if (type == null) {\n            return n.hasImageEqualTo(clazz.getSimpleName()) || n.hasImageEqualTo(clazz.getName());\n        }\n\n        return clazz.isAssignableFrom(type);\n    }\n\n    public static boolean isA(TypedNameDeclaration vnd, String className) {\n        Class<?> type = vnd.getType();\n        if (type != null) {\n            Class<?> expected = loadClass(type.getClassLoader(), className);\n            return expected.isAssignableFrom(type);\n        }\n        return false;\n    }\n}\n",
        "diffSourceCodeSet": [
            "private static Class<?> loadClass(final ClassLoader nullableClassLoader, final String clazzName) {\n        try {\n            ClassLoader classLoader = nullableClassLoader;\n            if (classLoader == null) {\n                // Using the system classloader then\n                classLoader = ClassLoader.getSystemClassLoader();\n            }\n\n            // If the requested type is in the classpath, using the same classloader should work\n            return ClassUtils.getClass(classLoader, clazzName);\n        } catch (ClassNotFoundException ignored) {\n            // The requested type is not on the auxclasspath. This might happen, if the type node\n            // is probed for a specific type (e.g. is is a JUnit5 Test Annotation class).\n            // Failing to resolve clazzName does not necessarily indicate an incomplete auxclasspath.\n        } catch (final LinkageError expected) {\n            // We found the class but it's invalid / incomplete. This may be an incomplete auxclasspath\n            // if it was a NoClassDefFoundError. TODO : Report it?\n        }\n        \n        return null;\n    }"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "private static Class<?> loadClassWithNodeClassloader(final TypeNode n, final String clazzName) {\n        if (n.getType() != null) {\n            return loadClass(n.getType().getClassLoader(), clazzName);\n        }\n\n        return null;\n    }\nprivate static Class<?> loadClass(final ClassLoader nullableClassLoader, final String clazzName) {\n        try {\n            ClassLoader classLoader = nullableClassLoader;\n            if (classLoader == null) {\n                // Using the system classloader then\n                classLoader = ClassLoader.getSystemClassLoader();\n            }\n\n            // If the requested type is in the classpath, using the same classloader should work\n            return ClassUtils.getClass(classLoader, clazzName);\n        } catch (ClassNotFoundException ignored) {\n            // The requested type is not on the auxclasspath. This might happen, if the type node\n            // is probed for a specific type (e.g. is is a JUnit5 Test Annotation class).\n            // Failing to resolve clazzName does not necessarily indicate an incomplete auxclasspath.\n        } catch (final LinkageError expected) {\n            // We found the class but it's invalid / incomplete. This may be an incomplete auxclasspath\n            // if it was a NoClassDefFoundError. TODO : Report it?\n        }\n        \n        return null;\n    }",
        "diffSourceCode": "    55:     private static Class<?> loadClassWithNodeClassloader(final TypeNode n, final String clazzName) {\n    56:         if (n.getType() != null) {\n-   57:             try {\n-   58:                 ClassLoader classLoader = n.getType().getClassLoader();\n-   59:                 if (classLoader == null) {\n-   60:                     // Using the system classloader then\n-   61:                     classLoader = ClassLoader.getSystemClassLoader();\n-   62:                 }\n-   63:     \n-   64:                 // If the requested type is in the classpath, using the same classloader should work\n-   65:                 return ClassUtils.getClass(classLoader, clazzName);\n-   66:             } catch (final ClassNotFoundException ignored) {\n-   67:                 // The requested type is not on the auxclasspath. This might happen, if the type node\n-   68:                 // is probed for a specific type (e.g. is is a JUnit5 Test Annotation class).\n-   69:                 // Failing to resolve clazzName does not necessarily indicate an incomplete auxclasspath.\n-   70:             } catch (final LinkageError expected) {\n-   71:                 // We found the class but it's invalid / incomplete. This may be an incomplete auxclasspath\n-   72:                 // if it was a NoClassDefFoundError. TODO : Report it?\n-   73:             }\n-   74:         }\n-   75:         \n-   76:         return null;\n-   77:     }\n-   78: \n-   79:     /** @see #isA(TypeNode, String) */\n-   80:     public static boolean isA(TypeNode n, Class<?> clazz) {\n-   81:         return subclasses(n, clazz);\n-   82:     }\n-   83: \n+   57:             return loadClass(n.getType().getClassLoader(), clazzName);\n+   58:         }\n+   59: \n+   60:         return null;\n+   61:     }\n+   62: \n+   63:     private static Class<?> loadClass(final ClassLoader nullableClassLoader, final String clazzName) {\n+   64:         try {\n+   65:             ClassLoader classLoader = nullableClassLoader;\n+   66:             if (classLoader == null) {\n+   67:                 // Using the system classloader then\n+   68:                 classLoader = ClassLoader.getSystemClassLoader();\n+   69:             }\n+   70: \n+   71:             // If the requested type is in the classpath, using the same classloader should work\n+   72:             return ClassUtils.getClass(classLoader, clazzName);\n+   73:         } catch (ClassNotFoundException ignored) {\n+   74:             // The requested type is not on the auxclasspath. This might happen, if the type node\n+   75:             // is probed for a specific type (e.g. is is a JUnit5 Test Annotation class).\n+   76:             // Failing to resolve clazzName does not necessarily indicate an incomplete auxclasspath.\n+   77:         } catch (final LinkageError expected) {\n+   78:             // We found the class but it's invalid / incomplete. This may be an incomplete auxclasspath\n+   79:             // if it was a NoClassDefFoundError. TODO : Report it?\n+   80:         }\n+   81:         \n+   82:         return null;\n+   83:     }\n",
        "uniqueId": "cc8181edc9f9c8f9676c78aba66428040120c17a_55_77_63_83_55_61",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 1,
                "covered": 19
            },
            "BRANCH": {
                "missed": 0,
                "covered": 4
            },
            "LINE": {
                "missed": 1,
                "covered": 8
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 3
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11
    }
]