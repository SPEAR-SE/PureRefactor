[
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate getExplicitJavaType() : BasicJavaType<?> extracted from protected buildResolution() : Resolution<?> in class org.hibernate.mapping.BasicValue",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/mapping/BasicValue.java",
                "startLine": 428,
                "endLine": 498,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/mapping/BasicValue.java",
                "startLine": 427,
                "endLine": 460,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/mapping/BasicValue.java",
                "startLine": 462,
                "endLine": 465,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "protected Resolution<?> buildResolution() {\n\t\tfinal Properties typeParameters = getTypeParameters();\n\t\tif ( typeParameters != null\n\t\t\t\t&& parseBoolean( typeParameters.getProperty(DynamicParameterizedType.IS_DYNAMIC) )\n\t\t\t\t&& typeParameters.get(DynamicParameterizedType.PARAMETER_TYPE) == null ) {\n\t\t\tcreateParameterImpl();\n\t\t}\n\n\t\tif ( explicitTypeName != null ) {\n\t\t\treturn interpretExplicitlyNamedType(\n\t\t\t\t\texplicitTypeName,\n\t\t\t\t\texplicitJavaTypeAccess,\n\t\t\t\t\texplicitJdbcTypeAccess,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tgetAttributeConverterDescriptor(),\n\t\t\t\t\ttypeParameters,\n\t\t\t\t\tthis::setTypeParameters,\n\t\t\t\t\tthis,\n\t\t\t\t\tgetBuildingContext()\n\t\t\t);\n\t\t}\n\n\t\tif ( isVersion() ) {\n\t\t\treturn VersionResolution.from( implicitJavaTypeAccess, timeZoneStorageType, getBuildingContext() );\n\t\t}\n\n\t\t// determine JavaType if we can\n\t\tfinal BasicJavaType<?> explicitJavaType = explicitJavaTypeAccess == null\n\t\t\t\t? null\n\t\t\t\t: explicitJavaTypeAccess.apply( getTypeConfiguration() );\n\n\t\tJavaType<?> javaType = determineJavaType( explicitJavaType );\n\t\tConverterDescriptor attributeConverterDescriptor = getAttributeConverterDescriptor();\n\n\t\tif ( isSoftDelete() ) {\n\t\t\tassert attributeConverterDescriptor != null;\n\t\t\tfinal boolean conversionWasUnspecified = SoftDelete.UnspecifiedConversion.class.equals( attributeConverterDescriptor.getAttributeConverterClass() );\n\t\t\tif ( conversionWasUnspecified ) {\n\t\t\t\tfinal JdbcType jdbcType = BooleanJdbcType.INSTANCE.resolveIndicatedType( this, javaType );\n\t\t\t\tif ( jdbcType.isNumber() ) {\n\t\t\t\t\tattributeConverterDescriptor = new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\t\tNumericBooleanConverter.INSTANCE,\n\t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\telse if ( jdbcType.isString() ) {\n\t\t\t\t\t// here we pick 'T' / 'F' storage, though 'Y' / 'N' is equally valid - its 50/50\n\t\t\t\t\tattributeConverterDescriptor = new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\t\tTrueFalseConverter.INSTANCE,\n\t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// should indicate BIT or BOOLEAN == no conversion needed\n\t\t\t\t\t//\t\t- we still create the converter to properly set up JDBC type, etc\n\t\t\t\t\tattributeConverterDescriptor = new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\t\tPassThruSoftDeleteConverter.INSTANCE,\n\t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( getSoftDeleteStrategy() == SoftDeleteType.ACTIVE ) {\n\t\t\t\tattributeConverterDescriptor = new ReversedConverterDescriptor<>( attributeConverterDescriptor );\n\t\t\t}\n\t\t}\n\n\t\treturn attributeConverterDescriptor != null\n\t\t\t\t? converterResolution( javaType, attributeConverterDescriptor )\n\t\t\t\t: resolution( explicitJavaType, javaType );\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/mapping/BasicValue.java",
        "isPureRefactoring": true,
        "commitId": "6c6c92e88d4535be020b4acb3d81f96df39a65d8",
        "packageNameBefore": "org.hibernate.mapping",
        "classNameBefore": "org.hibernate.mapping.BasicValue",
        "methodNameBefore": "org.hibernate.mapping.BasicValue#buildResolution",
        "invokedMethod": "methodSignature: org.hibernate.type.spi.TypeConfiguration.ArrayCacheKey#equals\n methodBody: public boolean equals(Object o) {\nreturn Arrays.equals(components,((ArrayCacheKey)o).components);\n}\nmethodSignature: org.hibernate.mapping.BasicValue#resolution\n methodBody: private Resolution<?> resolution(BasicJavaType explicitJavaType, JavaType<?> javaType) {\nfinal JavaType<?> basicJavaType;\nfinal JdbcType jdbcType;\nif(explicitJdbcTypeAccess != null){final TypeConfiguration typeConfiguration=getTypeConfiguration();\njdbcType=explicitJdbcTypeAccess.apply(typeConfiguration);\nbasicJavaType=javaType == null && jdbcType != null ? jdbcType.getJdbcRecommendedJavaTypeMapping(null,null,typeConfiguration) : javaType;\n}{jdbcType=null;\nbasicJavaType=javaType;\n}if(basicJavaType == null){throw new MappingException(\"Unable to determine JavaType to use : \" + this);\n}if(basicJavaType instanceof BasicJavaType<?> && (!basicJavaType.getJavaTypeClass().isEnum() || enumerationStyle == null)){final TypeDefinition autoAppliedTypeDef=getBuildingContext().getTypeDefinitionRegistry().resolveAutoApplied((BasicJavaType<?>)basicJavaType);\nif(autoAppliedTypeDef != null){log.debug(\"BasicValue resolution matched auto-applied type-definition\");\nreturn autoAppliedTypeDef.resolve(getTypeParameters(),null,getBuildingContext(),this);\n}}return InferredBasicValueResolver.from(explicitJavaType,jdbcType,resolvedJavaType,this::determineReflectedJavaType,explicitMutabilityPlanAccess,this,getTable(),getColumn(),ownerName,propertyName,getBuildingContext());\n}\nmethodSignature: org.hibernate.mapping.BasicValue#isSoftDelete\n methodBody: public boolean isSoftDelete() {\nreturn isSoftDelete;\n}\nmethodSignature: org.hibernate.type.spi.TypeConfiguration.Scope#getTypeConfiguration\n methodBody: public TypeConfiguration getTypeConfiguration() {\nreturn typeConfiguration;\n}\nmethodSignature: org.hibernate.mapping.BasicValue.ReversedConverterDescriptor#getAttributeConverterClass\n methodBody: public Class<? extends AttributeConverter<Boolean,R>> getAttributeConverterClass() {\nreturn (Class<? extends AttributeConverter<Boolean,R>>)getClass();\n}\nmethodSignature: org.hibernate.mapping.BasicValue#interpretExplicitlyNamedType\n methodBody: private static Resolution<?> interpretExplicitlyNamedType(\n\t\t\tString name,\n\t\t\tFunction<TypeConfiguration, BasicJavaType> explicitJtdAccess,\n\t\t\tFunction<TypeConfiguration, JdbcType> explicitStdAccess,\n\t\t\tFunction<TypeConfiguration, MutabilityPlan> explicitMutabilityPlanAccess,\n\t\t\tConverterDescriptor converterDescriptor,\n\t\t\tMap<Object,Object> localTypeParams,\n\t\t\tConsumer<Properties> combinedParameterConsumer,\n\t\t\tJdbcTypeIndicators stdIndicators,\n\t\t\tMetadataBuildingContext context) {\nfinal StandardServiceRegistry serviceRegistry=context.getBootstrapContext().getServiceRegistry();\nfinal ManagedBeanRegistry managedBeanRegistry=serviceRegistry.requireService(ManagedBeanRegistry.class);\nfinal TypeConfiguration typeConfiguration=context.getBootstrapContext().getTypeConfiguration();\nfinal JpaAttributeConverterCreationContext converterCreationContext=new JpaAttributeConverterCreationContext(){\n  @Override public ManagedBeanRegistry getManagedBeanRegistry(){\n    return managedBeanRegistry;\n  }\n  @Override public TypeConfiguration getTypeConfiguration(){\n    return typeConfiguration;\n  }\n}\n;\nif(name.startsWith(ConverterDescriptor.TYPE_NAME_PREFIX)){return NamedConverterResolution.from(name,explicitJtdAccess,explicitStdAccess,explicitMutabilityPlanAccess,stdIndicators,converterCreationContext,context);\n}if(name.startsWith(BasicTypeImpl.EXTERNALIZED_PREFIX)){final BasicType<Object> basicType=context.getBootstrapContext().resolveAdHocBasicType(name);\nreturn new NamedBasicTypeResolution<>(basicType.getJavaTypeDescriptor(),basicType,null,explicitMutabilityPlanAccess,context);\n}final BasicType<?> basicTypeByName=typeConfiguration.getBasicTypeRegistry().getRegisteredType(name);\nif(basicTypeByName != null){final BasicValueConverter<?,?> valueConverter;\nfinal JavaType<?> domainJtd;\nif(converterDescriptor != null){valueConverter=converterDescriptor.createJpaAttributeConverter(converterCreationContext);\ndomainJtd=valueConverter.getDomainJavaType();\n}{valueConverter=basicTypeByName.getValueConverter();\ndomainJtd=basicTypeByName.getJavaTypeDescriptor();\n}return new NamedBasicTypeResolution<>(domainJtd,basicTypeByName,valueConverter,explicitMutabilityPlanAccess,context);\n}final TypeDefinition typeDefinition=context.getTypeDefinitionRegistry().resolve(name);\nif(typeDefinition != null){final Resolution<?> resolution=typeDefinition.resolve(localTypeParams,explicitMutabilityPlanAccess != null ? explicitMutabilityPlanAccess.apply(typeConfiguration) : null,context,stdIndicators);\ncombinedParameterConsumer.accept(resolution.getCombinedTypeParameters());\nreturn resolution;\n}final ClassLoaderService cls=serviceRegistry.requireService(ClassLoaderService.class);\ntryfinal Class<?> typeNamedClass=cls.classForName(name);\nif(CollectionHelper.isEmpty(localTypeParams)){final TypeDefinition implicitDefinition=new TypeDefinition(name,typeNamedClass,null,null);\ncontext.getTypeDefinitionRegistry().register(implicitDefinition);\nreturn implicitDefinition.resolve(localTypeParams,explicitMutabilityPlanAccess != null ? explicitMutabilityPlanAccess.apply(typeConfiguration) : null,context,stdIndicators);\n}return TypeDefinition.createLocalResolution(name,typeNamedClass,localTypeParams,context);\ncatch(ClassLoadingException e)log.debugf(\"Could not resolve type-name [%s] as Java type : %s\",name,e);\nthrow new MappingException(\"Could not resolve named type : \" + name);\n}\nmethodSignature: org.hibernate.mapping.BasicValue#getSoftDeleteStrategy\n methodBody: public SoftDeleteType getSoftDeleteStrategy() {\nreturn softDeleteStrategy;\n}\nmethodSignature: org.hibernate.mapping.BasicValue#determineJavaType\n methodBody: private JavaType<?> determineJavaType(JavaType<?> explicitJavaType) {\nJavaType<?> javaType=explicitJavaType;\nif(javaType == null){final JavaType<?> reflectedJtd=determineReflectedJavaType();\nif(reflectedJtd != null){javaType=reflectedJtd;\n}}return javaType;\n}\nmethodSignature: org.hibernate.mapping.BasicValue#converterResolution\n methodBody: private Resolution<?> converterResolution(JavaType<?> javaType, ConverterDescriptor attributeConverterDescriptor) {\nfinal NamedConverterResolution<?> converterResolution=NamedConverterResolution.from(attributeConverterDescriptor,explicitJavaTypeAccess,explicitJdbcTypeAccess,explicitMutabilityPlanAccess,resolvedJavaType,this,this,getBuildingContext());\nif(javaType instanceof BasicPluralJavaType<?> && !attributeConverterDescriptor.getDomainValueResolvedType().getErasedType().isAssignableFrom(javaType.getJavaTypeClass())){final BasicPluralJavaType<?> containerJtd=(BasicPluralJavaType<?>)javaType;\nfinal BasicType registeredElementType=converterResolution.getLegacyResolvedBasicType();\nfinal Selectable column=getColumn();\nfinal BasicType<?> registeredType=registeredElementType == null ? null : containerJtd.resolveType(getTypeConfiguration(),getDialect(),registeredElementType,column instanceof ColumnTypeInformation ? (ColumnTypeInformation)column : null,this);\nif(registeredType != null){getTypeConfiguration().getBasicTypeRegistry().register(registeredType);\nreturn new InferredBasicValueResolution(registeredType,registeredType.getJavaTypeDescriptor(),registeredType.getJavaTypeDescriptor(),registeredType.getJdbcType(),registeredType,null);\n}}return converterResolution;\n}",
        "classSignatureBefore": "public class BasicValue extends SimpleValue implements JdbcTypeIndicators, Resolvable, JpaAttributeConverterCreationContext ",
        "methodNameBeforeSet": [
            "org.hibernate.mapping.BasicValue#buildResolution"
        ],
        "classNameBeforeSet": [
            "org.hibernate.mapping.BasicValue"
        ],
        "classSignatureBeforeSet": [
            "public class BasicValue extends SimpleValue implements JdbcTypeIndicators, Resolvable, JpaAttributeConverterCreationContext "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.mapping;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\n\nimport org.hibernate.Incubating;\nimport org.hibernate.Internal;\nimport org.hibernate.MappingException;\nimport org.hibernate.TimeZoneStorageStrategy;\nimport org.hibernate.annotations.SoftDelete;\nimport org.hibernate.annotations.SoftDeleteType;\nimport org.hibernate.annotations.TimeZoneStorageType;\nimport org.hibernate.boot.model.TypeDefinition;\nimport org.hibernate.boot.model.convert.internal.AutoApplicableConverterDescriptorBypassedImpl;\nimport org.hibernate.boot.model.convert.internal.ClassBasedConverterDescriptor;\nimport org.hibernate.boot.model.convert.internal.InstanceBasedConverterDescriptor;\nimport org.hibernate.boot.model.convert.spi.AutoApplicableConverterDescriptor;\nimport org.hibernate.boot.model.convert.spi.ConverterDescriptor;\nimport org.hibernate.boot.model.convert.spi.JpaAttributeConverterCreationContext;\nimport org.hibernate.boot.model.process.internal.InferredBasicValueResolution;\nimport org.hibernate.boot.model.process.internal.InferredBasicValueResolver;\nimport org.hibernate.boot.model.process.internal.NamedBasicTypeResolution;\nimport org.hibernate.boot.model.process.internal.NamedConverterResolution;\nimport org.hibernate.boot.model.process.internal.UserTypeResolution;\nimport org.hibernate.boot.model.process.internal.VersionResolution;\nimport org.hibernate.boot.registry.StandardServiceRegistry;\nimport org.hibernate.boot.registry.classloading.spi.ClassLoaderService;\nimport org.hibernate.boot.registry.classloading.spi.ClassLoadingException;\nimport org.hibernate.boot.spi.MetadataBuildingContext;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.Size;\nimport org.hibernate.internal.CoreLogging;\nimport org.hibernate.internal.CoreMessageLogger;\nimport org.hibernate.internal.util.ReflectHelper;\nimport org.hibernate.internal.util.StringHelper;\nimport org.hibernate.internal.util.collections.CollectionHelper;\nimport org.hibernate.metamodel.mapping.JdbcMapping;\nimport org.hibernate.metamodel.mapping.SelectablePath;\nimport org.hibernate.resource.beans.internal.FallbackBeanInstanceProducer;\nimport org.hibernate.resource.beans.spi.BeanInstanceProducer;\nimport org.hibernate.resource.beans.spi.ManagedBean;\nimport org.hibernate.resource.beans.spi.ManagedBeanRegistry;\nimport org.hibernate.tool.schema.extract.spi.ColumnTypeInformation;\nimport org.hibernate.type.BasicType;\nimport org.hibernate.type.CustomType;\nimport org.hibernate.type.NumericBooleanConverter;\nimport org.hibernate.type.SqlTypes;\nimport org.hibernate.type.TrueFalseConverter;\nimport org.hibernate.type.Type;\nimport org.hibernate.type.WrapperArrayHandling;\nimport org.hibernate.type.descriptor.converter.spi.BasicValueConverter;\nimport org.hibernate.type.descriptor.converter.spi.JpaAttributeConverter;\nimport org.hibernate.type.descriptor.java.BasicJavaType;\nimport org.hibernate.type.descriptor.java.BasicPluralJavaType;\nimport org.hibernate.type.descriptor.java.JavaType;\nimport org.hibernate.type.descriptor.java.MutabilityPlan;\nimport org.hibernate.type.descriptor.java.spi.JavaTypeRegistry;\nimport org.hibernate.type.descriptor.java.spi.JsonJavaType;\nimport org.hibernate.type.descriptor.java.spi.RegistryHelper;\nimport org.hibernate.type.descriptor.java.spi.XmlJavaType;\nimport org.hibernate.type.descriptor.jdbc.BooleanJdbcType;\nimport org.hibernate.type.descriptor.jdbc.JdbcType;\nimport org.hibernate.type.descriptor.jdbc.JdbcTypeIndicators;\nimport org.hibernate.type.internal.BasicTypeImpl;\nimport org.hibernate.type.spi.TypeConfiguration;\nimport org.hibernate.type.spi.TypeConfigurationAware;\nimport org.hibernate.usertype.DynamicParameterizedType;\nimport org.hibernate.usertype.UserType;\n\nimport com.fasterxml.classmate.ResolvedType;\nimport jakarta.persistence.AttributeConverter;\nimport jakarta.persistence.EnumType;\nimport jakarta.persistence.TemporalType;\n\nimport static java.lang.Boolean.parseBoolean;\nimport static org.hibernate.internal.util.collections.CollectionHelper.isNotEmpty;\nimport static org.hibernate.mapping.MappingHelper.injectParameters;\n\n/**\n * @author Steve Ebersole\n */\npublic class BasicValue extends SimpleValue implements JdbcTypeIndicators, Resolvable, JpaAttributeConverterCreationContext {\n\tprivate static final CoreMessageLogger log = CoreLogging.messageLogger( BasicValue.class );\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// incoming \"configuration\" values\n\n\tprivate String explicitTypeName;\n\tprivate Map<String,String> explicitLocalTypeParams;\n\n\tprivate Function<TypeConfiguration, BasicJavaType> explicitJavaTypeAccess;\n\tprivate Function<TypeConfiguration, JdbcType> explicitJdbcTypeAccess;\n\tprivate Function<TypeConfiguration, MutabilityPlan> explicitMutabilityPlanAccess;\n\tprivate Function<TypeConfiguration, java.lang.reflect.Type> implicitJavaTypeAccess;\n\n\tprivate EnumType enumerationStyle;\n\tprivate TemporalType temporalPrecision;\n\tprivate TimeZoneStorageType timeZoneStorageType;\n\tprivate boolean isSoftDelete;\n\tprivate SoftDeleteType softDeleteStrategy;\n\n\tprivate java.lang.reflect.Type resolvedJavaType;\n\n\tprivate String ownerName;\n\tprivate String propertyName;\n\tprivate AggregateColumn aggregateColumn;\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// Resolved state - available after `#resolve`\n\tprivate Resolution<?> resolution;\n\tprivate Integer jdbcTypeCode;\n\n\n\tpublic BasicValue(MetadataBuildingContext buildingContext) {\n\t\tthis( buildingContext, null );\n\t}\n\n\tpublic BasicValue(MetadataBuildingContext buildingContext, Table table) {\n\t\tsuper( buildingContext, table );\n\t\tbuildingContext.getMetadataCollector().registerValueMappingResolver( this::resolve );\n\t}\n\n\tpublic BasicValue(BasicValue original) {\n\t\tsuper( original );\n\t\tthis.explicitTypeName = original.explicitTypeName;\n\t\tthis.explicitLocalTypeParams = original.explicitLocalTypeParams == null\n\t\t\t\t? null\n\t\t\t\t: new HashMap<>(original.explicitLocalTypeParams);\n\t\tthis.explicitJavaTypeAccess = original.explicitJavaTypeAccess;\n\t\tthis.explicitJdbcTypeAccess = original.explicitJdbcTypeAccess;\n\t\tthis.explicitMutabilityPlanAccess = original.explicitMutabilityPlanAccess;\n\t\tthis.implicitJavaTypeAccess = original.implicitJavaTypeAccess;\n\t\tthis.enumerationStyle = original.enumerationStyle;\n\t\tthis.temporalPrecision = original.temporalPrecision;\n\t\tthis.timeZoneStorageType = original.timeZoneStorageType;\n\t\tthis.resolvedJavaType = original.resolvedJavaType;\n\t\tthis.ownerName = original.ownerName;\n\t\tthis.propertyName = original.propertyName;\n\t}\n\n\t@Override\n\tpublic BasicValue copy() {\n\t\treturn new BasicValue( this );\n\t}\n\n\tpublic boolean isSoftDelete() {\n\t\treturn isSoftDelete;\n\t}\n\n\tpublic SoftDeleteType getSoftDeleteStrategy() {\n\t\treturn softDeleteStrategy;\n\t}\n\n\tpublic void makeSoftDelete(SoftDeleteType strategy) {\n\t\tisSoftDelete = true;\n\t\tsoftDeleteStrategy = strategy;\n\t}\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// Setters - in preparation of resolution\n\n\t@Override\n\tpublic void setTypeUsingReflection(String className, String propertyName) throws MappingException {\n\t\tif ( resolution != null ) {\n\t\t\tthrow new IllegalStateException( \"BasicValue already resolved\" );\n\t\t}\n\n\t\tthis.ownerName = className;\n\t\tthis.propertyName = propertyName;\n\n\t\tsuper.setTypeUsingReflection( className, propertyName );\n\t}\n\n\tpublic void setEnumerationStyle(EnumType enumerationStyle) {\n\t\tthis.enumerationStyle = enumerationStyle;\n\t}\n\n\tpublic EnumType getEnumerationStyle() {\n\t\treturn enumerationStyle;\n\t}\n\n\tpublic TimeZoneStorageType getTimeZoneStorageType() {\n\t\treturn timeZoneStorageType;\n\t}\n\n\tpublic void setTimeZoneStorageType(TimeZoneStorageType timeZoneStorageType) {\n\t\tthis.timeZoneStorageType = timeZoneStorageType;\n\t}\n\n\tpublic void setJpaAttributeConverterDescriptor(ConverterDescriptor descriptor) {\n\t\tsetAttributeConverterDescriptor( descriptor );\n\n\t\tsuper.setJpaAttributeConverterDescriptor( descriptor );\n\t}\n\n\t@SuppressWarnings(\"rawtypes\")\n\tpublic void setExplicitJavaTypeAccess(Function<TypeConfiguration, BasicJavaType> explicitJavaTypeAccess) {\n\t\tthis.explicitJavaTypeAccess = explicitJavaTypeAccess;\n\t}\n\n\tpublic void setExplicitJdbcTypeAccess(Function<TypeConfiguration, JdbcType> jdbcTypeAccess) {\n\t\tthis.explicitJdbcTypeAccess = jdbcTypeAccess;\n\t}\n\n\tpublic void setExplicitMutabilityPlanAccess(Function<TypeConfiguration, MutabilityPlan> explicitMutabilityPlanAccess) {\n\t\tthis.explicitMutabilityPlanAccess = explicitMutabilityPlanAccess;\n\t}\n\n\tpublic void setImplicitJavaTypeAccess(Function<TypeConfiguration, java.lang.reflect.Type> implicitJavaTypeAccess) {\n\t\tthis.implicitJavaTypeAccess = implicitJavaTypeAccess;\n\t}\n\n\tpublic Selectable getColumn() {\n\t\tif ( getColumnSpan() == 0 ) {\n\t\t\treturn null;\n\t\t}\n\t\treturn getColumn( 0 );\n\t}\n\n\tpublic java.lang.reflect.Type getResolvedJavaType() {\n\t\treturn resolvedJavaType;\n\t}\n\n\t@Override\n\tpublic long getColumnLength() {\n\t\tfinal Selectable selectable = getColumn();\n\t\tif ( selectable instanceof Column ) {\n\t\t\tfinal Column column = (Column) selectable;\n\t\t\tfinal Long length = column.getLength();\n\t\t\treturn length == null ? NO_COLUMN_LENGTH : length;\n\t\t}\n\t\telse {\n\t\t\treturn NO_COLUMN_LENGTH;\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getColumnPrecision() {\n\t\tfinal Selectable selectable = getColumn();\n\t\tif ( selectable instanceof Column ) {\n\t\t\tfinal Column column = (Column) selectable;\n\t\t\tif ( column.getTemporalPrecision() != null ) {\n\t\t\t\treturn column.getTemporalPrecision();\n\t\t\t}\n\t\t\tfinal Integer precision = column.getPrecision();\n\t\t\treturn precision == null ? NO_COLUMN_PRECISION : precision;\n\t\t}\n\t\telse {\n\t\t\treturn NO_COLUMN_PRECISION;\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getColumnScale() {\n\t\tfinal Selectable selectable = getColumn();\n\t\tif ( selectable instanceof Column ) {\n\t\t\tfinal Column column = (Column) selectable;\n\t\t\tfinal Integer scale = column.getScale();\n\t\t\treturn scale == null ? NO_COLUMN_SCALE : scale;\n\t\t}\n\t\telse {\n\t\t\treturn NO_COLUMN_SCALE;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void addColumn(Column incomingColumn) {\n\t\tsuper.addColumn( incomingColumn );\n\n\t\tcheckSelectable( incomingColumn );\n\t}\n\n\t@Override\n\tpublic void copyTypeFrom(SimpleValue sourceValue) {\n\t\tsuper.copyTypeFrom( sourceValue );\n\t\tif ( sourceValue instanceof BasicValue ) {\n\t\t\tfinal BasicValue basicValue = (BasicValue) sourceValue;\n\t\t\tthis.resolution = basicValue.resolution;\n\t\t\tthis.implicitJavaTypeAccess = (typeConfiguration) -> basicValue.implicitJavaTypeAccess.apply( typeConfiguration );\n\t\t}\n\t}\n\n\tprivate void checkSelectable(Selectable incomingColumn) {\n\t\tif ( incomingColumn == null ) {\n\t\t\tthrow new IllegalArgumentException( \"Incoming column was null\" );\n\t\t}\n\n\t\tfinal Selectable column = getColumn();\n\t\tif ( column == incomingColumn || column.getText().equals( incomingColumn.getText() ) ) {\n\t\t\tlog.debugf( \"Skipping column re-registration: %s.%s\", getTable().getName(), column.getText() );\n\t\t}\n//\t\telse {\n//\t\t\tthrow new IllegalStateException(\n//\t\t\t\t\t\"BasicValue [\" + ownerName + \".\" + propertyName +\n//\t\t\t\t\t\t\t\"] already had column associated: `\" + column.getText() +\n//\t\t\t\t\t\t\t\"` -> `\" + incomingColumn.getText() + \"`\"\n//\t\t\t);\n//\t\t}\n\t}\n\n\t@Override\n\tpublic void addColumn(Column incomingColumn, boolean isInsertable, boolean isUpdatable) {\n\t\tsuper.addColumn( incomingColumn, isInsertable, isUpdatable );\n\t\tcheckSelectable( incomingColumn );\n\t}\n\n\t@Override\n\tpublic void addFormula(Formula formula) {\n\t\tsuper.addFormula( formula );\n\n\t\tcheckSelectable( formula );\n\t}\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// Resolution\n\n\t@Override\n\tpublic Type getType() throws MappingException {\n\t\tresolve();\n\t\tassert getResolution() != null;\n\n\t\treturn getResolution().getLegacyResolvedBasicType();\n\t}\n\n\tpublic Resolution<?> getResolution() {\n\t\treturn resolution;\n\t}\n\n\t@Override\n\tpublic boolean resolve(MetadataBuildingContext buildingContext) {\n\t\tresolve();\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic Resolution<?> resolve() {\n\t\tif ( resolution != null ) {\n\t\t\treturn resolution;\n\t\t}\n\n\t\tresolution = buildResolution();\n\n\t\tif ( resolution == null ) {\n\t\t\tthrow new IllegalStateException( \"Unable to resolve BasicValue : \" + this );\n\t\t}\n\n\t\tfinal Selectable selectable = getColumn();\n\t\tfinal Size size;\n\t\tif ( selectable instanceof Column column ) {\n\t\t\tresolveColumn( column, getDialect() );\n\t\t\tsize = column.calculateColumnSize( getDialect(), getBuildingContext().getMetadataCollector() );\n\t\t}\n\t\telse {\n\t\t\tsize = Size.nil();\n\t\t}\n\n\t\tresolution.getJdbcType().addAuxiliaryDatabaseObjects(\n\t\t\t\tresolution.getRelationalJavaType(),\n\t\t\t\tresolution.getValueConverter(),\n\t\t\t\tsize,\n\t\t\t\tgetBuildingContext().getMetadataCollector().getDatabase(),\n\t\t\t\tthis\n\t\t);\n\n\t\treturn resolution;\n\t}\n\n\t@Override\n\tpublic String getExtraCreateTableInfo() {\n\t\treturn resolution.getJdbcType()\n\t\t\t\t.getExtraCreateTableInfo(\n\t\t\t\t\t\tresolution.getRelationalJavaType(),\n\t\t\t\t\t\tgetColumn().getText(),\n\t\t\t\t\t\tgetTable().getName(),\n\t\t\t\t\t\tgetBuildingContext().getMetadataCollector().getDatabase()\n\t\t\t\t);\n\t}\n\n\t@Override\n\tpublic Dialect getDialect() {\n\t\treturn getMetadata().getDatabase().getDialect();\n\t}\n\n\tprivate void resolveColumn(Column column, Dialect dialect) {\n\n\t\tif ( column.getSqlTypeCode() == null ) {\n\t\t\tcolumn.setSqlTypeCode( resolution.getJdbcType().getDdlTypeCode() );\n\t\t}\n\n//\t\tfinal String declaration = resolution.getLegacyResolvedBasicType().getSpecializedTypeDeclaration( dialect );\n//\t\tif ( declaration != null ) {\n//\t\t\tcolumn.setSpecializedTypeDeclaration( declaration );\n//\t\t}\n\n\t\tif ( dialect.supportsColumnCheck() ) {\n\t\t\tfinal String checkCondition = resolution.getLegacyResolvedBasicType()\n\t\t\t\t\t.getCheckCondition( column.getQuotedName( dialect ), dialect );\n\t\t\tif ( checkCondition != null ) {\n\t\t\t\tcolumn.addCheckConstraint( new CheckConstraint( checkCondition ) );\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic AggregateColumn getAggregateColumn() {\n\t\treturn aggregateColumn;\n\t}\n\n\tpublic void setAggregateColumn(AggregateColumn aggregateColumn) {\n\t\tthis.aggregateColumn = aggregateColumn;\n\t}\n\n\tpublic SelectablePath createSelectablePath(String selectableName) {\n\t\tif ( aggregateColumn != null ) {\n\t\t\treturn aggregateColumn.getSelectablePath().append( selectableName );\n\t\t}\n\t\treturn new SelectablePath( selectableName );\n\t}\n\n\tprotected Resolution<?> buildResolution() {\n\t\tfinal Properties typeParameters = getTypeParameters();\n\t\tif ( typeParameters != null\n\t\t\t\t&& parseBoolean( typeParameters.getProperty(DynamicParameterizedType.IS_DYNAMIC) )\n\t\t\t\t&& typeParameters.get(DynamicParameterizedType.PARAMETER_TYPE) == null ) {\n\t\t\tcreateParameterImpl();\n\t\t}\n\n\t\tif ( explicitTypeName != null ) {\n\t\t\treturn interpretExplicitlyNamedType(\n\t\t\t\t\texplicitTypeName,\n\t\t\t\t\texplicitJavaTypeAccess,\n\t\t\t\t\texplicitJdbcTypeAccess,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tgetAttributeConverterDescriptor(),\n\t\t\t\t\ttypeParameters,\n\t\t\t\t\tthis::setTypeParameters,\n\t\t\t\t\tthis,\n\t\t\t\t\tgetBuildingContext()\n\t\t\t);\n\t\t}\n\n\t\tif ( isVersion() ) {\n\t\t\treturn VersionResolution.from( implicitJavaTypeAccess, timeZoneStorageType, getBuildingContext() );\n\t\t}\n\n\t\t// determine JavaType if we can\n\t\tfinal BasicJavaType<?> explicitJavaType = explicitJavaTypeAccess == null\n\t\t\t\t? null\n\t\t\t\t: explicitJavaTypeAccess.apply( getTypeConfiguration() );\n\n\t\tJavaType<?> javaType = determineJavaType( explicitJavaType );\n\t\tConverterDescriptor attributeConverterDescriptor = getAttributeConverterDescriptor();\n\n\t\tif ( isSoftDelete() ) {\n\t\t\tassert attributeConverterDescriptor != null;\n\t\t\tfinal boolean conversionWasUnspecified = SoftDelete.UnspecifiedConversion.class.equals( attributeConverterDescriptor.getAttributeConverterClass() );\n\t\t\tif ( conversionWasUnspecified ) {\n\t\t\t\tfinal JdbcType jdbcType = BooleanJdbcType.INSTANCE.resolveIndicatedType( this, javaType );\n\t\t\t\tif ( jdbcType.isNumber() ) {\n\t\t\t\t\tattributeConverterDescriptor = new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\t\tNumericBooleanConverter.INSTANCE,\n\t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\telse if ( jdbcType.isString() ) {\n\t\t\t\t\t// here we pick 'T' / 'F' storage, though 'Y' / 'N' is equally valid - its 50/50\n\t\t\t\t\tattributeConverterDescriptor = new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\t\tTrueFalseConverter.INSTANCE,\n\t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// should indicate BIT or BOOLEAN == no conversion needed\n\t\t\t\t\t//\t\t- we still create the converter to properly set up JDBC type, etc\n\t\t\t\t\tattributeConverterDescriptor = new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\t\tPassThruSoftDeleteConverter.INSTANCE,\n\t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( getSoftDeleteStrategy() == SoftDeleteType.ACTIVE ) {\n\t\t\t\tattributeConverterDescriptor = new ReversedConverterDescriptor<>( attributeConverterDescriptor );\n\t\t\t}\n\t\t}\n\n\t\treturn attributeConverterDescriptor != null\n\t\t\t\t? converterResolution( javaType, attributeConverterDescriptor )\n\t\t\t\t: resolution( explicitJavaType, javaType );\n\t}\n\n\tprivate static class ReversedConverterDescriptor<R> implements ConverterDescriptor {\n\t\tprivate final ConverterDescriptor underlyingDescriptor;\n\n\t\tpublic ReversedConverterDescriptor(ConverterDescriptor underlyingDescriptor) {\n\t\t\tthis.underlyingDescriptor = underlyingDescriptor;\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<? extends AttributeConverter<Boolean,R>> getAttributeConverterClass() {\n\t\t\t//noinspection unchecked\n\t\t\treturn (Class<? extends AttributeConverter<Boolean, R>>) getClass();\n\t\t}\n\n\t\t@Override\n\t\tpublic ResolvedType getDomainValueResolvedType() {\n\t\t\treturn underlyingDescriptor.getDomainValueResolvedType();\n\t\t}\n\n\t\t@Override\n\t\tpublic ResolvedType getRelationalValueResolvedType() {\n\t\t\treturn underlyingDescriptor.getRelationalValueResolvedType();\n\t\t}\n\n\t\t@Override\n\t\tpublic AutoApplicableConverterDescriptor getAutoApplyDescriptor() {\n\t\t\treturn AutoApplicableConverterDescriptorBypassedImpl.INSTANCE;\n\t\t}\n\n\t\t@Override\n\t\tpublic JpaAttributeConverter<Boolean,R> createJpaAttributeConverter(JpaAttributeConverterCreationContext context) {\n\t\t\t//noinspection unchecked\n\t\t\treturn new ReversedJpaAttributeConverter<>(\n\t\t\t\t\t(JpaAttributeConverter<Boolean, R>) underlyingDescriptor.createJpaAttributeConverter( context ),\n\t\t\t\t\tcontext.getJavaTypeRegistry().getDescriptor( ReversedJpaAttributeConverter.class )\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate static class ReversedJpaAttributeConverter<R, B extends AttributeConverter<Boolean, R>>\n\t\t\timplements JpaAttributeConverter<Boolean,R>, AttributeConverter<Boolean,R>, ManagedBean<B> {\n\t\tprivate final JpaAttributeConverter<Boolean,R> underlyingJpaConverter;\n\t\tprivate final JavaType<ReversedJpaAttributeConverter<R,B>> converterJavaType;\n\n\t\tpublic ReversedJpaAttributeConverter(\n\t\t\t\tJpaAttributeConverter<Boolean, R> underlyingJpaConverter,\n\t\t\t\tJavaType<ReversedJpaAttributeConverter<R,B>> converterJavaType) {\n\t\t\tthis.underlyingJpaConverter = underlyingJpaConverter;\n\t\t\tthis.converterJavaType = converterJavaType;\n\t\t}\n\n\t\t@Override\n\t\tpublic Boolean toDomainValue(R relationalValue) {\n\t\t\treturn !underlyingJpaConverter.toDomainValue( relationalValue );\n\t\t}\n\n\t\t@Override\n\t\tpublic R toRelationalValue(Boolean domainValue) {\n\t\t\treturn underlyingJpaConverter.toRelationalValue( domainValue != null ? !domainValue : null );\n\t\t}\n\n\t\t@Override\n\t\tpublic Boolean convertToEntityAttribute(R relationalValue) {\n\t\t\treturn toDomainValue( relationalValue );\n\t\t}\n\n\t\t@Override\n\t\tpublic R convertToDatabaseColumn(Boolean domainValue) {\n\t\t\treturn toRelationalValue( domainValue );\n\t\t}\n\n\t\t@Override\n\t\tpublic JavaType<Boolean> getDomainJavaType() {\n\t\t\treturn underlyingJpaConverter.getDomainJavaType();\n\t\t}\n\n\t\t@Override\n\t\tpublic JavaType<R> getRelationalJavaType() {\n\t\t\treturn underlyingJpaConverter.getRelationalJavaType();\n\t\t}\n\n\t\t@Override\n\t\tpublic JavaType<? extends AttributeConverter<Boolean, R>> getConverterJavaType() {\n\t\t\treturn converterJavaType;\n\t\t}\n\n\t\t@Override\n\t\tpublic ManagedBean<? extends AttributeConverter<Boolean, R>> getConverterBean() {\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<B> getBeanClass() {\n\t\t\t//noinspection unchecked\n\t\t\treturn (Class<B>) getClass();\n\t\t}\n\n\t\t@Override\n\t\tpublic B getBeanInstance() {\n\t\t\t//noinspection unchecked\n\t\t\treturn (B) this;\n\t\t}\n\t}\n\n\tprivate static class PassThruSoftDeleteConverter implements AttributeConverter<Boolean,Boolean> {\n\t\tprivate static final PassThruSoftDeleteConverter INSTANCE = new PassThruSoftDeleteConverter();\n\n\t\t@Override\n\t\tpublic Boolean convertToDatabaseColumn(Boolean domainValue) {\n\t\t\treturn domainValue;\n\t\t}\n\n\t\t@Override\n\t\tpublic Boolean convertToEntityAttribute(Boolean relationalValue) {\n\t\t\treturn relationalValue;\n\t\t}\n\t}\n\n\tprivate Resolution<?> resolution(BasicJavaType explicitJavaType, JavaType<?> javaType) {\n\t\tfinal JavaType<?> basicJavaType;\n\t\tfinal JdbcType jdbcType;\n\t\tif ( explicitJdbcTypeAccess != null ) {\n\t\t\tfinal TypeConfiguration typeConfiguration = getTypeConfiguration();\n\t\t\tjdbcType = explicitJdbcTypeAccess.apply( typeConfiguration );\n\t\t\tbasicJavaType = javaType == null && jdbcType != null\n\t\t\t\t\t? jdbcType.getJdbcRecommendedJavaTypeMapping(null, null, typeConfiguration)\n\t\t\t\t\t: javaType;\n\t\t}\n\t\telse {\n\t\t\tjdbcType = null;\n\t\t\tbasicJavaType = javaType;\n\t\t}\n\t\tif ( basicJavaType == null ) {\n\t\t\tthrow new MappingException( \"Unable to determine JavaType to use : \" + this );\n\t\t}\n\n\t\tif ( basicJavaType instanceof BasicJavaType<?>\n\t\t\t\t&& ( !basicJavaType.getJavaTypeClass().isEnum() || enumerationStyle == null ) ) {\n\t\t\tfinal TypeDefinition autoAppliedTypeDef =\n\t\t\t\t\tgetBuildingContext().getTypeDefinitionRegistry()\n\t\t\t\t\t\t\t.resolveAutoApplied( (BasicJavaType<?>) basicJavaType );\n\t\t\tif ( autoAppliedTypeDef != null ) {\n\t\t\t\tlog.debug(\"BasicValue resolution matched auto-applied type-definition\");\n\t\t\t\treturn autoAppliedTypeDef.resolve( getTypeParameters(), null, getBuildingContext(), this );\n\t\t\t}\n\t\t}\n\n\t\treturn InferredBasicValueResolver.from(\n\t\t\t\texplicitJavaType,\n\t\t\t\tjdbcType,\n\t\t\t\tresolvedJavaType,\n\t\t\t\tthis::determineReflectedJavaType,\n\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\tthis,\n\t\t\t\tgetTable(),\n\t\t\t\tgetColumn(),\n\t\t\t\townerName,\n\t\t\t\tpropertyName,\n\t\t\t\tgetBuildingContext()\n\t\t);\n\t}\n\n\t@Override\n\tpublic ManagedBeanRegistry getManagedBeanRegistry() {\n\t\treturn getServiceRegistry().requireService( ManagedBeanRegistry.class );\n\t}\n\n\tprivate Resolution<?> converterResolution(JavaType<?> javaType, ConverterDescriptor attributeConverterDescriptor) {\n\t\tfinal NamedConverterResolution<?> converterResolution = NamedConverterResolution.from(\n\t\t\t\tattributeConverterDescriptor,\n\t\t\t\texplicitJavaTypeAccess,\n\t\t\t\texplicitJdbcTypeAccess,\n\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\tresolvedJavaType,\n\t\t\t\tthis,\n\t\t\t\tthis,\n\t\t\t\tgetBuildingContext()\n\t\t);\n\n\t\tif ( javaType instanceof BasicPluralJavaType<?>\n\t\t\t\t&& !attributeConverterDescriptor.getDomainValueResolvedType().getErasedType()\n\t\t\t\t\t\t.isAssignableFrom( javaType.getJavaTypeClass() ) ) {\n\t\t\t// In this case, the converter applies to the element of a BasicPluralJavaType\n\t\t\tfinal BasicPluralJavaType<?> containerJtd = (BasicPluralJavaType<?>) javaType;\n\t\t\tfinal BasicType registeredElementType = converterResolution.getLegacyResolvedBasicType();\n\t\t\tfinal Selectable column = getColumn();\n\t\t\tfinal BasicType<?> registeredType = registeredElementType == null ? null\n\t\t\t\t\t: containerJtd.resolveType(\n\t\t\t\t\t\t\tgetTypeConfiguration(),\n\t\t\t\t\t\t\tgetDialect(),\n\t\t\t\t\t\t\tregisteredElementType,\n\t\t\t\t\t\t\tcolumn instanceof ColumnTypeInformation ? (ColumnTypeInformation) column : null,\n\t\t\t\t\t\t\tthis\n\t\t\t);\n\t\t\tif ( registeredType != null ) {\n\t\t\t\tgetTypeConfiguration().getBasicTypeRegistry().register( registeredType );\n\t\t\t\treturn new InferredBasicValueResolution(\n\t\t\t\t\t\tregisteredType,\n\t\t\t\t\t\tregisteredType.getJavaTypeDescriptor(),\n\t\t\t\t\t\tregisteredType.getJavaTypeDescriptor(),\n\t\t\t\t\t\tregisteredType.getJdbcType(),\n\t\t\t\t\t\tregisteredType,\n\t\t\t\t\t\tnull\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn converterResolution;\n\t}\n\n\tprivate JavaType<?> determineJavaType(JavaType<?> explicitJavaType) {\n\t\tJavaType<?> javaType = explicitJavaType;\n//\n//\t\tif ( javaType == null ) {\n//\t\t\tif ( implicitJavaTypeAccess != null ) {\n//\t\t\t\tfinal java.lang.reflect.Type implicitJtd = implicitJavaTypeAccess.apply( getTypeConfiguration() );\n//\t\t\t\tif ( implicitJtd != null ) {\n//\t\t\t\t\tjavaType = getTypeConfiguration().getJavaTypeRegistry().getDescriptor( implicitJtd );\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n\n\t\tif ( javaType == null ) {\n\t\t\tfinal JavaType<?> reflectedJtd = determineReflectedJavaType();\n\t\t\tif ( reflectedJtd != null ) {\n\t\t\t\tjavaType = reflectedJtd;\n\t\t\t}\n\t\t}\n\n\t\treturn javaType;\n\t}\n\n\tprivate JavaType<?> determineReflectedJavaType() {\n\t\tfinal java.lang.reflect.Type impliedJavaType;\n\n\t\tfinal TypeConfiguration typeConfiguration = getTypeConfiguration();\n\t\tif ( resolvedJavaType != null ) {\n\t\t\timpliedJavaType = resolvedJavaType;\n\t\t}\n\t\telse if ( implicitJavaTypeAccess != null ) {\n\t\t\timpliedJavaType = implicitJavaTypeAccess.apply( typeConfiguration );\n\t\t}\n\t\telse if ( ownerName != null && propertyName != null ) {\n\t\t\timpliedJavaType = ReflectHelper.reflectedPropertyType(\n\t\t\t\t\townerName,\n\t\t\t\t\tpropertyName,\n\t\t\t\t\tgetServiceRegistry().requireService( ClassLoaderService.class )\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\n\t\tresolvedJavaType = impliedJavaType;\n\n\t\tif ( impliedJavaType == null ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal JavaTypeRegistry javaTypeRegistry = typeConfiguration.getJavaTypeRegistry();\n\t\tfinal JavaType<Object> javaType = javaTypeRegistry.findDescriptor( impliedJavaType );\n\t\tfinal MutabilityPlan<Object> explicitMutabilityPlan = explicitMutabilityPlanAccess != null\n\t\t\t\t? explicitMutabilityPlanAccess.apply( typeConfiguration )\n\t\t\t\t: null;\n\t\tfinal MutabilityPlan<Object> determinedMutabilityPlan = explicitMutabilityPlan != null\n\t\t\t\t? explicitMutabilityPlan\n\t\t\t\t: RegistryHelper.INSTANCE.determineMutabilityPlan( impliedJavaType, typeConfiguration );\n\t\tif ( javaType == null ) {\n\t\t\tif ( jdbcTypeCode != null ) {\n\t\t\t\t// Construct special JavaType instances for JSON/XML types which can report recommended JDBC types\n\t\t\t\t// and implement toString/fromString as well as copying based on FormatMapper operations\n\t\t\t\tswitch ( jdbcTypeCode ) {\n\t\t\t\t\tcase SqlTypes.JSON:\n\t\t\t\t\t\tfinal JavaType<Object> jsonJavaType = new JsonJavaType<>(\n\t\t\t\t\t\t\t\timpliedJavaType,\n\t\t\t\t\t\t\t\tdeterminedMutabilityPlan,\n\t\t\t\t\t\t\t\ttypeConfiguration\n\t\t\t\t\t\t);\n\t\t\t\t\t\tjavaTypeRegistry.addDescriptor( jsonJavaType );\n\t\t\t\t\t\treturn jsonJavaType;\n\t\t\t\t\tcase SqlTypes.SQLXML:\n\t\t\t\t\t\tfinal JavaType<Object> xmlJavaType = new XmlJavaType<>(\n\t\t\t\t\t\t\t\timpliedJavaType,\n\t\t\t\t\t\t\t\tdeterminedMutabilityPlan,\n\t\t\t\t\t\t\t\ttypeConfiguration\n\t\t\t\t\t\t);\n\t\t\t\t\t\tjavaTypeRegistry.addDescriptor( xmlJavaType );\n\t\t\t\t\t\treturn xmlJavaType;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn javaTypeRegistry.resolveDescriptor( impliedJavaType );\n\t\t}\n\t\treturn javaType;\n\t}\n\n\tprivate static Resolution<?> interpretExplicitlyNamedType(\n\t\t\tString name,\n\t\t\tFunction<TypeConfiguration, BasicJavaType> explicitJtdAccess,\n\t\t\tFunction<TypeConfiguration, JdbcType> explicitStdAccess,\n\t\t\tFunction<TypeConfiguration, MutabilityPlan> explicitMutabilityPlanAccess,\n\t\t\tConverterDescriptor converterDescriptor,\n\t\t\tMap<Object,Object> localTypeParams,\n\t\t\tConsumer<Properties> combinedParameterConsumer,\n\t\t\tJdbcTypeIndicators stdIndicators,\n\t\t\tMetadataBuildingContext context) {\n\n\t\tfinal StandardServiceRegistry serviceRegistry = context.getBootstrapContext().getServiceRegistry();\n\t\tfinal ManagedBeanRegistry managedBeanRegistry = serviceRegistry.requireService( ManagedBeanRegistry.class );\n\t\tfinal TypeConfiguration typeConfiguration = context.getBootstrapContext().getTypeConfiguration();\n\n\t\tfinal JpaAttributeConverterCreationContext converterCreationContext = new JpaAttributeConverterCreationContext() {\n\t\t\t@Override\n\t\t\tpublic ManagedBeanRegistry getManagedBeanRegistry() {\n\t\t\t\treturn managedBeanRegistry;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic TypeConfiguration getTypeConfiguration() {\n\t\t\t\treturn typeConfiguration;\n\t\t\t}\n\t\t};\n\n\t\t// Name could refer to:\n\t\t//\t\t1) a named converter - HBM support for JPA's AttributeConverter via its `type=\"...\"` XML attribute\n\t\t//\t\t2) a \"named composed\" mapping - like (1), this is mainly to support envers since it tells\n\t\t//\t\t\tHibernate the mappings via DOM.  See `org.hibernate.type.internal.BasicTypeImpl`\n\t\t//\t\t3) basic type \"resolution key\"\n\t\t//\t\t4) UserType or BasicType class name - directly, or through a TypeDefinition\n\n\t\tif ( name.startsWith( ConverterDescriptor.TYPE_NAME_PREFIX  ) ) {\n\t\t\treturn NamedConverterResolution.from(\n\t\t\t\t\tname,\n\t\t\t\t\texplicitJtdAccess,\n\t\t\t\t\texplicitStdAccess,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tstdIndicators,\n\t\t\t\t\tconverterCreationContext,\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\n//\t\tif ( name.startsWith( EnumeratedValueResolution.PREFIX ) ) {\n//\t\t\treturn EnumeratedValueResolution.fromName( name, stdIndicators, context );\n//\t\t}\n\n\t\tif ( name.startsWith( BasicTypeImpl.EXTERNALIZED_PREFIX ) ) {\n\t\t\tfinal BasicType<Object> basicType = context.getBootstrapContext().resolveAdHocBasicType( name );\n\t\t\treturn new NamedBasicTypeResolution<>(\n\t\t\t\t\tbasicType.getJavaTypeDescriptor(),\n\t\t\t\t\tbasicType,\n\t\t\t\t\tnull,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\n\t\t// see if it is a named basic type\n\t\tfinal BasicType<?> basicTypeByName = typeConfiguration.getBasicTypeRegistry().getRegisteredType( name );\n\t\tif ( basicTypeByName != null ) {\n\t\t\tfinal BasicValueConverter<?,?> valueConverter;\n\t\t\tfinal JavaType<?> domainJtd;\n\t\t\tif ( converterDescriptor != null ) {\n\t\t\t\tvalueConverter = converterDescriptor.createJpaAttributeConverter( converterCreationContext );\n\t\t\t\tdomainJtd = valueConverter.getDomainJavaType();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalueConverter = basicTypeByName.getValueConverter();\n\t\t\t\tdomainJtd = basicTypeByName.getJavaTypeDescriptor();\n\t\t\t}\n\n\t\t\treturn new NamedBasicTypeResolution<>(\n\t\t\t\t\tdomainJtd,\n\t\t\t\t\tbasicTypeByName,\n\t\t\t\t\tvalueConverter,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\n\t\t// see if it is a named TypeDefinition\n\t\tfinal TypeDefinition typeDefinition = context.getTypeDefinitionRegistry().resolve( name );\n\t\tif ( typeDefinition != null ) {\n\t\t\tfinal Resolution<?> resolution = typeDefinition.resolve(\n\t\t\t\t\tlocalTypeParams,\n\t\t\t\t\texplicitMutabilityPlanAccess != null\n\t\t\t\t\t\t\t? explicitMutabilityPlanAccess.apply( typeConfiguration )\n\t\t\t\t\t\t\t: null,\n\t\t\t\t\tcontext,\n\t\t\t\t\tstdIndicators\n\t\t\t);\n\t\t\tcombinedParameterConsumer.accept( resolution.getCombinedTypeParameters() );\n\t\t\treturn resolution;\n\t\t}\n\n\n\t\t// see if the name is a UserType or BasicType implementor class name\n\t\tfinal ClassLoaderService cls = serviceRegistry.requireService( ClassLoaderService.class );\n\t\ttry {\n\t\t\tfinal Class<?> typeNamedClass = cls.classForName( name );\n\n\t\t\t// if there are no local config params, register an implicit TypeDefinition for this custom type .\n\t\t\t//  later uses may find it and re-use its cacheable reference...\n\t\t\tif ( CollectionHelper.isEmpty( localTypeParams ) ) {\n\t\t\t\tfinal TypeDefinition implicitDefinition = new TypeDefinition(\n\t\t\t\t\t\tname,\n\t\t\t\t\t\ttypeNamedClass,\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\tnull\n\t\t\t\t);\n\t\t\t\tcontext.getTypeDefinitionRegistry().register( implicitDefinition );\n\t\t\t\treturn implicitDefinition.resolve(\n\t\t\t\t\t\tlocalTypeParams,\n\t\t\t\t\t\texplicitMutabilityPlanAccess != null\n\t\t\t\t\t\t\t\t? explicitMutabilityPlanAccess.apply( typeConfiguration )\n\t\t\t\t\t\t\t\t: null,\n\t\t\t\t\t\tcontext,\n\t\t\t\t\t\tstdIndicators\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn TypeDefinition.createLocalResolution( name, typeNamedClass, localTypeParams, context );\n\t\t}\n\t\tcatch (ClassLoadingException e) {\n\t\t\t// allow the exception below to trigger\n\t\t\tlog.debugf( \"Could not resolve type-name [%s] as Java type : %s\", name, e );\n\t\t}\n\n\t\tthrow new MappingException( \"Could not resolve named type : \" + name );\n\t}\n\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// SqlTypeDescriptorIndicators\n\n\t@Override\n\tpublic EnumType getEnumeratedType() {\n\t\treturn getEnumerationStyle();\n\t}\n\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForBoolean() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForBoolean() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForDuration() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForDuration() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForUuid() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForUuid() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForInstant() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForInstant() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForArray() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForArray() );\n\t}\n\n\t@Override\n\tpublic int resolveJdbcTypeCode(int jdbcTypeCode) {\n\t\treturn aggregateColumn == null\n\t\t\t\t? jdbcTypeCode\n\t\t\t\t: getDialect().getAggregateSupport()\n\t\t\t\t.aggregateComponentSqlTypeCode( aggregateColumn.getSqlTypeCode( getMetadata() ), jdbcTypeCode );\n\t}\n\n\t@Override\n\tpublic TimeZoneStorageStrategy getDefaultTimeZoneStorageStrategy() {\n\t\treturn timeZoneStorageStrategy( timeZoneStorageType, getBuildingContext() );\n\t}\n\n\t@Internal\n\tpublic static TimeZoneStorageStrategy timeZoneStorageStrategy(\n\t\t\tTimeZoneStorageType timeZoneStorageType,\n\t\t\tMetadataBuildingContext buildingContext) {\n\t\tif ( timeZoneStorageType != null ) {\n\t\t\tswitch ( timeZoneStorageType ) {\n\t\t\t\tcase COLUMN:\n\t\t\t\t\treturn TimeZoneStorageStrategy.COLUMN;\n\t\t\t\tcase NATIVE:\n\t\t\t\t\treturn TimeZoneStorageStrategy.NATIVE;\n\t\t\t\tcase NORMALIZE:\n\t\t\t\t\treturn TimeZoneStorageStrategy.NORMALIZE;\n\t\t\t\tcase NORMALIZE_UTC:\n\t\t\t\t\treturn TimeZoneStorageStrategy.NORMALIZE_UTC;\n\t\t\t}\n\t\t}\n\t\treturn buildingContext.getBuildingOptions().getDefaultTimeZoneStorage();\n\t}\n\n\tpublic void setExplicitTypeParams(Map<String,String> explicitLocalTypeParams) {\n\t\tthis.explicitLocalTypeParams = explicitLocalTypeParams;\n\t}\n\n\tpublic void setExplicitTypeName(String typeName) {\n\t\tthis.explicitTypeName = typeName;\n\t}\n\n\tpublic void setTypeName(String typeName) {\n\t\tif ( StringHelper.isNotEmpty( typeName ) ) {\n\t\t\tif ( typeName.startsWith( ConverterDescriptor.TYPE_NAME_PREFIX ) ) {\n\t\t\t\tfinal String converterClassName = typeName.substring( ConverterDescriptor.TYPE_NAME_PREFIX.length() );\n\t\t\t\tfinal ClassLoaderService cls = getServiceRegistry().requireService( ClassLoaderService.class );\n\t\t\t\ttry {\n\t\t\t\t\tfinal Class<AttributeConverter<?,?>> converterClass = cls.classForName( converterClassName );\n\t\t\t\t\tsetAttributeConverterDescriptor( new ClassBasedConverterDescriptor(\n\t\t\t\t\t\t\tconverterClass,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t\t) );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tlog.logBadHbmAttributeConverterType( typeName, e.getMessage() );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsetExplicitTypeName( typeName );\n\t\t\t}\n\t\t}\n\n\t\tsuper.setTypeName( typeName );\n\t}\n\n\tprivate static int COUNTER;\n\n\tpublic void setExplicitCustomType(Class<? extends UserType<?>> explicitCustomType) {\n\t\tif ( explicitCustomType != null ) {\n\t\t\tif ( resolution != null ) {\n\t\t\t\tthrow new UnsupportedOperationException( \"Unsupported attempt to set an explicit-custom-type when value is already resolved\" );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresolution = new UserTypeResolution<>(\n\t\t\t\t\t\tnew CustomType<>(\n\t\t\t\t\t\t\t\tgetConfiguredUserTypeBean( explicitCustomType, getCustomTypeProperties() ),\n\t\t\t\t\t\t\t\tgetTypeConfiguration()\n\t\t\t\t\t\t),\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\tgetCustomTypeProperties()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate Properties getCustomTypeProperties() {\n\t\tfinal Properties properties = new Properties();\n\t\tif ( isNotEmpty( getTypeParameters() ) ) {\n\t\t\tproperties.putAll( getTypeParameters() );\n\t\t}\n\t\tif ( isNotEmpty( explicitLocalTypeParams ) ) {\n\t\t\tproperties.putAll( explicitLocalTypeParams );\n\t\t}\n\t\treturn properties;\n\t}\n\n\tprivate UserType<?> getConfiguredUserTypeBean(Class<? extends UserType<?>> explicitCustomType, Properties properties) {\n\t\tfinal UserType<?> typeInstance =\n\t\t\t\t!getBuildingContext().getBuildingOptions().isAllowExtensionsInCdi()\n\t\t\t\t\t\t? FallbackBeanInstanceProducer.INSTANCE.produceBeanInstance( explicitCustomType )\n\t\t\t\t\t\t: getUserTypeBean( explicitCustomType, properties ).getBeanInstance();\n\n\t\tif ( typeInstance instanceof TypeConfigurationAware ) {\n\t\t\tfinal TypeConfigurationAware configurationAware = (TypeConfigurationAware) typeInstance;\n\t\t\tconfigurationAware.setTypeConfiguration( getTypeConfiguration() );\n\t\t}\n\n\t\tif ( typeInstance instanceof DynamicParameterizedType ) {\n\t\t\tif ( parseBoolean( properties.getProperty( DynamicParameterizedType.IS_DYNAMIC ) ) ) {\n\t\t\t\tif ( properties.get( DynamicParameterizedType.PARAMETER_TYPE ) == null ) {\n\t\t\t\t\tproperties.put( DynamicParameterizedType.PARAMETER_TYPE, makeParameterImpl() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tinjectParameters( typeInstance, properties);\n\t\t// envers - grr\n\t\tsetTypeParameters( properties );\n\n\t\treturn typeInstance;\n\t}\n\n\tprivate <T> ManagedBean<T> getUserTypeBean(Class<T> explicitCustomType, Properties properties) {\n\t\tfinal BeanInstanceProducer producer = getBuildingContext().getBootstrapContext().getCustomTypeProducer();\n\t\tfinal ManagedBeanRegistry registry = getServiceRegistry().requireService( ManagedBeanRegistry.class );\n\t\tif ( isNotEmpty( properties ) ) {\n\t\t\tfinal String name = explicitCustomType.getName() + COUNTER++;\n\t\t\treturn registry.getBean( name, explicitCustomType, producer );\n\t\t}\n\t\telse {\n\t\t\treturn registry.getBean( explicitCustomType, producer );\n\t\t}\n\t}\n\n\tpublic void setTemporalPrecision(TemporalType temporalPrecision) {\n\t\tthis.temporalPrecision = temporalPrecision;\n\t}\n\n\t@Override\n\tpublic TemporalType getTemporalPrecision() {\n\t\treturn temporalPrecision;\n\t}\n\n\t@Override\n\tpublic boolean isPreferJavaTimeJdbcTypesEnabled() {\n\t\treturn getBuildingContext().isPreferJavaTimeJdbcTypesEnabled();\n\t}\n\n\t@Override\n\tpublic boolean isPreferNativeEnumTypesEnabled() {\n\t\treturn getBuildingContext().isPreferNativeEnumTypesEnabled();\n\t}\n\n\t@Override\n\tpublic Object accept(ValueVisitor visitor) {\n\t\treturn visitor.accept(this);\n\t}\n\n\t@Internal\n\tpublic boolean isDisallowedWrapperArray() {\n\t\treturn getBuildingContext().getBuildingOptions().getWrapperArrayHandling() == WrapperArrayHandling.DISALLOW\n\t\t\t&& !isLob()\n\t\t\t&& ( explicitJavaTypeAccess == null || explicitJavaTypeAccess.apply( getTypeConfiguration() ) == null )\n\t\t\t&& isWrapperByteOrCharacterArray();\n\t}\n\n\tprivate boolean isWrapperByteOrCharacterArray() {\n\t\tfinal Class<?> javaTypeClass = getResolution().getDomainJavaType().getJavaTypeClass();\n\t\treturn javaTypeClass == Byte[].class || javaTypeClass == Character[].class;\n\t}\n\n\t@Incubating\n\tpublic void setExplicitJdbcTypeCode(Integer jdbcTypeCode) {\n\t\tthis.jdbcTypeCode = jdbcTypeCode;\n\t}\n\n\t@Override\n\tpublic Integer getExplicitJdbcTypeCode() {\n\t\treturn jdbcTypeCode == null ? getPreferredSqlTypeCodeForArray() : jdbcTypeCode;\n\t}\n\n\t/**\n\t * Resolved form of {@link BasicValue} as part of interpreting the\n\t * boot-time model into the run-time model\n\t */\n\tpublic interface Resolution<J> {\n\t\t/**\n\t\t * The BasicType resolved using the pre-6.0 rules.  This is temporarily\n\t\t * needed because of the split in extracting / binding\n\t\t */\n\t\tBasicType<J> getLegacyResolvedBasicType();\n\n\t\t/**\n\t\t * Get the collection of type-parameters collected both locally as well\n\t\t * as from the applied type-def, if one\n\t\t */\n\t\tdefault Properties getCombinedTypeParameters() {\n\t\t\treturn null;\n\t\t}\n\n\t\tJdbcMapping getJdbcMapping();\n\n\t\t/**\n\t\t * The JavaType for the value as part of the domain model\n\t\t */\n\t\tJavaType<J> getDomainJavaType();\n\n\t\t/**\n\t\t * The JavaType for the relational value as part of\n\t\t * the relational model (its JDBC representation)\n\t\t */\n\t\tJavaType<?> getRelationalJavaType();\n\n\t\t/**\n\t\t * The JavaType for the relational value as part of\n\t\t * the relational model (its JDBC representation)\n\t\t */\n\t\tJdbcType getJdbcType();\n\n\t\t/**\n\t\t * Converter, if any, to convert values between the\n\t\t * domain and relational JavaType representations\n\t\t */\n\t\tBasicValueConverter<J,?> getValueConverter();\n\n\t\t/**\n\t\t * The resolved MutabilityPlan\n\t\t */\n\t\tMutabilityPlan<J> getMutabilityPlan();\n\n\t\tdefault void updateResolution(BasicType<?> type) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/mapping/BasicValue.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.mapping;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\n\nimport org.hibernate.Incubating;\nimport org.hibernate.Internal;\nimport org.hibernate.MappingException;\nimport org.hibernate.TimeZoneStorageStrategy;\nimport org.hibernate.annotations.SoftDelete;\nimport org.hibernate.annotations.SoftDeleteType;\nimport org.hibernate.annotations.TimeZoneStorageType;\nimport org.hibernate.boot.model.TypeDefinition;\nimport org.hibernate.boot.model.convert.internal.AutoApplicableConverterDescriptorBypassedImpl;\nimport org.hibernate.boot.model.convert.internal.ClassBasedConverterDescriptor;\nimport org.hibernate.boot.model.convert.internal.InstanceBasedConverterDescriptor;\nimport org.hibernate.boot.model.convert.spi.AutoApplicableConverterDescriptor;\nimport org.hibernate.boot.model.convert.spi.ConverterDescriptor;\nimport org.hibernate.boot.model.convert.spi.JpaAttributeConverterCreationContext;\nimport org.hibernate.boot.model.process.internal.InferredBasicValueResolution;\nimport org.hibernate.boot.model.process.internal.InferredBasicValueResolver;\nimport org.hibernate.boot.model.process.internal.NamedBasicTypeResolution;\nimport org.hibernate.boot.model.process.internal.NamedConverterResolution;\nimport org.hibernate.boot.model.process.internal.UserTypeResolution;\nimport org.hibernate.boot.model.process.internal.VersionResolution;\nimport org.hibernate.boot.registry.StandardServiceRegistry;\nimport org.hibernate.boot.registry.classloading.spi.ClassLoaderService;\nimport org.hibernate.boot.registry.classloading.spi.ClassLoadingException;\nimport org.hibernate.boot.spi.MetadataBuildingContext;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.Size;\nimport org.hibernate.internal.CoreLogging;\nimport org.hibernate.internal.CoreMessageLogger;\nimport org.hibernate.internal.util.StringHelper;\nimport org.hibernate.internal.util.collections.CollectionHelper;\nimport org.hibernate.metamodel.mapping.JdbcMapping;\nimport org.hibernate.metamodel.mapping.SelectablePath;\nimport org.hibernate.resource.beans.internal.FallbackBeanInstanceProducer;\nimport org.hibernate.resource.beans.spi.BeanInstanceProducer;\nimport org.hibernate.resource.beans.spi.ManagedBean;\nimport org.hibernate.resource.beans.spi.ManagedBeanRegistry;\nimport org.hibernate.tool.schema.extract.spi.ColumnTypeInformation;\nimport org.hibernate.type.BasicType;\nimport org.hibernate.type.CustomType;\nimport org.hibernate.type.NumericBooleanConverter;\nimport org.hibernate.type.SqlTypes;\nimport org.hibernate.type.TrueFalseConverter;\nimport org.hibernate.type.Type;\nimport org.hibernate.type.WrapperArrayHandling;\nimport org.hibernate.type.descriptor.converter.spi.BasicValueConverter;\nimport org.hibernate.type.descriptor.converter.spi.JpaAttributeConverter;\nimport org.hibernate.type.descriptor.java.BasicJavaType;\nimport org.hibernate.type.descriptor.java.BasicPluralJavaType;\nimport org.hibernate.type.descriptor.java.JavaType;\nimport org.hibernate.type.descriptor.java.MutabilityPlan;\nimport org.hibernate.type.descriptor.java.spi.JavaTypeRegistry;\nimport org.hibernate.type.descriptor.java.spi.JsonJavaType;\nimport org.hibernate.type.descriptor.java.spi.RegistryHelper;\nimport org.hibernate.type.descriptor.java.spi.XmlJavaType;\nimport org.hibernate.type.descriptor.jdbc.BooleanJdbcType;\nimport org.hibernate.type.descriptor.jdbc.JdbcType;\nimport org.hibernate.type.descriptor.jdbc.JdbcTypeIndicators;\nimport org.hibernate.type.internal.BasicTypeImpl;\nimport org.hibernate.type.spi.TypeConfiguration;\nimport org.hibernate.type.spi.TypeConfigurationAware;\nimport org.hibernate.usertype.DynamicParameterizedType;\nimport org.hibernate.usertype.UserType;\n\nimport com.fasterxml.classmate.ResolvedType;\nimport jakarta.persistence.AttributeConverter;\nimport jakarta.persistence.EnumType;\nimport jakarta.persistence.TemporalType;\n\nimport static java.lang.Boolean.parseBoolean;\nimport static org.hibernate.internal.util.ReflectHelper.reflectedPropertyType;\nimport static org.hibernate.internal.util.collections.CollectionHelper.isNotEmpty;\nimport static org.hibernate.mapping.MappingHelper.injectParameters;\n\n/**\n * @author Steve Ebersole\n */\npublic class BasicValue extends SimpleValue implements JdbcTypeIndicators, Resolvable, JpaAttributeConverterCreationContext {\n\tprivate static final CoreMessageLogger log = CoreLogging.messageLogger( BasicValue.class );\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// incoming \"configuration\" values\n\n\tprivate String explicitTypeName;\n\tprivate Map<String,String> explicitLocalTypeParams;\n\n\tprivate Function<TypeConfiguration, BasicJavaType> explicitJavaTypeAccess;\n\tprivate Function<TypeConfiguration, JdbcType> explicitJdbcTypeAccess;\n\tprivate Function<TypeConfiguration, MutabilityPlan> explicitMutabilityPlanAccess;\n\tprivate Function<TypeConfiguration, java.lang.reflect.Type> implicitJavaTypeAccess;\n\n\tprivate EnumType enumerationStyle;\n\t@SuppressWarnings(\"deprecation\")\n\tprivate TemporalType temporalPrecision;\n\tprivate TimeZoneStorageType timeZoneStorageType;\n\tprivate boolean isSoftDelete;\n\tprivate SoftDeleteType softDeleteStrategy;\n\n\tprivate java.lang.reflect.Type resolvedJavaType;\n\n\tprivate String ownerName;\n\tprivate String propertyName;\n\tprivate AggregateColumn aggregateColumn;\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// Resolved state - available after `#resolve`\n\tprivate Resolution<?> resolution;\n\tprivate Integer jdbcTypeCode;\n\n\n\tpublic BasicValue(MetadataBuildingContext buildingContext) {\n\t\tthis( buildingContext, null );\n\t}\n\n\tpublic BasicValue(MetadataBuildingContext buildingContext, Table table) {\n\t\tsuper( buildingContext, table );\n\t\tbuildingContext.getMetadataCollector().registerValueMappingResolver( this::resolve );\n\t}\n\n\tpublic BasicValue(BasicValue original) {\n\t\tsuper( original );\n\t\tthis.explicitTypeName = original.explicitTypeName;\n\t\tthis.explicitLocalTypeParams = original.explicitLocalTypeParams == null\n\t\t\t\t? null\n\t\t\t\t: new HashMap<>(original.explicitLocalTypeParams);\n\t\tthis.explicitJavaTypeAccess = original.explicitJavaTypeAccess;\n\t\tthis.explicitJdbcTypeAccess = original.explicitJdbcTypeAccess;\n\t\tthis.explicitMutabilityPlanAccess = original.explicitMutabilityPlanAccess;\n\t\tthis.implicitJavaTypeAccess = original.implicitJavaTypeAccess;\n\t\tthis.enumerationStyle = original.enumerationStyle;\n\t\tthis.temporalPrecision = original.temporalPrecision;\n\t\tthis.timeZoneStorageType = original.timeZoneStorageType;\n\t\tthis.resolvedJavaType = original.resolvedJavaType;\n\t\tthis.ownerName = original.ownerName;\n\t\tthis.propertyName = original.propertyName;\n\t}\n\n\t@Override\n\tpublic BasicValue copy() {\n\t\treturn new BasicValue( this );\n\t}\n\n\tpublic boolean isSoftDelete() {\n\t\treturn isSoftDelete;\n\t}\n\n\tpublic SoftDeleteType getSoftDeleteStrategy() {\n\t\treturn softDeleteStrategy;\n\t}\n\n\tpublic void makeSoftDelete(SoftDeleteType strategy) {\n\t\tisSoftDelete = true;\n\t\tsoftDeleteStrategy = strategy;\n\t}\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// Setters - in preparation of resolution\n\n\t@Override\n\tpublic void setTypeUsingReflection(String className, String propertyName) throws MappingException {\n\t\tif ( resolution != null ) {\n\t\t\tthrow new IllegalStateException( \"BasicValue already resolved\" );\n\t\t}\n\n\t\tthis.ownerName = className;\n\t\tthis.propertyName = propertyName;\n\n\t\tsuper.setTypeUsingReflection( className, propertyName );\n\t}\n\n\tpublic void setEnumerationStyle(EnumType enumerationStyle) {\n\t\tthis.enumerationStyle = enumerationStyle;\n\t}\n\n\tpublic EnumType getEnumerationStyle() {\n\t\treturn enumerationStyle;\n\t}\n\n\tpublic TimeZoneStorageType getTimeZoneStorageType() {\n\t\treturn timeZoneStorageType;\n\t}\n\n\tpublic void setTimeZoneStorageType(TimeZoneStorageType timeZoneStorageType) {\n\t\tthis.timeZoneStorageType = timeZoneStorageType;\n\t}\n\n\tpublic void setJpaAttributeConverterDescriptor(ConverterDescriptor descriptor) {\n\t\tsetAttributeConverterDescriptor( descriptor );\n\n\t\tsuper.setJpaAttributeConverterDescriptor( descriptor );\n\t}\n\n\t@SuppressWarnings(\"rawtypes\")\n\tpublic void setExplicitJavaTypeAccess(Function<TypeConfiguration, BasicJavaType> explicitJavaTypeAccess) {\n\t\tthis.explicitJavaTypeAccess = explicitJavaTypeAccess;\n\t}\n\n\tpublic void setExplicitJdbcTypeAccess(Function<TypeConfiguration, JdbcType> jdbcTypeAccess) {\n\t\tthis.explicitJdbcTypeAccess = jdbcTypeAccess;\n\t}\n\n\tpublic void setExplicitMutabilityPlanAccess(Function<TypeConfiguration, MutabilityPlan> explicitMutabilityPlanAccess) {\n\t\tthis.explicitMutabilityPlanAccess = explicitMutabilityPlanAccess;\n\t}\n\n\tpublic void setImplicitJavaTypeAccess(Function<TypeConfiguration, java.lang.reflect.Type> implicitJavaTypeAccess) {\n\t\tthis.implicitJavaTypeAccess = implicitJavaTypeAccess;\n\t}\n\n\tpublic Selectable getColumn() {\n\t\tif ( getColumnSpan() == 0 ) {\n\t\t\treturn null;\n\t\t}\n\t\treturn getColumn( 0 );\n\t}\n\n\tpublic java.lang.reflect.Type getResolvedJavaType() {\n\t\treturn resolvedJavaType;\n\t}\n\n\t@Override\n\tpublic long getColumnLength() {\n\t\tfinal Selectable selectable = getColumn();\n\t\tif ( selectable instanceof Column column ) {\n\t\t\tfinal Long length = column.getLength();\n\t\t\treturn length == null ? NO_COLUMN_LENGTH : length;\n\t\t}\n\t\telse {\n\t\t\treturn NO_COLUMN_LENGTH;\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getColumnPrecision() {\n\t\tfinal Selectable selectable = getColumn();\n\t\tif ( selectable instanceof Column column ) {\n\t\t\tfinal Integer temporalPrecision = column.getTemporalPrecision();\n\t\t\tif ( temporalPrecision != null ) {\n\t\t\t\treturn temporalPrecision;\n\t\t\t}\n\t\t\tfinal Integer precision = column.getPrecision();\n\t\t\treturn precision == null ? NO_COLUMN_PRECISION : precision;\n\t\t}\n\t\telse {\n\t\t\treturn NO_COLUMN_PRECISION;\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getColumnScale() {\n\t\tfinal Selectable selectable = getColumn();\n\t\tif ( selectable instanceof Column column ) {\n\t\t\tfinal Integer scale = column.getScale();\n\t\t\treturn scale == null ? NO_COLUMN_SCALE : scale;\n\t\t}\n\t\telse {\n\t\t\treturn NO_COLUMN_SCALE;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void addColumn(Column incomingColumn) {\n\t\tsuper.addColumn( incomingColumn );\n\n\t\tcheckSelectable( incomingColumn );\n\t}\n\n\t@Override\n\tpublic void copyTypeFrom(SimpleValue sourceValue) {\n\t\tsuper.copyTypeFrom( sourceValue );\n\t\tif ( sourceValue instanceof BasicValue basicValue ) {\n\t\t\tresolution = basicValue.resolution;\n\t\t\timplicitJavaTypeAccess =\n\t\t\t\t\ttypeConfiguration -> basicValue.implicitJavaTypeAccess.apply( typeConfiguration );\n\t\t}\n\t}\n\n\tprivate void checkSelectable(Selectable incomingColumn) {\n\t\tif ( incomingColumn == null ) {\n\t\t\tthrow new IllegalArgumentException( \"Incoming column was null\" );\n\t\t}\n\n\t\tfinal Selectable column = getColumn();\n\t\tif ( column == incomingColumn || column.getText().equals( incomingColumn.getText() ) ) {\n\t\t\tlog.debugf( \"Skipping column re-registration: %s.%s\", getTable().getName(), column.getText() );\n\t\t}\n//\t\telse {\n//\t\t\tthrow new IllegalStateException(\n//\t\t\t\t\t\"BasicValue [\" + ownerName + \".\" + propertyName +\n//\t\t\t\t\t\t\t\"] already had column associated: `\" + column.getText() +\n//\t\t\t\t\t\t\t\"` -> `\" + incomingColumn.getText() + \"`\"\n//\t\t\t);\n//\t\t}\n\t}\n\n\t@Override\n\tpublic void addColumn(Column incomingColumn, boolean isInsertable, boolean isUpdatable) {\n\t\tsuper.addColumn( incomingColumn, isInsertable, isUpdatable );\n\t\tcheckSelectable( incomingColumn );\n\t}\n\n\t@Override\n\tpublic void addFormula(Formula formula) {\n\t\tsuper.addFormula( formula );\n\n\t\tcheckSelectable( formula );\n\t}\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// Resolution\n\n\t@Override\n\tpublic Type getType() throws MappingException {\n\t\tresolve();\n\t\tassert getResolution() != null;\n\n\t\treturn getResolution().getLegacyResolvedBasicType();\n\t}\n\n\tpublic Resolution<?> getResolution() {\n\t\treturn resolution;\n\t}\n\n\t@Override\n\tpublic boolean resolve(MetadataBuildingContext buildingContext) {\n\t\tresolve();\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic Resolution<?> resolve() {\n\t\tif ( resolution != null ) {\n\t\t\treturn resolution;\n\t\t}\n\n\t\tresolution = buildResolution();\n\n\t\tif ( resolution == null ) {\n\t\t\tthrow new IllegalStateException( \"Unable to resolve BasicValue : \" + this );\n\t\t}\n\n\t\tfinal Selectable selectable = getColumn();\n\t\tfinal Size size;\n\t\tif ( selectable instanceof Column column ) {\n\t\t\tresolveColumn( column, getDialect() );\n\t\t\tsize = column.calculateColumnSize( getDialect(), getBuildingContext().getMetadataCollector() );\n\t\t}\n\t\telse {\n\t\t\tsize = Size.nil();\n\t\t}\n\n\t\tresolution.getJdbcType().addAuxiliaryDatabaseObjects(\n\t\t\t\tresolution.getRelationalJavaType(),\n\t\t\t\tresolution.getValueConverter(),\n\t\t\t\tsize,\n\t\t\t\tgetBuildingContext().getMetadataCollector().getDatabase(),\n\t\t\t\tthis\n\t\t);\n\n\t\treturn resolution;\n\t}\n\n\t@Override\n\tpublic String getExtraCreateTableInfo() {\n\t\treturn resolution.getJdbcType()\n\t\t\t\t.getExtraCreateTableInfo(\n\t\t\t\t\t\tresolution.getRelationalJavaType(),\n\t\t\t\t\t\tgetColumn().getText(),\n\t\t\t\t\t\tgetTable().getName(),\n\t\t\t\t\t\tgetBuildingContext().getMetadataCollector().getDatabase()\n\t\t\t\t);\n\t}\n\n\t@Override\n\tpublic Dialect getDialect() {\n\t\treturn getMetadata().getDatabase().getDialect();\n\t}\n\n\tprivate void resolveColumn(Column column, Dialect dialect) {\n\n\t\tif ( column.getSqlTypeCode() == null ) {\n\t\t\tcolumn.setSqlTypeCode( resolution.getJdbcType().getDdlTypeCode() );\n\t\t}\n\n//\t\tfinal String declaration = resolution.getLegacyResolvedBasicType().getSpecializedTypeDeclaration( dialect );\n//\t\tif ( declaration != null ) {\n//\t\t\tcolumn.setSpecializedTypeDeclaration( declaration );\n//\t\t}\n\n\t\tif ( dialect.supportsColumnCheck() ) {\n\t\t\tfinal String checkCondition = resolution.getLegacyResolvedBasicType()\n\t\t\t\t\t.getCheckCondition( column.getQuotedName( dialect ), dialect );\n\t\t\tif ( checkCondition != null ) {\n\t\t\t\tcolumn.addCheckConstraint( new CheckConstraint( checkCondition ) );\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic AggregateColumn getAggregateColumn() {\n\t\treturn aggregateColumn;\n\t}\n\n\tpublic void setAggregateColumn(AggregateColumn aggregateColumn) {\n\t\tthis.aggregateColumn = aggregateColumn;\n\t}\n\n\tpublic SelectablePath createSelectablePath(String selectableName) {\n\t\tif ( aggregateColumn != null ) {\n\t\t\treturn aggregateColumn.getSelectablePath().append( selectableName );\n\t\t}\n\t\treturn new SelectablePath( selectableName );\n\t}\n\n\tprotected Resolution<?> buildResolution() {\n\t\tfinal Properties typeParameters = getTypeParameters();\n\t\tif ( typeParameters != null\n\t\t\t\t&& parseBoolean( typeParameters.getProperty(DynamicParameterizedType.IS_DYNAMIC) )\n\t\t\t\t&& typeParameters.get(DynamicParameterizedType.PARAMETER_TYPE) == null ) {\n\t\t\tcreateParameterImpl();\n\t\t}\n\n\t\tif ( explicitTypeName != null ) {\n\t\t\treturn interpretExplicitlyNamedType(\n\t\t\t\t\texplicitTypeName,\n\t\t\t\t\texplicitJavaTypeAccess,\n\t\t\t\t\texplicitJdbcTypeAccess,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tgetAttributeConverterDescriptor(),\n\t\t\t\t\ttypeParameters,\n\t\t\t\t\tthis::setTypeParameters,\n\t\t\t\t\tthis,\n\t\t\t\t\tgetBuildingContext()\n\t\t\t);\n\t\t}\n\t\telse if ( isVersion() ) {\n\t\t\treturn VersionResolution.from( implicitJavaTypeAccess, timeZoneStorageType, getBuildingContext() );\n\t\t}\n\t\telse {\n\t\t\t// determine JavaType if we can\n\t\t\tfinal BasicJavaType<?> explicitJavaType = getExplicitJavaType();\n\t\t\tfinal JavaType<?> javaType = determineJavaType( explicitJavaType );\n\t\t\tfinal ConverterDescriptor converterDescriptor = getConverterDescriptor( javaType );\n\t\t\treturn converterDescriptor != null\n\t\t\t\t\t? converterResolution( javaType, converterDescriptor )\n\t\t\t\t\t: resolution( explicitJavaType, javaType );\n\t\t}\n\t}\n\n\tprivate BasicJavaType<?> getExplicitJavaType() {\n\t\treturn explicitJavaTypeAccess == null ? null\n\t\t\t\t: explicitJavaTypeAccess.apply( getTypeConfiguration() );\n\t}\n\n\tprivate ConverterDescriptor getConverterDescriptor(JavaType<?> javaType) {\n\t\tfinal ConverterDescriptor converterDescriptor = getAttributeConverterDescriptor();\n\t\tif ( isSoftDelete() ) {\n\t\t\tassert converterDescriptor != null;\n\t\t\tfinal ConverterDescriptor softDeleteConverterDescriptor =\n\t\t\t\t\tgetSoftDeleteConverterDescriptor( converterDescriptor, javaType);\n\t\t\treturn getSoftDeleteStrategy() == SoftDeleteType.ACTIVE\n\t\t\t\t\t? new ReversedConverterDescriptor<>( softDeleteConverterDescriptor )\n\t\t\t\t\t: softDeleteConverterDescriptor;\n\t\t}\n\t\telse {\n\t\t\treturn converterDescriptor;\n\t\t}\n\t}\n\n\tprivate ConverterDescriptor getSoftDeleteConverterDescriptor(\n\t\t\tConverterDescriptor attributeConverterDescriptor, JavaType<?> javaType) {\n\t\tfinal boolean conversionWasUnspecified =\n\t\t\t\tSoftDelete.UnspecifiedConversion.class.equals( attributeConverterDescriptor.getAttributeConverterClass() );\n\t\tif ( conversionWasUnspecified ) {\n\t\t\tfinal JdbcType jdbcType = BooleanJdbcType.INSTANCE.resolveIndicatedType( this, javaType);\n\t\t\tif ( jdbcType.isNumber() ) {\n\t\t\t\treturn new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\tNumericBooleanConverter.INSTANCE,\n\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t);\n\t\t\t}\n\t\t\telse if ( jdbcType.isString() ) {\n\t\t\t\t// here we pick 'T' / 'F' storage, though 'Y' / 'N' is equally valid - its 50/50\n\t\t\t\treturn new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\tTrueFalseConverter.INSTANCE,\n\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// should indicate BIT or BOOLEAN == no conversion needed\n\t\t\t\t//\t\t- we still create the converter to properly set up JDBC type, etc\n\t\t\t\treturn new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\tPassThruSoftDeleteConverter.INSTANCE,\n\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn attributeConverterDescriptor;\n\t\t}\n\t}\n\n\tprivate static class ReversedConverterDescriptor<R> implements ConverterDescriptor {\n\t\tprivate final ConverterDescriptor underlyingDescriptor;\n\n\t\tpublic ReversedConverterDescriptor(ConverterDescriptor underlyingDescriptor) {\n\t\t\tthis.underlyingDescriptor = underlyingDescriptor;\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<? extends AttributeConverter<Boolean,R>> getAttributeConverterClass() {\n\t\t\t//noinspection unchecked\n\t\t\treturn (Class<? extends AttributeConverter<Boolean, R>>) getClass();\n\t\t}\n\n\t\t@Override\n\t\tpublic ResolvedType getDomainValueResolvedType() {\n\t\t\treturn underlyingDescriptor.getDomainValueResolvedType();\n\t\t}\n\n\t\t@Override\n\t\tpublic ResolvedType getRelationalValueResolvedType() {\n\t\t\treturn underlyingDescriptor.getRelationalValueResolvedType();\n\t\t}\n\n\t\t@Override\n\t\tpublic AutoApplicableConverterDescriptor getAutoApplyDescriptor() {\n\t\t\treturn AutoApplicableConverterDescriptorBypassedImpl.INSTANCE;\n\t\t}\n\n\t\t@Override\n\t\tpublic JpaAttributeConverter<Boolean,R> createJpaAttributeConverter(JpaAttributeConverterCreationContext context) {\n\t\t\t//noinspection unchecked\n\t\t\treturn new ReversedJpaAttributeConverter<>(\n\t\t\t\t\t(JpaAttributeConverter<Boolean, R>) underlyingDescriptor.createJpaAttributeConverter( context ),\n\t\t\t\t\tcontext.getJavaTypeRegistry().getDescriptor( ReversedJpaAttributeConverter.class )\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate static class ReversedJpaAttributeConverter<R, B extends AttributeConverter<Boolean, R>>\n\t\t\timplements JpaAttributeConverter<Boolean,R>, AttributeConverter<Boolean,R>, ManagedBean<B> {\n\t\tprivate final JpaAttributeConverter<Boolean,R> underlyingJpaConverter;\n\t\tprivate final JavaType<ReversedJpaAttributeConverter<R,B>> converterJavaType;\n\n\t\tpublic ReversedJpaAttributeConverter(\n\t\t\t\tJpaAttributeConverter<Boolean, R> underlyingJpaConverter,\n\t\t\t\tJavaType<ReversedJpaAttributeConverter<R,B>> converterJavaType) {\n\t\t\tthis.underlyingJpaConverter = underlyingJpaConverter;\n\t\t\tthis.converterJavaType = converterJavaType;\n\t\t}\n\n\t\t@Override\n\t\tpublic Boolean toDomainValue(R relationalValue) {\n\t\t\treturn !underlyingJpaConverter.toDomainValue( relationalValue );\n\t\t}\n\n\t\t@Override\n\t\tpublic R toRelationalValue(Boolean domainValue) {\n\t\t\treturn underlyingJpaConverter.toRelationalValue( domainValue != null ? !domainValue : null );\n\t\t}\n\n\t\t@Override\n\t\tpublic Boolean convertToEntityAttribute(R relationalValue) {\n\t\t\treturn toDomainValue( relationalValue );\n\t\t}\n\n\t\t@Override\n\t\tpublic R convertToDatabaseColumn(Boolean domainValue) {\n\t\t\treturn toRelationalValue( domainValue );\n\t\t}\n\n\t\t@Override\n\t\tpublic JavaType<Boolean> getDomainJavaType() {\n\t\t\treturn underlyingJpaConverter.getDomainJavaType();\n\t\t}\n\n\t\t@Override\n\t\tpublic JavaType<R> getRelationalJavaType() {\n\t\t\treturn underlyingJpaConverter.getRelationalJavaType();\n\t\t}\n\n\t\t@Override\n\t\tpublic JavaType<? extends AttributeConverter<Boolean, R>> getConverterJavaType() {\n\t\t\treturn converterJavaType;\n\t\t}\n\n\t\t@Override\n\t\tpublic ManagedBean<? extends AttributeConverter<Boolean, R>> getConverterBean() {\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<B> getBeanClass() {\n\t\t\t//noinspection unchecked\n\t\t\treturn (Class<B>) getClass();\n\t\t}\n\n\t\t@Override\n\t\tpublic B getBeanInstance() {\n\t\t\t//noinspection unchecked\n\t\t\treturn (B) this;\n\t\t}\n\t}\n\n\tprivate static class PassThruSoftDeleteConverter implements AttributeConverter<Boolean,Boolean> {\n\t\tprivate static final PassThruSoftDeleteConverter INSTANCE = new PassThruSoftDeleteConverter();\n\n\t\t@Override\n\t\tpublic Boolean convertToDatabaseColumn(Boolean domainValue) {\n\t\t\treturn domainValue;\n\t\t}\n\n\t\t@Override\n\t\tpublic Boolean convertToEntityAttribute(Boolean relationalValue) {\n\t\t\treturn relationalValue;\n\t\t}\n\t}\n\n\tprivate Resolution<?> resolution(BasicJavaType explicitJavaType, JavaType<?> javaType) {\n\t\tfinal JavaType<?> basicJavaType;\n\t\tfinal JdbcType jdbcType;\n\t\tif ( explicitJdbcTypeAccess != null ) {\n\t\t\tfinal TypeConfiguration typeConfiguration = getTypeConfiguration();\n\t\t\tjdbcType = explicitJdbcTypeAccess.apply( typeConfiguration );\n\t\t\tbasicJavaType = javaType == null && jdbcType != null\n\t\t\t\t\t? jdbcType.getJdbcRecommendedJavaTypeMapping(null, null, typeConfiguration)\n\t\t\t\t\t: javaType;\n\t\t}\n\t\telse {\n\t\t\tjdbcType = null;\n\t\t\tbasicJavaType = javaType;\n\t\t}\n\t\tif ( basicJavaType == null ) {\n\t\t\tthrow new MappingException( \"Unable to determine JavaType to use : \" + this );\n\t\t}\n\n\t\tif ( basicJavaType instanceof BasicJavaType<?>\n\t\t\t\t&& ( !basicJavaType.getJavaTypeClass().isEnum() || enumerationStyle == null ) ) {\n\t\t\tfinal TypeDefinition autoAppliedTypeDef =\n\t\t\t\t\tgetBuildingContext().getTypeDefinitionRegistry()\n\t\t\t\t\t\t\t.resolveAutoApplied( (BasicJavaType<?>) basicJavaType );\n\t\t\tif ( autoAppliedTypeDef != null ) {\n\t\t\t\tlog.debug(\"BasicValue resolution matched auto-applied type-definition\");\n\t\t\t\treturn autoAppliedTypeDef.resolve( getTypeParameters(), null, getBuildingContext(), this );\n\t\t\t}\n\t\t}\n\n\t\treturn InferredBasicValueResolver.from(\n\t\t\t\texplicitJavaType,\n\t\t\t\tjdbcType,\n\t\t\t\tresolvedJavaType,\n\t\t\t\tthis::determineReflectedJavaType,\n\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\tthis,\n\t\t\t\tgetTable(),\n\t\t\t\tgetColumn(),\n\t\t\t\townerName,\n\t\t\t\tpropertyName,\n\t\t\t\tgetBuildingContext()\n\t\t);\n\t}\n\n\t@Override\n\tpublic ManagedBeanRegistry getManagedBeanRegistry() {\n\t\treturn getServiceRegistry().requireService( ManagedBeanRegistry.class );\n\t}\n\n\tprivate Resolution<?> converterResolution(JavaType<?> javaType, ConverterDescriptor attributeConverterDescriptor) {\n\t\tfinal NamedConverterResolution<?> converterResolution = NamedConverterResolution.from(\n\t\t\t\tattributeConverterDescriptor,\n\t\t\t\texplicitJavaTypeAccess,\n\t\t\t\texplicitJdbcTypeAccess,\n\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\tresolvedJavaType,\n\t\t\t\tthis,\n\t\t\t\tthis,\n\t\t\t\tgetBuildingContext()\n\t\t);\n\n\t\tif ( javaType instanceof BasicPluralJavaType<?> containerJtd\n\t\t\t\t&& !attributeConverterDescriptor.getDomainValueResolvedType().getErasedType()\n\t\t\t\t\t\t.isAssignableFrom( javaType.getJavaTypeClass() ) ) {\n\t\t\t// In this case, the converter applies to the element of a BasicPluralJavaType\n\t\t\tfinal BasicType registeredElementType = converterResolution.getLegacyResolvedBasicType();\n\t\t\tfinal Selectable column = getColumn();\n\t\t\tfinal BasicType<?> registeredType = registeredElementType == null ? null\n\t\t\t\t\t: containerJtd.resolveType(\n\t\t\t\t\t\t\tgetTypeConfiguration(),\n\t\t\t\t\t\t\tgetDialect(),\n\t\t\t\t\t\t\tregisteredElementType,\n\t\t\t\t\t\t\tcolumn instanceof ColumnTypeInformation ? (ColumnTypeInformation) column : null,\n\t\t\t\t\t\t\tthis\n\t\t\t);\n\t\t\tif ( registeredType != null ) {\n\t\t\t\tgetTypeConfiguration().getBasicTypeRegistry().register( registeredType );\n\t\t\t\treturn new InferredBasicValueResolution(\n\t\t\t\t\t\tregisteredType,\n\t\t\t\t\t\tregisteredType.getJavaTypeDescriptor(),\n\t\t\t\t\t\tregisteredType.getJavaTypeDescriptor(),\n\t\t\t\t\t\tregisteredType.getJdbcType(),\n\t\t\t\t\t\tregisteredType,\n\t\t\t\t\t\tnull\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn converterResolution;\n\t}\n\n\tprivate JavaType<?> determineJavaType(JavaType<?> explicitJavaType) {\n\t\tJavaType<?> javaType = explicitJavaType;\n//\n//\t\tif ( javaType == null ) {\n//\t\t\tif ( implicitJavaTypeAccess != null ) {\n//\t\t\t\tfinal java.lang.reflect.Type implicitJtd = implicitJavaTypeAccess.apply( getTypeConfiguration() );\n//\t\t\t\tif ( implicitJtd != null ) {\n//\t\t\t\t\tjavaType = getTypeConfiguration().getJavaTypeRegistry().getDescriptor( implicitJtd );\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n\n\t\tif ( javaType == null ) {\n\t\t\tfinal JavaType<?> reflectedJtd = determineReflectedJavaType();\n\t\t\tif ( reflectedJtd != null ) {\n\t\t\t\tjavaType = reflectedJtd;\n\t\t\t}\n\t\t}\n\n\t\treturn javaType;\n\t}\n\n\tprivate JavaType<?> determineReflectedJavaType() {\n\t\tfinal TypeConfiguration typeConfiguration = getTypeConfiguration();\n\t\tfinal java.lang.reflect.Type impliedJavaType = impliedJavaType( typeConfiguration );\n\t\tif ( impliedJavaType == null ) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tresolvedJavaType = impliedJavaType;\n\t\t\treturn javaType( typeConfiguration, impliedJavaType );\n\t\t}\n\t}\n\n\tprivate java.lang.reflect.Type impliedJavaType(TypeConfiguration typeConfiguration) {\n\t\tif ( resolvedJavaType != null ) {\n\t\t\treturn resolvedJavaType;\n\t\t}\n\t\telse if ( implicitJavaTypeAccess != null ) {\n\t\t\treturn implicitJavaTypeAccess.apply(typeConfiguration);\n\t\t}\n\t\telse if ( ownerName != null && propertyName != null ) {\n\t\t\treturn reflectedPropertyType( ownerName, propertyName,\n\t\t\t\t\tgetServiceRegistry().requireService( ClassLoaderService.class ) );\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate JavaType<Object> javaType(TypeConfiguration typeConfiguration, java.lang.reflect.Type impliedJavaType) {\n\t\tfinal JavaType<Object> javaType = typeConfiguration.getJavaTypeRegistry().findDescriptor( impliedJavaType );\n\t\treturn javaType == null ? specialJavaType( typeConfiguration, impliedJavaType ) : javaType;\n\t}\n\n\tprivate JavaType<Object> specialJavaType(\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tjava.lang.reflect.Type impliedJavaType) {\n\t\tfinal JavaTypeRegistry javaTypeRegistry = typeConfiguration.getJavaTypeRegistry();\n\t\tif ( jdbcTypeCode != null ) {\n\t\t\t// Construct special JavaType instances for JSON/XML types which can report recommended JDBC types\n\t\t\t// and implement toString/fromString as well as copying based on FormatMapper operations\n\t\t\tswitch ( jdbcTypeCode ) {\n\t\t\t\tcase SqlTypes.JSON:\n\t\t\t\t\tfinal JavaType<Object> jsonJavaType =\n\t\t\t\t\t\t\tnew JsonJavaType<>( impliedJavaType,\n\t\t\t\t\t\t\t\t\tmutabilityPlan( typeConfiguration, impliedJavaType ),\n\t\t\t\t\t\t\t\t\ttypeConfiguration );\n\t\t\t\t\tjavaTypeRegistry.addDescriptor( jsonJavaType );\n\t\t\t\t\treturn jsonJavaType;\n\t\t\t\tcase SqlTypes.SQLXML:\n\t\t\t\t\tfinal JavaType<Object> xmlJavaType =\n\t\t\t\t\t\t\tnew XmlJavaType<>( impliedJavaType,\n\t\t\t\t\t\t\t\t\tmutabilityPlan( typeConfiguration, impliedJavaType ),\n\t\t\t\t\t\t\t\t\ttypeConfiguration );\n\t\t\t\t\tjavaTypeRegistry.addDescriptor( xmlJavaType );\n\t\t\t\t\treturn xmlJavaType;\n\t\t\t}\n\t\t}\n\t\treturn javaTypeRegistry.resolveDescriptor( impliedJavaType );\n\t}\n\n\tprivate MutabilityPlan<Object> mutabilityPlan(\n\t\t\tTypeConfiguration typeConfiguration, java.lang.reflect.Type impliedJavaType) {\n\t\tfinal MutabilityPlan<Object> explicitMutabilityPlan = getExplicitMutabilityPlan();\n\t\treturn explicitMutabilityPlan != null\n\t\t\t\t? explicitMutabilityPlan\n\t\t\t\t: RegistryHelper.INSTANCE.determineMutabilityPlan( impliedJavaType, typeConfiguration );\n\t}\n\n\tprivate MutabilityPlan<Object> getExplicitMutabilityPlan() {\n\t\treturn explicitMutabilityPlanAccess == null ? null\n\t\t\t\t: explicitMutabilityPlanAccess.apply( getTypeConfiguration()  );\n\t}\n\n\tprivate static Resolution<?> interpretExplicitlyNamedType(\n\t\t\tString name,\n\t\t\tFunction<TypeConfiguration, BasicJavaType> explicitJtdAccess,\n\t\t\tFunction<TypeConfiguration, JdbcType> explicitStdAccess,\n\t\t\tFunction<TypeConfiguration, MutabilityPlan> explicitMutabilityPlanAccess,\n\t\t\tConverterDescriptor converterDescriptor,\n\t\t\tMap<Object,Object> localTypeParams,\n\t\t\tConsumer<Properties> combinedParameterConsumer,\n\t\t\tJdbcTypeIndicators stdIndicators,\n\t\t\tMetadataBuildingContext context) {\n\n\t\tfinal StandardServiceRegistry serviceRegistry = context.getBootstrapContext().getServiceRegistry();\n\t\tfinal ManagedBeanRegistry managedBeanRegistry = serviceRegistry.requireService( ManagedBeanRegistry.class );\n\t\tfinal TypeConfiguration typeConfiguration = context.getBootstrapContext().getTypeConfiguration();\n\n\t\tfinal JpaAttributeConverterCreationContext converterCreationContext = new JpaAttributeConverterCreationContext() {\n\t\t\t@Override\n\t\t\tpublic ManagedBeanRegistry getManagedBeanRegistry() {\n\t\t\t\treturn managedBeanRegistry;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic TypeConfiguration getTypeConfiguration() {\n\t\t\t\treturn typeConfiguration;\n\t\t\t}\n\t\t};\n\n\t\t// Name could refer to:\n\t\t//\t\t1) a named converter - HBM support for JPA's AttributeConverter via its `type=\"...\"` XML attribute\n\t\t//\t\t2) a \"named composed\" mapping - like (1), this is mainly to support envers since it tells\n\t\t//\t\t\tHibernate the mappings via DOM.  See `org.hibernate.type.internal.BasicTypeImpl`\n\t\t//\t\t3) basic type \"resolution key\"\n\t\t//\t\t4) UserType or BasicType class name - directly, or through a TypeDefinition\n\n\t\tif ( name.startsWith( ConverterDescriptor.TYPE_NAME_PREFIX  ) ) {\n\t\t\treturn NamedConverterResolution.from(\n\t\t\t\t\tname,\n\t\t\t\t\texplicitJtdAccess,\n\t\t\t\t\texplicitStdAccess,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tstdIndicators,\n\t\t\t\t\tconverterCreationContext,\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\n//\t\tif ( name.startsWith( EnumeratedValueResolution.PREFIX ) ) {\n//\t\t\treturn EnumeratedValueResolution.fromName( name, stdIndicators, context );\n//\t\t}\n\n\t\tif ( name.startsWith( BasicTypeImpl.EXTERNALIZED_PREFIX ) ) {\n\t\t\tfinal BasicType<Object> basicType = context.getBootstrapContext().resolveAdHocBasicType( name );\n\t\t\treturn new NamedBasicTypeResolution<>(\n\t\t\t\t\tbasicType.getJavaTypeDescriptor(),\n\t\t\t\t\tbasicType,\n\t\t\t\t\tnull,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\n\t\t// see if it is a named basic type\n\t\tfinal BasicType<?> basicTypeByName = typeConfiguration.getBasicTypeRegistry().getRegisteredType( name );\n\t\tif ( basicTypeByName != null ) {\n\t\t\tfinal BasicValueConverter<?,?> valueConverter;\n\t\t\tfinal JavaType<?> domainJtd;\n\t\t\tif ( converterDescriptor != null ) {\n\t\t\t\tvalueConverter = converterDescriptor.createJpaAttributeConverter( converterCreationContext );\n\t\t\t\tdomainJtd = valueConverter.getDomainJavaType();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalueConverter = basicTypeByName.getValueConverter();\n\t\t\t\tdomainJtd = basicTypeByName.getJavaTypeDescriptor();\n\t\t\t}\n\n\t\t\treturn new NamedBasicTypeResolution<>(\n\t\t\t\t\tdomainJtd,\n\t\t\t\t\tbasicTypeByName,\n\t\t\t\t\tvalueConverter,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\n\t\t// see if it is a named TypeDefinition\n\t\tfinal TypeDefinition typeDefinition = context.getTypeDefinitionRegistry().resolve( name );\n\t\tif ( typeDefinition != null ) {\n\t\t\tfinal Resolution<?> resolution = typeDefinition.resolve(\n\t\t\t\t\tlocalTypeParams,\n\t\t\t\t\texplicitMutabilityPlanAccess != null\n\t\t\t\t\t\t\t? explicitMutabilityPlanAccess.apply( typeConfiguration )\n\t\t\t\t\t\t\t: null,\n\t\t\t\t\tcontext,\n\t\t\t\t\tstdIndicators\n\t\t\t);\n\t\t\tcombinedParameterConsumer.accept( resolution.getCombinedTypeParameters() );\n\t\t\treturn resolution;\n\t\t}\n\n\n\t\t// see if the name is a UserType or BasicType implementor class name\n\t\tfinal ClassLoaderService cls = serviceRegistry.requireService( ClassLoaderService.class );\n\t\ttry {\n\t\t\tfinal Class<?> typeNamedClass = cls.classForName( name );\n\n\t\t\t// if there are no local config params, register an implicit TypeDefinition for this custom type .\n\t\t\t//  later uses may find it and re-use its cacheable reference...\n\t\t\tif ( CollectionHelper.isEmpty( localTypeParams ) ) {\n\t\t\t\tfinal TypeDefinition implicitDefinition = new TypeDefinition(\n\t\t\t\t\t\tname,\n\t\t\t\t\t\ttypeNamedClass,\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\tnull\n\t\t\t\t);\n\t\t\t\tcontext.getTypeDefinitionRegistry().register( implicitDefinition );\n\t\t\t\treturn implicitDefinition.resolve(\n\t\t\t\t\t\tlocalTypeParams,\n\t\t\t\t\t\texplicitMutabilityPlanAccess != null\n\t\t\t\t\t\t\t\t? explicitMutabilityPlanAccess.apply( typeConfiguration )\n\t\t\t\t\t\t\t\t: null,\n\t\t\t\t\t\tcontext,\n\t\t\t\t\t\tstdIndicators\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn TypeDefinition.createLocalResolution( name, typeNamedClass, localTypeParams, context );\n\t\t}\n\t\tcatch (ClassLoadingException e) {\n\t\t\t// allow the exception below to trigger\n\t\t\tlog.debugf( \"Could not resolve type-name [%s] as Java type : %s\", name, e );\n\t\t}\n\n\t\tthrow new MappingException( \"Could not resolve named type : \" + name );\n\t}\n\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// SqlTypeDescriptorIndicators\n\n\t@Override\n\tpublic EnumType getEnumeratedType() {\n\t\treturn getEnumerationStyle();\n\t}\n\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForBoolean() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForBoolean() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForDuration() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForDuration() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForUuid() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForUuid() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForInstant() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForInstant() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForArray() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForArray() );\n\t}\n\n\t@Override\n\tpublic int resolveJdbcTypeCode(int jdbcTypeCode) {\n\t\treturn aggregateColumn == null\n\t\t\t\t? jdbcTypeCode\n\t\t\t\t: getDialect().getAggregateSupport()\n\t\t\t\t.aggregateComponentSqlTypeCode( aggregateColumn.getSqlTypeCode( getMetadata() ), jdbcTypeCode );\n\t}\n\n\t@Override\n\tpublic TimeZoneStorageStrategy getDefaultTimeZoneStorageStrategy() {\n\t\treturn timeZoneStorageStrategy( timeZoneStorageType, getBuildingContext() );\n\t}\n\n\t@Internal\n\tpublic static TimeZoneStorageStrategy timeZoneStorageStrategy(\n\t\t\tTimeZoneStorageType timeZoneStorageType,\n\t\t\tMetadataBuildingContext buildingContext) {\n\t\tif ( timeZoneStorageType != null ) {\n\t\t\tswitch ( timeZoneStorageType ) {\n\t\t\t\tcase COLUMN:\n\t\t\t\t\treturn TimeZoneStorageStrategy.COLUMN;\n\t\t\t\tcase NATIVE:\n\t\t\t\t\treturn TimeZoneStorageStrategy.NATIVE;\n\t\t\t\tcase NORMALIZE:\n\t\t\t\t\treturn TimeZoneStorageStrategy.NORMALIZE;\n\t\t\t\tcase NORMALIZE_UTC:\n\t\t\t\t\treturn TimeZoneStorageStrategy.NORMALIZE_UTC;\n\t\t\t}\n\t\t}\n\t\treturn buildingContext.getBuildingOptions().getDefaultTimeZoneStorage();\n\t}\n\n\tpublic void setExplicitTypeParams(Map<String,String> explicitLocalTypeParams) {\n\t\tthis.explicitLocalTypeParams = explicitLocalTypeParams;\n\t}\n\n\tpublic void setExplicitTypeName(String typeName) {\n\t\tthis.explicitTypeName = typeName;\n\t}\n\n\tpublic void setTypeName(String typeName) {\n\t\tif ( StringHelper.isNotEmpty( typeName ) ) {\n\t\t\tif ( typeName.startsWith( ConverterDescriptor.TYPE_NAME_PREFIX ) ) {\n\t\t\t\tfinal String converterClassName = typeName.substring( ConverterDescriptor.TYPE_NAME_PREFIX.length() );\n\t\t\t\tfinal ClassLoaderService cls = getServiceRegistry().requireService( ClassLoaderService.class );\n\t\t\t\ttry {\n\t\t\t\t\tfinal Class<AttributeConverter<?,?>> converterClass = cls.classForName( converterClassName );\n\t\t\t\t\tsetAttributeConverterDescriptor( new ClassBasedConverterDescriptor(\n\t\t\t\t\t\t\tconverterClass,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t\t) );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tlog.logBadHbmAttributeConverterType( typeName, e.getMessage() );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsetExplicitTypeName( typeName );\n\t\t\t}\n\t\t}\n\n\t\tsuper.setTypeName( typeName );\n\t}\n\n\tprivate static int COUNTER;\n\n\tpublic void setExplicitCustomType(Class<? extends UserType<?>> explicitCustomType) {\n\t\tif ( explicitCustomType != null ) {\n\t\t\tif ( resolution != null ) {\n\t\t\t\tthrow new UnsupportedOperationException( \"Unsupported attempt to set an explicit-custom-type when value is already resolved\" );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresolution = new UserTypeResolution<>(\n\t\t\t\t\t\tnew CustomType<>(\n\t\t\t\t\t\t\t\tgetConfiguredUserTypeBean( explicitCustomType, getCustomTypeProperties() ),\n\t\t\t\t\t\t\t\tgetTypeConfiguration()\n\t\t\t\t\t\t),\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\tgetCustomTypeProperties()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate Properties getCustomTypeProperties() {\n\t\tfinal Properties properties = new Properties();\n\t\tif ( isNotEmpty( getTypeParameters() ) ) {\n\t\t\tproperties.putAll( getTypeParameters() );\n\t\t}\n\t\tif ( isNotEmpty( explicitLocalTypeParams ) ) {\n\t\t\tproperties.putAll( explicitLocalTypeParams );\n\t\t}\n\t\treturn properties;\n\t}\n\n\tprivate UserType<?> getConfiguredUserTypeBean(Class<? extends UserType<?>> explicitCustomType, Properties properties) {\n\t\tfinal UserType<?> typeInstance =\n\t\t\t\t!getBuildingContext().getBuildingOptions().isAllowExtensionsInCdi()\n\t\t\t\t\t\t? FallbackBeanInstanceProducer.INSTANCE.produceBeanInstance( explicitCustomType )\n\t\t\t\t\t\t: getUserTypeBean( explicitCustomType, properties ).getBeanInstance();\n\n\t\tif ( typeInstance instanceof TypeConfigurationAware configurationAware ) {\n\t\t\tconfigurationAware.setTypeConfiguration( getTypeConfiguration() );\n\t\t}\n\n\t\tif ( typeInstance instanceof DynamicParameterizedType ) {\n\t\t\tif ( parseBoolean( properties.getProperty( DynamicParameterizedType.IS_DYNAMIC ) ) ) {\n\t\t\t\tif ( properties.get( DynamicParameterizedType.PARAMETER_TYPE ) == null ) {\n\t\t\t\t\tproperties.put( DynamicParameterizedType.PARAMETER_TYPE, makeParameterImpl() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tinjectParameters( typeInstance, properties);\n\t\t// envers - grr\n\t\tsetTypeParameters( properties );\n\n\t\treturn typeInstance;\n\t}\n\n\tprivate <T> ManagedBean<T> getUserTypeBean(Class<T> explicitCustomType, Properties properties) {\n\t\tfinal BeanInstanceProducer producer = getBuildingContext().getBootstrapContext().getCustomTypeProducer();\n\t\tfinal ManagedBeanRegistry registry = getServiceRegistry().requireService( ManagedBeanRegistry.class );\n\t\tif ( isNotEmpty( properties ) ) {\n\t\t\tfinal String name = explicitCustomType.getName() + COUNTER++;\n\t\t\treturn registry.getBean( name, explicitCustomType, producer );\n\t\t}\n\t\telse {\n\t\t\treturn registry.getBean( explicitCustomType, producer );\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"deprecation\")\n\tpublic void setTemporalPrecision(TemporalType temporalPrecision) {\n\t\tthis.temporalPrecision = temporalPrecision;\n\t}\n\n\t@Override @SuppressWarnings(\"deprecation\")\n\tpublic TemporalType getTemporalPrecision() {\n\t\treturn temporalPrecision;\n\t}\n\n\t@Override\n\tpublic boolean isPreferJavaTimeJdbcTypesEnabled() {\n\t\treturn getBuildingContext().isPreferJavaTimeJdbcTypesEnabled();\n\t}\n\n\t@Override\n\tpublic boolean isPreferNativeEnumTypesEnabled() {\n\t\treturn getBuildingContext().isPreferNativeEnumTypesEnabled();\n\t}\n\n\t@Override\n\tpublic Object accept(ValueVisitor visitor) {\n\t\treturn visitor.accept(this);\n\t}\n\n\t@Internal\n\tpublic boolean isDisallowedWrapperArray() {\n\t\treturn getBuildingContext().getBuildingOptions().getWrapperArrayHandling() == WrapperArrayHandling.DISALLOW\n\t\t\t&& !isLob()\n\t\t\t&& ( explicitJavaTypeAccess == null || explicitJavaTypeAccess.apply( getTypeConfiguration() ) == null )\n\t\t\t&& isWrapperByteOrCharacterArray();\n\t}\n\n\tprivate boolean isWrapperByteOrCharacterArray() {\n\t\tfinal Class<?> javaTypeClass = getResolution().getDomainJavaType().getJavaTypeClass();\n\t\treturn javaTypeClass == Byte[].class || javaTypeClass == Character[].class;\n\t}\n\n\t@Incubating\n\tpublic void setExplicitJdbcTypeCode(Integer jdbcTypeCode) {\n\t\tthis.jdbcTypeCode = jdbcTypeCode;\n\t}\n\n\t@Override\n\tpublic Integer getExplicitJdbcTypeCode() {\n\t\treturn jdbcTypeCode == null ? getPreferredSqlTypeCodeForArray() : jdbcTypeCode;\n\t}\n\n\t/**\n\t * Resolved form of {@link BasicValue} as part of interpreting the\n\t * boot-time model into the run-time model\n\t */\n\tpublic interface Resolution<J> {\n\t\t/**\n\t\t * The BasicType resolved using the pre-6.0 rules.  This is temporarily\n\t\t * needed because of the split in extracting / binding\n\t\t */\n\t\tBasicType<J> getLegacyResolvedBasicType();\n\n\t\t/**\n\t\t * Get the collection of type-parameters collected both locally as well\n\t\t * as from the applied type-def, if one\n\t\t */\n\t\tdefault Properties getCombinedTypeParameters() {\n\t\t\treturn null;\n\t\t}\n\n\t\tJdbcMapping getJdbcMapping();\n\n\t\t/**\n\t\t * The JavaType for the value as part of the domain model\n\t\t */\n\t\tJavaType<J> getDomainJavaType();\n\n\t\t/**\n\t\t * The JavaType for the relational value as part of\n\t\t * the relational model (its JDBC representation)\n\t\t */\n\t\tJavaType<?> getRelationalJavaType();\n\n\t\t/**\n\t\t * The JavaType for the relational value as part of\n\t\t * the relational model (its JDBC representation)\n\t\t */\n\t\tJdbcType getJdbcType();\n\n\t\t/**\n\t\t * Converter, if any, to convert values between the\n\t\t * domain and relational JavaType representations\n\t\t */\n\t\tBasicValueConverter<J,?> getValueConverter();\n\n\t\t/**\n\t\t * The resolved MutabilityPlan\n\t\t */\n\t\tMutabilityPlan<J> getMutabilityPlan();\n\n\t\tdefault void updateResolution(BasicType<?> type) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private BasicJavaType<?> getExplicitJavaType() {\n\t\treturn explicitJavaTypeAccess == null ? null\n\t\t\t\t: explicitJavaTypeAccess.apply( getTypeConfiguration() );\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.type.spi.TypeConfiguration.ArrayCacheKey#equals\n methodBody: public boolean equals(Object o) {\nreturn Arrays.equals(components,((ArrayCacheKey)o).components);\n}",
            "methodSignature: org.hibernate.mapping.BasicValue#resolution\n methodBody: private Resolution<?> resolution(BasicJavaType explicitJavaType, JavaType<?> javaType) {\nfinal JavaType<?> basicJavaType;\nfinal JdbcType jdbcType;\nif(explicitJdbcTypeAccess != null){final TypeConfiguration typeConfiguration=getTypeConfiguration();\njdbcType=explicitJdbcTypeAccess.apply(typeConfiguration);\nbasicJavaType=javaType == null && jdbcType != null ? jdbcType.getJdbcRecommendedJavaTypeMapping(null,null,typeConfiguration) : javaType;\n}{jdbcType=null;\nbasicJavaType=javaType;\n}if(basicJavaType == null){throw new MappingException(\"Unable to determine JavaType to use : \" + this);\n}if(basicJavaType instanceof BasicJavaType<?> && (!basicJavaType.getJavaTypeClass().isEnum() || enumerationStyle == null)){final TypeDefinition autoAppliedTypeDef=getBuildingContext().getTypeDefinitionRegistry().resolveAutoApplied((BasicJavaType<?>)basicJavaType);\nif(autoAppliedTypeDef != null){log.debug(\"BasicValue resolution matched auto-applied type-definition\");\nreturn autoAppliedTypeDef.resolve(getTypeParameters(),null,getBuildingContext(),this);\n}}return InferredBasicValueResolver.from(explicitJavaType,jdbcType,resolvedJavaType,this::determineReflectedJavaType,explicitMutabilityPlanAccess,this,getTable(),getColumn(),ownerName,propertyName,getBuildingContext());\n}",
            "methodSignature: org.hibernate.mapping.BasicValue#isSoftDelete\n methodBody: public boolean isSoftDelete() {\nreturn isSoftDelete;\n}",
            "methodSignature: org.hibernate.type.spi.TypeConfiguration.Scope#getTypeConfiguration\n methodBody: public TypeConfiguration getTypeConfiguration() {\nreturn typeConfiguration;\n}",
            "methodSignature: org.hibernate.mapping.BasicValue.ReversedConverterDescriptor#getAttributeConverterClass\n methodBody: public Class<? extends AttributeConverter<Boolean,R>> getAttributeConverterClass() {\nreturn (Class<? extends AttributeConverter<Boolean,R>>)getClass();\n}",
            "methodSignature: org.hibernate.mapping.BasicValue#interpretExplicitlyNamedType\n methodBody: private static Resolution<?> interpretExplicitlyNamedType(\n\t\t\tString name,\n\t\t\tFunction<TypeConfiguration, BasicJavaType> explicitJtdAccess,\n\t\t\tFunction<TypeConfiguration, JdbcType> explicitStdAccess,\n\t\t\tFunction<TypeConfiguration, MutabilityPlan> explicitMutabilityPlanAccess,\n\t\t\tConverterDescriptor converterDescriptor,\n\t\t\tMap<Object,Object> localTypeParams,\n\t\t\tConsumer<Properties> combinedParameterConsumer,\n\t\t\tJdbcTypeIndicators stdIndicators,\n\t\t\tMetadataBuildingContext context) {\nfinal StandardServiceRegistry serviceRegistry=context.getBootstrapContext().getServiceRegistry();\nfinal ManagedBeanRegistry managedBeanRegistry=serviceRegistry.requireService(ManagedBeanRegistry.class);\nfinal TypeConfiguration typeConfiguration=context.getBootstrapContext().getTypeConfiguration();\nfinal JpaAttributeConverterCreationContext converterCreationContext=new JpaAttributeConverterCreationContext(){\n  @Override public ManagedBeanRegistry getManagedBeanRegistry(){\n    return managedBeanRegistry;\n  }\n  @Override public TypeConfiguration getTypeConfiguration(){\n    return typeConfiguration;\n  }\n}\n;\nif(name.startsWith(ConverterDescriptor.TYPE_NAME_PREFIX)){return NamedConverterResolution.from(name,explicitJtdAccess,explicitStdAccess,explicitMutabilityPlanAccess,stdIndicators,converterCreationContext,context);\n}if(name.startsWith(BasicTypeImpl.EXTERNALIZED_PREFIX)){final BasicType<Object> basicType=context.getBootstrapContext().resolveAdHocBasicType(name);\nreturn new NamedBasicTypeResolution<>(basicType.getJavaTypeDescriptor(),basicType,null,explicitMutabilityPlanAccess,context);\n}final BasicType<?> basicTypeByName=typeConfiguration.getBasicTypeRegistry().getRegisteredType(name);\nif(basicTypeByName != null){final BasicValueConverter<?,?> valueConverter;\nfinal JavaType<?> domainJtd;\nif(converterDescriptor != null){valueConverter=converterDescriptor.createJpaAttributeConverter(converterCreationContext);\ndomainJtd=valueConverter.getDomainJavaType();\n}{valueConverter=basicTypeByName.getValueConverter();\ndomainJtd=basicTypeByName.getJavaTypeDescriptor();\n}return new NamedBasicTypeResolution<>(domainJtd,basicTypeByName,valueConverter,explicitMutabilityPlanAccess,context);\n}final TypeDefinition typeDefinition=context.getTypeDefinitionRegistry().resolve(name);\nif(typeDefinition != null){final Resolution<?> resolution=typeDefinition.resolve(localTypeParams,explicitMutabilityPlanAccess != null ? explicitMutabilityPlanAccess.apply(typeConfiguration) : null,context,stdIndicators);\ncombinedParameterConsumer.accept(resolution.getCombinedTypeParameters());\nreturn resolution;\n}final ClassLoaderService cls=serviceRegistry.requireService(ClassLoaderService.class);\ntryfinal Class<?> typeNamedClass=cls.classForName(name);\nif(CollectionHelper.isEmpty(localTypeParams)){final TypeDefinition implicitDefinition=new TypeDefinition(name,typeNamedClass,null,null);\ncontext.getTypeDefinitionRegistry().register(implicitDefinition);\nreturn implicitDefinition.resolve(localTypeParams,explicitMutabilityPlanAccess != null ? explicitMutabilityPlanAccess.apply(typeConfiguration) : null,context,stdIndicators);\n}return TypeDefinition.createLocalResolution(name,typeNamedClass,localTypeParams,context);\ncatch(ClassLoadingException e)log.debugf(\"Could not resolve type-name [%s] as Java type : %s\",name,e);\nthrow new MappingException(\"Could not resolve named type : \" + name);\n}",
            "methodSignature: org.hibernate.mapping.BasicValue#getSoftDeleteStrategy\n methodBody: public SoftDeleteType getSoftDeleteStrategy() {\nreturn softDeleteStrategy;\n}",
            "methodSignature: org.hibernate.mapping.BasicValue#determineJavaType\n methodBody: private JavaType<?> determineJavaType(JavaType<?> explicitJavaType) {\nJavaType<?> javaType=explicitJavaType;\nif(javaType == null){final JavaType<?> reflectedJtd=determineReflectedJavaType();\nif(reflectedJtd != null){javaType=reflectedJtd;\n}}return javaType;\n}",
            "methodSignature: org.hibernate.mapping.BasicValue#converterResolution\n methodBody: private Resolution<?> converterResolution(JavaType<?> javaType, ConverterDescriptor attributeConverterDescriptor) {\nfinal NamedConverterResolution<?> converterResolution=NamedConverterResolution.from(attributeConverterDescriptor,explicitJavaTypeAccess,explicitJdbcTypeAccess,explicitMutabilityPlanAccess,resolvedJavaType,this,this,getBuildingContext());\nif(javaType instanceof BasicPluralJavaType<?> && !attributeConverterDescriptor.getDomainValueResolvedType().getErasedType().isAssignableFrom(javaType.getJavaTypeClass())){final BasicPluralJavaType<?> containerJtd=(BasicPluralJavaType<?>)javaType;\nfinal BasicType registeredElementType=converterResolution.getLegacyResolvedBasicType();\nfinal Selectable column=getColumn();\nfinal BasicType<?> registeredType=registeredElementType == null ? null : containerJtd.resolveType(getTypeConfiguration(),getDialect(),registeredElementType,column instanceof ColumnTypeInformation ? (ColumnTypeInformation)column : null,this);\nif(registeredType != null){getTypeConfiguration().getBasicTypeRegistry().register(registeredType);\nreturn new InferredBasicValueResolution(registeredType,registeredType.getJavaTypeDescriptor(),registeredType.getJavaTypeDescriptor(),registeredType.getJdbcType(),registeredType,null);\n}}return converterResolution;\n}"
        ],
        "sourceCodeAfterRefactoring": "protected Resolution<?> buildResolution() {\n\t\tfinal Properties typeParameters = getTypeParameters();\n\t\tif ( typeParameters != null\n\t\t\t\t&& parseBoolean( typeParameters.getProperty(DynamicParameterizedType.IS_DYNAMIC) )\n\t\t\t\t&& typeParameters.get(DynamicParameterizedType.PARAMETER_TYPE) == null ) {\n\t\t\tcreateParameterImpl();\n\t\t}\n\n\t\tif ( explicitTypeName != null ) {\n\t\t\treturn interpretExplicitlyNamedType(\n\t\t\t\t\texplicitTypeName,\n\t\t\t\t\texplicitJavaTypeAccess,\n\t\t\t\t\texplicitJdbcTypeAccess,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tgetAttributeConverterDescriptor(),\n\t\t\t\t\ttypeParameters,\n\t\t\t\t\tthis::setTypeParameters,\n\t\t\t\t\tthis,\n\t\t\t\t\tgetBuildingContext()\n\t\t\t);\n\t\t}\n\t\telse if ( isVersion() ) {\n\t\t\treturn VersionResolution.from( implicitJavaTypeAccess, timeZoneStorageType, getBuildingContext() );\n\t\t}\n\t\telse {\n\t\t\t// determine JavaType if we can\n\t\t\tfinal BasicJavaType<?> explicitJavaType = getExplicitJavaType();\n\t\t\tfinal JavaType<?> javaType = determineJavaType( explicitJavaType );\n\t\t\tfinal ConverterDescriptor converterDescriptor = getConverterDescriptor( javaType );\n\t\t\treturn converterDescriptor != null\n\t\t\t\t\t? converterResolution( javaType, converterDescriptor )\n\t\t\t\t\t: resolution( explicitJavaType, javaType );\n\t\t}\n\t}\nprivate BasicJavaType<?> getExplicitJavaType() {\n\t\treturn explicitJavaTypeAccess == null ? null\n\t\t\t\t: explicitJavaTypeAccess.apply( getTypeConfiguration() );\n\t}",
        "diffSourceCode": "-  427: \n-  428: \tprotected Resolution<?> buildResolution() {\n-  429: \t\tfinal Properties typeParameters = getTypeParameters();\n-  430: \t\tif ( typeParameters != null\n-  431: \t\t\t\t&& parseBoolean( typeParameters.getProperty(DynamicParameterizedType.IS_DYNAMIC) )\n-  432: \t\t\t\t&& typeParameters.get(DynamicParameterizedType.PARAMETER_TYPE) == null ) {\n-  433: \t\t\tcreateParameterImpl();\n-  434: \t\t}\n-  435: \n-  436: \t\tif ( explicitTypeName != null ) {\n-  437: \t\t\treturn interpretExplicitlyNamedType(\n-  438: \t\t\t\t\texplicitTypeName,\n-  439: \t\t\t\t\texplicitJavaTypeAccess,\n-  440: \t\t\t\t\texplicitJdbcTypeAccess,\n-  441: \t\t\t\t\texplicitMutabilityPlanAccess,\n-  442: \t\t\t\t\tgetAttributeConverterDescriptor(),\n-  443: \t\t\t\t\ttypeParameters,\n-  444: \t\t\t\t\tthis::setTypeParameters,\n-  445: \t\t\t\t\tthis,\n-  446: \t\t\t\t\tgetBuildingContext()\n-  447: \t\t\t);\n-  448: \t\t}\n-  449: \n-  450: \t\tif ( isVersion() ) {\n-  451: \t\t\treturn VersionResolution.from( implicitJavaTypeAccess, timeZoneStorageType, getBuildingContext() );\n-  452: \t\t}\n-  453: \n-  454: \t\t// determine JavaType if we can\n-  455: \t\tfinal BasicJavaType<?> explicitJavaType = explicitJavaTypeAccess == null\n-  456: \t\t\t\t? null\n-  457: \t\t\t\t: explicitJavaTypeAccess.apply( getTypeConfiguration() );\n-  458: \n-  459: \t\tJavaType<?> javaType = determineJavaType( explicitJavaType );\n-  460: \t\tConverterDescriptor attributeConverterDescriptor = getAttributeConverterDescriptor();\n+  427: \tprotected Resolution<?> buildResolution() {\n+  428: \t\tfinal Properties typeParameters = getTypeParameters();\n+  429: \t\tif ( typeParameters != null\n+  430: \t\t\t\t&& parseBoolean( typeParameters.getProperty(DynamicParameterizedType.IS_DYNAMIC) )\n+  431: \t\t\t\t&& typeParameters.get(DynamicParameterizedType.PARAMETER_TYPE) == null ) {\n+  432: \t\t\tcreateParameterImpl();\n+  433: \t\t}\n+  434: \n+  435: \t\tif ( explicitTypeName != null ) {\n+  436: \t\t\treturn interpretExplicitlyNamedType(\n+  437: \t\t\t\t\texplicitTypeName,\n+  438: \t\t\t\t\texplicitJavaTypeAccess,\n+  439: \t\t\t\t\texplicitJdbcTypeAccess,\n+  440: \t\t\t\t\texplicitMutabilityPlanAccess,\n+  441: \t\t\t\t\tgetAttributeConverterDescriptor(),\n+  442: \t\t\t\t\ttypeParameters,\n+  443: \t\t\t\t\tthis::setTypeParameters,\n+  444: \t\t\t\t\tthis,\n+  445: \t\t\t\t\tgetBuildingContext()\n+  446: \t\t\t);\n+  447: \t\t}\n+  448: \t\telse if ( isVersion() ) {\n+  449: \t\t\treturn VersionResolution.from( implicitJavaTypeAccess, timeZoneStorageType, getBuildingContext() );\n+  450: \t\t}\n+  451: \t\telse {\n+  452: \t\t\t// determine JavaType if we can\n+  453: \t\t\tfinal BasicJavaType<?> explicitJavaType = getExplicitJavaType();\n+  454: \t\t\tfinal JavaType<?> javaType = determineJavaType( explicitJavaType );\n+  455: \t\t\tfinal ConverterDescriptor converterDescriptor = getConverterDescriptor( javaType );\n+  456: \t\t\treturn converterDescriptor != null\n+  457: \t\t\t\t\t? converterResolution( javaType, converterDescriptor )\n+  458: \t\t\t\t\t: resolution( explicitJavaType, javaType );\n+  459: \t\t}\n+  460: \t}\n   461: \n-  462: \t\tif ( isSoftDelete() ) {\n-  463: \t\t\tassert attributeConverterDescriptor != null;\n-  464: \t\t\tfinal boolean conversionWasUnspecified = SoftDelete.UnspecifiedConversion.class.equals( attributeConverterDescriptor.getAttributeConverterClass() );\n-  465: \t\t\tif ( conversionWasUnspecified ) {\n-  466: \t\t\t\tfinal JdbcType jdbcType = BooleanJdbcType.INSTANCE.resolveIndicatedType( this, javaType );\n-  467: \t\t\t\tif ( jdbcType.isNumber() ) {\n-  468: \t\t\t\t\tattributeConverterDescriptor = new InstanceBasedConverterDescriptor(\n-  469: \t\t\t\t\t\t\tNumericBooleanConverter.INSTANCE,\n-  470: \t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n-  471: \t\t\t\t\t);\n-  472: \t\t\t\t}\n-  473: \t\t\t\telse if ( jdbcType.isString() ) {\n-  474: \t\t\t\t\t// here we pick 'T' / 'F' storage, though 'Y' / 'N' is equally valid - its 50/50\n-  475: \t\t\t\t\tattributeConverterDescriptor = new InstanceBasedConverterDescriptor(\n-  476: \t\t\t\t\t\t\tTrueFalseConverter.INSTANCE,\n-  477: \t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n-  478: \t\t\t\t\t);\n-  479: \t\t\t\t}\n-  480: \t\t\t\telse {\n-  481: \t\t\t\t\t// should indicate BIT or BOOLEAN == no conversion needed\n-  482: \t\t\t\t\t//\t\t- we still create the converter to properly set up JDBC type, etc\n-  483: \t\t\t\t\tattributeConverterDescriptor = new InstanceBasedConverterDescriptor(\n-  484: \t\t\t\t\t\t\tPassThruSoftDeleteConverter.INSTANCE,\n-  485: \t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n-  486: \t\t\t\t\t);\n-  487: \t\t\t\t}\n-  488: \t\t\t}\n-  489: \n-  490: \t\t\tif ( getSoftDeleteStrategy() == SoftDeleteType.ACTIVE ) {\n-  491: \t\t\t\tattributeConverterDescriptor = new ReversedConverterDescriptor<>( attributeConverterDescriptor );\n-  492: \t\t\t}\n-  493: \t\t}\n-  494: \n-  495: \t\treturn attributeConverterDescriptor != null\n-  496: \t\t\t\t? converterResolution( javaType, attributeConverterDescriptor )\n-  497: \t\t\t\t: resolution( explicitJavaType, javaType );\n-  498: \t}\n+  462: \tprivate BasicJavaType<?> getExplicitJavaType() {\n+  463: \t\treturn explicitJavaTypeAccess == null ? null\n+  464: \t\t\t\t: explicitJavaTypeAccess.apply( getTypeConfiguration() );\n+  465: \t}\n+  466: \n+  467: \tprivate ConverterDescriptor getConverterDescriptor(JavaType<?> javaType) {\n+  468: \t\tfinal ConverterDescriptor converterDescriptor = getAttributeConverterDescriptor();\n+  469: \t\tif ( isSoftDelete() ) {\n+  470: \t\t\tassert converterDescriptor != null;\n+  471: \t\t\tfinal ConverterDescriptor softDeleteConverterDescriptor =\n+  472: \t\t\t\t\tgetSoftDeleteConverterDescriptor( converterDescriptor, javaType);\n+  473: \t\t\treturn getSoftDeleteStrategy() == SoftDeleteType.ACTIVE\n+  474: \t\t\t\t\t? new ReversedConverterDescriptor<>( softDeleteConverterDescriptor )\n+  475: \t\t\t\t\t: softDeleteConverterDescriptor;\n+  476: \t\t}\n+  477: \t\telse {\n+  478: \t\t\treturn converterDescriptor;\n+  479: \t\t}\n+  480: \t}\n+  481: \n+  482: \tprivate ConverterDescriptor getSoftDeleteConverterDescriptor(\n+  483: \t\t\tConverterDescriptor attributeConverterDescriptor, JavaType<?> javaType) {\n+  484: \t\tfinal boolean conversionWasUnspecified =\n+  485: \t\t\t\tSoftDelete.UnspecifiedConversion.class.equals( attributeConverterDescriptor.getAttributeConverterClass() );\n+  486: \t\tif ( conversionWasUnspecified ) {\n+  487: \t\t\tfinal JdbcType jdbcType = BooleanJdbcType.INSTANCE.resolveIndicatedType( this, javaType);\n+  488: \t\t\tif ( jdbcType.isNumber() ) {\n+  489: \t\t\t\treturn new InstanceBasedConverterDescriptor(\n+  490: \t\t\t\t\t\tNumericBooleanConverter.INSTANCE,\n+  491: \t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n+  492: \t\t\t\t);\n+  493: \t\t\t}\n+  494: \t\t\telse if ( jdbcType.isString() ) {\n+  495: \t\t\t\t// here we pick 'T' / 'F' storage, though 'Y' / 'N' is equally valid - its 50/50\n+  496: \t\t\t\treturn new InstanceBasedConverterDescriptor(\n+  497: \t\t\t\t\t\tTrueFalseConverter.INSTANCE,\n+  498: \t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n",
        "uniqueId": "6c6c92e88d4535be020b4acb3d81f96df39a65d8_428_498_462_465_427_460",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 71
            },
            "BRANCH": {
                "missed": 0,
                "covered": 12
            },
            "LINE": {
                "missed": 0,
                "covered": 17
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 7
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": true,
        "refactoredCode": "##########################\nprotected Resolution<?> buildResolution() {\n    final Properties typeParameters = getTypeParameters();\n    if (typeParameters != null\n            && parseBoolean(typeParameters.getProperty(DynamicParameterizedType.IS_DYNAMIC))\n            && typeParameters.get(DynamicParameterizedType.PARAMETER_TYPE) == null) {\n        createParameterImpl();\n    }\n\n    if (explicitTypeName != null) {\n        return interpretExplicitlyNamedType(\n                explicitTypeName,\n                explicitJavaTypeAccess,\n                explicitJdbcTypeAccess,\n                explicitMutabilityPlanAccess,\n                getAttributeConverterDescriptor(),\n                typeParameters,\n                this::setTypeParameters,\n                this,\n                getBuildingContext()\n        );\n    }\n\n    if (isVersion()) {\n        return VersionResolution.from(implicitJavaTypeAccess, timeZoneStorageType, getBuildingContext());\n    }\n\n    // determine JavaType if we can\n    final BasicJavaType<?> explicitJavaType = explicitJavaTypeAccess == null\n            ? null\n            : explicitJavaTypeAccess.apply(getTypeConfiguration());\n\n    JavaType<?> javaType = determineJavaType(explicitJavaType);\n    ConverterDescriptor attributeConverterDescriptor = getAttributeConverterDescriptor();\n\n    if (isSoftDelete()) {\n        assert attributeConverterDescriptor != null;\n        final boolean conversionWasUnspecified = SoftDelete.UnspecifiedConversion.class.equals(attributeConverterDescriptor.getAttributeConverterClass());\n        if (conversionWasUnspecified) {\n            final JdbcType jdbcType = BooleanJdbcType.INSTANCE.resolveIndicatedType(this, javaType);\n            if (jdbcType.isNumber()) {\n                attributeConverterDescriptor = new InstanceBasedConverterDescriptor(\n                        NumericBooleanConverter.INSTANCE,\n                        getBuildingContext().getBootstrapContext().getClassmateContext()\n                );\n            } else if (jdbcType.isString()) {\n                // here we pick 'T' / 'F' storage, though 'Y' / 'N' is equally valid - its 50/50\n                attributeConverterDescriptor = new InstanceBasedConverterDescriptor(\n                        TrueFalseConverter.INSTANCE,\n                        getBuildingContext().getBootstrapContext().getClassmateContext()\n                );\n            } else {\n                // should indicate BIT or BOOLEAN == no conversion needed\n                //\t\t- we still create the converter to properly set up JDBC type, etc\n                attributeConverterDescriptor = new InstanceBasedConverterDescriptor(\n                        PassThruSoftDeleteConverter.INSTANCE,\n                        getBuildingContext().getBootstrapContext().getClassmateContext()\n                );\n            }\n        }\n\n        if (getSoftDeleteStrategy() == SoftDeleteType.ACTIVE) {\n            attributeConverterDescriptor = new ReversedConverterDescriptor<>(attributeConverterDescriptor);\n        }\n    }\n\n    return attributeConverterDescriptor != null\n            ? converterResolution(javaType, attributeConverterDescriptor)\n            : resolution(explicitJavaType, javaType);\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprotected Resolution<?> buildResolution() {\n\t\tfinal Properties typeParameters = getTypeParameters();\n\t\tif ( typeParameters != null\n\t\t\t\t&& parseBoolean( typeParameters.getProperty(DynamicParameterizedType.IS_DYNAMIC) )\n\t\t\t\t&& typeParameters.get(DynamicParameterizedType.PARAMETER_TYPE) == null ) {\n\t\t\tcreateParameterImpl();\n\t\t}\n\n\t\tif ( explicitTypeName != null ) {\n\t\t\treturn interpretExplicitlyNamedType(\n\t\t\t\t\texplicitTypeName,\n\t\t\t\t\texplicitJavaTypeAccess,\n\t\t\t\t\texplicitJdbcTypeAccess,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tgetAttributeConverterDescriptor(),\n\t\t\t\t\ttypeParameters,\n\t\t\t\t\tthis::setTypeParameters,\n\t\t\t\t\tthis,\n\t\t\t\t\tgetBuildingContext()\n\t\t\t);\n\t\t}\n\n\t\tif ( isVersion() ) {\n\t\t\treturn VersionResolution.from( implicitJavaTypeAccess, timeZoneStorageType, getBuildingContext() );\n\t\t}\n\n\t\t// determine JavaType if we can\n\t\tfinal BasicJavaType<?> explicitJavaType = explicitJavaTypeAccess == null\n\t\t\t\t? null\n\t\t\t\t: explicitJavaTypeAccess.apply( getTypeConfiguration() );\n\n\t\tJavaType<?> javaType = determineJavaType( explicitJavaType );\n\t\tConverterDescriptor attributeConverterDescriptor = getAttributeConverterDescriptor();\n\n\t\tif ( isSoftDelete() ) {\n\t\t\tassert attributeConverterDescriptor != null;\n\t\t\tfinal boolean conversionWasUnspecified = SoftDelete.UnspecifiedConversion.class.equals( attributeConverterDescriptor.getAttributeConverterClass() );\n\t\t\tif ( conversionWasUnspecified ) {\n\t\t\t\tfinal JdbcType jdbcType = BooleanJdbcType.INSTANCE.resolveIndicatedType( this, javaType );\n\t\t\t\tif ( jdbcType.isNumber() ) {\n\t\t\t\t\tattributeConverterDescriptor = new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\t\tNumericBooleanConverter.INSTANCE,\n\t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\telse if ( jdbcType.isString() ) {\n\t\t\t\t\t// here we pick 'T' / 'F' storage, though 'Y' / 'N' is equally valid - its 50/50\n\t\t\t\t\tattributeConverterDescriptor = new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\t\tTrueFalseConverter.INSTANCE,\n\t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// should indicate BIT or BOOLEAN == no conversion needed\n\t\t\t\t\t//\t\t- we still create the converter to properly set up JDBC type, etc\n\t\t\t\t\tattributeConverterDescriptor = new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\t\tPassThruSoftDeleteConverter.INSTANCE,\n\t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( getSoftDeleteStrategy() == SoftDeleteType.ACTIVE ) {\n\t\t\t\tattributeConverterDescriptor = new ReversedConverterDescriptor<>( attributeConverterDescriptor );\n\t\t\t}\n\t\t}\n\n\t\treturn attributeConverterDescriptor != null\n\t\t\t\t? converterResolution( javaType, attributeConverterDescriptor )\n\t\t\t\t: resolution( explicitJavaType, javaType );\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.mapping;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\n\nimport org.hibernate.Incubating;\nimport org.hibernate.Internal;\nimport org.hibernate.MappingException;\nimport org.hibernate.TimeZoneStorageStrategy;\nimport org.hibernate.annotations.SoftDelete;\nimport org.hibernate.annotations.SoftDeleteType;\nimport org.hibernate.annotations.TimeZoneStorageType;\nimport org.hibernate.boot.model.TypeDefinition;\nimport org.hibernate.boot.model.convert.internal.AutoApplicableConverterDescriptorBypassedImpl;\nimport org.hibernate.boot.model.convert.internal.ClassBasedConverterDescriptor;\nimport org.hibernate.boot.model.convert.internal.InstanceBasedConverterDescriptor;\nimport org.hibernate.boot.model.convert.spi.AutoApplicableConverterDescriptor;\nimport org.hibernate.boot.model.convert.spi.ConverterDescriptor;\nimport org.hibernate.boot.model.convert.spi.JpaAttributeConverterCreationContext;\nimport org.hibernate.boot.model.process.internal.InferredBasicValueResolution;\nimport org.hibernate.boot.model.process.internal.InferredBasicValueResolver;\nimport org.hibernate.boot.model.process.internal.NamedBasicTypeResolution;\nimport org.hibernate.boot.model.process.internal.NamedConverterResolution;\nimport org.hibernate.boot.model.process.internal.UserTypeResolution;\nimport org.hibernate.boot.model.process.internal.VersionResolution;\nimport org.hibernate.boot.registry.StandardServiceRegistry;\nimport org.hibernate.boot.registry.classloading.spi.ClassLoaderService;\nimport org.hibernate.boot.registry.classloading.spi.ClassLoadingException;\nimport org.hibernate.boot.spi.MetadataBuildingContext;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.Size;\nimport org.hibernate.internal.CoreLogging;\nimport org.hibernate.internal.CoreMessageLogger;\nimport org.hibernate.internal.util.ReflectHelper;\nimport org.hibernate.internal.util.StringHelper;\nimport org.hibernate.internal.util.collections.CollectionHelper;\nimport org.hibernate.metamodel.mapping.JdbcMapping;\nimport org.hibernate.metamodel.mapping.SelectablePath;\nimport org.hibernate.resource.beans.internal.FallbackBeanInstanceProducer;\nimport org.hibernate.resource.beans.spi.BeanInstanceProducer;\nimport org.hibernate.resource.beans.spi.ManagedBean;\nimport org.hibernate.resource.beans.spi.ManagedBeanRegistry;\nimport org.hibernate.tool.schema.extract.spi.ColumnTypeInformation;\nimport org.hibernate.type.BasicType;\nimport org.hibernate.type.CustomType;\nimport org.hibernate.type.NumericBooleanConverter;\nimport org.hibernate.type.SqlTypes;\nimport org.hibernate.type.TrueFalseConverter;\nimport org.hibernate.type.Type;\nimport org.hibernate.type.WrapperArrayHandling;\nimport org.hibernate.type.descriptor.converter.spi.BasicValueConverter;\nimport org.hibernate.type.descriptor.converter.spi.JpaAttributeConverter;\nimport org.hibernate.type.descriptor.java.BasicJavaType;\nimport org.hibernate.type.descriptor.java.BasicPluralJavaType;\nimport org.hibernate.type.descriptor.java.JavaType;\nimport org.hibernate.type.descriptor.java.MutabilityPlan;\nimport org.hibernate.type.descriptor.java.spi.JavaTypeRegistry;\nimport org.hibernate.type.descriptor.java.spi.JsonJavaType;\nimport org.hibernate.type.descriptor.java.spi.RegistryHelper;\nimport org.hibernate.type.descriptor.java.spi.XmlJavaType;\nimport org.hibernate.type.descriptor.jdbc.BooleanJdbcType;\nimport org.hibernate.type.descriptor.jdbc.JdbcType;\nimport org.hibernate.type.descriptor.jdbc.JdbcTypeIndicators;\nimport org.hibernate.type.internal.BasicTypeImpl;\nimport org.hibernate.type.spi.TypeConfiguration;\nimport org.hibernate.type.spi.TypeConfigurationAware;\nimport org.hibernate.usertype.DynamicParameterizedType;\nimport org.hibernate.usertype.UserType;\n\nimport com.fasterxml.classmate.ResolvedType;\nimport jakarta.persistence.AttributeConverter;\nimport jakarta.persistence.EnumType;\nimport jakarta.persistence.TemporalType;\n\nimport static java.lang.Boolean.parseBoolean;\nimport static org.hibernate.internal.util.collections.CollectionHelper.isNotEmpty;\nimport static org.hibernate.mapping.MappingHelper.injectParameters;\n\n/**\n * @author Steve Ebersole\n */\npublic class BasicValue extends SimpleValue implements JdbcTypeIndicators, Resolvable, JpaAttributeConverterCreationContext {\n\tprivate static final CoreMessageLogger log = CoreLogging.messageLogger( BasicValue.class );\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// incoming \"configuration\" values\n\n\tprivate String explicitTypeName;\n\tprivate Map<String,String> explicitLocalTypeParams;\n\n\tprivate Function<TypeConfiguration, BasicJavaType> explicitJavaTypeAccess;\n\tprivate Function<TypeConfiguration, JdbcType> explicitJdbcTypeAccess;\n\tprivate Function<TypeConfiguration, MutabilityPlan> explicitMutabilityPlanAccess;\n\tprivate Function<TypeConfiguration, java.lang.reflect.Type> implicitJavaTypeAccess;\n\n\tprivate EnumType enumerationStyle;\n\tprivate TemporalType temporalPrecision;\n\tprivate TimeZoneStorageType timeZoneStorageType;\n\tprivate boolean isSoftDelete;\n\tprivate SoftDeleteType softDeleteStrategy;\n\n\tprivate java.lang.reflect.Type resolvedJavaType;\n\n\tprivate String ownerName;\n\tprivate String propertyName;\n\tprivate AggregateColumn aggregateColumn;\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// Resolved state - available after `#resolve`\n\tprivate Resolution<?> resolution;\n\tprivate Integer jdbcTypeCode;\n\n\n\tpublic BasicValue(MetadataBuildingContext buildingContext) {\n\t\tthis( buildingContext, null );\n\t}\n\n\tpublic BasicValue(MetadataBuildingContext buildingContext, Table table) {\n\t\tsuper( buildingContext, table );\n\t\tbuildingContext.getMetadataCollector().registerValueMappingResolver( this::resolve );\n\t}\n\n\tpublic BasicValue(BasicValue original) {\n\t\tsuper( original );\n\t\tthis.explicitTypeName = original.explicitTypeName;\n\t\tthis.explicitLocalTypeParams = original.explicitLocalTypeParams == null\n\t\t\t\t? null\n\t\t\t\t: new HashMap<>(original.explicitLocalTypeParams);\n\t\tthis.explicitJavaTypeAccess = original.explicitJavaTypeAccess;\n\t\tthis.explicitJdbcTypeAccess = original.explicitJdbcTypeAccess;\n\t\tthis.explicitMutabilityPlanAccess = original.explicitMutabilityPlanAccess;\n\t\tthis.implicitJavaTypeAccess = original.implicitJavaTypeAccess;\n\t\tthis.enumerationStyle = original.enumerationStyle;\n\t\tthis.temporalPrecision = original.temporalPrecision;\n\t\tthis.timeZoneStorageType = original.timeZoneStorageType;\n\t\tthis.resolvedJavaType = original.resolvedJavaType;\n\t\tthis.ownerName = original.ownerName;\n\t\tthis.propertyName = original.propertyName;\n\t}\n\n\t@Override\n\tpublic BasicValue copy() {\n\t\treturn new BasicValue( this );\n\t}\n\n\tpublic boolean isSoftDelete() {\n\t\treturn isSoftDelete;\n\t}\n\n\tpublic SoftDeleteType getSoftDeleteStrategy() {\n\t\treturn softDeleteStrategy;\n\t}\n\n\tpublic void makeSoftDelete(SoftDeleteType strategy) {\n\t\tisSoftDelete = true;\n\t\tsoftDeleteStrategy = strategy;\n\t}\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// Setters - in preparation of resolution\n\n\t@Override\n\tpublic void setTypeUsingReflection(String className, String propertyName) throws MappingException {\n\t\tif ( resolution != null ) {\n\t\t\tthrow new IllegalStateException( \"BasicValue already resolved\" );\n\t\t}\n\n\t\tthis.ownerName = className;\n\t\tthis.propertyName = propertyName;\n\n\t\tsuper.setTypeUsingReflection( className, propertyName );\n\t}\n\n\tpublic void setEnumerationStyle(EnumType enumerationStyle) {\n\t\tthis.enumerationStyle = enumerationStyle;\n\t}\n\n\tpublic EnumType getEnumerationStyle() {\n\t\treturn enumerationStyle;\n\t}\n\n\tpublic TimeZoneStorageType getTimeZoneStorageType() {\n\t\treturn timeZoneStorageType;\n\t}\n\n\tpublic void setTimeZoneStorageType(TimeZoneStorageType timeZoneStorageType) {\n\t\tthis.timeZoneStorageType = timeZoneStorageType;\n\t}\n\n\tpublic void setJpaAttributeConverterDescriptor(ConverterDescriptor descriptor) {\n\t\tsetAttributeConverterDescriptor( descriptor );\n\n\t\tsuper.setJpaAttributeConverterDescriptor( descriptor );\n\t}\n\n\t@SuppressWarnings(\"rawtypes\")\n\tpublic void setExplicitJavaTypeAccess(Function<TypeConfiguration, BasicJavaType> explicitJavaTypeAccess) {\n\t\tthis.explicitJavaTypeAccess = explicitJavaTypeAccess;\n\t}\n\n\tpublic void setExplicitJdbcTypeAccess(Function<TypeConfiguration, JdbcType> jdbcTypeAccess) {\n\t\tthis.explicitJdbcTypeAccess = jdbcTypeAccess;\n\t}\n\n\tpublic void setExplicitMutabilityPlanAccess(Function<TypeConfiguration, MutabilityPlan> explicitMutabilityPlanAccess) {\n\t\tthis.explicitMutabilityPlanAccess = explicitMutabilityPlanAccess;\n\t}\n\n\tpublic void setImplicitJavaTypeAccess(Function<TypeConfiguration, java.lang.reflect.Type> implicitJavaTypeAccess) {\n\t\tthis.implicitJavaTypeAccess = implicitJavaTypeAccess;\n\t}\n\n\tpublic Selectable getColumn() {\n\t\tif ( getColumnSpan() == 0 ) {\n\t\t\treturn null;\n\t\t}\n\t\treturn getColumn( 0 );\n\t}\n\n\tpublic java.lang.reflect.Type getResolvedJavaType() {\n\t\treturn resolvedJavaType;\n\t}\n\n\t@Override\n\tpublic long getColumnLength() {\n\t\tfinal Selectable selectable = getColumn();\n\t\tif ( selectable instanceof Column ) {\n\t\t\tfinal Column column = (Column) selectable;\n\t\t\tfinal Long length = column.getLength();\n\t\t\treturn length == null ? NO_COLUMN_LENGTH : length;\n\t\t}\n\t\telse {\n\t\t\treturn NO_COLUMN_LENGTH;\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getColumnPrecision() {\n\t\tfinal Selectable selectable = getColumn();\n\t\tif ( selectable instanceof Column ) {\n\t\t\tfinal Column column = (Column) selectable;\n\t\t\tif ( column.getTemporalPrecision() != null ) {\n\t\t\t\treturn column.getTemporalPrecision();\n\t\t\t}\n\t\t\tfinal Integer precision = column.getPrecision();\n\t\t\treturn precision == null ? NO_COLUMN_PRECISION : precision;\n\t\t}\n\t\telse {\n\t\t\treturn NO_COLUMN_PRECISION;\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getColumnScale() {\n\t\tfinal Selectable selectable = getColumn();\n\t\tif ( selectable instanceof Column ) {\n\t\t\tfinal Column column = (Column) selectable;\n\t\t\tfinal Integer scale = column.getScale();\n\t\t\treturn scale == null ? NO_COLUMN_SCALE : scale;\n\t\t}\n\t\telse {\n\t\t\treturn NO_COLUMN_SCALE;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void addColumn(Column incomingColumn) {\n\t\tsuper.addColumn( incomingColumn );\n\n\t\tcheckSelectable( incomingColumn );\n\t}\n\n\t@Override\n\tpublic void copyTypeFrom(SimpleValue sourceValue) {\n\t\tsuper.copyTypeFrom( sourceValue );\n\t\tif ( sourceValue instanceof BasicValue ) {\n\t\t\tfinal BasicValue basicValue = (BasicValue) sourceValue;\n\t\t\tthis.resolution = basicValue.resolution;\n\t\t\tthis.implicitJavaTypeAccess = (typeConfiguration) -> basicValue.implicitJavaTypeAccess.apply( typeConfiguration );\n\t\t}\n\t}\n\n\tprivate void checkSelectable(Selectable incomingColumn) {\n\t\tif ( incomingColumn == null ) {\n\t\t\tthrow new IllegalArgumentException( \"Incoming column was null\" );\n\t\t}\n\n\t\tfinal Selectable column = getColumn();\n\t\tif ( column == incomingColumn || column.getText().equals( incomingColumn.getText() ) ) {\n\t\t\tlog.debugf( \"Skipping column re-registration: %s.%s\", getTable().getName(), column.getText() );\n\t\t}\n//\t\telse {\n//\t\t\tthrow new IllegalStateException(\n//\t\t\t\t\t\"BasicValue [\" + ownerName + \".\" + propertyName +\n//\t\t\t\t\t\t\t\"] already had column associated: `\" + column.getText() +\n//\t\t\t\t\t\t\t\"` -> `\" + incomingColumn.getText() + \"`\"\n//\t\t\t);\n//\t\t}\n\t}\n\n\t@Override\n\tpublic void addColumn(Column incomingColumn, boolean isInsertable, boolean isUpdatable) {\n\t\tsuper.addColumn( incomingColumn, isInsertable, isUpdatable );\n\t\tcheckSelectable( incomingColumn );\n\t}\n\n\t@Override\n\tpublic void addFormula(Formula formula) {\n\t\tsuper.addFormula( formula );\n\n\t\tcheckSelectable( formula );\n\t}\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// Resolution\n\n\t@Override\n\tpublic Type getType() throws MappingException {\n\t\tresolve();\n\t\tassert getResolution() != null;\n\n\t\treturn getResolution().getLegacyResolvedBasicType();\n\t}\n\n\tpublic Resolution<?> getResolution() {\n\t\treturn resolution;\n\t}\n\n\t@Override\n\tpublic boolean resolve(MetadataBuildingContext buildingContext) {\n\t\tresolve();\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic Resolution<?> resolve() {\n\t\tif ( resolution != null ) {\n\t\t\treturn resolution;\n\t\t}\n\n\t\tresolution = buildResolution();\n\n\t\tif ( resolution == null ) {\n\t\t\tthrow new IllegalStateException( \"Unable to resolve BasicValue : \" + this );\n\t\t}\n\n\t\tfinal Selectable selectable = getColumn();\n\t\tfinal Size size;\n\t\tif ( selectable instanceof Column column ) {\n\t\t\tresolveColumn( column, getDialect() );\n\t\t\tsize = column.calculateColumnSize( getDialect(), getBuildingContext().getMetadataCollector() );\n\t\t}\n\t\telse {\n\t\t\tsize = Size.nil();\n\t\t}\n\n\t\tresolution.getJdbcType().addAuxiliaryDatabaseObjects(\n\t\t\t\tresolution.getRelationalJavaType(),\n\t\t\t\tresolution.getValueConverter(),\n\t\t\t\tsize,\n\t\t\t\tgetBuildingContext().getMetadataCollector().getDatabase(),\n\t\t\t\tthis\n\t\t);\n\n\t\treturn resolution;\n\t}\n\n\t@Override\n\tpublic String getExtraCreateTableInfo() {\n\t\treturn resolution.getJdbcType()\n\t\t\t\t.getExtraCreateTableInfo(\n\t\t\t\t\t\tresolution.getRelationalJavaType(),\n\t\t\t\t\t\tgetColumn().getText(),\n\t\t\t\t\t\tgetTable().getName(),\n\t\t\t\t\t\tgetBuildingContext().getMetadataCollector().getDatabase()\n\t\t\t\t);\n\t}\n\n\t@Override\n\tpublic Dialect getDialect() {\n\t\treturn getMetadata().getDatabase().getDialect();\n\t}\n\n\tprivate void resolveColumn(Column column, Dialect dialect) {\n\n\t\tif ( column.getSqlTypeCode() == null ) {\n\t\t\tcolumn.setSqlTypeCode( resolution.getJdbcType().getDdlTypeCode() );\n\t\t}\n\n//\t\tfinal String declaration = resolution.getLegacyResolvedBasicType().getSpecializedTypeDeclaration( dialect );\n//\t\tif ( declaration != null ) {\n//\t\t\tcolumn.setSpecializedTypeDeclaration( declaration );\n//\t\t}\n\n\t\tif ( dialect.supportsColumnCheck() ) {\n\t\t\tfinal String checkCondition = resolution.getLegacyResolvedBasicType()\n\t\t\t\t\t.getCheckCondition( column.getQuotedName( dialect ), dialect );\n\t\t\tif ( checkCondition != null ) {\n\t\t\t\tcolumn.addCheckConstraint( new CheckConstraint( checkCondition ) );\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic AggregateColumn getAggregateColumn() {\n\t\treturn aggregateColumn;\n\t}\n\n\tpublic void setAggregateColumn(AggregateColumn aggregateColumn) {\n\t\tthis.aggregateColumn = aggregateColumn;\n\t}\n\n\tpublic SelectablePath createSelectablePath(String selectableName) {\n\t\tif ( aggregateColumn != null ) {\n\t\t\treturn aggregateColumn.getSelectablePath().append( selectableName );\n\t\t}\n\t\treturn new SelectablePath( selectableName );\n\t}\n\n\tprotected Resolution<?> buildResolution() {\n\t\tfinal Properties typeParameters = getTypeParameters();\n\t\tif ( typeParameters != null\n\t\t\t\t&& parseBoolean( typeParameters.getProperty(DynamicParameterizedType.IS_DYNAMIC) )\n\t\t\t\t&& typeParameters.get(DynamicParameterizedType.PARAMETER_TYPE) == null ) {\n\t\t\tcreateParameterImpl();\n\t\t}\n\n\t\tif ( explicitTypeName != null ) {\n\t\t\treturn interpretExplicitlyNamedType(\n\t\t\t\t\texplicitTypeName,\n\t\t\t\t\texplicitJavaTypeAccess,\n\t\t\t\t\texplicitJdbcTypeAccess,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tgetAttributeConverterDescriptor(),\n\t\t\t\t\ttypeParameters,\n\t\t\t\t\tthis::setTypeParameters,\n\t\t\t\t\tthis,\n\t\t\t\t\tgetBuildingContext()\n\t\t\t);\n\t\t}\n\n\t\tif ( isVersion() ) {\n\t\t\treturn VersionResolution.from( implicitJavaTypeAccess, timeZoneStorageType, getBuildingContext() );\n\t\t}\n\n\t\t// determine JavaType if we can\n\t\tfinal BasicJavaType<?> explicitJavaType = explicitJavaTypeAccess == null\n\t\t\t\t? null\n\t\t\t\t: explicitJavaTypeAccess.apply( getTypeConfiguration() );\n\n\t\tJavaType<?> javaType = determineJavaType( explicitJavaType );\n\t\tConverterDescriptor attributeConverterDescriptor = getAttributeConverterDescriptor();\n\n\t\tif ( isSoftDelete() ) {\n\t\t\tassert attributeConverterDescriptor != null;\n\t\t\tfinal boolean conversionWasUnspecified = SoftDelete.UnspecifiedConversion.class.equals( attributeConverterDescriptor.getAttributeConverterClass() );\n\t\t\tif ( conversionWasUnspecified ) {\n\t\t\t\tfinal JdbcType jdbcType = BooleanJdbcType.INSTANCE.resolveIndicatedType( this, javaType );\n\t\t\t\tif ( jdbcType.isNumber() ) {\n\t\t\t\t\tattributeConverterDescriptor = new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\t\tNumericBooleanConverter.INSTANCE,\n\t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\telse if ( jdbcType.isString() ) {\n\t\t\t\t\t// here we pick 'T' / 'F' storage, though 'Y' / 'N' is equally valid - its 50/50\n\t\t\t\t\tattributeConverterDescriptor = new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\t\tTrueFalseConverter.INSTANCE,\n\t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// should indicate BIT or BOOLEAN == no conversion needed\n\t\t\t\t\t//\t\t- we still create the converter to properly set up JDBC type, etc\n\t\t\t\t\tattributeConverterDescriptor = new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\t\tPassThruSoftDeleteConverter.INSTANCE,\n\t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( getSoftDeleteStrategy() == SoftDeleteType.ACTIVE ) {\n\t\t\t\tattributeConverterDescriptor = new ReversedConverterDescriptor<>( attributeConverterDescriptor );\n\t\t\t}\n\t\t}\n\n\t\treturn attributeConverterDescriptor != null\n\t\t\t\t? converterResolution( javaType, attributeConverterDescriptor )\n\t\t\t\t: resolution( explicitJavaType, javaType );\n\t}\n\n\tprivate static class ReversedConverterDescriptor<R> implements ConverterDescriptor {\n\t\tprivate final ConverterDescriptor underlyingDescriptor;\n\n\t\tpublic ReversedConverterDescriptor(ConverterDescriptor underlyingDescriptor) {\n\t\t\tthis.underlyingDescriptor = underlyingDescriptor;\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<? extends AttributeConverter<Boolean,R>> getAttributeConverterClass() {\n\t\t\t//noinspection unchecked\n\t\t\treturn (Class<? extends AttributeConverter<Boolean, R>>) getClass();\n\t\t}\n\n\t\t@Override\n\t\tpublic ResolvedType getDomainValueResolvedType() {\n\t\t\treturn underlyingDescriptor.getDomainValueResolvedType();\n\t\t}\n\n\t\t@Override\n\t\tpublic ResolvedType getRelationalValueResolvedType() {\n\t\t\treturn underlyingDescriptor.getRelationalValueResolvedType();\n\t\t}\n\n\t\t@Override\n\t\tpublic AutoApplicableConverterDescriptor getAutoApplyDescriptor() {\n\t\t\treturn AutoApplicableConverterDescriptorBypassedImpl.INSTANCE;\n\t\t}\n\n\t\t@Override\n\t\tpublic JpaAttributeConverter<Boolean,R> createJpaAttributeConverter(JpaAttributeConverterCreationContext context) {\n\t\t\t//noinspection unchecked\n\t\t\treturn new ReversedJpaAttributeConverter<>(\n\t\t\t\t\t(JpaAttributeConverter<Boolean, R>) underlyingDescriptor.createJpaAttributeConverter( context ),\n\t\t\t\t\tcontext.getJavaTypeRegistry().getDescriptor( ReversedJpaAttributeConverter.class )\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate static class ReversedJpaAttributeConverter<R, B extends AttributeConverter<Boolean, R>>\n\t\t\timplements JpaAttributeConverter<Boolean,R>, AttributeConverter<Boolean,R>, ManagedBean<B> {\n\t\tprivate final JpaAttributeConverter<Boolean,R> underlyingJpaConverter;\n\t\tprivate final JavaType<ReversedJpaAttributeConverter<R,B>> converterJavaType;\n\n\t\tpublic ReversedJpaAttributeConverter(\n\t\t\t\tJpaAttributeConverter<Boolean, R> underlyingJpaConverter,\n\t\t\t\tJavaType<ReversedJpaAttributeConverter<R,B>> converterJavaType) {\n\t\t\tthis.underlyingJpaConverter = underlyingJpaConverter;\n\t\t\tthis.converterJavaType = converterJavaType;\n\t\t}\n\n\t\t@Override\n\t\tpublic Boolean toDomainValue(R relationalValue) {\n\t\t\treturn !underlyingJpaConverter.toDomainValue( relationalValue );\n\t\t}\n\n\t\t@Override\n\t\tpublic R toRelationalValue(Boolean domainValue) {\n\t\t\treturn underlyingJpaConverter.toRelationalValue( domainValue != null ? !domainValue : null );\n\t\t}\n\n\t\t@Override\n\t\tpublic Boolean convertToEntityAttribute(R relationalValue) {\n\t\t\treturn toDomainValue( relationalValue );\n\t\t}\n\n\t\t@Override\n\t\tpublic R convertToDatabaseColumn(Boolean domainValue) {\n\t\t\treturn toRelationalValue( domainValue );\n\t\t}\n\n\t\t@Override\n\t\tpublic JavaType<Boolean> getDomainJavaType() {\n\t\t\treturn underlyingJpaConverter.getDomainJavaType();\n\t\t}\n\n\t\t@Override\n\t\tpublic JavaType<R> getRelationalJavaType() {\n\t\t\treturn underlyingJpaConverter.getRelationalJavaType();\n\t\t}\n\n\t\t@Override\n\t\tpublic JavaType<? extends AttributeConverter<Boolean, R>> getConverterJavaType() {\n\t\t\treturn converterJavaType;\n\t\t}\n\n\t\t@Override\n\t\tpublic ManagedBean<? extends AttributeConverter<Boolean, R>> getConverterBean() {\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<B> getBeanClass() {\n\t\t\t//noinspection unchecked\n\t\t\treturn (Class<B>) getClass();\n\t\t}\n\n\t\t@Override\n\t\tpublic B getBeanInstance() {\n\t\t\t//noinspection unchecked\n\t\t\treturn (B) this;\n\t\t}\n\t}\n\n\tprivate static class PassThruSoftDeleteConverter implements AttributeConverter<Boolean,Boolean> {\n\t\tprivate static final PassThruSoftDeleteConverter INSTANCE = new PassThruSoftDeleteConverter();\n\n\t\t@Override\n\t\tpublic Boolean convertToDatabaseColumn(Boolean domainValue) {\n\t\t\treturn domainValue;\n\t\t}\n\n\t\t@Override\n\t\tpublic Boolean convertToEntityAttribute(Boolean relationalValue) {\n\t\t\treturn relationalValue;\n\t\t}\n\t}\n\n\tprivate Resolution<?> resolution(BasicJavaType explicitJavaType, JavaType<?> javaType) {\n\t\tfinal JavaType<?> basicJavaType;\n\t\tfinal JdbcType jdbcType;\n\t\tif ( explicitJdbcTypeAccess != null ) {\n\t\t\tfinal TypeConfiguration typeConfiguration = getTypeConfiguration();\n\t\t\tjdbcType = explicitJdbcTypeAccess.apply( typeConfiguration );\n\t\t\tbasicJavaType = javaType == null && jdbcType != null\n\t\t\t\t\t? jdbcType.getJdbcRecommendedJavaTypeMapping(null, null, typeConfiguration)\n\t\t\t\t\t: javaType;\n\t\t}\n\t\telse {\n\t\t\tjdbcType = null;\n\t\t\tbasicJavaType = javaType;\n\t\t}\n\t\tif ( basicJavaType == null ) {\n\t\t\tthrow new MappingException( \"Unable to determine JavaType to use : \" + this );\n\t\t}\n\n\t\tif ( basicJavaType instanceof BasicJavaType<?>\n\t\t\t\t&& ( !basicJavaType.getJavaTypeClass().isEnum() || enumerationStyle == null ) ) {\n\t\t\tfinal TypeDefinition autoAppliedTypeDef =\n\t\t\t\t\tgetBuildingContext().getTypeDefinitionRegistry()\n\t\t\t\t\t\t\t.resolveAutoApplied( (BasicJavaType<?>) basicJavaType );\n\t\t\tif ( autoAppliedTypeDef != null ) {\n\t\t\t\tlog.debug(\"BasicValue resolution matched auto-applied type-definition\");\n\t\t\t\treturn autoAppliedTypeDef.resolve( getTypeParameters(), null, getBuildingContext(), this );\n\t\t\t}\n\t\t}\n\n\t\treturn InferredBasicValueResolver.from(\n\t\t\t\texplicitJavaType,\n\t\t\t\tjdbcType,\n\t\t\t\tresolvedJavaType,\n\t\t\t\tthis::determineReflectedJavaType,\n\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\tthis,\n\t\t\t\tgetTable(),\n\t\t\t\tgetColumn(),\n\t\t\t\townerName,\n\t\t\t\tpropertyName,\n\t\t\t\tgetBuildingContext()\n\t\t);\n\t}\n\n\t@Override\n\tpublic ManagedBeanRegistry getManagedBeanRegistry() {\n\t\treturn getServiceRegistry().requireService( ManagedBeanRegistry.class );\n\t}\n\n\tprivate Resolution<?> converterResolution(JavaType<?> javaType, ConverterDescriptor attributeConverterDescriptor) {\n\t\tfinal NamedConverterResolution<?> converterResolution = NamedConverterResolution.from(\n\t\t\t\tattributeConverterDescriptor,\n\t\t\t\texplicitJavaTypeAccess,\n\t\t\t\texplicitJdbcTypeAccess,\n\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\tresolvedJavaType,\n\t\t\t\tthis,\n\t\t\t\tthis,\n\t\t\t\tgetBuildingContext()\n\t\t);\n\n\t\tif ( javaType instanceof BasicPluralJavaType<?>\n\t\t\t\t&& !attributeConverterDescriptor.getDomainValueResolvedType().getErasedType()\n\t\t\t\t\t\t.isAssignableFrom( javaType.getJavaTypeClass() ) ) {\n\t\t\t// In this case, the converter applies to the element of a BasicPluralJavaType\n\t\t\tfinal BasicPluralJavaType<?> containerJtd = (BasicPluralJavaType<?>) javaType;\n\t\t\tfinal BasicType registeredElementType = converterResolution.getLegacyResolvedBasicType();\n\t\t\tfinal Selectable column = getColumn();\n\t\t\tfinal BasicType<?> registeredType = registeredElementType == null ? null\n\t\t\t\t\t: containerJtd.resolveType(\n\t\t\t\t\t\t\tgetTypeConfiguration(),\n\t\t\t\t\t\t\tgetDialect(),\n\t\t\t\t\t\t\tregisteredElementType,\n\t\t\t\t\t\t\tcolumn instanceof ColumnTypeInformation ? (ColumnTypeInformation) column : null,\n\t\t\t\t\t\t\tthis\n\t\t\t);\n\t\t\tif ( registeredType != null ) {\n\t\t\t\tgetTypeConfiguration().getBasicTypeRegistry().register( registeredType );\n\t\t\t\treturn new InferredBasicValueResolution(\n\t\t\t\t\t\tregisteredType,\n\t\t\t\t\t\tregisteredType.getJavaTypeDescriptor(),\n\t\t\t\t\t\tregisteredType.getJavaTypeDescriptor(),\n\t\t\t\t\t\tregisteredType.getJdbcType(),\n\t\t\t\t\t\tregisteredType,\n\t\t\t\t\t\tnull\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn converterResolution;\n\t}\n\n\tprivate JavaType<?> determineJavaType(JavaType<?> explicitJavaType) {\n\t\tJavaType<?> javaType = explicitJavaType;\n//\n//\t\tif ( javaType == null ) {\n//\t\t\tif ( implicitJavaTypeAccess != null ) {\n//\t\t\t\tfinal java.lang.reflect.Type implicitJtd = implicitJavaTypeAccess.apply( getTypeConfiguration() );\n//\t\t\t\tif ( implicitJtd != null ) {\n//\t\t\t\t\tjavaType = getTypeConfiguration().getJavaTypeRegistry().getDescriptor( implicitJtd );\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n\n\t\tif ( javaType == null ) {\n\t\t\tfinal JavaType<?> reflectedJtd = determineReflectedJavaType();\n\t\t\tif ( reflectedJtd != null ) {\n\t\t\t\tjavaType = reflectedJtd;\n\t\t\t}\n\t\t}\n\n\t\treturn javaType;\n\t}\n\n\tprivate JavaType<?> determineReflectedJavaType() {\n\t\tfinal java.lang.reflect.Type impliedJavaType;\n\n\t\tfinal TypeConfiguration typeConfiguration = getTypeConfiguration();\n\t\tif ( resolvedJavaType != null ) {\n\t\t\timpliedJavaType = resolvedJavaType;\n\t\t}\n\t\telse if ( implicitJavaTypeAccess != null ) {\n\t\t\timpliedJavaType = implicitJavaTypeAccess.apply( typeConfiguration );\n\t\t}\n\t\telse if ( ownerName != null && propertyName != null ) {\n\t\t\timpliedJavaType = ReflectHelper.reflectedPropertyType(\n\t\t\t\t\townerName,\n\t\t\t\t\tpropertyName,\n\t\t\t\t\tgetServiceRegistry().requireService( ClassLoaderService.class )\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\n\t\tresolvedJavaType = impliedJavaType;\n\n\t\tif ( impliedJavaType == null ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal JavaTypeRegistry javaTypeRegistry = typeConfiguration.getJavaTypeRegistry();\n\t\tfinal JavaType<Object> javaType = javaTypeRegistry.findDescriptor( impliedJavaType );\n\t\tfinal MutabilityPlan<Object> explicitMutabilityPlan = explicitMutabilityPlanAccess != null\n\t\t\t\t? explicitMutabilityPlanAccess.apply( typeConfiguration )\n\t\t\t\t: null;\n\t\tfinal MutabilityPlan<Object> determinedMutabilityPlan = explicitMutabilityPlan != null\n\t\t\t\t? explicitMutabilityPlan\n\t\t\t\t: RegistryHelper.INSTANCE.determineMutabilityPlan( impliedJavaType, typeConfiguration );\n\t\tif ( javaType == null ) {\n\t\t\tif ( jdbcTypeCode != null ) {\n\t\t\t\t// Construct special JavaType instances for JSON/XML types which can report recommended JDBC types\n\t\t\t\t// and implement toString/fromString as well as copying based on FormatMapper operations\n\t\t\t\tswitch ( jdbcTypeCode ) {\n\t\t\t\t\tcase SqlTypes.JSON:\n\t\t\t\t\t\tfinal JavaType<Object> jsonJavaType = new JsonJavaType<>(\n\t\t\t\t\t\t\t\timpliedJavaType,\n\t\t\t\t\t\t\t\tdeterminedMutabilityPlan,\n\t\t\t\t\t\t\t\ttypeConfiguration\n\t\t\t\t\t\t);\n\t\t\t\t\t\tjavaTypeRegistry.addDescriptor( jsonJavaType );\n\t\t\t\t\t\treturn jsonJavaType;\n\t\t\t\t\tcase SqlTypes.SQLXML:\n\t\t\t\t\t\tfinal JavaType<Object> xmlJavaType = new XmlJavaType<>(\n\t\t\t\t\t\t\t\timpliedJavaType,\n\t\t\t\t\t\t\t\tdeterminedMutabilityPlan,\n\t\t\t\t\t\t\t\ttypeConfiguration\n\t\t\t\t\t\t);\n\t\t\t\t\t\tjavaTypeRegistry.addDescriptor( xmlJavaType );\n\t\t\t\t\t\treturn xmlJavaType;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn javaTypeRegistry.resolveDescriptor( impliedJavaType );\n\t\t}\n\t\treturn javaType;\n\t}\n\n\tprivate static Resolution<?> interpretExplicitlyNamedType(\n\t\t\tString name,\n\t\t\tFunction<TypeConfiguration, BasicJavaType> explicitJtdAccess,\n\t\t\tFunction<TypeConfiguration, JdbcType> explicitStdAccess,\n\t\t\tFunction<TypeConfiguration, MutabilityPlan> explicitMutabilityPlanAccess,\n\t\t\tConverterDescriptor converterDescriptor,\n\t\t\tMap<Object,Object> localTypeParams,\n\t\t\tConsumer<Properties> combinedParameterConsumer,\n\t\t\tJdbcTypeIndicators stdIndicators,\n\t\t\tMetadataBuildingContext context) {\n\n\t\tfinal StandardServiceRegistry serviceRegistry = context.getBootstrapContext().getServiceRegistry();\n\t\tfinal ManagedBeanRegistry managedBeanRegistry = serviceRegistry.requireService( ManagedBeanRegistry.class );\n\t\tfinal TypeConfiguration typeConfiguration = context.getBootstrapContext().getTypeConfiguration();\n\n\t\tfinal JpaAttributeConverterCreationContext converterCreationContext = new JpaAttributeConverterCreationContext() {\n\t\t\t@Override\n\t\t\tpublic ManagedBeanRegistry getManagedBeanRegistry() {\n\t\t\t\treturn managedBeanRegistry;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic TypeConfiguration getTypeConfiguration() {\n\t\t\t\treturn typeConfiguration;\n\t\t\t}\n\t\t};\n\n\t\t// Name could refer to:\n\t\t//\t\t1) a named converter - HBM support for JPA's AttributeConverter via its `type=\"...\"` XML attribute\n\t\t//\t\t2) a \"named composed\" mapping - like (1), this is mainly to support envers since it tells\n\t\t//\t\t\tHibernate the mappings via DOM.  See `org.hibernate.type.internal.BasicTypeImpl`\n\t\t//\t\t3) basic type \"resolution key\"\n\t\t//\t\t4) UserType or BasicType class name - directly, or through a TypeDefinition\n\n\t\tif ( name.startsWith( ConverterDescriptor.TYPE_NAME_PREFIX  ) ) {\n\t\t\treturn NamedConverterResolution.from(\n\t\t\t\t\tname,\n\t\t\t\t\texplicitJtdAccess,\n\t\t\t\t\texplicitStdAccess,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tstdIndicators,\n\t\t\t\t\tconverterCreationContext,\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\n//\t\tif ( name.startsWith( EnumeratedValueResolution.PREFIX ) ) {\n//\t\t\treturn EnumeratedValueResolution.fromName( name, stdIndicators, context );\n//\t\t}\n\n\t\tif ( name.startsWith( BasicTypeImpl.EXTERNALIZED_PREFIX ) ) {\n\t\t\tfinal BasicType<Object> basicType = context.getBootstrapContext().resolveAdHocBasicType( name );\n\t\t\treturn new NamedBasicTypeResolution<>(\n\t\t\t\t\tbasicType.getJavaTypeDescriptor(),\n\t\t\t\t\tbasicType,\n\t\t\t\t\tnull,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\n\t\t// see if it is a named basic type\n\t\tfinal BasicType<?> basicTypeByName = typeConfiguration.getBasicTypeRegistry().getRegisteredType( name );\n\t\tif ( basicTypeByName != null ) {\n\t\t\tfinal BasicValueConverter<?,?> valueConverter;\n\t\t\tfinal JavaType<?> domainJtd;\n\t\t\tif ( converterDescriptor != null ) {\n\t\t\t\tvalueConverter = converterDescriptor.createJpaAttributeConverter( converterCreationContext );\n\t\t\t\tdomainJtd = valueConverter.getDomainJavaType();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalueConverter = basicTypeByName.getValueConverter();\n\t\t\t\tdomainJtd = basicTypeByName.getJavaTypeDescriptor();\n\t\t\t}\n\n\t\t\treturn new NamedBasicTypeResolution<>(\n\t\t\t\t\tdomainJtd,\n\t\t\t\t\tbasicTypeByName,\n\t\t\t\t\tvalueConverter,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\n\t\t// see if it is a named TypeDefinition\n\t\tfinal TypeDefinition typeDefinition = context.getTypeDefinitionRegistry().resolve( name );\n\t\tif ( typeDefinition != null ) {\n\t\t\tfinal Resolution<?> resolution = typeDefinition.resolve(\n\t\t\t\t\tlocalTypeParams,\n\t\t\t\t\texplicitMutabilityPlanAccess != null\n\t\t\t\t\t\t\t? explicitMutabilityPlanAccess.apply( typeConfiguration )\n\t\t\t\t\t\t\t: null,\n\t\t\t\t\tcontext,\n\t\t\t\t\tstdIndicators\n\t\t\t);\n\t\t\tcombinedParameterConsumer.accept( resolution.getCombinedTypeParameters() );\n\t\t\treturn resolution;\n\t\t}\n\n\n\t\t// see if the name is a UserType or BasicType implementor class name\n\t\tfinal ClassLoaderService cls = serviceRegistry.requireService( ClassLoaderService.class );\n\t\ttry {\n\t\t\tfinal Class<?> typeNamedClass = cls.classForName( name );\n\n\t\t\t// if there are no local config params, register an implicit TypeDefinition for this custom type .\n\t\t\t//  later uses may find it and re-use its cacheable reference...\n\t\t\tif ( CollectionHelper.isEmpty( localTypeParams ) ) {\n\t\t\t\tfinal TypeDefinition implicitDefinition = new TypeDefinition(\n\t\t\t\t\t\tname,\n\t\t\t\t\t\ttypeNamedClass,\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\tnull\n\t\t\t\t);\n\t\t\t\tcontext.getTypeDefinitionRegistry().register( implicitDefinition );\n\t\t\t\treturn implicitDefinition.resolve(\n\t\t\t\t\t\tlocalTypeParams,\n\t\t\t\t\t\texplicitMutabilityPlanAccess != null\n\t\t\t\t\t\t\t\t? explicitMutabilityPlanAccess.apply( typeConfiguration )\n\t\t\t\t\t\t\t\t: null,\n\t\t\t\t\t\tcontext,\n\t\t\t\t\t\tstdIndicators\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn TypeDefinition.createLocalResolution( name, typeNamedClass, localTypeParams, context );\n\t\t}\n\t\tcatch (ClassLoadingException e) {\n\t\t\t// allow the exception below to trigger\n\t\t\tlog.debugf( \"Could not resolve type-name [%s] as Java type : %s\", name, e );\n\t\t}\n\n\t\tthrow new MappingException( \"Could not resolve named type : \" + name );\n\t}\n\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// SqlTypeDescriptorIndicators\n\n\t@Override\n\tpublic EnumType getEnumeratedType() {\n\t\treturn getEnumerationStyle();\n\t}\n\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForBoolean() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForBoolean() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForDuration() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForDuration() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForUuid() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForUuid() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForInstant() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForInstant() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForArray() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForArray() );\n\t}\n\n\t@Override\n\tpublic int resolveJdbcTypeCode(int jdbcTypeCode) {\n\t\treturn aggregateColumn == null\n\t\t\t\t? jdbcTypeCode\n\t\t\t\t: getDialect().getAggregateSupport()\n\t\t\t\t.aggregateComponentSqlTypeCode( aggregateColumn.getSqlTypeCode( getMetadata() ), jdbcTypeCode );\n\t}\n\n\t@Override\n\tpublic TimeZoneStorageStrategy getDefaultTimeZoneStorageStrategy() {\n\t\treturn timeZoneStorageStrategy( timeZoneStorageType, getBuildingContext() );\n\t}\n\n\t@Internal\n\tpublic static TimeZoneStorageStrategy timeZoneStorageStrategy(\n\t\t\tTimeZoneStorageType timeZoneStorageType,\n\t\t\tMetadataBuildingContext buildingContext) {\n\t\tif ( timeZoneStorageType != null ) {\n\t\t\tswitch ( timeZoneStorageType ) {\n\t\t\t\tcase COLUMN:\n\t\t\t\t\treturn TimeZoneStorageStrategy.COLUMN;\n\t\t\t\tcase NATIVE:\n\t\t\t\t\treturn TimeZoneStorageStrategy.NATIVE;\n\t\t\t\tcase NORMALIZE:\n\t\t\t\t\treturn TimeZoneStorageStrategy.NORMALIZE;\n\t\t\t\tcase NORMALIZE_UTC:\n\t\t\t\t\treturn TimeZoneStorageStrategy.NORMALIZE_UTC;\n\t\t\t}\n\t\t}\n\t\treturn buildingContext.getBuildingOptions().getDefaultTimeZoneStorage();\n\t}\n\n\tpublic void setExplicitTypeParams(Map<String,String> explicitLocalTypeParams) {\n\t\tthis.explicitLocalTypeParams = explicitLocalTypeParams;\n\t}\n\n\tpublic void setExplicitTypeName(String typeName) {\n\t\tthis.explicitTypeName = typeName;\n\t}\n\n\tpublic void setTypeName(String typeName) {\n\t\tif ( StringHelper.isNotEmpty( typeName ) ) {\n\t\t\tif ( typeName.startsWith( ConverterDescriptor.TYPE_NAME_PREFIX ) ) {\n\t\t\t\tfinal String converterClassName = typeName.substring( ConverterDescriptor.TYPE_NAME_PREFIX.length() );\n\t\t\t\tfinal ClassLoaderService cls = getServiceRegistry().requireService( ClassLoaderService.class );\n\t\t\t\ttry {\n\t\t\t\t\tfinal Class<AttributeConverter<?,?>> converterClass = cls.classForName( converterClassName );\n\t\t\t\t\tsetAttributeConverterDescriptor( new ClassBasedConverterDescriptor(\n\t\t\t\t\t\t\tconverterClass,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t\t) );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tlog.logBadHbmAttributeConverterType( typeName, e.getMessage() );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsetExplicitTypeName( typeName );\n\t\t\t}\n\t\t}\n\n\t\tsuper.setTypeName( typeName );\n\t}\n\n\tprivate static int COUNTER;\n\n\tpublic void setExplicitCustomType(Class<? extends UserType<?>> explicitCustomType) {\n\t\tif ( explicitCustomType != null ) {\n\t\t\tif ( resolution != null ) {\n\t\t\t\tthrow new UnsupportedOperationException( \"Unsupported attempt to set an explicit-custom-type when value is already resolved\" );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresolution = new UserTypeResolution<>(\n\t\t\t\t\t\tnew CustomType<>(\n\t\t\t\t\t\t\t\tgetConfiguredUserTypeBean( explicitCustomType, getCustomTypeProperties() ),\n\t\t\t\t\t\t\t\tgetTypeConfiguration()\n\t\t\t\t\t\t),\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\tgetCustomTypeProperties()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate Properties getCustomTypeProperties() {\n\t\tfinal Properties properties = new Properties();\n\t\tif ( isNotEmpty( getTypeParameters() ) ) {\n\t\t\tproperties.putAll( getTypeParameters() );\n\t\t}\n\t\tif ( isNotEmpty( explicitLocalTypeParams ) ) {\n\t\t\tproperties.putAll( explicitLocalTypeParams );\n\t\t}\n\t\treturn properties;\n\t}\n\n\tprivate UserType<?> getConfiguredUserTypeBean(Class<? extends UserType<?>> explicitCustomType, Properties properties) {\n\t\tfinal UserType<?> typeInstance =\n\t\t\t\t!getBuildingContext().getBuildingOptions().isAllowExtensionsInCdi()\n\t\t\t\t\t\t? FallbackBeanInstanceProducer.INSTANCE.produceBeanInstance( explicitCustomType )\n\t\t\t\t\t\t: getUserTypeBean( explicitCustomType, properties ).getBeanInstance();\n\n\t\tif ( typeInstance instanceof TypeConfigurationAware ) {\n\t\t\tfinal TypeConfigurationAware configurationAware = (TypeConfigurationAware) typeInstance;\n\t\t\tconfigurationAware.setTypeConfiguration( getTypeConfiguration() );\n\t\t}\n\n\t\tif ( typeInstance instanceof DynamicParameterizedType ) {\n\t\t\tif ( parseBoolean( properties.getProperty( DynamicParameterizedType.IS_DYNAMIC ) ) ) {\n\t\t\t\tif ( properties.get( DynamicParameterizedType.PARAMETER_TYPE ) == null ) {\n\t\t\t\t\tproperties.put( DynamicParameterizedType.PARAMETER_TYPE, makeParameterImpl() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tinjectParameters( typeInstance, properties);\n\t\t// envers - grr\n\t\tsetTypeParameters( properties );\n\n\t\treturn typeInstance;\n\t}\n\n\tprivate <T> ManagedBean<T> getUserTypeBean(Class<T> explicitCustomType, Properties properties) {\n\t\tfinal BeanInstanceProducer producer = getBuildingContext().getBootstrapContext().getCustomTypeProducer();\n\t\tfinal ManagedBeanRegistry registry = getServiceRegistry().requireService( ManagedBeanRegistry.class );\n\t\tif ( isNotEmpty( properties ) ) {\n\t\t\tfinal String name = explicitCustomType.getName() + COUNTER++;\n\t\t\treturn registry.getBean( name, explicitCustomType, producer );\n\t\t}\n\t\telse {\n\t\t\treturn registry.getBean( explicitCustomType, producer );\n\t\t}\n\t}\n\n\tpublic void setTemporalPrecision(TemporalType temporalPrecision) {\n\t\tthis.temporalPrecision = temporalPrecision;\n\t}\n\n\t@Override\n\tpublic TemporalType getTemporalPrecision() {\n\t\treturn temporalPrecision;\n\t}\n\n\t@Override\n\tpublic boolean isPreferJavaTimeJdbcTypesEnabled() {\n\t\treturn getBuildingContext().isPreferJavaTimeJdbcTypesEnabled();\n\t}\n\n\t@Override\n\tpublic boolean isPreferNativeEnumTypesEnabled() {\n\t\treturn getBuildingContext().isPreferNativeEnumTypesEnabled();\n\t}\n\n\t@Override\n\tpublic Object accept(ValueVisitor visitor) {\n\t\treturn visitor.accept(this);\n\t}\n\n\t@Internal\n\tpublic boolean isDisallowedWrapperArray() {\n\t\treturn getBuildingContext().getBuildingOptions().getWrapperArrayHandling() == WrapperArrayHandling.DISALLOW\n\t\t\t&& !isLob()\n\t\t\t&& ( explicitJavaTypeAccess == null || explicitJavaTypeAccess.apply( getTypeConfiguration() ) == null )\n\t\t\t&& isWrapperByteOrCharacterArray();\n\t}\n\n\tprivate boolean isWrapperByteOrCharacterArray() {\n\t\tfinal Class<?> javaTypeClass = getResolution().getDomainJavaType().getJavaTypeClass();\n\t\treturn javaTypeClass == Byte[].class || javaTypeClass == Character[].class;\n\t}\n\n\t@Incubating\n\tpublic void setExplicitJdbcTypeCode(Integer jdbcTypeCode) {\n\t\tthis.jdbcTypeCode = jdbcTypeCode;\n\t}\n\n\t@Override\n\tpublic Integer getExplicitJdbcTypeCode() {\n\t\treturn jdbcTypeCode == null ? getPreferredSqlTypeCodeForArray() : jdbcTypeCode;\n\t}\n\n\t/**\n\t * Resolved form of {@link BasicValue} as part of interpreting the\n\t * boot-time model into the run-time model\n\t */\n\tpublic interface Resolution<J> {\n\t\t/**\n\t\t * The BasicType resolved using the pre-6.0 rules.  This is temporarily\n\t\t * needed because of the split in extracting / binding\n\t\t */\n\t\tBasicType<J> getLegacyResolvedBasicType();\n\n\t\t/**\n\t\t * Get the collection of type-parameters collected both locally as well\n\t\t * as from the applied type-def, if one\n\t\t */\n\t\tdefault Properties getCombinedTypeParameters() {\n\t\t\treturn null;\n\t\t}\n\n\t\tJdbcMapping getJdbcMapping();\n\n\t\t/**\n\t\t * The JavaType for the value as part of the domain model\n\t\t */\n\t\tJavaType<J> getDomainJavaType();\n\n\t\t/**\n\t\t * The JavaType for the relational value as part of\n\t\t * the relational model (its JDBC representation)\n\t\t */\n\t\tJavaType<?> getRelationalJavaType();\n\n\t\t/**\n\t\t * The JavaType for the relational value as part of\n\t\t * the relational model (its JDBC representation)\n\t\t */\n\t\tJdbcType getJdbcType();\n\n\t\t/**\n\t\t * Converter, if any, to convert values between the\n\t\t * domain and relational JavaType representations\n\t\t */\n\t\tBasicValueConverter<J,?> getValueConverter();\n\n\t\t/**\n\t\t * The resolved MutabilityPlan\n\t\t */\n\t\tMutabilityPlan<J> getMutabilityPlan();\n\n\t\tdefault void updateResolution(BasicType<?> type) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate verifyOutcome(statementDetails PreparedStatementDetails, affectedRowCount int, batchPosition int) : boolean extracted from protected doDynamicInserts(id Object, values Object[], object Object, session SharedSessionContractImplementor, forceIdentifierBinding boolean) : GeneratedValues in class org.hibernate.persister.entity.mutation.InsertCoordinatorStandard",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/persister/entity/mutation/InsertCoordinatorStandard.java",
                "startLine": 296,
                "endLine": 333,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/persister/entity/mutation/InsertCoordinatorStandard.java",
                "startLine": 290,
                "endLine": 320,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/persister/entity/mutation/InsertCoordinatorStandard.java",
                "startLine": 322,
                "endLine": 331,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "protected GeneratedValues doDynamicInserts(\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\n\t\tfinal boolean[] insertability = getPropertiesToInsert( values );\n\t\tfinal MutationOperationGroup insertGroup = generateDynamicInsertSqlGroup( insertability, object, session, forceIdentifierBinding );\n\n\t\tfinal MutationExecutor mutationExecutor = executor( session, insertGroup, true );\n\n\t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n\n\t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n\n\t\tdecomposeForInsert( mutationExecutor, id, values, insertGroup, insertability, tableInclusionChecker, session );\n\n\t\ttry {\n\t\t\treturn mutationExecutor.execute(\n\t\t\t\t\tobject,\n\t\t\t\t\tinsertValuesAnalysis,\n\t\t\t\t\ttableInclusionChecker,\n\t\t\t\t\t(statementDetails, affectedRowCount, batchPosition) -> {\n\t\t\t\t\t\tstatementDetails.getExpectation().verifyOutcome(\n\t\t\t\t\t\t\t\taffectedRowCount,\n\t\t\t\t\t\t\t\tstatementDetails.getStatement(),\n\t\t\t\t\t\t\t\tbatchPosition,\n\t\t\t\t\t\t\t\tstatementDetails.getSqlString()\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tmutationExecutor.release();\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/persister/entity/mutation/InsertCoordinatorStandard.java",
        "isPureRefactoring": true,
        "commitId": "ee00217733018075ccade7e1145f45ff9acae0c2",
        "packageNameBefore": "org.hibernate.persister.entity.mutation",
        "classNameBefore": "org.hibernate.persister.entity.mutation.InsertCoordinatorStandard",
        "methodNameBefore": "org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#doDynamicInserts",
        "invokedMethod": "methodSignature: org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#getPropertiesToInsert\n methodBody: public boolean[] getPropertiesToInsert(Object[] fields) {\nboolean[] notNull=new boolean[fields.length];\nboolean[] insertable=entityPersister().getPropertyInsertability();\nfor(int i=0; i < fields.length; i++){notNull[i]=insertable[i] && fields[i] != null;\n}return notNull;\n}\nmethodSignature: org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#decomposeForInsert\n methodBody: protected void decomposeForInsert(\n\t\t\tMutationExecutor mutationExecutor,\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tMutationOperationGroup mutationGroup,\n\t\t\tboolean[] propertyInclusions,\n\t\t\tTableInclusionChecker tableInclusionChecker,\n\t\t\tSharedSessionContractImplementor session) {\nfinal JdbcValueBindings jdbcValueBindings=mutationExecutor.getJdbcValueBindings();\nfinal AttributeMappingsList attributeMappings=entityPersister().getAttributeMappings();\nfor(int position=0; position < mutationGroup.getNumberOfOperations(); position++){final MutationOperation operation=mutationGroup.getOperation(position);\nfinal EntityTableMapping tableDetails=(EntityTableMapping)operation.getTableDetails();\nif(tableInclusionChecker.include(tableDetails)){final int[] attributeIndexes=tableDetails.getAttributeIndexes();\nfor(int i=0; i < attributeIndexes.length; i++){final int attributeIndex=attributeIndexes[i];\nif(propertyInclusions[attributeIndex]){final AttributeMapping mapping=attributeMappings.get(attributeIndex);\ndecomposeAttribute(values[attributeIndex],session,jdbcValueBindings,mapping);\n}}}}if(id == null){assert entityPersister().getInsertDelegate() != null;\n}{for(int position=0; position < mutationGroup.getNumberOfOperations(); position++){final MutationOperation jdbcOperation=mutationGroup.getOperation(position);\nfinal EntityTableMapping tableDetails=(EntityTableMapping)jdbcOperation.getTableDetails();\nbreakDownJdbcValue(id,session,jdbcValueBindings,tableDetails);\n}}}\nmethodSignature: org.hibernate.engine.jdbc.mutation.internal.MutationExecutorStandard#release\n methodBody: public void release() {\nnonBatchedStatementGroup.release();\n}\nmethodSignature: org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#getTableInclusionChecker\n methodBody: protected static TableInclusionChecker getTableInclusionChecker(InsertValuesAnalysis insertValuesAnalysis) {\nreturn tableMapping -> !tableMapping.isOptional() || insertValuesAnalysis.hasNonNullBindings(tableMapping);\n}\nmethodSignature: org.hibernate.engine.jdbc.mutation.internal.AbstractMutationExecutor#execute\n methodBody: public final GeneratedValues execute(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session) {\nfinal GeneratedValues generatedValues=performNonBatchedOperations(modelReference,valuesAnalysis,inclusionChecker,resultChecker,session);\nperformSelfExecutingOperations(valuesAnalysis,inclusionChecker,session);\nperformBatchedOperations(valuesAnalysis,inclusionChecker);\nreturn generatedValues;\n}\nmethodSignature: org.hibernate.orm.test.jpa.transaction.batch.AbstractBatchingTest.BatchWrapper#execute\n methodBody: public void execute() {\nwrapped.execute();\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#execute\n methodBody: void execute();\nmethodSignature: org.hibernate.orm.test.jpa.transaction.batch.AbstractBatchingTest.BatchWrapper#release\n methodBody: public void release() {\nwasReleaseCalled=true;\nwrapped.release();\nnumberOfStatementsAfterRelease=wrapped.getStatementGroup().getNumberOfActiveStatements();\n}\nmethodSignature: org.hibernate.persister.entity.mutation.AbstractDeleteCoordinator#executor\n methodBody: private MutationExecutor executor(SharedSessionContractImplementor session, MutationOperationGroup group) {\nreturn mutationExecutorService.createExecutor(resolveBatchKeyAccess(false,session),group,session);\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.BatchImpl#execute\n methodBody: public void execute() {\nnotifyObserversExplicitExecution();\nif(getStatementGroup().getNumberOfStatements() == 0){return;\n}tryif(batchPosition == 0){if(!batchExecuted){if(BATCH_LOGGER.isDebugEnabled()){BATCH_LOGGER.debugf(\"No batched statements to execute - %s\",getKey().toLoggableString());\n}}}{performExecution();\n}finallyreleaseStatements();\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#release\n methodBody: void release();\nmethodSignature: org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#generateDynamicInsertSqlGroup\n methodBody: protected MutationOperationGroup generateDynamicInsertSqlGroup(\n\t\t\tboolean[] insertable,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\nfinal MutationGroupBuilder insertGroupBuilder=new MutationGroupBuilder(MutationType.INSERT,entityPersister());\nentityPersister().forEachMutableTable((tableMapping) -> insertGroupBuilder.addTableDetailsBuilder(createTableInsertBuilder(tableMapping,forceIdentifierBinding)));\napplyTableInsertDetails(insertGroupBuilder,insertable,object,session,forceIdentifierBinding);\nreturn createOperationGroup(null,insertGroupBuilder.buildMutationGroup());\n}\nmethodSignature: org.hibernate.engine.jdbc.mutation.internal.MutationExecutorSingleBatched#release\n methodBody: public void release() {\n}\nmethodSignature: org.hibernate.engine.jdbc.mutation.MutationExecutor#release\n methodBody: void release();\nmethodSignature: org.hibernate.persister.entity.mutation.UpdateCoordinatorStandard#executor\n methodBody: private MutationExecutor executor(SharedSessionContractImplementor session, MutationOperationGroup group, boolean dynamicUpdate) {\nreturn mutationExecutorService.createExecutor(resolveBatchKeyAccess(dynamicUpdate,session),group,session);\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.BatchImpl#release\n methodBody: public void release() {\nif(BATCH_MESSAGE_LOGGER.isInfoEnabled()){final PreparedStatementGroup statementGroup=getStatementGroup();\nif(statementGroup.getNumberOfStatements() != 0){if(statementGroup.hasMatching((statementDetails) -> statementDetails.getStatement() != null)){BATCH_MESSAGE_LOGGER.batchContainedStatementsOnRelease();\n}}}releaseStatements();\nobservers.clear();\n}\nmethodSignature: org.hibernate.persister.entity.mutation.AbstractMutationCoordinator#entityPersister\n methodBody: protected EntityPersister entityPersister() {\nreturn entityPersister;\n}\nmethodSignature: org.hibernate.engine.jdbc.mutation.MutationExecutor#execute\n methodBody: GeneratedValues execute(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session);\nmethodSignature: org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#executor\n methodBody: private MutationExecutor executor(SharedSessionContractImplementor session, MutationOperationGroup group, boolean dynamicUpdate) {\nreturn mutationExecutorService.createExecutor(resolveBatchKeyAccess(dynamicUpdate,session),group,session);\n}",
        "classSignatureBefore": "public class InsertCoordinatorStandard extends AbstractMutationCoordinator implements InsertCoordinator ",
        "methodNameBeforeSet": [
            "org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#doDynamicInserts"
        ],
        "classNameBeforeSet": [
            "org.hibernate.persister.entity.mutation.InsertCoordinatorStandard"
        ],
        "classSignatureBeforeSet": [
            "public class InsertCoordinatorStandard extends AbstractMutationCoordinator implements InsertCoordinator "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html.\n */\npackage org.hibernate.persister.entity.mutation;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.hibernate.Internal;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.batch.internal.BasicBatchKey;\nimport org.hibernate.engine.jdbc.batch.spi.BatchKey;\nimport org.hibernate.engine.jdbc.mutation.JdbcValueBindings;\nimport org.hibernate.engine.jdbc.mutation.MutationExecutor;\nimport org.hibernate.engine.jdbc.mutation.ParameterUsage;\nimport org.hibernate.engine.jdbc.mutation.TableInclusionChecker;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.engine.spi.SharedSessionContractImplementor;\nimport org.hibernate.generator.BeforeExecutionGenerator;\nimport org.hibernate.generator.Generator;\nimport org.hibernate.generator.OnExecutionGenerator;\nimport org.hibernate.generator.values.GeneratedValues;\nimport org.hibernate.generator.values.GeneratedValuesMutationDelegate;\nimport org.hibernate.metamodel.mapping.AttributeMapping;\nimport org.hibernate.metamodel.mapping.AttributeMappingsList;\nimport org.hibernate.metamodel.mapping.BasicEntityIdentifierMapping;\nimport org.hibernate.metamodel.mapping.PluralAttributeMapping;\nimport org.hibernate.persister.entity.EntityPersister;\nimport org.hibernate.sql.model.MutationOperation;\nimport org.hibernate.sql.model.MutationOperationGroup;\nimport org.hibernate.sql.model.MutationType;\nimport org.hibernate.sql.model.TableMapping;\nimport org.hibernate.sql.model.ValuesAnalysis;\nimport org.hibernate.sql.model.ast.builder.MutationGroupBuilder;\nimport org.hibernate.sql.model.ast.builder.TableInsertBuilder;\nimport org.hibernate.sql.model.ast.builder.TableInsertBuilderStandard;\nimport org.hibernate.sql.model.ast.builder.TableMutationBuilder;\nimport org.hibernate.tuple.entity.EntityMetamodel;\n\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport static org.hibernate.generator.EventType.INSERT;\n\n/**\n * Coordinates the insertion of an entity.\n *\n * @see #coordinateInsert\n *\n * @author Steve Ebersole\n */\n@Internal\npublic class InsertCoordinatorStandard extends AbstractMutationCoordinator implements InsertCoordinator {\n\tprivate final MutationOperationGroup staticInsertGroup;\n\tprivate final BasicBatchKey batchKey;\n\n\tpublic InsertCoordinatorStandard(EntityPersister entityPersister, SessionFactoryImplementor factory) {\n\t\tsuper( entityPersister, factory );\n\n\t\tif ( entityPersister.isIdentifierAssignedByInsert() || entityPersister.hasInsertGeneratedProperties() ) {\n\t\t\t// disable batching in case of insert generated identifier or properties\n\t\t\tbatchKey = null;\n\t\t}\n\t\telse {\n\t\t\tbatchKey = new BasicBatchKey( entityPersister.getEntityName() + \"#INSERT\" );\n\t\t}\n\n\t\tif ( entityPersister.getEntityMetamodel().isDynamicInsert() ) {\n\t\t\t// the entity specified dynamic-insert - skip generating the\n\t\t\t// static inserts as we will create them every time\n\t\t\tstaticInsertGroup = null;\n\t\t}\n\t\telse {\n\t\t\tstaticInsertGroup = generateStaticOperationGroup();\n\t\t}\n\t}\n\n\t@Override\n\tpublic MutationOperationGroup getStaticMutationOperationGroup() {\n\t\treturn staticInsertGroup;\n\t}\n\n\t@Override\n\tprotected BatchKey getBatchKey() {\n\t\treturn batchKey;\n\t}\n\n\t@Override\n\tpublic @Nullable GeneratedValues insert(Object entity, Object[] values, SharedSessionContractImplementor session) {\n\t\treturn coordinateInsert( null, values, entity, session );\n\t}\n\n\t@Override\n\tpublic @Nullable GeneratedValues insert(\n\t\t\tObject entity,\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tSharedSessionContractImplementor session) {\n\t\treturn coordinateInsert( id, values, entity, session );\n\t}\n\n\t/**\n\t * Perform the insert(s).\n\t *\n\t * @param id This is the id as known in memory. For post-insert id generation (IDENTITY, etc)\n\t * this will be null.\n\t * @param values The extracted attribute values\n\t * @param entity The entity instance being persisted\n\t * @param session The originating context\n\t *\n\t * @return The {@linkplain GeneratedValues generated values} if any, {@code null} otherwise.\n\t */\n\tpublic GeneratedValues coordinateInsert(\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tObject entity,\n\t\t\tSharedSessionContractImplementor session) {\n\t\t// apply any pre-insert in-memory value generation\n\t\tfinal boolean needsDynamicInsert = preInsertInMemoryValueGeneration( values, entity, session );\n\n\t\tfinal EntityMetamodel entityMetamodel = entityPersister().getEntityMetamodel();\n\t\tfinal boolean forceIdentifierBinding = entityPersister().getGenerator().generatedOnExecution() && id != null;\n\t\tif ( entityMetamodel.isDynamicInsert() || needsDynamicInsert || forceIdentifierBinding ) {\n\t\t\treturn doDynamicInserts( id, values, entity, session, forceIdentifierBinding );\n\t\t}\n\t\telse {\n\t\t\treturn doStaticInserts( id, values, entity, session );\n\t\t}\n\t}\n\n\tprotected boolean preInsertInMemoryValueGeneration(Object[] values, Object entity, SharedSessionContractImplementor session) {\n\t\tfinal EntityPersister persister = entityPersister();\n\t\tfinal EntityMetamodel entityMetamodel = persister.getEntityMetamodel();\n\t\tboolean foundStateDependentGenerator = false;\n\t\tif ( entityMetamodel.hasPreInsertGeneratedValues() ) {\n\t\t\tfinal Generator[] generators = entityMetamodel.getGenerators();\n\t\t\tfor ( int i = 0; i < generators.length; i++ ) {\n\t\t\t\tfinal Generator generator = generators[i];\n\t\t\t\tif ( generator != null\n\t\t\t\t\t\t&& generator.generatesOnInsert()\n\t\t\t\t\t\t&& !generator.generatedOnExecution( entity, session ) ) {\n\t\t\t\t\tvalues[i] = ( (BeforeExecutionGenerator) generator ).generate( session, entity, values[i], INSERT );\n\t\t\t\t\tpersister.setPropertyValue( entity, i, values[i] );\n\t\t\t\t\tfoundStateDependentGenerator = foundStateDependentGenerator || generator.generatedOnExecution();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn foundStateDependentGenerator;\n\t}\n\n\tpublic static class InsertValuesAnalysis implements ValuesAnalysis {\n\t\tprivate final List<TableMapping> tablesWithNonNullValues = new ArrayList<>();\n\n\t\tpublic InsertValuesAnalysis(EntityMutationTarget mutationTarget, Object[] values) {\n\t\t\tmutationTarget.forEachMutableTable( (tableMapping) -> {\n\t\t\t\tfinal int[] tableAttributeIndexes = tableMapping.getAttributeIndexes();\n\t\t\t\tfor ( int i = 0; i < tableAttributeIndexes.length; i++ ) {\n\t\t\t\t\tif ( values[tableAttributeIndexes[i]] != null ) {\n\t\t\t\t\t\ttablesWithNonNullValues.add( tableMapping );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\tpublic boolean hasNonNullBindings(TableMapping tableMapping) {\n\t\t\treturn tablesWithNonNullValues.contains( tableMapping );\n\t\t}\n\t}\n\n\tprotected GeneratedValues doStaticInserts(Object id, Object[] values, Object object, SharedSessionContractImplementor session) {\n\t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n\n\t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n\n\t\tfinal MutationExecutor mutationExecutor = executor( session, staticInsertGroup, false );\n\n\t\tdecomposeForInsert(\n\t\t\t\tmutationExecutor,\n\t\t\t\tid,\n\t\t\t\tvalues,\n\t\t\t\tstaticInsertGroup,\n\t\t\t\tentityPersister().getPropertyInsertability(),\n\t\t\t\ttableInclusionChecker,\n\t\t\t\tsession\n\t\t);\n\n\t\ttry {\n\t\t\treturn mutationExecutor.execute(\n\t\t\t\t\tobject,\n\t\t\t\t\tinsertValuesAnalysis,\n\t\t\t\t\ttableInclusionChecker,\n\t\t\t\t\t(statementDetails, affectedRowCount, batchPosition) -> {\n\t\t\t\t\t\tstatementDetails.getExpectation().verifyOutcome(\n\t\t\t\t\t\t\t\taffectedRowCount,\n\t\t\t\t\t\t\t\tstatementDetails.getStatement(),\n\t\t\t\t\t\t\t\tbatchPosition,\n\t\t\t\t\t\t\t\tstatementDetails.getSqlString()\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tmutationExecutor.release();\n\t\t}\n\t}\n\n\tprotected void decomposeForInsert(\n\t\t\tMutationExecutor mutationExecutor,\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tMutationOperationGroup mutationGroup,\n\t\t\tboolean[] propertyInclusions,\n\t\t\tTableInclusionChecker tableInclusionChecker,\n\t\t\tSharedSessionContractImplementor session) {\n\t\tfinal JdbcValueBindings jdbcValueBindings = mutationExecutor.getJdbcValueBindings();\n\t\tfinal AttributeMappingsList attributeMappings = entityPersister().getAttributeMappings();\n\n\t\tfor ( int position = 0; position < mutationGroup.getNumberOfOperations(); position++ ) {\n\t\t\tfinal MutationOperation operation = mutationGroup.getOperation( position );\n\t\t\tfinal EntityTableMapping tableDetails = (EntityTableMapping) operation.getTableDetails();\n\t\t\tif ( tableInclusionChecker.include( tableDetails ) ) {\n\t\t\t\tfinal int[] attributeIndexes = tableDetails.getAttributeIndexes();\n\t\t\t\tfor ( int i = 0; i < attributeIndexes.length; i++ ) {\n\t\t\t\t\tfinal int attributeIndex = attributeIndexes[ i ];\n\t\t\t\t\tif ( propertyInclusions[attributeIndex] ) {\n\t\t\t\t\t\tfinal AttributeMapping mapping = attributeMappings.get( attributeIndex );\n\t\t\t\t\t\tdecomposeAttribute( values[attributeIndex], session, jdbcValueBindings, mapping );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( id == null ) {\n\t\t\tassert entityPersister().getInsertDelegate() != null;\n\t\t}\n\t\telse {\n\t\t\tfor ( int position = 0; position < mutationGroup.getNumberOfOperations(); position++ ) {\n\t\t\t\tfinal MutationOperation jdbcOperation = mutationGroup.getOperation( position );\n\t\t\t\tfinal EntityTableMapping tableDetails = (EntityTableMapping) jdbcOperation.getTableDetails();\n\t\t\t\tbreakDownJdbcValue( id, session, jdbcValueBindings, tableDetails );\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected void breakDownJdbcValue(\n\t\t\tObject id,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tJdbcValueBindings jdbcValueBindings,\n\t\t\tEntityTableMapping tableDetails) {\n\t\tfinal String tableName = tableDetails.getTableName();\n\t\ttableDetails.getKeyMapping().breakDownKeyJdbcValues(\n\t\t\t\tid,\n\t\t\t\t(jdbcValue, columnMapping) -> {\n\t\t\t\t\tjdbcValueBindings.bindValue(\n\t\t\t\t\t\t\tjdbcValue,\n\t\t\t\t\t\t\ttableName,\n\t\t\t\t\t\t\tcolumnMapping.getColumnName(),\n\t\t\t\t\t\t\tParameterUsage.SET\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t\tsession\n\t\t);\n\t}\n\n\tprotected void decomposeAttribute(\n\t\t\tObject value,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tJdbcValueBindings jdbcValueBindings,\n\t\t\tAttributeMapping mapping) {\n\t\tif ( !(mapping instanceof PluralAttributeMapping) ) {\n\t\t\tmapping.decompose(\n\t\t\t\t\tvalue,\n\t\t\t\t\t0,\n\t\t\t\t\tjdbcValueBindings,\n\t\t\t\t\tnull,\n\t\t\t\t\t(valueIndex, bindings, noop, jdbcValue, selectableMapping) -> {\n\t\t\t\t\t\tif ( selectableMapping.isInsertable() ) {\n\t\t\t\t\t\t\tbindings.bindValue(\n\t\t\t\t\t\t\t\t\tjdbcValue,\n\t\t\t\t\t\t\t\t\tentityPersister().physicalTableNameForMutation( selectableMapping ),\n\t\t\t\t\t\t\t\t\tselectableMapping.getSelectionExpression(),\n\t\t\t\t\t\t\t\t\tParameterUsage.SET\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t}\n\n\tprotected GeneratedValues doDynamicInserts(\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\n\t\tfinal boolean[] insertability = getPropertiesToInsert( values );\n\t\tfinal MutationOperationGroup insertGroup = generateDynamicInsertSqlGroup( insertability, object, session, forceIdentifierBinding );\n\n\t\tfinal MutationExecutor mutationExecutor = executor( session, insertGroup, true );\n\n\t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n\n\t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n\n\t\tdecomposeForInsert( mutationExecutor, id, values, insertGroup, insertability, tableInclusionChecker, session );\n\n\t\ttry {\n\t\t\treturn mutationExecutor.execute(\n\t\t\t\t\tobject,\n\t\t\t\t\tinsertValuesAnalysis,\n\t\t\t\t\ttableInclusionChecker,\n\t\t\t\t\t(statementDetails, affectedRowCount, batchPosition) -> {\n\t\t\t\t\t\tstatementDetails.getExpectation().verifyOutcome(\n\t\t\t\t\t\t\t\taffectedRowCount,\n\t\t\t\t\t\t\t\tstatementDetails.getStatement(),\n\t\t\t\t\t\t\t\tbatchPosition,\n\t\t\t\t\t\t\t\tstatementDetails.getSqlString()\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tmutationExecutor.release();\n\t\t}\n\t}\n\n\tprivate MutationExecutor executor(SharedSessionContractImplementor session, MutationOperationGroup group, boolean dynamicUpdate) {\n\t\treturn mutationExecutorService\n\t\t\t\t.createExecutor( resolveBatchKeyAccess( dynamicUpdate, session ), group, session );\n\t}\n\n\tprotected static TableInclusionChecker getTableInclusionChecker(InsertValuesAnalysis insertValuesAnalysis) {\n\t\treturn tableMapping -> !tableMapping.isOptional() || insertValuesAnalysis.hasNonNullBindings( tableMapping );\n\t}\n\n\n\t/**\n\t * Transform the array of property indexes to an array of booleans,\n\t * true when the property is insertable and non-null\n\t */\n\tpublic boolean[] getPropertiesToInsert(Object[] fields) {\n\t\tboolean[] notNull = new boolean[fields.length];\n\t\tboolean[] insertable = entityPersister().getPropertyInsertability();\n\t\tfor ( int i = 0; i < fields.length; i++ ) {\n\t\t\tnotNull[i] = insertable[i] && fields[i] != null;\n\t\t}\n\t\treturn notNull;\n\t}\n\n\tprotected MutationOperationGroup generateDynamicInsertSqlGroup(\n\t\t\tboolean[] insertable,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\n\t\tfinal MutationGroupBuilder insertGroupBuilder = new MutationGroupBuilder( MutationType.INSERT, entityPersister() );\n\t\tentityPersister().forEachMutableTable(\n\t\t\t\t(tableMapping) -> insertGroupBuilder.addTableDetailsBuilder( createTableInsertBuilder( tableMapping, forceIdentifierBinding ) )\n\t\t);\n\t\tapplyTableInsertDetails( insertGroupBuilder, insertable, object, session, forceIdentifierBinding );\n\t\treturn createOperationGroup( null, insertGroupBuilder.buildMutationGroup() );\n\t}\n\n\tpublic MutationOperationGroup generateStaticOperationGroup() {\n\t\tfinal MutationGroupBuilder insertGroupBuilder = new MutationGroupBuilder( MutationType.INSERT, entityPersister() );\n\t\tentityPersister().forEachMutableTable(\n\t\t\t\t(tableMapping) -> insertGroupBuilder.addTableDetailsBuilder( createTableInsertBuilder( tableMapping, false ) )\n\t\t);\n\t\tapplyTableInsertDetails( insertGroupBuilder, entityPersister().getPropertyInsertability(), null, null, false );\n\t\treturn createOperationGroup( null, insertGroupBuilder.buildMutationGroup() );\n\t}\n\n\tprivate TableMutationBuilder<?> createTableInsertBuilder(EntityTableMapping tableMapping, boolean forceIdentifierBinding) {\n\t\tfinal GeneratedValuesMutationDelegate delegate = entityPersister().getInsertDelegate();\n\t\tif ( tableMapping.isIdentifierTable() && delegate != null && !forceIdentifierBinding ) {\n\t\t\treturn delegate.createTableMutationBuilder( tableMapping.getInsertExpectation(), factory() );\n\t\t}\n\t\telse {\n\t\t\treturn new TableInsertBuilderStandard( entityPersister(), tableMapping, factory() );\n\t\t}\n\t}\n\n\tprivate void applyTableInsertDetails(\n\t\t\tMutationGroupBuilder insertGroupBuilder,\n\t\t\tboolean[] attributeInclusions,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\n\t\tfinal AttributeMappingsList attributeMappings = entityPersister().getAttributeMappings();\n\n\t\tinsertGroupBuilder.forEachTableMutationBuilder( (builder) -> {\n\t\t\tfinal EntityTableMapping tableMapping = (EntityTableMapping) builder.getMutatingTable().getTableMapping();\n\t\t\tassert !tableMapping.isInverse();\n\n\t\t\t// `attributeIndexes` represents the indexes (relative to `attributeMappings`) of\n\t\t\t// the attributes mapped to the table\n\t\t\tfinal int[] attributeIndexes = tableMapping.getAttributeIndexes();\n\t\t\tfor ( int i = 0; i < attributeIndexes.length; i++ ) {\n\t\t\t\tfinal int attributeIndex = attributeIndexes[ i ];\n\t\t\t\tfinal AttributeMapping attributeMapping = attributeMappings.get( attributeIndex );\n\t\t\t\tif ( attributeInclusions[attributeIndex] ) {\n\t\t\t\t\tattributeMapping.forEachInsertable( insertGroupBuilder );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfinal Generator generator = attributeMapping.getGenerator();\n\t\t\t\t\tif ( isValueGenerated( generator ) ) {\n\t\t\t\t\t\tif ( session != null && !generator.generatedOnExecution( object, session ) ) {\n\t\t\t\t\t\t\tattributeInclusions[attributeIndex] = true;\n\t\t\t\t\t\t\tattributeMapping.forEachInsertable( insertGroupBuilder );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ( isValueGenerationInSql( generator, factory().getJdbcServices().getDialect() ) ) {\n\t\t\t\t\t\t\thandleValueGeneration( attributeMapping, insertGroupBuilder, (OnExecutionGenerator) generator );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t\t// add the discriminator\n\t\tentityPersister().addDiscriminatorToInsertGroup( insertGroupBuilder );\n\t\tentityPersister().addSoftDeleteToInsertGroup( insertGroupBuilder );\n\n\t\t// add the keys\n\t\tinsertGroupBuilder.forEachTableMutationBuilder( (tableMutationBuilder) -> {\n\t\t\tfinal TableInsertBuilder tableInsertBuilder = (TableInsertBuilder) tableMutationBuilder;\n\t\t\tfinal EntityTableMapping tableMapping = (EntityTableMapping) tableInsertBuilder.getMutatingTable().getTableMapping();\n\t\t\tif ( tableMapping.isIdentifierTable() && entityPersister().isIdentifierAssignedByInsert() && !forceIdentifierBinding ) {\n\t\t\t\tassert entityPersister().getInsertDelegate() != null;\n\t\t\t\tfinal OnExecutionGenerator generator = (OnExecutionGenerator) entityPersister().getGenerator();\n\t\t\t\tif ( generator.referenceColumnsInSql( dialect() ) ) {\n\t\t\t\t\tfinal BasicEntityIdentifierMapping identifierMapping = (BasicEntityIdentifierMapping) entityPersister().getIdentifierMapping();\n\t\t\t\t\tfinal String[] columnValues = generator.getReferencedColumnValues( dialect );\n\t\t\t\t\ttableMapping.getKeyMapping().forEachKeyColumn( (i, column) -> tableInsertBuilder.addKeyColumn(\n\t\t\t\t\t\t\tcolumn.getColumnName(),\n\t\t\t\t\t\t\tcolumnValues[i],\n\t\t\t\t\t\t\tidentifierMapping.getJdbcMapping()\n\t\t\t\t\t) );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttableMapping.getKeyMapping().forEachKeyColumn( tableInsertBuilder::addKeyColumn );\n\t\t\t}\n\t\t} );\n\t}\n\n\tprivate static boolean isValueGenerated(Generator generator) {\n\t\treturn generator != null\n\t\t\t\t&& generator.generatesOnInsert()\n\t\t\t\t&& generator.generatedOnExecution();\n\t}\n\n\tprivate static boolean isValueGenerationInSql(Generator generator, Dialect dialect) {\n\t\tassert isValueGenerated( generator );\n\t\treturn ( (OnExecutionGenerator) generator ).referenceColumnsInSql(dialect);\n\t}\n\n\t/**\n\t * @deprecated Use {@link #getBatchKey()}\n\t */\n\t@Deprecated\n\tpublic BasicBatchKey getInsertBatchKey() {\n\t\treturn batchKey;\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/persister/entity/mutation/InsertCoordinatorStandard.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html.\n */\npackage org.hibernate.persister.entity.mutation;\n\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.hibernate.Internal;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.batch.internal.BasicBatchKey;\nimport org.hibernate.engine.jdbc.batch.spi.BatchKey;\nimport org.hibernate.engine.jdbc.mutation.JdbcValueBindings;\nimport org.hibernate.engine.jdbc.mutation.MutationExecutor;\nimport org.hibernate.engine.jdbc.mutation.ParameterUsage;\nimport org.hibernate.engine.jdbc.mutation.TableInclusionChecker;\nimport org.hibernate.engine.jdbc.mutation.group.PreparedStatementDetails;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.engine.spi.SharedSessionContractImplementor;\nimport org.hibernate.generator.BeforeExecutionGenerator;\nimport org.hibernate.generator.Generator;\nimport org.hibernate.generator.OnExecutionGenerator;\nimport org.hibernate.generator.values.GeneratedValues;\nimport org.hibernate.generator.values.GeneratedValuesMutationDelegate;\nimport org.hibernate.metamodel.mapping.AttributeMapping;\nimport org.hibernate.metamodel.mapping.AttributeMappingsList;\nimport org.hibernate.metamodel.mapping.BasicEntityIdentifierMapping;\nimport org.hibernate.metamodel.mapping.PluralAttributeMapping;\nimport org.hibernate.persister.entity.EntityPersister;\nimport org.hibernate.sql.model.MutationOperation;\nimport org.hibernate.sql.model.MutationOperationGroup;\nimport org.hibernate.sql.model.MutationType;\nimport org.hibernate.sql.model.TableMapping;\nimport org.hibernate.sql.model.ValuesAnalysis;\nimport org.hibernate.sql.model.ast.builder.MutationGroupBuilder;\nimport org.hibernate.sql.model.ast.builder.TableInsertBuilder;\nimport org.hibernate.sql.model.ast.builder.TableInsertBuilderStandard;\nimport org.hibernate.sql.model.ast.builder.TableMutationBuilder;\nimport org.hibernate.tuple.entity.EntityMetamodel;\n\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport static org.hibernate.generator.EventType.INSERT;\n\n/**\n * Coordinates the insertion of an entity.\n *\n * @see #coordinateInsert\n *\n * @author Steve Ebersole\n */\n@Internal\npublic class InsertCoordinatorStandard extends AbstractMutationCoordinator implements InsertCoordinator {\n\tprivate final MutationOperationGroup staticInsertGroup;\n\tprivate final BasicBatchKey batchKey;\n\n\tpublic InsertCoordinatorStandard(EntityPersister entityPersister, SessionFactoryImplementor factory) {\n\t\tsuper( entityPersister, factory );\n\n\t\tif ( entityPersister.isIdentifierAssignedByInsert() || entityPersister.hasInsertGeneratedProperties() ) {\n\t\t\t// disable batching in case of insert generated identifier or properties\n\t\t\tbatchKey = null;\n\t\t}\n\t\telse {\n\t\t\tbatchKey = new BasicBatchKey( entityPersister.getEntityName() + \"#INSERT\" );\n\t\t}\n\n\t\tif ( entityPersister.getEntityMetamodel().isDynamicInsert() ) {\n\t\t\t// the entity specified dynamic-insert - skip generating the\n\t\t\t// static inserts as we will create them every time\n\t\t\tstaticInsertGroup = null;\n\t\t}\n\t\telse {\n\t\t\tstaticInsertGroup = generateStaticOperationGroup();\n\t\t}\n\t}\n\n\t@Override\n\tpublic MutationOperationGroup getStaticMutationOperationGroup() {\n\t\treturn staticInsertGroup;\n\t}\n\n\t@Override\n\tprotected BatchKey getBatchKey() {\n\t\treturn batchKey;\n\t}\n\n\t@Override\n\tpublic @Nullable GeneratedValues insert(Object entity, Object[] values, SharedSessionContractImplementor session) {\n\t\treturn coordinateInsert( null, values, entity, session );\n\t}\n\n\t@Override\n\tpublic @Nullable GeneratedValues insert(\n\t\t\tObject entity,\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tSharedSessionContractImplementor session) {\n\t\treturn coordinateInsert( id, values, entity, session );\n\t}\n\n\t/**\n\t * Perform the insert(s).\n\t *\n\t * @param id This is the id as known in memory. For post-insert id generation (IDENTITY, etc)\n\t * this will be null.\n\t * @param values The extracted attribute values\n\t * @param entity The entity instance being persisted\n\t * @param session The originating context\n\t *\n\t * @return The {@linkplain GeneratedValues generated values} if any, {@code null} otherwise.\n\t */\n\tpublic GeneratedValues coordinateInsert(\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tObject entity,\n\t\t\tSharedSessionContractImplementor session) {\n\t\t// apply any pre-insert in-memory value generation\n\t\tfinal boolean needsDynamicInsert = preInsertInMemoryValueGeneration( values, entity, session );\n\n\t\tfinal EntityMetamodel entityMetamodel = entityPersister().getEntityMetamodel();\n\t\tfinal boolean forceIdentifierBinding = entityPersister().getGenerator().generatedOnExecution() && id != null;\n\t\tif ( entityMetamodel.isDynamicInsert() || needsDynamicInsert || forceIdentifierBinding ) {\n\t\t\treturn doDynamicInserts( id, values, entity, session, forceIdentifierBinding );\n\t\t}\n\t\telse {\n\t\t\treturn doStaticInserts( id, values, entity, session );\n\t\t}\n\t}\n\n\tprotected boolean preInsertInMemoryValueGeneration(Object[] values, Object entity, SharedSessionContractImplementor session) {\n\t\tfinal EntityPersister persister = entityPersister();\n\t\tfinal EntityMetamodel entityMetamodel = persister.getEntityMetamodel();\n\t\tboolean foundStateDependentGenerator = false;\n\t\tif ( entityMetamodel.hasPreInsertGeneratedValues() ) {\n\t\t\tfinal Generator[] generators = entityMetamodel.getGenerators();\n\t\t\tfor ( int i = 0; i < generators.length; i++ ) {\n\t\t\t\tfinal Generator generator = generators[i];\n\t\t\t\tif ( generator != null\n\t\t\t\t\t\t&& generator.generatesOnInsert()\n\t\t\t\t\t\t&& !generator.generatedOnExecution( entity, session ) ) {\n\t\t\t\t\tvalues[i] = ( (BeforeExecutionGenerator) generator ).generate( session, entity, values[i], INSERT );\n\t\t\t\t\tpersister.setPropertyValue( entity, i, values[i] );\n\t\t\t\t\tfoundStateDependentGenerator = foundStateDependentGenerator || generator.generatedOnExecution();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn foundStateDependentGenerator;\n\t}\n\n\tpublic static class InsertValuesAnalysis implements ValuesAnalysis {\n\t\tprivate final List<TableMapping> tablesWithNonNullValues = new ArrayList<>();\n\n\t\tpublic InsertValuesAnalysis(EntityMutationTarget mutationTarget, Object[] values) {\n\t\t\tmutationTarget.forEachMutableTable( (tableMapping) -> {\n\t\t\t\tfinal int[] tableAttributeIndexes = tableMapping.getAttributeIndexes();\n\t\t\t\tfor ( int i = 0; i < tableAttributeIndexes.length; i++ ) {\n\t\t\t\t\tif ( values[tableAttributeIndexes[i]] != null ) {\n\t\t\t\t\t\ttablesWithNonNullValues.add( tableMapping );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\tpublic boolean hasNonNullBindings(TableMapping tableMapping) {\n\t\t\treturn tablesWithNonNullValues.contains( tableMapping );\n\t\t}\n\t}\n\n\tprotected GeneratedValues doStaticInserts(Object id, Object[] values, Object object, SharedSessionContractImplementor session) {\n\t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n\n\t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n\n\t\tfinal MutationExecutor mutationExecutor = executor( session, staticInsertGroup, false );\n\n\t\tdecomposeForInsert(\n\t\t\t\tmutationExecutor,\n\t\t\t\tid,\n\t\t\t\tvalues,\n\t\t\t\tstaticInsertGroup,\n\t\t\t\tentityPersister().getPropertyInsertability(),\n\t\t\t\ttableInclusionChecker,\n\t\t\t\tsession\n\t\t);\n\n\t\ttry {\n\t\t\treturn mutationExecutor.execute(\n\t\t\t\t\tobject,\n\t\t\t\t\tinsertValuesAnalysis,\n\t\t\t\t\ttableInclusionChecker,\n\t\t\t\t\tInsertCoordinatorStandard::verifyOutcome,\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tmutationExecutor.release();\n\t\t}\n\t}\n\n\tprotected void decomposeForInsert(\n\t\t\tMutationExecutor mutationExecutor,\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tMutationOperationGroup mutationGroup,\n\t\t\tboolean[] propertyInclusions,\n\t\t\tTableInclusionChecker tableInclusionChecker,\n\t\t\tSharedSessionContractImplementor session) {\n\t\tfinal JdbcValueBindings jdbcValueBindings = mutationExecutor.getJdbcValueBindings();\n\t\tfinal AttributeMappingsList attributeMappings = entityPersister().getAttributeMappings();\n\n\t\tfor ( int position = 0; position < mutationGroup.getNumberOfOperations(); position++ ) {\n\t\t\tfinal MutationOperation operation = mutationGroup.getOperation( position );\n\t\t\tfinal EntityTableMapping tableDetails = (EntityTableMapping) operation.getTableDetails();\n\t\t\tif ( tableInclusionChecker.include( tableDetails ) ) {\n\t\t\t\tfinal int[] attributeIndexes = tableDetails.getAttributeIndexes();\n\t\t\t\tfor ( int i = 0; i < attributeIndexes.length; i++ ) {\n\t\t\t\t\tfinal int attributeIndex = attributeIndexes[ i ];\n\t\t\t\t\tif ( propertyInclusions[attributeIndex] ) {\n\t\t\t\t\t\tfinal AttributeMapping mapping = attributeMappings.get( attributeIndex );\n\t\t\t\t\t\tdecomposeAttribute( values[attributeIndex], session, jdbcValueBindings, mapping );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( id == null ) {\n\t\t\tassert entityPersister().getInsertDelegate() != null;\n\t\t}\n\t\telse {\n\t\t\tfor ( int position = 0; position < mutationGroup.getNumberOfOperations(); position++ ) {\n\t\t\t\tfinal MutationOperation jdbcOperation = mutationGroup.getOperation( position );\n\t\t\t\tfinal EntityTableMapping tableDetails = (EntityTableMapping) jdbcOperation.getTableDetails();\n\t\t\t\tbreakDownJdbcValue( id, session, jdbcValueBindings, tableDetails );\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected void breakDownJdbcValue(\n\t\t\tObject id,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tJdbcValueBindings jdbcValueBindings,\n\t\t\tEntityTableMapping tableDetails) {\n\t\tfinal String tableName = tableDetails.getTableName();\n\t\ttableDetails.getKeyMapping().breakDownKeyJdbcValues(\n\t\t\t\tid,\n\t\t\t\t(jdbcValue, columnMapping) -> {\n\t\t\t\t\tjdbcValueBindings.bindValue(\n\t\t\t\t\t\t\tjdbcValue,\n\t\t\t\t\t\t\ttableName,\n\t\t\t\t\t\t\tcolumnMapping.getColumnName(),\n\t\t\t\t\t\t\tParameterUsage.SET\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t\tsession\n\t\t);\n\t}\n\n\tprotected void decomposeAttribute(\n\t\t\tObject value,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tJdbcValueBindings jdbcValueBindings,\n\t\t\tAttributeMapping mapping) {\n\t\tif ( !(mapping instanceof PluralAttributeMapping) ) {\n\t\t\tmapping.decompose(\n\t\t\t\t\tvalue,\n\t\t\t\t\t0,\n\t\t\t\t\tjdbcValueBindings,\n\t\t\t\t\tnull,\n\t\t\t\t\t(valueIndex, bindings, noop, jdbcValue, selectableMapping) -> {\n\t\t\t\t\t\tif ( selectableMapping.isInsertable() ) {\n\t\t\t\t\t\t\tbindings.bindValue(\n\t\t\t\t\t\t\t\t\tjdbcValue,\n\t\t\t\t\t\t\t\t\tentityPersister().physicalTableNameForMutation( selectableMapping ),\n\t\t\t\t\t\t\t\t\tselectableMapping.getSelectionExpression(),\n\t\t\t\t\t\t\t\t\tParameterUsage.SET\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t}\n\n\tprotected GeneratedValues doDynamicInserts(\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\n\t\tfinal boolean[] insertability = getPropertiesToInsert( values );\n\t\tfinal MutationOperationGroup insertGroup =\n\t\t\t\tgenerateDynamicInsertSqlGroup( insertability, object, session, forceIdentifierBinding );\n\n\t\tfinal MutationExecutor mutationExecutor = executor( session, insertGroup, true );\n\n\t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n\n\t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n\n\t\tdecomposeForInsert( mutationExecutor, id, values, insertGroup, insertability, tableInclusionChecker, session );\n\n\t\ttry {\n\t\t\treturn mutationExecutor.execute(\n\t\t\t\t\tobject,\n\t\t\t\t\tinsertValuesAnalysis,\n\t\t\t\t\ttableInclusionChecker,\n\t\t\t\t\tInsertCoordinatorStandard::verifyOutcome,\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tmutationExecutor.release();\n\t\t}\n\t}\n\n\tprivate static boolean verifyOutcome(PreparedStatementDetails statementDetails, int affectedRowCount, int batchPosition)\n\t\t\tthrows SQLException {\n\t\tstatementDetails.getExpectation().verifyOutcome(\n\t\t\t\taffectedRowCount,\n\t\t\t\tstatementDetails.getStatement(),\n\t\t\t\tbatchPosition,\n\t\t\t\tstatementDetails.getSqlString()\n\t\t);\n\t\treturn true;\n\t}\n\n\tprivate MutationExecutor executor(SharedSessionContractImplementor session, MutationOperationGroup group, boolean dynamicUpdate) {\n\t\treturn mutationExecutorService\n\t\t\t\t.createExecutor( resolveBatchKeyAccess( dynamicUpdate, session ), group, session );\n\t}\n\n\tprotected static TableInclusionChecker getTableInclusionChecker(InsertValuesAnalysis insertValuesAnalysis) {\n\t\treturn tableMapping -> !tableMapping.isOptional() || insertValuesAnalysis.hasNonNullBindings( tableMapping );\n\t}\n\n\n\t/**\n\t * Transform the array of property indexes to an array of booleans,\n\t * true when the property is insertable and non-null\n\t */\n\tpublic boolean[] getPropertiesToInsert(Object[] fields) {\n\t\tboolean[] notNull = new boolean[fields.length];\n\t\tboolean[] insertable = entityPersister().getPropertyInsertability();\n\t\tfor ( int i = 0; i < fields.length; i++ ) {\n\t\t\tnotNull[i] = insertable[i] && fields[i] != null;\n\t\t}\n\t\treturn notNull;\n\t}\n\n\tprotected MutationOperationGroup generateDynamicInsertSqlGroup(\n\t\t\tboolean[] insertable,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\n\t\tfinal MutationGroupBuilder insertGroupBuilder = new MutationGroupBuilder( MutationType.INSERT, entityPersister() );\n\t\tentityPersister().forEachMutableTable(\n\t\t\t\t(tableMapping) -> insertGroupBuilder.addTableDetailsBuilder( createTableInsertBuilder( tableMapping, forceIdentifierBinding ) )\n\t\t);\n\t\tapplyTableInsertDetails( insertGroupBuilder, insertable, object, session, forceIdentifierBinding );\n\t\treturn createOperationGroup( null, insertGroupBuilder.buildMutationGroup() );\n\t}\n\n\tpublic MutationOperationGroup generateStaticOperationGroup() {\n\t\tfinal MutationGroupBuilder insertGroupBuilder = new MutationGroupBuilder( MutationType.INSERT, entityPersister() );\n\t\tentityPersister().forEachMutableTable(\n\t\t\t\t(tableMapping) -> insertGroupBuilder.addTableDetailsBuilder( createTableInsertBuilder( tableMapping, false ) )\n\t\t);\n\t\tapplyTableInsertDetails( insertGroupBuilder, entityPersister().getPropertyInsertability(), null, null, false );\n\t\treturn createOperationGroup( null, insertGroupBuilder.buildMutationGroup() );\n\t}\n\n\tprivate TableMutationBuilder<?> createTableInsertBuilder(EntityTableMapping tableMapping, boolean forceIdentifierBinding) {\n\t\tfinal GeneratedValuesMutationDelegate delegate = entityPersister().getInsertDelegate();\n\t\tif ( tableMapping.isIdentifierTable() && delegate != null && !forceIdentifierBinding ) {\n\t\t\treturn delegate.createTableMutationBuilder( tableMapping.getInsertExpectation(), factory() );\n\t\t}\n\t\telse {\n\t\t\treturn new TableInsertBuilderStandard( entityPersister(), tableMapping, factory() );\n\t\t}\n\t}\n\n\tprivate void applyTableInsertDetails(\n\t\t\tMutationGroupBuilder insertGroupBuilder,\n\t\t\tboolean[] attributeInclusions,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\n\t\tfinal AttributeMappingsList attributeMappings = entityPersister().getAttributeMappings();\n\n\t\tinsertGroupBuilder.forEachTableMutationBuilder( (builder) -> {\n\t\t\tfinal EntityTableMapping tableMapping = (EntityTableMapping) builder.getMutatingTable().getTableMapping();\n\t\t\tassert !tableMapping.isInverse();\n\n\t\t\t// `attributeIndexes` represents the indexes (relative to `attributeMappings`) of\n\t\t\t// the attributes mapped to the table\n\t\t\tfinal int[] attributeIndexes = tableMapping.getAttributeIndexes();\n\t\t\tfor ( int i = 0; i < attributeIndexes.length; i++ ) {\n\t\t\t\tfinal int attributeIndex = attributeIndexes[ i ];\n\t\t\t\tfinal AttributeMapping attributeMapping = attributeMappings.get( attributeIndex );\n\t\t\t\tif ( attributeInclusions[attributeIndex] ) {\n\t\t\t\t\tattributeMapping.forEachInsertable( insertGroupBuilder );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfinal Generator generator = attributeMapping.getGenerator();\n\t\t\t\t\tif ( isValueGenerated( generator ) ) {\n\t\t\t\t\t\tif ( session != null && !generator.generatedOnExecution( object, session ) ) {\n\t\t\t\t\t\t\tattributeInclusions[attributeIndex] = true;\n\t\t\t\t\t\t\tattributeMapping.forEachInsertable( insertGroupBuilder );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ( isValueGenerationInSql( generator, factory.getJdbcServices().getDialect() ) ) {\n\t\t\t\t\t\t\thandleValueGeneration( attributeMapping, insertGroupBuilder, (OnExecutionGenerator) generator );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t\t// add the discriminator\n\t\tentityPersister().addDiscriminatorToInsertGroup( insertGroupBuilder );\n\t\tentityPersister().addSoftDeleteToInsertGroup( insertGroupBuilder );\n\n\t\t// add the keys\n\t\tinsertGroupBuilder.forEachTableMutationBuilder( (tableMutationBuilder) -> {\n\t\t\tfinal TableInsertBuilder tableInsertBuilder = (TableInsertBuilder) tableMutationBuilder;\n\t\t\tfinal EntityTableMapping tableMapping = (EntityTableMapping) tableInsertBuilder.getMutatingTable().getTableMapping();\n\t\t\tif ( tableMapping.isIdentifierTable() && entityPersister().isIdentifierAssignedByInsert() && !forceIdentifierBinding ) {\n\t\t\t\tassert entityPersister().getInsertDelegate() != null;\n\t\t\t\tfinal OnExecutionGenerator generator = (OnExecutionGenerator) entityPersister().getGenerator();\n\t\t\t\tif ( generator.referenceColumnsInSql( dialect() ) ) {\n\t\t\t\t\tfinal BasicEntityIdentifierMapping identifierMapping = (BasicEntityIdentifierMapping) entityPersister().getIdentifierMapping();\n\t\t\t\t\tfinal String[] columnValues = generator.getReferencedColumnValues( dialect );\n\t\t\t\t\ttableMapping.getKeyMapping().forEachKeyColumn( (i, column) -> tableInsertBuilder.addKeyColumn(\n\t\t\t\t\t\t\tcolumn.getColumnName(),\n\t\t\t\t\t\t\tcolumnValues[i],\n\t\t\t\t\t\t\tidentifierMapping.getJdbcMapping()\n\t\t\t\t\t) );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttableMapping.getKeyMapping().forEachKeyColumn( tableInsertBuilder::addKeyColumn );\n\t\t\t}\n\t\t} );\n\t}\n\n\tprivate static boolean isValueGenerated(Generator generator) {\n\t\treturn generator != null\n\t\t\t\t&& generator.generatesOnInsert()\n\t\t\t\t&& generator.generatedOnExecution();\n\t}\n\n\tprivate static boolean isValueGenerationInSql(Generator generator, Dialect dialect) {\n\t\tassert isValueGenerated( generator );\n\t\treturn ( (OnExecutionGenerator) generator ).referenceColumnsInSql(dialect);\n\t}\n\n\t/**\n\t * @deprecated Use {@link #getBatchKey()}\n\t */\n\t@Deprecated\n\tpublic BasicBatchKey getInsertBatchKey() {\n\t\treturn batchKey;\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private static boolean verifyOutcome(PreparedStatementDetails statementDetails, int affectedRowCount, int batchPosition)\n\t\t\tthrows SQLException {\n\t\tstatementDetails.getExpectation().verifyOutcome(\n\t\t\t\taffectedRowCount,\n\t\t\t\tstatementDetails.getStatement(),\n\t\t\t\tbatchPosition,\n\t\t\t\tstatementDetails.getSqlString()\n\t\t);\n\t\treturn true;\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#getPropertiesToInsert\n methodBody: public boolean[] getPropertiesToInsert(Object[] fields) {\nboolean[] notNull=new boolean[fields.length];\nboolean[] insertable=entityPersister().getPropertyInsertability();\nfor(int i=0; i < fields.length; i++){notNull[i]=insertable[i] && fields[i] != null;\n}return notNull;\n}",
            "methodSignature: org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#decomposeForInsert\n methodBody: protected void decomposeForInsert(\n\t\t\tMutationExecutor mutationExecutor,\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tMutationOperationGroup mutationGroup,\n\t\t\tboolean[] propertyInclusions,\n\t\t\tTableInclusionChecker tableInclusionChecker,\n\t\t\tSharedSessionContractImplementor session) {\nfinal JdbcValueBindings jdbcValueBindings=mutationExecutor.getJdbcValueBindings();\nfinal AttributeMappingsList attributeMappings=entityPersister().getAttributeMappings();\nfor(int position=0; position < mutationGroup.getNumberOfOperations(); position++){final MutationOperation operation=mutationGroup.getOperation(position);\nfinal EntityTableMapping tableDetails=(EntityTableMapping)operation.getTableDetails();\nif(tableInclusionChecker.include(tableDetails)){final int[] attributeIndexes=tableDetails.getAttributeIndexes();\nfor(int i=0; i < attributeIndexes.length; i++){final int attributeIndex=attributeIndexes[i];\nif(propertyInclusions[attributeIndex]){final AttributeMapping mapping=attributeMappings.get(attributeIndex);\ndecomposeAttribute(values[attributeIndex],session,jdbcValueBindings,mapping);\n}}}}if(id == null){assert entityPersister().getInsertDelegate() != null;\n}{for(int position=0; position < mutationGroup.getNumberOfOperations(); position++){final MutationOperation jdbcOperation=mutationGroup.getOperation(position);\nfinal EntityTableMapping tableDetails=(EntityTableMapping)jdbcOperation.getTableDetails();\nbreakDownJdbcValue(id,session,jdbcValueBindings,tableDetails);\n}}}",
            "methodSignature: org.hibernate.engine.jdbc.mutation.internal.MutationExecutorStandard#release\n methodBody: public void release() {\nnonBatchedStatementGroup.release();\n}",
            "methodSignature: org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#getTableInclusionChecker\n methodBody: protected static TableInclusionChecker getTableInclusionChecker(InsertValuesAnalysis insertValuesAnalysis) {\nreturn tableMapping -> !tableMapping.isOptional() || insertValuesAnalysis.hasNonNullBindings(tableMapping);\n}",
            "methodSignature: org.hibernate.engine.jdbc.mutation.internal.AbstractMutationExecutor#execute\n methodBody: public final GeneratedValues execute(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session) {\nfinal GeneratedValues generatedValues=performNonBatchedOperations(modelReference,valuesAnalysis,inclusionChecker,resultChecker,session);\nperformSelfExecutingOperations(valuesAnalysis,inclusionChecker,session);\nperformBatchedOperations(valuesAnalysis,inclusionChecker);\nreturn generatedValues;\n}",
            "methodSignature: org.hibernate.orm.test.jpa.transaction.batch.AbstractBatchingTest.BatchWrapper#execute\n methodBody: public void execute() {\nwrapped.execute();\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#execute\n methodBody: void execute();",
            "methodSignature: org.hibernate.orm.test.jpa.transaction.batch.AbstractBatchingTest.BatchWrapper#release\n methodBody: public void release() {\nwasReleaseCalled=true;\nwrapped.release();\nnumberOfStatementsAfterRelease=wrapped.getStatementGroup().getNumberOfActiveStatements();\n}",
            "methodSignature: org.hibernate.persister.entity.mutation.AbstractDeleteCoordinator#executor\n methodBody: private MutationExecutor executor(SharedSessionContractImplementor session, MutationOperationGroup group) {\nreturn mutationExecutorService.createExecutor(resolveBatchKeyAccess(false,session),group,session);\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.BatchImpl#execute\n methodBody: public void execute() {\nnotifyObserversExplicitExecution();\nif(getStatementGroup().getNumberOfStatements() == 0){return;\n}tryif(batchPosition == 0){if(!batchExecuted){if(BATCH_LOGGER.isDebugEnabled()){BATCH_LOGGER.debugf(\"No batched statements to execute - %s\",getKey().toLoggableString());\n}}}{performExecution();\n}finallyreleaseStatements();\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#release\n methodBody: void release();",
            "methodSignature: org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#generateDynamicInsertSqlGroup\n methodBody: protected MutationOperationGroup generateDynamicInsertSqlGroup(\n\t\t\tboolean[] insertable,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\nfinal MutationGroupBuilder insertGroupBuilder=new MutationGroupBuilder(MutationType.INSERT,entityPersister());\nentityPersister().forEachMutableTable((tableMapping) -> insertGroupBuilder.addTableDetailsBuilder(createTableInsertBuilder(tableMapping,forceIdentifierBinding)));\napplyTableInsertDetails(insertGroupBuilder,insertable,object,session,forceIdentifierBinding);\nreturn createOperationGroup(null,insertGroupBuilder.buildMutationGroup());\n}",
            "methodSignature: org.hibernate.engine.jdbc.mutation.internal.MutationExecutorSingleBatched#release\n methodBody: public void release() {\n}",
            "methodSignature: org.hibernate.engine.jdbc.mutation.MutationExecutor#release\n methodBody: void release();",
            "methodSignature: org.hibernate.persister.entity.mutation.UpdateCoordinatorStandard#executor\n methodBody: private MutationExecutor executor(SharedSessionContractImplementor session, MutationOperationGroup group, boolean dynamicUpdate) {\nreturn mutationExecutorService.createExecutor(resolveBatchKeyAccess(dynamicUpdate,session),group,session);\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.BatchImpl#release\n methodBody: public void release() {\nif(BATCH_MESSAGE_LOGGER.isInfoEnabled()){final PreparedStatementGroup statementGroup=getStatementGroup();\nif(statementGroup.getNumberOfStatements() != 0){if(statementGroup.hasMatching((statementDetails) -> statementDetails.getStatement() != null)){BATCH_MESSAGE_LOGGER.batchContainedStatementsOnRelease();\n}}}releaseStatements();\nobservers.clear();\n}",
            "methodSignature: org.hibernate.persister.entity.mutation.AbstractMutationCoordinator#entityPersister\n methodBody: protected EntityPersister entityPersister() {\nreturn entityPersister;\n}",
            "methodSignature: org.hibernate.engine.jdbc.mutation.MutationExecutor#execute\n methodBody: GeneratedValues execute(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session);",
            "methodSignature: org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#executor\n methodBody: private MutationExecutor executor(SharedSessionContractImplementor session, MutationOperationGroup group, boolean dynamicUpdate) {\nreturn mutationExecutorService.createExecutor(resolveBatchKeyAccess(dynamicUpdate,session),group,session);\n}"
        ],
        "sourceCodeAfterRefactoring": "protected GeneratedValues doDynamicInserts(\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\n\t\tfinal boolean[] insertability = getPropertiesToInsert( values );\n\t\tfinal MutationOperationGroup insertGroup =\n\t\t\t\tgenerateDynamicInsertSqlGroup( insertability, object, session, forceIdentifierBinding );\n\n\t\tfinal MutationExecutor mutationExecutor = executor( session, insertGroup, true );\n\n\t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n\n\t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n\n\t\tdecomposeForInsert( mutationExecutor, id, values, insertGroup, insertability, tableInclusionChecker, session );\n\n\t\ttry {\n\t\t\treturn mutationExecutor.execute(\n\t\t\t\t\tobject,\n\t\t\t\t\tinsertValuesAnalysis,\n\t\t\t\t\ttableInclusionChecker,\n\t\t\t\t\tInsertCoordinatorStandard::verifyOutcome,\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tmutationExecutor.release();\n\t\t}\n\t}\nprivate static boolean verifyOutcome(PreparedStatementDetails statementDetails, int affectedRowCount, int batchPosition)\n\t\t\tthrows SQLException {\n\t\tstatementDetails.getExpectation().verifyOutcome(\n\t\t\t\taffectedRowCount,\n\t\t\t\tstatementDetails.getStatement(),\n\t\t\t\tbatchPosition,\n\t\t\t\tstatementDetails.getSqlString()\n\t\t);\n\t\treturn true;\n\t}",
        "diffSourceCode": "-  290: \t\t\t\t\t},\n-  291: \t\t\t\t\tsession\n-  292: \t\t\t);\n-  293: \t\t}\n-  294: \t}\n-  295: \n-  296: \tprotected GeneratedValues doDynamicInserts(\n-  297: \t\t\tObject id,\n-  298: \t\t\tObject[] values,\n-  299: \t\t\tObject object,\n-  300: \t\t\tSharedSessionContractImplementor session,\n-  301: \t\t\tboolean forceIdentifierBinding) {\n-  302: \t\tfinal boolean[] insertability = getPropertiesToInsert( values );\n-  303: \t\tfinal MutationOperationGroup insertGroup = generateDynamicInsertSqlGroup( insertability, object, session, forceIdentifierBinding );\n-  304: \n-  305: \t\tfinal MutationExecutor mutationExecutor = executor( session, insertGroup, true );\n-  306: \n-  307: \t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n-  308: \n-  309: \t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n-  310: \n-  311: \t\tdecomposeForInsert( mutationExecutor, id, values, insertGroup, insertability, tableInclusionChecker, session );\n-  312: \n-  313: \t\ttry {\n-  314: \t\t\treturn mutationExecutor.execute(\n-  315: \t\t\t\t\tobject,\n-  316: \t\t\t\t\tinsertValuesAnalysis,\n-  317: \t\t\t\t\ttableInclusionChecker,\n-  318: \t\t\t\t\t(statementDetails, affectedRowCount, batchPosition) -> {\n-  319: \t\t\t\t\t\tstatementDetails.getExpectation().verifyOutcome(\n-  320: \t\t\t\t\t\t\t\taffectedRowCount,\n-  321: \t\t\t\t\t\t\t\tstatementDetails.getStatement(),\n-  322: \t\t\t\t\t\t\t\tbatchPosition,\n-  323: \t\t\t\t\t\t\t\tstatementDetails.getSqlString()\n-  324: \t\t\t\t\t\t);\n-  325: \t\t\t\t\t\treturn true;\n-  326: \t\t\t\t\t},\n-  327: \t\t\t\t\tsession\n-  328: \t\t\t);\n-  329: \t\t}\n-  330: \t\tfinally {\n-  331: \t\t\tmutationExecutor.release();\n-  332: \t\t}\n-  333: \t}\n+  290: \tprotected GeneratedValues doDynamicInserts(\n+  291: \t\t\tObject id,\n+  292: \t\t\tObject[] values,\n+  293: \t\t\tObject object,\n+  294: \t\t\tSharedSessionContractImplementor session,\n+  295: \t\t\tboolean forceIdentifierBinding) {\n+  296: \t\tfinal boolean[] insertability = getPropertiesToInsert( values );\n+  297: \t\tfinal MutationOperationGroup insertGroup =\n+  298: \t\t\t\tgenerateDynamicInsertSqlGroup( insertability, object, session, forceIdentifierBinding );\n+  299: \n+  300: \t\tfinal MutationExecutor mutationExecutor = executor( session, insertGroup, true );\n+  301: \n+  302: \t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n+  303: \n+  304: \t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n+  305: \n+  306: \t\tdecomposeForInsert( mutationExecutor, id, values, insertGroup, insertability, tableInclusionChecker, session );\n+  307: \n+  308: \t\ttry {\n+  309: \t\t\treturn mutationExecutor.execute(\n+  310: \t\t\t\t\tobject,\n+  311: \t\t\t\t\tinsertValuesAnalysis,\n+  312: \t\t\t\t\ttableInclusionChecker,\n+  313: \t\t\t\t\tInsertCoordinatorStandard::verifyOutcome,\n+  314: \t\t\t\t\tsession\n+  315: \t\t\t);\n+  316: \t\t}\n+  317: \t\tfinally {\n+  318: \t\t\tmutationExecutor.release();\n+  319: \t\t}\n+  320: \t}\n+  321: \n+  322: \tprivate static boolean verifyOutcome(PreparedStatementDetails statementDetails, int affectedRowCount, int batchPosition)\n+  323: \t\t\tthrows SQLException {\n+  324: \t\tstatementDetails.getExpectation().verifyOutcome(\n+  325: \t\t\t\taffectedRowCount,\n+  326: \t\t\t\tstatementDetails.getStatement(),\n+  327: \t\t\t\tbatchPosition,\n+  328: \t\t\t\tstatementDetails.getSqlString()\n+  329: \t\t);\n+  330: \t\treturn true;\n+  331: \t}\n+  332: \n+  333: \tprivate MutationExecutor executor(SharedSessionContractImplementor session, MutationOperationGroup group, boolean dynamicUpdate) {\n",
        "uniqueId": "ee00217733018075ccade7e1145f45ff9acae0c2_296_333_322_331_290_320",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 48
            },
            "LINE": {
                "missed": 0,
                "covered": 8
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\nprotected GeneratedValues doStaticInserts(\n        Object id,\n        Object[] values,\n        Object object,\n        SharedSessionContractImplementor session) {\n    final InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis(entityPersister(), values);\n\n    final TableInclusionChecker tableInclusionChecker = getTableInclusionChecker(insertValuesAnalysis);\n\n    final MutationExecutor mutationExecutor = executor(session, staticInsertGroup, false);\n\n    decomposeForInsert(\n            mutationExecutor,\n            id,\n            values,\n            staticInsertGroup,\n            entityPersister().getPropertyInsertability(),\n            tableInclusionChecker,\n            session\n    );\n\n    try {\n        return mutationExecutor.execute(\n                object,\n                insertValuesAnalysis,\n                tableInclusionChecker,\n                (statementDetails, affectedRowCount, batchPosition) -> {\n                    statementDetails.getExpectation().verifyOutcome(\n                            affectedRowCount,\n                            statementDetails.getStatement(),\n                            batchPosition,\n                            statementDetails.getSqlString()\n                    );\n                    return true;\n                },\n                session\n        );\n    } finally {\n        mutationExecutor.release();\n    }\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprotected GeneratedValues doDynamicInserts(\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\n\t\tfinal boolean[] insertability = getPropertiesToInsert( values );\n\t\tfinal MutationOperationGroup insertGroup = generateDynamicInsertSqlGroup( insertability, object, session, forceIdentifierBinding );\n\n\t\tfinal MutationExecutor mutationExecutor = executor( session, insertGroup, true );\n\n\t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n\n\t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n\n\t\tdecomposeForInsert( mutationExecutor, id, values, insertGroup, insertability, tableInclusionChecker, session );\n\n\t\ttry {\n\t\t\treturn mutationExecutor.execute(\n\t\t\t\t\tobject,\n\t\t\t\t\tinsertValuesAnalysis,\n\t\t\t\t\ttableInclusionChecker,\n\t\t\t\t\t(statementDetails, affectedRowCount, batchPosition) -> {\n\t\t\t\t\t\tstatementDetails.getExpectation().verifyOutcome(\n\t\t\t\t\t\t\t\taffectedRowCount,\n\t\t\t\t\t\t\t\tstatementDetails.getStatement(),\n\t\t\t\t\t\t\t\tbatchPosition,\n\t\t\t\t\t\t\t\tstatementDetails.getSqlString()\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tmutationExecutor.release();\n\t\t}\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html.\n */\npackage org.hibernate.persister.entity.mutation;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.hibernate.Internal;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.batch.internal.BasicBatchKey;\nimport org.hibernate.engine.jdbc.batch.spi.BatchKey;\nimport org.hibernate.engine.jdbc.mutation.JdbcValueBindings;\nimport org.hibernate.engine.jdbc.mutation.MutationExecutor;\nimport org.hibernate.engine.jdbc.mutation.ParameterUsage;\nimport org.hibernate.engine.jdbc.mutation.TableInclusionChecker;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.engine.spi.SharedSessionContractImplementor;\nimport org.hibernate.generator.BeforeExecutionGenerator;\nimport org.hibernate.generator.Generator;\nimport org.hibernate.generator.OnExecutionGenerator;\nimport org.hibernate.generator.values.GeneratedValues;\nimport org.hibernate.generator.values.GeneratedValuesMutationDelegate;\nimport org.hibernate.metamodel.mapping.AttributeMapping;\nimport org.hibernate.metamodel.mapping.AttributeMappingsList;\nimport org.hibernate.metamodel.mapping.BasicEntityIdentifierMapping;\nimport org.hibernate.metamodel.mapping.PluralAttributeMapping;\nimport org.hibernate.persister.entity.EntityPersister;\nimport org.hibernate.sql.model.MutationOperation;\nimport org.hibernate.sql.model.MutationOperationGroup;\nimport org.hibernate.sql.model.MutationType;\nimport org.hibernate.sql.model.TableMapping;\nimport org.hibernate.sql.model.ValuesAnalysis;\nimport org.hibernate.sql.model.ast.builder.MutationGroupBuilder;\nimport org.hibernate.sql.model.ast.builder.TableInsertBuilder;\nimport org.hibernate.sql.model.ast.builder.TableInsertBuilderStandard;\nimport org.hibernate.sql.model.ast.builder.TableMutationBuilder;\nimport org.hibernate.tuple.entity.EntityMetamodel;\n\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport static org.hibernate.generator.EventType.INSERT;\n\n/**\n * Coordinates the insertion of an entity.\n *\n * @see #coordinateInsert\n *\n * @author Steve Ebersole\n */\n@Internal\npublic class InsertCoordinatorStandard extends AbstractMutationCoordinator implements InsertCoordinator {\n\tprivate final MutationOperationGroup staticInsertGroup;\n\tprivate final BasicBatchKey batchKey;\n\n\tpublic InsertCoordinatorStandard(EntityPersister entityPersister, SessionFactoryImplementor factory) {\n\t\tsuper( entityPersister, factory );\n\n\t\tif ( entityPersister.isIdentifierAssignedByInsert() || entityPersister.hasInsertGeneratedProperties() ) {\n\t\t\t// disable batching in case of insert generated identifier or properties\n\t\t\tbatchKey = null;\n\t\t}\n\t\telse {\n\t\t\tbatchKey = new BasicBatchKey( entityPersister.getEntityName() + \"#INSERT\" );\n\t\t}\n\n\t\tif ( entityPersister.getEntityMetamodel().isDynamicInsert() ) {\n\t\t\t// the entity specified dynamic-insert - skip generating the\n\t\t\t// static inserts as we will create them every time\n\t\t\tstaticInsertGroup = null;\n\t\t}\n\t\telse {\n\t\t\tstaticInsertGroup = generateStaticOperationGroup();\n\t\t}\n\t}\n\n\t@Override\n\tpublic MutationOperationGroup getStaticMutationOperationGroup() {\n\t\treturn staticInsertGroup;\n\t}\n\n\t@Override\n\tprotected BatchKey getBatchKey() {\n\t\treturn batchKey;\n\t}\n\n\t@Override\n\tpublic @Nullable GeneratedValues insert(Object entity, Object[] values, SharedSessionContractImplementor session) {\n\t\treturn coordinateInsert( null, values, entity, session );\n\t}\n\n\t@Override\n\tpublic @Nullable GeneratedValues insert(\n\t\t\tObject entity,\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tSharedSessionContractImplementor session) {\n\t\treturn coordinateInsert( id, values, entity, session );\n\t}\n\n\t/**\n\t * Perform the insert(s).\n\t *\n\t * @param id This is the id as known in memory. For post-insert id generation (IDENTITY, etc)\n\t * this will be null.\n\t * @param values The extracted attribute values\n\t * @param entity The entity instance being persisted\n\t * @param session The originating context\n\t *\n\t * @return The {@linkplain GeneratedValues generated values} if any, {@code null} otherwise.\n\t */\n\tpublic GeneratedValues coordinateInsert(\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tObject entity,\n\t\t\tSharedSessionContractImplementor session) {\n\t\t// apply any pre-insert in-memory value generation\n\t\tfinal boolean needsDynamicInsert = preInsertInMemoryValueGeneration( values, entity, session );\n\n\t\tfinal EntityMetamodel entityMetamodel = entityPersister().getEntityMetamodel();\n\t\tfinal boolean forceIdentifierBinding = entityPersister().getGenerator().generatedOnExecution() && id != null;\n\t\tif ( entityMetamodel.isDynamicInsert() || needsDynamicInsert || forceIdentifierBinding ) {\n\t\t\treturn doDynamicInserts( id, values, entity, session, forceIdentifierBinding );\n\t\t}\n\t\telse {\n\t\t\treturn doStaticInserts( id, values, entity, session );\n\t\t}\n\t}\n\n\tprotected boolean preInsertInMemoryValueGeneration(Object[] values, Object entity, SharedSessionContractImplementor session) {\n\t\tfinal EntityPersister persister = entityPersister();\n\t\tfinal EntityMetamodel entityMetamodel = persister.getEntityMetamodel();\n\t\tboolean foundStateDependentGenerator = false;\n\t\tif ( entityMetamodel.hasPreInsertGeneratedValues() ) {\n\t\t\tfinal Generator[] generators = entityMetamodel.getGenerators();\n\t\t\tfor ( int i = 0; i < generators.length; i++ ) {\n\t\t\t\tfinal Generator generator = generators[i];\n\t\t\t\tif ( generator != null\n\t\t\t\t\t\t&& generator.generatesOnInsert()\n\t\t\t\t\t\t&& !generator.generatedOnExecution( entity, session ) ) {\n\t\t\t\t\tvalues[i] = ( (BeforeExecutionGenerator) generator ).generate( session, entity, values[i], INSERT );\n\t\t\t\t\tpersister.setPropertyValue( entity, i, values[i] );\n\t\t\t\t\tfoundStateDependentGenerator = foundStateDependentGenerator || generator.generatedOnExecution();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn foundStateDependentGenerator;\n\t}\n\n\tpublic static class InsertValuesAnalysis implements ValuesAnalysis {\n\t\tprivate final List<TableMapping> tablesWithNonNullValues = new ArrayList<>();\n\n\t\tpublic InsertValuesAnalysis(EntityMutationTarget mutationTarget, Object[] values) {\n\t\t\tmutationTarget.forEachMutableTable( (tableMapping) -> {\n\t\t\t\tfinal int[] tableAttributeIndexes = tableMapping.getAttributeIndexes();\n\t\t\t\tfor ( int i = 0; i < tableAttributeIndexes.length; i++ ) {\n\t\t\t\t\tif ( values[tableAttributeIndexes[i]] != null ) {\n\t\t\t\t\t\ttablesWithNonNullValues.add( tableMapping );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\tpublic boolean hasNonNullBindings(TableMapping tableMapping) {\n\t\t\treturn tablesWithNonNullValues.contains( tableMapping );\n\t\t}\n\t}\n\n\tprotected GeneratedValues doStaticInserts(Object id, Object[] values, Object object, SharedSessionContractImplementor session) {\n\t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n\n\t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n\n\t\tfinal MutationExecutor mutationExecutor = executor( session, staticInsertGroup, false );\n\n\t\tdecomposeForInsert(\n\t\t\t\tmutationExecutor,\n\t\t\t\tid,\n\t\t\t\tvalues,\n\t\t\t\tstaticInsertGroup,\n\t\t\t\tentityPersister().getPropertyInsertability(),\n\t\t\t\ttableInclusionChecker,\n\t\t\t\tsession\n\t\t);\n\n\t\ttry {\n\t\t\treturn mutationExecutor.execute(\n\t\t\t\t\tobject,\n\t\t\t\t\tinsertValuesAnalysis,\n\t\t\t\t\ttableInclusionChecker,\n\t\t\t\t\t(statementDetails, affectedRowCount, batchPosition) -> {\n\t\t\t\t\t\tstatementDetails.getExpectation().verifyOutcome(\n\t\t\t\t\t\t\t\taffectedRowCount,\n\t\t\t\t\t\t\t\tstatementDetails.getStatement(),\n\t\t\t\t\t\t\t\tbatchPosition,\n\t\t\t\t\t\t\t\tstatementDetails.getSqlString()\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tmutationExecutor.release();\n\t\t}\n\t}\n\n\tprotected void decomposeForInsert(\n\t\t\tMutationExecutor mutationExecutor,\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tMutationOperationGroup mutationGroup,\n\t\t\tboolean[] propertyInclusions,\n\t\t\tTableInclusionChecker tableInclusionChecker,\n\t\t\tSharedSessionContractImplementor session) {\n\t\tfinal JdbcValueBindings jdbcValueBindings = mutationExecutor.getJdbcValueBindings();\n\t\tfinal AttributeMappingsList attributeMappings = entityPersister().getAttributeMappings();\n\n\t\tfor ( int position = 0; position < mutationGroup.getNumberOfOperations(); position++ ) {\n\t\t\tfinal MutationOperation operation = mutationGroup.getOperation( position );\n\t\t\tfinal EntityTableMapping tableDetails = (EntityTableMapping) operation.getTableDetails();\n\t\t\tif ( tableInclusionChecker.include( tableDetails ) ) {\n\t\t\t\tfinal int[] attributeIndexes = tableDetails.getAttributeIndexes();\n\t\t\t\tfor ( int i = 0; i < attributeIndexes.length; i++ ) {\n\t\t\t\t\tfinal int attributeIndex = attributeIndexes[ i ];\n\t\t\t\t\tif ( propertyInclusions[attributeIndex] ) {\n\t\t\t\t\t\tfinal AttributeMapping mapping = attributeMappings.get( attributeIndex );\n\t\t\t\t\t\tdecomposeAttribute( values[attributeIndex], session, jdbcValueBindings, mapping );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( id == null ) {\n\t\t\tassert entityPersister().getInsertDelegate() != null;\n\t\t}\n\t\telse {\n\t\t\tfor ( int position = 0; position < mutationGroup.getNumberOfOperations(); position++ ) {\n\t\t\t\tfinal MutationOperation jdbcOperation = mutationGroup.getOperation( position );\n\t\t\t\tfinal EntityTableMapping tableDetails = (EntityTableMapping) jdbcOperation.getTableDetails();\n\t\t\t\tbreakDownJdbcValue( id, session, jdbcValueBindings, tableDetails );\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected void breakDownJdbcValue(\n\t\t\tObject id,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tJdbcValueBindings jdbcValueBindings,\n\t\t\tEntityTableMapping tableDetails) {\n\t\tfinal String tableName = tableDetails.getTableName();\n\t\ttableDetails.getKeyMapping().breakDownKeyJdbcValues(\n\t\t\t\tid,\n\t\t\t\t(jdbcValue, columnMapping) -> {\n\t\t\t\t\tjdbcValueBindings.bindValue(\n\t\t\t\t\t\t\tjdbcValue,\n\t\t\t\t\t\t\ttableName,\n\t\t\t\t\t\t\tcolumnMapping.getColumnName(),\n\t\t\t\t\t\t\tParameterUsage.SET\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t\tsession\n\t\t);\n\t}\n\n\tprotected void decomposeAttribute(\n\t\t\tObject value,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tJdbcValueBindings jdbcValueBindings,\n\t\t\tAttributeMapping mapping) {\n\t\tif ( !(mapping instanceof PluralAttributeMapping) ) {\n\t\t\tmapping.decompose(\n\t\t\t\t\tvalue,\n\t\t\t\t\t0,\n\t\t\t\t\tjdbcValueBindings,\n\t\t\t\t\tnull,\n\t\t\t\t\t(valueIndex, bindings, noop, jdbcValue, selectableMapping) -> {\n\t\t\t\t\t\tif ( selectableMapping.isInsertable() ) {\n\t\t\t\t\t\t\tbindings.bindValue(\n\t\t\t\t\t\t\t\t\tjdbcValue,\n\t\t\t\t\t\t\t\t\tentityPersister().physicalTableNameForMutation( selectableMapping ),\n\t\t\t\t\t\t\t\t\tselectableMapping.getSelectionExpression(),\n\t\t\t\t\t\t\t\t\tParameterUsage.SET\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t}\n\n\tprotected GeneratedValues doDynamicInserts(\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\n\t\tfinal boolean[] insertability = getPropertiesToInsert( values );\n\t\tfinal MutationOperationGroup insertGroup = generateDynamicInsertSqlGroup( insertability, object, session, forceIdentifierBinding );\n\n\t\tfinal MutationExecutor mutationExecutor = executor( session, insertGroup, true );\n\n\t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n\n\t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n\n\t\tdecomposeForInsert( mutationExecutor, id, values, insertGroup, insertability, tableInclusionChecker, session );\n\n\t\ttry {\n\t\t\treturn mutationExecutor.execute(\n\t\t\t\t\tobject,\n\t\t\t\t\tinsertValuesAnalysis,\n\t\t\t\t\ttableInclusionChecker,\n\t\t\t\t\t(statementDetails, affectedRowCount, batchPosition) -> {\n\t\t\t\t\t\tstatementDetails.getExpectation().verifyOutcome(\n\t\t\t\t\t\t\t\taffectedRowCount,\n\t\t\t\t\t\t\t\tstatementDetails.getStatement(),\n\t\t\t\t\t\t\t\tbatchPosition,\n\t\t\t\t\t\t\t\tstatementDetails.getSqlString()\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tmutationExecutor.release();\n\t\t}\n\t}\n\n\tprivate MutationExecutor executor(SharedSessionContractImplementor session, MutationOperationGroup group, boolean dynamicUpdate) {\n\t\treturn mutationExecutorService\n\t\t\t\t.createExecutor( resolveBatchKeyAccess( dynamicUpdate, session ), group, session );\n\t}\n\n\tprotected static TableInclusionChecker getTableInclusionChecker(InsertValuesAnalysis insertValuesAnalysis) {\n\t\treturn tableMapping -> !tableMapping.isOptional() || insertValuesAnalysis.hasNonNullBindings( tableMapping );\n\t}\n\n\n\t/**\n\t * Transform the array of property indexes to an array of booleans,\n\t * true when the property is insertable and non-null\n\t */\n\tpublic boolean[] getPropertiesToInsert(Object[] fields) {\n\t\tboolean[] notNull = new boolean[fields.length];\n\t\tboolean[] insertable = entityPersister().getPropertyInsertability();\n\t\tfor ( int i = 0; i < fields.length; i++ ) {\n\t\t\tnotNull[i] = insertable[i] && fields[i] != null;\n\t\t}\n\t\treturn notNull;\n\t}\n\n\tprotected MutationOperationGroup generateDynamicInsertSqlGroup(\n\t\t\tboolean[] insertable,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\n\t\tfinal MutationGroupBuilder insertGroupBuilder = new MutationGroupBuilder( MutationType.INSERT, entityPersister() );\n\t\tentityPersister().forEachMutableTable(\n\t\t\t\t(tableMapping) -> insertGroupBuilder.addTableDetailsBuilder( createTableInsertBuilder( tableMapping, forceIdentifierBinding ) )\n\t\t);\n\t\tapplyTableInsertDetails( insertGroupBuilder, insertable, object, session, forceIdentifierBinding );\n\t\treturn createOperationGroup( null, insertGroupBuilder.buildMutationGroup() );\n\t}\n\n\tpublic MutationOperationGroup generateStaticOperationGroup() {\n\t\tfinal MutationGroupBuilder insertGroupBuilder = new MutationGroupBuilder( MutationType.INSERT, entityPersister() );\n\t\tentityPersister().forEachMutableTable(\n\t\t\t\t(tableMapping) -> insertGroupBuilder.addTableDetailsBuilder( createTableInsertBuilder( tableMapping, false ) )\n\t\t);\n\t\tapplyTableInsertDetails( insertGroupBuilder, entityPersister().getPropertyInsertability(), null, null, false );\n\t\treturn createOperationGroup( null, insertGroupBuilder.buildMutationGroup() );\n\t}\n\n\tprivate TableMutationBuilder<?> createTableInsertBuilder(EntityTableMapping tableMapping, boolean forceIdentifierBinding) {\n\t\tfinal GeneratedValuesMutationDelegate delegate = entityPersister().getInsertDelegate();\n\t\tif ( tableMapping.isIdentifierTable() && delegate != null && !forceIdentifierBinding ) {\n\t\t\treturn delegate.createTableMutationBuilder( tableMapping.getInsertExpectation(), factory() );\n\t\t}\n\t\telse {\n\t\t\treturn new TableInsertBuilderStandard( entityPersister(), tableMapping, factory() );\n\t\t}\n\t}\n\n\tprivate void applyTableInsertDetails(\n\t\t\tMutationGroupBuilder insertGroupBuilder,\n\t\t\tboolean[] attributeInclusions,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\n\t\tfinal AttributeMappingsList attributeMappings = entityPersister().getAttributeMappings();\n\n\t\tinsertGroupBuilder.forEachTableMutationBuilder( (builder) -> {\n\t\t\tfinal EntityTableMapping tableMapping = (EntityTableMapping) builder.getMutatingTable().getTableMapping();\n\t\t\tassert !tableMapping.isInverse();\n\n\t\t\t// `attributeIndexes` represents the indexes (relative to `attributeMappings`) of\n\t\t\t// the attributes mapped to the table\n\t\t\tfinal int[] attributeIndexes = tableMapping.getAttributeIndexes();\n\t\t\tfor ( int i = 0; i < attributeIndexes.length; i++ ) {\n\t\t\t\tfinal int attributeIndex = attributeIndexes[ i ];\n\t\t\t\tfinal AttributeMapping attributeMapping = attributeMappings.get( attributeIndex );\n\t\t\t\tif ( attributeInclusions[attributeIndex] ) {\n\t\t\t\t\tattributeMapping.forEachInsertable( insertGroupBuilder );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfinal Generator generator = attributeMapping.getGenerator();\n\t\t\t\t\tif ( isValueGenerated( generator ) ) {\n\t\t\t\t\t\tif ( session != null && !generator.generatedOnExecution( object, session ) ) {\n\t\t\t\t\t\t\tattributeInclusions[attributeIndex] = true;\n\t\t\t\t\t\t\tattributeMapping.forEachInsertable( insertGroupBuilder );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ( isValueGenerationInSql( generator, factory().getJdbcServices().getDialect() ) ) {\n\t\t\t\t\t\t\thandleValueGeneration( attributeMapping, insertGroupBuilder, (OnExecutionGenerator) generator );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t\t// add the discriminator\n\t\tentityPersister().addDiscriminatorToInsertGroup( insertGroupBuilder );\n\t\tentityPersister().addSoftDeleteToInsertGroup( insertGroupBuilder );\n\n\t\t// add the keys\n\t\tinsertGroupBuilder.forEachTableMutationBuilder( (tableMutationBuilder) -> {\n\t\t\tfinal TableInsertBuilder tableInsertBuilder = (TableInsertBuilder) tableMutationBuilder;\n\t\t\tfinal EntityTableMapping tableMapping = (EntityTableMapping) tableInsertBuilder.getMutatingTable().getTableMapping();\n\t\t\tif ( tableMapping.isIdentifierTable() && entityPersister().isIdentifierAssignedByInsert() && !forceIdentifierBinding ) {\n\t\t\t\tassert entityPersister().getInsertDelegate() != null;\n\t\t\t\tfinal OnExecutionGenerator generator = (OnExecutionGenerator) entityPersister().getGenerator();\n\t\t\t\tif ( generator.referenceColumnsInSql( dialect() ) ) {\n\t\t\t\t\tfinal BasicEntityIdentifierMapping identifierMapping = (BasicEntityIdentifierMapping) entityPersister().getIdentifierMapping();\n\t\t\t\t\tfinal String[] columnValues = generator.getReferencedColumnValues( dialect );\n\t\t\t\t\ttableMapping.getKeyMapping().forEachKeyColumn( (i, column) -> tableInsertBuilder.addKeyColumn(\n\t\t\t\t\t\t\tcolumn.getColumnName(),\n\t\t\t\t\t\t\tcolumnValues[i],\n\t\t\t\t\t\t\tidentifierMapping.getJdbcMapping()\n\t\t\t\t\t) );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttableMapping.getKeyMapping().forEachKeyColumn( tableInsertBuilder::addKeyColumn );\n\t\t\t}\n\t\t} );\n\t}\n\n\tprivate static boolean isValueGenerated(Generator generator) {\n\t\treturn generator != null\n\t\t\t\t&& generator.generatesOnInsert()\n\t\t\t\t&& generator.generatedOnExecution();\n\t}\n\n\tprivate static boolean isValueGenerationInSql(Generator generator, Dialect dialect) {\n\t\tassert isValueGenerated( generator );\n\t\treturn ( (OnExecutionGenerator) generator ).referenceColumnsInSql(dialect);\n\t}\n\n\t/**\n\t * @deprecated Use {@link #getBatchKey()}\n\t */\n\t@Deprecated\n\tpublic BasicBatchKey getInsertBatchKey() {\n\t\treturn batchKey;\n\t}\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate verifyOutcome(statementDetails PreparedStatementDetails, affectedRowCount int, batchPosition int) : boolean extracted from protected doStaticInserts(id Object, values Object[], object Object, session SharedSessionContractImplementor) : GeneratedValues in class org.hibernate.persister.entity.mutation.InsertCoordinatorStandard",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/persister/entity/mutation/InsertCoordinatorStandard.java",
                "startLine": 173,
                "endLine": 210,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/persister/entity/mutation/InsertCoordinatorStandard.java",
                "startLine": 175,
                "endLine": 204,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/persister/entity/mutation/InsertCoordinatorStandard.java",
                "startLine": 322,
                "endLine": 331,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "protected GeneratedValues doStaticInserts(Object id, Object[] values, Object object, SharedSessionContractImplementor session) {\n\t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n\n\t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n\n\t\tfinal MutationExecutor mutationExecutor = executor( session, staticInsertGroup, false );\n\n\t\tdecomposeForInsert(\n\t\t\t\tmutationExecutor,\n\t\t\t\tid,\n\t\t\t\tvalues,\n\t\t\t\tstaticInsertGroup,\n\t\t\t\tentityPersister().getPropertyInsertability(),\n\t\t\t\ttableInclusionChecker,\n\t\t\t\tsession\n\t\t);\n\n\t\ttry {\n\t\t\treturn mutationExecutor.execute(\n\t\t\t\t\tobject,\n\t\t\t\t\tinsertValuesAnalysis,\n\t\t\t\t\ttableInclusionChecker,\n\t\t\t\t\t(statementDetails, affectedRowCount, batchPosition) -> {\n\t\t\t\t\t\tstatementDetails.getExpectation().verifyOutcome(\n\t\t\t\t\t\t\t\taffectedRowCount,\n\t\t\t\t\t\t\t\tstatementDetails.getStatement(),\n\t\t\t\t\t\t\t\tbatchPosition,\n\t\t\t\t\t\t\t\tstatementDetails.getSqlString()\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tmutationExecutor.release();\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/persister/entity/mutation/InsertCoordinatorStandard.java",
        "isPureRefactoring": true,
        "commitId": "ee00217733018075ccade7e1145f45ff9acae0c2",
        "packageNameBefore": "org.hibernate.persister.entity.mutation",
        "classNameBefore": "org.hibernate.persister.entity.mutation.InsertCoordinatorStandard",
        "methodNameBefore": "org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#doStaticInserts",
        "invokedMethod": "methodSignature: org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#decomposeForInsert\n methodBody: protected void decomposeForInsert(\n\t\t\tMutationExecutor mutationExecutor,\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tMutationOperationGroup mutationGroup,\n\t\t\tboolean[] propertyInclusions,\n\t\t\tTableInclusionChecker tableInclusionChecker,\n\t\t\tSharedSessionContractImplementor session) {\nfinal JdbcValueBindings jdbcValueBindings=mutationExecutor.getJdbcValueBindings();\nfinal AttributeMappingsList attributeMappings=entityPersister().getAttributeMappings();\nfor(int position=0; position < mutationGroup.getNumberOfOperations(); position++){final MutationOperation operation=mutationGroup.getOperation(position);\nfinal EntityTableMapping tableDetails=(EntityTableMapping)operation.getTableDetails();\nif(tableInclusionChecker.include(tableDetails)){final int[] attributeIndexes=tableDetails.getAttributeIndexes();\nfor(int i=0; i < attributeIndexes.length; i++){final int attributeIndex=attributeIndexes[i];\nif(propertyInclusions[attributeIndex]){final AttributeMapping mapping=attributeMappings.get(attributeIndex);\ndecomposeAttribute(values[attributeIndex],session,jdbcValueBindings,mapping);\n}}}}if(id == null){assert entityPersister().getInsertDelegate() != null;\n}{for(int position=0; position < mutationGroup.getNumberOfOperations(); position++){final MutationOperation jdbcOperation=mutationGroup.getOperation(position);\nfinal EntityTableMapping tableDetails=(EntityTableMapping)jdbcOperation.getTableDetails();\nbreakDownJdbcValue(id,session,jdbcValueBindings,tableDetails);\n}}}\nmethodSignature: org.hibernate.engine.jdbc.mutation.internal.MutationExecutorStandard#release\n methodBody: public void release() {\nnonBatchedStatementGroup.release();\n}\nmethodSignature: org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#getTableInclusionChecker\n methodBody: protected static TableInclusionChecker getTableInclusionChecker(InsertValuesAnalysis insertValuesAnalysis) {\nreturn tableMapping -> !tableMapping.isOptional() || insertValuesAnalysis.hasNonNullBindings(tableMapping);\n}\nmethodSignature: org.hibernate.engine.jdbc.mutation.internal.AbstractMutationExecutor#execute\n methodBody: public final GeneratedValues execute(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session) {\nfinal GeneratedValues generatedValues=performNonBatchedOperations(modelReference,valuesAnalysis,inclusionChecker,resultChecker,session);\nperformSelfExecutingOperations(valuesAnalysis,inclusionChecker,session);\nperformBatchedOperations(valuesAnalysis,inclusionChecker);\nreturn generatedValues;\n}\nmethodSignature: org.hibernate.orm.test.jpa.transaction.batch.AbstractBatchingTest.BatchWrapper#execute\n methodBody: public void execute() {\nwrapped.execute();\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#execute\n methodBody: void execute();\nmethodSignature: org.hibernate.orm.test.jpa.transaction.batch.AbstractBatchingTest.BatchWrapper#release\n methodBody: public void release() {\nwasReleaseCalled=true;\nwrapped.release();\nnumberOfStatementsAfterRelease=wrapped.getStatementGroup().getNumberOfActiveStatements();\n}\nmethodSignature: org.hibernate.persister.entity.mutation.AbstractDeleteCoordinator#executor\n methodBody: private MutationExecutor executor(SharedSessionContractImplementor session, MutationOperationGroup group) {\nreturn mutationExecutorService.createExecutor(resolveBatchKeyAccess(false,session),group,session);\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.BatchImpl#execute\n methodBody: public void execute() {\nnotifyObserversExplicitExecution();\nif(getStatementGroup().getNumberOfStatements() == 0){return;\n}tryif(batchPosition == 0){if(!batchExecuted){if(BATCH_LOGGER.isDebugEnabled()){BATCH_LOGGER.debugf(\"No batched statements to execute - %s\",getKey().toLoggableString());\n}}}{performExecution();\n}finallyreleaseStatements();\n}\nmethodSignature: org.hibernate.persister.entity.AbstractEntityPersister#getPropertyInsertability\n methodBody: public boolean[] getPropertyInsertability() {\nreturn entityMetamodel.getPropertyInsertability();\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#release\n methodBody: void release();\nmethodSignature: org.hibernate.engine.jdbc.mutation.internal.MutationExecutorSingleBatched#release\n methodBody: public void release() {\n}\nmethodSignature: org.hibernate.engine.jdbc.mutation.MutationExecutor#release\n methodBody: void release();\nmethodSignature: org.hibernate.persister.entity.mutation.UpdateCoordinatorStandard#executor\n methodBody: private MutationExecutor executor(SharedSessionContractImplementor session, MutationOperationGroup group, boolean dynamicUpdate) {\nreturn mutationExecutorService.createExecutor(resolveBatchKeyAccess(dynamicUpdate,session),group,session);\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.BatchImpl#release\n methodBody: public void release() {\nif(BATCH_MESSAGE_LOGGER.isInfoEnabled()){final PreparedStatementGroup statementGroup=getStatementGroup();\nif(statementGroup.getNumberOfStatements() != 0){if(statementGroup.hasMatching((statementDetails) -> statementDetails.getStatement() != null)){BATCH_MESSAGE_LOGGER.batchContainedStatementsOnRelease();\n}}}releaseStatements();\nobservers.clear();\n}\nmethodSignature: org.hibernate.persister.entity.mutation.AbstractMutationCoordinator#entityPersister\n methodBody: protected EntityPersister entityPersister() {\nreturn entityPersister;\n}\nmethodSignature: org.hibernate.engine.jdbc.mutation.MutationExecutor#execute\n methodBody: GeneratedValues execute(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session);\nmethodSignature: org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#executor\n methodBody: private MutationExecutor executor(SharedSessionContractImplementor session, MutationOperationGroup group, boolean dynamicUpdate) {\nreturn mutationExecutorService.createExecutor(resolveBatchKeyAccess(dynamicUpdate,session),group,session);\n}",
        "classSignatureBefore": "public class InsertCoordinatorStandard extends AbstractMutationCoordinator implements InsertCoordinator ",
        "methodNameBeforeSet": [
            "org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#doStaticInserts"
        ],
        "classNameBeforeSet": [
            "org.hibernate.persister.entity.mutation.InsertCoordinatorStandard"
        ],
        "classSignatureBeforeSet": [
            "public class InsertCoordinatorStandard extends AbstractMutationCoordinator implements InsertCoordinator "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html.\n */\npackage org.hibernate.persister.entity.mutation;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.hibernate.Internal;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.batch.internal.BasicBatchKey;\nimport org.hibernate.engine.jdbc.batch.spi.BatchKey;\nimport org.hibernate.engine.jdbc.mutation.JdbcValueBindings;\nimport org.hibernate.engine.jdbc.mutation.MutationExecutor;\nimport org.hibernate.engine.jdbc.mutation.ParameterUsage;\nimport org.hibernate.engine.jdbc.mutation.TableInclusionChecker;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.engine.spi.SharedSessionContractImplementor;\nimport org.hibernate.generator.BeforeExecutionGenerator;\nimport org.hibernate.generator.Generator;\nimport org.hibernate.generator.OnExecutionGenerator;\nimport org.hibernate.generator.values.GeneratedValues;\nimport org.hibernate.generator.values.GeneratedValuesMutationDelegate;\nimport org.hibernate.metamodel.mapping.AttributeMapping;\nimport org.hibernate.metamodel.mapping.AttributeMappingsList;\nimport org.hibernate.metamodel.mapping.BasicEntityIdentifierMapping;\nimport org.hibernate.metamodel.mapping.PluralAttributeMapping;\nimport org.hibernate.persister.entity.EntityPersister;\nimport org.hibernate.sql.model.MutationOperation;\nimport org.hibernate.sql.model.MutationOperationGroup;\nimport org.hibernate.sql.model.MutationType;\nimport org.hibernate.sql.model.TableMapping;\nimport org.hibernate.sql.model.ValuesAnalysis;\nimport org.hibernate.sql.model.ast.builder.MutationGroupBuilder;\nimport org.hibernate.sql.model.ast.builder.TableInsertBuilder;\nimport org.hibernate.sql.model.ast.builder.TableInsertBuilderStandard;\nimport org.hibernate.sql.model.ast.builder.TableMutationBuilder;\nimport org.hibernate.tuple.entity.EntityMetamodel;\n\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport static org.hibernate.generator.EventType.INSERT;\n\n/**\n * Coordinates the insertion of an entity.\n *\n * @see #coordinateInsert\n *\n * @author Steve Ebersole\n */\n@Internal\npublic class InsertCoordinatorStandard extends AbstractMutationCoordinator implements InsertCoordinator {\n\tprivate final MutationOperationGroup staticInsertGroup;\n\tprivate final BasicBatchKey batchKey;\n\n\tpublic InsertCoordinatorStandard(EntityPersister entityPersister, SessionFactoryImplementor factory) {\n\t\tsuper( entityPersister, factory );\n\n\t\tif ( entityPersister.isIdentifierAssignedByInsert() || entityPersister.hasInsertGeneratedProperties() ) {\n\t\t\t// disable batching in case of insert generated identifier or properties\n\t\t\tbatchKey = null;\n\t\t}\n\t\telse {\n\t\t\tbatchKey = new BasicBatchKey( entityPersister.getEntityName() + \"#INSERT\" );\n\t\t}\n\n\t\tif ( entityPersister.getEntityMetamodel().isDynamicInsert() ) {\n\t\t\t// the entity specified dynamic-insert - skip generating the\n\t\t\t// static inserts as we will create them every time\n\t\t\tstaticInsertGroup = null;\n\t\t}\n\t\telse {\n\t\t\tstaticInsertGroup = generateStaticOperationGroup();\n\t\t}\n\t}\n\n\t@Override\n\tpublic MutationOperationGroup getStaticMutationOperationGroup() {\n\t\treturn staticInsertGroup;\n\t}\n\n\t@Override\n\tprotected BatchKey getBatchKey() {\n\t\treturn batchKey;\n\t}\n\n\t@Override\n\tpublic @Nullable GeneratedValues insert(Object entity, Object[] values, SharedSessionContractImplementor session) {\n\t\treturn coordinateInsert( null, values, entity, session );\n\t}\n\n\t@Override\n\tpublic @Nullable GeneratedValues insert(\n\t\t\tObject entity,\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tSharedSessionContractImplementor session) {\n\t\treturn coordinateInsert( id, values, entity, session );\n\t}\n\n\t/**\n\t * Perform the insert(s).\n\t *\n\t * @param id This is the id as known in memory. For post-insert id generation (IDENTITY, etc)\n\t * this will be null.\n\t * @param values The extracted attribute values\n\t * @param entity The entity instance being persisted\n\t * @param session The originating context\n\t *\n\t * @return The {@linkplain GeneratedValues generated values} if any, {@code null} otherwise.\n\t */\n\tpublic GeneratedValues coordinateInsert(\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tObject entity,\n\t\t\tSharedSessionContractImplementor session) {\n\t\t// apply any pre-insert in-memory value generation\n\t\tfinal boolean needsDynamicInsert = preInsertInMemoryValueGeneration( values, entity, session );\n\n\t\tfinal EntityMetamodel entityMetamodel = entityPersister().getEntityMetamodel();\n\t\tfinal boolean forceIdentifierBinding = entityPersister().getGenerator().generatedOnExecution() && id != null;\n\t\tif ( entityMetamodel.isDynamicInsert() || needsDynamicInsert || forceIdentifierBinding ) {\n\t\t\treturn doDynamicInserts( id, values, entity, session, forceIdentifierBinding );\n\t\t}\n\t\telse {\n\t\t\treturn doStaticInserts( id, values, entity, session );\n\t\t}\n\t}\n\n\tprotected boolean preInsertInMemoryValueGeneration(Object[] values, Object entity, SharedSessionContractImplementor session) {\n\t\tfinal EntityPersister persister = entityPersister();\n\t\tfinal EntityMetamodel entityMetamodel = persister.getEntityMetamodel();\n\t\tboolean foundStateDependentGenerator = false;\n\t\tif ( entityMetamodel.hasPreInsertGeneratedValues() ) {\n\t\t\tfinal Generator[] generators = entityMetamodel.getGenerators();\n\t\t\tfor ( int i = 0; i < generators.length; i++ ) {\n\t\t\t\tfinal Generator generator = generators[i];\n\t\t\t\tif ( generator != null\n\t\t\t\t\t\t&& generator.generatesOnInsert()\n\t\t\t\t\t\t&& !generator.generatedOnExecution( entity, session ) ) {\n\t\t\t\t\tvalues[i] = ( (BeforeExecutionGenerator) generator ).generate( session, entity, values[i], INSERT );\n\t\t\t\t\tpersister.setPropertyValue( entity, i, values[i] );\n\t\t\t\t\tfoundStateDependentGenerator = foundStateDependentGenerator || generator.generatedOnExecution();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn foundStateDependentGenerator;\n\t}\n\n\tpublic static class InsertValuesAnalysis implements ValuesAnalysis {\n\t\tprivate final List<TableMapping> tablesWithNonNullValues = new ArrayList<>();\n\n\t\tpublic InsertValuesAnalysis(EntityMutationTarget mutationTarget, Object[] values) {\n\t\t\tmutationTarget.forEachMutableTable( (tableMapping) -> {\n\t\t\t\tfinal int[] tableAttributeIndexes = tableMapping.getAttributeIndexes();\n\t\t\t\tfor ( int i = 0; i < tableAttributeIndexes.length; i++ ) {\n\t\t\t\t\tif ( values[tableAttributeIndexes[i]] != null ) {\n\t\t\t\t\t\ttablesWithNonNullValues.add( tableMapping );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\tpublic boolean hasNonNullBindings(TableMapping tableMapping) {\n\t\t\treturn tablesWithNonNullValues.contains( tableMapping );\n\t\t}\n\t}\n\n\tprotected GeneratedValues doStaticInserts(Object id, Object[] values, Object object, SharedSessionContractImplementor session) {\n\t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n\n\t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n\n\t\tfinal MutationExecutor mutationExecutor = executor( session, staticInsertGroup, false );\n\n\t\tdecomposeForInsert(\n\t\t\t\tmutationExecutor,\n\t\t\t\tid,\n\t\t\t\tvalues,\n\t\t\t\tstaticInsertGroup,\n\t\t\t\tentityPersister().getPropertyInsertability(),\n\t\t\t\ttableInclusionChecker,\n\t\t\t\tsession\n\t\t);\n\n\t\ttry {\n\t\t\treturn mutationExecutor.execute(\n\t\t\t\t\tobject,\n\t\t\t\t\tinsertValuesAnalysis,\n\t\t\t\t\ttableInclusionChecker,\n\t\t\t\t\t(statementDetails, affectedRowCount, batchPosition) -> {\n\t\t\t\t\t\tstatementDetails.getExpectation().verifyOutcome(\n\t\t\t\t\t\t\t\taffectedRowCount,\n\t\t\t\t\t\t\t\tstatementDetails.getStatement(),\n\t\t\t\t\t\t\t\tbatchPosition,\n\t\t\t\t\t\t\t\tstatementDetails.getSqlString()\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tmutationExecutor.release();\n\t\t}\n\t}\n\n\tprotected void decomposeForInsert(\n\t\t\tMutationExecutor mutationExecutor,\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tMutationOperationGroup mutationGroup,\n\t\t\tboolean[] propertyInclusions,\n\t\t\tTableInclusionChecker tableInclusionChecker,\n\t\t\tSharedSessionContractImplementor session) {\n\t\tfinal JdbcValueBindings jdbcValueBindings = mutationExecutor.getJdbcValueBindings();\n\t\tfinal AttributeMappingsList attributeMappings = entityPersister().getAttributeMappings();\n\n\t\tfor ( int position = 0; position < mutationGroup.getNumberOfOperations(); position++ ) {\n\t\t\tfinal MutationOperation operation = mutationGroup.getOperation( position );\n\t\t\tfinal EntityTableMapping tableDetails = (EntityTableMapping) operation.getTableDetails();\n\t\t\tif ( tableInclusionChecker.include( tableDetails ) ) {\n\t\t\t\tfinal int[] attributeIndexes = tableDetails.getAttributeIndexes();\n\t\t\t\tfor ( int i = 0; i < attributeIndexes.length; i++ ) {\n\t\t\t\t\tfinal int attributeIndex = attributeIndexes[ i ];\n\t\t\t\t\tif ( propertyInclusions[attributeIndex] ) {\n\t\t\t\t\t\tfinal AttributeMapping mapping = attributeMappings.get( attributeIndex );\n\t\t\t\t\t\tdecomposeAttribute( values[attributeIndex], session, jdbcValueBindings, mapping );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( id == null ) {\n\t\t\tassert entityPersister().getInsertDelegate() != null;\n\t\t}\n\t\telse {\n\t\t\tfor ( int position = 0; position < mutationGroup.getNumberOfOperations(); position++ ) {\n\t\t\t\tfinal MutationOperation jdbcOperation = mutationGroup.getOperation( position );\n\t\t\t\tfinal EntityTableMapping tableDetails = (EntityTableMapping) jdbcOperation.getTableDetails();\n\t\t\t\tbreakDownJdbcValue( id, session, jdbcValueBindings, tableDetails );\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected void breakDownJdbcValue(\n\t\t\tObject id,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tJdbcValueBindings jdbcValueBindings,\n\t\t\tEntityTableMapping tableDetails) {\n\t\tfinal String tableName = tableDetails.getTableName();\n\t\ttableDetails.getKeyMapping().breakDownKeyJdbcValues(\n\t\t\t\tid,\n\t\t\t\t(jdbcValue, columnMapping) -> {\n\t\t\t\t\tjdbcValueBindings.bindValue(\n\t\t\t\t\t\t\tjdbcValue,\n\t\t\t\t\t\t\ttableName,\n\t\t\t\t\t\t\tcolumnMapping.getColumnName(),\n\t\t\t\t\t\t\tParameterUsage.SET\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t\tsession\n\t\t);\n\t}\n\n\tprotected void decomposeAttribute(\n\t\t\tObject value,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tJdbcValueBindings jdbcValueBindings,\n\t\t\tAttributeMapping mapping) {\n\t\tif ( !(mapping instanceof PluralAttributeMapping) ) {\n\t\t\tmapping.decompose(\n\t\t\t\t\tvalue,\n\t\t\t\t\t0,\n\t\t\t\t\tjdbcValueBindings,\n\t\t\t\t\tnull,\n\t\t\t\t\t(valueIndex, bindings, noop, jdbcValue, selectableMapping) -> {\n\t\t\t\t\t\tif ( selectableMapping.isInsertable() ) {\n\t\t\t\t\t\t\tbindings.bindValue(\n\t\t\t\t\t\t\t\t\tjdbcValue,\n\t\t\t\t\t\t\t\t\tentityPersister().physicalTableNameForMutation( selectableMapping ),\n\t\t\t\t\t\t\t\t\tselectableMapping.getSelectionExpression(),\n\t\t\t\t\t\t\t\t\tParameterUsage.SET\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t}\n\n\tprotected GeneratedValues doDynamicInserts(\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\n\t\tfinal boolean[] insertability = getPropertiesToInsert( values );\n\t\tfinal MutationOperationGroup insertGroup = generateDynamicInsertSqlGroup( insertability, object, session, forceIdentifierBinding );\n\n\t\tfinal MutationExecutor mutationExecutor = executor( session, insertGroup, true );\n\n\t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n\n\t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n\n\t\tdecomposeForInsert( mutationExecutor, id, values, insertGroup, insertability, tableInclusionChecker, session );\n\n\t\ttry {\n\t\t\treturn mutationExecutor.execute(\n\t\t\t\t\tobject,\n\t\t\t\t\tinsertValuesAnalysis,\n\t\t\t\t\ttableInclusionChecker,\n\t\t\t\t\t(statementDetails, affectedRowCount, batchPosition) -> {\n\t\t\t\t\t\tstatementDetails.getExpectation().verifyOutcome(\n\t\t\t\t\t\t\t\taffectedRowCount,\n\t\t\t\t\t\t\t\tstatementDetails.getStatement(),\n\t\t\t\t\t\t\t\tbatchPosition,\n\t\t\t\t\t\t\t\tstatementDetails.getSqlString()\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tmutationExecutor.release();\n\t\t}\n\t}\n\n\tprivate MutationExecutor executor(SharedSessionContractImplementor session, MutationOperationGroup group, boolean dynamicUpdate) {\n\t\treturn mutationExecutorService\n\t\t\t\t.createExecutor( resolveBatchKeyAccess( dynamicUpdate, session ), group, session );\n\t}\n\n\tprotected static TableInclusionChecker getTableInclusionChecker(InsertValuesAnalysis insertValuesAnalysis) {\n\t\treturn tableMapping -> !tableMapping.isOptional() || insertValuesAnalysis.hasNonNullBindings( tableMapping );\n\t}\n\n\n\t/**\n\t * Transform the array of property indexes to an array of booleans,\n\t * true when the property is insertable and non-null\n\t */\n\tpublic boolean[] getPropertiesToInsert(Object[] fields) {\n\t\tboolean[] notNull = new boolean[fields.length];\n\t\tboolean[] insertable = entityPersister().getPropertyInsertability();\n\t\tfor ( int i = 0; i < fields.length; i++ ) {\n\t\t\tnotNull[i] = insertable[i] && fields[i] != null;\n\t\t}\n\t\treturn notNull;\n\t}\n\n\tprotected MutationOperationGroup generateDynamicInsertSqlGroup(\n\t\t\tboolean[] insertable,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\n\t\tfinal MutationGroupBuilder insertGroupBuilder = new MutationGroupBuilder( MutationType.INSERT, entityPersister() );\n\t\tentityPersister().forEachMutableTable(\n\t\t\t\t(tableMapping) -> insertGroupBuilder.addTableDetailsBuilder( createTableInsertBuilder( tableMapping, forceIdentifierBinding ) )\n\t\t);\n\t\tapplyTableInsertDetails( insertGroupBuilder, insertable, object, session, forceIdentifierBinding );\n\t\treturn createOperationGroup( null, insertGroupBuilder.buildMutationGroup() );\n\t}\n\n\tpublic MutationOperationGroup generateStaticOperationGroup() {\n\t\tfinal MutationGroupBuilder insertGroupBuilder = new MutationGroupBuilder( MutationType.INSERT, entityPersister() );\n\t\tentityPersister().forEachMutableTable(\n\t\t\t\t(tableMapping) -> insertGroupBuilder.addTableDetailsBuilder( createTableInsertBuilder( tableMapping, false ) )\n\t\t);\n\t\tapplyTableInsertDetails( insertGroupBuilder, entityPersister().getPropertyInsertability(), null, null, false );\n\t\treturn createOperationGroup( null, insertGroupBuilder.buildMutationGroup() );\n\t}\n\n\tprivate TableMutationBuilder<?> createTableInsertBuilder(EntityTableMapping tableMapping, boolean forceIdentifierBinding) {\n\t\tfinal GeneratedValuesMutationDelegate delegate = entityPersister().getInsertDelegate();\n\t\tif ( tableMapping.isIdentifierTable() && delegate != null && !forceIdentifierBinding ) {\n\t\t\treturn delegate.createTableMutationBuilder( tableMapping.getInsertExpectation(), factory() );\n\t\t}\n\t\telse {\n\t\t\treturn new TableInsertBuilderStandard( entityPersister(), tableMapping, factory() );\n\t\t}\n\t}\n\n\tprivate void applyTableInsertDetails(\n\t\t\tMutationGroupBuilder insertGroupBuilder,\n\t\t\tboolean[] attributeInclusions,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\n\t\tfinal AttributeMappingsList attributeMappings = entityPersister().getAttributeMappings();\n\n\t\tinsertGroupBuilder.forEachTableMutationBuilder( (builder) -> {\n\t\t\tfinal EntityTableMapping tableMapping = (EntityTableMapping) builder.getMutatingTable().getTableMapping();\n\t\t\tassert !tableMapping.isInverse();\n\n\t\t\t// `attributeIndexes` represents the indexes (relative to `attributeMappings`) of\n\t\t\t// the attributes mapped to the table\n\t\t\tfinal int[] attributeIndexes = tableMapping.getAttributeIndexes();\n\t\t\tfor ( int i = 0; i < attributeIndexes.length; i++ ) {\n\t\t\t\tfinal int attributeIndex = attributeIndexes[ i ];\n\t\t\t\tfinal AttributeMapping attributeMapping = attributeMappings.get( attributeIndex );\n\t\t\t\tif ( attributeInclusions[attributeIndex] ) {\n\t\t\t\t\tattributeMapping.forEachInsertable( insertGroupBuilder );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfinal Generator generator = attributeMapping.getGenerator();\n\t\t\t\t\tif ( isValueGenerated( generator ) ) {\n\t\t\t\t\t\tif ( session != null && !generator.generatedOnExecution( object, session ) ) {\n\t\t\t\t\t\t\tattributeInclusions[attributeIndex] = true;\n\t\t\t\t\t\t\tattributeMapping.forEachInsertable( insertGroupBuilder );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ( isValueGenerationInSql( generator, factory().getJdbcServices().getDialect() ) ) {\n\t\t\t\t\t\t\thandleValueGeneration( attributeMapping, insertGroupBuilder, (OnExecutionGenerator) generator );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t\t// add the discriminator\n\t\tentityPersister().addDiscriminatorToInsertGroup( insertGroupBuilder );\n\t\tentityPersister().addSoftDeleteToInsertGroup( insertGroupBuilder );\n\n\t\t// add the keys\n\t\tinsertGroupBuilder.forEachTableMutationBuilder( (tableMutationBuilder) -> {\n\t\t\tfinal TableInsertBuilder tableInsertBuilder = (TableInsertBuilder) tableMutationBuilder;\n\t\t\tfinal EntityTableMapping tableMapping = (EntityTableMapping) tableInsertBuilder.getMutatingTable().getTableMapping();\n\t\t\tif ( tableMapping.isIdentifierTable() && entityPersister().isIdentifierAssignedByInsert() && !forceIdentifierBinding ) {\n\t\t\t\tassert entityPersister().getInsertDelegate() != null;\n\t\t\t\tfinal OnExecutionGenerator generator = (OnExecutionGenerator) entityPersister().getGenerator();\n\t\t\t\tif ( generator.referenceColumnsInSql( dialect() ) ) {\n\t\t\t\t\tfinal BasicEntityIdentifierMapping identifierMapping = (BasicEntityIdentifierMapping) entityPersister().getIdentifierMapping();\n\t\t\t\t\tfinal String[] columnValues = generator.getReferencedColumnValues( dialect );\n\t\t\t\t\ttableMapping.getKeyMapping().forEachKeyColumn( (i, column) -> tableInsertBuilder.addKeyColumn(\n\t\t\t\t\t\t\tcolumn.getColumnName(),\n\t\t\t\t\t\t\tcolumnValues[i],\n\t\t\t\t\t\t\tidentifierMapping.getJdbcMapping()\n\t\t\t\t\t) );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttableMapping.getKeyMapping().forEachKeyColumn( tableInsertBuilder::addKeyColumn );\n\t\t\t}\n\t\t} );\n\t}\n\n\tprivate static boolean isValueGenerated(Generator generator) {\n\t\treturn generator != null\n\t\t\t\t&& generator.generatesOnInsert()\n\t\t\t\t&& generator.generatedOnExecution();\n\t}\n\n\tprivate static boolean isValueGenerationInSql(Generator generator, Dialect dialect) {\n\t\tassert isValueGenerated( generator );\n\t\treturn ( (OnExecutionGenerator) generator ).referenceColumnsInSql(dialect);\n\t}\n\n\t/**\n\t * @deprecated Use {@link #getBatchKey()}\n\t */\n\t@Deprecated\n\tpublic BasicBatchKey getInsertBatchKey() {\n\t\treturn batchKey;\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/persister/entity/mutation/InsertCoordinatorStandard.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html.\n */\npackage org.hibernate.persister.entity.mutation;\n\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.hibernate.Internal;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.batch.internal.BasicBatchKey;\nimport org.hibernate.engine.jdbc.batch.spi.BatchKey;\nimport org.hibernate.engine.jdbc.mutation.JdbcValueBindings;\nimport org.hibernate.engine.jdbc.mutation.MutationExecutor;\nimport org.hibernate.engine.jdbc.mutation.ParameterUsage;\nimport org.hibernate.engine.jdbc.mutation.TableInclusionChecker;\nimport org.hibernate.engine.jdbc.mutation.group.PreparedStatementDetails;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.engine.spi.SharedSessionContractImplementor;\nimport org.hibernate.generator.BeforeExecutionGenerator;\nimport org.hibernate.generator.Generator;\nimport org.hibernate.generator.OnExecutionGenerator;\nimport org.hibernate.generator.values.GeneratedValues;\nimport org.hibernate.generator.values.GeneratedValuesMutationDelegate;\nimport org.hibernate.metamodel.mapping.AttributeMapping;\nimport org.hibernate.metamodel.mapping.AttributeMappingsList;\nimport org.hibernate.metamodel.mapping.BasicEntityIdentifierMapping;\nimport org.hibernate.metamodel.mapping.PluralAttributeMapping;\nimport org.hibernate.persister.entity.EntityPersister;\nimport org.hibernate.sql.model.MutationOperation;\nimport org.hibernate.sql.model.MutationOperationGroup;\nimport org.hibernate.sql.model.MutationType;\nimport org.hibernate.sql.model.TableMapping;\nimport org.hibernate.sql.model.ValuesAnalysis;\nimport org.hibernate.sql.model.ast.builder.MutationGroupBuilder;\nimport org.hibernate.sql.model.ast.builder.TableInsertBuilder;\nimport org.hibernate.sql.model.ast.builder.TableInsertBuilderStandard;\nimport org.hibernate.sql.model.ast.builder.TableMutationBuilder;\nimport org.hibernate.tuple.entity.EntityMetamodel;\n\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport static org.hibernate.generator.EventType.INSERT;\n\n/**\n * Coordinates the insertion of an entity.\n *\n * @see #coordinateInsert\n *\n * @author Steve Ebersole\n */\n@Internal\npublic class InsertCoordinatorStandard extends AbstractMutationCoordinator implements InsertCoordinator {\n\tprivate final MutationOperationGroup staticInsertGroup;\n\tprivate final BasicBatchKey batchKey;\n\n\tpublic InsertCoordinatorStandard(EntityPersister entityPersister, SessionFactoryImplementor factory) {\n\t\tsuper( entityPersister, factory );\n\n\t\tif ( entityPersister.isIdentifierAssignedByInsert() || entityPersister.hasInsertGeneratedProperties() ) {\n\t\t\t// disable batching in case of insert generated identifier or properties\n\t\t\tbatchKey = null;\n\t\t}\n\t\telse {\n\t\t\tbatchKey = new BasicBatchKey( entityPersister.getEntityName() + \"#INSERT\" );\n\t\t}\n\n\t\tif ( entityPersister.getEntityMetamodel().isDynamicInsert() ) {\n\t\t\t// the entity specified dynamic-insert - skip generating the\n\t\t\t// static inserts as we will create them every time\n\t\t\tstaticInsertGroup = null;\n\t\t}\n\t\telse {\n\t\t\tstaticInsertGroup = generateStaticOperationGroup();\n\t\t}\n\t}\n\n\t@Override\n\tpublic MutationOperationGroup getStaticMutationOperationGroup() {\n\t\treturn staticInsertGroup;\n\t}\n\n\t@Override\n\tprotected BatchKey getBatchKey() {\n\t\treturn batchKey;\n\t}\n\n\t@Override\n\tpublic @Nullable GeneratedValues insert(Object entity, Object[] values, SharedSessionContractImplementor session) {\n\t\treturn coordinateInsert( null, values, entity, session );\n\t}\n\n\t@Override\n\tpublic @Nullable GeneratedValues insert(\n\t\t\tObject entity,\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tSharedSessionContractImplementor session) {\n\t\treturn coordinateInsert( id, values, entity, session );\n\t}\n\n\t/**\n\t * Perform the insert(s).\n\t *\n\t * @param id This is the id as known in memory. For post-insert id generation (IDENTITY, etc)\n\t * this will be null.\n\t * @param values The extracted attribute values\n\t * @param entity The entity instance being persisted\n\t * @param session The originating context\n\t *\n\t * @return The {@linkplain GeneratedValues generated values} if any, {@code null} otherwise.\n\t */\n\tpublic GeneratedValues coordinateInsert(\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tObject entity,\n\t\t\tSharedSessionContractImplementor session) {\n\t\t// apply any pre-insert in-memory value generation\n\t\tfinal boolean needsDynamicInsert = preInsertInMemoryValueGeneration( values, entity, session );\n\n\t\tfinal EntityMetamodel entityMetamodel = entityPersister().getEntityMetamodel();\n\t\tfinal boolean forceIdentifierBinding = entityPersister().getGenerator().generatedOnExecution() && id != null;\n\t\tif ( entityMetamodel.isDynamicInsert() || needsDynamicInsert || forceIdentifierBinding ) {\n\t\t\treturn doDynamicInserts( id, values, entity, session, forceIdentifierBinding );\n\t\t}\n\t\telse {\n\t\t\treturn doStaticInserts( id, values, entity, session );\n\t\t}\n\t}\n\n\tprotected boolean preInsertInMemoryValueGeneration(Object[] values, Object entity, SharedSessionContractImplementor session) {\n\t\tfinal EntityPersister persister = entityPersister();\n\t\tfinal EntityMetamodel entityMetamodel = persister.getEntityMetamodel();\n\t\tboolean foundStateDependentGenerator = false;\n\t\tif ( entityMetamodel.hasPreInsertGeneratedValues() ) {\n\t\t\tfinal Generator[] generators = entityMetamodel.getGenerators();\n\t\t\tfor ( int i = 0; i < generators.length; i++ ) {\n\t\t\t\tfinal Generator generator = generators[i];\n\t\t\t\tif ( generator != null\n\t\t\t\t\t\t&& generator.generatesOnInsert()\n\t\t\t\t\t\t&& !generator.generatedOnExecution( entity, session ) ) {\n\t\t\t\t\tvalues[i] = ( (BeforeExecutionGenerator) generator ).generate( session, entity, values[i], INSERT );\n\t\t\t\t\tpersister.setPropertyValue( entity, i, values[i] );\n\t\t\t\t\tfoundStateDependentGenerator = foundStateDependentGenerator || generator.generatedOnExecution();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn foundStateDependentGenerator;\n\t}\n\n\tpublic static class InsertValuesAnalysis implements ValuesAnalysis {\n\t\tprivate final List<TableMapping> tablesWithNonNullValues = new ArrayList<>();\n\n\t\tpublic InsertValuesAnalysis(EntityMutationTarget mutationTarget, Object[] values) {\n\t\t\tmutationTarget.forEachMutableTable( (tableMapping) -> {\n\t\t\t\tfinal int[] tableAttributeIndexes = tableMapping.getAttributeIndexes();\n\t\t\t\tfor ( int i = 0; i < tableAttributeIndexes.length; i++ ) {\n\t\t\t\t\tif ( values[tableAttributeIndexes[i]] != null ) {\n\t\t\t\t\t\ttablesWithNonNullValues.add( tableMapping );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\tpublic boolean hasNonNullBindings(TableMapping tableMapping) {\n\t\t\treturn tablesWithNonNullValues.contains( tableMapping );\n\t\t}\n\t}\n\n\tprotected GeneratedValues doStaticInserts(Object id, Object[] values, Object object, SharedSessionContractImplementor session) {\n\t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n\n\t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n\n\t\tfinal MutationExecutor mutationExecutor = executor( session, staticInsertGroup, false );\n\n\t\tdecomposeForInsert(\n\t\t\t\tmutationExecutor,\n\t\t\t\tid,\n\t\t\t\tvalues,\n\t\t\t\tstaticInsertGroup,\n\t\t\t\tentityPersister().getPropertyInsertability(),\n\t\t\t\ttableInclusionChecker,\n\t\t\t\tsession\n\t\t);\n\n\t\ttry {\n\t\t\treturn mutationExecutor.execute(\n\t\t\t\t\tobject,\n\t\t\t\t\tinsertValuesAnalysis,\n\t\t\t\t\ttableInclusionChecker,\n\t\t\t\t\tInsertCoordinatorStandard::verifyOutcome,\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tmutationExecutor.release();\n\t\t}\n\t}\n\n\tprotected void decomposeForInsert(\n\t\t\tMutationExecutor mutationExecutor,\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tMutationOperationGroup mutationGroup,\n\t\t\tboolean[] propertyInclusions,\n\t\t\tTableInclusionChecker tableInclusionChecker,\n\t\t\tSharedSessionContractImplementor session) {\n\t\tfinal JdbcValueBindings jdbcValueBindings = mutationExecutor.getJdbcValueBindings();\n\t\tfinal AttributeMappingsList attributeMappings = entityPersister().getAttributeMappings();\n\n\t\tfor ( int position = 0; position < mutationGroup.getNumberOfOperations(); position++ ) {\n\t\t\tfinal MutationOperation operation = mutationGroup.getOperation( position );\n\t\t\tfinal EntityTableMapping tableDetails = (EntityTableMapping) operation.getTableDetails();\n\t\t\tif ( tableInclusionChecker.include( tableDetails ) ) {\n\t\t\t\tfinal int[] attributeIndexes = tableDetails.getAttributeIndexes();\n\t\t\t\tfor ( int i = 0; i < attributeIndexes.length; i++ ) {\n\t\t\t\t\tfinal int attributeIndex = attributeIndexes[ i ];\n\t\t\t\t\tif ( propertyInclusions[attributeIndex] ) {\n\t\t\t\t\t\tfinal AttributeMapping mapping = attributeMappings.get( attributeIndex );\n\t\t\t\t\t\tdecomposeAttribute( values[attributeIndex], session, jdbcValueBindings, mapping );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( id == null ) {\n\t\t\tassert entityPersister().getInsertDelegate() != null;\n\t\t}\n\t\telse {\n\t\t\tfor ( int position = 0; position < mutationGroup.getNumberOfOperations(); position++ ) {\n\t\t\t\tfinal MutationOperation jdbcOperation = mutationGroup.getOperation( position );\n\t\t\t\tfinal EntityTableMapping tableDetails = (EntityTableMapping) jdbcOperation.getTableDetails();\n\t\t\t\tbreakDownJdbcValue( id, session, jdbcValueBindings, tableDetails );\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected void breakDownJdbcValue(\n\t\t\tObject id,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tJdbcValueBindings jdbcValueBindings,\n\t\t\tEntityTableMapping tableDetails) {\n\t\tfinal String tableName = tableDetails.getTableName();\n\t\ttableDetails.getKeyMapping().breakDownKeyJdbcValues(\n\t\t\t\tid,\n\t\t\t\t(jdbcValue, columnMapping) -> {\n\t\t\t\t\tjdbcValueBindings.bindValue(\n\t\t\t\t\t\t\tjdbcValue,\n\t\t\t\t\t\t\ttableName,\n\t\t\t\t\t\t\tcolumnMapping.getColumnName(),\n\t\t\t\t\t\t\tParameterUsage.SET\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t\tsession\n\t\t);\n\t}\n\n\tprotected void decomposeAttribute(\n\t\t\tObject value,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tJdbcValueBindings jdbcValueBindings,\n\t\t\tAttributeMapping mapping) {\n\t\tif ( !(mapping instanceof PluralAttributeMapping) ) {\n\t\t\tmapping.decompose(\n\t\t\t\t\tvalue,\n\t\t\t\t\t0,\n\t\t\t\t\tjdbcValueBindings,\n\t\t\t\t\tnull,\n\t\t\t\t\t(valueIndex, bindings, noop, jdbcValue, selectableMapping) -> {\n\t\t\t\t\t\tif ( selectableMapping.isInsertable() ) {\n\t\t\t\t\t\t\tbindings.bindValue(\n\t\t\t\t\t\t\t\t\tjdbcValue,\n\t\t\t\t\t\t\t\t\tentityPersister().physicalTableNameForMutation( selectableMapping ),\n\t\t\t\t\t\t\t\t\tselectableMapping.getSelectionExpression(),\n\t\t\t\t\t\t\t\t\tParameterUsage.SET\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t}\n\n\tprotected GeneratedValues doDynamicInserts(\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\n\t\tfinal boolean[] insertability = getPropertiesToInsert( values );\n\t\tfinal MutationOperationGroup insertGroup =\n\t\t\t\tgenerateDynamicInsertSqlGroup( insertability, object, session, forceIdentifierBinding );\n\n\t\tfinal MutationExecutor mutationExecutor = executor( session, insertGroup, true );\n\n\t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n\n\t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n\n\t\tdecomposeForInsert( mutationExecutor, id, values, insertGroup, insertability, tableInclusionChecker, session );\n\n\t\ttry {\n\t\t\treturn mutationExecutor.execute(\n\t\t\t\t\tobject,\n\t\t\t\t\tinsertValuesAnalysis,\n\t\t\t\t\ttableInclusionChecker,\n\t\t\t\t\tInsertCoordinatorStandard::verifyOutcome,\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tmutationExecutor.release();\n\t\t}\n\t}\n\n\tprivate static boolean verifyOutcome(PreparedStatementDetails statementDetails, int affectedRowCount, int batchPosition)\n\t\t\tthrows SQLException {\n\t\tstatementDetails.getExpectation().verifyOutcome(\n\t\t\t\taffectedRowCount,\n\t\t\t\tstatementDetails.getStatement(),\n\t\t\t\tbatchPosition,\n\t\t\t\tstatementDetails.getSqlString()\n\t\t);\n\t\treturn true;\n\t}\n\n\tprivate MutationExecutor executor(SharedSessionContractImplementor session, MutationOperationGroup group, boolean dynamicUpdate) {\n\t\treturn mutationExecutorService\n\t\t\t\t.createExecutor( resolveBatchKeyAccess( dynamicUpdate, session ), group, session );\n\t}\n\n\tprotected static TableInclusionChecker getTableInclusionChecker(InsertValuesAnalysis insertValuesAnalysis) {\n\t\treturn tableMapping -> !tableMapping.isOptional() || insertValuesAnalysis.hasNonNullBindings( tableMapping );\n\t}\n\n\n\t/**\n\t * Transform the array of property indexes to an array of booleans,\n\t * true when the property is insertable and non-null\n\t */\n\tpublic boolean[] getPropertiesToInsert(Object[] fields) {\n\t\tboolean[] notNull = new boolean[fields.length];\n\t\tboolean[] insertable = entityPersister().getPropertyInsertability();\n\t\tfor ( int i = 0; i < fields.length; i++ ) {\n\t\t\tnotNull[i] = insertable[i] && fields[i] != null;\n\t\t}\n\t\treturn notNull;\n\t}\n\n\tprotected MutationOperationGroup generateDynamicInsertSqlGroup(\n\t\t\tboolean[] insertable,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\n\t\tfinal MutationGroupBuilder insertGroupBuilder = new MutationGroupBuilder( MutationType.INSERT, entityPersister() );\n\t\tentityPersister().forEachMutableTable(\n\t\t\t\t(tableMapping) -> insertGroupBuilder.addTableDetailsBuilder( createTableInsertBuilder( tableMapping, forceIdentifierBinding ) )\n\t\t);\n\t\tapplyTableInsertDetails( insertGroupBuilder, insertable, object, session, forceIdentifierBinding );\n\t\treturn createOperationGroup( null, insertGroupBuilder.buildMutationGroup() );\n\t}\n\n\tpublic MutationOperationGroup generateStaticOperationGroup() {\n\t\tfinal MutationGroupBuilder insertGroupBuilder = new MutationGroupBuilder( MutationType.INSERT, entityPersister() );\n\t\tentityPersister().forEachMutableTable(\n\t\t\t\t(tableMapping) -> insertGroupBuilder.addTableDetailsBuilder( createTableInsertBuilder( tableMapping, false ) )\n\t\t);\n\t\tapplyTableInsertDetails( insertGroupBuilder, entityPersister().getPropertyInsertability(), null, null, false );\n\t\treturn createOperationGroup( null, insertGroupBuilder.buildMutationGroup() );\n\t}\n\n\tprivate TableMutationBuilder<?> createTableInsertBuilder(EntityTableMapping tableMapping, boolean forceIdentifierBinding) {\n\t\tfinal GeneratedValuesMutationDelegate delegate = entityPersister().getInsertDelegate();\n\t\tif ( tableMapping.isIdentifierTable() && delegate != null && !forceIdentifierBinding ) {\n\t\t\treturn delegate.createTableMutationBuilder( tableMapping.getInsertExpectation(), factory() );\n\t\t}\n\t\telse {\n\t\t\treturn new TableInsertBuilderStandard( entityPersister(), tableMapping, factory() );\n\t\t}\n\t}\n\n\tprivate void applyTableInsertDetails(\n\t\t\tMutationGroupBuilder insertGroupBuilder,\n\t\t\tboolean[] attributeInclusions,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\n\t\tfinal AttributeMappingsList attributeMappings = entityPersister().getAttributeMappings();\n\n\t\tinsertGroupBuilder.forEachTableMutationBuilder( (builder) -> {\n\t\t\tfinal EntityTableMapping tableMapping = (EntityTableMapping) builder.getMutatingTable().getTableMapping();\n\t\t\tassert !tableMapping.isInverse();\n\n\t\t\t// `attributeIndexes` represents the indexes (relative to `attributeMappings`) of\n\t\t\t// the attributes mapped to the table\n\t\t\tfinal int[] attributeIndexes = tableMapping.getAttributeIndexes();\n\t\t\tfor ( int i = 0; i < attributeIndexes.length; i++ ) {\n\t\t\t\tfinal int attributeIndex = attributeIndexes[ i ];\n\t\t\t\tfinal AttributeMapping attributeMapping = attributeMappings.get( attributeIndex );\n\t\t\t\tif ( attributeInclusions[attributeIndex] ) {\n\t\t\t\t\tattributeMapping.forEachInsertable( insertGroupBuilder );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfinal Generator generator = attributeMapping.getGenerator();\n\t\t\t\t\tif ( isValueGenerated( generator ) ) {\n\t\t\t\t\t\tif ( session != null && !generator.generatedOnExecution( object, session ) ) {\n\t\t\t\t\t\t\tattributeInclusions[attributeIndex] = true;\n\t\t\t\t\t\t\tattributeMapping.forEachInsertable( insertGroupBuilder );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ( isValueGenerationInSql( generator, factory.getJdbcServices().getDialect() ) ) {\n\t\t\t\t\t\t\thandleValueGeneration( attributeMapping, insertGroupBuilder, (OnExecutionGenerator) generator );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t\t// add the discriminator\n\t\tentityPersister().addDiscriminatorToInsertGroup( insertGroupBuilder );\n\t\tentityPersister().addSoftDeleteToInsertGroup( insertGroupBuilder );\n\n\t\t// add the keys\n\t\tinsertGroupBuilder.forEachTableMutationBuilder( (tableMutationBuilder) -> {\n\t\t\tfinal TableInsertBuilder tableInsertBuilder = (TableInsertBuilder) tableMutationBuilder;\n\t\t\tfinal EntityTableMapping tableMapping = (EntityTableMapping) tableInsertBuilder.getMutatingTable().getTableMapping();\n\t\t\tif ( tableMapping.isIdentifierTable() && entityPersister().isIdentifierAssignedByInsert() && !forceIdentifierBinding ) {\n\t\t\t\tassert entityPersister().getInsertDelegate() != null;\n\t\t\t\tfinal OnExecutionGenerator generator = (OnExecutionGenerator) entityPersister().getGenerator();\n\t\t\t\tif ( generator.referenceColumnsInSql( dialect() ) ) {\n\t\t\t\t\tfinal BasicEntityIdentifierMapping identifierMapping = (BasicEntityIdentifierMapping) entityPersister().getIdentifierMapping();\n\t\t\t\t\tfinal String[] columnValues = generator.getReferencedColumnValues( dialect );\n\t\t\t\t\ttableMapping.getKeyMapping().forEachKeyColumn( (i, column) -> tableInsertBuilder.addKeyColumn(\n\t\t\t\t\t\t\tcolumn.getColumnName(),\n\t\t\t\t\t\t\tcolumnValues[i],\n\t\t\t\t\t\t\tidentifierMapping.getJdbcMapping()\n\t\t\t\t\t) );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttableMapping.getKeyMapping().forEachKeyColumn( tableInsertBuilder::addKeyColumn );\n\t\t\t}\n\t\t} );\n\t}\n\n\tprivate static boolean isValueGenerated(Generator generator) {\n\t\treturn generator != null\n\t\t\t\t&& generator.generatesOnInsert()\n\t\t\t\t&& generator.generatedOnExecution();\n\t}\n\n\tprivate static boolean isValueGenerationInSql(Generator generator, Dialect dialect) {\n\t\tassert isValueGenerated( generator );\n\t\treturn ( (OnExecutionGenerator) generator ).referenceColumnsInSql(dialect);\n\t}\n\n\t/**\n\t * @deprecated Use {@link #getBatchKey()}\n\t */\n\t@Deprecated\n\tpublic BasicBatchKey getInsertBatchKey() {\n\t\treturn batchKey;\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private static boolean verifyOutcome(PreparedStatementDetails statementDetails, int affectedRowCount, int batchPosition)\n\t\t\tthrows SQLException {\n\t\tstatementDetails.getExpectation().verifyOutcome(\n\t\t\t\taffectedRowCount,\n\t\t\t\tstatementDetails.getStatement(),\n\t\t\t\tbatchPosition,\n\t\t\t\tstatementDetails.getSqlString()\n\t\t);\n\t\treturn true;\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#decomposeForInsert\n methodBody: protected void decomposeForInsert(\n\t\t\tMutationExecutor mutationExecutor,\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tMutationOperationGroup mutationGroup,\n\t\t\tboolean[] propertyInclusions,\n\t\t\tTableInclusionChecker tableInclusionChecker,\n\t\t\tSharedSessionContractImplementor session) {\nfinal JdbcValueBindings jdbcValueBindings=mutationExecutor.getJdbcValueBindings();\nfinal AttributeMappingsList attributeMappings=entityPersister().getAttributeMappings();\nfor(int position=0; position < mutationGroup.getNumberOfOperations(); position++){final MutationOperation operation=mutationGroup.getOperation(position);\nfinal EntityTableMapping tableDetails=(EntityTableMapping)operation.getTableDetails();\nif(tableInclusionChecker.include(tableDetails)){final int[] attributeIndexes=tableDetails.getAttributeIndexes();\nfor(int i=0; i < attributeIndexes.length; i++){final int attributeIndex=attributeIndexes[i];\nif(propertyInclusions[attributeIndex]){final AttributeMapping mapping=attributeMappings.get(attributeIndex);\ndecomposeAttribute(values[attributeIndex],session,jdbcValueBindings,mapping);\n}}}}if(id == null){assert entityPersister().getInsertDelegate() != null;\n}{for(int position=0; position < mutationGroup.getNumberOfOperations(); position++){final MutationOperation jdbcOperation=mutationGroup.getOperation(position);\nfinal EntityTableMapping tableDetails=(EntityTableMapping)jdbcOperation.getTableDetails();\nbreakDownJdbcValue(id,session,jdbcValueBindings,tableDetails);\n}}}",
            "methodSignature: org.hibernate.engine.jdbc.mutation.internal.MutationExecutorStandard#release\n methodBody: public void release() {\nnonBatchedStatementGroup.release();\n}",
            "methodSignature: org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#getTableInclusionChecker\n methodBody: protected static TableInclusionChecker getTableInclusionChecker(InsertValuesAnalysis insertValuesAnalysis) {\nreturn tableMapping -> !tableMapping.isOptional() || insertValuesAnalysis.hasNonNullBindings(tableMapping);\n}",
            "methodSignature: org.hibernate.engine.jdbc.mutation.internal.AbstractMutationExecutor#execute\n methodBody: public final GeneratedValues execute(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session) {\nfinal GeneratedValues generatedValues=performNonBatchedOperations(modelReference,valuesAnalysis,inclusionChecker,resultChecker,session);\nperformSelfExecutingOperations(valuesAnalysis,inclusionChecker,session);\nperformBatchedOperations(valuesAnalysis,inclusionChecker);\nreturn generatedValues;\n}",
            "methodSignature: org.hibernate.orm.test.jpa.transaction.batch.AbstractBatchingTest.BatchWrapper#execute\n methodBody: public void execute() {\nwrapped.execute();\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#execute\n methodBody: void execute();",
            "methodSignature: org.hibernate.orm.test.jpa.transaction.batch.AbstractBatchingTest.BatchWrapper#release\n methodBody: public void release() {\nwasReleaseCalled=true;\nwrapped.release();\nnumberOfStatementsAfterRelease=wrapped.getStatementGroup().getNumberOfActiveStatements();\n}",
            "methodSignature: org.hibernate.persister.entity.mutation.AbstractDeleteCoordinator#executor\n methodBody: private MutationExecutor executor(SharedSessionContractImplementor session, MutationOperationGroup group) {\nreturn mutationExecutorService.createExecutor(resolveBatchKeyAccess(false,session),group,session);\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.BatchImpl#execute\n methodBody: public void execute() {\nnotifyObserversExplicitExecution();\nif(getStatementGroup().getNumberOfStatements() == 0){return;\n}tryif(batchPosition == 0){if(!batchExecuted){if(BATCH_LOGGER.isDebugEnabled()){BATCH_LOGGER.debugf(\"No batched statements to execute - %s\",getKey().toLoggableString());\n}}}{performExecution();\n}finallyreleaseStatements();\n}",
            "methodSignature: org.hibernate.persister.entity.AbstractEntityPersister#getPropertyInsertability\n methodBody: public boolean[] getPropertyInsertability() {\nreturn entityMetamodel.getPropertyInsertability();\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#release\n methodBody: void release();",
            "methodSignature: org.hibernate.engine.jdbc.mutation.internal.MutationExecutorSingleBatched#release\n methodBody: public void release() {\n}",
            "methodSignature: org.hibernate.engine.jdbc.mutation.MutationExecutor#release\n methodBody: void release();",
            "methodSignature: org.hibernate.persister.entity.mutation.UpdateCoordinatorStandard#executor\n methodBody: private MutationExecutor executor(SharedSessionContractImplementor session, MutationOperationGroup group, boolean dynamicUpdate) {\nreturn mutationExecutorService.createExecutor(resolveBatchKeyAccess(dynamicUpdate,session),group,session);\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.BatchImpl#release\n methodBody: public void release() {\nif(BATCH_MESSAGE_LOGGER.isInfoEnabled()){final PreparedStatementGroup statementGroup=getStatementGroup();\nif(statementGroup.getNumberOfStatements() != 0){if(statementGroup.hasMatching((statementDetails) -> statementDetails.getStatement() != null)){BATCH_MESSAGE_LOGGER.batchContainedStatementsOnRelease();\n}}}releaseStatements();\nobservers.clear();\n}",
            "methodSignature: org.hibernate.persister.entity.mutation.AbstractMutationCoordinator#entityPersister\n methodBody: protected EntityPersister entityPersister() {\nreturn entityPersister;\n}",
            "methodSignature: org.hibernate.engine.jdbc.mutation.MutationExecutor#execute\n methodBody: GeneratedValues execute(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session);",
            "methodSignature: org.hibernate.persister.entity.mutation.InsertCoordinatorStandard#executor\n methodBody: private MutationExecutor executor(SharedSessionContractImplementor session, MutationOperationGroup group, boolean dynamicUpdate) {\nreturn mutationExecutorService.createExecutor(resolveBatchKeyAccess(dynamicUpdate,session),group,session);\n}"
        ],
        "sourceCodeAfterRefactoring": "protected GeneratedValues doStaticInserts(Object id, Object[] values, Object object, SharedSessionContractImplementor session) {\n\t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n\n\t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n\n\t\tfinal MutationExecutor mutationExecutor = executor( session, staticInsertGroup, false );\n\n\t\tdecomposeForInsert(\n\t\t\t\tmutationExecutor,\n\t\t\t\tid,\n\t\t\t\tvalues,\n\t\t\t\tstaticInsertGroup,\n\t\t\t\tentityPersister().getPropertyInsertability(),\n\t\t\t\ttableInclusionChecker,\n\t\t\t\tsession\n\t\t);\n\n\t\ttry {\n\t\t\treturn mutationExecutor.execute(\n\t\t\t\t\tobject,\n\t\t\t\t\tinsertValuesAnalysis,\n\t\t\t\t\ttableInclusionChecker,\n\t\t\t\t\tInsertCoordinatorStandard::verifyOutcome,\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tmutationExecutor.release();\n\t\t}\n\t}\nprivate static boolean verifyOutcome(PreparedStatementDetails statementDetails, int affectedRowCount, int batchPosition)\n\t\t\tthrows SQLException {\n\t\tstatementDetails.getExpectation().verifyOutcome(\n\t\t\t\taffectedRowCount,\n\t\t\t\tstatementDetails.getStatement(),\n\t\t\t\tbatchPosition,\n\t\t\t\tstatementDetails.getSqlString()\n\t\t);\n\t\treturn true;\n\t}",
        "diffSourceCode": "-  173: \tprotected GeneratedValues doStaticInserts(Object id, Object[] values, Object object, SharedSessionContractImplementor session) {\n-  174: \t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n-  175: \n-  176: \t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n+  173: \t}\n+  174: \n+  175: \tprotected GeneratedValues doStaticInserts(Object id, Object[] values, Object object, SharedSessionContractImplementor session) {\n+  176: \t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n   177: \n-  178: \t\tfinal MutationExecutor mutationExecutor = executor( session, staticInsertGroup, false );\n+  178: \t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n   179: \n-  180: \t\tdecomposeForInsert(\n-  181: \t\t\t\tmutationExecutor,\n-  182: \t\t\t\tid,\n-  183: \t\t\t\tvalues,\n-  184: \t\t\t\tstaticInsertGroup,\n-  185: \t\t\t\tentityPersister().getPropertyInsertability(),\n-  186: \t\t\t\ttableInclusionChecker,\n-  187: \t\t\t\tsession\n-  188: \t\t);\n-  189: \n-  190: \t\ttry {\n-  191: \t\t\treturn mutationExecutor.execute(\n-  192: \t\t\t\t\tobject,\n-  193: \t\t\t\t\tinsertValuesAnalysis,\n-  194: \t\t\t\t\ttableInclusionChecker,\n-  195: \t\t\t\t\t(statementDetails, affectedRowCount, batchPosition) -> {\n-  196: \t\t\t\t\t\tstatementDetails.getExpectation().verifyOutcome(\n-  197: \t\t\t\t\t\t\t\taffectedRowCount,\n-  198: \t\t\t\t\t\t\t\tstatementDetails.getStatement(),\n-  199: \t\t\t\t\t\t\t\tbatchPosition,\n-  200: \t\t\t\t\t\t\t\tstatementDetails.getSqlString()\n-  201: \t\t\t\t\t\t);\n-  202: \t\t\t\t\t\treturn true;\n-  203: \t\t\t\t\t},\n-  204: \t\t\t\t\tsession\n-  205: \t\t\t);\n-  206: \t\t}\n-  207: \t\tfinally {\n-  208: \t\t\tmutationExecutor.release();\n-  209: \t\t}\n-  210: \t}\n-  322: \t\t\t\t\t\t\t\tbatchPosition,\n-  323: \t\t\t\t\t\t\t\tstatementDetails.getSqlString()\n-  324: \t\t\t\t\t\t);\n-  325: \t\t\t\t\t\treturn true;\n-  326: \t\t\t\t\t},\n-  327: \t\t\t\t\tsession\n-  328: \t\t\t);\n-  329: \t\t}\n-  330: \t\tfinally {\n-  331: \t\t\tmutationExecutor.release();\n+  180: \t\tfinal MutationExecutor mutationExecutor = executor( session, staticInsertGroup, false );\n+  181: \n+  182: \t\tdecomposeForInsert(\n+  183: \t\t\t\tmutationExecutor,\n+  184: \t\t\t\tid,\n+  185: \t\t\t\tvalues,\n+  186: \t\t\t\tstaticInsertGroup,\n+  187: \t\t\t\tentityPersister().getPropertyInsertability(),\n+  188: \t\t\t\ttableInclusionChecker,\n+  189: \t\t\t\tsession\n+  190: \t\t);\n+  191: \n+  192: \t\ttry {\n+  193: \t\t\treturn mutationExecutor.execute(\n+  194: \t\t\t\t\tobject,\n+  195: \t\t\t\t\tinsertValuesAnalysis,\n+  196: \t\t\t\t\ttableInclusionChecker,\n+  197: \t\t\t\t\tInsertCoordinatorStandard::verifyOutcome,\n+  198: \t\t\t\t\tsession\n+  199: \t\t\t);\n+  200: \t\t}\n+  201: \t\tfinally {\n+  202: \t\t\tmutationExecutor.release();\n+  203: \t\t}\n+  204: \t}\n+  205: \n+  206: \tprotected void decomposeForInsert(\n+  207: \t\t\tMutationExecutor mutationExecutor,\n+  208: \t\t\tObject id,\n+  209: \t\t\tObject[] values,\n+  210: \t\t\tMutationOperationGroup mutationGroup,\n+  322: \tprivate static boolean verifyOutcome(PreparedStatementDetails statementDetails, int affectedRowCount, int batchPosition)\n+  323: \t\t\tthrows SQLException {\n+  324: \t\tstatementDetails.getExpectation().verifyOutcome(\n+  325: \t\t\t\taffectedRowCount,\n+  326: \t\t\t\tstatementDetails.getStatement(),\n+  327: \t\t\t\tbatchPosition,\n+  328: \t\t\t\tstatementDetails.getSqlString()\n+  329: \t\t);\n+  330: \t\treturn true;\n+  331: \t}\n",
        "uniqueId": "ee00217733018075ccade7e1145f45ff9acae0c2_173_210_322_331_175_204",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 41
            },
            "LINE": {
                "missed": 0,
                "covered": 7
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": true,
        "refactoredCode": "##########################\nprotected GeneratedValues doStaticInserts(Object id, Object[] values, Object object, SharedSessionContractImplementor session) {\n\t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n\n\t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n\n\t\tfinal MutationExecutor mutationExecutor = executor( session, staticInsertGroup, false );\n\n\t\tdecomposeForInsert(\n\t\t\t\tmutationExecutor,\n\t\t\t\tid,\n\t\t\t\tvalues,\n\t\t\t\tstaticInsertGroup,\n\t\t\t\tentityPersister().getPropertyInsertability(),\n\t\t\t\ttableInclusionChecker,\n\t\t\t\tsession\n\t\t);\n\n\t\ttry {\n\t\t\treturn mutationExecutor.execute(\n\t\t\t\t\tobject,\n\t\t\t\t\tinsertValuesAnalysis,\n\t\t\t\t\ttableInclusionChecker,\n\t\t\t\t\t(statementDetails, affectedRowCount, batchPosition) -> {\n\t\t\t\t\t\tstatementDetails.getExpectation().verifyOutcome(\n\t\t\t\t\t\t\t\taffectedRowCount,\n\t\t\t\t\t\t\t\tstatementDetails.getStatement(),\n\t\t\t\t\t\t\t\tbatchPosition,\n\t\t\t\t\t\t\t\tstatementDetails.getSqlString()\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tmutationExecutor.release();\n\t\t}\n\t}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprotected GeneratedValues doStaticInserts(Object id, Object[] values, Object object, SharedSessionContractImplementor session) {\n\t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n\n\t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n\n\t\tfinal MutationExecutor mutationExecutor = executor( session, staticInsertGroup, false );\n\n\t\tdecomposeForInsert(\n\t\t\t\tmutationExecutor,\n\t\t\t\tid,\n\t\t\t\tvalues,\n\t\t\t\tstaticInsertGroup,\n\t\t\t\tentityPersister().getPropertyInsertability(),\n\t\t\t\ttableInclusionChecker,\n\t\t\t\tsession\n\t\t);\n\n\t\ttry {\n\t\t\treturn mutationExecutor.execute(\n\t\t\t\t\tobject,\n\t\t\t\t\tinsertValuesAnalysis,\n\t\t\t\t\ttableInclusionChecker,\n\t\t\t\t\t(statementDetails, affectedRowCount, batchPosition) -> {\n\t\t\t\t\t\tstatementDetails.getExpectation().verifyOutcome(\n\t\t\t\t\t\t\t\taffectedRowCount,\n\t\t\t\t\t\t\t\tstatementDetails.getStatement(),\n\t\t\t\t\t\t\t\tbatchPosition,\n\t\t\t\t\t\t\t\tstatementDetails.getSqlString()\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tmutationExecutor.release();\n\t\t}\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html.\n */\npackage org.hibernate.persister.entity.mutation;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.hibernate.Internal;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.batch.internal.BasicBatchKey;\nimport org.hibernate.engine.jdbc.batch.spi.BatchKey;\nimport org.hibernate.engine.jdbc.mutation.JdbcValueBindings;\nimport org.hibernate.engine.jdbc.mutation.MutationExecutor;\nimport org.hibernate.engine.jdbc.mutation.ParameterUsage;\nimport org.hibernate.engine.jdbc.mutation.TableInclusionChecker;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.engine.spi.SharedSessionContractImplementor;\nimport org.hibernate.generator.BeforeExecutionGenerator;\nimport org.hibernate.generator.Generator;\nimport org.hibernate.generator.OnExecutionGenerator;\nimport org.hibernate.generator.values.GeneratedValues;\nimport org.hibernate.generator.values.GeneratedValuesMutationDelegate;\nimport org.hibernate.metamodel.mapping.AttributeMapping;\nimport org.hibernate.metamodel.mapping.AttributeMappingsList;\nimport org.hibernate.metamodel.mapping.BasicEntityIdentifierMapping;\nimport org.hibernate.metamodel.mapping.PluralAttributeMapping;\nimport org.hibernate.persister.entity.EntityPersister;\nimport org.hibernate.sql.model.MutationOperation;\nimport org.hibernate.sql.model.MutationOperationGroup;\nimport org.hibernate.sql.model.MutationType;\nimport org.hibernate.sql.model.TableMapping;\nimport org.hibernate.sql.model.ValuesAnalysis;\nimport org.hibernate.sql.model.ast.builder.MutationGroupBuilder;\nimport org.hibernate.sql.model.ast.builder.TableInsertBuilder;\nimport org.hibernate.sql.model.ast.builder.TableInsertBuilderStandard;\nimport org.hibernate.sql.model.ast.builder.TableMutationBuilder;\nimport org.hibernate.tuple.entity.EntityMetamodel;\n\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport static org.hibernate.generator.EventType.INSERT;\n\n/**\n * Coordinates the insertion of an entity.\n *\n * @see #coordinateInsert\n *\n * @author Steve Ebersole\n */\n@Internal\npublic class InsertCoordinatorStandard extends AbstractMutationCoordinator implements InsertCoordinator {\n\tprivate final MutationOperationGroup staticInsertGroup;\n\tprivate final BasicBatchKey batchKey;\n\n\tpublic InsertCoordinatorStandard(EntityPersister entityPersister, SessionFactoryImplementor factory) {\n\t\tsuper( entityPersister, factory );\n\n\t\tif ( entityPersister.isIdentifierAssignedByInsert() || entityPersister.hasInsertGeneratedProperties() ) {\n\t\t\t// disable batching in case of insert generated identifier or properties\n\t\t\tbatchKey = null;\n\t\t}\n\t\telse {\n\t\t\tbatchKey = new BasicBatchKey( entityPersister.getEntityName() + \"#INSERT\" );\n\t\t}\n\n\t\tif ( entityPersister.getEntityMetamodel().isDynamicInsert() ) {\n\t\t\t// the entity specified dynamic-insert - skip generating the\n\t\t\t// static inserts as we will create them every time\n\t\t\tstaticInsertGroup = null;\n\t\t}\n\t\telse {\n\t\t\tstaticInsertGroup = generateStaticOperationGroup();\n\t\t}\n\t}\n\n\t@Override\n\tpublic MutationOperationGroup getStaticMutationOperationGroup() {\n\t\treturn staticInsertGroup;\n\t}\n\n\t@Override\n\tprotected BatchKey getBatchKey() {\n\t\treturn batchKey;\n\t}\n\n\t@Override\n\tpublic @Nullable GeneratedValues insert(Object entity, Object[] values, SharedSessionContractImplementor session) {\n\t\treturn coordinateInsert( null, values, entity, session );\n\t}\n\n\t@Override\n\tpublic @Nullable GeneratedValues insert(\n\t\t\tObject entity,\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tSharedSessionContractImplementor session) {\n\t\treturn coordinateInsert( id, values, entity, session );\n\t}\n\n\t/**\n\t * Perform the insert(s).\n\t *\n\t * @param id This is the id as known in memory. For post-insert id generation (IDENTITY, etc)\n\t * this will be null.\n\t * @param values The extracted attribute values\n\t * @param entity The entity instance being persisted\n\t * @param session The originating context\n\t *\n\t * @return The {@linkplain GeneratedValues generated values} if any, {@code null} otherwise.\n\t */\n\tpublic GeneratedValues coordinateInsert(\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tObject entity,\n\t\t\tSharedSessionContractImplementor session) {\n\t\t// apply any pre-insert in-memory value generation\n\t\tfinal boolean needsDynamicInsert = preInsertInMemoryValueGeneration( values, entity, session );\n\n\t\tfinal EntityMetamodel entityMetamodel = entityPersister().getEntityMetamodel();\n\t\tfinal boolean forceIdentifierBinding = entityPersister().getGenerator().generatedOnExecution() && id != null;\n\t\tif ( entityMetamodel.isDynamicInsert() || needsDynamicInsert || forceIdentifierBinding ) {\n\t\t\treturn doDynamicInserts( id, values, entity, session, forceIdentifierBinding );\n\t\t}\n\t\telse {\n\t\t\treturn doStaticInserts( id, values, entity, session );\n\t\t}\n\t}\n\n\tprotected boolean preInsertInMemoryValueGeneration(Object[] values, Object entity, SharedSessionContractImplementor session) {\n\t\tfinal EntityPersister persister = entityPersister();\n\t\tfinal EntityMetamodel entityMetamodel = persister.getEntityMetamodel();\n\t\tboolean foundStateDependentGenerator = false;\n\t\tif ( entityMetamodel.hasPreInsertGeneratedValues() ) {\n\t\t\tfinal Generator[] generators = entityMetamodel.getGenerators();\n\t\t\tfor ( int i = 0; i < generators.length; i++ ) {\n\t\t\t\tfinal Generator generator = generators[i];\n\t\t\t\tif ( generator != null\n\t\t\t\t\t\t&& generator.generatesOnInsert()\n\t\t\t\t\t\t&& !generator.generatedOnExecution( entity, session ) ) {\n\t\t\t\t\tvalues[i] = ( (BeforeExecutionGenerator) generator ).generate( session, entity, values[i], INSERT );\n\t\t\t\t\tpersister.setPropertyValue( entity, i, values[i] );\n\t\t\t\t\tfoundStateDependentGenerator = foundStateDependentGenerator || generator.generatedOnExecution();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn foundStateDependentGenerator;\n\t}\n\n\tpublic static class InsertValuesAnalysis implements ValuesAnalysis {\n\t\tprivate final List<TableMapping> tablesWithNonNullValues = new ArrayList<>();\n\n\t\tpublic InsertValuesAnalysis(EntityMutationTarget mutationTarget, Object[] values) {\n\t\t\tmutationTarget.forEachMutableTable( (tableMapping) -> {\n\t\t\t\tfinal int[] tableAttributeIndexes = tableMapping.getAttributeIndexes();\n\t\t\t\tfor ( int i = 0; i < tableAttributeIndexes.length; i++ ) {\n\t\t\t\t\tif ( values[tableAttributeIndexes[i]] != null ) {\n\t\t\t\t\t\ttablesWithNonNullValues.add( tableMapping );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\tpublic boolean hasNonNullBindings(TableMapping tableMapping) {\n\t\t\treturn tablesWithNonNullValues.contains( tableMapping );\n\t\t}\n\t}\n\n\tprotected GeneratedValues doStaticInserts(Object id, Object[] values, Object object, SharedSessionContractImplementor session) {\n\t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n\n\t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n\n\t\tfinal MutationExecutor mutationExecutor = executor( session, staticInsertGroup, false );\n\n\t\tdecomposeForInsert(\n\t\t\t\tmutationExecutor,\n\t\t\t\tid,\n\t\t\t\tvalues,\n\t\t\t\tstaticInsertGroup,\n\t\t\t\tentityPersister().getPropertyInsertability(),\n\t\t\t\ttableInclusionChecker,\n\t\t\t\tsession\n\t\t);\n\n\t\ttry {\n\t\t\treturn mutationExecutor.execute(\n\t\t\t\t\tobject,\n\t\t\t\t\tinsertValuesAnalysis,\n\t\t\t\t\ttableInclusionChecker,\n\t\t\t\t\t(statementDetails, affectedRowCount, batchPosition) -> {\n\t\t\t\t\t\tstatementDetails.getExpectation().verifyOutcome(\n\t\t\t\t\t\t\t\taffectedRowCount,\n\t\t\t\t\t\t\t\tstatementDetails.getStatement(),\n\t\t\t\t\t\t\t\tbatchPosition,\n\t\t\t\t\t\t\t\tstatementDetails.getSqlString()\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tmutationExecutor.release();\n\t\t}\n\t}\n\n\tprotected void decomposeForInsert(\n\t\t\tMutationExecutor mutationExecutor,\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tMutationOperationGroup mutationGroup,\n\t\t\tboolean[] propertyInclusions,\n\t\t\tTableInclusionChecker tableInclusionChecker,\n\t\t\tSharedSessionContractImplementor session) {\n\t\tfinal JdbcValueBindings jdbcValueBindings = mutationExecutor.getJdbcValueBindings();\n\t\tfinal AttributeMappingsList attributeMappings = entityPersister().getAttributeMappings();\n\n\t\tfor ( int position = 0; position < mutationGroup.getNumberOfOperations(); position++ ) {\n\t\t\tfinal MutationOperation operation = mutationGroup.getOperation( position );\n\t\t\tfinal EntityTableMapping tableDetails = (EntityTableMapping) operation.getTableDetails();\n\t\t\tif ( tableInclusionChecker.include( tableDetails ) ) {\n\t\t\t\tfinal int[] attributeIndexes = tableDetails.getAttributeIndexes();\n\t\t\t\tfor ( int i = 0; i < attributeIndexes.length; i++ ) {\n\t\t\t\t\tfinal int attributeIndex = attributeIndexes[ i ];\n\t\t\t\t\tif ( propertyInclusions[attributeIndex] ) {\n\t\t\t\t\t\tfinal AttributeMapping mapping = attributeMappings.get( attributeIndex );\n\t\t\t\t\t\tdecomposeAttribute( values[attributeIndex], session, jdbcValueBindings, mapping );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( id == null ) {\n\t\t\tassert entityPersister().getInsertDelegate() != null;\n\t\t}\n\t\telse {\n\t\t\tfor ( int position = 0; position < mutationGroup.getNumberOfOperations(); position++ ) {\n\t\t\t\tfinal MutationOperation jdbcOperation = mutationGroup.getOperation( position );\n\t\t\t\tfinal EntityTableMapping tableDetails = (EntityTableMapping) jdbcOperation.getTableDetails();\n\t\t\t\tbreakDownJdbcValue( id, session, jdbcValueBindings, tableDetails );\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected void breakDownJdbcValue(\n\t\t\tObject id,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tJdbcValueBindings jdbcValueBindings,\n\t\t\tEntityTableMapping tableDetails) {\n\t\tfinal String tableName = tableDetails.getTableName();\n\t\ttableDetails.getKeyMapping().breakDownKeyJdbcValues(\n\t\t\t\tid,\n\t\t\t\t(jdbcValue, columnMapping) -> {\n\t\t\t\t\tjdbcValueBindings.bindValue(\n\t\t\t\t\t\t\tjdbcValue,\n\t\t\t\t\t\t\ttableName,\n\t\t\t\t\t\t\tcolumnMapping.getColumnName(),\n\t\t\t\t\t\t\tParameterUsage.SET\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t\tsession\n\t\t);\n\t}\n\n\tprotected void decomposeAttribute(\n\t\t\tObject value,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tJdbcValueBindings jdbcValueBindings,\n\t\t\tAttributeMapping mapping) {\n\t\tif ( !(mapping instanceof PluralAttributeMapping) ) {\n\t\t\tmapping.decompose(\n\t\t\t\t\tvalue,\n\t\t\t\t\t0,\n\t\t\t\t\tjdbcValueBindings,\n\t\t\t\t\tnull,\n\t\t\t\t\t(valueIndex, bindings, noop, jdbcValue, selectableMapping) -> {\n\t\t\t\t\t\tif ( selectableMapping.isInsertable() ) {\n\t\t\t\t\t\t\tbindings.bindValue(\n\t\t\t\t\t\t\t\t\tjdbcValue,\n\t\t\t\t\t\t\t\t\tentityPersister().physicalTableNameForMutation( selectableMapping ),\n\t\t\t\t\t\t\t\t\tselectableMapping.getSelectionExpression(),\n\t\t\t\t\t\t\t\t\tParameterUsage.SET\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t}\n\n\tprotected GeneratedValues doDynamicInserts(\n\t\t\tObject id,\n\t\t\tObject[] values,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\n\t\tfinal boolean[] insertability = getPropertiesToInsert( values );\n\t\tfinal MutationOperationGroup insertGroup = generateDynamicInsertSqlGroup( insertability, object, session, forceIdentifierBinding );\n\n\t\tfinal MutationExecutor mutationExecutor = executor( session, insertGroup, true );\n\n\t\tfinal InsertValuesAnalysis insertValuesAnalysis = new InsertValuesAnalysis( entityPersister(), values );\n\n\t\tfinal TableInclusionChecker tableInclusionChecker = getTableInclusionChecker( insertValuesAnalysis );\n\n\t\tdecomposeForInsert( mutationExecutor, id, values, insertGroup, insertability, tableInclusionChecker, session );\n\n\t\ttry {\n\t\t\treturn mutationExecutor.execute(\n\t\t\t\t\tobject,\n\t\t\t\t\tinsertValuesAnalysis,\n\t\t\t\t\ttableInclusionChecker,\n\t\t\t\t\t(statementDetails, affectedRowCount, batchPosition) -> {\n\t\t\t\t\t\tstatementDetails.getExpectation().verifyOutcome(\n\t\t\t\t\t\t\t\taffectedRowCount,\n\t\t\t\t\t\t\t\tstatementDetails.getStatement(),\n\t\t\t\t\t\t\t\tbatchPosition,\n\t\t\t\t\t\t\t\tstatementDetails.getSqlString()\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t},\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tmutationExecutor.release();\n\t\t}\n\t}\n\n\tprivate MutationExecutor executor(SharedSessionContractImplementor session, MutationOperationGroup group, boolean dynamicUpdate) {\n\t\treturn mutationExecutorService\n\t\t\t\t.createExecutor( resolveBatchKeyAccess( dynamicUpdate, session ), group, session );\n\t}\n\n\tprotected static TableInclusionChecker getTableInclusionChecker(InsertValuesAnalysis insertValuesAnalysis) {\n\t\treturn tableMapping -> !tableMapping.isOptional() || insertValuesAnalysis.hasNonNullBindings( tableMapping );\n\t}\n\n\n\t/**\n\t * Transform the array of property indexes to an array of booleans,\n\t * true when the property is insertable and non-null\n\t */\n\tpublic boolean[] getPropertiesToInsert(Object[] fields) {\n\t\tboolean[] notNull = new boolean[fields.length];\n\t\tboolean[] insertable = entityPersister().getPropertyInsertability();\n\t\tfor ( int i = 0; i < fields.length; i++ ) {\n\t\t\tnotNull[i] = insertable[i] && fields[i] != null;\n\t\t}\n\t\treturn notNull;\n\t}\n\n\tprotected MutationOperationGroup generateDynamicInsertSqlGroup(\n\t\t\tboolean[] insertable,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\n\t\tfinal MutationGroupBuilder insertGroupBuilder = new MutationGroupBuilder( MutationType.INSERT, entityPersister() );\n\t\tentityPersister().forEachMutableTable(\n\t\t\t\t(tableMapping) -> insertGroupBuilder.addTableDetailsBuilder( createTableInsertBuilder( tableMapping, forceIdentifierBinding ) )\n\t\t);\n\t\tapplyTableInsertDetails( insertGroupBuilder, insertable, object, session, forceIdentifierBinding );\n\t\treturn createOperationGroup( null, insertGroupBuilder.buildMutationGroup() );\n\t}\n\n\tpublic MutationOperationGroup generateStaticOperationGroup() {\n\t\tfinal MutationGroupBuilder insertGroupBuilder = new MutationGroupBuilder( MutationType.INSERT, entityPersister() );\n\t\tentityPersister().forEachMutableTable(\n\t\t\t\t(tableMapping) -> insertGroupBuilder.addTableDetailsBuilder( createTableInsertBuilder( tableMapping, false ) )\n\t\t);\n\t\tapplyTableInsertDetails( insertGroupBuilder, entityPersister().getPropertyInsertability(), null, null, false );\n\t\treturn createOperationGroup( null, insertGroupBuilder.buildMutationGroup() );\n\t}\n\n\tprivate TableMutationBuilder<?> createTableInsertBuilder(EntityTableMapping tableMapping, boolean forceIdentifierBinding) {\n\t\tfinal GeneratedValuesMutationDelegate delegate = entityPersister().getInsertDelegate();\n\t\tif ( tableMapping.isIdentifierTable() && delegate != null && !forceIdentifierBinding ) {\n\t\t\treturn delegate.createTableMutationBuilder( tableMapping.getInsertExpectation(), factory() );\n\t\t}\n\t\telse {\n\t\t\treturn new TableInsertBuilderStandard( entityPersister(), tableMapping, factory() );\n\t\t}\n\t}\n\n\tprivate void applyTableInsertDetails(\n\t\t\tMutationGroupBuilder insertGroupBuilder,\n\t\t\tboolean[] attributeInclusions,\n\t\t\tObject object,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tboolean forceIdentifierBinding) {\n\t\tfinal AttributeMappingsList attributeMappings = entityPersister().getAttributeMappings();\n\n\t\tinsertGroupBuilder.forEachTableMutationBuilder( (builder) -> {\n\t\t\tfinal EntityTableMapping tableMapping = (EntityTableMapping) builder.getMutatingTable().getTableMapping();\n\t\t\tassert !tableMapping.isInverse();\n\n\t\t\t// `attributeIndexes` represents the indexes (relative to `attributeMappings`) of\n\t\t\t// the attributes mapped to the table\n\t\t\tfinal int[] attributeIndexes = tableMapping.getAttributeIndexes();\n\t\t\tfor ( int i = 0; i < attributeIndexes.length; i++ ) {\n\t\t\t\tfinal int attributeIndex = attributeIndexes[ i ];\n\t\t\t\tfinal AttributeMapping attributeMapping = attributeMappings.get( attributeIndex );\n\t\t\t\tif ( attributeInclusions[attributeIndex] ) {\n\t\t\t\t\tattributeMapping.forEachInsertable( insertGroupBuilder );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfinal Generator generator = attributeMapping.getGenerator();\n\t\t\t\t\tif ( isValueGenerated( generator ) ) {\n\t\t\t\t\t\tif ( session != null && !generator.generatedOnExecution( object, session ) ) {\n\t\t\t\t\t\t\tattributeInclusions[attributeIndex] = true;\n\t\t\t\t\t\t\tattributeMapping.forEachInsertable( insertGroupBuilder );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ( isValueGenerationInSql( generator, factory().getJdbcServices().getDialect() ) ) {\n\t\t\t\t\t\t\thandleValueGeneration( attributeMapping, insertGroupBuilder, (OnExecutionGenerator) generator );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t\t// add the discriminator\n\t\tentityPersister().addDiscriminatorToInsertGroup( insertGroupBuilder );\n\t\tentityPersister().addSoftDeleteToInsertGroup( insertGroupBuilder );\n\n\t\t// add the keys\n\t\tinsertGroupBuilder.forEachTableMutationBuilder( (tableMutationBuilder) -> {\n\t\t\tfinal TableInsertBuilder tableInsertBuilder = (TableInsertBuilder) tableMutationBuilder;\n\t\t\tfinal EntityTableMapping tableMapping = (EntityTableMapping) tableInsertBuilder.getMutatingTable().getTableMapping();\n\t\t\tif ( tableMapping.isIdentifierTable() && entityPersister().isIdentifierAssignedByInsert() && !forceIdentifierBinding ) {\n\t\t\t\tassert entityPersister().getInsertDelegate() != null;\n\t\t\t\tfinal OnExecutionGenerator generator = (OnExecutionGenerator) entityPersister().getGenerator();\n\t\t\t\tif ( generator.referenceColumnsInSql( dialect() ) ) {\n\t\t\t\t\tfinal BasicEntityIdentifierMapping identifierMapping = (BasicEntityIdentifierMapping) entityPersister().getIdentifierMapping();\n\t\t\t\t\tfinal String[] columnValues = generator.getReferencedColumnValues( dialect );\n\t\t\t\t\ttableMapping.getKeyMapping().forEachKeyColumn( (i, column) -> tableInsertBuilder.addKeyColumn(\n\t\t\t\t\t\t\tcolumn.getColumnName(),\n\t\t\t\t\t\t\tcolumnValues[i],\n\t\t\t\t\t\t\tidentifierMapping.getJdbcMapping()\n\t\t\t\t\t) );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttableMapping.getKeyMapping().forEachKeyColumn( tableInsertBuilder::addKeyColumn );\n\t\t\t}\n\t\t} );\n\t}\n\n\tprivate static boolean isValueGenerated(Generator generator) {\n\t\treturn generator != null\n\t\t\t\t&& generator.generatesOnInsert()\n\t\t\t\t&& generator.generatedOnExecution();\n\t}\n\n\tprivate static boolean isValueGenerationInSql(Generator generator, Dialect dialect) {\n\t\tassert isValueGenerated( generator );\n\t\treturn ( (OnExecutionGenerator) generator ).referenceColumnsInSql(dialect);\n\t}\n\n\t/**\n\t * @deprecated Use {@link #getBatchKey()}\n\t */\n\t@Deprecated\n\tpublic BasicBatchKey getInsertBatchKey() {\n\t\treturn batchKey;\n\t}\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic execute(modelReference Object, valuesAnalysis ValuesAnalysis, inclusionChecker TableInclusionChecker, resultChecker OperationResultChecker, session SharedSessionContractImplementor, staleStateMapper Batch.StaleStateMapper) : GeneratedValues extracted from public execute(modelReference Object, valuesAnalysis ValuesAnalysis, inclusionChecker TableInclusionChecker, resultChecker OperationResultChecker, session SharedSessionContractImplementor) : GeneratedValues in class org.hibernate.engine.jdbc.mutation.internal.AbstractMutationExecutor",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/mutation/internal/AbstractMutationExecutor.java",
                "startLine": 41,
                "endLine": 65,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/mutation/internal/AbstractMutationExecutor.java",
                "startLine": 43,
                "endLine": 58,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/mutation/internal/AbstractMutationExecutor.java",
                "startLine": 60,
                "endLine": 78,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n\t * Templated implementation of execution as <ol>\n\t *     <li>{@link #performNonBatchedOperations}</li>\n\t *     <li>{@link #performSelfExecutingOperations}</li>\n\t *     <li>{@link #performBatchedOperations}</li>\n\t * </ol>\n\t */\n\t@Override\n\tpublic final GeneratedValues execute(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session) {\n\t\tfinal GeneratedValues generatedValues = performNonBatchedOperations(\n\t\t\t\tmodelReference,\n\t\t\t\tvaluesAnalysis,\n\t\t\t\tinclusionChecker,\n\t\t\t\tresultChecker,\n\t\t\t\tsession\n\t\t);\n\t\tperformSelfExecutingOperations( valuesAnalysis, inclusionChecker, session );\n\t\tperformBatchedOperations( valuesAnalysis, inclusionChecker );\n\t\treturn generatedValues;\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/mutation/internal/AbstractMutationExecutor.java",
        "isPureRefactoring": true,
        "commitId": "ee00217733018075ccade7e1145f45ff9acae0c2",
        "packageNameBefore": "org.hibernate.engine.jdbc.mutation.internal",
        "classNameBefore": "org.hibernate.engine.jdbc.mutation.internal.AbstractMutationExecutor",
        "methodNameBefore": "org.hibernate.engine.jdbc.mutation.internal.AbstractMutationExecutor#execute",
        "invokedMethod": "methodSignature: org.hibernate.engine.jdbc.mutation.internal.AbstractMutationExecutor#performNonBatchedOperations\n methodBody: protected GeneratedValues performNonBatchedOperations(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session) {\nreturn null;\n}\nmethodSignature: org.hibernate.engine.jdbc.mutation.internal.MutationExecutorStandard#performNonBatchedOperations\n methodBody: protected GeneratedValues performNonBatchedOperations(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session) {\nif(nonBatchedStatementGroup == null || nonBatchedStatementGroup.getNumberOfStatements() <= 0){return null;\n}final GeneratedValues generatedValues;\nif(generatedValuesDelegate != null){final EntityMutationOperationGroup entityGroup=mutationOperationGroup.asEntityMutationOperationGroup();\nfinal EntityMutationTarget entityTarget=entityGroup.getMutationTarget();\nfinal PreparedStatementDetails details=nonBatchedStatementGroup.getPreparedStatementDetails(entityTarget.getIdentifierTableName());\ngeneratedValues=generatedValuesDelegate.performMutation(details,valueBindings,modelReference,session);\nfinal Object id=entityGroup.getMutationType() == MutationType.INSERT && details.getMutatingTableDetails().isIdentifierTable() ? generatedValues.getGeneratedValue(entityTarget.getTargetPart().getIdentifierMapping()) : null;\nnonBatchedStatementGroup.forEachStatement((tableName,statementDetails) -> {\n  if (!statementDetails.getMutatingTableDetails().isIdentifierTable()) {\n    performNonBatchedMutation(statementDetails,id,valueBindings,inclusionChecker,resultChecker,session);\n  }\n}\n);\n}{generatedValues=null;\nnonBatchedStatementGroup.forEachStatement((tableName,statementDetails) -> performNonBatchedMutation(statementDetails,null,valueBindings,inclusionChecker,resultChecker,session));\n}return generatedValues;\n}\nmethodSignature: org.hibernate.engine.jdbc.mutation.internal.MutationExecutorStandard#performSelfExecutingOperations\n methodBody: protected void performSelfExecutingOperations(ValuesAnalysis valuesAnalysis, TableInclusionChecker inclusionChecker, SharedSessionContractImplementor session) {\nif(selfExecutingMutations == null || selfExecutingMutations.isEmpty()){return;\n}for(int i=0; i < selfExecutingMutations.size(); i++){final SelfExecutingUpdateOperation operation=selfExecutingMutations.get(i);\nif(inclusionChecker.include(operation.getTableDetails())){operation.performMutation(valueBindings,valuesAnalysis,session);\n}}}\nmethodSignature: org.hibernate.engine.jdbc.mutation.internal.MutationExecutorStandard#performBatchedOperations\n methodBody: protected void performBatchedOperations(\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker) {\nif(batch == null){return;\n}batch.addToBatch(valueBindings,inclusionChecker);\n}\nmethodSignature: org.hibernate.engine.jdbc.mutation.internal.MutationExecutorSingleBatched#performBatchedOperations\n methodBody: protected void performBatchedOperations(ValuesAnalysis valuesAnalysis, TableInclusionChecker inclusionChecker) {\nresolveBatch().addToBatch(getJdbcValueBindings(),inclusionChecker);\n}\nmethodSignature: org.hibernate.engine.jdbc.mutation.internal.AbstractMutationExecutor#performSelfExecutingOperations\n methodBody: protected void performSelfExecutingOperations(\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tSharedSessionContractImplementor session) {\n}\nmethodSignature: org.hibernate.engine.jdbc.mutation.internal.AbstractMutationExecutor#performBatchedOperations\n methodBody: protected void performBatchedOperations(\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker) {\n}",
        "classSignatureBefore": "public abstract class AbstractMutationExecutor implements MutationExecutor ",
        "methodNameBeforeSet": [
            "org.hibernate.engine.jdbc.mutation.internal.AbstractMutationExecutor#execute"
        ],
        "classNameBeforeSet": [
            "org.hibernate.engine.jdbc.mutation.internal.AbstractMutationExecutor"
        ],
        "classSignatureBeforeSet": [
            "public abstract class AbstractMutationExecutor implements MutationExecutor "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Overlapped refactoring - can be identical by undoing the overlapped refactoring\n- Add Parameter-",
                "description": "Parametrization or Add Parameter on top of the extract method - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html.\n */\npackage org.hibernate.engine.jdbc.mutation.internal;\n\nimport java.sql.SQLException;\n\nimport org.hibernate.engine.jdbc.batch.spi.BatchKey;\nimport org.hibernate.engine.jdbc.mutation.JdbcValueBindings;\nimport org.hibernate.engine.jdbc.mutation.MutationExecutor;\nimport org.hibernate.engine.jdbc.mutation.OperationResultChecker;\nimport org.hibernate.engine.jdbc.mutation.ParameterUsage;\nimport org.hibernate.engine.jdbc.mutation.TableInclusionChecker;\nimport org.hibernate.engine.jdbc.mutation.group.PreparedStatementDetails;\nimport org.hibernate.engine.spi.SharedSessionContractImplementor;\nimport org.hibernate.generator.values.GeneratedValues;\nimport org.hibernate.persister.entity.mutation.EntityTableMapping;\nimport org.hibernate.sql.model.TableMapping;\nimport org.hibernate.sql.model.ValuesAnalysis;\n\nimport static org.hibernate.sql.model.ModelMutationLogging.MODEL_MUTATION_LOGGER;\n\n/**\n * Base support for MutationExecutor implementations\n *\n * @author Steve Ebersole\n */\npublic abstract class AbstractMutationExecutor implements MutationExecutor {\n\t/**\n\t * Executors with non-batched operations should call this to clean up any \"previous\" batch\n\t * before starting their work\n\t */\n\tprotected void prepareForNonBatchedWork(BatchKey batchKey, SharedSessionContractImplementor session) {\n\t\t// if there is a current batch, make sure to execute it first\n\t\tsession.getJdbcCoordinator().conditionallyExecuteBatch( batchKey );\n\t}\n\n\t/**\n\t * Templated implementation of execution as <ol>\n\t *     <li>{@link #performNonBatchedOperations}</li>\n\t *     <li>{@link #performSelfExecutingOperations}</li>\n\t *     <li>{@link #performBatchedOperations}</li>\n\t * </ol>\n\t */\n\t@Override\n\tpublic final GeneratedValues execute(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session) {\n\t\tfinal GeneratedValues generatedValues = performNonBatchedOperations(\n\t\t\t\tmodelReference,\n\t\t\t\tvaluesAnalysis,\n\t\t\t\tinclusionChecker,\n\t\t\t\tresultChecker,\n\t\t\t\tsession\n\t\t);\n\t\tperformSelfExecutingOperations( valuesAnalysis, inclusionChecker, session );\n\t\tperformBatchedOperations( valuesAnalysis, inclusionChecker );\n\t\treturn generatedValues;\n\t}\n\n\tprotected GeneratedValues performNonBatchedOperations(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session) {\n\t\treturn null;\n\t}\n\n\tprotected void performSelfExecutingOperations(\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tSharedSessionContractImplementor session) {\n\t}\n\n\tprotected void performBatchedOperations(\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker) {\n\t}\n\n\t/**\n\t * Perform a non-batched mutation\n\t */\n\tprotected void performNonBatchedMutation(\n\t\t\tPreparedStatementDetails statementDetails,\n\t\t\tObject id,\n\t\t\tJdbcValueBindings valueBindings,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session) {\n\t\tif ( statementDetails == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal TableMapping tableDetails = statementDetails.getMutatingTableDetails();\n\t\tif ( inclusionChecker != null && !inclusionChecker.include( tableDetails ) ) {\n\t\t\tif ( MODEL_MUTATION_LOGGER.isTraceEnabled() ) {\n\t\t\t\tMODEL_MUTATION_LOGGER.tracef(\n\t\t\t\t\t\t\"Skipping execution of secondary insert : %s\",\n\t\t\t\t\t\ttableDetails.getTableName()\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif ( id != null ) {\n\t\t\tassert !tableDetails.isIdentifierTable() : \"Unsupported identifier table with generated id\";\n\t\t\t( (EntityTableMapping) tableDetails ).getKeyMapping().breakDownKeyJdbcValues(\n\t\t\t\t\tid,\n\t\t\t\t\t(jdbcValue, columnMapping) -> valueBindings.bindValue(\n\t\t\t\t\t\t\tjdbcValue,\n\t\t\t\t\t\t\ttableDetails.getTableName(),\n\t\t\t\t\t\t\tcolumnMapping.getColumnName(),\n\t\t\t\t\t\t\tParameterUsage.SET\n\t\t\t\t\t),\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\n\t\t// If we get here the statement is needed - make sure it is resolved\n\t\tsession.getJdbcServices().getSqlStatementLogger().logStatement( statementDetails.getSqlString() );\n\n\t\ttry {\n\t\t\tvalueBindings.beforeStatement( statementDetails );\n\n\t\t\tfinal int affectedRowCount = session.getJdbcCoordinator()\n\t\t\t\t\t.getResultSetReturn()\n\t\t\t\t\t.executeUpdate( statementDetails.getStatement(), statementDetails.getSqlString() );\n\n\t\t\tif ( affectedRowCount == 0 && tableDetails.isOptional() ) {\n\t\t\t\t// the optional table did not have a row\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tModelMutationHelper.checkResults( resultChecker, statementDetails, affectedRowCount, -1 );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow session.getJdbcServices().getSqlExceptionHelper().convert(\n\t\t\t\t\te,\n\t\t\t\t\tString.format(\n\t\t\t\t\t\t\t\"Unable to execute mutation PreparedStatement against table `%s`\",\n\t\t\t\t\t\t\ttableDetails.getTableName()\n\t\t\t\t\t),\n\t\t\t\t\tstatementDetails.getSqlString()\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tif ( statementDetails.getStatement() != null ) {\n\t\t\t\tstatementDetails.releaseStatement( session );\n\t\t\t}\n\t\t\tvalueBindings.afterStatement( tableDetails );\n\t\t}\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/mutation/internal/AbstractMutationExecutor.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html.\n */\npackage org.hibernate.engine.jdbc.mutation.internal;\n\nimport java.sql.SQLException;\n\nimport org.hibernate.engine.jdbc.batch.spi.Batch;\nimport org.hibernate.engine.jdbc.batch.spi.BatchKey;\nimport org.hibernate.engine.jdbc.mutation.JdbcValueBindings;\nimport org.hibernate.engine.jdbc.mutation.MutationExecutor;\nimport org.hibernate.engine.jdbc.mutation.OperationResultChecker;\nimport org.hibernate.engine.jdbc.mutation.ParameterUsage;\nimport org.hibernate.engine.jdbc.mutation.TableInclusionChecker;\nimport org.hibernate.engine.jdbc.mutation.group.PreparedStatementDetails;\nimport org.hibernate.engine.spi.SharedSessionContractImplementor;\nimport org.hibernate.generator.values.GeneratedValues;\nimport org.hibernate.persister.entity.mutation.EntityTableMapping;\nimport org.hibernate.sql.model.TableMapping;\nimport org.hibernate.sql.model.ValuesAnalysis;\n\nimport static org.hibernate.engine.jdbc.mutation.internal.ModelMutationHelper.checkResults;\nimport static org.hibernate.sql.model.ModelMutationLogging.MODEL_MUTATION_LOGGER;\n\n/**\n * Base support for MutationExecutor implementations\n *\n * @author Steve Ebersole\n */\npublic abstract class AbstractMutationExecutor implements MutationExecutor {\n\t/**\n\t * Executors with non-batched operations should call this to clean up any \"previous\" batch\n\t * before starting their work\n\t */\n\tprotected void prepareForNonBatchedWork(BatchKey batchKey, SharedSessionContractImplementor session) {\n\t\t// if there is a current batch, make sure to execute it first\n\t\tsession.getJdbcCoordinator().conditionallyExecuteBatch( batchKey );\n\t}\n\n\t/**\n\t * Templated implementation of execution as <ol>\n\t *     <li>{@link #performNonBatchedOperations}</li>\n\t *     <li>{@link #performSelfExecutingOperations}</li>\n\t *     <li>{@link #performBatchedOperations}</li>\n\t * </ol>\n\t */\n\t@Override\n\tpublic final GeneratedValues execute(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session) {\n\t\treturn execute( modelReference, valuesAnalysis, inclusionChecker, resultChecker, session, null );\n\t}\n\n\t@Override\n\tpublic final GeneratedValues execute(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tBatch.StaleStateMapper staleStateMapper) {\n\t\tfinal GeneratedValues generatedValues = performNonBatchedOperations(\n\t\t\t\tmodelReference,\n\t\t\t\tvaluesAnalysis,\n\t\t\t\tinclusionChecker,\n\t\t\t\tresultChecker,\n\t\t\t\tsession\n\t\t);\n\t\tperformSelfExecutingOperations( valuesAnalysis, inclusionChecker, session );\n\t\tperformBatchedOperations( valuesAnalysis, inclusionChecker, staleStateMapper );\n\t\treturn generatedValues;\n\t}\n\n\n\n\tprotected GeneratedValues performNonBatchedOperations(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session) {\n\t\treturn null;\n\t}\n\n\tprotected void performSelfExecutingOperations(\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tSharedSessionContractImplementor session) {\n\t}\n\n\tprotected void performBatchedOperations(\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tBatch.StaleStateMapper staleStateMapper) {\n\t}\n\n\t/**\n\t * Perform a non-batched mutation\n\t */\n\tprotected void performNonBatchedMutation(\n\t\t\tPreparedStatementDetails statementDetails,\n\t\t\tObject id,\n\t\t\tJdbcValueBindings valueBindings,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session) {\n\t\tif ( statementDetails == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal TableMapping tableDetails = statementDetails.getMutatingTableDetails();\n\t\tif ( inclusionChecker != null && !inclusionChecker.include( tableDetails ) ) {\n\t\t\tif ( MODEL_MUTATION_LOGGER.isTraceEnabled() ) {\n\t\t\t\tMODEL_MUTATION_LOGGER.tracef(\n\t\t\t\t\t\t\"Skipping execution of secondary insert : %s\",\n\t\t\t\t\t\ttableDetails.getTableName()\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif ( id != null ) {\n\t\t\tassert !tableDetails.isIdentifierTable() : \"Unsupported identifier table with generated id\";\n\t\t\t( (EntityTableMapping) tableDetails ).getKeyMapping().breakDownKeyJdbcValues(\n\t\t\t\t\tid,\n\t\t\t\t\t(jdbcValue, columnMapping) -> valueBindings.bindValue(\n\t\t\t\t\t\t\tjdbcValue,\n\t\t\t\t\t\t\ttableDetails.getTableName(),\n\t\t\t\t\t\t\tcolumnMapping.getColumnName(),\n\t\t\t\t\t\t\tParameterUsage.SET\n\t\t\t\t\t),\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\n\t\t// If we get here the statement is needed - make sure it is resolved\n\t\tsession.getJdbcServices().getSqlStatementLogger().logStatement( statementDetails.getSqlString() );\n\n\t\ttry {\n\t\t\tvalueBindings.beforeStatement( statementDetails );\n\n\t\t\tfinal int affectedRowCount = session.getJdbcCoordinator()\n\t\t\t\t\t.getResultSetReturn()\n\t\t\t\t\t.executeUpdate( statementDetails.getStatement(), statementDetails.getSqlString() );\n\n\t\t\tif ( affectedRowCount == 0 && tableDetails.isOptional() ) {\n\t\t\t\t// the optional table did not have a row\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcheckResults( resultChecker, statementDetails, affectedRowCount, -1 );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow session.getJdbcServices().getSqlExceptionHelper().convert(\n\t\t\t\t\te,\n\t\t\t\t\tString.format(\n\t\t\t\t\t\t\t\"Unable to execute mutation PreparedStatement against table `%s`\",\n\t\t\t\t\t\t\ttableDetails.getTableName()\n\t\t\t\t\t),\n\t\t\t\t\tstatementDetails.getSqlString()\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tif ( statementDetails.getStatement() != null ) {\n\t\t\t\tstatementDetails.releaseStatement( session );\n\t\t\t}\n\t\t\tvalueBindings.afterStatement( tableDetails );\n\t\t}\n\t}\n}\n",
        "diffSourceCodeSet": [
            "@Override\n\tpublic final GeneratedValues execute(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tBatch.StaleStateMapper staleStateMapper) {\n\t\tfinal GeneratedValues generatedValues = performNonBatchedOperations(\n\t\t\t\tmodelReference,\n\t\t\t\tvaluesAnalysis,\n\t\t\t\tinclusionChecker,\n\t\t\t\tresultChecker,\n\t\t\t\tsession\n\t\t);\n\t\tperformSelfExecutingOperations( valuesAnalysis, inclusionChecker, session );\n\t\tperformBatchedOperations( valuesAnalysis, inclusionChecker, staleStateMapper );\n\t\treturn generatedValues;\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.engine.jdbc.mutation.internal.AbstractMutationExecutor#performNonBatchedOperations\n methodBody: protected GeneratedValues performNonBatchedOperations(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session) {\nreturn null;\n}",
            "methodSignature: org.hibernate.engine.jdbc.mutation.internal.MutationExecutorStandard#performNonBatchedOperations\n methodBody: protected GeneratedValues performNonBatchedOperations(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session) {\nif(nonBatchedStatementGroup == null || nonBatchedStatementGroup.getNumberOfStatements() <= 0){return null;\n}final GeneratedValues generatedValues;\nif(generatedValuesDelegate != null){final EntityMutationOperationGroup entityGroup=mutationOperationGroup.asEntityMutationOperationGroup();\nfinal EntityMutationTarget entityTarget=entityGroup.getMutationTarget();\nfinal PreparedStatementDetails details=nonBatchedStatementGroup.getPreparedStatementDetails(entityTarget.getIdentifierTableName());\ngeneratedValues=generatedValuesDelegate.performMutation(details,valueBindings,modelReference,session);\nfinal Object id=entityGroup.getMutationType() == MutationType.INSERT && details.getMutatingTableDetails().isIdentifierTable() ? generatedValues.getGeneratedValue(entityTarget.getTargetPart().getIdentifierMapping()) : null;\nnonBatchedStatementGroup.forEachStatement((tableName,statementDetails) -> {\n  if (!statementDetails.getMutatingTableDetails().isIdentifierTable()) {\n    performNonBatchedMutation(statementDetails,id,valueBindings,inclusionChecker,resultChecker,session);\n  }\n}\n);\n}{generatedValues=null;\nnonBatchedStatementGroup.forEachStatement((tableName,statementDetails) -> performNonBatchedMutation(statementDetails,null,valueBindings,inclusionChecker,resultChecker,session));\n}return generatedValues;\n}",
            "methodSignature: org.hibernate.engine.jdbc.mutation.internal.MutationExecutorStandard#performSelfExecutingOperations\n methodBody: protected void performSelfExecutingOperations(ValuesAnalysis valuesAnalysis, TableInclusionChecker inclusionChecker, SharedSessionContractImplementor session) {\nif(selfExecutingMutations == null || selfExecutingMutations.isEmpty()){return;\n}for(int i=0; i < selfExecutingMutations.size(); i++){final SelfExecutingUpdateOperation operation=selfExecutingMutations.get(i);\nif(inclusionChecker.include(operation.getTableDetails())){operation.performMutation(valueBindings,valuesAnalysis,session);\n}}}",
            "methodSignature: org.hibernate.engine.jdbc.mutation.internal.MutationExecutorStandard#performBatchedOperations\n methodBody: protected void performBatchedOperations(\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker) {\nif(batch == null){return;\n}batch.addToBatch(valueBindings,inclusionChecker);\n}",
            "methodSignature: org.hibernate.engine.jdbc.mutation.internal.MutationExecutorSingleBatched#performBatchedOperations\n methodBody: protected void performBatchedOperations(ValuesAnalysis valuesAnalysis, TableInclusionChecker inclusionChecker) {\nresolveBatch().addToBatch(getJdbcValueBindings(),inclusionChecker);\n}",
            "methodSignature: org.hibernate.engine.jdbc.mutation.internal.AbstractMutationExecutor#performSelfExecutingOperations\n methodBody: protected void performSelfExecutingOperations(\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tSharedSessionContractImplementor session) {\n}",
            "methodSignature: org.hibernate.engine.jdbc.mutation.internal.AbstractMutationExecutor#performBatchedOperations\n methodBody: protected void performBatchedOperations(\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker) {\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n\t * Templated implementation of execution as <ol>\n\t *     <li>{@link #performNonBatchedOperations}</li>\n\t *     <li>{@link #performSelfExecutingOperations}</li>\n\t *     <li>{@link #performBatchedOperations}</li>\n\t * </ol>\n\t */\n\t@Override\n\tpublic final GeneratedValues execute(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session) {\n\t\treturn execute( modelReference, valuesAnalysis, inclusionChecker, resultChecker, session, null );\n\t}\n@Override\n\tpublic final GeneratedValues execute(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session,\n\t\t\tBatch.StaleStateMapper staleStateMapper) {\n\t\tfinal GeneratedValues generatedValues = performNonBatchedOperations(\n\t\t\t\tmodelReference,\n\t\t\t\tvaluesAnalysis,\n\t\t\t\tinclusionChecker,\n\t\t\t\tresultChecker,\n\t\t\t\tsession\n\t\t);\n\t\tperformSelfExecutingOperations( valuesAnalysis, inclusionChecker, session );\n\t\tperformBatchedOperations( valuesAnalysis, inclusionChecker, staleStateMapper );\n\t\treturn generatedValues;\n\t}",
        "diffSourceCode": "-   41: \t/**\n-   42: \t * Templated implementation of execution as <ol>\n-   43: \t *     <li>{@link #performNonBatchedOperations}</li>\n-   44: \t *     <li>{@link #performSelfExecutingOperations}</li>\n-   45: \t *     <li>{@link #performBatchedOperations}</li>\n-   46: \t * </ol>\n-   47: \t */\n-   48: \t@Override\n-   49: \tpublic final GeneratedValues execute(\n-   50: \t\t\tObject modelReference,\n-   51: \t\t\tValuesAnalysis valuesAnalysis,\n-   52: \t\t\tTableInclusionChecker inclusionChecker,\n-   53: \t\t\tOperationResultChecker resultChecker,\n-   54: \t\t\tSharedSessionContractImplementor session) {\n-   55: \t\tfinal GeneratedValues generatedValues = performNonBatchedOperations(\n-   56: \t\t\t\tmodelReference,\n-   57: \t\t\t\tvaluesAnalysis,\n-   58: \t\t\t\tinclusionChecker,\n-   59: \t\t\t\tresultChecker,\n-   60: \t\t\t\tsession\n-   61: \t\t);\n-   62: \t\tperformSelfExecutingOperations( valuesAnalysis, inclusionChecker, session );\n-   63: \t\tperformBatchedOperations( valuesAnalysis, inclusionChecker );\n-   64: \t\treturn generatedValues;\n-   65: \t}\n-   66: \n-   67: \tprotected GeneratedValues performNonBatchedOperations(\n-   68: \t\t\tObject modelReference,\n-   69: \t\t\tValuesAnalysis valuesAnalysis,\n-   70: \t\t\tTableInclusionChecker inclusionChecker,\n-   71: \t\t\tOperationResultChecker resultChecker,\n-   72: \t\t\tSharedSessionContractImplementor session) {\n-   73: \t\treturn null;\n-   74: \t}\n-   75: \n-   76: \tprotected void performSelfExecutingOperations(\n-   77: \t\t\tValuesAnalysis valuesAnalysis,\n-   78: \t\t\tTableInclusionChecker inclusionChecker,\n+   41: \t}\n+   42: \n+   43: \t/**\n+   44: \t * Templated implementation of execution as <ol>\n+   45: \t *     <li>{@link #performNonBatchedOperations}</li>\n+   46: \t *     <li>{@link #performSelfExecutingOperations}</li>\n+   47: \t *     <li>{@link #performBatchedOperations}</li>\n+   48: \t * </ol>\n+   49: \t */\n+   50: \t@Override\n+   51: \tpublic final GeneratedValues execute(\n+   52: \t\t\tObject modelReference,\n+   53: \t\t\tValuesAnalysis valuesAnalysis,\n+   54: \t\t\tTableInclusionChecker inclusionChecker,\n+   55: \t\t\tOperationResultChecker resultChecker,\n+   56: \t\t\tSharedSessionContractImplementor session) {\n+   57: \t\treturn execute( modelReference, valuesAnalysis, inclusionChecker, resultChecker, session, null );\n+   58: \t}\n+   59: \n+   60: \t@Override\n+   61: \tpublic final GeneratedValues execute(\n+   62: \t\t\tObject modelReference,\n+   63: \t\t\tValuesAnalysis valuesAnalysis,\n+   64: \t\t\tTableInclusionChecker inclusionChecker,\n+   65: \t\t\tOperationResultChecker resultChecker,\n+   66: \t\t\tSharedSessionContractImplementor session,\n+   67: \t\t\tBatch.StaleStateMapper staleStateMapper) {\n+   68: \t\tfinal GeneratedValues generatedValues = performNonBatchedOperations(\n+   69: \t\t\t\tmodelReference,\n+   70: \t\t\t\tvaluesAnalysis,\n+   71: \t\t\t\tinclusionChecker,\n+   72: \t\t\t\tresultChecker,\n+   73: \t\t\t\tsession\n+   74: \t\t);\n+   75: \t\tperformSelfExecutingOperations( valuesAnalysis, inclusionChecker, session );\n+   76: \t\tperformBatchedOperations( valuesAnalysis, inclusionChecker, staleStateMapper );\n+   77: \t\treturn generatedValues;\n+   78: \t}\n",
        "uniqueId": "ee00217733018075ccade7e1145f45ff9acae0c2_41_65_60_78_43_58",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 20
            },
            "LINE": {
                "missed": 0,
                "covered": 4
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\n/**\n * Perform a non-batched mutation\n */\nprotected void performNonBatchedMutation(\n        PreparedStatementDetails statementDetails,\n        Object id,\n        JdbcValueBindings valueBindings,\n        TableInclusionChecker inclusionChecker,\n        OperationResultChecker resultChecker,\n        SharedSessionContractImplementor session) {\n    if ( statementDetails == null ) {\n        return;\n    }\n\n    final TableMapping tableDetails = statementDetails.getMutatingTableDetails();\n    if ( inclusionChecker != null && !inclusionChecker.include( tableDetails ) ) {\n        if ( MODEL_MUTATION_LOGGER.isTraceEnabled() ) {\n            MODEL_MUTATION_LOGGER.tracef(\n                    \"Skipping execution of secondary insert : %s\",\n                    tableDetails.getTableName()\n            );\n        }\n        return;\n    }\n\n    if ( id != null ) {\n        assert !tableDetails.isIdentifierTable() : \"Unsupported identifier table with generated id\";\n        ( (EntityTableMapping) tableDetails ).getKeyMapping().breakDownKeyJdbcValues(\n                id,\n                (jdbcValue, columnMapping) -> valueBindings.bindValue(\n                        jdbcValue,\n                        tableDetails.getTableName(),\n                        columnMapping.getColumnName(),\n                        ParameterUsage.SET\n                ),\n                session\n        );\n    }\n\n    // If we get here the statement is needed - make sure it is resolved\n    session.getJdbcServices().getSqlStatementLogger().logStatement( statementDetails.getSqlString() );\n\n    try {\n        valueBindings.beforeStatement( statementDetails );\n\n        final int affectedRowCount = session.getJdbcCoordinator()\n                .getResultSetReturn()\n                .executeUpdate( statementDetails.getStatement(), statementDetails.getSqlString() );\n\n        if ( affectedRowCount == 0 && tableDetails.isOptional() ) {\n            // the optional table did not have a row\n            return;\n        }\n\n        ModelMutationHelper.checkResults( resultChecker, statementDetails, affectedRowCount, -1 );\n    }\n    catch (SQLException e) {\n        throw session.getJdbcServices().getSqlExceptionHelper().convert(\n                e,\n                String.format(\n                        \"Unable to execute mutation PreparedStatement against table `%s`\",\n                        tableDetails.getTableName()\n                ),\n                statementDetails.getSqlString()\n        );\n    }\n    finally {\n        if ( statementDetails.getStatement() != null ) {\n            statementDetails.releaseStatement( session );\n        }\n        valueBindings.afterStatement( tableDetails );\n    }\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n\t * Templated implementation of execution as <ol>\n\t *     <li>{@link #performNonBatchedOperations}</li>\n\t *     <li>{@link #performSelfExecutingOperations}</li>\n\t *     <li>{@link #performBatchedOperations}</li>\n\t * </ol>\n\t */\n\t@Override\n\tpublic final GeneratedValues execute(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session) {\n\t\tfinal GeneratedValues generatedValues = performNonBatchedOperations(\n\t\t\t\tmodelReference,\n\t\t\t\tvaluesAnalysis,\n\t\t\t\tinclusionChecker,\n\t\t\t\tresultChecker,\n\t\t\t\tsession\n\t\t);\n\t\tperformSelfExecutingOperations( valuesAnalysis, inclusionChecker, session );\n\t\tperformBatchedOperations( valuesAnalysis, inclusionChecker );\n\t\treturn generatedValues;\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html.\n */\npackage org.hibernate.engine.jdbc.mutation.internal;\n\nimport java.sql.SQLException;\n\nimport org.hibernate.engine.jdbc.batch.spi.BatchKey;\nimport org.hibernate.engine.jdbc.mutation.JdbcValueBindings;\nimport org.hibernate.engine.jdbc.mutation.MutationExecutor;\nimport org.hibernate.engine.jdbc.mutation.OperationResultChecker;\nimport org.hibernate.engine.jdbc.mutation.ParameterUsage;\nimport org.hibernate.engine.jdbc.mutation.TableInclusionChecker;\nimport org.hibernate.engine.jdbc.mutation.group.PreparedStatementDetails;\nimport org.hibernate.engine.spi.SharedSessionContractImplementor;\nimport org.hibernate.generator.values.GeneratedValues;\nimport org.hibernate.persister.entity.mutation.EntityTableMapping;\nimport org.hibernate.sql.model.TableMapping;\nimport org.hibernate.sql.model.ValuesAnalysis;\n\nimport static org.hibernate.sql.model.ModelMutationLogging.MODEL_MUTATION_LOGGER;\n\n/**\n * Base support for MutationExecutor implementations\n *\n * @author Steve Ebersole\n */\npublic abstract class AbstractMutationExecutor implements MutationExecutor {\n\t/**\n\t * Executors with non-batched operations should call this to clean up any \"previous\" batch\n\t * before starting their work\n\t */\n\tprotected void prepareForNonBatchedWork(BatchKey batchKey, SharedSessionContractImplementor session) {\n\t\t// if there is a current batch, make sure to execute it first\n\t\tsession.getJdbcCoordinator().conditionallyExecuteBatch( batchKey );\n\t}\n\n\t/**\n\t * Templated implementation of execution as <ol>\n\t *     <li>{@link #performNonBatchedOperations}</li>\n\t *     <li>{@link #performSelfExecutingOperations}</li>\n\t *     <li>{@link #performBatchedOperations}</li>\n\t * </ol>\n\t */\n\t@Override\n\tpublic final GeneratedValues execute(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session) {\n\t\tfinal GeneratedValues generatedValues = performNonBatchedOperations(\n\t\t\t\tmodelReference,\n\t\t\t\tvaluesAnalysis,\n\t\t\t\tinclusionChecker,\n\t\t\t\tresultChecker,\n\t\t\t\tsession\n\t\t);\n\t\tperformSelfExecutingOperations( valuesAnalysis, inclusionChecker, session );\n\t\tperformBatchedOperations( valuesAnalysis, inclusionChecker );\n\t\treturn generatedValues;\n\t}\n\n\tprotected GeneratedValues performNonBatchedOperations(\n\t\t\tObject modelReference,\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session) {\n\t\treturn null;\n\t}\n\n\tprotected void performSelfExecutingOperations(\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tSharedSessionContractImplementor session) {\n\t}\n\n\tprotected void performBatchedOperations(\n\t\t\tValuesAnalysis valuesAnalysis,\n\t\t\tTableInclusionChecker inclusionChecker) {\n\t}\n\n\t/**\n\t * Perform a non-batched mutation\n\t */\n\tprotected void performNonBatchedMutation(\n\t\t\tPreparedStatementDetails statementDetails,\n\t\t\tObject id,\n\t\t\tJdbcValueBindings valueBindings,\n\t\t\tTableInclusionChecker inclusionChecker,\n\t\t\tOperationResultChecker resultChecker,\n\t\t\tSharedSessionContractImplementor session) {\n\t\tif ( statementDetails == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal TableMapping tableDetails = statementDetails.getMutatingTableDetails();\n\t\tif ( inclusionChecker != null && !inclusionChecker.include( tableDetails ) ) {\n\t\t\tif ( MODEL_MUTATION_LOGGER.isTraceEnabled() ) {\n\t\t\t\tMODEL_MUTATION_LOGGER.tracef(\n\t\t\t\t\t\t\"Skipping execution of secondary insert : %s\",\n\t\t\t\t\t\ttableDetails.getTableName()\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif ( id != null ) {\n\t\t\tassert !tableDetails.isIdentifierTable() : \"Unsupported identifier table with generated id\";\n\t\t\t( (EntityTableMapping) tableDetails ).getKeyMapping().breakDownKeyJdbcValues(\n\t\t\t\t\tid,\n\t\t\t\t\t(jdbcValue, columnMapping) -> valueBindings.bindValue(\n\t\t\t\t\t\t\tjdbcValue,\n\t\t\t\t\t\t\ttableDetails.getTableName(),\n\t\t\t\t\t\t\tcolumnMapping.getColumnName(),\n\t\t\t\t\t\t\tParameterUsage.SET\n\t\t\t\t\t),\n\t\t\t\t\tsession\n\t\t\t);\n\t\t}\n\n\t\t// If we get here the statement is needed - make sure it is resolved\n\t\tsession.getJdbcServices().getSqlStatementLogger().logStatement( statementDetails.getSqlString() );\n\n\t\ttry {\n\t\t\tvalueBindings.beforeStatement( statementDetails );\n\n\t\t\tfinal int affectedRowCount = session.getJdbcCoordinator()\n\t\t\t\t\t.getResultSetReturn()\n\t\t\t\t\t.executeUpdate( statementDetails.getStatement(), statementDetails.getSqlString() );\n\n\t\t\tif ( affectedRowCount == 0 && tableDetails.isOptional() ) {\n\t\t\t\t// the optional table did not have a row\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tModelMutationHelper.checkResults( resultChecker, statementDetails, affectedRowCount, -1 );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow session.getJdbcServices().getSqlExceptionHelper().convert(\n\t\t\t\t\te,\n\t\t\t\t\tString.format(\n\t\t\t\t\t\t\t\"Unable to execute mutation PreparedStatement against table `%s`\",\n\t\t\t\t\t\t\ttableDetails.getTableName()\n\t\t\t\t\t),\n\t\t\t\t\tstatementDetails.getSqlString()\n\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\tif ( statementDetails.getStatement() != null ) {\n\t\t\t\tstatementDetails.releaseStatement( session );\n\t\t\t}\n\t\t\tvalueBindings.afterStatement( tableDetails );\n\t\t}\n\t}\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate registerEntityNameUsage(tableGroup TableGroup, creationState SqlAstCreationState, tableName String) : void extracted from private render(aliasGenerator FilterAliasGenerator, filterIndex int, tableGroup TableGroup, creationState SqlAstCreationState) : String in class org.hibernate.internal.FilterHelper",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/internal/FilterHelper.java",
                "startLine": 226,
                "endLine": 295,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/internal/FilterHelper.java",
                "startLine": 279,
                "endLine": 288,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/internal/FilterHelper.java",
                "startLine": 290,
                "endLine": 293,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private String render(\n\t\t\tFilterAliasGenerator aliasGenerator,\n\t\t\tint filterIndex,\n\t\t\tTableGroup tableGroup,\n\t\t\tSqlAstCreationState creationState) {\n\t\tMap<String, String> aliasTableMap = filterAliasTableMaps[filterIndex];\n\t\tString condition = filterConditions[filterIndex];\n\t\tif ( aliasGenerator == null ) {\n\t\t\treturn StringHelper.replace( condition, FilterImpl.MARKER + \".\", \"\");\n\t\t}\n\t\tif ( filterAutoAliasFlags[filterIndex] ) {\n\t\t\tfinal String tableName = aliasTableMap.get( null );\n\t\t\tfinal String newCondition = StringHelper.replace(\n\t\t\t\t\tcondition,\n\t\t\t\t\tFilterImpl.MARKER,\n\t\t\t\t\taliasGenerator.getAlias( tableName )\n\t\t\t);\n\t\t\tif ( creationState != null && tableToEntityName != null && !newCondition.equals( condition ) ) {\n\t\t\t\tcreationState.registerEntityNameUsage(\n\t\t\t\t\t\ttableGroup,\n\t\t\t\t\t\tEntityNameUse.EXPRESSION,\n\t\t\t\t\t\ttableToEntityName.get(\n\t\t\t\t\t\t\t\ttableName == null\n\t\t\t\t\t\t\t\t\t\t? tableGroup.getPrimaryTableReference().getTableId()\n\t\t\t\t\t\t\t\t\t\t: tableName\n\t\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn newCondition;\n\t\t}\n\t\telse if ( isTableFromPersistentClass( aliasTableMap ) ) {\n\t\t\tfinal String tableName = aliasTableMap.get( null );\n\t\t\tfinal String newCondition = StringHelper.replace(\n\t\t\t\t\tcondition,\n\t\t\t\t\t\"{alias}\",\n\t\t\t\t\taliasGenerator.getAlias( tableName )\n\t\t\t);\n\t\t\tif ( creationState != null && !newCondition.equals( condition ) ) {\n\t\t\t\tcreationState.registerEntityNameUsage(\n\t\t\t\t\t\ttableGroup,\n\t\t\t\t\t\tEntityNameUse.EXPRESSION,\n\t\t\t\t\t\ttableToEntityName.get(\n\t\t\t\t\t\t\t\ttableName == null\n\t\t\t\t\t\t\t\t\t\t? tableGroup.getPrimaryTableReference().getTableId()\n\t\t\t\t\t\t\t\t\t\t: tableName\n\t\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn newCondition;\n\t\t}\n\t\telse {\n\t\t\tfor ( Map.Entry<String, String> entry : aliasTableMap.entrySet() ) {\n\t\t\t\tfinal String tableName = entry.getValue();\n\t\t\t\tfinal String newCondition = StringHelper.replace(\n\t\t\t\t\t\tcondition,\n\t\t\t\t\t\t\"{\" + entry.getKey() + \"}\",\n\t\t\t\t\t\taliasGenerator.getAlias( tableName )\n\t\t\t\t);\n\t\t\t\tif ( creationState != null && !newCondition.equals( condition ) ) {\n\t\t\t\t\tcreationState.registerEntityNameUsage(\n\t\t\t\t\t\t\ttableGroup,\n\t\t\t\t\t\t\tEntityNameUse.EXPRESSION,\n\t\t\t\t\t\t\ttableToEntityName.get( tableName )\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcondition = newCondition;\n\t\t\t}\n\t\t\treturn condition;\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/internal/FilterHelper.java",
        "isPureRefactoring": true,
        "commitId": "57cfbb616164b6cb93fd6bb1b3f8a4a5d4f7d59f",
        "packageNameBefore": "org.hibernate.internal",
        "classNameBefore": "org.hibernate.internal.FilterHelper",
        "methodNameBefore": "org.hibernate.internal.FilterHelper#render",
        "invokedMethod": "methodSignature: org.hibernate.sql.ast.tree.predicate.FilterPredicate.FilterFragmentParameter#getValue\n methodBody: public Object getValue() {\nreturn value;\n}\nmethodSignature: org.hibernate.internal.FilterHelper#isTableFromPersistentClass\n methodBody: private static boolean isTableFromPersistentClass(Map<String, String> aliasTableMap) {\nreturn aliasTableMap.size() == 1 && aliasTableMap.containsKey(null);\n}\nmethodSignature: org.hibernate.internal.util.StringHelper#replace\n methodBody: public static String replace(\n\t\t\tString beforePlaceholder,\n\t\t\tString afterPlaceholder,\n\t\t\tString placeholder,\n\t\t\tString replacement,\n\t\t\tboolean wholeWords,\n\t\t\tboolean encloseInParensIfNecessary) {\nfinal boolean actuallyReplace=!wholeWords || afterPlaceholder.length() == 0 || !Character.isJavaIdentifierPart(afterPlaceholder.charAt(0));\nboolean encloseInParens=actuallyReplace && encloseInParensIfNecessary && !(getLastNonWhitespaceCharacter(beforePlaceholder) == '(') && !(getLastNonWhitespaceCharacter(beforePlaceholder) == ',' && getFirstNonWhitespaceCharacter(afterPlaceholder) == ')');\nStringBuilder buf=new StringBuilder(beforePlaceholder);\nif(encloseInParens){buf.append('(');\n}buf.append(actuallyReplace ? replacement : placeholder);\nif(encloseInParens){buf.append(')');\n}buf.append(replace(afterPlaceholder,placeholder,replacement,wholeWords,encloseInParensIfNecessary));\nreturn buf.toString();\n}\nmethodSignature: org.hibernate.mapping.Selectable#getAlias\n methodBody: String getAlias(Dialect dialect, Table table);",
        "classSignatureBefore": "public class FilterHelper ",
        "methodNameBeforeSet": [
            "org.hibernate.internal.FilterHelper#render"
        ],
        "classNameBeforeSet": [
            "org.hibernate.internal.FilterHelper"
        ],
        "classSignatureBeforeSet": [
            "public class FilterHelper "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.internal;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.Consumer;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.hibernate.Filter;\nimport org.hibernate.engine.spi.LoadQueryInfluencers;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.internal.util.StringHelper;\nimport org.hibernate.internal.util.collections.CollectionHelper;\nimport org.hibernate.metamodel.mapping.Restrictable;\nimport org.hibernate.persister.entity.EntityNameUse;\nimport org.hibernate.sql.Template;\nimport org.hibernate.sql.ast.spi.SqlAstCreationState;\nimport org.hibernate.sql.ast.tree.from.TableGroup;\nimport org.hibernate.sql.ast.tree.predicate.FilterPredicate;\nimport org.hibernate.sql.ast.tree.predicate.Predicate;\n\nimport static org.hibernate.internal.util.StringHelper.safeInterning;\n\n/**\n * Implementation of FilterHelper.\n *\n * @author Steve Ebersole\n * @author Rob Worsnop\n * @author Nathan Xu\n */\npublic class FilterHelper {\n\tprivate static final Pattern FILTER_PARAMETER_PATTERN = Pattern.compile( \":(\\\\S+)(\\\\w+)\" );\n\n\tprivate final String[] filterNames;\n\tprivate final String[] filterConditions;\n\tprivate final boolean[] filterAutoAliasFlags;\n\tprivate final Map<String, String>[] filterAliasTableMaps;\n\tprivate final List<String>[] parameterNames;\n\tprivate final Map<String, String> tableToEntityName;\n\n\tpublic FilterHelper(List<FilterConfiguration> filters, SessionFactoryImplementor factory) {\n\t\tthis( filters, null, factory );\n\t}\n\n\t/**\n\t * The map of defined filters.  This is expected to be in format\n\t * where the filter names are the map keys, and the defined\n\t * conditions are the values.\n\t *\n\t * @param filters The map of defined filters.\n\t * @param factory The session factory\n\t */\n\tpublic FilterHelper(List<FilterConfiguration> filters, Map<String, String> tableToEntityName, SessionFactoryImplementor factory) {\n\t\tint filterCount = filters.size();\n\n\t\tfilterNames = new String[filterCount];\n\t\tfilterConditions = new String[filterCount];\n\t\tfilterAutoAliasFlags = new boolean[filterCount];\n\t\tfilterAliasTableMaps = new Map[filterCount];\n\t\tparameterNames = new List[filterCount];\n\t\tthis.tableToEntityName = tableToEntityName;\n\n\t\tfilterCount = 0;\n\t\tfor ( final FilterConfiguration filter : filters ) {\n\t\t\tfinal String filterName = safeInterning( filter.getName() );\n\t\t\tfilterNames[filterCount] = filterName;\n\t\t\tfilterConditions[filterCount] = safeInterning( filter.getCondition() );\n\n\t\t\tfilterAliasTableMaps[filterCount] = filter.getAliasTableMap( factory );\n\t\t\tfilterAutoAliasFlags[filterCount] = false;\n\n\t\t\tif ( ( filterAliasTableMaps[filterCount].isEmpty()\n\t\t\t\t\t|| isTableFromPersistentClass( filterAliasTableMaps[filterCount] ) )\n\t\t\t\t\t&& filter.useAutoAliasInjection() ) {\n\t\t\t\tfinal String autoAliasedCondition = Template.renderWhereStringTemplate(\n\t\t\t\t\t\tfilter.getCondition(),\n\t\t\t\t\t\tFilterImpl.MARKER,\n\t\t\t\t\t\tfactory.getJdbcServices().getDialect(),\n\t\t\t\t\t\tfactory.getTypeConfiguration()\n\t\t\t\t);\n\t\t\t\tfilterConditions[filterCount] = safeInterning( autoAliasedCondition );\n\t\t\t\tfilterAutoAliasFlags[filterCount] = true;\n\t\t\t}\n\n\t\t\t// look for parameters in the condition.  for each parameter, we:\n\t\t\t//\t\t1) keep track of the name for later\n\t\t\t//\t\t2) // we replace `:{param-name} ` with `:{filter-name}.{param-name} ` in the condition\n\t\t\tfinal Matcher matcher = FILTER_PARAMETER_PATTERN.matcher( filterConditions[filterCount] );\n\n\t\t\tString copy = filterConditions[filterCount];\n\t\t\tfinal List<String> filterParamNames = new ArrayList<>();\n\t\t\tparameterNames[filterCount] = filterParamNames;\n\t\t\tboolean foundAny = false;\n\n\t\t\t// handle any subsequent matched parameters\n\t\t\twhile( matcher.find() ) {\n\t\t\t\tfinal String parameterLabel = filterConditions[filterCount].substring( matcher.start() + 1, matcher.end() );\n\t\t\t\tfilterParamNames.add( parameterLabel );\n\t\t\t\tcopy = copy.replace(\n\t\t\t\t\t\t\":\" + parameterLabel,\n\t\t\t\t\t\t\":\" + filterName + \".\" + parameterLabel\n\t\t\t\t);\n\t\t\t\tfoundAny = true;\n\t\t\t}\n\n\t\t\tif ( foundAny ) {\n\t\t\t\tfilterConditions[filterCount] = safeInterning( copy );\n\t\t\t}\n\n\t\t\tfilterCount++;\n\t\t}\n\t}\n\n\tprivate static boolean isTableFromPersistentClass(Map<String, String> aliasTableMap) {\n\t\treturn aliasTableMap.size() == 1 && aliasTableMap.containsKey( null );\n\t}\n\n\tpublic String[] getFilterNames() {\n\t\treturn filterNames;\n\t}\n\n\tpublic boolean isAffectedBy(Map<String, Filter> enabledFilters) {\n\t\treturn isAffectedBy( enabledFilters, false );\n\t}\n\n\tpublic boolean isAffectedBy(Map<String, Filter> enabledFilters, boolean onlyApplyForLoadByKey) {\n\t\tfor ( String filterName : filterNames ) {\n\t\t\tFilter filter = enabledFilters.get( filterName );\n\t\t\tif ( filter != null && ( !onlyApplyForLoadByKey || filter.isAppliedToLoadByKey() ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static void applyBaseRestrictions(\n\t\t\tConsumer<Predicate> predicateConsumer,\n\t\t\tRestrictable restrictable,\n\t\t\tTableGroup rootTableGroup,\n\t\t\tboolean useIdentificationVariable,\n\t\t\tLoadQueryInfluencers loadQueryInfluencers,\n\t\t\tSqlAstCreationState astCreationState) {\n\t\trestrictable.applyBaseRestrictions(\n\t\t\t\tpredicateConsumer,\n\t\t\t\trootTableGroup,\n\t\t\t\tuseIdentificationVariable,\n\t\t\t\tloadQueryInfluencers.getEnabledFilters(),\n\t\t\t\tastCreationState.applyOnlyLoadByKeyFilters(),\n\t\t\t\tnull,\n\t\t\t\tastCreationState\n\t\t);\n\t}\n\n\tpublic void applyEnabledFilters(\n\t\t\tConsumer<Predicate> predicateConsumer,\n\t\t\tFilterAliasGenerator aliasGenerator,\n\t\t\tMap<String, Filter> enabledFilters,\n\t\t\tboolean onlyApplyLoadByKeyFilters,\n\t\t\tTableGroup tableGroup,\n\t\t\tSqlAstCreationState creationState) {\n\t\tfinal FilterPredicate predicate = generateFilterPredicate(\n\t\t\t\taliasGenerator,\n\t\t\t\tenabledFilters,\n\t\t\t\tonlyApplyLoadByKeyFilters,\n\t\t\t\ttableGroup,\n\t\t\t\tcreationState\n\t\t);\n\t\tif ( predicate != null ) {\n\t\t\tpredicateConsumer.accept( predicate );\n\t\t}\n\t}\n\n\tprivate FilterPredicate generateFilterPredicate(\n\t\t\tFilterAliasGenerator aliasGenerator,\n\t\t\tMap<String, Filter> enabledFilters,\n\t\t\tboolean onlyApplyLoadByKeyFilters,\n\t\t\tTableGroup tableGroup,\n\t\t\tSqlAstCreationState creationState) {\n\t\tfinal FilterPredicate filterPredicate = new FilterPredicate();\n\n\t\tfor ( int i = 0, max = filterNames.length; i < max; i++ ) {\n\t\t\tfinal String filterName = filterNames[i];\n\t\t\tfinal FilterImpl enabledFilter = (FilterImpl) enabledFilters.get( filterName );\n\t\t\tif ( enabledFilter != null && ( !onlyApplyLoadByKeyFilters || enabledFilter.isAppliedToLoadByKey() ) ) {\n\t\t\t\tfilterPredicate.applyFragment( render( aliasGenerator, i, tableGroup, creationState ), enabledFilter, parameterNames[i] );\n\t\t\t}\n\t\t}\n\n\t\tif ( filterPredicate.isEmpty() ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn filterPredicate;\n\t}\n\n\tpublic String render(FilterAliasGenerator aliasGenerator, Map<String, Filter> enabledFilters) {\n\t\tStringBuilder buffer = new StringBuilder();\n\t\trender( buffer, aliasGenerator, enabledFilters );\n\t\treturn buffer.toString();\n\t}\n\n\tpublic void render(StringBuilder buffer, FilterAliasGenerator aliasGenerator, Map<String, Filter> enabledFilters) {\n\t\tif ( CollectionHelper.isEmpty( filterNames ) ) {\n\t\t\treturn;\n\t\t}\n\t\tfor ( int i = 0, max = filterNames.length; i < max; i++ ) {\n\t\t\tif ( enabledFilters.containsKey( filterNames[i] ) ) {\n\t\t\t\tfinal String condition = filterConditions[i];\n\t\t\t\tif ( StringHelper.isNotEmpty( condition ) ) {\n\t\t\t\t\tif ( buffer.length() > 0 ) {\n\t\t\t\t\t\tbuffer.append( \" and \" );\n\t\t\t\t\t}\n\t\t\t\t\tbuffer.append( render( aliasGenerator, i, null, null ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate String render(\n\t\t\tFilterAliasGenerator aliasGenerator,\n\t\t\tint filterIndex,\n\t\t\tTableGroup tableGroup,\n\t\t\tSqlAstCreationState creationState) {\n\t\tMap<String, String> aliasTableMap = filterAliasTableMaps[filterIndex];\n\t\tString condition = filterConditions[filterIndex];\n\t\tif ( aliasGenerator == null ) {\n\t\t\treturn StringHelper.replace( condition, FilterImpl.MARKER + \".\", \"\");\n\t\t}\n\t\tif ( filterAutoAliasFlags[filterIndex] ) {\n\t\t\tfinal String tableName = aliasTableMap.get( null );\n\t\t\tfinal String newCondition = StringHelper.replace(\n\t\t\t\t\tcondition,\n\t\t\t\t\tFilterImpl.MARKER,\n\t\t\t\t\taliasGenerator.getAlias( tableName )\n\t\t\t);\n\t\t\tif ( creationState != null && tableToEntityName != null && !newCondition.equals( condition ) ) {\n\t\t\t\tcreationState.registerEntityNameUsage(\n\t\t\t\t\t\ttableGroup,\n\t\t\t\t\t\tEntityNameUse.EXPRESSION,\n\t\t\t\t\t\ttableToEntityName.get(\n\t\t\t\t\t\t\t\ttableName == null\n\t\t\t\t\t\t\t\t\t\t? tableGroup.getPrimaryTableReference().getTableId()\n\t\t\t\t\t\t\t\t\t\t: tableName\n\t\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn newCondition;\n\t\t}\n\t\telse if ( isTableFromPersistentClass( aliasTableMap ) ) {\n\t\t\tfinal String tableName = aliasTableMap.get( null );\n\t\t\tfinal String newCondition = StringHelper.replace(\n\t\t\t\t\tcondition,\n\t\t\t\t\t\"{alias}\",\n\t\t\t\t\taliasGenerator.getAlias( tableName )\n\t\t\t);\n\t\t\tif ( creationState != null && !newCondition.equals( condition ) ) {\n\t\t\t\tcreationState.registerEntityNameUsage(\n\t\t\t\t\t\ttableGroup,\n\t\t\t\t\t\tEntityNameUse.EXPRESSION,\n\t\t\t\t\t\ttableToEntityName.get(\n\t\t\t\t\t\t\t\ttableName == null\n\t\t\t\t\t\t\t\t\t\t? tableGroup.getPrimaryTableReference().getTableId()\n\t\t\t\t\t\t\t\t\t\t: tableName\n\t\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn newCondition;\n\t\t}\n\t\telse {\n\t\t\tfor ( Map.Entry<String, String> entry : aliasTableMap.entrySet() ) {\n\t\t\t\tfinal String tableName = entry.getValue();\n\t\t\t\tfinal String newCondition = StringHelper.replace(\n\t\t\t\t\t\tcondition,\n\t\t\t\t\t\t\"{\" + entry.getKey() + \"}\",\n\t\t\t\t\t\taliasGenerator.getAlias( tableName )\n\t\t\t\t);\n\t\t\t\tif ( creationState != null && !newCondition.equals( condition ) ) {\n\t\t\t\t\tcreationState.registerEntityNameUsage(\n\t\t\t\t\t\t\ttableGroup,\n\t\t\t\t\t\t\tEntityNameUse.EXPRESSION,\n\t\t\t\t\t\t\ttableToEntityName.get( tableName )\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcondition = newCondition;\n\t\t\t}\n\t\t\treturn condition;\n\t\t}\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/internal/FilterHelper.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.internal;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.Consumer;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.hibernate.Filter;\nimport org.hibernate.engine.spi.LoadQueryInfluencers;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.metamodel.mapping.Restrictable;\nimport org.hibernate.persister.entity.EntityNameUse;\nimport org.hibernate.sql.Template;\nimport org.hibernate.sql.ast.spi.SqlAstCreationState;\nimport org.hibernate.sql.ast.tree.from.TableGroup;\nimport org.hibernate.sql.ast.tree.predicate.FilterPredicate;\nimport org.hibernate.sql.ast.tree.predicate.Predicate;\n\nimport static org.hibernate.internal.FilterImpl.MARKER;\nimport static org.hibernate.internal.util.StringHelper.isNotEmpty;\nimport static org.hibernate.internal.util.StringHelper.replace;\nimport static org.hibernate.internal.util.StringHelper.safeInterning;\nimport static org.hibernate.internal.util.collections.CollectionHelper.isNotEmpty;\n\n/**\n * Utility methods for dealing with {@linkplain FilterConfiguration filters}.\n *\n * @author Steve Ebersole\n * @author Rob Worsnop\n * @author Nathan Xu\n */\npublic class FilterHelper {\n\tprivate static final Pattern FILTER_PARAMETER_PATTERN = Pattern.compile( \":((\\\\S+)(\\\\w+))\" );\n\n\tprivate final String[] filterNames;\n\tprivate final String[] filterConditions;\n\tprivate final boolean[] filterAutoAliasFlags;\n\tprivate final Map<String, String>[] filterAliasTableMaps;\n\tprivate final List<String>[] parameterNames;\n\tprivate final Map<String, String> tableToEntityName;\n\n\tpublic FilterHelper(List<FilterConfiguration> filters, SessionFactoryImplementor factory) {\n\t\tthis( filters, null, factory );\n\t}\n\n\t/**\n\t * The map of defined filters.  This is expected to be in format\n\t * where the filter names are the map keys, and the defined\n\t * conditions are the values.\n\t *\n\t * @param filters The map of defined filters.\n\t * @param factory The session factory\n\t */\n\tpublic FilterHelper(List<FilterConfiguration> filters, Map<String, String> tableToEntityName, SessionFactoryImplementor factory) {\n\t\tint filterCount = filters.size();\n\n\t\tfilterNames = new String[filterCount];\n\t\tfilterConditions = new String[filterCount];\n\t\tfilterAutoAliasFlags = new boolean[filterCount];\n\t\tfilterAliasTableMaps = new Map[filterCount];\n\t\tparameterNames = new List[filterCount];\n\t\tthis.tableToEntityName = tableToEntityName;\n\n\t\tfilterCount = 0;\n\t\tfor ( final FilterConfiguration filter : filters ) {\n\t\t\tfinal String filterName = safeInterning( filter.getName() );\n\t\t\tfilterNames[filterCount] = filterName;\n\t\t\tfilterConditions[filterCount] = safeInterning( filter.getCondition() );\n\n\t\t\tfilterAliasTableMaps[filterCount] = filter.getAliasTableMap( factory );\n\t\t\tfilterAutoAliasFlags[filterCount] = false;\n\n\t\t\tinjectAliases( factory, filter, filterCount );\n\t\t\tqualifyParameterNames( filterCount, filterName );\n\n\t\t\tfilterCount++;\n\t\t}\n\t}\n\n\tprivate void injectAliases(SessionFactoryImplementor factory, FilterConfiguration filter, int filterCount) {\n\t\tif ( ( filterAliasTableMaps[filterCount].isEmpty()\n\t\t\t\t|| isTableFromPersistentClass( filterAliasTableMaps[filterCount] ) )\n\t\t\t\t&& filter.useAutoAliasInjection() ) {\n\t\t\tfinal String autoAliasedCondition = Template.renderWhereStringTemplate(\n\t\t\t\t\tfilter.getCondition(),\n\t\t\t\t\tMARKER,\n\t\t\t\t\tfactory.getJdbcServices().getDialect(),\n\t\t\t\t\tfactory.getTypeConfiguration()\n\t\t\t);\n\t\t\tfilterConditions[filterCount] = safeInterning( autoAliasedCondition );\n\t\t\tfilterAutoAliasFlags[filterCount] = true;\n\t\t}\n\t}\n\n\t/**\n\t * Look for parameters in the given condition. For each parameter, we:\n\t * <ol>\n\t *     <li>keep track of the name for later</li>\n\t *     <li>replace {@code :{param-name}} with {@code :{filter-name}.{param-name}}\n\t *     in the condition</li>\n\t * </ol>\n\t */\n\tprivate void qualifyParameterNames(int filterCount, String filterName) {\n\t\tfinal List<String> parameterNames = new ArrayList<>();\n\t\tboolean foundAny = false;\n\t\tfinal Matcher matcher = FILTER_PARAMETER_PATTERN.matcher( filterConditions[filterCount] );\n\t\twhile ( matcher.find() ) {\n\t\t\tparameterNames.add( matcher.group(1) );\n\t\t\tfoundAny = true;\n\t\t}\n\t\tif ( foundAny ) {\n\t\t\tfilterConditions[filterCount] =\n\t\t\t\t\tsafeInterning( matcher.replaceAll(\":\" + filterName +  \".$1\") );\n\t\t}\n\t\tthis.parameterNames[filterCount] = parameterNames;\n\t}\n\n\tprivate static boolean isTableFromPersistentClass(Map<String, String> aliasTableMap) {\n\t\treturn aliasTableMap.size() == 1 && aliasTableMap.containsKey( null );\n\t}\n\n\tpublic String[] getFilterNames() {\n\t\treturn filterNames;\n\t}\n\n\tpublic boolean isAffectedBy(Map<String, Filter> enabledFilters) {\n\t\treturn isAffectedBy( enabledFilters, false );\n\t}\n\n\tpublic boolean isAffectedBy(Map<String, Filter> enabledFilters, boolean onlyApplyForLoadByKey) {\n\t\tfor ( String filterName : filterNames ) {\n\t\t\tFilter filter = enabledFilters.get( filterName );\n\t\t\tif ( filter != null && ( !onlyApplyForLoadByKey || filter.isAppliedToLoadByKey() ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static void applyBaseRestrictions(\n\t\t\tConsumer<Predicate> predicateConsumer,\n\t\t\tRestrictable restrictable,\n\t\t\tTableGroup rootTableGroup,\n\t\t\tboolean useIdentificationVariable,\n\t\t\tLoadQueryInfluencers loadQueryInfluencers,\n\t\t\tSqlAstCreationState astCreationState) {\n\t\trestrictable.applyBaseRestrictions(\n\t\t\t\tpredicateConsumer,\n\t\t\t\trootTableGroup,\n\t\t\t\tuseIdentificationVariable,\n\t\t\t\tloadQueryInfluencers.getEnabledFilters(),\n\t\t\t\tastCreationState.applyOnlyLoadByKeyFilters(),\n\t\t\t\tnull,\n\t\t\t\tastCreationState\n\t\t);\n\t}\n\n\tpublic void applyEnabledFilters(\n\t\t\tConsumer<Predicate> predicateConsumer,\n\t\t\tFilterAliasGenerator aliasGenerator,\n\t\t\tMap<String, Filter> enabledFilters,\n\t\t\tboolean onlyApplyLoadByKeyFilters,\n\t\t\tTableGroup tableGroup,\n\t\t\tSqlAstCreationState creationState) {\n\t\tfinal FilterPredicate predicate = generateFilterPredicate(\n\t\t\t\taliasGenerator,\n\t\t\t\tenabledFilters,\n\t\t\t\tonlyApplyLoadByKeyFilters,\n\t\t\t\ttableGroup,\n\t\t\t\tcreationState\n\t\t);\n\t\tif ( predicate != null ) {\n\t\t\tpredicateConsumer.accept( predicate );\n\t\t}\n\t}\n\n\tprivate FilterPredicate generateFilterPredicate(\n\t\t\tFilterAliasGenerator aliasGenerator,\n\t\t\tMap<String, Filter> enabledFilters,\n\t\t\tboolean onlyApplyLoadByKeyFilters,\n\t\t\tTableGroup tableGroup,\n\t\t\tSqlAstCreationState creationState) {\n\t\tfinal FilterPredicate filterPredicate = new FilterPredicate();\n\n\t\tfor ( int i = 0, max = filterNames.length; i < max; i++ ) {\n\t\t\tfinal Filter enabledFilter = enabledFilters.get( filterNames[i] );\n\t\t\tif ( enabledFilter != null && ( !onlyApplyLoadByKeyFilters || enabledFilter.isAppliedToLoadByKey() ) ) {\n\t\t\t\tfilterPredicate.applyFragment( render( aliasGenerator, i, tableGroup, creationState ), enabledFilter, parameterNames[i] );\n\t\t\t}\n\t\t}\n\n\t\tif ( filterPredicate.isEmpty() ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn filterPredicate;\n\t}\n\n\tpublic String render(FilterAliasGenerator aliasGenerator, Map<String, Filter> enabledFilters) {\n\t\tfinal StringBuilder buffer = new StringBuilder();\n\t\trender( buffer, aliasGenerator, enabledFilters );\n\t\treturn buffer.toString();\n\t}\n\n\tpublic void render(StringBuilder buffer, FilterAliasGenerator aliasGenerator, Map<String, Filter> enabledFilters) {\n\t\tif ( isNotEmpty( filterNames ) ) {\n\t\t\tfor ( int i = 0, max = filterNames.length; i < max; i++ ) {\n\t\t\t\tif ( enabledFilters.containsKey( filterNames[i] ) ) {\n\t\t\t\t\tif ( isNotEmpty( filterConditions[i] ) ) {\n\t\t\t\t\t\tif ( !buffer.isEmpty() ) {\n\t\t\t\t\t\t\tbuffer.append( \" and \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbuffer.append( render( aliasGenerator, i, null, null ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate String render(\n\t\t\tFilterAliasGenerator aliasGenerator,\n\t\t\tint filterIndex,\n\t\t\tTableGroup tableGroup,\n\t\t\tSqlAstCreationState creationState) {\n\t\tfinal String condition = filterConditions[filterIndex];\n\t\tif ( aliasGenerator == null ) {\n\t\t\treturn replace( condition, MARKER + \".\", \"\");\n\t\t}\n\t\telse {\n\t\t\tfinal Map<String, String> aliasTableMap = filterAliasTableMaps[filterIndex];\n\t\t\tif ( filterAutoAliasFlags[filterIndex] ) {\n\t\t\t\tfinal String tableName = aliasTableMap.get( null );\n\t\t\t\treturn replaceMarker( tableGroup, creationState, condition,\n\t\t\t\t\t\taliasGenerator.getAlias( tableName ),\n\t\t\t\t\t\ttableName( tableGroup, tableName ) );\n\t\t\t}\n\t\t\telse if ( isTableFromPersistentClass( aliasTableMap ) ) {\n\t\t\t\tfinal String tableName = aliasTableMap.get( null );\n\t\t\t\treturn replaceAlias( tableGroup, creationState, condition,\n\t\t\t\t\t\t\"{alias}\",\n\t\t\t\t\t\taliasGenerator.getAlias( tableName ),\n\t\t\t\t\t\ttableName( tableGroup, tableName ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString newCondition = condition;\n\t\t\t\tfor ( Map.Entry<String, String> entry : aliasTableMap.entrySet() ) {\n\t\t\t\t\tfinal String tableName = entry.getValue();\n\t\t\t\t\tnewCondition =\n\t\t\t\t\t\t\treplaceAlias( tableGroup, creationState, newCondition,\n\t\t\t\t\t\t\t\t\t\"{\" + entry.getKey() + \"}\",\n\t\t\t\t\t\t\t\t\taliasGenerator.getAlias( tableName ),\n\t\t\t\t\t\t\t\t\ttableName );\n\t\t\t\t}\n\t\t\t\treturn newCondition;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate String replaceMarker(\n\t\t\tTableGroup tableGroup, SqlAstCreationState creationState,\n\t\t\tString condition, String alias, String tableName) {\n\t\tfinal String newCondition = replace( condition, MARKER, alias );\n\t\tif ( creationState != null\n\t\t\t\t&& tableToEntityName != null\n\t\t\t\t&& !newCondition.equals(condition) ) {\n\t\t\tregisterEntityNameUsage( tableGroup, creationState, tableName );\n\t\t}\n\t\treturn newCondition;\n\t}\n\n\tprivate String replaceAlias(\n\t\t\tTableGroup tableGroup, SqlAstCreationState creationState,\n\t\t\tString condition, String placeholder, String alias, String tableName) {\n\t\tfinal String newCondition = replace( condition, placeholder, alias );\n\t\tif ( creationState != null\n\t\t\t\t&& !newCondition.equals(condition) ) {\n\t\t\tregisterEntityNameUsage( tableGroup, creationState, tableName );\n\t\t}\n\t\treturn newCondition;\n\t}\n\n\tprivate void registerEntityNameUsage(TableGroup tableGroup, SqlAstCreationState creationState, String tableName) {\n\t\tcreationState.registerEntityNameUsage( tableGroup, EntityNameUse.EXPRESSION,\n\t\t\t\ttableToEntityName.get( tableName ) );\n\t}\n\n\tprivate static String tableName(TableGroup tableGroup, String tableName) {\n\t\treturn tableName == null\n\t\t\t\t? tableGroup.getPrimaryTableReference().getTableId()\n\t\t\t\t: tableName;\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private void registerEntityNameUsage(TableGroup tableGroup, SqlAstCreationState creationState, String tableName) {\n\t\tcreationState.registerEntityNameUsage( tableGroup, EntityNameUse.EXPRESSION,\n\t\t\t\ttableToEntityName.get( tableName ) );\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.sql.ast.tree.predicate.FilterPredicate.FilterFragmentParameter#getValue\n methodBody: public Object getValue() {\nreturn value;\n}",
            "methodSignature: org.hibernate.internal.FilterHelper#isTableFromPersistentClass\n methodBody: private static boolean isTableFromPersistentClass(Map<String, String> aliasTableMap) {\nreturn aliasTableMap.size() == 1 && aliasTableMap.containsKey(null);\n}",
            "methodSignature: org.hibernate.internal.util.StringHelper#replace\n methodBody: public static String replace(\n\t\t\tString beforePlaceholder,\n\t\t\tString afterPlaceholder,\n\t\t\tString placeholder,\n\t\t\tString replacement,\n\t\t\tboolean wholeWords,\n\t\t\tboolean encloseInParensIfNecessary) {\nfinal boolean actuallyReplace=!wholeWords || afterPlaceholder.length() == 0 || !Character.isJavaIdentifierPart(afterPlaceholder.charAt(0));\nboolean encloseInParens=actuallyReplace && encloseInParensIfNecessary && !(getLastNonWhitespaceCharacter(beforePlaceholder) == '(') && !(getLastNonWhitespaceCharacter(beforePlaceholder) == ',' && getFirstNonWhitespaceCharacter(afterPlaceholder) == ')');\nStringBuilder buf=new StringBuilder(beforePlaceholder);\nif(encloseInParens){buf.append('(');\n}buf.append(actuallyReplace ? replacement : placeholder);\nif(encloseInParens){buf.append(')');\n}buf.append(replace(afterPlaceholder,placeholder,replacement,wholeWords,encloseInParensIfNecessary));\nreturn buf.toString();\n}",
            "methodSignature: org.hibernate.mapping.Selectable#getAlias\n methodBody: String getAlias(Dialect dialect, Table table);"
        ],
        "sourceCodeAfterRefactoring": "private String replaceAlias(\n\t\t\tTableGroup tableGroup, SqlAstCreationState creationState,\n\t\t\tString condition, String placeholder, String alias, String tableName) {\n\t\tfinal String newCondition = replace( condition, placeholder, alias );\n\t\tif ( creationState != null\n\t\t\t\t&& !newCondition.equals(condition) ) {\n\t\t\tregisterEntityNameUsage( tableGroup, creationState, tableName );\n\t\t}\n\t\treturn newCondition;\n\t}\nprivate void registerEntityNameUsage(TableGroup tableGroup, SqlAstCreationState creationState, String tableName) {\n\t\tcreationState.registerEntityNameUsage( tableGroup, EntityNameUse.EXPRESSION,\n\t\t\t\ttableToEntityName.get( tableName ) );\n\t}",
        "diffSourceCode": "-  226: \tprivate String render(\n-  227: \t\t\tFilterAliasGenerator aliasGenerator,\n-  228: \t\t\tint filterIndex,\n-  229: \t\t\tTableGroup tableGroup,\n-  230: \t\t\tSqlAstCreationState creationState) {\n-  231: \t\tMap<String, String> aliasTableMap = filterAliasTableMaps[filterIndex];\n-  232: \t\tString condition = filterConditions[filterIndex];\n-  233: \t\tif ( aliasGenerator == null ) {\n-  234: \t\t\treturn StringHelper.replace( condition, FilterImpl.MARKER + \".\", \"\");\n-  235: \t\t}\n-  236: \t\tif ( filterAutoAliasFlags[filterIndex] ) {\n-  237: \t\t\tfinal String tableName = aliasTableMap.get( null );\n-  238: \t\t\tfinal String newCondition = StringHelper.replace(\n-  239: \t\t\t\t\tcondition,\n-  240: \t\t\t\t\tFilterImpl.MARKER,\n-  241: \t\t\t\t\taliasGenerator.getAlias( tableName )\n-  242: \t\t\t);\n-  243: \t\t\tif ( creationState != null && tableToEntityName != null && !newCondition.equals( condition ) ) {\n-  244: \t\t\t\tcreationState.registerEntityNameUsage(\n-  245: \t\t\t\t\t\ttableGroup,\n-  246: \t\t\t\t\t\tEntityNameUse.EXPRESSION,\n-  247: \t\t\t\t\t\ttableToEntityName.get(\n-  248: \t\t\t\t\t\t\t\ttableName == null\n-  249: \t\t\t\t\t\t\t\t\t\t? tableGroup.getPrimaryTableReference().getTableId()\n-  250: \t\t\t\t\t\t\t\t\t\t: tableName\n-  251: \t\t\t\t\t\t)\n-  252: \t\t\t\t);\n-  253: \t\t\t}\n-  254: \t\t\treturn newCondition;\n-  255: \t\t}\n-  256: \t\telse if ( isTableFromPersistentClass( aliasTableMap ) ) {\n-  257: \t\t\tfinal String tableName = aliasTableMap.get( null );\n-  258: \t\t\tfinal String newCondition = StringHelper.replace(\n-  259: \t\t\t\t\tcondition,\n-  260: \t\t\t\t\t\"{alias}\",\n-  261: \t\t\t\t\taliasGenerator.getAlias( tableName )\n-  262: \t\t\t);\n-  263: \t\t\tif ( creationState != null && !newCondition.equals( condition ) ) {\n-  264: \t\t\t\tcreationState.registerEntityNameUsage(\n-  265: \t\t\t\t\t\ttableGroup,\n-  266: \t\t\t\t\t\tEntityNameUse.EXPRESSION,\n-  267: \t\t\t\t\t\ttableToEntityName.get(\n-  268: \t\t\t\t\t\t\t\ttableName == null\n-  269: \t\t\t\t\t\t\t\t\t\t? tableGroup.getPrimaryTableReference().getTableId()\n-  270: \t\t\t\t\t\t\t\t\t\t: tableName\n-  271: \t\t\t\t\t\t)\n-  272: \t\t\t\t);\n-  273: \t\t\t}\n-  274: \t\t\treturn newCondition;\n+  226: \t}\n+  227: \n+  228: \tprivate String render(\n+  229: \t\t\tFilterAliasGenerator aliasGenerator,\n+  230: \t\t\tint filterIndex,\n+  231: \t\t\tTableGroup tableGroup,\n+  232: \t\t\tSqlAstCreationState creationState) {\n+  233: \t\tfinal String condition = filterConditions[filterIndex];\n+  234: \t\tif ( aliasGenerator == null ) {\n+  235: \t\t\treturn replace( condition, MARKER + \".\", \"\");\n+  236: \t\t}\n+  237: \t\telse {\n+  238: \t\t\tfinal Map<String, String> aliasTableMap = filterAliasTableMaps[filterIndex];\n+  239: \t\t\tif ( filterAutoAliasFlags[filterIndex] ) {\n+  240: \t\t\t\tfinal String tableName = aliasTableMap.get( null );\n+  241: \t\t\t\treturn replaceMarker( tableGroup, creationState, condition,\n+  242: \t\t\t\t\t\taliasGenerator.getAlias( tableName ),\n+  243: \t\t\t\t\t\ttableName( tableGroup, tableName ) );\n+  244: \t\t\t}\n+  245: \t\t\telse if ( isTableFromPersistentClass( aliasTableMap ) ) {\n+  246: \t\t\t\tfinal String tableName = aliasTableMap.get( null );\n+  247: \t\t\t\treturn replaceAlias( tableGroup, creationState, condition,\n+  248: \t\t\t\t\t\t\"{alias}\",\n+  249: \t\t\t\t\t\taliasGenerator.getAlias( tableName ),\n+  250: \t\t\t\t\t\ttableName( tableGroup, tableName ) );\n+  251: \t\t\t}\n+  252: \t\t\telse {\n+  253: \t\t\t\tString newCondition = condition;\n+  254: \t\t\t\tfor ( Map.Entry<String, String> entry : aliasTableMap.entrySet() ) {\n+  255: \t\t\t\t\tfinal String tableName = entry.getValue();\n+  256: \t\t\t\t\tnewCondition =\n+  257: \t\t\t\t\t\t\treplaceAlias( tableGroup, creationState, newCondition,\n+  258: \t\t\t\t\t\t\t\t\t\"{\" + entry.getKey() + \"}\",\n+  259: \t\t\t\t\t\t\t\t\taliasGenerator.getAlias( tableName ),\n+  260: \t\t\t\t\t\t\t\t\ttableName );\n+  261: \t\t\t\t}\n+  262: \t\t\t\treturn newCondition;\n+  263: \t\t\t}\n+  264: \t\t}\n+  265: \t}\n+  266: \n+  267: \tprivate String replaceMarker(\n+  268: \t\t\tTableGroup tableGroup, SqlAstCreationState creationState,\n+  269: \t\t\tString condition, String alias, String tableName) {\n+  270: \t\tfinal String newCondition = replace( condition, MARKER, alias );\n+  271: \t\tif ( creationState != null\n+  272: \t\t\t\t&& tableToEntityName != null\n+  273: \t\t\t\t&& !newCondition.equals(condition) ) {\n+  274: \t\t\tregisterEntityNameUsage( tableGroup, creationState, tableName );\n   275: \t\t}\n-  276: \t\telse {\n-  277: \t\t\tfor ( Map.Entry<String, String> entry : aliasTableMap.entrySet() ) {\n-  278: \t\t\t\tfinal String tableName = entry.getValue();\n-  279: \t\t\t\tfinal String newCondition = StringHelper.replace(\n-  280: \t\t\t\t\t\tcondition,\n-  281: \t\t\t\t\t\t\"{\" + entry.getKey() + \"}\",\n-  282: \t\t\t\t\t\taliasGenerator.getAlias( tableName )\n-  283: \t\t\t\t);\n-  284: \t\t\t\tif ( creationState != null && !newCondition.equals( condition ) ) {\n-  285: \t\t\t\t\tcreationState.registerEntityNameUsage(\n-  286: \t\t\t\t\t\t\ttableGroup,\n-  287: \t\t\t\t\t\t\tEntityNameUse.EXPRESSION,\n-  288: \t\t\t\t\t\t\ttableToEntityName.get( tableName )\n-  289: \t\t\t\t\t);\n-  290: \t\t\t\t}\n-  291: \t\t\t\tcondition = newCondition;\n-  292: \t\t\t}\n-  293: \t\t\treturn condition;\n-  294: \t\t}\n-  295: \t}\n+  276: \t\treturn newCondition;\n+  277: \t}\n+  278: \n+  279: \tprivate String replaceAlias(\n+  280: \t\t\tTableGroup tableGroup, SqlAstCreationState creationState,\n+  281: \t\t\tString condition, String placeholder, String alias, String tableName) {\n+  282: \t\tfinal String newCondition = replace( condition, placeholder, alias );\n+  283: \t\tif ( creationState != null\n+  284: \t\t\t\t&& !newCondition.equals(condition) ) {\n+  285: \t\t\tregisterEntityNameUsage( tableGroup, creationState, tableName );\n+  286: \t\t}\n+  287: \t\treturn newCondition;\n+  288: \t}\n+  289: \n+  290: \tprivate void registerEntityNameUsage(TableGroup tableGroup, SqlAstCreationState creationState, String tableName) {\n+  291: \t\tcreationState.registerEntityNameUsage( tableGroup, EntityNameUse.EXPRESSION,\n+  292: \t\t\t\ttableToEntityName.get( tableName ) );\n+  293: \t}\n+  294: \n+  295: \tprivate static String tableName(TableGroup tableGroup, String tableName) {\n",
        "uniqueId": "57cfbb616164b6cb93fd6bb1b3f8a4a5d4f7d59f_226_295_290_293_279_288",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 5,
                "covered": 89
            },
            "BRANCH": {
                "missed": 1,
                "covered": 7
            },
            "LINE": {
                "missed": 1,
                "covered": 22
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 4
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\nprivate String applyFilterCondition(FilterAliasGenerator aliasGenerator, int filterIndex, TableGroup tableGroup, SqlAstCreationState creationState, Map<String, String> aliasTableMap, String condition) {\n    if (aliasGenerator == null) {\n        return StringHelper.replace(condition, FilterImpl.MARKER + \".\", \"\");\n    }\n    if (filterAutoAliasFlags[filterIndex]) {\n        final String tableName = aliasTableMap.get(null);\n        final String newCondition = StringHelper.replace(\n                condition,\n                FilterImpl.MARKER,\n                aliasGenerator.getAlias(tableName)\n        );\n        if (creationState != null && tableToEntityName != null && !newCondition.equals(condition)) {\n            creationState.registerEntityNameUsage(\n                    tableGroup,\n                    EntityNameUse.EXPRESSION,\n                    tableToEntityName.get(\n                            tableName == null\n                                    ? tableGroup.getPrimaryTableReference().getTableId()\n                                    : tableName\n                    )\n            );\n        }\n        return newCondition;\n    } else if (isTableFromPersistentClass(aliasTableMap)) {\n        final String tableName = aliasTableMap.get(null);\n        final String newCondition = StringHelper.replace(\n                condition,\n                \"{alias}\",\n                aliasGenerator.getAlias(tableName)\n        );\n        if (creationState != null && !newCondition.equals(condition)) {\n            creationState.registerEntityNameUsage(\n                    tableGroup,\n                    EntityNameUse.EXPRESSION,\n                    tableToEntityName.get(\n                            tableName == null\n                                    ? tableGroup.getPrimaryTableReference().getTableId()\n                                    : tableName\n                    )\n            );\n        }\n        return newCondition;\n    } else {\n        for (Map.Entry<String, String> entry : aliasTableMap.entrySet()) {\n            final String tableName = entry.getValue();\n            final String newCondition = StringHelper.replace(\n                    condition,\n                    \"{\" + entry.getKey() + \"}\",\n                    aliasGenerator.getAlias(tableName)\n            );\n            if (creationState != null && !newCondition.equals(condition)) {\n                creationState.registerEntityNameUsage(\n                        tableGroup,\n                        EntityNameUse.EXPRESSION,\n                        tableToEntityName.get(tableName)\n                );\n            }\n            condition = newCondition;\n        }\n        return condition;\n    }\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprivate String render(\n\t\t\tFilterAliasGenerator aliasGenerator,\n\t\t\tint filterIndex,\n\t\t\tTableGroup tableGroup,\n\t\t\tSqlAstCreationState creationState) {\n\t\tMap<String, String> aliasTableMap = filterAliasTableMaps[filterIndex];\n\t\tString condition = filterConditions[filterIndex];\n\t\tif ( aliasGenerator == null ) {\n\t\t\treturn StringHelper.replace( condition, FilterImpl.MARKER + \".\", \"\");\n\t\t}\n\t\tif ( filterAutoAliasFlags[filterIndex] ) {\n\t\t\tfinal String tableName = aliasTableMap.get( null );\n\t\t\tfinal String newCondition = StringHelper.replace(\n\t\t\t\t\tcondition,\n\t\t\t\t\tFilterImpl.MARKER,\n\t\t\t\t\taliasGenerator.getAlias( tableName )\n\t\t\t);\n\t\t\tif ( creationState != null && tableToEntityName != null && !newCondition.equals( condition ) ) {\n\t\t\t\tcreationState.registerEntityNameUsage(\n\t\t\t\t\t\ttableGroup,\n\t\t\t\t\t\tEntityNameUse.EXPRESSION,\n\t\t\t\t\t\ttableToEntityName.get(\n\t\t\t\t\t\t\t\ttableName == null\n\t\t\t\t\t\t\t\t\t\t? tableGroup.getPrimaryTableReference().getTableId()\n\t\t\t\t\t\t\t\t\t\t: tableName\n\t\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn newCondition;\n\t\t}\n\t\telse if ( isTableFromPersistentClass( aliasTableMap ) ) {\n\t\t\tfinal String tableName = aliasTableMap.get( null );\n\t\t\tfinal String newCondition = StringHelper.replace(\n\t\t\t\t\tcondition,\n\t\t\t\t\t\"{alias}\",\n\t\t\t\t\taliasGenerator.getAlias( tableName )\n\t\t\t);\n\t\t\tif ( creationState != null && !newCondition.equals( condition ) ) {\n\t\t\t\tcreationState.registerEntityNameUsage(\n\t\t\t\t\t\ttableGroup,\n\t\t\t\t\t\tEntityNameUse.EXPRESSION,\n\t\t\t\t\t\ttableToEntityName.get(\n\t\t\t\t\t\t\t\ttableName == null\n\t\t\t\t\t\t\t\t\t\t? tableGroup.getPrimaryTableReference().getTableId()\n\t\t\t\t\t\t\t\t\t\t: tableName\n\t\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn newCondition;\n\t\t}\n\t\telse {\n\t\t\tfor ( Map.Entry<String, String> entry : aliasTableMap.entrySet() ) {\n\t\t\t\tfinal String tableName = entry.getValue();\n\t\t\t\tfinal String newCondition = StringHelper.replace(\n\t\t\t\t\t\tcondition,\n\t\t\t\t\t\t\"{\" + entry.getKey() + \"}\",\n\t\t\t\t\t\taliasGenerator.getAlias( tableName )\n\t\t\t\t);\n\t\t\t\tif ( creationState != null && !newCondition.equals( condition ) ) {\n\t\t\t\t\tcreationState.registerEntityNameUsage(\n\t\t\t\t\t\t\ttableGroup,\n\t\t\t\t\t\t\tEntityNameUse.EXPRESSION,\n\t\t\t\t\t\t\ttableToEntityName.get( tableName )\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcondition = newCondition;\n\t\t\t}\n\t\t\treturn condition;\n\t\t}\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.internal;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.Consumer;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.hibernate.Filter;\nimport org.hibernate.engine.spi.LoadQueryInfluencers;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.internal.util.StringHelper;\nimport org.hibernate.internal.util.collections.CollectionHelper;\nimport org.hibernate.metamodel.mapping.Restrictable;\nimport org.hibernate.persister.entity.EntityNameUse;\nimport org.hibernate.sql.Template;\nimport org.hibernate.sql.ast.spi.SqlAstCreationState;\nimport org.hibernate.sql.ast.tree.from.TableGroup;\nimport org.hibernate.sql.ast.tree.predicate.FilterPredicate;\nimport org.hibernate.sql.ast.tree.predicate.Predicate;\n\nimport static org.hibernate.internal.util.StringHelper.safeInterning;\n\n/**\n * Implementation of FilterHelper.\n *\n * @author Steve Ebersole\n * @author Rob Worsnop\n * @author Nathan Xu\n */\npublic class FilterHelper {\n\tprivate static final Pattern FILTER_PARAMETER_PATTERN = Pattern.compile( \":(\\\\S+)(\\\\w+)\" );\n\n\tprivate final String[] filterNames;\n\tprivate final String[] filterConditions;\n\tprivate final boolean[] filterAutoAliasFlags;\n\tprivate final Map<String, String>[] filterAliasTableMaps;\n\tprivate final List<String>[] parameterNames;\n\tprivate final Map<String, String> tableToEntityName;\n\n\tpublic FilterHelper(List<FilterConfiguration> filters, SessionFactoryImplementor factory) {\n\t\tthis( filters, null, factory );\n\t}\n\n\t/**\n\t * The map of defined filters.  This is expected to be in format\n\t * where the filter names are the map keys, and the defined\n\t * conditions are the values.\n\t *\n\t * @param filters The map of defined filters.\n\t * @param factory The session factory\n\t */\n\tpublic FilterHelper(List<FilterConfiguration> filters, Map<String, String> tableToEntityName, SessionFactoryImplementor factory) {\n\t\tint filterCount = filters.size();\n\n\t\tfilterNames = new String[filterCount];\n\t\tfilterConditions = new String[filterCount];\n\t\tfilterAutoAliasFlags = new boolean[filterCount];\n\t\tfilterAliasTableMaps = new Map[filterCount];\n\t\tparameterNames = new List[filterCount];\n\t\tthis.tableToEntityName = tableToEntityName;\n\n\t\tfilterCount = 0;\n\t\tfor ( final FilterConfiguration filter : filters ) {\n\t\t\tfinal String filterName = safeInterning( filter.getName() );\n\t\t\tfilterNames[filterCount] = filterName;\n\t\t\tfilterConditions[filterCount] = safeInterning( filter.getCondition() );\n\n\t\t\tfilterAliasTableMaps[filterCount] = filter.getAliasTableMap( factory );\n\t\t\tfilterAutoAliasFlags[filterCount] = false;\n\n\t\t\tif ( ( filterAliasTableMaps[filterCount].isEmpty()\n\t\t\t\t\t|| isTableFromPersistentClass( filterAliasTableMaps[filterCount] ) )\n\t\t\t\t\t&& filter.useAutoAliasInjection() ) {\n\t\t\t\tfinal String autoAliasedCondition = Template.renderWhereStringTemplate(\n\t\t\t\t\t\tfilter.getCondition(),\n\t\t\t\t\t\tFilterImpl.MARKER,\n\t\t\t\t\t\tfactory.getJdbcServices().getDialect(),\n\t\t\t\t\t\tfactory.getTypeConfiguration()\n\t\t\t\t);\n\t\t\t\tfilterConditions[filterCount] = safeInterning( autoAliasedCondition );\n\t\t\t\tfilterAutoAliasFlags[filterCount] = true;\n\t\t\t}\n\n\t\t\t// look for parameters in the condition.  for each parameter, we:\n\t\t\t//\t\t1) keep track of the name for later\n\t\t\t//\t\t2) // we replace `:{param-name} ` with `:{filter-name}.{param-name} ` in the condition\n\t\t\tfinal Matcher matcher = FILTER_PARAMETER_PATTERN.matcher( filterConditions[filterCount] );\n\n\t\t\tString copy = filterConditions[filterCount];\n\t\t\tfinal List<String> filterParamNames = new ArrayList<>();\n\t\t\tparameterNames[filterCount] = filterParamNames;\n\t\t\tboolean foundAny = false;\n\n\t\t\t// handle any subsequent matched parameters\n\t\t\twhile( matcher.find() ) {\n\t\t\t\tfinal String parameterLabel = filterConditions[filterCount].substring( matcher.start() + 1, matcher.end() );\n\t\t\t\tfilterParamNames.add( parameterLabel );\n\t\t\t\tcopy = copy.replace(\n\t\t\t\t\t\t\":\" + parameterLabel,\n\t\t\t\t\t\t\":\" + filterName + \".\" + parameterLabel\n\t\t\t\t);\n\t\t\t\tfoundAny = true;\n\t\t\t}\n\n\t\t\tif ( foundAny ) {\n\t\t\t\tfilterConditions[filterCount] = safeInterning( copy );\n\t\t\t}\n\n\t\t\tfilterCount++;\n\t\t}\n\t}\n\n\tprivate static boolean isTableFromPersistentClass(Map<String, String> aliasTableMap) {\n\t\treturn aliasTableMap.size() == 1 && aliasTableMap.containsKey( null );\n\t}\n\n\tpublic String[] getFilterNames() {\n\t\treturn filterNames;\n\t}\n\n\tpublic boolean isAffectedBy(Map<String, Filter> enabledFilters) {\n\t\treturn isAffectedBy( enabledFilters, false );\n\t}\n\n\tpublic boolean isAffectedBy(Map<String, Filter> enabledFilters, boolean onlyApplyForLoadByKey) {\n\t\tfor ( String filterName : filterNames ) {\n\t\t\tFilter filter = enabledFilters.get( filterName );\n\t\t\tif ( filter != null && ( !onlyApplyForLoadByKey || filter.isAppliedToLoadByKey() ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static void applyBaseRestrictions(\n\t\t\tConsumer<Predicate> predicateConsumer,\n\t\t\tRestrictable restrictable,\n\t\t\tTableGroup rootTableGroup,\n\t\t\tboolean useIdentificationVariable,\n\t\t\tLoadQueryInfluencers loadQueryInfluencers,\n\t\t\tSqlAstCreationState astCreationState) {\n\t\trestrictable.applyBaseRestrictions(\n\t\t\t\tpredicateConsumer,\n\t\t\t\trootTableGroup,\n\t\t\t\tuseIdentificationVariable,\n\t\t\t\tloadQueryInfluencers.getEnabledFilters(),\n\t\t\t\tastCreationState.applyOnlyLoadByKeyFilters(),\n\t\t\t\tnull,\n\t\t\t\tastCreationState\n\t\t);\n\t}\n\n\tpublic void applyEnabledFilters(\n\t\t\tConsumer<Predicate> predicateConsumer,\n\t\t\tFilterAliasGenerator aliasGenerator,\n\t\t\tMap<String, Filter> enabledFilters,\n\t\t\tboolean onlyApplyLoadByKeyFilters,\n\t\t\tTableGroup tableGroup,\n\t\t\tSqlAstCreationState creationState) {\n\t\tfinal FilterPredicate predicate = generateFilterPredicate(\n\t\t\t\taliasGenerator,\n\t\t\t\tenabledFilters,\n\t\t\t\tonlyApplyLoadByKeyFilters,\n\t\t\t\ttableGroup,\n\t\t\t\tcreationState\n\t\t);\n\t\tif ( predicate != null ) {\n\t\t\tpredicateConsumer.accept( predicate );\n\t\t}\n\t}\n\n\tprivate FilterPredicate generateFilterPredicate(\n\t\t\tFilterAliasGenerator aliasGenerator,\n\t\t\tMap<String, Filter> enabledFilters,\n\t\t\tboolean onlyApplyLoadByKeyFilters,\n\t\t\tTableGroup tableGroup,\n\t\t\tSqlAstCreationState creationState) {\n\t\tfinal FilterPredicate filterPredicate = new FilterPredicate();\n\n\t\tfor ( int i = 0, max = filterNames.length; i < max; i++ ) {\n\t\t\tfinal String filterName = filterNames[i];\n\t\t\tfinal FilterImpl enabledFilter = (FilterImpl) enabledFilters.get( filterName );\n\t\t\tif ( enabledFilter != null && ( !onlyApplyLoadByKeyFilters || enabledFilter.isAppliedToLoadByKey() ) ) {\n\t\t\t\tfilterPredicate.applyFragment( render( aliasGenerator, i, tableGroup, creationState ), enabledFilter, parameterNames[i] );\n\t\t\t}\n\t\t}\n\n\t\tif ( filterPredicate.isEmpty() ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn filterPredicate;\n\t}\n\n\tpublic String render(FilterAliasGenerator aliasGenerator, Map<String, Filter> enabledFilters) {\n\t\tStringBuilder buffer = new StringBuilder();\n\t\trender( buffer, aliasGenerator, enabledFilters );\n\t\treturn buffer.toString();\n\t}\n\n\tpublic void render(StringBuilder buffer, FilterAliasGenerator aliasGenerator, Map<String, Filter> enabledFilters) {\n\t\tif ( CollectionHelper.isEmpty( filterNames ) ) {\n\t\t\treturn;\n\t\t}\n\t\tfor ( int i = 0, max = filterNames.length; i < max; i++ ) {\n\t\t\tif ( enabledFilters.containsKey( filterNames[i] ) ) {\n\t\t\t\tfinal String condition = filterConditions[i];\n\t\t\t\tif ( StringHelper.isNotEmpty( condition ) ) {\n\t\t\t\t\tif ( buffer.length() > 0 ) {\n\t\t\t\t\t\tbuffer.append( \" and \" );\n\t\t\t\t\t}\n\t\t\t\t\tbuffer.append( render( aliasGenerator, i, null, null ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate String render(\n\t\t\tFilterAliasGenerator aliasGenerator,\n\t\t\tint filterIndex,\n\t\t\tTableGroup tableGroup,\n\t\t\tSqlAstCreationState creationState) {\n\t\tMap<String, String> aliasTableMap = filterAliasTableMaps[filterIndex];\n\t\tString condition = filterConditions[filterIndex];\n\t\tif ( aliasGenerator == null ) {\n\t\t\treturn StringHelper.replace( condition, FilterImpl.MARKER + \".\", \"\");\n\t\t}\n\t\tif ( filterAutoAliasFlags[filterIndex] ) {\n\t\t\tfinal String tableName = aliasTableMap.get( null );\n\t\t\tfinal String newCondition = StringHelper.replace(\n\t\t\t\t\tcondition,\n\t\t\t\t\tFilterImpl.MARKER,\n\t\t\t\t\taliasGenerator.getAlias( tableName )\n\t\t\t);\n\t\t\tif ( creationState != null && tableToEntityName != null && !newCondition.equals( condition ) ) {\n\t\t\t\tcreationState.registerEntityNameUsage(\n\t\t\t\t\t\ttableGroup,\n\t\t\t\t\t\tEntityNameUse.EXPRESSION,\n\t\t\t\t\t\ttableToEntityName.get(\n\t\t\t\t\t\t\t\ttableName == null\n\t\t\t\t\t\t\t\t\t\t? tableGroup.getPrimaryTableReference().getTableId()\n\t\t\t\t\t\t\t\t\t\t: tableName\n\t\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn newCondition;\n\t\t}\n\t\telse if ( isTableFromPersistentClass( aliasTableMap ) ) {\n\t\t\tfinal String tableName = aliasTableMap.get( null );\n\t\t\tfinal String newCondition = StringHelper.replace(\n\t\t\t\t\tcondition,\n\t\t\t\t\t\"{alias}\",\n\t\t\t\t\taliasGenerator.getAlias( tableName )\n\t\t\t);\n\t\t\tif ( creationState != null && !newCondition.equals( condition ) ) {\n\t\t\t\tcreationState.registerEntityNameUsage(\n\t\t\t\t\t\ttableGroup,\n\t\t\t\t\t\tEntityNameUse.EXPRESSION,\n\t\t\t\t\t\ttableToEntityName.get(\n\t\t\t\t\t\t\t\ttableName == null\n\t\t\t\t\t\t\t\t\t\t? tableGroup.getPrimaryTableReference().getTableId()\n\t\t\t\t\t\t\t\t\t\t: tableName\n\t\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn newCondition;\n\t\t}\n\t\telse {\n\t\t\tfor ( Map.Entry<String, String> entry : aliasTableMap.entrySet() ) {\n\t\t\t\tfinal String tableName = entry.getValue();\n\t\t\t\tfinal String newCondition = StringHelper.replace(\n\t\t\t\t\t\tcondition,\n\t\t\t\t\t\t\"{\" + entry.getKey() + \"}\",\n\t\t\t\t\t\taliasGenerator.getAlias( tableName )\n\t\t\t\t);\n\t\t\t\tif ( creationState != null && !newCondition.equals( condition ) ) {\n\t\t\t\t\tcreationState.registerEntityNameUsage(\n\t\t\t\t\t\t\ttableGroup,\n\t\t\t\t\t\t\tEntityNameUse.EXPRESSION,\n\t\t\t\t\t\t\ttableToEntityName.get( tableName )\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcondition = newCondition;\n\t\t\t}\n\t\t\treturn condition;\n\t\t}\n\t}\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate lookahead(sql String, symbols String, tokens StringTokenizer, skip int) : StringTokenizer extracted from private isLiteral(lcToken String, next String, sqlWhereString String, symbols String, tokens StringTokenizer) : boolean in class org.hibernate.sql.Template",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
                "startLine": 270,
                "endLine": 308,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
                "startLine": 300,
                "endLine": 316,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
                "startLine": 318,
                "endLine": 335,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private static boolean isLiteral(\n\t\t\tString lcToken, String next,\n\t\t\tString sqlWhereString, String symbols, StringTokenizer tokens) {\n\t\tif ( LITERAL_PREFIXES.contains( lcToken ) && next != null ) {\n\t\t\t// easy cases first\n\t\t\tif ( \"'\".equals(next) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if ( !next.isBlank() ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// we need to look ahead in the token stream\n\t\t\t\t// to find the first non-blank token\n\t\t\t\tfinal StringTokenizer lookahead =\n\t\t\t\t\t\tnew StringTokenizer( sqlWhereString, symbols, true );\n\t\t\t\twhile ( lookahead.countTokens() > tokens.countTokens()+1 ) {\n\t\t\t\t\tlookahead.nextToken();\n\t\t\t\t}\n\t\t\t\tif ( lookahead.hasMoreTokens() ) {\n\t\t\t\t\tString nextToken;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tnextToken = lookahead.nextToken().toLowerCase(Locale.ROOT);\n\t\t\t\t\t}\n\t\t\t\t\twhile ( nextToken.isBlank() && lookahead.hasMoreTokens() );\n\t\t\t\t\treturn \"'\".equals( nextToken )\n\t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"with\".equals( nextToken )\n\t\t\t\t\t\t|| lcToken.equals( \"timestamp\" ) && \"with\".equals( nextToken )\n\t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"zone\".equals( nextToken );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
        "isPureRefactoring": true,
        "commitId": "a20fb5663dc6e389aa1d9787dfbaf9750b693943",
        "packageNameBefore": "org.hibernate.sql",
        "classNameBefore": "org.hibernate.sql.Template",
        "methodNameBefore": "org.hibernate.sql.Template#isLiteral",
        "invokedMethod": "methodSignature: org.hibernate.mapping.Formula#equals\n methodBody: public boolean equals(Object obj) {\nreturn obj instanceof Formula && ((Formula)obj).formula.equals(formula);\n}\nmethodSignature: org.hibernate.mapping.PersistentClass#contains\n methodBody: public boolean contains(Property property) {\nreturn properties.contains(property);\n}",
        "classSignatureBefore": "public final class Template ",
        "methodNameBeforeSet": [
            "org.hibernate.sql.Template#isLiteral"
        ],
        "classNameBeforeSet": [
            "org.hibernate.sql.Template"
        ],
        "classSignatureBeforeSet": [
            "public final class Template "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics \n Severe changes",
                "description": "Return expression has been added within the Extract Method mechanics - with non-mapped leaves",
                "mappingState": 2
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.sql;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.query.sqm.function.SqmFunctionDescriptor;\nimport org.hibernate.query.sqm.function.SqmFunctionRegistry;\nimport org.hibernate.type.spi.TypeConfiguration;\n\nimport static java.lang.Boolean.parseBoolean;\nimport static java.lang.Character.isLetter;\nimport static org.hibernate.internal.util.StringHelper.WHITESPACE;\n\n/**\n * Parses SQL fragments specified in mapping documents.\n *\n * @author Gavin King\n */\npublic final class Template {\n\n\tprivate static final Set<String> KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> BEFORE_TABLE_KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> FUNCTION_KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> LITERAL_PREFIXES = new HashSet<>();\n\tpublic static final String PUNCTUATION = \"=><!+-*/()',|&`\";\n\n\tstatic {\n\t\tKEYWORDS.add(\"and\");\n\t\tKEYWORDS.add(\"or\");\n\t\tKEYWORDS.add(\"not\");\n\t\tKEYWORDS.add(\"like\");\n\t\tKEYWORDS.add(\"escape\");\n\t\tKEYWORDS.add(\"is\");\n\t\tKEYWORDS.add(\"in\");\n\t\tKEYWORDS.add(\"between\");\n\t\tKEYWORDS.add(\"null\");\n\t\tKEYWORDS.add(\"select\");\n\t\tKEYWORDS.add(\"distinct\");\n\t\tKEYWORDS.add(\"from\");\n\t\tKEYWORDS.add(\"join\");\n\t\tKEYWORDS.add(\"inner\");\n\t\tKEYWORDS.add(\"outer\");\n\t\tKEYWORDS.add(\"left\");\n\t\tKEYWORDS.add(\"right\");\n\t\tKEYWORDS.add(\"on\");\n\t\tKEYWORDS.add(\"where\");\n\t\tKEYWORDS.add(\"having\");\n\t\tKEYWORDS.add(\"group\");\n\t\tKEYWORDS.add(\"order\");\n\t\tKEYWORDS.add(\"by\");\n\t\tKEYWORDS.add(\"desc\");\n\t\tKEYWORDS.add(\"asc\");\n\t\tKEYWORDS.add(\"limit\");\n\t\tKEYWORDS.add(\"any\");\n\t\tKEYWORDS.add(\"some\");\n\t\tKEYWORDS.add(\"exists\");\n\t\tKEYWORDS.add(\"all\");\n\t\tKEYWORDS.add(\"union\");\n\t\tKEYWORDS.add(\"minus\");\n\t\tKEYWORDS.add(\"except\");\n\t\tKEYWORDS.add(\"intersect\");\n\t\tKEYWORDS.add(\"partition\");\n\n\t\tBEFORE_TABLE_KEYWORDS.add(\"from\");\n\t\tBEFORE_TABLE_KEYWORDS.add(\"join\");\n\n\t\tFUNCTION_KEYWORDS.add(\"as\");\n\t\tFUNCTION_KEYWORDS.add(\"leading\");\n\t\tFUNCTION_KEYWORDS.add(\"trailing\");\n\t\tFUNCTION_KEYWORDS.add(\"from\");\n\t\tFUNCTION_KEYWORDS.add(\"case\");\n\t\tFUNCTION_KEYWORDS.add(\"when\");\n\t\tFUNCTION_KEYWORDS.add(\"then\");\n\t\tFUNCTION_KEYWORDS.add(\"else\");\n\t\tFUNCTION_KEYWORDS.add(\"end\");\n\n\t\tLITERAL_PREFIXES.add(\"n\");\n\t\tLITERAL_PREFIXES.add(\"x\");\n\t\tLITERAL_PREFIXES.add(\"varbyte\");\n\t\tLITERAL_PREFIXES.add(\"bx\");\n\t\tLITERAL_PREFIXES.add(\"bytea\");\n\t\tLITERAL_PREFIXES.add(\"date\");\n\t\tLITERAL_PREFIXES.add(\"time\");\n\t\tLITERAL_PREFIXES.add(\"timestamp\");\n\t\tLITERAL_PREFIXES.add(\"zone\");\n\t}\n\n\tpublic static final String TEMPLATE = \"$PlaceHolder$\";\n\n\tprivate Template() {}\n\n\tpublic static String renderTransformerReadFragment(\n\t\t\tString fragment,\n\t\t\tString... columnNames) {\n\t\t// NOTE : would need access to SessionFactoryImplementor to make this configurable\n\t\tfor ( String columnName : columnNames ) {\n\t\t\tfragment = fragment.replace( columnName, TEMPLATE + '.' + columnName );\n\t\t}\n\t\treturn fragment;\n\t}\n\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn renderWhereStringTemplate( sqlWhereString, TEMPLATE, dialect, typeConfiguration, functionRegistry );\n\t}\n\n\t/**\n\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n\t * named parameters.\n\t *\n\t * @param sqlWhereString The string into which to interpolate the placeholder value\n\t * @param placeholder The value to be interpolated into the sqlWhereString\n\t * @param dialect The dialect to apply\n\t * @param functionRegistry The registry of all sql functions\n\t * @return The rendered sql fragment\n\t */\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\n\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n\t\t//\t\tidentifier references.\n\n\t\tfinal String symbols = PUNCTUATION + WHITESPACE + dialect.openQuote() + dialect.closeQuote();\n\t\tfinal StringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n\t\tfinal StringBuilder result = new StringBuilder();\n\n\t\tboolean quoted = false;\n\t\tboolean quotedIdentifier = false;\n\t\tboolean beforeTable = false;\n\t\tboolean inFromClause = false;\n\t\tboolean afterFromTable = false;\n\n\t\tboolean hasMore = tokens.hasMoreTokens();\n\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n\t\twhile ( hasMore ) {\n\t\t\tString token = nextToken;\n\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\tboolean isQuoteCharacter = false;\n\n\t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n\t\t\t\tquoted = !quoted;\n\t\t\t\tisQuoteCharacter = true;\n\t\t\t}\n\n\t\t\tif ( !quoted ) {\n\t\t\t\tfinal boolean isOpenQuote;\n\t\t\t\tif ( \"`\".equals(token) ) {\n\t\t\t\t\tisOpenQuote = !quotedIdentifier;\n\t\t\t\t\ttoken = lcToken = isOpenQuote\n\t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n\t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n\t\t\t\t\tquotedIdentifier = isOpenQuote;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( !quotedIdentifier && dialect.openQuote()==token.charAt(0) ) {\n\t\t\t\t\tisOpenQuote = true;\n\t\t\t\t\tquotedIdentifier = true;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( quotedIdentifier && dialect.closeQuote()==token.charAt(0) ) {\n\t\t\t\t\tquotedIdentifier = false;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\tif ( isOpenQuote ) {\n\t\t\t\t\tresult.append( placeholder ).append( '.' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinal boolean quotedOrWhitespace =\n\t\t\t\t\tquoted || quotedIdentifier || isQuoteCharacter\n\t\t\t\t\t\t\t|| token.isBlank();\n\t\t\tif ( quotedOrWhitespace ) {\n\t\t\t\tresult.append( token );\n\t\t\t}\n\t\t\telse if ( beforeTable ) {\n\t\t\t\tresult.append( token );\n\t\t\t\tbeforeTable = false;\n\t\t\t\tafterFromTable = true;\n\t\t\t}\n\t\t\telse if ( afterFromTable ) {\n\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n\t\t\t\t\tafterFromTable = false;\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isNamedParameter(token) ) {\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isExtractFunction( lcToken, nextToken ) ) {\n\t\t\t\t// Special processing for ANSI SQL EXTRACT function\n\t\t\t\thandleExtractFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\t\t\t}\n\t\t\telse if ( isTrimFunction( lcToken, nextToken ) ) {\n\t\t\t\t// Special processing for ANSI SQL TRIM function\n\t\t\t\thandleTrimFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\t\t\t}\n\t\t\telse if ( isIdentifier(token)\n\t\t\t\t\t&& !isFunctionOrKeyword( lcToken, nextToken, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t\t&& !isLiteral( lcToken, nextToken, sqlWhereString, symbols, tokens ) ) {\n\t\t\t\tresult.append(placeholder)\n\t\t\t\t\t\t.append('.')\n\t\t\t\t\t\t.append( dialect.quote(token) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t\tinFromClause = true;\n\t\t\t\t}\n\t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t}\n\t\t\t\tif ( isBoolean( token ) ) {\n\t\t\t\t\ttoken = dialect.toBooleanValueString( parseBoolean( token ) );\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\n\t\t\t//Yuck:\n\t\t\tif ( inFromClause\n\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n\t\t\t\tinFromClause = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result.toString();\n\t}\n\n\tprivate static boolean isTrimFunction(String lcToken, String nextToken) {\n\t\treturn \"trim\".equals(lcToken) && \"(\".equals(nextToken);\n\t}\n\n\tprivate static boolean isExtractFunction(String lcToken, String nextToken) {\n\t\treturn \"extract\".equals(lcToken) && \"(\".equals(nextToken);\n\t}\n\n\tprivate static boolean isLiteral(\n\t\t\tString lcToken, String next,\n\t\t\tString sqlWhereString, String symbols, StringTokenizer tokens) {\n\t\tif ( LITERAL_PREFIXES.contains( lcToken ) && next != null ) {\n\t\t\t// easy cases first\n\t\t\tif ( \"'\".equals(next) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if ( !next.isBlank() ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// we need to look ahead in the token stream\n\t\t\t\t// to find the first non-blank token\n\t\t\t\tfinal StringTokenizer lookahead =\n\t\t\t\t\t\tnew StringTokenizer( sqlWhereString, symbols, true );\n\t\t\t\twhile ( lookahead.countTokens() > tokens.countTokens()+1 ) {\n\t\t\t\t\tlookahead.nextToken();\n\t\t\t\t}\n\t\t\t\tif ( lookahead.hasMoreTokens() ) {\n\t\t\t\t\tString nextToken;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tnextToken = lookahead.nextToken().toLowerCase(Locale.ROOT);\n\t\t\t\t\t}\n\t\t\t\t\twhile ( nextToken.isBlank() && lookahead.hasMoreTokens() );\n\t\t\t\t\treturn \"'\".equals( nextToken )\n\t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"with\".equals( nextToken )\n\t\t\t\t\t\t|| lcToken.equals( \"timestamp\" ) && \"with\".equals( nextToken )\n\t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"zone\".equals( nextToken );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate static void handleTrimFunction(\n\t\t\tString placeholder, Dialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry,\n\t\t\tStringTokenizer tokens,\n\t\t\tStringBuilder result) {\n\t\tfinal List<String> operands = new ArrayList<>();\n\t\tfinal StringBuilder builder = new StringBuilder();\n\n\t\tboolean hasMoreOperands = true;\n\t\tString operandToken = tokens.nextToken();\n\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\tcase \"leading\":\n\t\t\tcase \"trailing\":\n\t\t\tcase \"both\":\n\t\t\t\toperands.add( operandToken );\n\t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tboolean quotedOperand = false;\n\t\tint parenthesis = 0;\n\t\twhile ( hasMoreOperands ) {\n\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n\t\t\tif ( isQuote ) {\n\t\t\t\tquotedOperand = !quotedOperand;\n\t\t\t\tif ( !quotedOperand ) {\n\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuilder.append( '\\'' );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( quotedOperand ) {\n\t\t\t\tbuilder.append( operandToken );\n\t\t\t}\n\t\t\telse if ( parenthesis != 0 ) {\n\t\t\t\tbuilder.append( operandToken );\n\t\t\t\tswitch ( operandToken ) {\n\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \")\":\n\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbuilder.append( operandToken );\n\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \")\":\n\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"from\":\n\t\t\t\t\t\tif ( !builder.isEmpty() ) {\n\t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\toperandToken = tokens.nextToken();\n\t\t\thasMoreOperands = tokens.hasMoreTokens()\n\t\t\t\t\t&& ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n\t\t}\n\t\tif ( !builder.isEmpty() ) {\n\t\t\toperands.add( builder.toString() );\n\t\t}\n\n\t\tfinal TrimOperands trimOperands = new TrimOperands( operands );\n\t\tresult.append( \"trim(\" );\n\t\tif ( trimOperands.trimSpec != null ) {\n\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n\t\t}\n\t\tif ( trimOperands.trimChar != null ) {\n\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n\t\t\t\tresult.append( trimOperands.trimChar );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult.append(\n\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t);\n\t\t\t}\n\t\t\tresult.append( ' ' );\n\t\t}\n\t\tif ( trimOperands.from != null ) {\n\t\t\tresult.append( trimOperands.from ).append( ' ' );\n\t\t}\n\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char is specified\n\t\t\tresult.append( \"from \" );\n\t\t}\n\n\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, typeConfiguration, functionRegistry ) )\n\t\t\t\t.append( ')' );\n\t}\n\n\tprivate static void handleExtractFunction(\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry,\n\t\t\tStringTokenizer tokens,\n\t\t\tStringBuilder result) {\n\t\tfinal String field = extractUntil( tokens, \"from\" );\n\t\tfinal String source = renderWhereStringTemplate(\n\t\t\t\textractUntil( tokens, \")\" ),\n\t\t\t\tplaceholder,\n\t\t\t\tdialect,\n\t\t\t\ttypeConfiguration,\n\t\t\t\tfunctionRegistry\n\t\t);\n\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n\t}\n\n\tpublic static List<String> collectColumnNames(\n\t\t\tString sql,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn collectColumnNames( renderWhereStringTemplate( sql, dialect, typeConfiguration, functionRegistry ) );\n\t}\n\n\tpublic static List<String> collectColumnNames(String template) {\n\t\tfinal List<String> names = new ArrayList<>();\n\t\tint begin = 0;\n\t\tint match;\n\t\twhile ( ( match = template.indexOf(TEMPLATE, begin) ) >= 0 ) {\n\t\t\tint start = match + TEMPLATE.length() + 1;\n\t\t\tfor ( int loc = start;; loc++ ) {\n\t\t\t\tif ( loc == template.length() - 1 ) {\n\t\t\t\t\tnames.add( template.substring( start ) );\n\t\t\t\t\tbegin = template.length();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar ch = template.charAt( loc );\n\t\t\t\t\tif ( PUNCTUATION.indexOf(ch) >= 0 || WHITESPACE.indexOf(ch) >= 0 ) {\n\t\t\t\t\t\tnames.add( template.substring( start, loc ) );\n\t\t\t\t\t\tbegin = loc;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn names;\n\t}\n\n//\t/**\n//\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n//\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n//\t * named parameters.\n//\t *\n//\t * @param sqlWhereString The string into which to interpolate the placeholder value\n//\t * @param placeholder The value to be interpolated into the sqlWhereString\n//\t * @param dialect The dialect to apply\n//\t * @param functionRegistry The registry of all sql functions\n//\t *\n//\t * @return The rendered sql fragment\n//\t */\n//\tpublic static String renderWhereStringTemplate(\n//\t\t\tString sqlWhereString,\n//\t\t\tString placeholder,\n//\t\t\tDialect dialect,\n//\t\t\tSQLFunctionRegistry functionRegistry) {\n//\n//\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n//\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n//\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n//\t\t//\t\tidentifier references.\n//\n//\t\tfinal String dialectOpenQuote = Character.toString( dialect.openQuote() );\n//\t\tfinal String dialectCloseQuote = Character.toString( dialect.closeQuote() );\n//\n//\t\tString symbols = new StringBuilder()\n//\t\t\t\t.append( \"=><!+-*/()',|&`\" )\n//\t\t\t\t.append( StringHelper.WHITESPACE )\n//\t\t\t\t.append( dialect.openQuote() )\n//\t\t\t\t.append( dialect.closeQuote() )\n//\t\t\t\t.toString();\n//\t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n//\t\tProcessingState state = new ProcessingState();\n//\n//\t\tStringBuilder quotedBuffer = new StringBuilder();\n//\t\tStringBuilder result = new StringBuilder();\n//\n//\t\tboolean hasMore = tokens.hasMoreTokens();\n//\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n//\t\twhile ( hasMore ) {\n//\t\t\tString token = nextToken;\n//\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n//\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t// First, determine quoting which might be based on either:\n//\t\t\t// \t\t1) back-tick\n//\t\t\t// \t\t2) single quote (ANSI SQL standard)\n//\t\t\t// \t\t3) or dialect defined quote character(s)\n//\t\t\tQuotingCharacterDisposition quotingCharacterDisposition = QuotingCharacterDisposition.NONE;\n//\t\t\tif ( \"`\".equals( token ) ) {\n//\t\t\t\tstate.quoted = !state.quoted;\n//\t\t\t\tquotingCharacterDisposition = state.quoted\n//\t\t\t\t\t\t? QuotingCharacterDisposition.OPEN\n//\t\t\t\t\t\t: QuotingCharacterDisposition.CLOSE;\n//\t\t\t\t// replace token with the appropriate dialect quoting char\n//\t\t\t\ttoken = lcToken = ( quotingCharacterDisposition == QuotingCharacterDisposition.OPEN )\n//\t\t\t\t\t\t? dialectOpenQuote\n//\t\t\t\t\t\t: dialectCloseQuote;\n//\t\t\t}\n//\t\t\telse if ( \"'\".equals( token ) ) {\n//\t\t\t\tstate.quoted = !state.quoted;\n//\t\t\t\tquotingCharacterDisposition = state.quoted\n//\t\t\t\t\t\t? QuotingCharacterDisposition.OPEN\n//\t\t\t\t\t\t: QuotingCharacterDisposition.CLOSE;\n//\t\t\t}\n//\t\t\telse if ( !state.quoted && dialectOpenQuote.equals( token ) ) {\n//\t\t\t\tstate.quoted = true;\n//\t\t\t\tquotingCharacterDisposition = QuotingCharacterDisposition.OPEN;\n//\t\t\t}\n//\t\t\telse if ( state.quoted && dialectCloseQuote.equals( token ) ) {\n//\t\t\t\tstate.quoted = false;\n//\t\t\t\tquotingCharacterDisposition = QuotingCharacterDisposition.CLOSE;\n//\t\t\t}\n//\n//\t\t\tif ( state.quoted ) {\n//\t\t\t\tquotedBuffer.append( token );\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// if we were previously processing quoted state and just encountered the close quote, then handle that\n//\t\t\t// quoted text\n//\t\t\tif ( quotingCharacterDisposition == QuotingCharacterDisposition.CLOSE ) {\n//\t\t\t\ttoken = quotedBuffer.toString();\n//\t\t\t\tquotedBuffer.setLength( 0 );\n//\t\t\t\tresult.append( placeholder ).append( '.' )\n//\t\t\t\t\t\t.append( dialectOpenQuote ).append( token ).append( dialectCloseQuote );\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// Special processing for ANSI SQL EXTRACT function\n//\t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n//\t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n//\t\t\t\tfinal String source = renderWhereStringTemplate(\n//\t\t\t\t\t\textractUntil( tokens, \")\" ),\n//\t\t\t\t\t\tplaceholder,\n//\t\t\t\t\t\tdialect,\n//\t\t\t\t\t\tfunctionRegistry\n//\t\t\t\t);\n//\t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n//\n//\t\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// Special processing for ANSI SQL TRIM function\n//\t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n//\t\t\t\tList<String> operands = new ArrayList<String>();\n//\t\t\t\tStringBuilder builder = new StringBuilder();\n//\n//\t\t\t\tboolean hasMoreOperands = true;\n//\t\t\t\tString operandToken = tokens.nextToken();\n//\t\t\t\tboolean quoted = false;\n//\t\t\t\twhile ( hasMoreOperands ) {\n//\t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n//\t\t\t\t\tif ( isQuote ) {\n//\t\t\t\t\t\tquoted = !quoted;\n//\t\t\t\t\t\tif ( !quoted ) {\n//\t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n//\t\t\t\t\t\t\tbuilder.setLength( 0 );\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse {\n//\t\t\t\t\t\t\tbuilder.append( '\\'' );\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t\telse if ( quoted ) {\n//\t\t\t\t\t\tbuilder.append( operandToken );\n//\t\t\t\t\t}\n//\t\t\t\t\telse if ( operandToken.length() == 1 && Character.isWhitespace( operandToken.charAt( 0 ) ) ) {\n//\t\t\t\t\t\t// do nothing\n//\t\t\t\t\t}\n//\t\t\t\t\telse {\n//\t\t\t\t\t\toperands.add( operandToken );\n//\t\t\t\t\t}\n//\t\t\t\t\toperandToken = tokens.nextToken();\n//\t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ! \")\".equals( operandToken );\n//\t\t\t\t}\n//\n//\t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n//\t\t\t\tresult.append( \"trim(\" );\n//\t\t\t\tif ( trimOperands.trimSpec != null ) {\n//\t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n//\t\t\t\t}\n//\t\t\t\tif ( trimOperands.trimChar != null ) {\n//\t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n//\t\t\t\t\t\tresult.append( trimOperands.trimChar );\n//\t\t\t\t\t}\n//\t\t\t\t\telse {\n//\t\t\t\t\t\tresult.append(\n//\t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, functionRegistry )\n//\t\t\t\t\t\t);\n//\t\t\t\t\t}\n//\t\t\t\t\tresult.append( ' ' );\n//\t\t\t\t}\n//\t\t\t\tif ( trimOperands.from != null ) {\n//\t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n//\t\t\t\t}\n//\t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n//\t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char are specified\n//\t\t\t\t\tresult.append( \"from \" );\n//\t\t\t\t}\n//\n//\t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, functionRegistry ) )\n//\t\t\t\t\t\t.append( ')' );\n//\n//\t\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\n//\t\t\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\n//\t\t\tif ( Character.isWhitespace( token.charAt( 0 ) ) ) {\n//\t\t\t\tresult.append( token );\n//\t\t\t}\n//\t\t\telse if ( state.beforeTable ) {\n//\t\t\t\tresult.append( token );\n//\t\t\t\tstate.beforeTable = false;\n//\t\t\t\tstate.afterFromTable = true;\n//\t\t\t}\n//\t\t\telse if ( state.afterFromTable ) {\n//\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n//\t\t\t\t\tstate.afterFromTable = false;\n//\t\t\t\t}\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\t\t\telse if ( isNamedParameter(token) ) {\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\t\t\telse if ( isIdentifier(token, dialect)\n//\t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect , functionRegistry) ) {\n//\t\t\t\tresult.append(placeholder)\n//\t\t\t\t\t\t.append('.')\n//\t\t\t\t\t\t.append( dialect.quote(token) );\n//\t\t\t}\n//\t\t\telse {\n//\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n//\t\t\t\t\tstate.beforeTable = true;\n//\t\t\t\t\tstate.inFromClause = true;\n//\t\t\t\t}\n//\t\t\t\telse if ( state.inFromClause && \",\".equals(lcToken) ) {\n//\t\t\t\t\tstate.beforeTable = true;\n//\t\t\t\t}\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\n//\t\t\t//Yuck:\n//\t\t\tif ( state.inFromClause\n//\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n//\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n//\t\t\t\tstate.inFromClause = false;\n//\t\t\t}\n//\t\t}\n//\n//\t\treturn result.toString();\n//\t}\n//\n//\tprivate static class ProcessingState {\n//\t\tboolean quoted = false;\n//\t\tboolean quotedIdentifier = false;\n//\t\tboolean beforeTable = false;\n//\t\tboolean inFromClause = false;\n//\t\tboolean afterFromTable = false;\n//\t}\n//\n//\tprivate static enum QuotingCharacterDisposition { NONE, OPEN, CLOSE }\n\n\tprivate static class TrimOperands {\n\t\tprivate final String trimSpec;\n\t\tprivate final String trimChar;\n\t\tprivate final String from;\n\t\tprivate final String trimSource;\n\n\t\tprivate TrimOperands(List<String> operands) {\n\t\t\tfinal int size = operands.size();\n\t\t\tif ( size == 1 ) {\n\t\t\t\ttrimSpec = null;\n\t\t\t\ttrimChar = null;\n\t\t\t\tfrom = null;\n\t\t\t\ttrimSource = operands.get(0);\n\t\t\t}\n\t\t\telse if ( size == 4 ) {\n\t\t\t\ttrimSpec = operands.get(0);\n\t\t\t\ttrimChar = operands.get(1);\n\t\t\t\tfrom = operands.get(2);\n\t\t\t\ttrimSource = operands.get(3);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( size < 1 || size > 4 ) {\n\t\t\t\t\tthrow new HibernateException( \"Unexpected number of trim function operands : \" + size );\n\t\t\t\t}\n\n\t\t\t\t// trim-source will always be the last operand\n\t\t\t\ttrimSource = operands.get( size - 1 );\n\n\t\t\t\t// ANSI SQL says that more than one operand means that the FROM is required\n\t\t\t\tif ( ! \"from\".equals( operands.get( size - 2 ) ) ) {\n\t\t\t\t\tthrow new HibernateException( \"Expecting FROM, found : \" + operands.get( size - 2 ) );\n\t\t\t\t}\n\t\t\t\tfrom = operands.get( size - 2 );\n\n\t\t\t\t// trim-spec, if there is one will always be the first operand\n\t\t\t\tif ( \"leading\".equalsIgnoreCase( operands.get(0) )\n\t\t\t\t\t\t|| \"trailing\".equalsIgnoreCase( operands.get(0) )\n\t\t\t\t\t\t|| \"both\".equalsIgnoreCase( operands.get(0) ) ) {\n\t\t\t\t\ttrimSpec = operands.get(0);\n\t\t\t\t\ttrimChar = null;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttrimSpec = null;\n\t\t\t\t\tif ( size - 2 == 0 ) {\n\t\t\t\t\t\ttrimChar = null;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttrimChar = operands.get( 0 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static String extractUntil(StringTokenizer tokens, String delimiter) {\n\t\tfinal StringBuilder valueBuilder = new StringBuilder();\n\t\tString token = tokens.nextToken();\n\t\twhile ( ! delimiter.equalsIgnoreCase( token ) ) {\n\t\t\tvalueBuilder.append( token );\n\t\t\ttoken = tokens.nextToken();\n\t\t}\n\t\treturn valueBuilder.toString().trim();\n\t}\n\n\tprivate static boolean isNamedParameter(String token) {\n\t\treturn token.startsWith( \":\" );\n\t}\n\n\tprivate static boolean isFunctionOrKeyword(\n\t\t\tString lcToken,\n\t\t\tString nextToken,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\tif ( \"(\".equals( nextToken ) ) {\n\t\t\treturn true;\n\t\t}\n\t\telse if ( \"date\".equals( lcToken ) || \"time\".equals( lcToken ) ) {\n\t\t\t// these can be column names on some databases\n\t\t\t// TODO: treat 'current date' as a function\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\treturn KEYWORDS.contains( lcToken )\n\t\t\t\t|| isType( lcToken, typeConfiguration )\n\t\t\t\t|| isFunction( lcToken, nextToken, functionRegistry )\n\t\t\t\t|| dialect.getKeywords().contains( lcToken )\n\t\t\t\t|| FUNCTION_KEYWORDS.contains( lcToken );\n\t\t}\n\t}\n\n\tprivate static boolean isType(String lcToken, TypeConfiguration typeConfiguration) {\n\t\treturn typeConfiguration.getDdlTypeRegistry().isTypeNameRegistered( lcToken );\n\t}\n\n\tprivate static boolean isFunction(String lcToken, String nextToken, SqmFunctionRegistry functionRegistry) {\n\t\t// checking for \"(\" is currently redundant because it is checked before getting here;\n\t\t// doing the check anyhow, in case that earlier check goes away;\n\t\tif ( \"(\".equals( nextToken ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tfinal SqmFunctionDescriptor function = functionRegistry.findFunctionDescriptor( lcToken );\n\t\treturn function != null;\n\t}\n\n\tprivate static boolean isIdentifier(String token) {\n\t\tif ( isBoolean( token ) ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn token.charAt( 0 ) == '`'\n\t\t\t|| ( //allow any identifier quoted with backtick\n\t\t\t\tisLetter( token.charAt( 0 ) ) && //only recognizes identifiers beginning with a letter\n\t\t\t\t\t\ttoken.indexOf( '.' ) < 0\n\t\t\t);\n\t}\n\n\tprivate static boolean isBoolean(String token) {\n\t\treturn \"true\".equals( token ) || \"false\".equals( token );\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.sql;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.function.Function;\n\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.type.spi.TypeConfiguration;\n\nimport static java.lang.Boolean.parseBoolean;\nimport static java.lang.Character.isLetter;\nimport static org.hibernate.internal.util.StringHelper.WHITESPACE;\n\n/**\n * Parses SQL fragments specified in mapping documents. The SQL fragment\n * should be written in the native SQL dialect of the target database,\n * with the following special exceptions:\n * <ul>\n *     <li>any backtick-quoted identifiers, for example {@code `hello`},\n *     is interpreted as a quoted identifier and re-quoted using the\n *     {@linkplain Dialect#quote native quoted identifier syntax} of\n *     the database, and</li>\n *     <li>the literal identifiers {@code true} and {@code false} are\n *     interpreted are literal boolean values, and replaced with\n *     {@linkplain Dialect#toBooleanValueString dialect-specific\n *     literal values}.\n *     </li>\n * </ul>\n *\n * @implNote This is based on a simple scanner-based state machine.\n *           It is NOT in any way, shape, nor form, a parser, since\n *           we simply cannot recognize the syntax of every dialect\n *           of SQL we support.\n *\n * @author Gavin King\n */\npublic final class Template {\n\n\tprivate static final Set<String> KEYWORDS = Set.of(\n\t\t\t\"and\",\n\t\t\t\"or\",\n\t\t\t\"not\",\n\t\t\t\"like\",\n\t\t\t\"escape\",\n\t\t\t\"is\",\n\t\t\t\"in\",\n\t\t\t\"between\",\n\t\t\t\"null\",\n\t\t\t\"select\",\n\t\t\t\"distinct\",\n\t\t\t\"from\",\n\t\t\t\"join\",\n\t\t\t\"inner\",\n\t\t\t\"outer\",\n\t\t\t\"left\",\n\t\t\t\"right\",\n\t\t\t\"on\",\n\t\t\t\"where\",\n\t\t\t\"having\",\n\t\t\t\"group\",\n\t\t\t\"order\",\n\t\t\t\"by\",\n\t\t\t\"desc\",\n\t\t\t\"asc\",\n\t\t\t\"limit\",\n\t\t\t\"any\",\n\t\t\t\"some\",\n\t\t\t\"exists\",\n\t\t\t\"all\",\n\t\t\t\"union\",\n\t\t\t\"minus\",\n\t\t\t\"except\",\n\t\t\t\"intersect\",\n\t\t\t\"partition\");\n\tprivate static final Set<String> BEFORE_TABLE_KEYWORDS\n\t\t\t= Set.of(\"from\", \"join\");\n\tprivate static final Set<String> FUNCTION_KEYWORDS\n\t\t\t= Set.of(\"as\", \"leading\", \"trailing\", \"from\", \"case\", \"when\", \"then\", \"else\", \"end\");\n\tprivate static final Set<String> FUNCTION_WITH_FROM_KEYWORDS\n\t\t\t= Set.of(\"extract\", \"trim\");\n\tprivate static final Set<String> SOFT_KEYWORDS\n\t\t\t= Set.of(\"date\", \"time\");\n\tprivate static final Set<String> LITERAL_PREFIXES\n\t\t\t= Set.of(\"n\", \"x\", \"varbyte\", \"bx\", \"bytea\", \"date\", \"time\", \"timestamp\", \"zone\");\n\n\tprivate static final String PUNCTUATION = \"=><!+-*/()',|&`\";\n\n\tpublic static final String TEMPLATE = \"{@}\";\n\n\tprivate Template() {}\n\n\tpublic static String renderTransformerReadFragment(\n\t\t\tString fragment,\n\t\t\tString... columnNames) {\n\t\t// NOTE : would need access to SessionFactoryImplementor to make this configurable\n\t\tfor ( String columnName : columnNames ) {\n\t\t\tfragment = fragment.replace( columnName, TEMPLATE + '.' + columnName );\n\t\t}\n\t\treturn fragment;\n\t}\n\n\t/**\n\t * Takes the SQL fragment provided in the mapping attribute and interpolates the default\n\t * {@linkplain #TEMPLATE placeholder value}, which is {@value #TEMPLATE}, using it to\n\t * qualify every unqualified column name.\n\t * <p>\n\t * Handles subselects, quoted identifiers, quoted strings, expressions, SQL functions,\n\t * named parameters, literals.\n\t *\n\t * @param sql The SQL string into which to interpolate the placeholder value\n\t * @param dialect The dialect to apply\n\t * @return The rendered SQL fragment\n\t */\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sql,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration) {\n\t\treturn renderWhereStringTemplate( sql, TEMPLATE, dialect, typeConfiguration );\n\t}\n\n\t/**\n\t * Takes the SQL fragment provided in the mapping attribute and interpolates the given\n\t * alias, using it to qualify every unqualified column name.\n\t * <p>\n\t * Handles subselects, quoted identifiers, quoted strings, expressions, SQL functions,\n\t * named parameters, literals.\n\t *\n\t * @param sql The SQL string into which to interpolate the alias value\n\t * @param alias The alias to be interpolated into the SQL\n\t * @param dialect The dialect to apply\n\t * @return The rendered SQL fragment\n\t */\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sql,\n\t\t\tString alias,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration) {\n\n\t\t// IMPL NOTE: The basic process here is to tokenize the incoming string and to iterate over each token\n\t\t//\t\tin turn. As we process each token, we set a series of flags used to indicate the type of context in\n\t\t// \t\twhich the tokens occur. Depending on the state of those flags we decide whether we need to qualify\n\t\t//\t\tidentifier references.\n\n\t\t// WARNING TO MAINTAINERS: This is a simple scanner-based state machine. Please don't attempt to turn it into\n\t\t//      a parser for SQL, no matter how \"special\" your case is. What I mean by this is: don't write code which\n\t\t//      attempts to recognize the grammar of SQL, not even little bits of SQL. Previous \"enhancements\" to this\n\t\t//      function did not respect this concept, and resulted in code which was fragile and unmaintainable. If\n\t\t//      lookahead is truly necessary, use the lookahead() function provided below.\n\n\t\tfinal String symbols = PUNCTUATION + WHITESPACE + dialect.openQuote() + dialect.closeQuote();\n\t\tfinal StringTokenizer tokens = new StringTokenizer( sql, symbols, true );\n\t\tfinal StringBuilder result = new StringBuilder();\n\n\t\tboolean quoted = false;\n\t\tboolean quotedIdentifier = false;\n\t\tboolean beforeTable = false;\n\t\tboolean inFromClause = false;\n\t\tboolean afterFromTable = false;\n\t\tboolean inExtractOrTrim = false;\n\n\t\tboolean hasMore = tokens.hasMoreTokens();\n\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n\t\twhile ( hasMore ) {\n\t\t\tString token = nextToken;\n\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\tboolean isQuoteCharacter = false;\n\n\t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n\t\t\t\tquoted = !quoted;\n\t\t\t\tisQuoteCharacter = true;\n\t\t\t}\n\n\t\t\tif ( !quoted ) {\n\t\t\t\tfinal boolean isOpenQuote;\n\t\t\t\tif ( \"`\".equals(token) ) {\n\t\t\t\t\tisOpenQuote = !quotedIdentifier;\n\t\t\t\t\ttoken = lcToken = isOpenQuote\n\t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n\t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n\t\t\t\t\tquotedIdentifier = isOpenQuote;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( !quotedIdentifier && dialect.openQuote()==token.charAt(0) ) {\n\t\t\t\t\tisOpenQuote = true;\n\t\t\t\t\tquotedIdentifier = true;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( quotedIdentifier && dialect.closeQuote()==token.charAt(0) ) {\n\t\t\t\t\tquotedIdentifier = false;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\tif ( isOpenQuote ) {\n\t\t\t\t\tresult.append( alias ).append( '.' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinal boolean quotedOrWhitespace =\n\t\t\t\t\tquoted || quotedIdentifier || isQuoteCharacter\n\t\t\t\t\t\t\t|| token.isBlank();\n\t\t\tif ( quotedOrWhitespace ) {\n\t\t\t\tresult.append( token );\n\t\t\t}\n\t\t\telse if ( beforeTable ) {\n\t\t\t\tresult.append( token );\n\t\t\t\tbeforeTable = false;\n\t\t\t\tafterFromTable = true;\n\t\t\t}\n\t\t\telse if ( afterFromTable ) {\n\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n\t\t\t\t\tafterFromTable = false;\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isNamedParameter(token) ) {\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( FUNCTION_WITH_FROM_KEYWORDS.contains(lcToken) && \"(\".equals( nextToken ) ) {\n\t\t\t\tresult.append(token);\n\t\t\t\tinExtractOrTrim = true;\n\t\t\t}\n\t\t\telse if ( isIdentifier(token)\n\t\t\t\t\t&& !isFunctionOrKeyword( lcToken, nextToken, dialect, typeConfiguration )\n\t\t\t\t\t&& !isLiteral( lcToken, nextToken, sql, symbols, tokens ) ) {\n\t\t\t\tresult.append(alias)\n\t\t\t\t\t\t.append('.')\n\t\t\t\t\t\t.append( dialect.quote(token) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( \")\".equals( lcToken) ) {\n\t\t\t\t\tinExtractOrTrim = false;\n\t\t\t\t}\n\t\t\t\telse if ( !inExtractOrTrim\n\t\t\t\t\t\t&& BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t\tinFromClause = true;\n\t\t\t\t}\n\t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t}\n\t\t\t\tif ( isBoolean( token ) ) {\n\t\t\t\t\ttoken = dialect.toBooleanValueString( parseBoolean( token ) );\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\n\t\t\t//Yuck:\n\t\t\tif ( inFromClause\n\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n\t\t\t\tinFromClause = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result.toString();\n\t}\n\n\tprivate static boolean isLiteral(\n\t\t\tString lcToken, String next,\n\t\t\tString sqlWhereString, String symbols, StringTokenizer tokens) {\n\t\tif ( LITERAL_PREFIXES.contains( lcToken ) && next != null ) {\n\t\t\t// easy cases first\n\t\t\tif ( \"'\".equals(next) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if ( !next.isBlank() ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// we need to look ahead in the token stream\n\t\t\t\t// to find the first non-blank token\n\t\t\t\treturn lookPastBlankTokens( sqlWhereString, symbols, tokens, 1,\n\t\t\t\t\t\t(String nextToken)\n\t\t\t\t\t\t\t\t-> \"'\".equals(nextToken)\n\t\t\t\t\t\t\t\t|| lcToken.equals(\"time\") && \"with\".equals(nextToken)\n\t\t\t\t\t\t\t\t|| lcToken.equals(\"timestamp\") && \"with\".equals(nextToken)\n\t\t\t\t\t\t\t\t|| lcToken.equals(\"time\") && \"zone\".equals(nextToken) );\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate static boolean lookPastBlankTokens(\n\t\t\tString sqlWhereString, String symbols, StringTokenizer tokens,\n\t\t\t@SuppressWarnings(\"SameParameterValue\") int skip,\n\t\t\tFunction<String, Boolean> check) {\n\t\tfinal StringTokenizer lookahead = lookahead( sqlWhereString, symbols, tokens, skip );\n\t\tif ( lookahead.hasMoreTokens() ) {\n\t\t\tString nextToken;\n\t\t\tdo {\n\t\t\t\tnextToken = lookahead.nextToken().toLowerCase(Locale.ROOT);\n\t\t\t}\n\t\t\twhile ( nextToken.isBlank() && lookahead.hasMoreTokens() );\n\t\t\treturn check.apply( nextToken );\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Clone the given token stream, returning a token stream which begins\n\t * from the next token.\n\t *\n\t * @param sql the full SQL we are scanning\n\t * @param symbols the delimiter symbols\n\t * @param tokens the current token stream\n\t * @param skip the number of tokens to skip\n\t * @return a cloned token stream\n\t */\n\tprivate static StringTokenizer lookahead(String sql, String symbols, StringTokenizer tokens, int skip) {\n\t\tfinal StringTokenizer lookahead =\n\t\t\t\tnew StringTokenizer( sql, symbols, true );\n\t\twhile ( lookahead.countTokens() > tokens.countTokens() + skip ) {\n\t\t\tlookahead.nextToken();\n\t\t}\n\t\treturn lookahead;\n\t}\n\n\tpublic static List<String> collectColumnNames(String sql, Dialect dialect, TypeConfiguration typeConfiguration) {\n\t\treturn collectColumnNames( renderWhereStringTemplate( sql, dialect, typeConfiguration ) );\n\t}\n\n\tpublic static List<String> collectColumnNames(String template) {\n\t\tfinal List<String> names = new ArrayList<>();\n\t\tint begin = 0;\n\t\tint match;\n\t\twhile ( ( match = template.indexOf(TEMPLATE, begin) ) >= 0 ) {\n\t\t\tint start = match + TEMPLATE.length() + 1;\n\t\t\tfor ( int loc = start;; loc++ ) {\n\t\t\t\tif ( loc == template.length() - 1 ) {\n\t\t\t\t\tnames.add( template.substring( start ) );\n\t\t\t\t\tbegin = template.length();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar ch = template.charAt( loc );\n\t\t\t\t\tif ( PUNCTUATION.indexOf(ch) >= 0 || WHITESPACE.indexOf(ch) >= 0 ) {\n\t\t\t\t\t\tnames.add( template.substring( start, loc ) );\n\t\t\t\t\t\tbegin = loc;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn names;\n\t}\n\n\tprivate static boolean isNamedParameter(String token) {\n\t\treturn token.startsWith( \":\" );\n\t}\n\n\tprivate static boolean isFunctionOrKeyword(\n\t\t\tString lcToken,\n\t\t\tString nextToken,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration) {\n\t\tif ( \"(\".equals( nextToken ) ) {\n\t\t\treturn true;\n\t\t}\n\t\telse if ( SOFT_KEYWORDS.contains( lcToken ) ) {\n\t\t\t// these can be column names on some databases\n\t\t\t// TODO: treat 'current date' as a function\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\treturn KEYWORDS.contains( lcToken )\n\t\t\t\t|| isType( lcToken, typeConfiguration )\n\t\t\t\t|| dialect.getKeywords().contains( lcToken )\n\t\t\t\t|| FUNCTION_KEYWORDS.contains( lcToken );\n\t\t}\n\t}\n\n\tprivate static boolean isType(String lcToken, TypeConfiguration typeConfiguration) {\n\t\treturn typeConfiguration.getDdlTypeRegistry().isTypeNameRegistered( lcToken );\n\t}\n\n\tprivate static boolean isIdentifier(String token) {\n\t\tif ( isBoolean( token ) ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn token.charAt( 0 ) == '`'\n\t\t\t|| ( //allow any identifier quoted with backtick\n\t\t\t\tisLetter( token.charAt( 0 ) ) && //only recognizes identifiers beginning with a letter\n\t\t\t\t\t\ttoken.indexOf( '.' ) < 0\n\t\t\t);\n\t}\n\n\tprivate static boolean isBoolean(String token) {\n\t\treturn \"true\".equals( token ) || \"false\".equals( token );\n\t}\n}\n",
        "diffSourceCodeSet": [
            "/**\n\t * Clone the given token stream, returning a token stream which begins\n\t * from the next token.\n\t *\n\t * @param sql the full SQL we are scanning\n\t * @param symbols the delimiter symbols\n\t * @param tokens the current token stream\n\t * @param skip the number of tokens to skip\n\t * @return a cloned token stream\n\t */\n\tprivate static StringTokenizer lookahead(String sql, String symbols, StringTokenizer tokens, int skip) {\n\t\tfinal StringTokenizer lookahead =\n\t\t\t\tnew StringTokenizer( sql, symbols, true );\n\t\twhile ( lookahead.countTokens() > tokens.countTokens() + skip ) {\n\t\t\tlookahead.nextToken();\n\t\t}\n\t\treturn lookahead;\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.mapping.Formula#equals\n methodBody: public boolean equals(Object obj) {\nreturn obj instanceof Formula && ((Formula)obj).formula.equals(formula);\n}",
            "methodSignature: org.hibernate.mapping.PersistentClass#contains\n methodBody: public boolean contains(Property property) {\nreturn properties.contains(property);\n}"
        ],
        "sourceCodeAfterRefactoring": "private static boolean lookPastBlankTokens(\n\t\t\tString sqlWhereString, String symbols, StringTokenizer tokens,\n\t\t\t@SuppressWarnings(\"SameParameterValue\") int skip,\n\t\t\tFunction<String, Boolean> check) {\n\t\tfinal StringTokenizer lookahead = lookahead( sqlWhereString, symbols, tokens, skip );\n\t\tif ( lookahead.hasMoreTokens() ) {\n\t\t\tString nextToken;\n\t\t\tdo {\n\t\t\t\tnextToken = lookahead.nextToken().toLowerCase(Locale.ROOT);\n\t\t\t}\n\t\t\twhile ( nextToken.isBlank() && lookahead.hasMoreTokens() );\n\t\t\treturn check.apply( nextToken );\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n/**\n\t * Clone the given token stream, returning a token stream which begins\n\t * from the next token.\n\t *\n\t * @param sql the full SQL we are scanning\n\t * @param symbols the delimiter symbols\n\t * @param tokens the current token stream\n\t * @param skip the number of tokens to skip\n\t * @return a cloned token stream\n\t */\n\tprivate static StringTokenizer lookahead(String sql, String symbols, StringTokenizer tokens, int skip) {\n\t\tfinal StringTokenizer lookahead =\n\t\t\t\tnew StringTokenizer( sql, symbols, true );\n\t\twhile ( lookahead.countTokens() > tokens.countTokens() + skip ) {\n\t\t\tlookahead.nextToken();\n\t\t}\n\t\treturn lookahead;\n\t}",
        "diffSourceCode": "-  270: \tprivate static boolean isLiteral(\n-  271: \t\t\tString lcToken, String next,\n-  272: \t\t\tString sqlWhereString, String symbols, StringTokenizer tokens) {\n-  273: \t\tif ( LITERAL_PREFIXES.contains( lcToken ) && next != null ) {\n-  274: \t\t\t// easy cases first\n-  275: \t\t\tif ( \"'\".equals(next) ) {\n-  276: \t\t\t\treturn true;\n-  277: \t\t\t}\n-  278: \t\t\telse if ( !next.isBlank() ) {\n-  279: \t\t\t\treturn false;\n+  270: \t\treturn result.toString();\n+  271: \t}\n+  272: \n+  273: \tprivate static boolean isLiteral(\n+  274: \t\t\tString lcToken, String next,\n+  275: \t\t\tString sqlWhereString, String symbols, StringTokenizer tokens) {\n+  276: \t\tif ( LITERAL_PREFIXES.contains( lcToken ) && next != null ) {\n+  277: \t\t\t// easy cases first\n+  278: \t\t\tif ( \"'\".equals(next) ) {\n+  279: \t\t\t\treturn true;\n   280: \t\t\t}\n-  281: \t\t\telse {\n-  282: \t\t\t\t// we need to look ahead in the token stream\n-  283: \t\t\t\t// to find the first non-blank token\n-  284: \t\t\t\tfinal StringTokenizer lookahead =\n-  285: \t\t\t\t\t\tnew StringTokenizer( sqlWhereString, symbols, true );\n-  286: \t\t\t\twhile ( lookahead.countTokens() > tokens.countTokens()+1 ) {\n-  287: \t\t\t\t\tlookahead.nextToken();\n-  288: \t\t\t\t}\n-  289: \t\t\t\tif ( lookahead.hasMoreTokens() ) {\n-  290: \t\t\t\t\tString nextToken;\n-  291: \t\t\t\t\tdo {\n-  292: \t\t\t\t\t\tnextToken = lookahead.nextToken().toLowerCase(Locale.ROOT);\n-  293: \t\t\t\t\t}\n-  294: \t\t\t\t\twhile ( nextToken.isBlank() && lookahead.hasMoreTokens() );\n-  295: \t\t\t\t\treturn \"'\".equals( nextToken )\n-  296: \t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"with\".equals( nextToken )\n-  297: \t\t\t\t\t\t|| lcToken.equals( \"timestamp\" ) && \"with\".equals( nextToken )\n-  298: \t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"zone\".equals( nextToken );\n-  299: \t\t\t\t}\n-  300: \t\t\t\telse {\n-  301: \t\t\t\t\treturn false;\n-  302: \t\t\t\t}\n-  303: \t\t\t}\n-  304: \t\t}\n-  305: \t\telse {\n-  306: \t\t\treturn false;\n-  307: \t\t}\n-  308: \t}\n-  309: \n-  310: \tprivate static void handleTrimFunction(\n-  311: \t\t\tString placeholder, Dialect dialect,\n-  312: \t\t\tTypeConfiguration typeConfiguration,\n-  313: \t\t\tSqmFunctionRegistry functionRegistry,\n-  314: \t\t\tStringTokenizer tokens,\n-  315: \t\t\tStringBuilder result) {\n-  316: \t\tfinal List<String> operands = new ArrayList<>();\n-  318: \n-  319: \t\tboolean hasMoreOperands = true;\n-  320: \t\tString operandToken = tokens.nextToken();\n-  321: \t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n-  322: \t\t\tcase \"leading\":\n-  323: \t\t\tcase \"trailing\":\n-  324: \t\t\tcase \"both\":\n-  325: \t\t\t\toperands.add( operandToken );\n-  326: \t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n-  327: \t\t\t\t\toperandToken = tokens.nextToken();\n-  328: \t\t\t\t}\n-  329: \t\t\t\tbreak;\n-  330: \t\t}\n-  331: \t\tboolean quotedOperand = false;\n-  332: \t\tint parenthesis = 0;\n-  333: \t\twhile ( hasMoreOperands ) {\n-  334: \t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n-  335: \t\t\tif ( isQuote ) {\n+  281: \t\t\telse if ( !next.isBlank() ) {\n+  282: \t\t\t\treturn false;\n+  283: \t\t\t}\n+  284: \t\t\telse {\n+  285: \t\t\t\t// we need to look ahead in the token stream\n+  286: \t\t\t\t// to find the first non-blank token\n+  287: \t\t\t\treturn lookPastBlankTokens( sqlWhereString, symbols, tokens, 1,\n+  288: \t\t\t\t\t\t(String nextToken)\n+  289: \t\t\t\t\t\t\t\t-> \"'\".equals(nextToken)\n+  290: \t\t\t\t\t\t\t\t|| lcToken.equals(\"time\") && \"with\".equals(nextToken)\n+  291: \t\t\t\t\t\t\t\t|| lcToken.equals(\"timestamp\") && \"with\".equals(nextToken)\n+  292: \t\t\t\t\t\t\t\t|| lcToken.equals(\"time\") && \"zone\".equals(nextToken) );\n+  293: \t\t\t}\n+  294: \t\t}\n+  295: \t\telse {\n+  296: \t\t\treturn false;\n+  297: \t\t}\n+  298: \t}\n+  299: \n+  300: \tprivate static boolean lookPastBlankTokens(\n+  301: \t\t\tString sqlWhereString, String symbols, StringTokenizer tokens,\n+  302: \t\t\t@SuppressWarnings(\"SameParameterValue\") int skip,\n+  303: \t\t\tFunction<String, Boolean> check) {\n+  304: \t\tfinal StringTokenizer lookahead = lookahead( sqlWhereString, symbols, tokens, skip );\n+  305: \t\tif ( lookahead.hasMoreTokens() ) {\n+  306: \t\t\tString nextToken;\n+  307: \t\t\tdo {\n+  308: \t\t\t\tnextToken = lookahead.nextToken().toLowerCase(Locale.ROOT);\n+  309: \t\t\t}\n+  310: \t\t\twhile ( nextToken.isBlank() && lookahead.hasMoreTokens() );\n+  311: \t\t\treturn check.apply( nextToken );\n+  312: \t\t}\n+  313: \t\telse {\n+  314: \t\t\treturn false;\n+  315: \t\t}\n+  316: \t}\n+  318: \t/**\n+  319: \t * Clone the given token stream, returning a token stream which begins\n+  320: \t * from the next token.\n+  321: \t *\n+  322: \t * @param sql the full SQL we are scanning\n+  323: \t * @param symbols the delimiter symbols\n+  324: \t * @param tokens the current token stream\n+  325: \t * @param skip the number of tokens to skip\n+  326: \t * @return a cloned token stream\n+  327: \t */\n+  328: \tprivate static StringTokenizer lookahead(String sql, String symbols, StringTokenizer tokens, int skip) {\n+  329: \t\tfinal StringTokenizer lookahead =\n+  330: \t\t\t\tnew StringTokenizer( sql, symbols, true );\n+  331: \t\twhile ( lookahead.countTokens() > tokens.countTokens() + skip ) {\n+  332: \t\t\tlookahead.nextToken();\n+  333: \t\t}\n+  334: \t\treturn lookahead;\n+  335: \t}\n",
        "uniqueId": "a20fb5663dc6e389aa1d9787dfbaf9750b693943_270_308_318_335_300_316",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 8,
                "covered": 77
            },
            "BRANCH": {
                "missed": 7,
                "covered": 23
            },
            "LINE": {
                "missed": 2,
                "covered": 15
            },
            "COMPLEXITY": {
                "missed": 6,
                "covered": 10
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "refactoringMinerResult": false,
        "compileAndTestResult": true,
        "refactoredCode": "##########################\nprivate static boolean isLiteral(\n        String lcToken, String next,\n        String sqlWhereString, String symbols, StringTokenizer tokens) {\n    if (LITERAL_PREFIXES.contains(lcToken) && next != null) {\n        // easy cases first\n        if (\"'\".equals(next)) {\n            return true;\n        } else if (!next.isBlank()) {\n            return false;\n        } else {\n            // we need to look ahead in the token stream\n            // to find the first non-blank token\n            final StringTokenizer lookahead =\n                    new StringTokenizer(sqlWhereString, symbols, true);\n            while (lookahead.countTokens() > tokens.countTokens() + 1) {\n                lookahead.nextToken();\n            }\n            if (lookahead.hasMoreTokens()) {\n                String nextToken;\n                do {\n                    nextToken = lookahead.nextToken().toLowerCase(Locale.ROOT);\n                }\n                while (nextToken.isBlank() && lookahead.hasMoreTokens());\n                return \"'\".equals(nextToken)\n                        || lcToken.equals(\"time\") && \"with\".equals(nextToken)\n                        || lcToken.equals(\"timestamp\") && \"with\".equals(nextToken)\n                        || lcToken.equals(\"time\") && \"zone\".equals(nextToken);\n            } else {\n                return false;\n            }\n        }\n    } else {\n        return false;\n    }\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprivate static boolean isLiteral(\n\t\t\tString lcToken, String next,\n\t\t\tString sqlWhereString, String symbols, StringTokenizer tokens) {\n\t\tif ( LITERAL_PREFIXES.contains( lcToken ) && next != null ) {\n\t\t\t// easy cases first\n\t\t\tif ( \"'\".equals(next) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if ( !next.isBlank() ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// we need to look ahead in the token stream\n\t\t\t\t// to find the first non-blank token\n\t\t\t\tfinal StringTokenizer lookahead =\n\t\t\t\t\t\tnew StringTokenizer( sqlWhereString, symbols, true );\n\t\t\t\twhile ( lookahead.countTokens() > tokens.countTokens()+1 ) {\n\t\t\t\t\tlookahead.nextToken();\n\t\t\t\t}\n\t\t\t\tif ( lookahead.hasMoreTokens() ) {\n\t\t\t\t\tString nextToken;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tnextToken = lookahead.nextToken().toLowerCase(Locale.ROOT);\n\t\t\t\t\t}\n\t\t\t\t\twhile ( nextToken.isBlank() && lookahead.hasMoreTokens() );\n\t\t\t\t\treturn \"'\".equals( nextToken )\n\t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"with\".equals( nextToken )\n\t\t\t\t\t\t|| lcToken.equals( \"timestamp\" ) && \"with\".equals( nextToken )\n\t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"zone\".equals( nextToken );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.sql;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.query.sqm.function.SqmFunctionDescriptor;\nimport org.hibernate.query.sqm.function.SqmFunctionRegistry;\nimport org.hibernate.type.spi.TypeConfiguration;\n\nimport static java.lang.Boolean.parseBoolean;\nimport static java.lang.Character.isLetter;\nimport static org.hibernate.internal.util.StringHelper.WHITESPACE;\n\n/**\n * Parses SQL fragments specified in mapping documents.\n *\n * @author Gavin King\n */\npublic final class Template {\n\n\tprivate static final Set<String> KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> BEFORE_TABLE_KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> FUNCTION_KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> LITERAL_PREFIXES = new HashSet<>();\n\tpublic static final String PUNCTUATION = \"=><!+-*/()',|&`\";\n\n\tstatic {\n\t\tKEYWORDS.add(\"and\");\n\t\tKEYWORDS.add(\"or\");\n\t\tKEYWORDS.add(\"not\");\n\t\tKEYWORDS.add(\"like\");\n\t\tKEYWORDS.add(\"escape\");\n\t\tKEYWORDS.add(\"is\");\n\t\tKEYWORDS.add(\"in\");\n\t\tKEYWORDS.add(\"between\");\n\t\tKEYWORDS.add(\"null\");\n\t\tKEYWORDS.add(\"select\");\n\t\tKEYWORDS.add(\"distinct\");\n\t\tKEYWORDS.add(\"from\");\n\t\tKEYWORDS.add(\"join\");\n\t\tKEYWORDS.add(\"inner\");\n\t\tKEYWORDS.add(\"outer\");\n\t\tKEYWORDS.add(\"left\");\n\t\tKEYWORDS.add(\"right\");\n\t\tKEYWORDS.add(\"on\");\n\t\tKEYWORDS.add(\"where\");\n\t\tKEYWORDS.add(\"having\");\n\t\tKEYWORDS.add(\"group\");\n\t\tKEYWORDS.add(\"order\");\n\t\tKEYWORDS.add(\"by\");\n\t\tKEYWORDS.add(\"desc\");\n\t\tKEYWORDS.add(\"asc\");\n\t\tKEYWORDS.add(\"limit\");\n\t\tKEYWORDS.add(\"any\");\n\t\tKEYWORDS.add(\"some\");\n\t\tKEYWORDS.add(\"exists\");\n\t\tKEYWORDS.add(\"all\");\n\t\tKEYWORDS.add(\"union\");\n\t\tKEYWORDS.add(\"minus\");\n\t\tKEYWORDS.add(\"except\");\n\t\tKEYWORDS.add(\"intersect\");\n\t\tKEYWORDS.add(\"partition\");\n\n\t\tBEFORE_TABLE_KEYWORDS.add(\"from\");\n\t\tBEFORE_TABLE_KEYWORDS.add(\"join\");\n\n\t\tFUNCTION_KEYWORDS.add(\"as\");\n\t\tFUNCTION_KEYWORDS.add(\"leading\");\n\t\tFUNCTION_KEYWORDS.add(\"trailing\");\n\t\tFUNCTION_KEYWORDS.add(\"from\");\n\t\tFUNCTION_KEYWORDS.add(\"case\");\n\t\tFUNCTION_KEYWORDS.add(\"when\");\n\t\tFUNCTION_KEYWORDS.add(\"then\");\n\t\tFUNCTION_KEYWORDS.add(\"else\");\n\t\tFUNCTION_KEYWORDS.add(\"end\");\n\n\t\tLITERAL_PREFIXES.add(\"n\");\n\t\tLITERAL_PREFIXES.add(\"x\");\n\t\tLITERAL_PREFIXES.add(\"varbyte\");\n\t\tLITERAL_PREFIXES.add(\"bx\");\n\t\tLITERAL_PREFIXES.add(\"bytea\");\n\t\tLITERAL_PREFIXES.add(\"date\");\n\t\tLITERAL_PREFIXES.add(\"time\");\n\t\tLITERAL_PREFIXES.add(\"timestamp\");\n\t\tLITERAL_PREFIXES.add(\"zone\");\n\t}\n\n\tpublic static final String TEMPLATE = \"$PlaceHolder$\";\n\n\tprivate Template() {}\n\n\tpublic static String renderTransformerReadFragment(\n\t\t\tString fragment,\n\t\t\tString... columnNames) {\n\t\t// NOTE : would need access to SessionFactoryImplementor to make this configurable\n\t\tfor ( String columnName : columnNames ) {\n\t\t\tfragment = fragment.replace( columnName, TEMPLATE + '.' + columnName );\n\t\t}\n\t\treturn fragment;\n\t}\n\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn renderWhereStringTemplate( sqlWhereString, TEMPLATE, dialect, typeConfiguration, functionRegistry );\n\t}\n\n\t/**\n\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n\t * named parameters.\n\t *\n\t * @param sqlWhereString The string into which to interpolate the placeholder value\n\t * @param placeholder The value to be interpolated into the sqlWhereString\n\t * @param dialect The dialect to apply\n\t * @param functionRegistry The registry of all sql functions\n\t * @return The rendered sql fragment\n\t */\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\n\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n\t\t//\t\tidentifier references.\n\n\t\tfinal String symbols = PUNCTUATION + WHITESPACE + dialect.openQuote() + dialect.closeQuote();\n\t\tfinal StringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n\t\tfinal StringBuilder result = new StringBuilder();\n\n\t\tboolean quoted = false;\n\t\tboolean quotedIdentifier = false;\n\t\tboolean beforeTable = false;\n\t\tboolean inFromClause = false;\n\t\tboolean afterFromTable = false;\n\n\t\tboolean hasMore = tokens.hasMoreTokens();\n\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n\t\twhile ( hasMore ) {\n\t\t\tString token = nextToken;\n\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\tboolean isQuoteCharacter = false;\n\n\t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n\t\t\t\tquoted = !quoted;\n\t\t\t\tisQuoteCharacter = true;\n\t\t\t}\n\n\t\t\tif ( !quoted ) {\n\t\t\t\tfinal boolean isOpenQuote;\n\t\t\t\tif ( \"`\".equals(token) ) {\n\t\t\t\t\tisOpenQuote = !quotedIdentifier;\n\t\t\t\t\ttoken = lcToken = isOpenQuote\n\t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n\t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n\t\t\t\t\tquotedIdentifier = isOpenQuote;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( !quotedIdentifier && dialect.openQuote()==token.charAt(0) ) {\n\t\t\t\t\tisOpenQuote = true;\n\t\t\t\t\tquotedIdentifier = true;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( quotedIdentifier && dialect.closeQuote()==token.charAt(0) ) {\n\t\t\t\t\tquotedIdentifier = false;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\tif ( isOpenQuote ) {\n\t\t\t\t\tresult.append( placeholder ).append( '.' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinal boolean quotedOrWhitespace =\n\t\t\t\t\tquoted || quotedIdentifier || isQuoteCharacter\n\t\t\t\t\t\t\t|| token.isBlank();\n\t\t\tif ( quotedOrWhitespace ) {\n\t\t\t\tresult.append( token );\n\t\t\t}\n\t\t\telse if ( beforeTable ) {\n\t\t\t\tresult.append( token );\n\t\t\t\tbeforeTable = false;\n\t\t\t\tafterFromTable = true;\n\t\t\t}\n\t\t\telse if ( afterFromTable ) {\n\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n\t\t\t\t\tafterFromTable = false;\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isNamedParameter(token) ) {\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isExtractFunction( lcToken, nextToken ) ) {\n\t\t\t\t// Special processing for ANSI SQL EXTRACT function\n\t\t\t\thandleExtractFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\t\t\t}\n\t\t\telse if ( isTrimFunction( lcToken, nextToken ) ) {\n\t\t\t\t// Special processing for ANSI SQL TRIM function\n\t\t\t\thandleTrimFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\t\t\t}\n\t\t\telse if ( isIdentifier(token)\n\t\t\t\t\t&& !isFunctionOrKeyword( lcToken, nextToken, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t\t&& !isLiteral( lcToken, nextToken, sqlWhereString, symbols, tokens ) ) {\n\t\t\t\tresult.append(placeholder)\n\t\t\t\t\t\t.append('.')\n\t\t\t\t\t\t.append( dialect.quote(token) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t\tinFromClause = true;\n\t\t\t\t}\n\t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t}\n\t\t\t\tif ( isBoolean( token ) ) {\n\t\t\t\t\ttoken = dialect.toBooleanValueString( parseBoolean( token ) );\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\n\t\t\t//Yuck:\n\t\t\tif ( inFromClause\n\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n\t\t\t\tinFromClause = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result.toString();\n\t}\n\n\tprivate static boolean isTrimFunction(String lcToken, String nextToken) {\n\t\treturn \"trim\".equals(lcToken) && \"(\".equals(nextToken);\n\t}\n\n\tprivate static boolean isExtractFunction(String lcToken, String nextToken) {\n\t\treturn \"extract\".equals(lcToken) && \"(\".equals(nextToken);\n\t}\n\n\tprivate static boolean isLiteral(\n\t\t\tString lcToken, String next,\n\t\t\tString sqlWhereString, String symbols, StringTokenizer tokens) {\n\t\tif ( LITERAL_PREFIXES.contains( lcToken ) && next != null ) {\n\t\t\t// easy cases first\n\t\t\tif ( \"'\".equals(next) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if ( !next.isBlank() ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// we need to look ahead in the token stream\n\t\t\t\t// to find the first non-blank token\n\t\t\t\tfinal StringTokenizer lookahead =\n\t\t\t\t\t\tnew StringTokenizer( sqlWhereString, symbols, true );\n\t\t\t\twhile ( lookahead.countTokens() > tokens.countTokens()+1 ) {\n\t\t\t\t\tlookahead.nextToken();\n\t\t\t\t}\n\t\t\t\tif ( lookahead.hasMoreTokens() ) {\n\t\t\t\t\tString nextToken;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tnextToken = lookahead.nextToken().toLowerCase(Locale.ROOT);\n\t\t\t\t\t}\n\t\t\t\t\twhile ( nextToken.isBlank() && lookahead.hasMoreTokens() );\n\t\t\t\t\treturn \"'\".equals( nextToken )\n\t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"with\".equals( nextToken )\n\t\t\t\t\t\t|| lcToken.equals( \"timestamp\" ) && \"with\".equals( nextToken )\n\t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"zone\".equals( nextToken );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate static void handleTrimFunction(\n\t\t\tString placeholder, Dialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry,\n\t\t\tStringTokenizer tokens,\n\t\t\tStringBuilder result) {\n\t\tfinal List<String> operands = new ArrayList<>();\n\t\tfinal StringBuilder builder = new StringBuilder();\n\n\t\tboolean hasMoreOperands = true;\n\t\tString operandToken = tokens.nextToken();\n\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\tcase \"leading\":\n\t\t\tcase \"trailing\":\n\t\t\tcase \"both\":\n\t\t\t\toperands.add( operandToken );\n\t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tboolean quotedOperand = false;\n\t\tint parenthesis = 0;\n\t\twhile ( hasMoreOperands ) {\n\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n\t\t\tif ( isQuote ) {\n\t\t\t\tquotedOperand = !quotedOperand;\n\t\t\t\tif ( !quotedOperand ) {\n\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuilder.append( '\\'' );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( quotedOperand ) {\n\t\t\t\tbuilder.append( operandToken );\n\t\t\t}\n\t\t\telse if ( parenthesis != 0 ) {\n\t\t\t\tbuilder.append( operandToken );\n\t\t\t\tswitch ( operandToken ) {\n\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \")\":\n\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbuilder.append( operandToken );\n\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \")\":\n\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"from\":\n\t\t\t\t\t\tif ( !builder.isEmpty() ) {\n\t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\toperandToken = tokens.nextToken();\n\t\t\thasMoreOperands = tokens.hasMoreTokens()\n\t\t\t\t\t&& ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n\t\t}\n\t\tif ( !builder.isEmpty() ) {\n\t\t\toperands.add( builder.toString() );\n\t\t}\n\n\t\tfinal TrimOperands trimOperands = new TrimOperands( operands );\n\t\tresult.append( \"trim(\" );\n\t\tif ( trimOperands.trimSpec != null ) {\n\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n\t\t}\n\t\tif ( trimOperands.trimChar != null ) {\n\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n\t\t\t\tresult.append( trimOperands.trimChar );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult.append(\n\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t);\n\t\t\t}\n\t\t\tresult.append( ' ' );\n\t\t}\n\t\tif ( trimOperands.from != null ) {\n\t\t\tresult.append( trimOperands.from ).append( ' ' );\n\t\t}\n\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char is specified\n\t\t\tresult.append( \"from \" );\n\t\t}\n\n\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, typeConfiguration, functionRegistry ) )\n\t\t\t\t.append( ')' );\n\t}\n\n\tprivate static void handleExtractFunction(\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry,\n\t\t\tStringTokenizer tokens,\n\t\t\tStringBuilder result) {\n\t\tfinal String field = extractUntil( tokens, \"from\" );\n\t\tfinal String source = renderWhereStringTemplate(\n\t\t\t\textractUntil( tokens, \")\" ),\n\t\t\t\tplaceholder,\n\t\t\t\tdialect,\n\t\t\t\ttypeConfiguration,\n\t\t\t\tfunctionRegistry\n\t\t);\n\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n\t}\n\n\tpublic static List<String> collectColumnNames(\n\t\t\tString sql,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn collectColumnNames( renderWhereStringTemplate( sql, dialect, typeConfiguration, functionRegistry ) );\n\t}\n\n\tpublic static List<String> collectColumnNames(String template) {\n\t\tfinal List<String> names = new ArrayList<>();\n\t\tint begin = 0;\n\t\tint match;\n\t\twhile ( ( match = template.indexOf(TEMPLATE, begin) ) >= 0 ) {\n\t\t\tint start = match + TEMPLATE.length() + 1;\n\t\t\tfor ( int loc = start;; loc++ ) {\n\t\t\t\tif ( loc == template.length() - 1 ) {\n\t\t\t\t\tnames.add( template.substring( start ) );\n\t\t\t\t\tbegin = template.length();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar ch = template.charAt( loc );\n\t\t\t\t\tif ( PUNCTUATION.indexOf(ch) >= 0 || WHITESPACE.indexOf(ch) >= 0 ) {\n\t\t\t\t\t\tnames.add( template.substring( start, loc ) );\n\t\t\t\t\t\tbegin = loc;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn names;\n\t}\n\n//\t/**\n//\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n//\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n//\t * named parameters.\n//\t *\n//\t * @param sqlWhereString The string into which to interpolate the placeholder value\n//\t * @param placeholder The value to be interpolated into the sqlWhereString\n//\t * @param dialect The dialect to apply\n//\t * @param functionRegistry The registry of all sql functions\n//\t *\n//\t * @return The rendered sql fragment\n//\t */\n//\tpublic static String renderWhereStringTemplate(\n//\t\t\tString sqlWhereString,\n//\t\t\tString placeholder,\n//\t\t\tDialect dialect,\n//\t\t\tSQLFunctionRegistry functionRegistry) {\n//\n//\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n//\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n//\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n//\t\t//\t\tidentifier references.\n//\n//\t\tfinal String dialectOpenQuote = Character.toString( dialect.openQuote() );\n//\t\tfinal String dialectCloseQuote = Character.toString( dialect.closeQuote() );\n//\n//\t\tString symbols = new StringBuilder()\n//\t\t\t\t.append( \"=><!+-*/()',|&`\" )\n//\t\t\t\t.append( StringHelper.WHITESPACE )\n//\t\t\t\t.append( dialect.openQuote() )\n//\t\t\t\t.append( dialect.closeQuote() )\n//\t\t\t\t.toString();\n//\t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n//\t\tProcessingState state = new ProcessingState();\n//\n//\t\tStringBuilder quotedBuffer = new StringBuilder();\n//\t\tStringBuilder result = new StringBuilder();\n//\n//\t\tboolean hasMore = tokens.hasMoreTokens();\n//\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n//\t\twhile ( hasMore ) {\n//\t\t\tString token = nextToken;\n//\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n//\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t// First, determine quoting which might be based on either:\n//\t\t\t// \t\t1) back-tick\n//\t\t\t// \t\t2) single quote (ANSI SQL standard)\n//\t\t\t// \t\t3) or dialect defined quote character(s)\n//\t\t\tQuotingCharacterDisposition quotingCharacterDisposition = QuotingCharacterDisposition.NONE;\n//\t\t\tif ( \"`\".equals( token ) ) {\n//\t\t\t\tstate.quoted = !state.quoted;\n//\t\t\t\tquotingCharacterDisposition = state.quoted\n//\t\t\t\t\t\t? QuotingCharacterDisposition.OPEN\n//\t\t\t\t\t\t: QuotingCharacterDisposition.CLOSE;\n//\t\t\t\t// replace token with the appropriate dialect quoting char\n//\t\t\t\ttoken = lcToken = ( quotingCharacterDisposition == QuotingCharacterDisposition.OPEN )\n//\t\t\t\t\t\t? dialectOpenQuote\n//\t\t\t\t\t\t: dialectCloseQuote;\n//\t\t\t}\n//\t\t\telse if ( \"'\".equals( token ) ) {\n//\t\t\t\tstate.quoted = !state.quoted;\n//\t\t\t\tquotingCharacterDisposition = state.quoted\n//\t\t\t\t\t\t? QuotingCharacterDisposition.OPEN\n//\t\t\t\t\t\t: QuotingCharacterDisposition.CLOSE;\n//\t\t\t}\n//\t\t\telse if ( !state.quoted && dialectOpenQuote.equals( token ) ) {\n//\t\t\t\tstate.quoted = true;\n//\t\t\t\tquotingCharacterDisposition = QuotingCharacterDisposition.OPEN;\n//\t\t\t}\n//\t\t\telse if ( state.quoted && dialectCloseQuote.equals( token ) ) {\n//\t\t\t\tstate.quoted = false;\n//\t\t\t\tquotingCharacterDisposition = QuotingCharacterDisposition.CLOSE;\n//\t\t\t}\n//\n//\t\t\tif ( state.quoted ) {\n//\t\t\t\tquotedBuffer.append( token );\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// if we were previously processing quoted state and just encountered the close quote, then handle that\n//\t\t\t// quoted text\n//\t\t\tif ( quotingCharacterDisposition == QuotingCharacterDisposition.CLOSE ) {\n//\t\t\t\ttoken = quotedBuffer.toString();\n//\t\t\t\tquotedBuffer.setLength( 0 );\n//\t\t\t\tresult.append( placeholder ).append( '.' )\n//\t\t\t\t\t\t.append( dialectOpenQuote ).append( token ).append( dialectCloseQuote );\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// Special processing for ANSI SQL EXTRACT function\n//\t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n//\t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n//\t\t\t\tfinal String source = renderWhereStringTemplate(\n//\t\t\t\t\t\textractUntil( tokens, \")\" ),\n//\t\t\t\t\t\tplaceholder,\n//\t\t\t\t\t\tdialect,\n//\t\t\t\t\t\tfunctionRegistry\n//\t\t\t\t);\n//\t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n//\n//\t\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// Special processing for ANSI SQL TRIM function\n//\t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n//\t\t\t\tList<String> operands = new ArrayList<String>();\n//\t\t\t\tStringBuilder builder = new StringBuilder();\n//\n//\t\t\t\tboolean hasMoreOperands = true;\n//\t\t\t\tString operandToken = tokens.nextToken();\n//\t\t\t\tboolean quoted = false;\n//\t\t\t\twhile ( hasMoreOperands ) {\n//\t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n//\t\t\t\t\tif ( isQuote ) {\n//\t\t\t\t\t\tquoted = !quoted;\n//\t\t\t\t\t\tif ( !quoted ) {\n//\t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n//\t\t\t\t\t\t\tbuilder.setLength( 0 );\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse {\n//\t\t\t\t\t\t\tbuilder.append( '\\'' );\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t\telse if ( quoted ) {\n//\t\t\t\t\t\tbuilder.append( operandToken );\n//\t\t\t\t\t}\n//\t\t\t\t\telse if ( operandToken.length() == 1 && Character.isWhitespace( operandToken.charAt( 0 ) ) ) {\n//\t\t\t\t\t\t// do nothing\n//\t\t\t\t\t}\n//\t\t\t\t\telse {\n//\t\t\t\t\t\toperands.add( operandToken );\n//\t\t\t\t\t}\n//\t\t\t\t\toperandToken = tokens.nextToken();\n//\t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ! \")\".equals( operandToken );\n//\t\t\t\t}\n//\n//\t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n//\t\t\t\tresult.append( \"trim(\" );\n//\t\t\t\tif ( trimOperands.trimSpec != null ) {\n//\t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n//\t\t\t\t}\n//\t\t\t\tif ( trimOperands.trimChar != null ) {\n//\t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n//\t\t\t\t\t\tresult.append( trimOperands.trimChar );\n//\t\t\t\t\t}\n//\t\t\t\t\telse {\n//\t\t\t\t\t\tresult.append(\n//\t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, functionRegistry )\n//\t\t\t\t\t\t);\n//\t\t\t\t\t}\n//\t\t\t\t\tresult.append( ' ' );\n//\t\t\t\t}\n//\t\t\t\tif ( trimOperands.from != null ) {\n//\t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n//\t\t\t\t}\n//\t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n//\t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char are specified\n//\t\t\t\t\tresult.append( \"from \" );\n//\t\t\t\t}\n//\n//\t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, functionRegistry ) )\n//\t\t\t\t\t\t.append( ')' );\n//\n//\t\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\n//\t\t\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\n//\t\t\tif ( Character.isWhitespace( token.charAt( 0 ) ) ) {\n//\t\t\t\tresult.append( token );\n//\t\t\t}\n//\t\t\telse if ( state.beforeTable ) {\n//\t\t\t\tresult.append( token );\n//\t\t\t\tstate.beforeTable = false;\n//\t\t\t\tstate.afterFromTable = true;\n//\t\t\t}\n//\t\t\telse if ( state.afterFromTable ) {\n//\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n//\t\t\t\t\tstate.afterFromTable = false;\n//\t\t\t\t}\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\t\t\telse if ( isNamedParameter(token) ) {\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\t\t\telse if ( isIdentifier(token, dialect)\n//\t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect , functionRegistry) ) {\n//\t\t\t\tresult.append(placeholder)\n//\t\t\t\t\t\t.append('.')\n//\t\t\t\t\t\t.append( dialect.quote(token) );\n//\t\t\t}\n//\t\t\telse {\n//\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n//\t\t\t\t\tstate.beforeTable = true;\n//\t\t\t\t\tstate.inFromClause = true;\n//\t\t\t\t}\n//\t\t\t\telse if ( state.inFromClause && \",\".equals(lcToken) ) {\n//\t\t\t\t\tstate.beforeTable = true;\n//\t\t\t\t}\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\n//\t\t\t//Yuck:\n//\t\t\tif ( state.inFromClause\n//\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n//\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n//\t\t\t\tstate.inFromClause = false;\n//\t\t\t}\n//\t\t}\n//\n//\t\treturn result.toString();\n//\t}\n//\n//\tprivate static class ProcessingState {\n//\t\tboolean quoted = false;\n//\t\tboolean quotedIdentifier = false;\n//\t\tboolean beforeTable = false;\n//\t\tboolean inFromClause = false;\n//\t\tboolean afterFromTable = false;\n//\t}\n//\n//\tprivate static enum QuotingCharacterDisposition { NONE, OPEN, CLOSE }\n\n\tprivate static class TrimOperands {\n\t\tprivate final String trimSpec;\n\t\tprivate final String trimChar;\n\t\tprivate final String from;\n\t\tprivate final String trimSource;\n\n\t\tprivate TrimOperands(List<String> operands) {\n\t\t\tfinal int size = operands.size();\n\t\t\tif ( size == 1 ) {\n\t\t\t\ttrimSpec = null;\n\t\t\t\ttrimChar = null;\n\t\t\t\tfrom = null;\n\t\t\t\ttrimSource = operands.get(0);\n\t\t\t}\n\t\t\telse if ( size == 4 ) {\n\t\t\t\ttrimSpec = operands.get(0);\n\t\t\t\ttrimChar = operands.get(1);\n\t\t\t\tfrom = operands.get(2);\n\t\t\t\ttrimSource = operands.get(3);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( size < 1 || size > 4 ) {\n\t\t\t\t\tthrow new HibernateException( \"Unexpected number of trim function operands : \" + size );\n\t\t\t\t}\n\n\t\t\t\t// trim-source will always be the last operand\n\t\t\t\ttrimSource = operands.get( size - 1 );\n\n\t\t\t\t// ANSI SQL says that more than one operand means that the FROM is required\n\t\t\t\tif ( ! \"from\".equals( operands.get( size - 2 ) ) ) {\n\t\t\t\t\tthrow new HibernateException( \"Expecting FROM, found : \" + operands.get( size - 2 ) );\n\t\t\t\t}\n\t\t\t\tfrom = operands.get( size - 2 );\n\n\t\t\t\t// trim-spec, if there is one will always be the first operand\n\t\t\t\tif ( \"leading\".equalsIgnoreCase( operands.get(0) )\n\t\t\t\t\t\t|| \"trailing\".equalsIgnoreCase( operands.get(0) )\n\t\t\t\t\t\t|| \"both\".equalsIgnoreCase( operands.get(0) ) ) {\n\t\t\t\t\ttrimSpec = operands.get(0);\n\t\t\t\t\ttrimChar = null;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttrimSpec = null;\n\t\t\t\t\tif ( size - 2 == 0 ) {\n\t\t\t\t\t\ttrimChar = null;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttrimChar = operands.get( 0 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static String extractUntil(StringTokenizer tokens, String delimiter) {\n\t\tfinal StringBuilder valueBuilder = new StringBuilder();\n\t\tString token = tokens.nextToken();\n\t\twhile ( ! delimiter.equalsIgnoreCase( token ) ) {\n\t\t\tvalueBuilder.append( token );\n\t\t\ttoken = tokens.nextToken();\n\t\t}\n\t\treturn valueBuilder.toString().trim();\n\t}\n\n\tprivate static boolean isNamedParameter(String token) {\n\t\treturn token.startsWith( \":\" );\n\t}\n\n\tprivate static boolean isFunctionOrKeyword(\n\t\t\tString lcToken,\n\t\t\tString nextToken,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\tif ( \"(\".equals( nextToken ) ) {\n\t\t\treturn true;\n\t\t}\n\t\telse if ( \"date\".equals( lcToken ) || \"time\".equals( lcToken ) ) {\n\t\t\t// these can be column names on some databases\n\t\t\t// TODO: treat 'current date' as a function\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\treturn KEYWORDS.contains( lcToken )\n\t\t\t\t|| isType( lcToken, typeConfiguration )\n\t\t\t\t|| isFunction( lcToken, nextToken, functionRegistry )\n\t\t\t\t|| dialect.getKeywords().contains( lcToken )\n\t\t\t\t|| FUNCTION_KEYWORDS.contains( lcToken );\n\t\t}\n\t}\n\n\tprivate static boolean isType(String lcToken, TypeConfiguration typeConfiguration) {\n\t\treturn typeConfiguration.getDdlTypeRegistry().isTypeNameRegistered( lcToken );\n\t}\n\n\tprivate static boolean isFunction(String lcToken, String nextToken, SqmFunctionRegistry functionRegistry) {\n\t\t// checking for \"(\" is currently redundant because it is checked before getting here;\n\t\t// doing the check anyhow, in case that earlier check goes away;\n\t\tif ( \"(\".equals( nextToken ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tfinal SqmFunctionDescriptor function = functionRegistry.findFunctionDescriptor( lcToken );\n\t\treturn function != null;\n\t}\n\n\tprivate static boolean isIdentifier(String token) {\n\t\tif ( isBoolean( token ) ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn token.charAt( 0 ) == '`'\n\t\t\t|| ( //allow any identifier quoted with backtick\n\t\t\t\tisLetter( token.charAt( 0 ) ) && //only recognizes identifiers beginning with a letter\n\t\t\t\t\t\ttoken.indexOf( '.' ) < 0\n\t\t\t);\n\t}\n\n\tprivate static boolean isBoolean(String token) {\n\t\treturn \"true\".equals( token ) || \"false\".equals( token );\n\t}\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate handleExtractFunction(placeholder String, dialect Dialect, typeConfiguration TypeConfiguration, functionRegistry SqmFunctionRegistry, tokens StringTokenizer, result StringBuilder) : void extracted from public renderWhereStringTemplate(sqlWhereString String, placeholder String, dialect Dialect, typeConfiguration TypeConfiguration, functionRegistry SqmFunctionRegistry) : String in class org.hibernate.sql.Template",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
                "startLine": 119,
                "endLine": 402,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
                "startLine": 122,
                "endLine": 260,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
                "startLine": 413,
                "endLine": 429,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n\t * named parameters.\n\t *\n\t * @param sqlWhereString The string into which to interpolate the placeholder value\n\t * @param placeholder The value to be interpolated into the sqlWhereString\n\t * @param dialect The dialect to apply\n\t * @param functionRegistry The registry of all sql functions\n\t * @return The rendered sql fragment\n\t */\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\n\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n\t\t//\t\tidentifier references.\n\n\t\tString symbols = PUNCTUATION +\n\t\t\t\tWHITESPACE +\n\t\t\t\tdialect.openQuote() +\n\t\t\t\tdialect.closeQuote();\n\t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n\t\tStringBuilder result = new StringBuilder();\n\n\t\tboolean quoted = false;\n\t\tboolean quotedIdentifier = false;\n\t\tboolean beforeTable = false;\n\t\tboolean inFromClause = false;\n\t\tboolean afterFromTable = false;\n\n\t\tboolean hasMore = tokens.hasMoreTokens();\n\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n\t\twhile ( hasMore ) {\n\t\t\tString token = nextToken;\n\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\tboolean isQuoteCharacter = false;\n\n\t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n\t\t\t\tquoted = !quoted;\n\t\t\t\tisQuoteCharacter = true;\n\t\t\t}\n\n\t\t\tif ( !quoted ) {\n\t\t\t\tboolean isOpenQuote;\n\t\t\t\tif ( \"`\".equals(token) ) {\n\t\t\t\t\tisOpenQuote = !quotedIdentifier;\n\t\t\t\t\ttoken = lcToken = isOpenQuote\n\t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n\t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n\t\t\t\t\tquotedIdentifier = isOpenQuote;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( !quotedIdentifier && ( dialect.openQuote()==token.charAt(0) ) ) {\n\t\t\t\t\tisOpenQuote = true;\n\t\t\t\t\tquotedIdentifier = true;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( quotedIdentifier && ( dialect.closeQuote()==token.charAt(0) ) ) {\n\t\t\t\t\tquotedIdentifier = false;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\telse if ( LITERAL_PREFIXES.contains( lcToken ) ) {\n\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n\t\t\t\t\t\t// Don't prefix a literal\n\t\t\t\t\t\tresult.append( token );\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) ) {\n\t\t\t\t\t\tfinal StringBuilder additionalTokens = new StringBuilder();\n\t\t\t\t\t\tTimeZoneTokens possibleNextToken = null;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tpossibleNextToken = possibleNextToken == null\n\t\t\t\t\t\t\t\t\t? TimeZoneTokens.getPossibleNextTokens( lcToken )\n\t\t\t\t\t\t\t\t\t: possibleNextToken.nextToken();\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tadditionalTokens.append( nextToken );\n\t\t\t\t\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\t\t\t\t\tnextToken = tokens.nextToken();\n\t\t\t\t\t\t\t} while ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) );\n\t\t\t\t\t\t} while ( nextToken != null && possibleNextToken.isToken( nextToken ) );\n\t\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n\t\t\t\t\t\t\t// Don't prefix a literal\n\t\t\t\t\t\t\tresult.append( token );\n\t\t\t\t\t\t\tresult.append( additionalTokens );\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\n\t\t\t\tif ( isOpenQuote ) {\n\t\t\t\t\tresult.append( placeholder ).append( '.' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Special processing for ANSI SQL EXTRACT function\n\t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n\t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n\t\t\t\tfinal String source = renderWhereStringTemplate(\n\t\t\t\t\t\textractUntil( tokens, \")\" ),\n\t\t\t\t\t\tplaceholder,\n\t\t\t\t\t\tdialect,\n\t\t\t\t\t\ttypeConfiguration,\n\t\t\t\t\t\tfunctionRegistry\n\t\t\t\t);\n\t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Special processing for ANSI SQL TRIM function\n\t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n\t\t\t\tList<String> operands = new ArrayList<>();\n\t\t\t\tStringBuilder builder = new StringBuilder();\n\n\t\t\t\tboolean hasMoreOperands = true;\n\t\t\t\tString operandToken = tokens.nextToken();\n\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\tcase \"leading\":\n\t\t\t\t\tcase \"trailing\":\n\t\t\t\t\tcase \"both\":\n\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n\t\t\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tboolean quotedOperand = false;\n\t\t\t\tint parenthesis = 0;\n\t\t\t\twhile ( hasMoreOperands ) {\n\t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n\t\t\t\t\tif ( isQuote ) {\n\t\t\t\t\t\tquotedOperand = !quotedOperand;\n\t\t\t\t\t\tif ( !quotedOperand ) {\n\t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbuilder.append( '\\'' );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if ( quotedOperand ) {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( parenthesis != 0 ) {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t\tswitch ( operandToken ) {\n\t\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"from\":\n\t\t\t\t\t\t\t\tif ( builder.length() != 0 ) {\n\t\t\t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n\t\t\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n\t\t\t\t}\n\t\t\t\tif ( builder.length() != 0 ) {\n\t\t\t\t\toperands.add( builder.toString() );\n\t\t\t\t}\n\n\t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n\t\t\t\tresult.append( \"trim(\" );\n\t\t\t\tif ( trimOperands.trimSpec != null ) {\n\t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n\t\t\t\t}\n\t\t\t\tif ( trimOperands.trimChar != null ) {\n\t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n\t\t\t\t\t\tresult.append( trimOperands.trimChar );\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresult.append(\n\t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tresult.append( ' ' );\n\t\t\t\t}\n\t\t\t\tif ( trimOperands.from != null ) {\n\t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n\t\t\t\t}\n\t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n\t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char is specified\n\t\t\t\t\tresult.append( \"from \" );\n\t\t\t\t}\n\n\t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, typeConfiguration, functionRegistry ) )\n\t\t\t\t\t\t.append( ')' );\n\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tboolean quotedOrWhitespace = quoted || quotedIdentifier || isQuoteCharacter\n\t\t\t\t\t|| Character.isWhitespace( token.charAt(0) );\n\n\t\t\tif ( quotedOrWhitespace ) {\n\t\t\t\tresult.append( token );\n\t\t\t}\n\t\t\telse if ( beforeTable ) {\n\t\t\t\tresult.append( token );\n\t\t\t\tbeforeTable = false;\n\t\t\t\tafterFromTable = true;\n\t\t\t}\n\t\t\telse if ( afterFromTable ) {\n\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n\t\t\t\t\tafterFromTable = false;\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isNamedParameter(token) ) {\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isIdentifier(token)\n\t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect, typeConfiguration, functionRegistry) ) {\n\t\t\t\tresult.append(placeholder)\n\t\t\t\t\t\t.append('.')\n\t\t\t\t\t\t.append( dialect.quote(token) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t\tinFromClause = true;\n\t\t\t\t}\n\t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t}\n\t\t\t\tif ( isBoolean( token ) ) {\n\t\t\t\t\ttoken = dialect.toBooleanValueString( Boolean.parseBoolean( token ) );\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\n\t\t\t//Yuck:\n\t\t\tif ( inFromClause\n\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n\t\t\t\tinFromClause = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result.toString();\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
        "isPureRefactoring": true,
        "commitId": "35f96d6e901dbd071b375d809521ef6f1c979868",
        "packageNameBefore": "org.hibernate.sql",
        "classNameBefore": "org.hibernate.sql.Template",
        "methodNameBefore": "org.hibernate.sql.Template#renderWhereStringTemplate",
        "invokedMethod": "methodSignature: org.hibernate.sql.Template#extractUntil\n methodBody: private static String extractUntil(StringTokenizer tokens, String delimiter) {\nStringBuilder valueBuilder=new StringBuilder();\nString token=tokens.nextToken();\nwhile(!delimiter.equalsIgnoreCase(token)){valueBuilder.append(token);\ntoken=tokens.nextToken();\n}return valueBuilder.toString().trim();\n}\nmethodSignature: org.hibernate.sql.Template#renderWhereStringTemplate\n methodBody: public static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\nString symbols=PUNCTUATION + WHITESPACE + dialect.openQuote() + dialect.closeQuote();\nStringTokenizer tokens=new StringTokenizer(sqlWhereString,symbols,true);\nStringBuilder result=new StringBuilder();\nboolean quoted=false;\nboolean quotedIdentifier=false;\nboolean beforeTable=false;\nboolean inFromClause=false;\nboolean afterFromTable=false;\nboolean hasMore=tokens.hasMoreTokens();\nString nextToken=hasMore ? tokens.nextToken() : null;\nwhile(hasMore){String token=nextToken;\nString lcToken=token.toLowerCase(Locale.ROOT);\nhasMore=tokens.hasMoreTokens();\nnextToken=hasMore ? tokens.nextToken() : null;\nboolean isQuoteCharacter=false;\nif(!quotedIdentifier && \"'\".equals(token)){quoted=!quoted;\nisQuoteCharacter=true;\n}if(!quoted){boolean isOpenQuote;\nif(\"`\".equals(token)){isOpenQuote=!quotedIdentifier;\ntoken=lcToken=isOpenQuote ? Character.toString(dialect.openQuote()) : Character.toString(dialect.closeQuote());\nquotedIdentifier=isOpenQuote;\nisQuoteCharacter=true;\n}if(!quotedIdentifier && (dialect.openQuote() == token.charAt(0))){isOpenQuote=true;\nquotedIdentifier=true;\nisQuoteCharacter=true;\n}if(quotedIdentifier && (dialect.closeQuote() == token.charAt(0))){quotedIdentifier=false;\nisQuoteCharacter=true;\nisOpenQuote=false;\n}if(LITERAL_PREFIXES.contains(lcToken)){if(\"'\".equals(nextToken)){result.append(token);\ncontinue;\n}if(nextToken != null && Character.isWhitespace(nextToken.charAt(0))){final StringBuilder additionalTokens=new StringBuilder();\nTimeZoneTokens possibleNextToken=null;\ndo(nextToken != null && possibleNextToken.isToken(nextToken)){possibleNextToken=possibleNextToken == null ? TimeZoneTokens.getPossibleNextTokens(lcToken) : possibleNextToken.nextToken();\ndo(nextToken != null && Character.isWhitespace(nextToken.charAt(0))){additionalTokens.append(nextToken);\nhasMore=tokens.hasMoreTokens();\nnextToken=tokens.nextToken();\n}}if(\"'\".equals(nextToken)){result.append(token);\nresult.append(additionalTokens);\ncontinue;\n}{isOpenQuote=false;\n}}{isOpenQuote=false;\n}}{isOpenQuote=false;\n}if(isOpenQuote){result.append(placeholder).append('.');\n}}if(\"extract\".equals(lcToken) && \"(\".equals(nextToken)){final String field=extractUntil(tokens,\"from\");\nfinal String source=renderWhereStringTemplate(extractUntil(tokens,\")\"),placeholder,dialect,typeConfiguration,functionRegistry);\nresult.append(\"extract(\").append(field).append(\" from \").append(source).append(')');\nhasMore=tokens.hasMoreTokens();\nnextToken=hasMore ? tokens.nextToken() : null;\ncontinue;\n}if(\"trim\".equals(lcToken) && \"(\".equals(nextToken)){List<String> operands=new ArrayList<>();\nStringBuilder builder=new StringBuilder();\nboolean hasMoreOperands=true;\nString operandToken=tokens.nextToken();\nswitch(operandToken.toLowerCase(Locale.ROOT))case \"leading\":case \"trailing\":case \"both\":operands.add(operandToken);\nif(hasMoreOperands=tokens.hasMoreTokens()){operandToken=tokens.nextToken();\n}break;\nboolean quotedOperand=false;\nint parenthesis=0;\nwhile(hasMoreOperands){final boolean isQuote=\"'\".equals(operandToken);\nif(isQuote){quotedOperand=!quotedOperand;\nif(!quotedOperand){operands.add(builder.append('\\'').toString());\nbuilder.setLength(0);\n}{builder.append('\\'');\n}}if(quotedOperand){builder.append(operandToken);\n}if(parenthesis != 0){builder.append(operandToken);\nswitch(operandToken)case \"(\":parenthesis++;\nbreak;\ncase \")\":parenthesis--;\nbreak;\n}{builder.append(operandToken);\nswitch(operandToken.toLowerCase(Locale.ROOT))case \"(\":parenthesis++;\nbreak;\ncase \")\":parenthesis--;\nbreak;\ncase \"from\":if(builder.length() != 0){operands.add(builder.substring(0,builder.length() - 4));\nbuilder.setLength(0);\noperands.add(operandToken);\n}break;\n}operandToken=tokens.nextToken();\nhasMoreOperands=tokens.hasMoreTokens() && (parenthesis != 0 || !\")\".equals(operandToken));\n}if(builder.length() != 0){operands.add(builder.toString());\n}TrimOperands trimOperands=new TrimOperands(operands);\nresult.append(\"trim(\");\nif(trimOperands.trimSpec != null){result.append(trimOperands.trimSpec).append(' ');\n}if(trimOperands.trimChar != null){if(trimOperands.trimChar.startsWith(\"'\") && trimOperands.trimChar.endsWith(\"'\")){result.append(trimOperands.trimChar);\n}{result.append(renderWhereStringTemplate(trimOperands.trimSpec,placeholder,dialect,typeConfiguration,functionRegistry));\n}result.append(' ');\n}if(trimOperands.from != null){result.append(trimOperands.from).append(' ');\n}if(trimOperands.trimSpec != null || trimOperands.trimChar != null){result.append(\"from \");\n}result.append(renderWhereStringTemplate(trimOperands.trimSource,placeholder,dialect,typeConfiguration,functionRegistry)).append(')');\nhasMore=tokens.hasMoreTokens();\nnextToken=hasMore ? tokens.nextToken() : null;\ncontinue;\n}boolean quotedOrWhitespace=quoted || quotedIdentifier || isQuoteCharacter || Character.isWhitespace(token.charAt(0));\nif(quotedOrWhitespace){result.append(token);\n}if(beforeTable){result.append(token);\nbeforeTable=false;\nafterFromTable=true;\n}if(afterFromTable){if(!\"as\".equals(lcToken)){afterFromTable=false;\n}result.append(token);\n}if(isNamedParameter(token)){result.append(token);\n}if(isIdentifier(token) && !isFunctionOrKeyword(lcToken,nextToken,dialect,typeConfiguration,functionRegistry)){result.append(placeholder).append('.').append(dialect.quote(token));\n}{if(BEFORE_TABLE_KEYWORDS.contains(lcToken)){beforeTable=true;\ninFromClause=true;\n}if(inFromClause && \",\".equals(lcToken)){beforeTable=true;\n}if(isBoolean(token)){token=dialect.toBooleanValueString(Boolean.parseBoolean(token));\n}result.append(token);\n}if(inFromClause && KEYWORDS.contains(lcToken) && !BEFORE_TABLE_KEYWORDS.contains(lcToken)){inFromClause=false;\n}}return result.toString();\n}\nmethodSignature: org.hibernate.sql.Template.TimeZoneTokens#isToken\n methodBody: public boolean isToken(String token) {\nreturn this != NONE && name().equalsIgnoreCase(token);\n}\nmethodSignature: org.hibernate.sql.Template#isBoolean\n methodBody: private static boolean isBoolean(String token) {\nreturn \"true\".equals(token) || \"false\".equals(token);\n}\nmethodSignature: org.hibernate.sql.Template.TimeZoneTokens#nextToken\n methodBody: public TimeZoneTokens nextToken() {\nif(this == WITH){return TIME;\n}if(this == TIME){return ZONE;\n}{return NONE;\n}}\nmethodSignature: org.hibernate.sql.Template.TimeZoneTokens#getPossibleNextTokens\n methodBody: static TimeZoneTokens getPossibleNextTokens(String lctoken) {\nswitch(lctoken)case \"time\":case \"timestamp\":return WITH;\ndefault:return NONE;\n}\nmethodSignature: org.hibernate.sql.Template#isIdentifier\n methodBody: private static boolean isIdentifier(String token) {\nif(isBoolean(token)){return false;\n}return token.charAt(0) == '`' || (Character.isLetter(token.charAt(0)) && token.indexOf('.') < 0);\n}\nmethodSignature: org.hibernate.sql.Template#isNamedParameter\n methodBody: private static boolean isNamedParameter(String token) {\nreturn token.startsWith(\":\");\n}\nmethodSignature: org.hibernate.sql.Template#isFunctionOrKeyword\n methodBody: private static boolean isFunctionOrKeyword(\n\t\t\tString lcToken,\n\t\t\tString nextToken,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\nreturn \"(\".equals(nextToken) || KEYWORDS.contains(lcToken) || isType(lcToken,typeConfiguration) || isFunction(lcToken,nextToken,functionRegistry) || dialect.getKeywords().contains(lcToken) || FUNCTION_KEYWORDS.contains(lcToken);\n}",
        "classSignatureBefore": "public final class Template ",
        "methodNameBeforeSet": [
            "org.hibernate.sql.Template#renderWhereStringTemplate"
        ],
        "classNameBeforeSet": [
            "org.hibernate.sql.Template"
        ],
        "classSignatureBeforeSet": [
            "public final class Template "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.sql;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.query.sqm.function.SqmFunctionDescriptor;\nimport org.hibernate.query.sqm.function.SqmFunctionRegistry;\nimport org.hibernate.type.spi.TypeConfiguration;\n\nimport static org.hibernate.internal.util.StringHelper.WHITESPACE;\n\n/**\n * Parses SQL fragments specified in mapping documents.\n *\n * @author Gavin King\n */\npublic final class Template {\n\n\tprivate static final Set<String> KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> BEFORE_TABLE_KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> FUNCTION_KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> LITERAL_PREFIXES = new HashSet<>();\n\tpublic static final String PUNCTUATION = \"=><!+-*/()',|&`\";\n\n\tstatic {\n\t\tKEYWORDS.add(\"and\");\n\t\tKEYWORDS.add(\"or\");\n\t\tKEYWORDS.add(\"not\");\n\t\tKEYWORDS.add(\"like\");\n\t\tKEYWORDS.add(\"escape\");\n\t\tKEYWORDS.add(\"is\");\n\t\tKEYWORDS.add(\"in\");\n\t\tKEYWORDS.add(\"between\");\n\t\tKEYWORDS.add(\"null\");\n\t\tKEYWORDS.add(\"select\");\n\t\tKEYWORDS.add(\"distinct\");\n\t\tKEYWORDS.add(\"from\");\n\t\tKEYWORDS.add(\"join\");\n\t\tKEYWORDS.add(\"inner\");\n\t\tKEYWORDS.add(\"outer\");\n\t\tKEYWORDS.add(\"left\");\n\t\tKEYWORDS.add(\"right\");\n\t\tKEYWORDS.add(\"on\");\n\t\tKEYWORDS.add(\"where\");\n\t\tKEYWORDS.add(\"having\");\n\t\tKEYWORDS.add(\"group\");\n\t\tKEYWORDS.add(\"order\");\n\t\tKEYWORDS.add(\"by\");\n\t\tKEYWORDS.add(\"desc\");\n\t\tKEYWORDS.add(\"asc\");\n\t\tKEYWORDS.add(\"limit\");\n\t\tKEYWORDS.add(\"any\");\n\t\tKEYWORDS.add(\"some\");\n\t\tKEYWORDS.add(\"exists\");\n\t\tKEYWORDS.add(\"all\");\n\t\tKEYWORDS.add(\"union\");\n\t\tKEYWORDS.add(\"minus\");\n\t\tKEYWORDS.add(\"except\");\n\t\tKEYWORDS.add(\"intersect\");\n\t\tKEYWORDS.add(\"partition\");\n\n\t\tBEFORE_TABLE_KEYWORDS.add(\"from\");\n\t\tBEFORE_TABLE_KEYWORDS.add(\"join\");\n\n\t\tFUNCTION_KEYWORDS.add(\"as\");\n\t\tFUNCTION_KEYWORDS.add(\"leading\");\n\t\tFUNCTION_KEYWORDS.add(\"trailing\");\n\t\tFUNCTION_KEYWORDS.add(\"from\");\n\t\tFUNCTION_KEYWORDS.add(\"case\");\n\t\tFUNCTION_KEYWORDS.add(\"when\");\n\t\tFUNCTION_KEYWORDS.add(\"then\");\n\t\tFUNCTION_KEYWORDS.add(\"else\");\n\t\tFUNCTION_KEYWORDS.add(\"end\");\n\n\t\tLITERAL_PREFIXES.add(\"n\");\n\t\tLITERAL_PREFIXES.add(\"x\");\n\t\tLITERAL_PREFIXES.add(\"varbyte\");\n\t\tLITERAL_PREFIXES.add(\"bx\");\n\t\tLITERAL_PREFIXES.add(\"bytea\");\n\t\tLITERAL_PREFIXES.add(\"date\");\n\t\tLITERAL_PREFIXES.add(\"time\");\n\t\tLITERAL_PREFIXES.add(\"timestamp\");\n\t}\n\n\tpublic static final String TEMPLATE = \"$PlaceHolder$\";\n\n\tprivate Template() {}\n\n\tpublic static String renderTransformerReadFragment(\n\t\t\tString fragment,\n\t\t\tString... columnNames) {\n\t\t// NOTE : would need access to SessionFactoryImplementor to make this configurable\n\t\tfor ( String columnName : columnNames ) {\n\t\t\tfragment = fragment.replace( columnName, TEMPLATE + '.' + columnName );\n\t\t}\n\t\treturn fragment;\n\t}\n\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn renderWhereStringTemplate( sqlWhereString, TEMPLATE, dialect, typeConfiguration, functionRegistry );\n\t}\n\n\t/**\n\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n\t * named parameters.\n\t *\n\t * @param sqlWhereString The string into which to interpolate the placeholder value\n\t * @param placeholder The value to be interpolated into the sqlWhereString\n\t * @param dialect The dialect to apply\n\t * @param functionRegistry The registry of all sql functions\n\t * @return The rendered sql fragment\n\t */\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\n\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n\t\t//\t\tidentifier references.\n\n\t\tString symbols = PUNCTUATION +\n\t\t\t\tWHITESPACE +\n\t\t\t\tdialect.openQuote() +\n\t\t\t\tdialect.closeQuote();\n\t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n\t\tStringBuilder result = new StringBuilder();\n\n\t\tboolean quoted = false;\n\t\tboolean quotedIdentifier = false;\n\t\tboolean beforeTable = false;\n\t\tboolean inFromClause = false;\n\t\tboolean afterFromTable = false;\n\n\t\tboolean hasMore = tokens.hasMoreTokens();\n\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n\t\twhile ( hasMore ) {\n\t\t\tString token = nextToken;\n\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\tboolean isQuoteCharacter = false;\n\n\t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n\t\t\t\tquoted = !quoted;\n\t\t\t\tisQuoteCharacter = true;\n\t\t\t}\n\n\t\t\tif ( !quoted ) {\n\t\t\t\tboolean isOpenQuote;\n\t\t\t\tif ( \"`\".equals(token) ) {\n\t\t\t\t\tisOpenQuote = !quotedIdentifier;\n\t\t\t\t\ttoken = lcToken = isOpenQuote\n\t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n\t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n\t\t\t\t\tquotedIdentifier = isOpenQuote;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( !quotedIdentifier && ( dialect.openQuote()==token.charAt(0) ) ) {\n\t\t\t\t\tisOpenQuote = true;\n\t\t\t\t\tquotedIdentifier = true;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( quotedIdentifier && ( dialect.closeQuote()==token.charAt(0) ) ) {\n\t\t\t\t\tquotedIdentifier = false;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\telse if ( LITERAL_PREFIXES.contains( lcToken ) ) {\n\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n\t\t\t\t\t\t// Don't prefix a literal\n\t\t\t\t\t\tresult.append( token );\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) ) {\n\t\t\t\t\t\tfinal StringBuilder additionalTokens = new StringBuilder();\n\t\t\t\t\t\tTimeZoneTokens possibleNextToken = null;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tpossibleNextToken = possibleNextToken == null\n\t\t\t\t\t\t\t\t\t? TimeZoneTokens.getPossibleNextTokens( lcToken )\n\t\t\t\t\t\t\t\t\t: possibleNextToken.nextToken();\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tadditionalTokens.append( nextToken );\n\t\t\t\t\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\t\t\t\t\tnextToken = tokens.nextToken();\n\t\t\t\t\t\t\t} while ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) );\n\t\t\t\t\t\t} while ( nextToken != null && possibleNextToken.isToken( nextToken ) );\n\t\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n\t\t\t\t\t\t\t// Don't prefix a literal\n\t\t\t\t\t\t\tresult.append( token );\n\t\t\t\t\t\t\tresult.append( additionalTokens );\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\n\t\t\t\tif ( isOpenQuote ) {\n\t\t\t\t\tresult.append( placeholder ).append( '.' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Special processing for ANSI SQL EXTRACT function\n\t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n\t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n\t\t\t\tfinal String source = renderWhereStringTemplate(\n\t\t\t\t\t\textractUntil( tokens, \")\" ),\n\t\t\t\t\t\tplaceholder,\n\t\t\t\t\t\tdialect,\n\t\t\t\t\t\ttypeConfiguration,\n\t\t\t\t\t\tfunctionRegistry\n\t\t\t\t);\n\t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Special processing for ANSI SQL TRIM function\n\t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n\t\t\t\tList<String> operands = new ArrayList<>();\n\t\t\t\tStringBuilder builder = new StringBuilder();\n\n\t\t\t\tboolean hasMoreOperands = true;\n\t\t\t\tString operandToken = tokens.nextToken();\n\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\tcase \"leading\":\n\t\t\t\t\tcase \"trailing\":\n\t\t\t\t\tcase \"both\":\n\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n\t\t\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tboolean quotedOperand = false;\n\t\t\t\tint parenthesis = 0;\n\t\t\t\twhile ( hasMoreOperands ) {\n\t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n\t\t\t\t\tif ( isQuote ) {\n\t\t\t\t\t\tquotedOperand = !quotedOperand;\n\t\t\t\t\t\tif ( !quotedOperand ) {\n\t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbuilder.append( '\\'' );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if ( quotedOperand ) {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( parenthesis != 0 ) {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t\tswitch ( operandToken ) {\n\t\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"from\":\n\t\t\t\t\t\t\t\tif ( builder.length() != 0 ) {\n\t\t\t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n\t\t\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n\t\t\t\t}\n\t\t\t\tif ( builder.length() != 0 ) {\n\t\t\t\t\toperands.add( builder.toString() );\n\t\t\t\t}\n\n\t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n\t\t\t\tresult.append( \"trim(\" );\n\t\t\t\tif ( trimOperands.trimSpec != null ) {\n\t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n\t\t\t\t}\n\t\t\t\tif ( trimOperands.trimChar != null ) {\n\t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n\t\t\t\t\t\tresult.append( trimOperands.trimChar );\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresult.append(\n\t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tresult.append( ' ' );\n\t\t\t\t}\n\t\t\t\tif ( trimOperands.from != null ) {\n\t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n\t\t\t\t}\n\t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n\t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char is specified\n\t\t\t\t\tresult.append( \"from \" );\n\t\t\t\t}\n\n\t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, typeConfiguration, functionRegistry ) )\n\t\t\t\t\t\t.append( ')' );\n\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tboolean quotedOrWhitespace = quoted || quotedIdentifier || isQuoteCharacter\n\t\t\t\t\t|| Character.isWhitespace( token.charAt(0) );\n\n\t\t\tif ( quotedOrWhitespace ) {\n\t\t\t\tresult.append( token );\n\t\t\t}\n\t\t\telse if ( beforeTable ) {\n\t\t\t\tresult.append( token );\n\t\t\t\tbeforeTable = false;\n\t\t\t\tafterFromTable = true;\n\t\t\t}\n\t\t\telse if ( afterFromTable ) {\n\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n\t\t\t\t\tafterFromTable = false;\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isNamedParameter(token) ) {\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isIdentifier(token)\n\t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect, typeConfiguration, functionRegistry) ) {\n\t\t\t\tresult.append(placeholder)\n\t\t\t\t\t\t.append('.')\n\t\t\t\t\t\t.append( dialect.quote(token) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t\tinFromClause = true;\n\t\t\t\t}\n\t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t}\n\t\t\t\tif ( isBoolean( token ) ) {\n\t\t\t\t\ttoken = dialect.toBooleanValueString( Boolean.parseBoolean( token ) );\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\n\t\t\t//Yuck:\n\t\t\tif ( inFromClause\n\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n\t\t\t\tinFromClause = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result.toString();\n\t}\n\n\tprivate enum TimeZoneTokens {\n\t\tNONE,\n\t\tWITH,\n\t\tTIME,\n\t\tZONE;\n\n\t\tstatic TimeZoneTokens getPossibleNextTokens(String lctoken) {\n\t\t\tswitch ( lctoken ) {\n\t\t\t\tcase \"time\":\n\t\t\t\tcase \"timestamp\":\n\t\t\t\t\treturn WITH;\n\t\t\t\tdefault:\n\t\t\t\t\treturn NONE;\n\t\t\t}\n\t\t}\n\n\t\tpublic TimeZoneTokens nextToken() {\n\t\t\tif ( this == WITH ) {\n\t\t\t\treturn TIME;\n\t\t\t}\n\t\t\telse if ( this == TIME ) {\n\t\t\t\treturn ZONE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn NONE;\n\t\t\t}\n\t\t}\n\n\t\tpublic boolean isToken(String token) {\n\t\t\treturn this != NONE && name().equalsIgnoreCase( token );\n\t\t}\n\t}\n\n\tpublic static List<String> collectColumnNames(\n\t\t\tString sql,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn collectColumnNames( renderWhereStringTemplate( sql, dialect, typeConfiguration, functionRegistry ) );\n\t}\n\n\tpublic static List<String> collectColumnNames(String template) {\n\t\tfinal List<String> names = new ArrayList<>();\n\t\tint begin = 0;\n\t\tint match;\n\t\twhile ( ( match = template.indexOf(TEMPLATE, begin) ) >= 0 ) {\n\t\t\tint start = match + TEMPLATE.length() + 1;\n\t\t\tfor ( int loc = start;; loc++ ) {\n\t\t\t\tif ( loc == template.length() - 1 ) {\n\t\t\t\t\tnames.add( template.substring( start ) );\n\t\t\t\t\tbegin = template.length();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar ch = template.charAt( loc );\n\t\t\t\t\tif ( PUNCTUATION.indexOf(ch) >= 0 || WHITESPACE.indexOf(ch) >= 0 ) {\n\t\t\t\t\t\tnames.add( template.substring( start, loc ) );\n\t\t\t\t\t\tbegin = loc;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn names;\n\t}\n\n//\t/**\n//\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n//\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n//\t * named parameters.\n//\t *\n//\t * @param sqlWhereString The string into which to interpolate the placeholder value\n//\t * @param placeholder The value to be interpolated into the sqlWhereString\n//\t * @param dialect The dialect to apply\n//\t * @param functionRegistry The registry of all sql functions\n//\t *\n//\t * @return The rendered sql fragment\n//\t */\n//\tpublic static String renderWhereStringTemplate(\n//\t\t\tString sqlWhereString,\n//\t\t\tString placeholder,\n//\t\t\tDialect dialect,\n//\t\t\tSQLFunctionRegistry functionRegistry) {\n//\n//\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n//\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n//\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n//\t\t//\t\tidentifier references.\n//\n//\t\tfinal String dialectOpenQuote = Character.toString( dialect.openQuote() );\n//\t\tfinal String dialectCloseQuote = Character.toString( dialect.closeQuote() );\n//\n//\t\tString symbols = new StringBuilder()\n//\t\t\t\t.append( \"=><!+-*/()',|&`\" )\n//\t\t\t\t.append( StringHelper.WHITESPACE )\n//\t\t\t\t.append( dialect.openQuote() )\n//\t\t\t\t.append( dialect.closeQuote() )\n//\t\t\t\t.toString();\n//\t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n//\t\tProcessingState state = new ProcessingState();\n//\n//\t\tStringBuilder quotedBuffer = new StringBuilder();\n//\t\tStringBuilder result = new StringBuilder();\n//\n//\t\tboolean hasMore = tokens.hasMoreTokens();\n//\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n//\t\twhile ( hasMore ) {\n//\t\t\tString token = nextToken;\n//\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n//\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t// First, determine quoting which might be based on either:\n//\t\t\t// \t\t1) back-tick\n//\t\t\t// \t\t2) single quote (ANSI SQL standard)\n//\t\t\t// \t\t3) or dialect defined quote character(s)\n//\t\t\tQuotingCharacterDisposition quotingCharacterDisposition = QuotingCharacterDisposition.NONE;\n//\t\t\tif ( \"`\".equals( token ) ) {\n//\t\t\t\tstate.quoted = !state.quoted;\n//\t\t\t\tquotingCharacterDisposition = state.quoted\n//\t\t\t\t\t\t? QuotingCharacterDisposition.OPEN\n//\t\t\t\t\t\t: QuotingCharacterDisposition.CLOSE;\n//\t\t\t\t// replace token with the appropriate dialect quoting char\n//\t\t\t\ttoken = lcToken = ( quotingCharacterDisposition == QuotingCharacterDisposition.OPEN )\n//\t\t\t\t\t\t? dialectOpenQuote\n//\t\t\t\t\t\t: dialectCloseQuote;\n//\t\t\t}\n//\t\t\telse if ( \"'\".equals( token ) ) {\n//\t\t\t\tstate.quoted = !state.quoted;\n//\t\t\t\tquotingCharacterDisposition = state.quoted\n//\t\t\t\t\t\t? QuotingCharacterDisposition.OPEN\n//\t\t\t\t\t\t: QuotingCharacterDisposition.CLOSE;\n//\t\t\t}\n//\t\t\telse if ( !state.quoted && dialectOpenQuote.equals( token ) ) {\n//\t\t\t\tstate.quoted = true;\n//\t\t\t\tquotingCharacterDisposition = QuotingCharacterDisposition.OPEN;\n//\t\t\t}\n//\t\t\telse if ( state.quoted && dialectCloseQuote.equals( token ) ) {\n//\t\t\t\tstate.quoted = false;\n//\t\t\t\tquotingCharacterDisposition = QuotingCharacterDisposition.CLOSE;\n//\t\t\t}\n//\n//\t\t\tif ( state.quoted ) {\n//\t\t\t\tquotedBuffer.append( token );\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// if we were previously processing quoted state and just encountered the close quote, then handle that\n//\t\t\t// quoted text\n//\t\t\tif ( quotingCharacterDisposition == QuotingCharacterDisposition.CLOSE ) {\n//\t\t\t\ttoken = quotedBuffer.toString();\n//\t\t\t\tquotedBuffer.setLength( 0 );\n//\t\t\t\tresult.append( placeholder ).append( '.' )\n//\t\t\t\t\t\t.append( dialectOpenQuote ).append( token ).append( dialectCloseQuote );\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// Special processing for ANSI SQL EXTRACT function\n//\t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n//\t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n//\t\t\t\tfinal String source = renderWhereStringTemplate(\n//\t\t\t\t\t\textractUntil( tokens, \")\" ),\n//\t\t\t\t\t\tplaceholder,\n//\t\t\t\t\t\tdialect,\n//\t\t\t\t\t\tfunctionRegistry\n//\t\t\t\t);\n//\t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n//\n//\t\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// Special processing for ANSI SQL TRIM function\n//\t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n//\t\t\t\tList<String> operands = new ArrayList<String>();\n//\t\t\t\tStringBuilder builder = new StringBuilder();\n//\n//\t\t\t\tboolean hasMoreOperands = true;\n//\t\t\t\tString operandToken = tokens.nextToken();\n//\t\t\t\tboolean quoted = false;\n//\t\t\t\twhile ( hasMoreOperands ) {\n//\t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n//\t\t\t\t\tif ( isQuote ) {\n//\t\t\t\t\t\tquoted = !quoted;\n//\t\t\t\t\t\tif ( !quoted ) {\n//\t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n//\t\t\t\t\t\t\tbuilder.setLength( 0 );\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse {\n//\t\t\t\t\t\t\tbuilder.append( '\\'' );\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t\telse if ( quoted ) {\n//\t\t\t\t\t\tbuilder.append( operandToken );\n//\t\t\t\t\t}\n//\t\t\t\t\telse if ( operandToken.length() == 1 && Character.isWhitespace( operandToken.charAt( 0 ) ) ) {\n//\t\t\t\t\t\t// do nothing\n//\t\t\t\t\t}\n//\t\t\t\t\telse {\n//\t\t\t\t\t\toperands.add( operandToken );\n//\t\t\t\t\t}\n//\t\t\t\t\toperandToken = tokens.nextToken();\n//\t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ! \")\".equals( operandToken );\n//\t\t\t\t}\n//\n//\t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n//\t\t\t\tresult.append( \"trim(\" );\n//\t\t\t\tif ( trimOperands.trimSpec != null ) {\n//\t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n//\t\t\t\t}\n//\t\t\t\tif ( trimOperands.trimChar != null ) {\n//\t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n//\t\t\t\t\t\tresult.append( trimOperands.trimChar );\n//\t\t\t\t\t}\n//\t\t\t\t\telse {\n//\t\t\t\t\t\tresult.append(\n//\t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, functionRegistry )\n//\t\t\t\t\t\t);\n//\t\t\t\t\t}\n//\t\t\t\t\tresult.append( ' ' );\n//\t\t\t\t}\n//\t\t\t\tif ( trimOperands.from != null ) {\n//\t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n//\t\t\t\t}\n//\t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n//\t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char are specified\n//\t\t\t\t\tresult.append( \"from \" );\n//\t\t\t\t}\n//\n//\t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, functionRegistry ) )\n//\t\t\t\t\t\t.append( ')' );\n//\n//\t\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\n//\t\t\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\n//\t\t\tif ( Character.isWhitespace( token.charAt( 0 ) ) ) {\n//\t\t\t\tresult.append( token );\n//\t\t\t}\n//\t\t\telse if ( state.beforeTable ) {\n//\t\t\t\tresult.append( token );\n//\t\t\t\tstate.beforeTable = false;\n//\t\t\t\tstate.afterFromTable = true;\n//\t\t\t}\n//\t\t\telse if ( state.afterFromTable ) {\n//\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n//\t\t\t\t\tstate.afterFromTable = false;\n//\t\t\t\t}\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\t\t\telse if ( isNamedParameter(token) ) {\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\t\t\telse if ( isIdentifier(token, dialect)\n//\t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect , functionRegistry) ) {\n//\t\t\t\tresult.append(placeholder)\n//\t\t\t\t\t\t.append('.')\n//\t\t\t\t\t\t.append( dialect.quote(token) );\n//\t\t\t}\n//\t\t\telse {\n//\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n//\t\t\t\t\tstate.beforeTable = true;\n//\t\t\t\t\tstate.inFromClause = true;\n//\t\t\t\t}\n//\t\t\t\telse if ( state.inFromClause && \",\".equals(lcToken) ) {\n//\t\t\t\t\tstate.beforeTable = true;\n//\t\t\t\t}\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\n//\t\t\t//Yuck:\n//\t\t\tif ( state.inFromClause\n//\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n//\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n//\t\t\t\tstate.inFromClause = false;\n//\t\t\t}\n//\t\t}\n//\n//\t\treturn result.toString();\n//\t}\n//\n//\tprivate static class ProcessingState {\n//\t\tboolean quoted = false;\n//\t\tboolean quotedIdentifier = false;\n//\t\tboolean beforeTable = false;\n//\t\tboolean inFromClause = false;\n//\t\tboolean afterFromTable = false;\n//\t}\n//\n//\tprivate static enum QuotingCharacterDisposition { NONE, OPEN, CLOSE }\n\n\tprivate static class TrimOperands {\n\t\tprivate final String trimSpec;\n\t\tprivate final String trimChar;\n\t\tprivate final String from;\n\t\tprivate final String trimSource;\n\n\t\tprivate TrimOperands(List<String> operands) {\n\t\t\tfinal int size = operands.size();\n\t\t\tif ( size == 1 ) {\n\t\t\t\ttrimSpec = null;\n\t\t\t\ttrimChar = null;\n\t\t\t\tfrom = null;\n\t\t\t\ttrimSource = operands.get(0);\n\t\t\t}\n\t\t\telse if ( size == 4 ) {\n\t\t\t\ttrimSpec = operands.get(0);\n\t\t\t\ttrimChar = operands.get(1);\n\t\t\t\tfrom = operands.get(2);\n\t\t\t\ttrimSource = operands.get(3);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( size < 1 || size > 4 ) {\n\t\t\t\t\tthrow new HibernateException( \"Unexpected number of trim function operands : \" + size );\n\t\t\t\t}\n\n\t\t\t\t// trim-source will always be the last operand\n\t\t\t\ttrimSource = operands.get( size - 1 );\n\n\t\t\t\t// ANSI SQL says that more than one operand means that the FROM is required\n\t\t\t\tif ( ! \"from\".equals( operands.get( size - 2 ) ) ) {\n\t\t\t\t\tthrow new HibernateException( \"Expecting FROM, found : \" + operands.get( size - 2 ) );\n\t\t\t\t}\n\t\t\t\tfrom = operands.get( size - 2 );\n\n\t\t\t\t// trim-spec, if there is one will always be the first operand\n\t\t\t\tif ( \"leading\".equalsIgnoreCase( operands.get(0) )\n\t\t\t\t\t\t|| \"trailing\".equalsIgnoreCase( operands.get(0) )\n\t\t\t\t\t\t|| \"both\".equalsIgnoreCase( operands.get(0) ) ) {\n\t\t\t\t\ttrimSpec = operands.get(0);\n\t\t\t\t\ttrimChar = null;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttrimSpec = null;\n\t\t\t\t\tif ( size - 2 == 0 ) {\n\t\t\t\t\t\ttrimChar = null;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttrimChar = operands.get( 0 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static String extractUntil(StringTokenizer tokens, String delimiter) {\n\t\tStringBuilder valueBuilder = new StringBuilder();\n\t\tString token = tokens.nextToken();\n\t\twhile ( ! delimiter.equalsIgnoreCase( token ) ) {\n\t\t\tvalueBuilder.append( token );\n\t\t\ttoken = tokens.nextToken();\n\t\t}\n\t\treturn valueBuilder.toString().trim();\n\t}\n\n\tprivate static boolean isNamedParameter(String token) {\n\t\treturn token.startsWith( \":\" );\n\t}\n\n\tprivate static boolean isFunctionOrKeyword(\n\t\t\tString lcToken,\n\t\t\tString nextToken,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn \"(\".equals( nextToken ) ||\n\t\t\t\tKEYWORDS.contains( lcToken ) ||\n\t\t\t\tisType( lcToken, typeConfiguration ) ||\n\t\t\t\tisFunction( lcToken, nextToken, functionRegistry ) ||\n\t\t\t\tdialect.getKeywords().contains( lcToken ) ||\n\t\t\t\tFUNCTION_KEYWORDS.contains( lcToken );\n\t}\n\n\tprivate static boolean isType(String lcToken, TypeConfiguration typeConfiguration) {\n\t\treturn typeConfiguration.getDdlTypeRegistry().isTypeNameRegistered( lcToken );\n\t}\n\n\tprivate static boolean isFunction(String lcToken, String nextToken, SqmFunctionRegistry functionRegistry) {\n\t\t// checking for \"(\" is currently redundant because it is checked before getting here;\n\t\t// doing the check anyhow, in case that earlier check goes away;\n\t\tif ( \"(\".equals( nextToken ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tfinal SqmFunctionDescriptor function = functionRegistry.findFunctionDescriptor( lcToken );\n\t\treturn function != null;\n\t}\n\n\tprivate static boolean isIdentifier(String token) {\n\t\tif ( isBoolean( token ) ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn token.charAt( 0 ) == '`' || ( //allow any identifier quoted with backtick\n\t\t\t\tCharacter.isLetter( token.charAt( 0 ) ) && //only recognizes identifiers beginning with a letter\n\t\t\t\t\t\ttoken.indexOf( '.' ) < 0\n\t\t);\n\t}\n\n\tprivate static boolean isBoolean(String token) {\n\t\treturn \"true\".equals( token ) || \"false\".equals( token );\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.sql;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.query.sqm.function.SqmFunctionDescriptor;\nimport org.hibernate.query.sqm.function.SqmFunctionRegistry;\nimport org.hibernate.type.spi.TypeConfiguration;\n\nimport static java.lang.Boolean.parseBoolean;\nimport static java.lang.Character.isLetter;\nimport static org.hibernate.internal.util.StringHelper.WHITESPACE;\n\n/**\n * Parses SQL fragments specified in mapping documents.\n *\n * @author Gavin King\n */\npublic final class Template {\n\n\tprivate static final Set<String> KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> BEFORE_TABLE_KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> FUNCTION_KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> LITERAL_PREFIXES = new HashSet<>();\n\tpublic static final String PUNCTUATION = \"=><!+-*/()',|&`\";\n\n\tstatic {\n\t\tKEYWORDS.add(\"and\");\n\t\tKEYWORDS.add(\"or\");\n\t\tKEYWORDS.add(\"not\");\n\t\tKEYWORDS.add(\"like\");\n\t\tKEYWORDS.add(\"escape\");\n\t\tKEYWORDS.add(\"is\");\n\t\tKEYWORDS.add(\"in\");\n\t\tKEYWORDS.add(\"between\");\n\t\tKEYWORDS.add(\"null\");\n\t\tKEYWORDS.add(\"select\");\n\t\tKEYWORDS.add(\"distinct\");\n\t\tKEYWORDS.add(\"from\");\n\t\tKEYWORDS.add(\"join\");\n\t\tKEYWORDS.add(\"inner\");\n\t\tKEYWORDS.add(\"outer\");\n\t\tKEYWORDS.add(\"left\");\n\t\tKEYWORDS.add(\"right\");\n\t\tKEYWORDS.add(\"on\");\n\t\tKEYWORDS.add(\"where\");\n\t\tKEYWORDS.add(\"having\");\n\t\tKEYWORDS.add(\"group\");\n\t\tKEYWORDS.add(\"order\");\n\t\tKEYWORDS.add(\"by\");\n\t\tKEYWORDS.add(\"desc\");\n\t\tKEYWORDS.add(\"asc\");\n\t\tKEYWORDS.add(\"limit\");\n\t\tKEYWORDS.add(\"any\");\n\t\tKEYWORDS.add(\"some\");\n\t\tKEYWORDS.add(\"exists\");\n\t\tKEYWORDS.add(\"all\");\n\t\tKEYWORDS.add(\"union\");\n\t\tKEYWORDS.add(\"minus\");\n\t\tKEYWORDS.add(\"except\");\n\t\tKEYWORDS.add(\"intersect\");\n\t\tKEYWORDS.add(\"partition\");\n\n\t\tBEFORE_TABLE_KEYWORDS.add(\"from\");\n\t\tBEFORE_TABLE_KEYWORDS.add(\"join\");\n\n\t\tFUNCTION_KEYWORDS.add(\"as\");\n\t\tFUNCTION_KEYWORDS.add(\"leading\");\n\t\tFUNCTION_KEYWORDS.add(\"trailing\");\n\t\tFUNCTION_KEYWORDS.add(\"from\");\n\t\tFUNCTION_KEYWORDS.add(\"case\");\n\t\tFUNCTION_KEYWORDS.add(\"when\");\n\t\tFUNCTION_KEYWORDS.add(\"then\");\n\t\tFUNCTION_KEYWORDS.add(\"else\");\n\t\tFUNCTION_KEYWORDS.add(\"end\");\n\n\t\tLITERAL_PREFIXES.add(\"n\");\n\t\tLITERAL_PREFIXES.add(\"x\");\n\t\tLITERAL_PREFIXES.add(\"varbyte\");\n\t\tLITERAL_PREFIXES.add(\"bx\");\n\t\tLITERAL_PREFIXES.add(\"bytea\");\n\t\tLITERAL_PREFIXES.add(\"date\");\n\t\tLITERAL_PREFIXES.add(\"time\");\n\t\tLITERAL_PREFIXES.add(\"timestamp\");\n\t\tLITERAL_PREFIXES.add(\"zone\");\n\t}\n\n\tpublic static final String TEMPLATE = \"$PlaceHolder$\";\n\n\tprivate Template() {}\n\n\tpublic static String renderTransformerReadFragment(\n\t\t\tString fragment,\n\t\t\tString... columnNames) {\n\t\t// NOTE : would need access to SessionFactoryImplementor to make this configurable\n\t\tfor ( String columnName : columnNames ) {\n\t\t\tfragment = fragment.replace( columnName, TEMPLATE + '.' + columnName );\n\t\t}\n\t\treturn fragment;\n\t}\n\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn renderWhereStringTemplate( sqlWhereString, TEMPLATE, dialect, typeConfiguration, functionRegistry );\n\t}\n\n\t/**\n\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n\t * named parameters.\n\t *\n\t * @param sqlWhereString The string into which to interpolate the placeholder value\n\t * @param placeholder The value to be interpolated into the sqlWhereString\n\t * @param dialect The dialect to apply\n\t * @param functionRegistry The registry of all sql functions\n\t * @return The rendered sql fragment\n\t */\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\n\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n\t\t//\t\tidentifier references.\n\n\t\tfinal String symbols = PUNCTUATION + WHITESPACE + dialect.openQuote() + dialect.closeQuote();\n\t\tfinal StringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n\t\tfinal StringBuilder result = new StringBuilder();\n\n\t\tboolean quoted = false;\n\t\tboolean quotedIdentifier = false;\n\t\tboolean beforeTable = false;\n\t\tboolean inFromClause = false;\n\t\tboolean afterFromTable = false;\n\n\t\tboolean hasMore = tokens.hasMoreTokens();\n\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n\t\twhile ( hasMore ) {\n\t\t\tString token = nextToken;\n\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\tboolean isQuoteCharacter = false;\n\n\t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n\t\t\t\tquoted = !quoted;\n\t\t\t\tisQuoteCharacter = true;\n\t\t\t}\n\n\t\t\tif ( !quoted ) {\n\t\t\t\tfinal boolean isOpenQuote;\n\t\t\t\tif ( \"`\".equals(token) ) {\n\t\t\t\t\tisOpenQuote = !quotedIdentifier;\n\t\t\t\t\ttoken = lcToken = isOpenQuote\n\t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n\t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n\t\t\t\t\tquotedIdentifier = isOpenQuote;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( !quotedIdentifier && dialect.openQuote()==token.charAt(0) ) {\n\t\t\t\t\tisOpenQuote = true;\n\t\t\t\t\tquotedIdentifier = true;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( quotedIdentifier && dialect.closeQuote()==token.charAt(0) ) {\n\t\t\t\t\tquotedIdentifier = false;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\tif ( isOpenQuote ) {\n\t\t\t\t\tresult.append( placeholder ).append( '.' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinal boolean quotedOrWhitespace =\n\t\t\t\t\tquoted || quotedIdentifier || isQuoteCharacter\n\t\t\t\t\t\t\t|| token.isBlank();\n\t\t\tif ( quotedOrWhitespace ) {\n\t\t\t\tresult.append( token );\n\t\t\t}\n\t\t\telse if ( beforeTable ) {\n\t\t\t\tresult.append( token );\n\t\t\t\tbeforeTable = false;\n\t\t\t\tafterFromTable = true;\n\t\t\t}\n\t\t\telse if ( afterFromTable ) {\n\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n\t\t\t\t\tafterFromTable = false;\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isNamedParameter(token) ) {\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isExtractFunction( lcToken, nextToken ) ) {\n\t\t\t\t// Special processing for ANSI SQL EXTRACT function\n\t\t\t\thandleExtractFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\t\t\t}\n\t\t\telse if ( isTrimFunction( lcToken, nextToken ) ) {\n\t\t\t\t// Special processing for ANSI SQL TRIM function\n\t\t\t\thandleTrimFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\t\t\t}\n\t\t\telse if ( isIdentifier(token)\n\t\t\t\t\t&& !isFunctionOrKeyword( lcToken, nextToken, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t\t&& !isLiteral( lcToken, nextToken, sqlWhereString, symbols, tokens ) ) {\n\t\t\t\tresult.append(placeholder)\n\t\t\t\t\t\t.append('.')\n\t\t\t\t\t\t.append( dialect.quote(token) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t\tinFromClause = true;\n\t\t\t\t}\n\t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t}\n\t\t\t\tif ( isBoolean( token ) ) {\n\t\t\t\t\ttoken = dialect.toBooleanValueString( parseBoolean( token ) );\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\n\t\t\t//Yuck:\n\t\t\tif ( inFromClause\n\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n\t\t\t\tinFromClause = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result.toString();\n\t}\n\n\tprivate static boolean isTrimFunction(String lcToken, String nextToken) {\n\t\treturn \"trim\".equals(lcToken) && \"(\".equals(nextToken);\n\t}\n\n\tprivate static boolean isExtractFunction(String lcToken, String nextToken) {\n\t\treturn \"extract\".equals(lcToken) && \"(\".equals(nextToken);\n\t}\n\n\tprivate static boolean isLiteral(\n\t\t\tString lcToken, String next,\n\t\t\tString sqlWhereString, String symbols, StringTokenizer tokens) {\n\t\tif ( LITERAL_PREFIXES.contains( lcToken ) && next != null ) {\n\t\t\t// easy cases first\n\t\t\tif ( \"'\".equals(next) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if ( !next.isBlank() ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// we need to look ahead in the token stream\n\t\t\t\t// to find the first non-blank token\n\t\t\t\tfinal StringTokenizer lookahead =\n\t\t\t\t\t\tnew StringTokenizer( sqlWhereString, symbols, true );\n\t\t\t\twhile ( lookahead.countTokens() > tokens.countTokens()+1 ) {\n\t\t\t\t\tlookahead.nextToken();\n\t\t\t\t}\n\t\t\t\tif ( lookahead.hasMoreTokens() ) {\n\t\t\t\t\tString nextToken;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tnextToken = lookahead.nextToken().toLowerCase(Locale.ROOT);\n\t\t\t\t\t}\n\t\t\t\t\twhile ( nextToken.isBlank() && lookahead.hasMoreTokens() );\n\t\t\t\t\treturn \"'\".equals( nextToken )\n\t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"with\".equals( nextToken )\n\t\t\t\t\t\t|| lcToken.equals( \"timestamp\" ) && \"with\".equals( nextToken )\n\t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"zone\".equals( nextToken );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate static void handleTrimFunction(\n\t\t\tString placeholder, Dialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry,\n\t\t\tStringTokenizer tokens,\n\t\t\tStringBuilder result) {\n\t\tfinal List<String> operands = new ArrayList<>();\n\t\tfinal StringBuilder builder = new StringBuilder();\n\n\t\tboolean hasMoreOperands = true;\n\t\tString operandToken = tokens.nextToken();\n\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\tcase \"leading\":\n\t\t\tcase \"trailing\":\n\t\t\tcase \"both\":\n\t\t\t\toperands.add( operandToken );\n\t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tboolean quotedOperand = false;\n\t\tint parenthesis = 0;\n\t\twhile ( hasMoreOperands ) {\n\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n\t\t\tif ( isQuote ) {\n\t\t\t\tquotedOperand = !quotedOperand;\n\t\t\t\tif ( !quotedOperand ) {\n\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuilder.append( '\\'' );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( quotedOperand ) {\n\t\t\t\tbuilder.append( operandToken );\n\t\t\t}\n\t\t\telse if ( parenthesis != 0 ) {\n\t\t\t\tbuilder.append( operandToken );\n\t\t\t\tswitch ( operandToken ) {\n\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \")\":\n\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbuilder.append( operandToken );\n\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \")\":\n\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"from\":\n\t\t\t\t\t\tif ( !builder.isEmpty() ) {\n\t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\toperandToken = tokens.nextToken();\n\t\t\thasMoreOperands = tokens.hasMoreTokens()\n\t\t\t\t\t&& ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n\t\t}\n\t\tif ( !builder.isEmpty() ) {\n\t\t\toperands.add( builder.toString() );\n\t\t}\n\n\t\tfinal TrimOperands trimOperands = new TrimOperands( operands );\n\t\tresult.append( \"trim(\" );\n\t\tif ( trimOperands.trimSpec != null ) {\n\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n\t\t}\n\t\tif ( trimOperands.trimChar != null ) {\n\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n\t\t\t\tresult.append( trimOperands.trimChar );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult.append(\n\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t);\n\t\t\t}\n\t\t\tresult.append( ' ' );\n\t\t}\n\t\tif ( trimOperands.from != null ) {\n\t\t\tresult.append( trimOperands.from ).append( ' ' );\n\t\t}\n\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char is specified\n\t\t\tresult.append( \"from \" );\n\t\t}\n\n\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, typeConfiguration, functionRegistry ) )\n\t\t\t\t.append( ')' );\n\t}\n\n\tprivate static void handleExtractFunction(\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry,\n\t\t\tStringTokenizer tokens,\n\t\t\tStringBuilder result) {\n\t\tfinal String field = extractUntil( tokens, \"from\" );\n\t\tfinal String source = renderWhereStringTemplate(\n\t\t\t\textractUntil( tokens, \")\" ),\n\t\t\t\tplaceholder,\n\t\t\t\tdialect,\n\t\t\t\ttypeConfiguration,\n\t\t\t\tfunctionRegistry\n\t\t);\n\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n\t}\n\n\tpublic static List<String> collectColumnNames(\n\t\t\tString sql,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn collectColumnNames( renderWhereStringTemplate( sql, dialect, typeConfiguration, functionRegistry ) );\n\t}\n\n\tpublic static List<String> collectColumnNames(String template) {\n\t\tfinal List<String> names = new ArrayList<>();\n\t\tint begin = 0;\n\t\tint match;\n\t\twhile ( ( match = template.indexOf(TEMPLATE, begin) ) >= 0 ) {\n\t\t\tint start = match + TEMPLATE.length() + 1;\n\t\t\tfor ( int loc = start;; loc++ ) {\n\t\t\t\tif ( loc == template.length() - 1 ) {\n\t\t\t\t\tnames.add( template.substring( start ) );\n\t\t\t\t\tbegin = template.length();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar ch = template.charAt( loc );\n\t\t\t\t\tif ( PUNCTUATION.indexOf(ch) >= 0 || WHITESPACE.indexOf(ch) >= 0 ) {\n\t\t\t\t\t\tnames.add( template.substring( start, loc ) );\n\t\t\t\t\t\tbegin = loc;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn names;\n\t}\n\n//\t/**\n//\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n//\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n//\t * named parameters.\n//\t *\n//\t * @param sqlWhereString The string into which to interpolate the placeholder value\n//\t * @param placeholder The value to be interpolated into the sqlWhereString\n//\t * @param dialect The dialect to apply\n//\t * @param functionRegistry The registry of all sql functions\n//\t *\n//\t * @return The rendered sql fragment\n//\t */\n//\tpublic static String renderWhereStringTemplate(\n//\t\t\tString sqlWhereString,\n//\t\t\tString placeholder,\n//\t\t\tDialect dialect,\n//\t\t\tSQLFunctionRegistry functionRegistry) {\n//\n//\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n//\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n//\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n//\t\t//\t\tidentifier references.\n//\n//\t\tfinal String dialectOpenQuote = Character.toString( dialect.openQuote() );\n//\t\tfinal String dialectCloseQuote = Character.toString( dialect.closeQuote() );\n//\n//\t\tString symbols = new StringBuilder()\n//\t\t\t\t.append( \"=><!+-*/()',|&`\" )\n//\t\t\t\t.append( StringHelper.WHITESPACE )\n//\t\t\t\t.append( dialect.openQuote() )\n//\t\t\t\t.append( dialect.closeQuote() )\n//\t\t\t\t.toString();\n//\t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n//\t\tProcessingState state = new ProcessingState();\n//\n//\t\tStringBuilder quotedBuffer = new StringBuilder();\n//\t\tStringBuilder result = new StringBuilder();\n//\n//\t\tboolean hasMore = tokens.hasMoreTokens();\n//\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n//\t\twhile ( hasMore ) {\n//\t\t\tString token = nextToken;\n//\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n//\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t// First, determine quoting which might be based on either:\n//\t\t\t// \t\t1) back-tick\n//\t\t\t// \t\t2) single quote (ANSI SQL standard)\n//\t\t\t// \t\t3) or dialect defined quote character(s)\n//\t\t\tQuotingCharacterDisposition quotingCharacterDisposition = QuotingCharacterDisposition.NONE;\n//\t\t\tif ( \"`\".equals( token ) ) {\n//\t\t\t\tstate.quoted = !state.quoted;\n//\t\t\t\tquotingCharacterDisposition = state.quoted\n//\t\t\t\t\t\t? QuotingCharacterDisposition.OPEN\n//\t\t\t\t\t\t: QuotingCharacterDisposition.CLOSE;\n//\t\t\t\t// replace token with the appropriate dialect quoting char\n//\t\t\t\ttoken = lcToken = ( quotingCharacterDisposition == QuotingCharacterDisposition.OPEN )\n//\t\t\t\t\t\t? dialectOpenQuote\n//\t\t\t\t\t\t: dialectCloseQuote;\n//\t\t\t}\n//\t\t\telse if ( \"'\".equals( token ) ) {\n//\t\t\t\tstate.quoted = !state.quoted;\n//\t\t\t\tquotingCharacterDisposition = state.quoted\n//\t\t\t\t\t\t? QuotingCharacterDisposition.OPEN\n//\t\t\t\t\t\t: QuotingCharacterDisposition.CLOSE;\n//\t\t\t}\n//\t\t\telse if ( !state.quoted && dialectOpenQuote.equals( token ) ) {\n//\t\t\t\tstate.quoted = true;\n//\t\t\t\tquotingCharacterDisposition = QuotingCharacterDisposition.OPEN;\n//\t\t\t}\n//\t\t\telse if ( state.quoted && dialectCloseQuote.equals( token ) ) {\n//\t\t\t\tstate.quoted = false;\n//\t\t\t\tquotingCharacterDisposition = QuotingCharacterDisposition.CLOSE;\n//\t\t\t}\n//\n//\t\t\tif ( state.quoted ) {\n//\t\t\t\tquotedBuffer.append( token );\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// if we were previously processing quoted state and just encountered the close quote, then handle that\n//\t\t\t// quoted text\n//\t\t\tif ( quotingCharacterDisposition == QuotingCharacterDisposition.CLOSE ) {\n//\t\t\t\ttoken = quotedBuffer.toString();\n//\t\t\t\tquotedBuffer.setLength( 0 );\n//\t\t\t\tresult.append( placeholder ).append( '.' )\n//\t\t\t\t\t\t.append( dialectOpenQuote ).append( token ).append( dialectCloseQuote );\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// Special processing for ANSI SQL EXTRACT function\n//\t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n//\t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n//\t\t\t\tfinal String source = renderWhereStringTemplate(\n//\t\t\t\t\t\textractUntil( tokens, \")\" ),\n//\t\t\t\t\t\tplaceholder,\n//\t\t\t\t\t\tdialect,\n//\t\t\t\t\t\tfunctionRegistry\n//\t\t\t\t);\n//\t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n//\n//\t\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// Special processing for ANSI SQL TRIM function\n//\t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n//\t\t\t\tList<String> operands = new ArrayList<String>();\n//\t\t\t\tStringBuilder builder = new StringBuilder();\n//\n//\t\t\t\tboolean hasMoreOperands = true;\n//\t\t\t\tString operandToken = tokens.nextToken();\n//\t\t\t\tboolean quoted = false;\n//\t\t\t\twhile ( hasMoreOperands ) {\n//\t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n//\t\t\t\t\tif ( isQuote ) {\n//\t\t\t\t\t\tquoted = !quoted;\n//\t\t\t\t\t\tif ( !quoted ) {\n//\t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n//\t\t\t\t\t\t\tbuilder.setLength( 0 );\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse {\n//\t\t\t\t\t\t\tbuilder.append( '\\'' );\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t\telse if ( quoted ) {\n//\t\t\t\t\t\tbuilder.append( operandToken );\n//\t\t\t\t\t}\n//\t\t\t\t\telse if ( operandToken.length() == 1 && Character.isWhitespace( operandToken.charAt( 0 ) ) ) {\n//\t\t\t\t\t\t// do nothing\n//\t\t\t\t\t}\n//\t\t\t\t\telse {\n//\t\t\t\t\t\toperands.add( operandToken );\n//\t\t\t\t\t}\n//\t\t\t\t\toperandToken = tokens.nextToken();\n//\t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ! \")\".equals( operandToken );\n//\t\t\t\t}\n//\n//\t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n//\t\t\t\tresult.append( \"trim(\" );\n//\t\t\t\tif ( trimOperands.trimSpec != null ) {\n//\t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n//\t\t\t\t}\n//\t\t\t\tif ( trimOperands.trimChar != null ) {\n//\t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n//\t\t\t\t\t\tresult.append( trimOperands.trimChar );\n//\t\t\t\t\t}\n//\t\t\t\t\telse {\n//\t\t\t\t\t\tresult.append(\n//\t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, functionRegistry )\n//\t\t\t\t\t\t);\n//\t\t\t\t\t}\n//\t\t\t\t\tresult.append( ' ' );\n//\t\t\t\t}\n//\t\t\t\tif ( trimOperands.from != null ) {\n//\t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n//\t\t\t\t}\n//\t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n//\t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char are specified\n//\t\t\t\t\tresult.append( \"from \" );\n//\t\t\t\t}\n//\n//\t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, functionRegistry ) )\n//\t\t\t\t\t\t.append( ')' );\n//\n//\t\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\n//\t\t\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\n//\t\t\tif ( Character.isWhitespace( token.charAt( 0 ) ) ) {\n//\t\t\t\tresult.append( token );\n//\t\t\t}\n//\t\t\telse if ( state.beforeTable ) {\n//\t\t\t\tresult.append( token );\n//\t\t\t\tstate.beforeTable = false;\n//\t\t\t\tstate.afterFromTable = true;\n//\t\t\t}\n//\t\t\telse if ( state.afterFromTable ) {\n//\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n//\t\t\t\t\tstate.afterFromTable = false;\n//\t\t\t\t}\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\t\t\telse if ( isNamedParameter(token) ) {\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\t\t\telse if ( isIdentifier(token, dialect)\n//\t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect , functionRegistry) ) {\n//\t\t\t\tresult.append(placeholder)\n//\t\t\t\t\t\t.append('.')\n//\t\t\t\t\t\t.append( dialect.quote(token) );\n//\t\t\t}\n//\t\t\telse {\n//\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n//\t\t\t\t\tstate.beforeTable = true;\n//\t\t\t\t\tstate.inFromClause = true;\n//\t\t\t\t}\n//\t\t\t\telse if ( state.inFromClause && \",\".equals(lcToken) ) {\n//\t\t\t\t\tstate.beforeTable = true;\n//\t\t\t\t}\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\n//\t\t\t//Yuck:\n//\t\t\tif ( state.inFromClause\n//\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n//\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n//\t\t\t\tstate.inFromClause = false;\n//\t\t\t}\n//\t\t}\n//\n//\t\treturn result.toString();\n//\t}\n//\n//\tprivate static class ProcessingState {\n//\t\tboolean quoted = false;\n//\t\tboolean quotedIdentifier = false;\n//\t\tboolean beforeTable = false;\n//\t\tboolean inFromClause = false;\n//\t\tboolean afterFromTable = false;\n//\t}\n//\n//\tprivate static enum QuotingCharacterDisposition { NONE, OPEN, CLOSE }\n\n\tprivate static class TrimOperands {\n\t\tprivate final String trimSpec;\n\t\tprivate final String trimChar;\n\t\tprivate final String from;\n\t\tprivate final String trimSource;\n\n\t\tprivate TrimOperands(List<String> operands) {\n\t\t\tfinal int size = operands.size();\n\t\t\tif ( size == 1 ) {\n\t\t\t\ttrimSpec = null;\n\t\t\t\ttrimChar = null;\n\t\t\t\tfrom = null;\n\t\t\t\ttrimSource = operands.get(0);\n\t\t\t}\n\t\t\telse if ( size == 4 ) {\n\t\t\t\ttrimSpec = operands.get(0);\n\t\t\t\ttrimChar = operands.get(1);\n\t\t\t\tfrom = operands.get(2);\n\t\t\t\ttrimSource = operands.get(3);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( size < 1 || size > 4 ) {\n\t\t\t\t\tthrow new HibernateException( \"Unexpected number of trim function operands : \" + size );\n\t\t\t\t}\n\n\t\t\t\t// trim-source will always be the last operand\n\t\t\t\ttrimSource = operands.get( size - 1 );\n\n\t\t\t\t// ANSI SQL says that more than one operand means that the FROM is required\n\t\t\t\tif ( ! \"from\".equals( operands.get( size - 2 ) ) ) {\n\t\t\t\t\tthrow new HibernateException( \"Expecting FROM, found : \" + operands.get( size - 2 ) );\n\t\t\t\t}\n\t\t\t\tfrom = operands.get( size - 2 );\n\n\t\t\t\t// trim-spec, if there is one will always be the first operand\n\t\t\t\tif ( \"leading\".equalsIgnoreCase( operands.get(0) )\n\t\t\t\t\t\t|| \"trailing\".equalsIgnoreCase( operands.get(0) )\n\t\t\t\t\t\t|| \"both\".equalsIgnoreCase( operands.get(0) ) ) {\n\t\t\t\t\ttrimSpec = operands.get(0);\n\t\t\t\t\ttrimChar = null;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttrimSpec = null;\n\t\t\t\t\tif ( size - 2 == 0 ) {\n\t\t\t\t\t\ttrimChar = null;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttrimChar = operands.get( 0 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static String extractUntil(StringTokenizer tokens, String delimiter) {\n\t\tfinal StringBuilder valueBuilder = new StringBuilder();\n\t\tString token = tokens.nextToken();\n\t\twhile ( ! delimiter.equalsIgnoreCase( token ) ) {\n\t\t\tvalueBuilder.append( token );\n\t\t\ttoken = tokens.nextToken();\n\t\t}\n\t\treturn valueBuilder.toString().trim();\n\t}\n\n\tprivate static boolean isNamedParameter(String token) {\n\t\treturn token.startsWith( \":\" );\n\t}\n\n\tprivate static boolean isFunctionOrKeyword(\n\t\t\tString lcToken,\n\t\t\tString nextToken,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\tif ( \"(\".equals( nextToken ) ) {\n\t\t\treturn true;\n\t\t}\n\t\telse if ( \"date\".equals( lcToken ) || \"time\".equals( lcToken ) ) {\n\t\t\t// these can be column names on some databases\n\t\t\t// TODO: treat 'current date' as a function\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\treturn KEYWORDS.contains( lcToken )\n\t\t\t\t|| isType( lcToken, typeConfiguration )\n\t\t\t\t|| isFunction( lcToken, nextToken, functionRegistry )\n\t\t\t\t|| dialect.getKeywords().contains( lcToken )\n\t\t\t\t|| FUNCTION_KEYWORDS.contains( lcToken );\n\t\t}\n\t}\n\n\tprivate static boolean isType(String lcToken, TypeConfiguration typeConfiguration) {\n\t\treturn typeConfiguration.getDdlTypeRegistry().isTypeNameRegistered( lcToken );\n\t}\n\n\tprivate static boolean isFunction(String lcToken, String nextToken, SqmFunctionRegistry functionRegistry) {\n\t\t// checking for \"(\" is currently redundant because it is checked before getting here;\n\t\t// doing the check anyhow, in case that earlier check goes away;\n\t\tif ( \"(\".equals( nextToken ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tfinal SqmFunctionDescriptor function = functionRegistry.findFunctionDescriptor( lcToken );\n\t\treturn function != null;\n\t}\n\n\tprivate static boolean isIdentifier(String token) {\n\t\tif ( isBoolean( token ) ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn token.charAt( 0 ) == '`'\n\t\t\t|| ( //allow any identifier quoted with backtick\n\t\t\t\tisLetter( token.charAt( 0 ) ) && //only recognizes identifiers beginning with a letter\n\t\t\t\t\t\ttoken.indexOf( '.' ) < 0\n\t\t\t);\n\t}\n\n\tprivate static boolean isBoolean(String token) {\n\t\treturn \"true\".equals( token ) || \"false\".equals( token );\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private static void handleExtractFunction(\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry,\n\t\t\tStringTokenizer tokens,\n\t\t\tStringBuilder result) {\n\t\tfinal String field = extractUntil( tokens, \"from\" );\n\t\tfinal String source = renderWhereStringTemplate(\n\t\t\t\textractUntil( tokens, \")\" ),\n\t\t\t\tplaceholder,\n\t\t\t\tdialect,\n\t\t\t\ttypeConfiguration,\n\t\t\t\tfunctionRegistry\n\t\t);\n\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.sql.Template#extractUntil\n methodBody: private static String extractUntil(StringTokenizer tokens, String delimiter) {\nStringBuilder valueBuilder=new StringBuilder();\nString token=tokens.nextToken();\nwhile(!delimiter.equalsIgnoreCase(token)){valueBuilder.append(token);\ntoken=tokens.nextToken();\n}return valueBuilder.toString().trim();\n}",
            "methodSignature: org.hibernate.sql.Template#renderWhereStringTemplate\n methodBody: public static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\nString symbols=PUNCTUATION + WHITESPACE + dialect.openQuote() + dialect.closeQuote();\nStringTokenizer tokens=new StringTokenizer(sqlWhereString,symbols,true);\nStringBuilder result=new StringBuilder();\nboolean quoted=false;\nboolean quotedIdentifier=false;\nboolean beforeTable=false;\nboolean inFromClause=false;\nboolean afterFromTable=false;\nboolean hasMore=tokens.hasMoreTokens();\nString nextToken=hasMore ? tokens.nextToken() : null;\nwhile(hasMore){String token=nextToken;\nString lcToken=token.toLowerCase(Locale.ROOT);\nhasMore=tokens.hasMoreTokens();\nnextToken=hasMore ? tokens.nextToken() : null;\nboolean isQuoteCharacter=false;\nif(!quotedIdentifier && \"'\".equals(token)){quoted=!quoted;\nisQuoteCharacter=true;\n}if(!quoted){boolean isOpenQuote;\nif(\"`\".equals(token)){isOpenQuote=!quotedIdentifier;\ntoken=lcToken=isOpenQuote ? Character.toString(dialect.openQuote()) : Character.toString(dialect.closeQuote());\nquotedIdentifier=isOpenQuote;\nisQuoteCharacter=true;\n}if(!quotedIdentifier && (dialect.openQuote() == token.charAt(0))){isOpenQuote=true;\nquotedIdentifier=true;\nisQuoteCharacter=true;\n}if(quotedIdentifier && (dialect.closeQuote() == token.charAt(0))){quotedIdentifier=false;\nisQuoteCharacter=true;\nisOpenQuote=false;\n}if(LITERAL_PREFIXES.contains(lcToken)){if(\"'\".equals(nextToken)){result.append(token);\ncontinue;\n}if(nextToken != null && Character.isWhitespace(nextToken.charAt(0))){final StringBuilder additionalTokens=new StringBuilder();\nTimeZoneTokens possibleNextToken=null;\ndo(nextToken != null && possibleNextToken.isToken(nextToken)){possibleNextToken=possibleNextToken == null ? TimeZoneTokens.getPossibleNextTokens(lcToken) : possibleNextToken.nextToken();\ndo(nextToken != null && Character.isWhitespace(nextToken.charAt(0))){additionalTokens.append(nextToken);\nhasMore=tokens.hasMoreTokens();\nnextToken=tokens.nextToken();\n}}if(\"'\".equals(nextToken)){result.append(token);\nresult.append(additionalTokens);\ncontinue;\n}{isOpenQuote=false;\n}}{isOpenQuote=false;\n}}{isOpenQuote=false;\n}if(isOpenQuote){result.append(placeholder).append('.');\n}}if(\"extract\".equals(lcToken) && \"(\".equals(nextToken)){final String field=extractUntil(tokens,\"from\");\nfinal String source=renderWhereStringTemplate(extractUntil(tokens,\")\"),placeholder,dialect,typeConfiguration,functionRegistry);\nresult.append(\"extract(\").append(field).append(\" from \").append(source).append(')');\nhasMore=tokens.hasMoreTokens();\nnextToken=hasMore ? tokens.nextToken() : null;\ncontinue;\n}if(\"trim\".equals(lcToken) && \"(\".equals(nextToken)){List<String> operands=new ArrayList<>();\nStringBuilder builder=new StringBuilder();\nboolean hasMoreOperands=true;\nString operandToken=tokens.nextToken();\nswitch(operandToken.toLowerCase(Locale.ROOT))case \"leading\":case \"trailing\":case \"both\":operands.add(operandToken);\nif(hasMoreOperands=tokens.hasMoreTokens()){operandToken=tokens.nextToken();\n}break;\nboolean quotedOperand=false;\nint parenthesis=0;\nwhile(hasMoreOperands){final boolean isQuote=\"'\".equals(operandToken);\nif(isQuote){quotedOperand=!quotedOperand;\nif(!quotedOperand){operands.add(builder.append('\\'').toString());\nbuilder.setLength(0);\n}{builder.append('\\'');\n}}if(quotedOperand){builder.append(operandToken);\n}if(parenthesis != 0){builder.append(operandToken);\nswitch(operandToken)case \"(\":parenthesis++;\nbreak;\ncase \")\":parenthesis--;\nbreak;\n}{builder.append(operandToken);\nswitch(operandToken.toLowerCase(Locale.ROOT))case \"(\":parenthesis++;\nbreak;\ncase \")\":parenthesis--;\nbreak;\ncase \"from\":if(builder.length() != 0){operands.add(builder.substring(0,builder.length() - 4));\nbuilder.setLength(0);\noperands.add(operandToken);\n}break;\n}operandToken=tokens.nextToken();\nhasMoreOperands=tokens.hasMoreTokens() && (parenthesis != 0 || !\")\".equals(operandToken));\n}if(builder.length() != 0){operands.add(builder.toString());\n}TrimOperands trimOperands=new TrimOperands(operands);\nresult.append(\"trim(\");\nif(trimOperands.trimSpec != null){result.append(trimOperands.trimSpec).append(' ');\n}if(trimOperands.trimChar != null){if(trimOperands.trimChar.startsWith(\"'\") && trimOperands.trimChar.endsWith(\"'\")){result.append(trimOperands.trimChar);\n}{result.append(renderWhereStringTemplate(trimOperands.trimSpec,placeholder,dialect,typeConfiguration,functionRegistry));\n}result.append(' ');\n}if(trimOperands.from != null){result.append(trimOperands.from).append(' ');\n}if(trimOperands.trimSpec != null || trimOperands.trimChar != null){result.append(\"from \");\n}result.append(renderWhereStringTemplate(trimOperands.trimSource,placeholder,dialect,typeConfiguration,functionRegistry)).append(')');\nhasMore=tokens.hasMoreTokens();\nnextToken=hasMore ? tokens.nextToken() : null;\ncontinue;\n}boolean quotedOrWhitespace=quoted || quotedIdentifier || isQuoteCharacter || Character.isWhitespace(token.charAt(0));\nif(quotedOrWhitespace){result.append(token);\n}if(beforeTable){result.append(token);\nbeforeTable=false;\nafterFromTable=true;\n}if(afterFromTable){if(!\"as\".equals(lcToken)){afterFromTable=false;\n}result.append(token);\n}if(isNamedParameter(token)){result.append(token);\n}if(isIdentifier(token) && !isFunctionOrKeyword(lcToken,nextToken,dialect,typeConfiguration,functionRegistry)){result.append(placeholder).append('.').append(dialect.quote(token));\n}{if(BEFORE_TABLE_KEYWORDS.contains(lcToken)){beforeTable=true;\ninFromClause=true;\n}if(inFromClause && \",\".equals(lcToken)){beforeTable=true;\n}if(isBoolean(token)){token=dialect.toBooleanValueString(Boolean.parseBoolean(token));\n}result.append(token);\n}if(inFromClause && KEYWORDS.contains(lcToken) && !BEFORE_TABLE_KEYWORDS.contains(lcToken)){inFromClause=false;\n}}return result.toString();\n}",
            "methodSignature: org.hibernate.sql.Template.TimeZoneTokens#isToken\n methodBody: public boolean isToken(String token) {\nreturn this != NONE && name().equalsIgnoreCase(token);\n}",
            "methodSignature: org.hibernate.sql.Template#isBoolean\n methodBody: private static boolean isBoolean(String token) {\nreturn \"true\".equals(token) || \"false\".equals(token);\n}",
            "methodSignature: org.hibernate.sql.Template.TimeZoneTokens#nextToken\n methodBody: public TimeZoneTokens nextToken() {\nif(this == WITH){return TIME;\n}if(this == TIME){return ZONE;\n}{return NONE;\n}}",
            "methodSignature: org.hibernate.sql.Template.TimeZoneTokens#getPossibleNextTokens\n methodBody: static TimeZoneTokens getPossibleNextTokens(String lctoken) {\nswitch(lctoken)case \"time\":case \"timestamp\":return WITH;\ndefault:return NONE;\n}",
            "methodSignature: org.hibernate.sql.Template#isIdentifier\n methodBody: private static boolean isIdentifier(String token) {\nif(isBoolean(token)){return false;\n}return token.charAt(0) == '`' || (Character.isLetter(token.charAt(0)) && token.indexOf('.') < 0);\n}",
            "methodSignature: org.hibernate.sql.Template#isNamedParameter\n methodBody: private static boolean isNamedParameter(String token) {\nreturn token.startsWith(\":\");\n}",
            "methodSignature: org.hibernate.sql.Template#isFunctionOrKeyword\n methodBody: private static boolean isFunctionOrKeyword(\n\t\t\tString lcToken,\n\t\t\tString nextToken,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\nreturn \"(\".equals(nextToken) || KEYWORDS.contains(lcToken) || isType(lcToken,typeConfiguration) || isFunction(lcToken,nextToken,functionRegistry) || dialect.getKeywords().contains(lcToken) || FUNCTION_KEYWORDS.contains(lcToken);\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n\t * named parameters.\n\t *\n\t * @param sqlWhereString The string into which to interpolate the placeholder value\n\t * @param placeholder The value to be interpolated into the sqlWhereString\n\t * @param dialect The dialect to apply\n\t * @param functionRegistry The registry of all sql functions\n\t * @return The rendered sql fragment\n\t */\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\n\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n\t\t//\t\tidentifier references.\n\n\t\tfinal String symbols = PUNCTUATION + WHITESPACE + dialect.openQuote() + dialect.closeQuote();\n\t\tfinal StringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n\t\tfinal StringBuilder result = new StringBuilder();\n\n\t\tboolean quoted = false;\n\t\tboolean quotedIdentifier = false;\n\t\tboolean beforeTable = false;\n\t\tboolean inFromClause = false;\n\t\tboolean afterFromTable = false;\n\n\t\tboolean hasMore = tokens.hasMoreTokens();\n\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n\t\twhile ( hasMore ) {\n\t\t\tString token = nextToken;\n\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\tboolean isQuoteCharacter = false;\n\n\t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n\t\t\t\tquoted = !quoted;\n\t\t\t\tisQuoteCharacter = true;\n\t\t\t}\n\n\t\t\tif ( !quoted ) {\n\t\t\t\tfinal boolean isOpenQuote;\n\t\t\t\tif ( \"`\".equals(token) ) {\n\t\t\t\t\tisOpenQuote = !quotedIdentifier;\n\t\t\t\t\ttoken = lcToken = isOpenQuote\n\t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n\t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n\t\t\t\t\tquotedIdentifier = isOpenQuote;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( !quotedIdentifier && dialect.openQuote()==token.charAt(0) ) {\n\t\t\t\t\tisOpenQuote = true;\n\t\t\t\t\tquotedIdentifier = true;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( quotedIdentifier && dialect.closeQuote()==token.charAt(0) ) {\n\t\t\t\t\tquotedIdentifier = false;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\tif ( isOpenQuote ) {\n\t\t\t\t\tresult.append( placeholder ).append( '.' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinal boolean quotedOrWhitespace =\n\t\t\t\t\tquoted || quotedIdentifier || isQuoteCharacter\n\t\t\t\t\t\t\t|| token.isBlank();\n\t\t\tif ( quotedOrWhitespace ) {\n\t\t\t\tresult.append( token );\n\t\t\t}\n\t\t\telse if ( beforeTable ) {\n\t\t\t\tresult.append( token );\n\t\t\t\tbeforeTable = false;\n\t\t\t\tafterFromTable = true;\n\t\t\t}\n\t\t\telse if ( afterFromTable ) {\n\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n\t\t\t\t\tafterFromTable = false;\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isNamedParameter(token) ) {\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isExtractFunction( lcToken, nextToken ) ) {\n\t\t\t\t// Special processing for ANSI SQL EXTRACT function\n\t\t\t\thandleExtractFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\t\t\t}\n\t\t\telse if ( isTrimFunction( lcToken, nextToken ) ) {\n\t\t\t\t// Special processing for ANSI SQL TRIM function\n\t\t\t\thandleTrimFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\t\t\t}\n\t\t\telse if ( isIdentifier(token)\n\t\t\t\t\t&& !isFunctionOrKeyword( lcToken, nextToken, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t\t&& !isLiteral( lcToken, nextToken, sqlWhereString, symbols, tokens ) ) {\n\t\t\t\tresult.append(placeholder)\n\t\t\t\t\t\t.append('.')\n\t\t\t\t\t\t.append( dialect.quote(token) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t\tinFromClause = true;\n\t\t\t\t}\n\t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t}\n\t\t\t\tif ( isBoolean( token ) ) {\n\t\t\t\t\ttoken = dialect.toBooleanValueString( parseBoolean( token ) );\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\n\t\t\t//Yuck:\n\t\t\tif ( inFromClause\n\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n\t\t\t\tinFromClause = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result.toString();\n\t}\nprivate static void handleExtractFunction(\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry,\n\t\t\tStringTokenizer tokens,\n\t\t\tStringBuilder result) {\n\t\tfinal String field = extractUntil( tokens, \"from\" );\n\t\tfinal String source = renderWhereStringTemplate(\n\t\t\t\textractUntil( tokens, \")\" ),\n\t\t\t\tplaceholder,\n\t\t\t\tdialect,\n\t\t\t\ttypeConfiguration,\n\t\t\t\tfunctionRegistry\n\t\t);\n\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n\t}",
        "diffSourceCode": "-  119: \t/**\n-  120: \t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n-  121: \t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n-  122: \t * named parameters.\n-  123: \t *\n-  124: \t * @param sqlWhereString The string into which to interpolate the placeholder value\n-  125: \t * @param placeholder The value to be interpolated into the sqlWhereString\n-  126: \t * @param dialect The dialect to apply\n-  127: \t * @param functionRegistry The registry of all sql functions\n-  128: \t * @return The rendered sql fragment\n-  129: \t */\n-  130: \tpublic static String renderWhereStringTemplate(\n-  131: \t\t\tString sqlWhereString,\n-  132: \t\t\tString placeholder,\n-  133: \t\t\tDialect dialect,\n-  134: \t\t\tTypeConfiguration typeConfiguration,\n-  135: \t\t\tSqmFunctionRegistry functionRegistry) {\n-  136: \n-  137: \t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n-  138: \t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n-  139: \t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n-  140: \t\t//\t\tidentifier references.\n-  141: \n-  142: \t\tString symbols = PUNCTUATION +\n-  143: \t\t\t\tWHITESPACE +\n-  144: \t\t\t\tdialect.openQuote() +\n-  145: \t\t\t\tdialect.closeQuote();\n-  146: \t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n-  147: \t\tStringBuilder result = new StringBuilder();\n+  119: \t\treturn renderWhereStringTemplate( sqlWhereString, TEMPLATE, dialect, typeConfiguration, functionRegistry );\n+  120: \t}\n+  121: \n+  122: \t/**\n+  123: \t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n+  124: \t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n+  125: \t * named parameters.\n+  126: \t *\n+  127: \t * @param sqlWhereString The string into which to interpolate the placeholder value\n+  128: \t * @param placeholder The value to be interpolated into the sqlWhereString\n+  129: \t * @param dialect The dialect to apply\n+  130: \t * @param functionRegistry The registry of all sql functions\n+  131: \t * @return The rendered sql fragment\n+  132: \t */\n+  133: \tpublic static String renderWhereStringTemplate(\n+  134: \t\t\tString sqlWhereString,\n+  135: \t\t\tString placeholder,\n+  136: \t\t\tDialect dialect,\n+  137: \t\t\tTypeConfiguration typeConfiguration,\n+  138: \t\t\tSqmFunctionRegistry functionRegistry) {\n+  139: \n+  140: \t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n+  141: \t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n+  142: \t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n+  143: \t\t//\t\tidentifier references.\n+  144: \n+  145: \t\tfinal String symbols = PUNCTUATION + WHITESPACE + dialect.openQuote() + dialect.closeQuote();\n+  146: \t\tfinal StringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n+  147: \t\tfinal StringBuilder result = new StringBuilder();\n   148: \n   149: \t\tboolean quoted = false;\n   150: \t\tboolean quotedIdentifier = false;\n   151: \t\tboolean beforeTable = false;\n   152: \t\tboolean inFromClause = false;\n   153: \t\tboolean afterFromTable = false;\n   154: \n   155: \t\tboolean hasMore = tokens.hasMoreTokens();\n   156: \t\tString nextToken = hasMore ? tokens.nextToken() : null;\n   157: \t\twhile ( hasMore ) {\n   158: \t\t\tString token = nextToken;\n   159: \t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n   160: \t\t\thasMore = tokens.hasMoreTokens();\n   161: \t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n   162: \n   163: \t\t\tboolean isQuoteCharacter = false;\n   164: \n   165: \t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n   166: \t\t\t\tquoted = !quoted;\n   167: \t\t\t\tisQuoteCharacter = true;\n   168: \t\t\t}\n   169: \n   170: \t\t\tif ( !quoted ) {\n-  171: \t\t\t\tboolean isOpenQuote;\n+  171: \t\t\t\tfinal boolean isOpenQuote;\n   172: \t\t\t\tif ( \"`\".equals(token) ) {\n   173: \t\t\t\t\tisOpenQuote = !quotedIdentifier;\n   174: \t\t\t\t\ttoken = lcToken = isOpenQuote\n   175: \t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n   176: \t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n   177: \t\t\t\t\tquotedIdentifier = isOpenQuote;\n   178: \t\t\t\t\tisQuoteCharacter = true;\n   179: \t\t\t\t}\n-  180: \t\t\t\telse if ( !quotedIdentifier && ( dialect.openQuote()==token.charAt(0) ) ) {\n+  180: \t\t\t\telse if ( !quotedIdentifier && dialect.openQuote()==token.charAt(0) ) {\n   181: \t\t\t\t\tisOpenQuote = true;\n   182: \t\t\t\t\tquotedIdentifier = true;\n   183: \t\t\t\t\tisQuoteCharacter = true;\n   184: \t\t\t\t}\n-  185: \t\t\t\telse if ( quotedIdentifier && ( dialect.closeQuote()==token.charAt(0) ) ) {\n+  185: \t\t\t\telse if ( quotedIdentifier && dialect.closeQuote()==token.charAt(0) ) {\n   186: \t\t\t\t\tquotedIdentifier = false;\n   187: \t\t\t\t\tisQuoteCharacter = true;\n   188: \t\t\t\t\tisOpenQuote = false;\n   189: \t\t\t\t}\n-  190: \t\t\t\telse if ( LITERAL_PREFIXES.contains( lcToken ) ) {\n-  191: \t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n-  192: \t\t\t\t\t\t// Don't prefix a literal\n-  193: \t\t\t\t\t\tresult.append( token );\n-  194: \t\t\t\t\t\tcontinue;\n-  195: \t\t\t\t\t}\n-  196: \t\t\t\t\telse if ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) ) {\n-  197: \t\t\t\t\t\tfinal StringBuilder additionalTokens = new StringBuilder();\n-  198: \t\t\t\t\t\tTimeZoneTokens possibleNextToken = null;\n-  199: \t\t\t\t\t\tdo {\n-  200: \t\t\t\t\t\t\tpossibleNextToken = possibleNextToken == null\n-  201: \t\t\t\t\t\t\t\t\t? TimeZoneTokens.getPossibleNextTokens( lcToken )\n-  202: \t\t\t\t\t\t\t\t\t: possibleNextToken.nextToken();\n-  203: \t\t\t\t\t\t\tdo {\n-  204: \t\t\t\t\t\t\t\tadditionalTokens.append( nextToken );\n-  205: \t\t\t\t\t\t\t\thasMore = tokens.hasMoreTokens();\n-  206: \t\t\t\t\t\t\t\tnextToken = tokens.nextToken();\n-  207: \t\t\t\t\t\t\t} while ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) );\n-  208: \t\t\t\t\t\t} while ( nextToken != null && possibleNextToken.isToken( nextToken ) );\n-  209: \t\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n-  210: \t\t\t\t\t\t\t// Don't prefix a literal\n-  211: \t\t\t\t\t\t\tresult.append( token );\n-  212: \t\t\t\t\t\t\tresult.append( additionalTokens );\n-  213: \t\t\t\t\t\t\tcontinue;\n-  214: \t\t\t\t\t\t}\n-  215: \t\t\t\t\t\telse {\n-  216: \t\t\t\t\t\t\tisOpenQuote = false;\n-  217: \t\t\t\t\t\t}\n-  218: \t\t\t\t\t}\n-  219: \t\t\t\t\telse {\n-  220: \t\t\t\t\t\tisOpenQuote = false;\n-  221: \t\t\t\t\t}\n-  222: \t\t\t\t}\n-  223: \t\t\t\telse {\n-  224: \t\t\t\t\tisOpenQuote = false;\n-  225: \t\t\t\t}\n-  226: \n-  227: \t\t\t\tif ( isOpenQuote ) {\n-  228: \t\t\t\t\tresult.append( placeholder ).append( '.' );\n-  229: \t\t\t\t}\n-  230: \t\t\t}\n-  231: \n-  232: \t\t\t// Special processing for ANSI SQL EXTRACT function\n-  233: \t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n-  234: \t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n-  235: \t\t\t\tfinal String source = renderWhereStringTemplate(\n-  236: \t\t\t\t\t\textractUntil( tokens, \")\" ),\n-  237: \t\t\t\t\t\tplaceholder,\n-  238: \t\t\t\t\t\tdialect,\n-  239: \t\t\t\t\t\ttypeConfiguration,\n-  240: \t\t\t\t\t\tfunctionRegistry\n-  241: \t\t\t\t);\n-  242: \t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n-  243: \n-  244: \t\t\t\thasMore = tokens.hasMoreTokens();\n-  245: \t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n-  246: \n-  247: \t\t\t\tcontinue;\n-  248: \t\t\t}\n-  249: \n-  250: \t\t\t// Special processing for ANSI SQL TRIM function\n-  251: \t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n-  252: \t\t\t\tList<String> operands = new ArrayList<>();\n-  253: \t\t\t\tStringBuilder builder = new StringBuilder();\n-  254: \n-  255: \t\t\t\tboolean hasMoreOperands = true;\n-  256: \t\t\t\tString operandToken = tokens.nextToken();\n-  257: \t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n-  258: \t\t\t\t\tcase \"leading\":\n-  259: \t\t\t\t\tcase \"trailing\":\n-  260: \t\t\t\t\tcase \"both\":\n-  261: \t\t\t\t\t\toperands.add( operandToken );\n-  262: \t\t\t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n-  263: \t\t\t\t\t\t\toperandToken = tokens.nextToken();\n-  264: \t\t\t\t\t\t}\n-  265: \t\t\t\t\t\tbreak;\n-  266: \t\t\t\t}\n-  267: \t\t\t\tboolean quotedOperand = false;\n-  268: \t\t\t\tint parenthesis = 0;\n-  269: \t\t\t\twhile ( hasMoreOperands ) {\n-  270: \t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n-  271: \t\t\t\t\tif ( isQuote ) {\n-  272: \t\t\t\t\t\tquotedOperand = !quotedOperand;\n-  273: \t\t\t\t\t\tif ( !quotedOperand ) {\n-  274: \t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n-  275: \t\t\t\t\t\t\tbuilder.setLength( 0 );\n-  276: \t\t\t\t\t\t}\n-  277: \t\t\t\t\t\telse {\n-  278: \t\t\t\t\t\t\tbuilder.append( '\\'' );\n-  279: \t\t\t\t\t\t}\n-  280: \t\t\t\t\t}\n-  281: \t\t\t\t\telse if ( quotedOperand ) {\n-  282: \t\t\t\t\t\tbuilder.append( operandToken );\n-  283: \t\t\t\t\t}\n-  284: \t\t\t\t\telse if ( parenthesis != 0 ) {\n-  285: \t\t\t\t\t\tbuilder.append( operandToken );\n-  286: \t\t\t\t\t\tswitch ( operandToken ) {\n-  287: \t\t\t\t\t\t\tcase \"(\":\n-  288: \t\t\t\t\t\t\t\tparenthesis++;\n-  289: \t\t\t\t\t\t\t\tbreak;\n-  290: \t\t\t\t\t\t\tcase \")\":\n-  291: \t\t\t\t\t\t\t\tparenthesis--;\n-  292: \t\t\t\t\t\t\t\tbreak;\n-  293: \t\t\t\t\t\t}\n-  294: \t\t\t\t\t}\n-  295: \t\t\t\t\telse {\n-  296: \t\t\t\t\t\tbuilder.append( operandToken );\n-  297: \t\t\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n-  298: \t\t\t\t\t\t\tcase \"(\":\n-  299: \t\t\t\t\t\t\t\tparenthesis++;\n-  300: \t\t\t\t\t\t\t\tbreak;\n-  301: \t\t\t\t\t\t\tcase \")\":\n-  302: \t\t\t\t\t\t\t\tparenthesis--;\n-  303: \t\t\t\t\t\t\t\tbreak;\n-  304: \t\t\t\t\t\t\tcase \"from\":\n-  305: \t\t\t\t\t\t\t\tif ( builder.length() != 0 ) {\n-  306: \t\t\t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n-  307: \t\t\t\t\t\t\t\t\tbuilder.setLength( 0 );\n-  308: \t\t\t\t\t\t\t\t\toperands.add( operandToken );\n-  309: \t\t\t\t\t\t\t\t}\n-  310: \t\t\t\t\t\t\t\tbreak;\n-  311: \t\t\t\t\t\t}\n-  312: \t\t\t\t\t}\n-  313: \t\t\t\t\toperandToken = tokens.nextToken();\n-  314: \t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n-  315: \t\t\t\t}\n-  316: \t\t\t\tif ( builder.length() != 0 ) {\n-  317: \t\t\t\t\toperands.add( builder.toString() );\n-  318: \t\t\t\t}\n-  319: \n-  320: \t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n-  321: \t\t\t\tresult.append( \"trim(\" );\n-  322: \t\t\t\tif ( trimOperands.trimSpec != null ) {\n-  323: \t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n-  324: \t\t\t\t}\n-  325: \t\t\t\tif ( trimOperands.trimChar != null ) {\n-  326: \t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n-  327: \t\t\t\t\t\tresult.append( trimOperands.trimChar );\n-  328: \t\t\t\t\t}\n-  329: \t\t\t\t\telse {\n-  330: \t\t\t\t\t\tresult.append(\n-  331: \t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n-  332: \t\t\t\t\t\t);\n-  333: \t\t\t\t\t}\n-  334: \t\t\t\t\tresult.append( ' ' );\n-  335: \t\t\t\t}\n-  336: \t\t\t\tif ( trimOperands.from != null ) {\n-  337: \t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n-  338: \t\t\t\t}\n-  339: \t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n-  340: \t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char is specified\n-  341: \t\t\t\t\tresult.append( \"from \" );\n-  342: \t\t\t\t}\n-  343: \n-  344: \t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, typeConfiguration, functionRegistry ) )\n-  345: \t\t\t\t\t\t.append( ')' );\n-  346: \n-  347: \t\t\t\thasMore = tokens.hasMoreTokens();\n-  348: \t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n-  349: \n-  350: \t\t\t\tcontinue;\n-  351: \t\t\t}\n-  352: \n-  353: \t\t\tboolean quotedOrWhitespace = quoted || quotedIdentifier || isQuoteCharacter\n-  354: \t\t\t\t\t|| Character.isWhitespace( token.charAt(0) );\n-  355: \n-  356: \t\t\tif ( quotedOrWhitespace ) {\n-  357: \t\t\t\tresult.append( token );\n+  190: \t\t\t\telse {\n+  191: \t\t\t\t\tisOpenQuote = false;\n+  192: \t\t\t\t}\n+  193: \t\t\t\tif ( isOpenQuote ) {\n+  194: \t\t\t\t\tresult.append( placeholder ).append( '.' );\n+  195: \t\t\t\t}\n+  196: \t\t\t}\n+  197: \n+  198: \t\t\tfinal boolean quotedOrWhitespace =\n+  199: \t\t\t\t\tquoted || quotedIdentifier || isQuoteCharacter\n+  200: \t\t\t\t\t\t\t|| token.isBlank();\n+  201: \t\t\tif ( quotedOrWhitespace ) {\n+  202: \t\t\t\tresult.append( token );\n+  203: \t\t\t}\n+  204: \t\t\telse if ( beforeTable ) {\n+  205: \t\t\t\tresult.append( token );\n+  206: \t\t\t\tbeforeTable = false;\n+  207: \t\t\t\tafterFromTable = true;\n+  208: \t\t\t}\n+  209: \t\t\telse if ( afterFromTable ) {\n+  210: \t\t\t\tif ( !\"as\".equals(lcToken) ) {\n+  211: \t\t\t\t\tafterFromTable = false;\n+  212: \t\t\t\t}\n+  213: \t\t\t\tresult.append(token);\n+  214: \t\t\t}\n+  215: \t\t\telse if ( isNamedParameter(token) ) {\n+  216: \t\t\t\tresult.append(token);\n+  217: \t\t\t}\n+  218: \t\t\telse if ( isExtractFunction( lcToken, nextToken ) ) {\n+  219: \t\t\t\t// Special processing for ANSI SQL EXTRACT function\n+  220: \t\t\t\thandleExtractFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n+  221: \t\t\t\thasMore = tokens.hasMoreTokens();\n+  222: \t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n+  223: \t\t\t}\n+  224: \t\t\telse if ( isTrimFunction( lcToken, nextToken ) ) {\n+  225: \t\t\t\t// Special processing for ANSI SQL TRIM function\n+  226: \t\t\t\thandleTrimFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n+  227: \t\t\t\thasMore = tokens.hasMoreTokens();\n+  228: \t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n+  229: \t\t\t}\n+  230: \t\t\telse if ( isIdentifier(token)\n+  231: \t\t\t\t\t&& !isFunctionOrKeyword( lcToken, nextToken, dialect, typeConfiguration, functionRegistry )\n+  232: \t\t\t\t\t&& !isLiteral( lcToken, nextToken, sqlWhereString, symbols, tokens ) ) {\n+  233: \t\t\t\tresult.append(placeholder)\n+  234: \t\t\t\t\t\t.append('.')\n+  235: \t\t\t\t\t\t.append( dialect.quote(token) );\n+  236: \t\t\t}\n+  237: \t\t\telse {\n+  238: \t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n+  239: \t\t\t\t\tbeforeTable = true;\n+  240: \t\t\t\t\tinFromClause = true;\n+  241: \t\t\t\t}\n+  242: \t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n+  243: \t\t\t\t\tbeforeTable = true;\n+  244: \t\t\t\t}\n+  245: \t\t\t\tif ( isBoolean( token ) ) {\n+  246: \t\t\t\t\ttoken = dialect.toBooleanValueString( parseBoolean( token ) );\n+  247: \t\t\t\t}\n+  248: \t\t\t\tresult.append(token);\n+  249: \t\t\t}\n+  250: \n+  251: \t\t\t//Yuck:\n+  252: \t\t\tif ( inFromClause\n+  253: \t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n+  254: \t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n+  255: \t\t\t\tinFromClause = false;\n+  256: \t\t\t}\n+  257: \t\t}\n+  258: \n+  259: \t\treturn result.toString();\n+  260: \t}\n+  261: \n+  262: \tprivate static boolean isTrimFunction(String lcToken, String nextToken) {\n+  263: \t\treturn \"trim\".equals(lcToken) && \"(\".equals(nextToken);\n+  264: \t}\n+  265: \n+  266: \tprivate static boolean isExtractFunction(String lcToken, String nextToken) {\n+  267: \t\treturn \"extract\".equals(lcToken) && \"(\".equals(nextToken);\n+  268: \t}\n+  269: \n+  270: \tprivate static boolean isLiteral(\n+  271: \t\t\tString lcToken, String next,\n+  272: \t\t\tString sqlWhereString, String symbols, StringTokenizer tokens) {\n+  273: \t\tif ( LITERAL_PREFIXES.contains( lcToken ) && next != null ) {\n+  274: \t\t\t// easy cases first\n+  275: \t\t\tif ( \"'\".equals(next) ) {\n+  276: \t\t\t\treturn true;\n+  277: \t\t\t}\n+  278: \t\t\telse if ( !next.isBlank() ) {\n+  279: \t\t\t\treturn false;\n+  280: \t\t\t}\n+  281: \t\t\telse {\n+  282: \t\t\t\t// we need to look ahead in the token stream\n+  283: \t\t\t\t// to find the first non-blank token\n+  284: \t\t\t\tfinal StringTokenizer lookahead =\n+  285: \t\t\t\t\t\tnew StringTokenizer( sqlWhereString, symbols, true );\n+  286: \t\t\t\twhile ( lookahead.countTokens() > tokens.countTokens()+1 ) {\n+  287: \t\t\t\t\tlookahead.nextToken();\n+  288: \t\t\t\t}\n+  289: \t\t\t\tif ( lookahead.hasMoreTokens() ) {\n+  290: \t\t\t\t\tString nextToken;\n+  291: \t\t\t\t\tdo {\n+  292: \t\t\t\t\t\tnextToken = lookahead.nextToken().toLowerCase(Locale.ROOT);\n+  293: \t\t\t\t\t}\n+  294: \t\t\t\t\twhile ( nextToken.isBlank() && lookahead.hasMoreTokens() );\n+  295: \t\t\t\t\treturn \"'\".equals( nextToken )\n+  296: \t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"with\".equals( nextToken )\n+  297: \t\t\t\t\t\t|| lcToken.equals( \"timestamp\" ) && \"with\".equals( nextToken )\n+  298: \t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"zone\".equals( nextToken );\n+  299: \t\t\t\t}\n+  300: \t\t\t\telse {\n+  301: \t\t\t\t\treturn false;\n+  302: \t\t\t\t}\n+  303: \t\t\t}\n+  304: \t\t}\n+  305: \t\telse {\n+  306: \t\t\treturn false;\n+  307: \t\t}\n+  308: \t}\n+  309: \n+  310: \tprivate static void handleTrimFunction(\n+  311: \t\t\tString placeholder, Dialect dialect,\n+  312: \t\t\tTypeConfiguration typeConfiguration,\n+  313: \t\t\tSqmFunctionRegistry functionRegistry,\n+  314: \t\t\tStringTokenizer tokens,\n+  315: \t\t\tStringBuilder result) {\n+  316: \t\tfinal List<String> operands = new ArrayList<>();\n+  317: \t\tfinal StringBuilder builder = new StringBuilder();\n+  318: \n+  319: \t\tboolean hasMoreOperands = true;\n+  320: \t\tString operandToken = tokens.nextToken();\n+  321: \t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n+  322: \t\t\tcase \"leading\":\n+  323: \t\t\tcase \"trailing\":\n+  324: \t\t\tcase \"both\":\n+  325: \t\t\t\toperands.add( operandToken );\n+  326: \t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n+  327: \t\t\t\t\toperandToken = tokens.nextToken();\n+  328: \t\t\t\t}\n+  329: \t\t\t\tbreak;\n+  330: \t\t}\n+  331: \t\tboolean quotedOperand = false;\n+  332: \t\tint parenthesis = 0;\n+  333: \t\twhile ( hasMoreOperands ) {\n+  334: \t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n+  335: \t\t\tif ( isQuote ) {\n+  336: \t\t\t\tquotedOperand = !quotedOperand;\n+  337: \t\t\t\tif ( !quotedOperand ) {\n+  338: \t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n+  339: \t\t\t\t\tbuilder.setLength( 0 );\n+  340: \t\t\t\t}\n+  341: \t\t\t\telse {\n+  342: \t\t\t\t\tbuilder.append( '\\'' );\n+  343: \t\t\t\t}\n+  344: \t\t\t}\n+  345: \t\t\telse if ( quotedOperand ) {\n+  346: \t\t\t\tbuilder.append( operandToken );\n+  347: \t\t\t}\n+  348: \t\t\telse if ( parenthesis != 0 ) {\n+  349: \t\t\t\tbuilder.append( operandToken );\n+  350: \t\t\t\tswitch ( operandToken ) {\n+  351: \t\t\t\t\tcase \"(\":\n+  352: \t\t\t\t\t\tparenthesis++;\n+  353: \t\t\t\t\t\tbreak;\n+  354: \t\t\t\t\tcase \")\":\n+  355: \t\t\t\t\t\tparenthesis--;\n+  356: \t\t\t\t\t\tbreak;\n+  357: \t\t\t\t}\n   358: \t\t\t}\n-  359: \t\t\telse if ( beforeTable ) {\n-  360: \t\t\t\tresult.append( token );\n-  361: \t\t\t\tbeforeTable = false;\n-  362: \t\t\t\tafterFromTable = true;\n-  363: \t\t\t}\n-  364: \t\t\telse if ( afterFromTable ) {\n-  365: \t\t\t\tif ( !\"as\".equals(lcToken) ) {\n-  366: \t\t\t\t\tafterFromTable = false;\n-  367: \t\t\t\t}\n-  368: \t\t\t\tresult.append(token);\n-  369: \t\t\t}\n-  370: \t\t\telse if ( isNamedParameter(token) ) {\n-  371: \t\t\t\tresult.append(token);\n-  372: \t\t\t}\n-  373: \t\t\telse if ( isIdentifier(token)\n-  374: \t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect, typeConfiguration, functionRegistry) ) {\n-  375: \t\t\t\tresult.append(placeholder)\n-  376: \t\t\t\t\t\t.append('.')\n-  377: \t\t\t\t\t\t.append( dialect.quote(token) );\n-  378: \t\t\t}\n-  379: \t\t\telse {\n-  380: \t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n-  381: \t\t\t\t\tbeforeTable = true;\n-  382: \t\t\t\t\tinFromClause = true;\n-  383: \t\t\t\t}\n-  384: \t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n-  385: \t\t\t\t\tbeforeTable = true;\n-  386: \t\t\t\t}\n-  387: \t\t\t\tif ( isBoolean( token ) ) {\n-  388: \t\t\t\t\ttoken = dialect.toBooleanValueString( Boolean.parseBoolean( token ) );\n-  389: \t\t\t\t}\n-  390: \t\t\t\tresult.append(token);\n-  391: \t\t\t}\n-  392: \n-  393: \t\t\t//Yuck:\n-  394: \t\t\tif ( inFromClause\n-  395: \t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n-  396: \t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n-  397: \t\t\t\tinFromClause = false;\n+  359: \t\t\telse {\n+  360: \t\t\t\tbuilder.append( operandToken );\n+  361: \t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n+  362: \t\t\t\t\tcase \"(\":\n+  363: \t\t\t\t\t\tparenthesis++;\n+  364: \t\t\t\t\t\tbreak;\n+  365: \t\t\t\t\tcase \")\":\n+  366: \t\t\t\t\t\tparenthesis--;\n+  367: \t\t\t\t\t\tbreak;\n+  368: \t\t\t\t\tcase \"from\":\n+  369: \t\t\t\t\t\tif ( !builder.isEmpty() ) {\n+  370: \t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n+  371: \t\t\t\t\t\t\tbuilder.setLength( 0 );\n+  372: \t\t\t\t\t\t\toperands.add( operandToken );\n+  373: \t\t\t\t\t\t}\n+  374: \t\t\t\t\t\tbreak;\n+  375: \t\t\t\t}\n+  376: \t\t\t}\n+  377: \t\t\toperandToken = tokens.nextToken();\n+  378: \t\t\thasMoreOperands = tokens.hasMoreTokens()\n+  379: \t\t\t\t\t&& ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n+  380: \t\t}\n+  381: \t\tif ( !builder.isEmpty() ) {\n+  382: \t\t\toperands.add( builder.toString() );\n+  383: \t\t}\n+  384: \n+  385: \t\tfinal TrimOperands trimOperands = new TrimOperands( operands );\n+  386: \t\tresult.append( \"trim(\" );\n+  387: \t\tif ( trimOperands.trimSpec != null ) {\n+  388: \t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n+  389: \t\t}\n+  390: \t\tif ( trimOperands.trimChar != null ) {\n+  391: \t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n+  392: \t\t\t\tresult.append( trimOperands.trimChar );\n+  393: \t\t\t}\n+  394: \t\t\telse {\n+  395: \t\t\t\tresult.append(\n+  396: \t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n+  397: \t\t\t\t);\n   398: \t\t\t}\n-  399: \t\t}\n-  400: \n-  401: \t\treturn result.toString();\n-  402: \t}\n-  413: \t\t\t\tcase \"timestamp\":\n-  414: \t\t\t\t\treturn WITH;\n-  415: \t\t\t\tdefault:\n-  416: \t\t\t\t\treturn NONE;\n-  417: \t\t\t}\n-  418: \t\t}\n-  419: \n-  420: \t\tpublic TimeZoneTokens nextToken() {\n-  421: \t\t\tif ( this == WITH ) {\n-  422: \t\t\t\treturn TIME;\n-  423: \t\t\t}\n-  424: \t\t\telse if ( this == TIME ) {\n-  425: \t\t\t\treturn ZONE;\n-  426: \t\t\t}\n-  427: \t\t\telse {\n-  428: \t\t\t\treturn NONE;\n-  429: \t\t\t}\n+  399: \t\t\tresult.append( ' ' );\n+  400: \t\t}\n+  401: \t\tif ( trimOperands.from != null ) {\n+  402: \t\t\tresult.append( trimOperands.from ).append( ' ' );\n+  413: \tprivate static void handleExtractFunction(\n+  414: \t\t\tString placeholder,\n+  415: \t\t\tDialect dialect,\n+  416: \t\t\tTypeConfiguration typeConfiguration,\n+  417: \t\t\tSqmFunctionRegistry functionRegistry,\n+  418: \t\t\tStringTokenizer tokens,\n+  419: \t\t\tStringBuilder result) {\n+  420: \t\tfinal String field = extractUntil( tokens, \"from\" );\n+  421: \t\tfinal String source = renderWhereStringTemplate(\n+  422: \t\t\t\textractUntil( tokens, \")\" ),\n+  423: \t\t\t\tplaceholder,\n+  424: \t\t\t\tdialect,\n+  425: \t\t\t\ttypeConfiguration,\n+  426: \t\t\t\tfunctionRegistry\n+  427: \t\t);\n+  428: \t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n+  429: \t}\n",
        "uniqueId": "35f96d6e901dbd071b375d809521ef6f1c979868_119_402_413_429_122_260",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 137,
                "covered": 506
            },
            "BRANCH": {
                "missed": 37,
                "covered": 108
            },
            "LINE": {
                "missed": 32,
                "covered": 133
            },
            "COMPLEXITY": {
                "missed": 31,
                "covered": 44
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\npublic static String renderTransformerReadFragment(\n        String fragment,\n        String... columnNames) {\n    // NOTE : would need access to SessionFactoryImplementor to make this configurable\n    for (String columnName : columnNames) {\n        fragment = fragment.replace(columnName, TEMPLATE + '.' + columnName);\n    }\n    return fragment;\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n\t * named parameters.\n\t *\n\t * @param sqlWhereString The string into which to interpolate the placeholder value\n\t * @param placeholder The value to be interpolated into the sqlWhereString\n\t * @param dialect The dialect to apply\n\t * @param functionRegistry The registry of all sql functions\n\t * @return The rendered sql fragment\n\t */\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\n\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n\t\t//\t\tidentifier references.\n\n\t\tString symbols = PUNCTUATION +\n\t\t\t\tWHITESPACE +\n\t\t\t\tdialect.openQuote() +\n\t\t\t\tdialect.closeQuote();\n\t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n\t\tStringBuilder result = new StringBuilder();\n\n\t\tboolean quoted = false;\n\t\tboolean quotedIdentifier = false;\n\t\tboolean beforeTable = false;\n\t\tboolean inFromClause = false;\n\t\tboolean afterFromTable = false;\n\n\t\tboolean hasMore = tokens.hasMoreTokens();\n\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n\t\twhile ( hasMore ) {\n\t\t\tString token = nextToken;\n\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\tboolean isQuoteCharacter = false;\n\n\t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n\t\t\t\tquoted = !quoted;\n\t\t\t\tisQuoteCharacter = true;\n\t\t\t}\n\n\t\t\tif ( !quoted ) {\n\t\t\t\tboolean isOpenQuote;\n\t\t\t\tif ( \"`\".equals(token) ) {\n\t\t\t\t\tisOpenQuote = !quotedIdentifier;\n\t\t\t\t\ttoken = lcToken = isOpenQuote\n\t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n\t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n\t\t\t\t\tquotedIdentifier = isOpenQuote;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( !quotedIdentifier && ( dialect.openQuote()==token.charAt(0) ) ) {\n\t\t\t\t\tisOpenQuote = true;\n\t\t\t\t\tquotedIdentifier = true;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( quotedIdentifier && ( dialect.closeQuote()==token.charAt(0) ) ) {\n\t\t\t\t\tquotedIdentifier = false;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\telse if ( LITERAL_PREFIXES.contains( lcToken ) ) {\n\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n\t\t\t\t\t\t// Don't prefix a literal\n\t\t\t\t\t\tresult.append( token );\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) ) {\n\t\t\t\t\t\tfinal StringBuilder additionalTokens = new StringBuilder();\n\t\t\t\t\t\tTimeZoneTokens possibleNextToken = null;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tpossibleNextToken = possibleNextToken == null\n\t\t\t\t\t\t\t\t\t? TimeZoneTokens.getPossibleNextTokens( lcToken )\n\t\t\t\t\t\t\t\t\t: possibleNextToken.nextToken();\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tadditionalTokens.append( nextToken );\n\t\t\t\t\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\t\t\t\t\tnextToken = tokens.nextToken();\n\t\t\t\t\t\t\t} while ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) );\n\t\t\t\t\t\t} while ( nextToken != null && possibleNextToken.isToken( nextToken ) );\n\t\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n\t\t\t\t\t\t\t// Don't prefix a literal\n\t\t\t\t\t\t\tresult.append( token );\n\t\t\t\t\t\t\tresult.append( additionalTokens );\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\n\t\t\t\tif ( isOpenQuote ) {\n\t\t\t\t\tresult.append( placeholder ).append( '.' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Special processing for ANSI SQL EXTRACT function\n\t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n\t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n\t\t\t\tfinal String source = renderWhereStringTemplate(\n\t\t\t\t\t\textractUntil( tokens, \")\" ),\n\t\t\t\t\t\tplaceholder,\n\t\t\t\t\t\tdialect,\n\t\t\t\t\t\ttypeConfiguration,\n\t\t\t\t\t\tfunctionRegistry\n\t\t\t\t);\n\t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Special processing for ANSI SQL TRIM function\n\t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n\t\t\t\tList<String> operands = new ArrayList<>();\n\t\t\t\tStringBuilder builder = new StringBuilder();\n\n\t\t\t\tboolean hasMoreOperands = true;\n\t\t\t\tString operandToken = tokens.nextToken();\n\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\tcase \"leading\":\n\t\t\t\t\tcase \"trailing\":\n\t\t\t\t\tcase \"both\":\n\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n\t\t\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tboolean quotedOperand = false;\n\t\t\t\tint parenthesis = 0;\n\t\t\t\twhile ( hasMoreOperands ) {\n\t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n\t\t\t\t\tif ( isQuote ) {\n\t\t\t\t\t\tquotedOperand = !quotedOperand;\n\t\t\t\t\t\tif ( !quotedOperand ) {\n\t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbuilder.append( '\\'' );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if ( quotedOperand ) {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( parenthesis != 0 ) {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t\tswitch ( operandToken ) {\n\t\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"from\":\n\t\t\t\t\t\t\t\tif ( builder.length() != 0 ) {\n\t\t\t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n\t\t\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n\t\t\t\t}\n\t\t\t\tif ( builder.length() != 0 ) {\n\t\t\t\t\toperands.add( builder.toString() );\n\t\t\t\t}\n\n\t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n\t\t\t\tresult.append( \"trim(\" );\n\t\t\t\tif ( trimOperands.trimSpec != null ) {\n\t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n\t\t\t\t}\n\t\t\t\tif ( trimOperands.trimChar != null ) {\n\t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n\t\t\t\t\t\tresult.append( trimOperands.trimChar );\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresult.append(\n\t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tresult.append( ' ' );\n\t\t\t\t}\n\t\t\t\tif ( trimOperands.from != null ) {\n\t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n\t\t\t\t}\n\t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n\t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char is specified\n\t\t\t\t\tresult.append( \"from \" );\n\t\t\t\t}\n\n\t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, typeConfiguration, functionRegistry ) )\n\t\t\t\t\t\t.append( ')' );\n\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tboolean quotedOrWhitespace = quoted || quotedIdentifier || isQuoteCharacter\n\t\t\t\t\t|| Character.isWhitespace( token.charAt(0) );\n\n\t\t\tif ( quotedOrWhitespace ) {\n\t\t\t\tresult.append( token );\n\t\t\t}\n\t\t\telse if ( beforeTable ) {\n\t\t\t\tresult.append( token );\n\t\t\t\tbeforeTable = false;\n\t\t\t\tafterFromTable = true;\n\t\t\t}\n\t\t\telse if ( afterFromTable ) {\n\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n\t\t\t\t\tafterFromTable = false;\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isNamedParameter(token) ) {\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isIdentifier(token)\n\t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect, typeConfiguration, functionRegistry) ) {\n\t\t\t\tresult.append(placeholder)\n\t\t\t\t\t\t.append('.')\n\t\t\t\t\t\t.append( dialect.quote(token) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t\tinFromClause = true;\n\t\t\t\t}\n\t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t}\n\t\t\t\tif ( isBoolean( token ) ) {\n\t\t\t\t\ttoken = dialect.toBooleanValueString( Boolean.parseBoolean( token ) );\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\n\t\t\t//Yuck:\n\t\t\tif ( inFromClause\n\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n\t\t\t\tinFromClause = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result.toString();\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.sql;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.query.sqm.function.SqmFunctionDescriptor;\nimport org.hibernate.query.sqm.function.SqmFunctionRegistry;\nimport org.hibernate.type.spi.TypeConfiguration;\n\nimport static org.hibernate.internal.util.StringHelper.WHITESPACE;\n\n/**\n * Parses SQL fragments specified in mapping documents.\n *\n * @author Gavin King\n */\npublic final class Template {\n\n\tprivate static final Set<String> KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> BEFORE_TABLE_KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> FUNCTION_KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> LITERAL_PREFIXES = new HashSet<>();\n\tpublic static final String PUNCTUATION = \"=><!+-*/()',|&`\";\n\n\tstatic {\n\t\tKEYWORDS.add(\"and\");\n\t\tKEYWORDS.add(\"or\");\n\t\tKEYWORDS.add(\"not\");\n\t\tKEYWORDS.add(\"like\");\n\t\tKEYWORDS.add(\"escape\");\n\t\tKEYWORDS.add(\"is\");\n\t\tKEYWORDS.add(\"in\");\n\t\tKEYWORDS.add(\"between\");\n\t\tKEYWORDS.add(\"null\");\n\t\tKEYWORDS.add(\"select\");\n\t\tKEYWORDS.add(\"distinct\");\n\t\tKEYWORDS.add(\"from\");\n\t\tKEYWORDS.add(\"join\");\n\t\tKEYWORDS.add(\"inner\");\n\t\tKEYWORDS.add(\"outer\");\n\t\tKEYWORDS.add(\"left\");\n\t\tKEYWORDS.add(\"right\");\n\t\tKEYWORDS.add(\"on\");\n\t\tKEYWORDS.add(\"where\");\n\t\tKEYWORDS.add(\"having\");\n\t\tKEYWORDS.add(\"group\");\n\t\tKEYWORDS.add(\"order\");\n\t\tKEYWORDS.add(\"by\");\n\t\tKEYWORDS.add(\"desc\");\n\t\tKEYWORDS.add(\"asc\");\n\t\tKEYWORDS.add(\"limit\");\n\t\tKEYWORDS.add(\"any\");\n\t\tKEYWORDS.add(\"some\");\n\t\tKEYWORDS.add(\"exists\");\n\t\tKEYWORDS.add(\"all\");\n\t\tKEYWORDS.add(\"union\");\n\t\tKEYWORDS.add(\"minus\");\n\t\tKEYWORDS.add(\"except\");\n\t\tKEYWORDS.add(\"intersect\");\n\t\tKEYWORDS.add(\"partition\");\n\n\t\tBEFORE_TABLE_KEYWORDS.add(\"from\");\n\t\tBEFORE_TABLE_KEYWORDS.add(\"join\");\n\n\t\tFUNCTION_KEYWORDS.add(\"as\");\n\t\tFUNCTION_KEYWORDS.add(\"leading\");\n\t\tFUNCTION_KEYWORDS.add(\"trailing\");\n\t\tFUNCTION_KEYWORDS.add(\"from\");\n\t\tFUNCTION_KEYWORDS.add(\"case\");\n\t\tFUNCTION_KEYWORDS.add(\"when\");\n\t\tFUNCTION_KEYWORDS.add(\"then\");\n\t\tFUNCTION_KEYWORDS.add(\"else\");\n\t\tFUNCTION_KEYWORDS.add(\"end\");\n\n\t\tLITERAL_PREFIXES.add(\"n\");\n\t\tLITERAL_PREFIXES.add(\"x\");\n\t\tLITERAL_PREFIXES.add(\"varbyte\");\n\t\tLITERAL_PREFIXES.add(\"bx\");\n\t\tLITERAL_PREFIXES.add(\"bytea\");\n\t\tLITERAL_PREFIXES.add(\"date\");\n\t\tLITERAL_PREFIXES.add(\"time\");\n\t\tLITERAL_PREFIXES.add(\"timestamp\");\n\t}\n\n\tpublic static final String TEMPLATE = \"$PlaceHolder$\";\n\n\tprivate Template() {}\n\n\tpublic static String renderTransformerReadFragment(\n\t\t\tString fragment,\n\t\t\tString... columnNames) {\n\t\t// NOTE : would need access to SessionFactoryImplementor to make this configurable\n\t\tfor ( String columnName : columnNames ) {\n\t\t\tfragment = fragment.replace( columnName, TEMPLATE + '.' + columnName );\n\t\t}\n\t\treturn fragment;\n\t}\n\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn renderWhereStringTemplate( sqlWhereString, TEMPLATE, dialect, typeConfiguration, functionRegistry );\n\t}\n\n\t/**\n\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n\t * named parameters.\n\t *\n\t * @param sqlWhereString The string into which to interpolate the placeholder value\n\t * @param placeholder The value to be interpolated into the sqlWhereString\n\t * @param dialect The dialect to apply\n\t * @param functionRegistry The registry of all sql functions\n\t * @return The rendered sql fragment\n\t */\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\n\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n\t\t//\t\tidentifier references.\n\n\t\tString symbols = PUNCTUATION +\n\t\t\t\tWHITESPACE +\n\t\t\t\tdialect.openQuote() +\n\t\t\t\tdialect.closeQuote();\n\t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n\t\tStringBuilder result = new StringBuilder();\n\n\t\tboolean quoted = false;\n\t\tboolean quotedIdentifier = false;\n\t\tboolean beforeTable = false;\n\t\tboolean inFromClause = false;\n\t\tboolean afterFromTable = false;\n\n\t\tboolean hasMore = tokens.hasMoreTokens();\n\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n\t\twhile ( hasMore ) {\n\t\t\tString token = nextToken;\n\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\tboolean isQuoteCharacter = false;\n\n\t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n\t\t\t\tquoted = !quoted;\n\t\t\t\tisQuoteCharacter = true;\n\t\t\t}\n\n\t\t\tif ( !quoted ) {\n\t\t\t\tboolean isOpenQuote;\n\t\t\t\tif ( \"`\".equals(token) ) {\n\t\t\t\t\tisOpenQuote = !quotedIdentifier;\n\t\t\t\t\ttoken = lcToken = isOpenQuote\n\t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n\t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n\t\t\t\t\tquotedIdentifier = isOpenQuote;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( !quotedIdentifier && ( dialect.openQuote()==token.charAt(0) ) ) {\n\t\t\t\t\tisOpenQuote = true;\n\t\t\t\t\tquotedIdentifier = true;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( quotedIdentifier && ( dialect.closeQuote()==token.charAt(0) ) ) {\n\t\t\t\t\tquotedIdentifier = false;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\telse if ( LITERAL_PREFIXES.contains( lcToken ) ) {\n\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n\t\t\t\t\t\t// Don't prefix a literal\n\t\t\t\t\t\tresult.append( token );\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) ) {\n\t\t\t\t\t\tfinal StringBuilder additionalTokens = new StringBuilder();\n\t\t\t\t\t\tTimeZoneTokens possibleNextToken = null;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tpossibleNextToken = possibleNextToken == null\n\t\t\t\t\t\t\t\t\t? TimeZoneTokens.getPossibleNextTokens( lcToken )\n\t\t\t\t\t\t\t\t\t: possibleNextToken.nextToken();\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tadditionalTokens.append( nextToken );\n\t\t\t\t\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\t\t\t\t\tnextToken = tokens.nextToken();\n\t\t\t\t\t\t\t} while ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) );\n\t\t\t\t\t\t} while ( nextToken != null && possibleNextToken.isToken( nextToken ) );\n\t\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n\t\t\t\t\t\t\t// Don't prefix a literal\n\t\t\t\t\t\t\tresult.append( token );\n\t\t\t\t\t\t\tresult.append( additionalTokens );\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\n\t\t\t\tif ( isOpenQuote ) {\n\t\t\t\t\tresult.append( placeholder ).append( '.' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Special processing for ANSI SQL EXTRACT function\n\t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n\t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n\t\t\t\tfinal String source = renderWhereStringTemplate(\n\t\t\t\t\t\textractUntil( tokens, \")\" ),\n\t\t\t\t\t\tplaceholder,\n\t\t\t\t\t\tdialect,\n\t\t\t\t\t\ttypeConfiguration,\n\t\t\t\t\t\tfunctionRegistry\n\t\t\t\t);\n\t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Special processing for ANSI SQL TRIM function\n\t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n\t\t\t\tList<String> operands = new ArrayList<>();\n\t\t\t\tStringBuilder builder = new StringBuilder();\n\n\t\t\t\tboolean hasMoreOperands = true;\n\t\t\t\tString operandToken = tokens.nextToken();\n\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\tcase \"leading\":\n\t\t\t\t\tcase \"trailing\":\n\t\t\t\t\tcase \"both\":\n\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n\t\t\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tboolean quotedOperand = false;\n\t\t\t\tint parenthesis = 0;\n\t\t\t\twhile ( hasMoreOperands ) {\n\t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n\t\t\t\t\tif ( isQuote ) {\n\t\t\t\t\t\tquotedOperand = !quotedOperand;\n\t\t\t\t\t\tif ( !quotedOperand ) {\n\t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbuilder.append( '\\'' );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if ( quotedOperand ) {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( parenthesis != 0 ) {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t\tswitch ( operandToken ) {\n\t\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"from\":\n\t\t\t\t\t\t\t\tif ( builder.length() != 0 ) {\n\t\t\t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n\t\t\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n\t\t\t\t}\n\t\t\t\tif ( builder.length() != 0 ) {\n\t\t\t\t\toperands.add( builder.toString() );\n\t\t\t\t}\n\n\t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n\t\t\t\tresult.append( \"trim(\" );\n\t\t\t\tif ( trimOperands.trimSpec != null ) {\n\t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n\t\t\t\t}\n\t\t\t\tif ( trimOperands.trimChar != null ) {\n\t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n\t\t\t\t\t\tresult.append( trimOperands.trimChar );\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresult.append(\n\t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tresult.append( ' ' );\n\t\t\t\t}\n\t\t\t\tif ( trimOperands.from != null ) {\n\t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n\t\t\t\t}\n\t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n\t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char is specified\n\t\t\t\t\tresult.append( \"from \" );\n\t\t\t\t}\n\n\t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, typeConfiguration, functionRegistry ) )\n\t\t\t\t\t\t.append( ')' );\n\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tboolean quotedOrWhitespace = quoted || quotedIdentifier || isQuoteCharacter\n\t\t\t\t\t|| Character.isWhitespace( token.charAt(0) );\n\n\t\t\tif ( quotedOrWhitespace ) {\n\t\t\t\tresult.append( token );\n\t\t\t}\n\t\t\telse if ( beforeTable ) {\n\t\t\t\tresult.append( token );\n\t\t\t\tbeforeTable = false;\n\t\t\t\tafterFromTable = true;\n\t\t\t}\n\t\t\telse if ( afterFromTable ) {\n\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n\t\t\t\t\tafterFromTable = false;\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isNamedParameter(token) ) {\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isIdentifier(token)\n\t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect, typeConfiguration, functionRegistry) ) {\n\t\t\t\tresult.append(placeholder)\n\t\t\t\t\t\t.append('.')\n\t\t\t\t\t\t.append( dialect.quote(token) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t\tinFromClause = true;\n\t\t\t\t}\n\t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t}\n\t\t\t\tif ( isBoolean( token ) ) {\n\t\t\t\t\ttoken = dialect.toBooleanValueString( Boolean.parseBoolean( token ) );\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\n\t\t\t//Yuck:\n\t\t\tif ( inFromClause\n\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n\t\t\t\tinFromClause = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result.toString();\n\t}\n\n\tprivate enum TimeZoneTokens {\n\t\tNONE,\n\t\tWITH,\n\t\tTIME,\n\t\tZONE;\n\n\t\tstatic TimeZoneTokens getPossibleNextTokens(String lctoken) {\n\t\t\tswitch ( lctoken ) {\n\t\t\t\tcase \"time\":\n\t\t\t\tcase \"timestamp\":\n\t\t\t\t\treturn WITH;\n\t\t\t\tdefault:\n\t\t\t\t\treturn NONE;\n\t\t\t}\n\t\t}\n\n\t\tpublic TimeZoneTokens nextToken() {\n\t\t\tif ( this == WITH ) {\n\t\t\t\treturn TIME;\n\t\t\t}\n\t\t\telse if ( this == TIME ) {\n\t\t\t\treturn ZONE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn NONE;\n\t\t\t}\n\t\t}\n\n\t\tpublic boolean isToken(String token) {\n\t\t\treturn this != NONE && name().equalsIgnoreCase( token );\n\t\t}\n\t}\n\n\tpublic static List<String> collectColumnNames(\n\t\t\tString sql,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn collectColumnNames( renderWhereStringTemplate( sql, dialect, typeConfiguration, functionRegistry ) );\n\t}\n\n\tpublic static List<String> collectColumnNames(String template) {\n\t\tfinal List<String> names = new ArrayList<>();\n\t\tint begin = 0;\n\t\tint match;\n\t\twhile ( ( match = template.indexOf(TEMPLATE, begin) ) >= 0 ) {\n\t\t\tint start = match + TEMPLATE.length() + 1;\n\t\t\tfor ( int loc = start;; loc++ ) {\n\t\t\t\tif ( loc == template.length() - 1 ) {\n\t\t\t\t\tnames.add( template.substring( start ) );\n\t\t\t\t\tbegin = template.length();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar ch = template.charAt( loc );\n\t\t\t\t\tif ( PUNCTUATION.indexOf(ch) >= 0 || WHITESPACE.indexOf(ch) >= 0 ) {\n\t\t\t\t\t\tnames.add( template.substring( start, loc ) );\n\t\t\t\t\t\tbegin = loc;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn names;\n\t}\n\n//\t/**\n//\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n//\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n//\t * named parameters.\n//\t *\n//\t * @param sqlWhereString The string into which to interpolate the placeholder value\n//\t * @param placeholder The value to be interpolated into the sqlWhereString\n//\t * @param dialect The dialect to apply\n//\t * @param functionRegistry The registry of all sql functions\n//\t *\n//\t * @return The rendered sql fragment\n//\t */\n//\tpublic static String renderWhereStringTemplate(\n//\t\t\tString sqlWhereString,\n//\t\t\tString placeholder,\n//\t\t\tDialect dialect,\n//\t\t\tSQLFunctionRegistry functionRegistry) {\n//\n//\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n//\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n//\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n//\t\t//\t\tidentifier references.\n//\n//\t\tfinal String dialectOpenQuote = Character.toString( dialect.openQuote() );\n//\t\tfinal String dialectCloseQuote = Character.toString( dialect.closeQuote() );\n//\n//\t\tString symbols = new StringBuilder()\n//\t\t\t\t.append( \"=><!+-*/()',|&`\" )\n//\t\t\t\t.append( StringHelper.WHITESPACE )\n//\t\t\t\t.append( dialect.openQuote() )\n//\t\t\t\t.append( dialect.closeQuote() )\n//\t\t\t\t.toString();\n//\t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n//\t\tProcessingState state = new ProcessingState();\n//\n//\t\tStringBuilder quotedBuffer = new StringBuilder();\n//\t\tStringBuilder result = new StringBuilder();\n//\n//\t\tboolean hasMore = tokens.hasMoreTokens();\n//\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n//\t\twhile ( hasMore ) {\n//\t\t\tString token = nextToken;\n//\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n//\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t// First, determine quoting which might be based on either:\n//\t\t\t// \t\t1) back-tick\n//\t\t\t// \t\t2) single quote (ANSI SQL standard)\n//\t\t\t// \t\t3) or dialect defined quote character(s)\n//\t\t\tQuotingCharacterDisposition quotingCharacterDisposition = QuotingCharacterDisposition.NONE;\n//\t\t\tif ( \"`\".equals( token ) ) {\n//\t\t\t\tstate.quoted = !state.quoted;\n//\t\t\t\tquotingCharacterDisposition = state.quoted\n//\t\t\t\t\t\t? QuotingCharacterDisposition.OPEN\n//\t\t\t\t\t\t: QuotingCharacterDisposition.CLOSE;\n//\t\t\t\t// replace token with the appropriate dialect quoting char\n//\t\t\t\ttoken = lcToken = ( quotingCharacterDisposition == QuotingCharacterDisposition.OPEN )\n//\t\t\t\t\t\t? dialectOpenQuote\n//\t\t\t\t\t\t: dialectCloseQuote;\n//\t\t\t}\n//\t\t\telse if ( \"'\".equals( token ) ) {\n//\t\t\t\tstate.quoted = !state.quoted;\n//\t\t\t\tquotingCharacterDisposition = state.quoted\n//\t\t\t\t\t\t? QuotingCharacterDisposition.OPEN\n//\t\t\t\t\t\t: QuotingCharacterDisposition.CLOSE;\n//\t\t\t}\n//\t\t\telse if ( !state.quoted && dialectOpenQuote.equals( token ) ) {\n//\t\t\t\tstate.quoted = true;\n//\t\t\t\tquotingCharacterDisposition = QuotingCharacterDisposition.OPEN;\n//\t\t\t}\n//\t\t\telse if ( state.quoted && dialectCloseQuote.equals( token ) ) {\n//\t\t\t\tstate.quoted = false;\n//\t\t\t\tquotingCharacterDisposition = QuotingCharacterDisposition.CLOSE;\n//\t\t\t}\n//\n//\t\t\tif ( state.quoted ) {\n//\t\t\t\tquotedBuffer.append( token );\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// if we were previously processing quoted state and just encountered the close quote, then handle that\n//\t\t\t// quoted text\n//\t\t\tif ( quotingCharacterDisposition == QuotingCharacterDisposition.CLOSE ) {\n//\t\t\t\ttoken = quotedBuffer.toString();\n//\t\t\t\tquotedBuffer.setLength( 0 );\n//\t\t\t\tresult.append( placeholder ).append( '.' )\n//\t\t\t\t\t\t.append( dialectOpenQuote ).append( token ).append( dialectCloseQuote );\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// Special processing for ANSI SQL EXTRACT function\n//\t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n//\t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n//\t\t\t\tfinal String source = renderWhereStringTemplate(\n//\t\t\t\t\t\textractUntil( tokens, \")\" ),\n//\t\t\t\t\t\tplaceholder,\n//\t\t\t\t\t\tdialect,\n//\t\t\t\t\t\tfunctionRegistry\n//\t\t\t\t);\n//\t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n//\n//\t\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// Special processing for ANSI SQL TRIM function\n//\t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n//\t\t\t\tList<String> operands = new ArrayList<String>();\n//\t\t\t\tStringBuilder builder = new StringBuilder();\n//\n//\t\t\t\tboolean hasMoreOperands = true;\n//\t\t\t\tString operandToken = tokens.nextToken();\n//\t\t\t\tboolean quoted = false;\n//\t\t\t\twhile ( hasMoreOperands ) {\n//\t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n//\t\t\t\t\tif ( isQuote ) {\n//\t\t\t\t\t\tquoted = !quoted;\n//\t\t\t\t\t\tif ( !quoted ) {\n//\t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n//\t\t\t\t\t\t\tbuilder.setLength( 0 );\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse {\n//\t\t\t\t\t\t\tbuilder.append( '\\'' );\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t\telse if ( quoted ) {\n//\t\t\t\t\t\tbuilder.append( operandToken );\n//\t\t\t\t\t}\n//\t\t\t\t\telse if ( operandToken.length() == 1 && Character.isWhitespace( operandToken.charAt( 0 ) ) ) {\n//\t\t\t\t\t\t// do nothing\n//\t\t\t\t\t}\n//\t\t\t\t\telse {\n//\t\t\t\t\t\toperands.add( operandToken );\n//\t\t\t\t\t}\n//\t\t\t\t\toperandToken = tokens.nextToken();\n//\t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ! \")\".equals( operandToken );\n//\t\t\t\t}\n//\n//\t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n//\t\t\t\tresult.append( \"trim(\" );\n//\t\t\t\tif ( trimOperands.trimSpec != null ) {\n//\t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n//\t\t\t\t}\n//\t\t\t\tif ( trimOperands.trimChar != null ) {\n//\t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n//\t\t\t\t\t\tresult.append( trimOperands.trimChar );\n//\t\t\t\t\t}\n//\t\t\t\t\telse {\n//\t\t\t\t\t\tresult.append(\n//\t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, functionRegistry )\n//\t\t\t\t\t\t);\n//\t\t\t\t\t}\n//\t\t\t\t\tresult.append( ' ' );\n//\t\t\t\t}\n//\t\t\t\tif ( trimOperands.from != null ) {\n//\t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n//\t\t\t\t}\n//\t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n//\t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char are specified\n//\t\t\t\t\tresult.append( \"from \" );\n//\t\t\t\t}\n//\n//\t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, functionRegistry ) )\n//\t\t\t\t\t\t.append( ')' );\n//\n//\t\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\n//\t\t\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\n//\t\t\tif ( Character.isWhitespace( token.charAt( 0 ) ) ) {\n//\t\t\t\tresult.append( token );\n//\t\t\t}\n//\t\t\telse if ( state.beforeTable ) {\n//\t\t\t\tresult.append( token );\n//\t\t\t\tstate.beforeTable = false;\n//\t\t\t\tstate.afterFromTable = true;\n//\t\t\t}\n//\t\t\telse if ( state.afterFromTable ) {\n//\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n//\t\t\t\t\tstate.afterFromTable = false;\n//\t\t\t\t}\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\t\t\telse if ( isNamedParameter(token) ) {\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\t\t\telse if ( isIdentifier(token, dialect)\n//\t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect , functionRegistry) ) {\n//\t\t\t\tresult.append(placeholder)\n//\t\t\t\t\t\t.append('.')\n//\t\t\t\t\t\t.append( dialect.quote(token) );\n//\t\t\t}\n//\t\t\telse {\n//\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n//\t\t\t\t\tstate.beforeTable = true;\n//\t\t\t\t\tstate.inFromClause = true;\n//\t\t\t\t}\n//\t\t\t\telse if ( state.inFromClause && \",\".equals(lcToken) ) {\n//\t\t\t\t\tstate.beforeTable = true;\n//\t\t\t\t}\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\n//\t\t\t//Yuck:\n//\t\t\tif ( state.inFromClause\n//\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n//\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n//\t\t\t\tstate.inFromClause = false;\n//\t\t\t}\n//\t\t}\n//\n//\t\treturn result.toString();\n//\t}\n//\n//\tprivate static class ProcessingState {\n//\t\tboolean quoted = false;\n//\t\tboolean quotedIdentifier = false;\n//\t\tboolean beforeTable = false;\n//\t\tboolean inFromClause = false;\n//\t\tboolean afterFromTable = false;\n//\t}\n//\n//\tprivate static enum QuotingCharacterDisposition { NONE, OPEN, CLOSE }\n\n\tprivate static class TrimOperands {\n\t\tprivate final String trimSpec;\n\t\tprivate final String trimChar;\n\t\tprivate final String from;\n\t\tprivate final String trimSource;\n\n\t\tprivate TrimOperands(List<String> operands) {\n\t\t\tfinal int size = operands.size();\n\t\t\tif ( size == 1 ) {\n\t\t\t\ttrimSpec = null;\n\t\t\t\ttrimChar = null;\n\t\t\t\tfrom = null;\n\t\t\t\ttrimSource = operands.get(0);\n\t\t\t}\n\t\t\telse if ( size == 4 ) {\n\t\t\t\ttrimSpec = operands.get(0);\n\t\t\t\ttrimChar = operands.get(1);\n\t\t\t\tfrom = operands.get(2);\n\t\t\t\ttrimSource = operands.get(3);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( size < 1 || size > 4 ) {\n\t\t\t\t\tthrow new HibernateException( \"Unexpected number of trim function operands : \" + size );\n\t\t\t\t}\n\n\t\t\t\t// trim-source will always be the last operand\n\t\t\t\ttrimSource = operands.get( size - 1 );\n\n\t\t\t\t// ANSI SQL says that more than one operand means that the FROM is required\n\t\t\t\tif ( ! \"from\".equals( operands.get( size - 2 ) ) ) {\n\t\t\t\t\tthrow new HibernateException( \"Expecting FROM, found : \" + operands.get( size - 2 ) );\n\t\t\t\t}\n\t\t\t\tfrom = operands.get( size - 2 );\n\n\t\t\t\t// trim-spec, if there is one will always be the first operand\n\t\t\t\tif ( \"leading\".equalsIgnoreCase( operands.get(0) )\n\t\t\t\t\t\t|| \"trailing\".equalsIgnoreCase( operands.get(0) )\n\t\t\t\t\t\t|| \"both\".equalsIgnoreCase( operands.get(0) ) ) {\n\t\t\t\t\ttrimSpec = operands.get(0);\n\t\t\t\t\ttrimChar = null;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttrimSpec = null;\n\t\t\t\t\tif ( size - 2 == 0 ) {\n\t\t\t\t\t\ttrimChar = null;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttrimChar = operands.get( 0 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static String extractUntil(StringTokenizer tokens, String delimiter) {\n\t\tStringBuilder valueBuilder = new StringBuilder();\n\t\tString token = tokens.nextToken();\n\t\twhile ( ! delimiter.equalsIgnoreCase( token ) ) {\n\t\t\tvalueBuilder.append( token );\n\t\t\ttoken = tokens.nextToken();\n\t\t}\n\t\treturn valueBuilder.toString().trim();\n\t}\n\n\tprivate static boolean isNamedParameter(String token) {\n\t\treturn token.startsWith( \":\" );\n\t}\n\n\tprivate static boolean isFunctionOrKeyword(\n\t\t\tString lcToken,\n\t\t\tString nextToken,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn \"(\".equals( nextToken ) ||\n\t\t\t\tKEYWORDS.contains( lcToken ) ||\n\t\t\t\tisType( lcToken, typeConfiguration ) ||\n\t\t\t\tisFunction( lcToken, nextToken, functionRegistry ) ||\n\t\t\t\tdialect.getKeywords().contains( lcToken ) ||\n\t\t\t\tFUNCTION_KEYWORDS.contains( lcToken );\n\t}\n\n\tprivate static boolean isType(String lcToken, TypeConfiguration typeConfiguration) {\n\t\treturn typeConfiguration.getDdlTypeRegistry().isTypeNameRegistered( lcToken );\n\t}\n\n\tprivate static boolean isFunction(String lcToken, String nextToken, SqmFunctionRegistry functionRegistry) {\n\t\t// checking for \"(\" is currently redundant because it is checked before getting here;\n\t\t// doing the check anyhow, in case that earlier check goes away;\n\t\tif ( \"(\".equals( nextToken ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tfinal SqmFunctionDescriptor function = functionRegistry.findFunctionDescriptor( lcToken );\n\t\treturn function != null;\n\t}\n\n\tprivate static boolean isIdentifier(String token) {\n\t\tif ( isBoolean( token ) ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn token.charAt( 0 ) == '`' || ( //allow any identifier quoted with backtick\n\t\t\t\tCharacter.isLetter( token.charAt( 0 ) ) && //only recognizes identifiers beginning with a letter\n\t\t\t\t\t\ttoken.indexOf( '.' ) < 0\n\t\t);\n\t}\n\n\tprivate static boolean isBoolean(String token) {\n\t\treturn \"true\".equals( token ) || \"false\".equals( token );\n\t}\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate isExtractFunction(lcToken String, nextToken String) : boolean extracted from public renderWhereStringTemplate(sqlWhereString String, placeholder String, dialect Dialect, typeConfiguration TypeConfiguration, functionRegistry SqmFunctionRegistry) : String in class org.hibernate.sql.Template",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
                "startLine": 119,
                "endLine": 402,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
                "startLine": 122,
                "endLine": 260,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
                "startLine": 266,
                "endLine": 268,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n\t * named parameters.\n\t *\n\t * @param sqlWhereString The string into which to interpolate the placeholder value\n\t * @param placeholder The value to be interpolated into the sqlWhereString\n\t * @param dialect The dialect to apply\n\t * @param functionRegistry The registry of all sql functions\n\t * @return The rendered sql fragment\n\t */\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\n\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n\t\t//\t\tidentifier references.\n\n\t\tString symbols = PUNCTUATION +\n\t\t\t\tWHITESPACE +\n\t\t\t\tdialect.openQuote() +\n\t\t\t\tdialect.closeQuote();\n\t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n\t\tStringBuilder result = new StringBuilder();\n\n\t\tboolean quoted = false;\n\t\tboolean quotedIdentifier = false;\n\t\tboolean beforeTable = false;\n\t\tboolean inFromClause = false;\n\t\tboolean afterFromTable = false;\n\n\t\tboolean hasMore = tokens.hasMoreTokens();\n\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n\t\twhile ( hasMore ) {\n\t\t\tString token = nextToken;\n\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\tboolean isQuoteCharacter = false;\n\n\t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n\t\t\t\tquoted = !quoted;\n\t\t\t\tisQuoteCharacter = true;\n\t\t\t}\n\n\t\t\tif ( !quoted ) {\n\t\t\t\tboolean isOpenQuote;\n\t\t\t\tif ( \"`\".equals(token) ) {\n\t\t\t\t\tisOpenQuote = !quotedIdentifier;\n\t\t\t\t\ttoken = lcToken = isOpenQuote\n\t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n\t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n\t\t\t\t\tquotedIdentifier = isOpenQuote;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( !quotedIdentifier && ( dialect.openQuote()==token.charAt(0) ) ) {\n\t\t\t\t\tisOpenQuote = true;\n\t\t\t\t\tquotedIdentifier = true;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( quotedIdentifier && ( dialect.closeQuote()==token.charAt(0) ) ) {\n\t\t\t\t\tquotedIdentifier = false;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\telse if ( LITERAL_PREFIXES.contains( lcToken ) ) {\n\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n\t\t\t\t\t\t// Don't prefix a literal\n\t\t\t\t\t\tresult.append( token );\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) ) {\n\t\t\t\t\t\tfinal StringBuilder additionalTokens = new StringBuilder();\n\t\t\t\t\t\tTimeZoneTokens possibleNextToken = null;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tpossibleNextToken = possibleNextToken == null\n\t\t\t\t\t\t\t\t\t? TimeZoneTokens.getPossibleNextTokens( lcToken )\n\t\t\t\t\t\t\t\t\t: possibleNextToken.nextToken();\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tadditionalTokens.append( nextToken );\n\t\t\t\t\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\t\t\t\t\tnextToken = tokens.nextToken();\n\t\t\t\t\t\t\t} while ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) );\n\t\t\t\t\t\t} while ( nextToken != null && possibleNextToken.isToken( nextToken ) );\n\t\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n\t\t\t\t\t\t\t// Don't prefix a literal\n\t\t\t\t\t\t\tresult.append( token );\n\t\t\t\t\t\t\tresult.append( additionalTokens );\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\n\t\t\t\tif ( isOpenQuote ) {\n\t\t\t\t\tresult.append( placeholder ).append( '.' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Special processing for ANSI SQL EXTRACT function\n\t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n\t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n\t\t\t\tfinal String source = renderWhereStringTemplate(\n\t\t\t\t\t\textractUntil( tokens, \")\" ),\n\t\t\t\t\t\tplaceholder,\n\t\t\t\t\t\tdialect,\n\t\t\t\t\t\ttypeConfiguration,\n\t\t\t\t\t\tfunctionRegistry\n\t\t\t\t);\n\t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Special processing for ANSI SQL TRIM function\n\t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n\t\t\t\tList<String> operands = new ArrayList<>();\n\t\t\t\tStringBuilder builder = new StringBuilder();\n\n\t\t\t\tboolean hasMoreOperands = true;\n\t\t\t\tString operandToken = tokens.nextToken();\n\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\tcase \"leading\":\n\t\t\t\t\tcase \"trailing\":\n\t\t\t\t\tcase \"both\":\n\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n\t\t\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tboolean quotedOperand = false;\n\t\t\t\tint parenthesis = 0;\n\t\t\t\twhile ( hasMoreOperands ) {\n\t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n\t\t\t\t\tif ( isQuote ) {\n\t\t\t\t\t\tquotedOperand = !quotedOperand;\n\t\t\t\t\t\tif ( !quotedOperand ) {\n\t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbuilder.append( '\\'' );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if ( quotedOperand ) {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( parenthesis != 0 ) {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t\tswitch ( operandToken ) {\n\t\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"from\":\n\t\t\t\t\t\t\t\tif ( builder.length() != 0 ) {\n\t\t\t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n\t\t\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n\t\t\t\t}\n\t\t\t\tif ( builder.length() != 0 ) {\n\t\t\t\t\toperands.add( builder.toString() );\n\t\t\t\t}\n\n\t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n\t\t\t\tresult.append( \"trim(\" );\n\t\t\t\tif ( trimOperands.trimSpec != null ) {\n\t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n\t\t\t\t}\n\t\t\t\tif ( trimOperands.trimChar != null ) {\n\t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n\t\t\t\t\t\tresult.append( trimOperands.trimChar );\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresult.append(\n\t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tresult.append( ' ' );\n\t\t\t\t}\n\t\t\t\tif ( trimOperands.from != null ) {\n\t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n\t\t\t\t}\n\t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n\t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char is specified\n\t\t\t\t\tresult.append( \"from \" );\n\t\t\t\t}\n\n\t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, typeConfiguration, functionRegistry ) )\n\t\t\t\t\t\t.append( ')' );\n\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tboolean quotedOrWhitespace = quoted || quotedIdentifier || isQuoteCharacter\n\t\t\t\t\t|| Character.isWhitespace( token.charAt(0) );\n\n\t\t\tif ( quotedOrWhitespace ) {\n\t\t\t\tresult.append( token );\n\t\t\t}\n\t\t\telse if ( beforeTable ) {\n\t\t\t\tresult.append( token );\n\t\t\t\tbeforeTable = false;\n\t\t\t\tafterFromTable = true;\n\t\t\t}\n\t\t\telse if ( afterFromTable ) {\n\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n\t\t\t\t\tafterFromTable = false;\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isNamedParameter(token) ) {\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isIdentifier(token)\n\t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect, typeConfiguration, functionRegistry) ) {\n\t\t\t\tresult.append(placeholder)\n\t\t\t\t\t\t.append('.')\n\t\t\t\t\t\t.append( dialect.quote(token) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t\tinFromClause = true;\n\t\t\t\t}\n\t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t}\n\t\t\t\tif ( isBoolean( token ) ) {\n\t\t\t\t\ttoken = dialect.toBooleanValueString( Boolean.parseBoolean( token ) );\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\n\t\t\t//Yuck:\n\t\t\tif ( inFromClause\n\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n\t\t\t\tinFromClause = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result.toString();\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
        "isPureRefactoring": true,
        "commitId": "35f96d6e901dbd071b375d809521ef6f1c979868",
        "packageNameBefore": "org.hibernate.sql",
        "classNameBefore": "org.hibernate.sql.Template",
        "methodNameBefore": "org.hibernate.sql.Template#renderWhereStringTemplate",
        "invokedMethod": "methodSignature: org.hibernate.sql.Template#extractUntil\n methodBody: private static String extractUntil(StringTokenizer tokens, String delimiter) {\nStringBuilder valueBuilder=new StringBuilder();\nString token=tokens.nextToken();\nwhile(!delimiter.equalsIgnoreCase(token)){valueBuilder.append(token);\ntoken=tokens.nextToken();\n}return valueBuilder.toString().trim();\n}\nmethodSignature: org.hibernate.sql.Template#renderWhereStringTemplate\n methodBody: public static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\nString symbols=PUNCTUATION + WHITESPACE + dialect.openQuote() + dialect.closeQuote();\nStringTokenizer tokens=new StringTokenizer(sqlWhereString,symbols,true);\nStringBuilder result=new StringBuilder();\nboolean quoted=false;\nboolean quotedIdentifier=false;\nboolean beforeTable=false;\nboolean inFromClause=false;\nboolean afterFromTable=false;\nboolean hasMore=tokens.hasMoreTokens();\nString nextToken=hasMore ? tokens.nextToken() : null;\nwhile(hasMore){String token=nextToken;\nString lcToken=token.toLowerCase(Locale.ROOT);\nhasMore=tokens.hasMoreTokens();\nnextToken=hasMore ? tokens.nextToken() : null;\nboolean isQuoteCharacter=false;\nif(!quotedIdentifier && \"'\".equals(token)){quoted=!quoted;\nisQuoteCharacter=true;\n}if(!quoted){boolean isOpenQuote;\nif(\"`\".equals(token)){isOpenQuote=!quotedIdentifier;\ntoken=lcToken=isOpenQuote ? Character.toString(dialect.openQuote()) : Character.toString(dialect.closeQuote());\nquotedIdentifier=isOpenQuote;\nisQuoteCharacter=true;\n}if(!quotedIdentifier && (dialect.openQuote() == token.charAt(0))){isOpenQuote=true;\nquotedIdentifier=true;\nisQuoteCharacter=true;\n}if(quotedIdentifier && (dialect.closeQuote() == token.charAt(0))){quotedIdentifier=false;\nisQuoteCharacter=true;\nisOpenQuote=false;\n}if(LITERAL_PREFIXES.contains(lcToken)){if(\"'\".equals(nextToken)){result.append(token);\ncontinue;\n}if(nextToken != null && Character.isWhitespace(nextToken.charAt(0))){final StringBuilder additionalTokens=new StringBuilder();\nTimeZoneTokens possibleNextToken=null;\ndo(nextToken != null && possibleNextToken.isToken(nextToken)){possibleNextToken=possibleNextToken == null ? TimeZoneTokens.getPossibleNextTokens(lcToken) : possibleNextToken.nextToken();\ndo(nextToken != null && Character.isWhitespace(nextToken.charAt(0))){additionalTokens.append(nextToken);\nhasMore=tokens.hasMoreTokens();\nnextToken=tokens.nextToken();\n}}if(\"'\".equals(nextToken)){result.append(token);\nresult.append(additionalTokens);\ncontinue;\n}{isOpenQuote=false;\n}}{isOpenQuote=false;\n}}{isOpenQuote=false;\n}if(isOpenQuote){result.append(placeholder).append('.');\n}}if(\"extract\".equals(lcToken) && \"(\".equals(nextToken)){final String field=extractUntil(tokens,\"from\");\nfinal String source=renderWhereStringTemplate(extractUntil(tokens,\")\"),placeholder,dialect,typeConfiguration,functionRegistry);\nresult.append(\"extract(\").append(field).append(\" from \").append(source).append(')');\nhasMore=tokens.hasMoreTokens();\nnextToken=hasMore ? tokens.nextToken() : null;\ncontinue;\n}if(\"trim\".equals(lcToken) && \"(\".equals(nextToken)){List<String> operands=new ArrayList<>();\nStringBuilder builder=new StringBuilder();\nboolean hasMoreOperands=true;\nString operandToken=tokens.nextToken();\nswitch(operandToken.toLowerCase(Locale.ROOT))case \"leading\":case \"trailing\":case \"both\":operands.add(operandToken);\nif(hasMoreOperands=tokens.hasMoreTokens()){operandToken=tokens.nextToken();\n}break;\nboolean quotedOperand=false;\nint parenthesis=0;\nwhile(hasMoreOperands){final boolean isQuote=\"'\".equals(operandToken);\nif(isQuote){quotedOperand=!quotedOperand;\nif(!quotedOperand){operands.add(builder.append('\\'').toString());\nbuilder.setLength(0);\n}{builder.append('\\'');\n}}if(quotedOperand){builder.append(operandToken);\n}if(parenthesis != 0){builder.append(operandToken);\nswitch(operandToken)case \"(\":parenthesis++;\nbreak;\ncase \")\":parenthesis--;\nbreak;\n}{builder.append(operandToken);\nswitch(operandToken.toLowerCase(Locale.ROOT))case \"(\":parenthesis++;\nbreak;\ncase \")\":parenthesis--;\nbreak;\ncase \"from\":if(builder.length() != 0){operands.add(builder.substring(0,builder.length() - 4));\nbuilder.setLength(0);\noperands.add(operandToken);\n}break;\n}operandToken=tokens.nextToken();\nhasMoreOperands=tokens.hasMoreTokens() && (parenthesis != 0 || !\")\".equals(operandToken));\n}if(builder.length() != 0){operands.add(builder.toString());\n}TrimOperands trimOperands=new TrimOperands(operands);\nresult.append(\"trim(\");\nif(trimOperands.trimSpec != null){result.append(trimOperands.trimSpec).append(' ');\n}if(trimOperands.trimChar != null){if(trimOperands.trimChar.startsWith(\"'\") && trimOperands.trimChar.endsWith(\"'\")){result.append(trimOperands.trimChar);\n}{result.append(renderWhereStringTemplate(trimOperands.trimSpec,placeholder,dialect,typeConfiguration,functionRegistry));\n}result.append(' ');\n}if(trimOperands.from != null){result.append(trimOperands.from).append(' ');\n}if(trimOperands.trimSpec != null || trimOperands.trimChar != null){result.append(\"from \");\n}result.append(renderWhereStringTemplate(trimOperands.trimSource,placeholder,dialect,typeConfiguration,functionRegistry)).append(')');\nhasMore=tokens.hasMoreTokens();\nnextToken=hasMore ? tokens.nextToken() : null;\ncontinue;\n}boolean quotedOrWhitespace=quoted || quotedIdentifier || isQuoteCharacter || Character.isWhitespace(token.charAt(0));\nif(quotedOrWhitespace){result.append(token);\n}if(beforeTable){result.append(token);\nbeforeTable=false;\nafterFromTable=true;\n}if(afterFromTable){if(!\"as\".equals(lcToken)){afterFromTable=false;\n}result.append(token);\n}if(isNamedParameter(token)){result.append(token);\n}if(isIdentifier(token) && !isFunctionOrKeyword(lcToken,nextToken,dialect,typeConfiguration,functionRegistry)){result.append(placeholder).append('.').append(dialect.quote(token));\n}{if(BEFORE_TABLE_KEYWORDS.contains(lcToken)){beforeTable=true;\ninFromClause=true;\n}if(inFromClause && \",\".equals(lcToken)){beforeTable=true;\n}if(isBoolean(token)){token=dialect.toBooleanValueString(Boolean.parseBoolean(token));\n}result.append(token);\n}if(inFromClause && KEYWORDS.contains(lcToken) && !BEFORE_TABLE_KEYWORDS.contains(lcToken)){inFromClause=false;\n}}return result.toString();\n}\nmethodSignature: org.hibernate.sql.Template.TimeZoneTokens#isToken\n methodBody: public boolean isToken(String token) {\nreturn this != NONE && name().equalsIgnoreCase(token);\n}\nmethodSignature: org.hibernate.sql.Template#isBoolean\n methodBody: private static boolean isBoolean(String token) {\nreturn \"true\".equals(token) || \"false\".equals(token);\n}\nmethodSignature: org.hibernate.sql.Template.TimeZoneTokens#nextToken\n methodBody: public TimeZoneTokens nextToken() {\nif(this == WITH){return TIME;\n}if(this == TIME){return ZONE;\n}{return NONE;\n}}\nmethodSignature: org.hibernate.sql.Template.TimeZoneTokens#getPossibleNextTokens\n methodBody: static TimeZoneTokens getPossibleNextTokens(String lctoken) {\nswitch(lctoken)case \"time\":case \"timestamp\":return WITH;\ndefault:return NONE;\n}\nmethodSignature: org.hibernate.sql.Template#isIdentifier\n methodBody: private static boolean isIdentifier(String token) {\nif(isBoolean(token)){return false;\n}return token.charAt(0) == '`' || (Character.isLetter(token.charAt(0)) && token.indexOf('.') < 0);\n}\nmethodSignature: org.hibernate.sql.Template#isNamedParameter\n methodBody: private static boolean isNamedParameter(String token) {\nreturn token.startsWith(\":\");\n}\nmethodSignature: org.hibernate.sql.Template#isFunctionOrKeyword\n methodBody: private static boolean isFunctionOrKeyword(\n\t\t\tString lcToken,\n\t\t\tString nextToken,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\nreturn \"(\".equals(nextToken) || KEYWORDS.contains(lcToken) || isType(lcToken,typeConfiguration) || isFunction(lcToken,nextToken,functionRegistry) || dialect.getKeywords().contains(lcToken) || FUNCTION_KEYWORDS.contains(lcToken);\n}",
        "classSignatureBefore": "public final class Template ",
        "methodNameBeforeSet": [
            "org.hibernate.sql.Template#renderWhereStringTemplate"
        ],
        "classNameBeforeSet": [
            "org.hibernate.sql.Template"
        ],
        "classSignatureBeforeSet": [
            "public final class Template "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.sql;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.query.sqm.function.SqmFunctionDescriptor;\nimport org.hibernate.query.sqm.function.SqmFunctionRegistry;\nimport org.hibernate.type.spi.TypeConfiguration;\n\nimport static org.hibernate.internal.util.StringHelper.WHITESPACE;\n\n/**\n * Parses SQL fragments specified in mapping documents.\n *\n * @author Gavin King\n */\npublic final class Template {\n\n\tprivate static final Set<String> KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> BEFORE_TABLE_KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> FUNCTION_KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> LITERAL_PREFIXES = new HashSet<>();\n\tpublic static final String PUNCTUATION = \"=><!+-*/()',|&`\";\n\n\tstatic {\n\t\tKEYWORDS.add(\"and\");\n\t\tKEYWORDS.add(\"or\");\n\t\tKEYWORDS.add(\"not\");\n\t\tKEYWORDS.add(\"like\");\n\t\tKEYWORDS.add(\"escape\");\n\t\tKEYWORDS.add(\"is\");\n\t\tKEYWORDS.add(\"in\");\n\t\tKEYWORDS.add(\"between\");\n\t\tKEYWORDS.add(\"null\");\n\t\tKEYWORDS.add(\"select\");\n\t\tKEYWORDS.add(\"distinct\");\n\t\tKEYWORDS.add(\"from\");\n\t\tKEYWORDS.add(\"join\");\n\t\tKEYWORDS.add(\"inner\");\n\t\tKEYWORDS.add(\"outer\");\n\t\tKEYWORDS.add(\"left\");\n\t\tKEYWORDS.add(\"right\");\n\t\tKEYWORDS.add(\"on\");\n\t\tKEYWORDS.add(\"where\");\n\t\tKEYWORDS.add(\"having\");\n\t\tKEYWORDS.add(\"group\");\n\t\tKEYWORDS.add(\"order\");\n\t\tKEYWORDS.add(\"by\");\n\t\tKEYWORDS.add(\"desc\");\n\t\tKEYWORDS.add(\"asc\");\n\t\tKEYWORDS.add(\"limit\");\n\t\tKEYWORDS.add(\"any\");\n\t\tKEYWORDS.add(\"some\");\n\t\tKEYWORDS.add(\"exists\");\n\t\tKEYWORDS.add(\"all\");\n\t\tKEYWORDS.add(\"union\");\n\t\tKEYWORDS.add(\"minus\");\n\t\tKEYWORDS.add(\"except\");\n\t\tKEYWORDS.add(\"intersect\");\n\t\tKEYWORDS.add(\"partition\");\n\n\t\tBEFORE_TABLE_KEYWORDS.add(\"from\");\n\t\tBEFORE_TABLE_KEYWORDS.add(\"join\");\n\n\t\tFUNCTION_KEYWORDS.add(\"as\");\n\t\tFUNCTION_KEYWORDS.add(\"leading\");\n\t\tFUNCTION_KEYWORDS.add(\"trailing\");\n\t\tFUNCTION_KEYWORDS.add(\"from\");\n\t\tFUNCTION_KEYWORDS.add(\"case\");\n\t\tFUNCTION_KEYWORDS.add(\"when\");\n\t\tFUNCTION_KEYWORDS.add(\"then\");\n\t\tFUNCTION_KEYWORDS.add(\"else\");\n\t\tFUNCTION_KEYWORDS.add(\"end\");\n\n\t\tLITERAL_PREFIXES.add(\"n\");\n\t\tLITERAL_PREFIXES.add(\"x\");\n\t\tLITERAL_PREFIXES.add(\"varbyte\");\n\t\tLITERAL_PREFIXES.add(\"bx\");\n\t\tLITERAL_PREFIXES.add(\"bytea\");\n\t\tLITERAL_PREFIXES.add(\"date\");\n\t\tLITERAL_PREFIXES.add(\"time\");\n\t\tLITERAL_PREFIXES.add(\"timestamp\");\n\t}\n\n\tpublic static final String TEMPLATE = \"$PlaceHolder$\";\n\n\tprivate Template() {}\n\n\tpublic static String renderTransformerReadFragment(\n\t\t\tString fragment,\n\t\t\tString... columnNames) {\n\t\t// NOTE : would need access to SessionFactoryImplementor to make this configurable\n\t\tfor ( String columnName : columnNames ) {\n\t\t\tfragment = fragment.replace( columnName, TEMPLATE + '.' + columnName );\n\t\t}\n\t\treturn fragment;\n\t}\n\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn renderWhereStringTemplate( sqlWhereString, TEMPLATE, dialect, typeConfiguration, functionRegistry );\n\t}\n\n\t/**\n\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n\t * named parameters.\n\t *\n\t * @param sqlWhereString The string into which to interpolate the placeholder value\n\t * @param placeholder The value to be interpolated into the sqlWhereString\n\t * @param dialect The dialect to apply\n\t * @param functionRegistry The registry of all sql functions\n\t * @return The rendered sql fragment\n\t */\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\n\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n\t\t//\t\tidentifier references.\n\n\t\tString symbols = PUNCTUATION +\n\t\t\t\tWHITESPACE +\n\t\t\t\tdialect.openQuote() +\n\t\t\t\tdialect.closeQuote();\n\t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n\t\tStringBuilder result = new StringBuilder();\n\n\t\tboolean quoted = false;\n\t\tboolean quotedIdentifier = false;\n\t\tboolean beforeTable = false;\n\t\tboolean inFromClause = false;\n\t\tboolean afterFromTable = false;\n\n\t\tboolean hasMore = tokens.hasMoreTokens();\n\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n\t\twhile ( hasMore ) {\n\t\t\tString token = nextToken;\n\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\tboolean isQuoteCharacter = false;\n\n\t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n\t\t\t\tquoted = !quoted;\n\t\t\t\tisQuoteCharacter = true;\n\t\t\t}\n\n\t\t\tif ( !quoted ) {\n\t\t\t\tboolean isOpenQuote;\n\t\t\t\tif ( \"`\".equals(token) ) {\n\t\t\t\t\tisOpenQuote = !quotedIdentifier;\n\t\t\t\t\ttoken = lcToken = isOpenQuote\n\t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n\t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n\t\t\t\t\tquotedIdentifier = isOpenQuote;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( !quotedIdentifier && ( dialect.openQuote()==token.charAt(0) ) ) {\n\t\t\t\t\tisOpenQuote = true;\n\t\t\t\t\tquotedIdentifier = true;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( quotedIdentifier && ( dialect.closeQuote()==token.charAt(0) ) ) {\n\t\t\t\t\tquotedIdentifier = false;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\telse if ( LITERAL_PREFIXES.contains( lcToken ) ) {\n\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n\t\t\t\t\t\t// Don't prefix a literal\n\t\t\t\t\t\tresult.append( token );\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) ) {\n\t\t\t\t\t\tfinal StringBuilder additionalTokens = new StringBuilder();\n\t\t\t\t\t\tTimeZoneTokens possibleNextToken = null;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tpossibleNextToken = possibleNextToken == null\n\t\t\t\t\t\t\t\t\t? TimeZoneTokens.getPossibleNextTokens( lcToken )\n\t\t\t\t\t\t\t\t\t: possibleNextToken.nextToken();\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tadditionalTokens.append( nextToken );\n\t\t\t\t\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\t\t\t\t\tnextToken = tokens.nextToken();\n\t\t\t\t\t\t\t} while ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) );\n\t\t\t\t\t\t} while ( nextToken != null && possibleNextToken.isToken( nextToken ) );\n\t\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n\t\t\t\t\t\t\t// Don't prefix a literal\n\t\t\t\t\t\t\tresult.append( token );\n\t\t\t\t\t\t\tresult.append( additionalTokens );\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\n\t\t\t\tif ( isOpenQuote ) {\n\t\t\t\t\tresult.append( placeholder ).append( '.' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Special processing for ANSI SQL EXTRACT function\n\t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n\t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n\t\t\t\tfinal String source = renderWhereStringTemplate(\n\t\t\t\t\t\textractUntil( tokens, \")\" ),\n\t\t\t\t\t\tplaceholder,\n\t\t\t\t\t\tdialect,\n\t\t\t\t\t\ttypeConfiguration,\n\t\t\t\t\t\tfunctionRegistry\n\t\t\t\t);\n\t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Special processing for ANSI SQL TRIM function\n\t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n\t\t\t\tList<String> operands = new ArrayList<>();\n\t\t\t\tStringBuilder builder = new StringBuilder();\n\n\t\t\t\tboolean hasMoreOperands = true;\n\t\t\t\tString operandToken = tokens.nextToken();\n\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\tcase \"leading\":\n\t\t\t\t\tcase \"trailing\":\n\t\t\t\t\tcase \"both\":\n\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n\t\t\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tboolean quotedOperand = false;\n\t\t\t\tint parenthesis = 0;\n\t\t\t\twhile ( hasMoreOperands ) {\n\t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n\t\t\t\t\tif ( isQuote ) {\n\t\t\t\t\t\tquotedOperand = !quotedOperand;\n\t\t\t\t\t\tif ( !quotedOperand ) {\n\t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbuilder.append( '\\'' );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if ( quotedOperand ) {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( parenthesis != 0 ) {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t\tswitch ( operandToken ) {\n\t\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"from\":\n\t\t\t\t\t\t\t\tif ( builder.length() != 0 ) {\n\t\t\t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n\t\t\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n\t\t\t\t}\n\t\t\t\tif ( builder.length() != 0 ) {\n\t\t\t\t\toperands.add( builder.toString() );\n\t\t\t\t}\n\n\t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n\t\t\t\tresult.append( \"trim(\" );\n\t\t\t\tif ( trimOperands.trimSpec != null ) {\n\t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n\t\t\t\t}\n\t\t\t\tif ( trimOperands.trimChar != null ) {\n\t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n\t\t\t\t\t\tresult.append( trimOperands.trimChar );\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresult.append(\n\t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tresult.append( ' ' );\n\t\t\t\t}\n\t\t\t\tif ( trimOperands.from != null ) {\n\t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n\t\t\t\t}\n\t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n\t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char is specified\n\t\t\t\t\tresult.append( \"from \" );\n\t\t\t\t}\n\n\t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, typeConfiguration, functionRegistry ) )\n\t\t\t\t\t\t.append( ')' );\n\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tboolean quotedOrWhitespace = quoted || quotedIdentifier || isQuoteCharacter\n\t\t\t\t\t|| Character.isWhitespace( token.charAt(0) );\n\n\t\t\tif ( quotedOrWhitespace ) {\n\t\t\t\tresult.append( token );\n\t\t\t}\n\t\t\telse if ( beforeTable ) {\n\t\t\t\tresult.append( token );\n\t\t\t\tbeforeTable = false;\n\t\t\t\tafterFromTable = true;\n\t\t\t}\n\t\t\telse if ( afterFromTable ) {\n\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n\t\t\t\t\tafterFromTable = false;\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isNamedParameter(token) ) {\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isIdentifier(token)\n\t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect, typeConfiguration, functionRegistry) ) {\n\t\t\t\tresult.append(placeholder)\n\t\t\t\t\t\t.append('.')\n\t\t\t\t\t\t.append( dialect.quote(token) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t\tinFromClause = true;\n\t\t\t\t}\n\t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t}\n\t\t\t\tif ( isBoolean( token ) ) {\n\t\t\t\t\ttoken = dialect.toBooleanValueString( Boolean.parseBoolean( token ) );\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\n\t\t\t//Yuck:\n\t\t\tif ( inFromClause\n\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n\t\t\t\tinFromClause = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result.toString();\n\t}\n\n\tprivate enum TimeZoneTokens {\n\t\tNONE,\n\t\tWITH,\n\t\tTIME,\n\t\tZONE;\n\n\t\tstatic TimeZoneTokens getPossibleNextTokens(String lctoken) {\n\t\t\tswitch ( lctoken ) {\n\t\t\t\tcase \"time\":\n\t\t\t\tcase \"timestamp\":\n\t\t\t\t\treturn WITH;\n\t\t\t\tdefault:\n\t\t\t\t\treturn NONE;\n\t\t\t}\n\t\t}\n\n\t\tpublic TimeZoneTokens nextToken() {\n\t\t\tif ( this == WITH ) {\n\t\t\t\treturn TIME;\n\t\t\t}\n\t\t\telse if ( this == TIME ) {\n\t\t\t\treturn ZONE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn NONE;\n\t\t\t}\n\t\t}\n\n\t\tpublic boolean isToken(String token) {\n\t\t\treturn this != NONE && name().equalsIgnoreCase( token );\n\t\t}\n\t}\n\n\tpublic static List<String> collectColumnNames(\n\t\t\tString sql,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn collectColumnNames( renderWhereStringTemplate( sql, dialect, typeConfiguration, functionRegistry ) );\n\t}\n\n\tpublic static List<String> collectColumnNames(String template) {\n\t\tfinal List<String> names = new ArrayList<>();\n\t\tint begin = 0;\n\t\tint match;\n\t\twhile ( ( match = template.indexOf(TEMPLATE, begin) ) >= 0 ) {\n\t\t\tint start = match + TEMPLATE.length() + 1;\n\t\t\tfor ( int loc = start;; loc++ ) {\n\t\t\t\tif ( loc == template.length() - 1 ) {\n\t\t\t\t\tnames.add( template.substring( start ) );\n\t\t\t\t\tbegin = template.length();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar ch = template.charAt( loc );\n\t\t\t\t\tif ( PUNCTUATION.indexOf(ch) >= 0 || WHITESPACE.indexOf(ch) >= 0 ) {\n\t\t\t\t\t\tnames.add( template.substring( start, loc ) );\n\t\t\t\t\t\tbegin = loc;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn names;\n\t}\n\n//\t/**\n//\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n//\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n//\t * named parameters.\n//\t *\n//\t * @param sqlWhereString The string into which to interpolate the placeholder value\n//\t * @param placeholder The value to be interpolated into the sqlWhereString\n//\t * @param dialect The dialect to apply\n//\t * @param functionRegistry The registry of all sql functions\n//\t *\n//\t * @return The rendered sql fragment\n//\t */\n//\tpublic static String renderWhereStringTemplate(\n//\t\t\tString sqlWhereString,\n//\t\t\tString placeholder,\n//\t\t\tDialect dialect,\n//\t\t\tSQLFunctionRegistry functionRegistry) {\n//\n//\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n//\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n//\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n//\t\t//\t\tidentifier references.\n//\n//\t\tfinal String dialectOpenQuote = Character.toString( dialect.openQuote() );\n//\t\tfinal String dialectCloseQuote = Character.toString( dialect.closeQuote() );\n//\n//\t\tString symbols = new StringBuilder()\n//\t\t\t\t.append( \"=><!+-*/()',|&`\" )\n//\t\t\t\t.append( StringHelper.WHITESPACE )\n//\t\t\t\t.append( dialect.openQuote() )\n//\t\t\t\t.append( dialect.closeQuote() )\n//\t\t\t\t.toString();\n//\t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n//\t\tProcessingState state = new ProcessingState();\n//\n//\t\tStringBuilder quotedBuffer = new StringBuilder();\n//\t\tStringBuilder result = new StringBuilder();\n//\n//\t\tboolean hasMore = tokens.hasMoreTokens();\n//\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n//\t\twhile ( hasMore ) {\n//\t\t\tString token = nextToken;\n//\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n//\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t// First, determine quoting which might be based on either:\n//\t\t\t// \t\t1) back-tick\n//\t\t\t// \t\t2) single quote (ANSI SQL standard)\n//\t\t\t// \t\t3) or dialect defined quote character(s)\n//\t\t\tQuotingCharacterDisposition quotingCharacterDisposition = QuotingCharacterDisposition.NONE;\n//\t\t\tif ( \"`\".equals( token ) ) {\n//\t\t\t\tstate.quoted = !state.quoted;\n//\t\t\t\tquotingCharacterDisposition = state.quoted\n//\t\t\t\t\t\t? QuotingCharacterDisposition.OPEN\n//\t\t\t\t\t\t: QuotingCharacterDisposition.CLOSE;\n//\t\t\t\t// replace token with the appropriate dialect quoting char\n//\t\t\t\ttoken = lcToken = ( quotingCharacterDisposition == QuotingCharacterDisposition.OPEN )\n//\t\t\t\t\t\t? dialectOpenQuote\n//\t\t\t\t\t\t: dialectCloseQuote;\n//\t\t\t}\n//\t\t\telse if ( \"'\".equals( token ) ) {\n//\t\t\t\tstate.quoted = !state.quoted;\n//\t\t\t\tquotingCharacterDisposition = state.quoted\n//\t\t\t\t\t\t? QuotingCharacterDisposition.OPEN\n//\t\t\t\t\t\t: QuotingCharacterDisposition.CLOSE;\n//\t\t\t}\n//\t\t\telse if ( !state.quoted && dialectOpenQuote.equals( token ) ) {\n//\t\t\t\tstate.quoted = true;\n//\t\t\t\tquotingCharacterDisposition = QuotingCharacterDisposition.OPEN;\n//\t\t\t}\n//\t\t\telse if ( state.quoted && dialectCloseQuote.equals( token ) ) {\n//\t\t\t\tstate.quoted = false;\n//\t\t\t\tquotingCharacterDisposition = QuotingCharacterDisposition.CLOSE;\n//\t\t\t}\n//\n//\t\t\tif ( state.quoted ) {\n//\t\t\t\tquotedBuffer.append( token );\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// if we were previously processing quoted state and just encountered the close quote, then handle that\n//\t\t\t// quoted text\n//\t\t\tif ( quotingCharacterDisposition == QuotingCharacterDisposition.CLOSE ) {\n//\t\t\t\ttoken = quotedBuffer.toString();\n//\t\t\t\tquotedBuffer.setLength( 0 );\n//\t\t\t\tresult.append( placeholder ).append( '.' )\n//\t\t\t\t\t\t.append( dialectOpenQuote ).append( token ).append( dialectCloseQuote );\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// Special processing for ANSI SQL EXTRACT function\n//\t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n//\t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n//\t\t\t\tfinal String source = renderWhereStringTemplate(\n//\t\t\t\t\t\textractUntil( tokens, \")\" ),\n//\t\t\t\t\t\tplaceholder,\n//\t\t\t\t\t\tdialect,\n//\t\t\t\t\t\tfunctionRegistry\n//\t\t\t\t);\n//\t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n//\n//\t\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// Special processing for ANSI SQL TRIM function\n//\t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n//\t\t\t\tList<String> operands = new ArrayList<String>();\n//\t\t\t\tStringBuilder builder = new StringBuilder();\n//\n//\t\t\t\tboolean hasMoreOperands = true;\n//\t\t\t\tString operandToken = tokens.nextToken();\n//\t\t\t\tboolean quoted = false;\n//\t\t\t\twhile ( hasMoreOperands ) {\n//\t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n//\t\t\t\t\tif ( isQuote ) {\n//\t\t\t\t\t\tquoted = !quoted;\n//\t\t\t\t\t\tif ( !quoted ) {\n//\t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n//\t\t\t\t\t\t\tbuilder.setLength( 0 );\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse {\n//\t\t\t\t\t\t\tbuilder.append( '\\'' );\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t\telse if ( quoted ) {\n//\t\t\t\t\t\tbuilder.append( operandToken );\n//\t\t\t\t\t}\n//\t\t\t\t\telse if ( operandToken.length() == 1 && Character.isWhitespace( operandToken.charAt( 0 ) ) ) {\n//\t\t\t\t\t\t// do nothing\n//\t\t\t\t\t}\n//\t\t\t\t\telse {\n//\t\t\t\t\t\toperands.add( operandToken );\n//\t\t\t\t\t}\n//\t\t\t\t\toperandToken = tokens.nextToken();\n//\t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ! \")\".equals( operandToken );\n//\t\t\t\t}\n//\n//\t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n//\t\t\t\tresult.append( \"trim(\" );\n//\t\t\t\tif ( trimOperands.trimSpec != null ) {\n//\t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n//\t\t\t\t}\n//\t\t\t\tif ( trimOperands.trimChar != null ) {\n//\t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n//\t\t\t\t\t\tresult.append( trimOperands.trimChar );\n//\t\t\t\t\t}\n//\t\t\t\t\telse {\n//\t\t\t\t\t\tresult.append(\n//\t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, functionRegistry )\n//\t\t\t\t\t\t);\n//\t\t\t\t\t}\n//\t\t\t\t\tresult.append( ' ' );\n//\t\t\t\t}\n//\t\t\t\tif ( trimOperands.from != null ) {\n//\t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n//\t\t\t\t}\n//\t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n//\t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char are specified\n//\t\t\t\t\tresult.append( \"from \" );\n//\t\t\t\t}\n//\n//\t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, functionRegistry ) )\n//\t\t\t\t\t\t.append( ')' );\n//\n//\t\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\n//\t\t\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\n//\t\t\tif ( Character.isWhitespace( token.charAt( 0 ) ) ) {\n//\t\t\t\tresult.append( token );\n//\t\t\t}\n//\t\t\telse if ( state.beforeTable ) {\n//\t\t\t\tresult.append( token );\n//\t\t\t\tstate.beforeTable = false;\n//\t\t\t\tstate.afterFromTable = true;\n//\t\t\t}\n//\t\t\telse if ( state.afterFromTable ) {\n//\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n//\t\t\t\t\tstate.afterFromTable = false;\n//\t\t\t\t}\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\t\t\telse if ( isNamedParameter(token) ) {\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\t\t\telse if ( isIdentifier(token, dialect)\n//\t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect , functionRegistry) ) {\n//\t\t\t\tresult.append(placeholder)\n//\t\t\t\t\t\t.append('.')\n//\t\t\t\t\t\t.append( dialect.quote(token) );\n//\t\t\t}\n//\t\t\telse {\n//\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n//\t\t\t\t\tstate.beforeTable = true;\n//\t\t\t\t\tstate.inFromClause = true;\n//\t\t\t\t}\n//\t\t\t\telse if ( state.inFromClause && \",\".equals(lcToken) ) {\n//\t\t\t\t\tstate.beforeTable = true;\n//\t\t\t\t}\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\n//\t\t\t//Yuck:\n//\t\t\tif ( state.inFromClause\n//\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n//\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n//\t\t\t\tstate.inFromClause = false;\n//\t\t\t}\n//\t\t}\n//\n//\t\treturn result.toString();\n//\t}\n//\n//\tprivate static class ProcessingState {\n//\t\tboolean quoted = false;\n//\t\tboolean quotedIdentifier = false;\n//\t\tboolean beforeTable = false;\n//\t\tboolean inFromClause = false;\n//\t\tboolean afterFromTable = false;\n//\t}\n//\n//\tprivate static enum QuotingCharacterDisposition { NONE, OPEN, CLOSE }\n\n\tprivate static class TrimOperands {\n\t\tprivate final String trimSpec;\n\t\tprivate final String trimChar;\n\t\tprivate final String from;\n\t\tprivate final String trimSource;\n\n\t\tprivate TrimOperands(List<String> operands) {\n\t\t\tfinal int size = operands.size();\n\t\t\tif ( size == 1 ) {\n\t\t\t\ttrimSpec = null;\n\t\t\t\ttrimChar = null;\n\t\t\t\tfrom = null;\n\t\t\t\ttrimSource = operands.get(0);\n\t\t\t}\n\t\t\telse if ( size == 4 ) {\n\t\t\t\ttrimSpec = operands.get(0);\n\t\t\t\ttrimChar = operands.get(1);\n\t\t\t\tfrom = operands.get(2);\n\t\t\t\ttrimSource = operands.get(3);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( size < 1 || size > 4 ) {\n\t\t\t\t\tthrow new HibernateException( \"Unexpected number of trim function operands : \" + size );\n\t\t\t\t}\n\n\t\t\t\t// trim-source will always be the last operand\n\t\t\t\ttrimSource = operands.get( size - 1 );\n\n\t\t\t\t// ANSI SQL says that more than one operand means that the FROM is required\n\t\t\t\tif ( ! \"from\".equals( operands.get( size - 2 ) ) ) {\n\t\t\t\t\tthrow new HibernateException( \"Expecting FROM, found : \" + operands.get( size - 2 ) );\n\t\t\t\t}\n\t\t\t\tfrom = operands.get( size - 2 );\n\n\t\t\t\t// trim-spec, if there is one will always be the first operand\n\t\t\t\tif ( \"leading\".equalsIgnoreCase( operands.get(0) )\n\t\t\t\t\t\t|| \"trailing\".equalsIgnoreCase( operands.get(0) )\n\t\t\t\t\t\t|| \"both\".equalsIgnoreCase( operands.get(0) ) ) {\n\t\t\t\t\ttrimSpec = operands.get(0);\n\t\t\t\t\ttrimChar = null;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttrimSpec = null;\n\t\t\t\t\tif ( size - 2 == 0 ) {\n\t\t\t\t\t\ttrimChar = null;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttrimChar = operands.get( 0 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static String extractUntil(StringTokenizer tokens, String delimiter) {\n\t\tStringBuilder valueBuilder = new StringBuilder();\n\t\tString token = tokens.nextToken();\n\t\twhile ( ! delimiter.equalsIgnoreCase( token ) ) {\n\t\t\tvalueBuilder.append( token );\n\t\t\ttoken = tokens.nextToken();\n\t\t}\n\t\treturn valueBuilder.toString().trim();\n\t}\n\n\tprivate static boolean isNamedParameter(String token) {\n\t\treturn token.startsWith( \":\" );\n\t}\n\n\tprivate static boolean isFunctionOrKeyword(\n\t\t\tString lcToken,\n\t\t\tString nextToken,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn \"(\".equals( nextToken ) ||\n\t\t\t\tKEYWORDS.contains( lcToken ) ||\n\t\t\t\tisType( lcToken, typeConfiguration ) ||\n\t\t\t\tisFunction( lcToken, nextToken, functionRegistry ) ||\n\t\t\t\tdialect.getKeywords().contains( lcToken ) ||\n\t\t\t\tFUNCTION_KEYWORDS.contains( lcToken );\n\t}\n\n\tprivate static boolean isType(String lcToken, TypeConfiguration typeConfiguration) {\n\t\treturn typeConfiguration.getDdlTypeRegistry().isTypeNameRegistered( lcToken );\n\t}\n\n\tprivate static boolean isFunction(String lcToken, String nextToken, SqmFunctionRegistry functionRegistry) {\n\t\t// checking for \"(\" is currently redundant because it is checked before getting here;\n\t\t// doing the check anyhow, in case that earlier check goes away;\n\t\tif ( \"(\".equals( nextToken ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tfinal SqmFunctionDescriptor function = functionRegistry.findFunctionDescriptor( lcToken );\n\t\treturn function != null;\n\t}\n\n\tprivate static boolean isIdentifier(String token) {\n\t\tif ( isBoolean( token ) ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn token.charAt( 0 ) == '`' || ( //allow any identifier quoted with backtick\n\t\t\t\tCharacter.isLetter( token.charAt( 0 ) ) && //only recognizes identifiers beginning with a letter\n\t\t\t\t\t\ttoken.indexOf( '.' ) < 0\n\t\t);\n\t}\n\n\tprivate static boolean isBoolean(String token) {\n\t\treturn \"true\".equals( token ) || \"false\".equals( token );\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.sql;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.query.sqm.function.SqmFunctionDescriptor;\nimport org.hibernate.query.sqm.function.SqmFunctionRegistry;\nimport org.hibernate.type.spi.TypeConfiguration;\n\nimport static java.lang.Boolean.parseBoolean;\nimport static java.lang.Character.isLetter;\nimport static org.hibernate.internal.util.StringHelper.WHITESPACE;\n\n/**\n * Parses SQL fragments specified in mapping documents.\n *\n * @author Gavin King\n */\npublic final class Template {\n\n\tprivate static final Set<String> KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> BEFORE_TABLE_KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> FUNCTION_KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> LITERAL_PREFIXES = new HashSet<>();\n\tpublic static final String PUNCTUATION = \"=><!+-*/()',|&`\";\n\n\tstatic {\n\t\tKEYWORDS.add(\"and\");\n\t\tKEYWORDS.add(\"or\");\n\t\tKEYWORDS.add(\"not\");\n\t\tKEYWORDS.add(\"like\");\n\t\tKEYWORDS.add(\"escape\");\n\t\tKEYWORDS.add(\"is\");\n\t\tKEYWORDS.add(\"in\");\n\t\tKEYWORDS.add(\"between\");\n\t\tKEYWORDS.add(\"null\");\n\t\tKEYWORDS.add(\"select\");\n\t\tKEYWORDS.add(\"distinct\");\n\t\tKEYWORDS.add(\"from\");\n\t\tKEYWORDS.add(\"join\");\n\t\tKEYWORDS.add(\"inner\");\n\t\tKEYWORDS.add(\"outer\");\n\t\tKEYWORDS.add(\"left\");\n\t\tKEYWORDS.add(\"right\");\n\t\tKEYWORDS.add(\"on\");\n\t\tKEYWORDS.add(\"where\");\n\t\tKEYWORDS.add(\"having\");\n\t\tKEYWORDS.add(\"group\");\n\t\tKEYWORDS.add(\"order\");\n\t\tKEYWORDS.add(\"by\");\n\t\tKEYWORDS.add(\"desc\");\n\t\tKEYWORDS.add(\"asc\");\n\t\tKEYWORDS.add(\"limit\");\n\t\tKEYWORDS.add(\"any\");\n\t\tKEYWORDS.add(\"some\");\n\t\tKEYWORDS.add(\"exists\");\n\t\tKEYWORDS.add(\"all\");\n\t\tKEYWORDS.add(\"union\");\n\t\tKEYWORDS.add(\"minus\");\n\t\tKEYWORDS.add(\"except\");\n\t\tKEYWORDS.add(\"intersect\");\n\t\tKEYWORDS.add(\"partition\");\n\n\t\tBEFORE_TABLE_KEYWORDS.add(\"from\");\n\t\tBEFORE_TABLE_KEYWORDS.add(\"join\");\n\n\t\tFUNCTION_KEYWORDS.add(\"as\");\n\t\tFUNCTION_KEYWORDS.add(\"leading\");\n\t\tFUNCTION_KEYWORDS.add(\"trailing\");\n\t\tFUNCTION_KEYWORDS.add(\"from\");\n\t\tFUNCTION_KEYWORDS.add(\"case\");\n\t\tFUNCTION_KEYWORDS.add(\"when\");\n\t\tFUNCTION_KEYWORDS.add(\"then\");\n\t\tFUNCTION_KEYWORDS.add(\"else\");\n\t\tFUNCTION_KEYWORDS.add(\"end\");\n\n\t\tLITERAL_PREFIXES.add(\"n\");\n\t\tLITERAL_PREFIXES.add(\"x\");\n\t\tLITERAL_PREFIXES.add(\"varbyte\");\n\t\tLITERAL_PREFIXES.add(\"bx\");\n\t\tLITERAL_PREFIXES.add(\"bytea\");\n\t\tLITERAL_PREFIXES.add(\"date\");\n\t\tLITERAL_PREFIXES.add(\"time\");\n\t\tLITERAL_PREFIXES.add(\"timestamp\");\n\t\tLITERAL_PREFIXES.add(\"zone\");\n\t}\n\n\tpublic static final String TEMPLATE = \"$PlaceHolder$\";\n\n\tprivate Template() {}\n\n\tpublic static String renderTransformerReadFragment(\n\t\t\tString fragment,\n\t\t\tString... columnNames) {\n\t\t// NOTE : would need access to SessionFactoryImplementor to make this configurable\n\t\tfor ( String columnName : columnNames ) {\n\t\t\tfragment = fragment.replace( columnName, TEMPLATE + '.' + columnName );\n\t\t}\n\t\treturn fragment;\n\t}\n\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn renderWhereStringTemplate( sqlWhereString, TEMPLATE, dialect, typeConfiguration, functionRegistry );\n\t}\n\n\t/**\n\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n\t * named parameters.\n\t *\n\t * @param sqlWhereString The string into which to interpolate the placeholder value\n\t * @param placeholder The value to be interpolated into the sqlWhereString\n\t * @param dialect The dialect to apply\n\t * @param functionRegistry The registry of all sql functions\n\t * @return The rendered sql fragment\n\t */\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\n\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n\t\t//\t\tidentifier references.\n\n\t\tfinal String symbols = PUNCTUATION + WHITESPACE + dialect.openQuote() + dialect.closeQuote();\n\t\tfinal StringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n\t\tfinal StringBuilder result = new StringBuilder();\n\n\t\tboolean quoted = false;\n\t\tboolean quotedIdentifier = false;\n\t\tboolean beforeTable = false;\n\t\tboolean inFromClause = false;\n\t\tboolean afterFromTable = false;\n\n\t\tboolean hasMore = tokens.hasMoreTokens();\n\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n\t\twhile ( hasMore ) {\n\t\t\tString token = nextToken;\n\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\tboolean isQuoteCharacter = false;\n\n\t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n\t\t\t\tquoted = !quoted;\n\t\t\t\tisQuoteCharacter = true;\n\t\t\t}\n\n\t\t\tif ( !quoted ) {\n\t\t\t\tfinal boolean isOpenQuote;\n\t\t\t\tif ( \"`\".equals(token) ) {\n\t\t\t\t\tisOpenQuote = !quotedIdentifier;\n\t\t\t\t\ttoken = lcToken = isOpenQuote\n\t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n\t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n\t\t\t\t\tquotedIdentifier = isOpenQuote;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( !quotedIdentifier && dialect.openQuote()==token.charAt(0) ) {\n\t\t\t\t\tisOpenQuote = true;\n\t\t\t\t\tquotedIdentifier = true;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( quotedIdentifier && dialect.closeQuote()==token.charAt(0) ) {\n\t\t\t\t\tquotedIdentifier = false;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\tif ( isOpenQuote ) {\n\t\t\t\t\tresult.append( placeholder ).append( '.' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinal boolean quotedOrWhitespace =\n\t\t\t\t\tquoted || quotedIdentifier || isQuoteCharacter\n\t\t\t\t\t\t\t|| token.isBlank();\n\t\t\tif ( quotedOrWhitespace ) {\n\t\t\t\tresult.append( token );\n\t\t\t}\n\t\t\telse if ( beforeTable ) {\n\t\t\t\tresult.append( token );\n\t\t\t\tbeforeTable = false;\n\t\t\t\tafterFromTable = true;\n\t\t\t}\n\t\t\telse if ( afterFromTable ) {\n\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n\t\t\t\t\tafterFromTable = false;\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isNamedParameter(token) ) {\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isExtractFunction( lcToken, nextToken ) ) {\n\t\t\t\t// Special processing for ANSI SQL EXTRACT function\n\t\t\t\thandleExtractFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\t\t\t}\n\t\t\telse if ( isTrimFunction( lcToken, nextToken ) ) {\n\t\t\t\t// Special processing for ANSI SQL TRIM function\n\t\t\t\thandleTrimFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\t\t\t}\n\t\t\telse if ( isIdentifier(token)\n\t\t\t\t\t&& !isFunctionOrKeyword( lcToken, nextToken, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t\t&& !isLiteral( lcToken, nextToken, sqlWhereString, symbols, tokens ) ) {\n\t\t\t\tresult.append(placeholder)\n\t\t\t\t\t\t.append('.')\n\t\t\t\t\t\t.append( dialect.quote(token) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t\tinFromClause = true;\n\t\t\t\t}\n\t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t}\n\t\t\t\tif ( isBoolean( token ) ) {\n\t\t\t\t\ttoken = dialect.toBooleanValueString( parseBoolean( token ) );\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\n\t\t\t//Yuck:\n\t\t\tif ( inFromClause\n\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n\t\t\t\tinFromClause = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result.toString();\n\t}\n\n\tprivate static boolean isTrimFunction(String lcToken, String nextToken) {\n\t\treturn \"trim\".equals(lcToken) && \"(\".equals(nextToken);\n\t}\n\n\tprivate static boolean isExtractFunction(String lcToken, String nextToken) {\n\t\treturn \"extract\".equals(lcToken) && \"(\".equals(nextToken);\n\t}\n\n\tprivate static boolean isLiteral(\n\t\t\tString lcToken, String next,\n\t\t\tString sqlWhereString, String symbols, StringTokenizer tokens) {\n\t\tif ( LITERAL_PREFIXES.contains( lcToken ) && next != null ) {\n\t\t\t// easy cases first\n\t\t\tif ( \"'\".equals(next) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if ( !next.isBlank() ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// we need to look ahead in the token stream\n\t\t\t\t// to find the first non-blank token\n\t\t\t\tfinal StringTokenizer lookahead =\n\t\t\t\t\t\tnew StringTokenizer( sqlWhereString, symbols, true );\n\t\t\t\twhile ( lookahead.countTokens() > tokens.countTokens()+1 ) {\n\t\t\t\t\tlookahead.nextToken();\n\t\t\t\t}\n\t\t\t\tif ( lookahead.hasMoreTokens() ) {\n\t\t\t\t\tString nextToken;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tnextToken = lookahead.nextToken().toLowerCase(Locale.ROOT);\n\t\t\t\t\t}\n\t\t\t\t\twhile ( nextToken.isBlank() && lookahead.hasMoreTokens() );\n\t\t\t\t\treturn \"'\".equals( nextToken )\n\t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"with\".equals( nextToken )\n\t\t\t\t\t\t|| lcToken.equals( \"timestamp\" ) && \"with\".equals( nextToken )\n\t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"zone\".equals( nextToken );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate static void handleTrimFunction(\n\t\t\tString placeholder, Dialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry,\n\t\t\tStringTokenizer tokens,\n\t\t\tStringBuilder result) {\n\t\tfinal List<String> operands = new ArrayList<>();\n\t\tfinal StringBuilder builder = new StringBuilder();\n\n\t\tboolean hasMoreOperands = true;\n\t\tString operandToken = tokens.nextToken();\n\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\tcase \"leading\":\n\t\t\tcase \"trailing\":\n\t\t\tcase \"both\":\n\t\t\t\toperands.add( operandToken );\n\t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tboolean quotedOperand = false;\n\t\tint parenthesis = 0;\n\t\twhile ( hasMoreOperands ) {\n\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n\t\t\tif ( isQuote ) {\n\t\t\t\tquotedOperand = !quotedOperand;\n\t\t\t\tif ( !quotedOperand ) {\n\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuilder.append( '\\'' );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( quotedOperand ) {\n\t\t\t\tbuilder.append( operandToken );\n\t\t\t}\n\t\t\telse if ( parenthesis != 0 ) {\n\t\t\t\tbuilder.append( operandToken );\n\t\t\t\tswitch ( operandToken ) {\n\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \")\":\n\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbuilder.append( operandToken );\n\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \")\":\n\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"from\":\n\t\t\t\t\t\tif ( !builder.isEmpty() ) {\n\t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\toperandToken = tokens.nextToken();\n\t\t\thasMoreOperands = tokens.hasMoreTokens()\n\t\t\t\t\t&& ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n\t\t}\n\t\tif ( !builder.isEmpty() ) {\n\t\t\toperands.add( builder.toString() );\n\t\t}\n\n\t\tfinal TrimOperands trimOperands = new TrimOperands( operands );\n\t\tresult.append( \"trim(\" );\n\t\tif ( trimOperands.trimSpec != null ) {\n\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n\t\t}\n\t\tif ( trimOperands.trimChar != null ) {\n\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n\t\t\t\tresult.append( trimOperands.trimChar );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult.append(\n\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t);\n\t\t\t}\n\t\t\tresult.append( ' ' );\n\t\t}\n\t\tif ( trimOperands.from != null ) {\n\t\t\tresult.append( trimOperands.from ).append( ' ' );\n\t\t}\n\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char is specified\n\t\t\tresult.append( \"from \" );\n\t\t}\n\n\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, typeConfiguration, functionRegistry ) )\n\t\t\t\t.append( ')' );\n\t}\n\n\tprivate static void handleExtractFunction(\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry,\n\t\t\tStringTokenizer tokens,\n\t\t\tStringBuilder result) {\n\t\tfinal String field = extractUntil( tokens, \"from\" );\n\t\tfinal String source = renderWhereStringTemplate(\n\t\t\t\textractUntil( tokens, \")\" ),\n\t\t\t\tplaceholder,\n\t\t\t\tdialect,\n\t\t\t\ttypeConfiguration,\n\t\t\t\tfunctionRegistry\n\t\t);\n\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n\t}\n\n\tpublic static List<String> collectColumnNames(\n\t\t\tString sql,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn collectColumnNames( renderWhereStringTemplate( sql, dialect, typeConfiguration, functionRegistry ) );\n\t}\n\n\tpublic static List<String> collectColumnNames(String template) {\n\t\tfinal List<String> names = new ArrayList<>();\n\t\tint begin = 0;\n\t\tint match;\n\t\twhile ( ( match = template.indexOf(TEMPLATE, begin) ) >= 0 ) {\n\t\t\tint start = match + TEMPLATE.length() + 1;\n\t\t\tfor ( int loc = start;; loc++ ) {\n\t\t\t\tif ( loc == template.length() - 1 ) {\n\t\t\t\t\tnames.add( template.substring( start ) );\n\t\t\t\t\tbegin = template.length();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar ch = template.charAt( loc );\n\t\t\t\t\tif ( PUNCTUATION.indexOf(ch) >= 0 || WHITESPACE.indexOf(ch) >= 0 ) {\n\t\t\t\t\t\tnames.add( template.substring( start, loc ) );\n\t\t\t\t\t\tbegin = loc;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn names;\n\t}\n\n//\t/**\n//\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n//\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n//\t * named parameters.\n//\t *\n//\t * @param sqlWhereString The string into which to interpolate the placeholder value\n//\t * @param placeholder The value to be interpolated into the sqlWhereString\n//\t * @param dialect The dialect to apply\n//\t * @param functionRegistry The registry of all sql functions\n//\t *\n//\t * @return The rendered sql fragment\n//\t */\n//\tpublic static String renderWhereStringTemplate(\n//\t\t\tString sqlWhereString,\n//\t\t\tString placeholder,\n//\t\t\tDialect dialect,\n//\t\t\tSQLFunctionRegistry functionRegistry) {\n//\n//\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n//\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n//\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n//\t\t//\t\tidentifier references.\n//\n//\t\tfinal String dialectOpenQuote = Character.toString( dialect.openQuote() );\n//\t\tfinal String dialectCloseQuote = Character.toString( dialect.closeQuote() );\n//\n//\t\tString symbols = new StringBuilder()\n//\t\t\t\t.append( \"=><!+-*/()',|&`\" )\n//\t\t\t\t.append( StringHelper.WHITESPACE )\n//\t\t\t\t.append( dialect.openQuote() )\n//\t\t\t\t.append( dialect.closeQuote() )\n//\t\t\t\t.toString();\n//\t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n//\t\tProcessingState state = new ProcessingState();\n//\n//\t\tStringBuilder quotedBuffer = new StringBuilder();\n//\t\tStringBuilder result = new StringBuilder();\n//\n//\t\tboolean hasMore = tokens.hasMoreTokens();\n//\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n//\t\twhile ( hasMore ) {\n//\t\t\tString token = nextToken;\n//\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n//\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t// First, determine quoting which might be based on either:\n//\t\t\t// \t\t1) back-tick\n//\t\t\t// \t\t2) single quote (ANSI SQL standard)\n//\t\t\t// \t\t3) or dialect defined quote character(s)\n//\t\t\tQuotingCharacterDisposition quotingCharacterDisposition = QuotingCharacterDisposition.NONE;\n//\t\t\tif ( \"`\".equals( token ) ) {\n//\t\t\t\tstate.quoted = !state.quoted;\n//\t\t\t\tquotingCharacterDisposition = state.quoted\n//\t\t\t\t\t\t? QuotingCharacterDisposition.OPEN\n//\t\t\t\t\t\t: QuotingCharacterDisposition.CLOSE;\n//\t\t\t\t// replace token with the appropriate dialect quoting char\n//\t\t\t\ttoken = lcToken = ( quotingCharacterDisposition == QuotingCharacterDisposition.OPEN )\n//\t\t\t\t\t\t? dialectOpenQuote\n//\t\t\t\t\t\t: dialectCloseQuote;\n//\t\t\t}\n//\t\t\telse if ( \"'\".equals( token ) ) {\n//\t\t\t\tstate.quoted = !state.quoted;\n//\t\t\t\tquotingCharacterDisposition = state.quoted\n//\t\t\t\t\t\t? QuotingCharacterDisposition.OPEN\n//\t\t\t\t\t\t: QuotingCharacterDisposition.CLOSE;\n//\t\t\t}\n//\t\t\telse if ( !state.quoted && dialectOpenQuote.equals( token ) ) {\n//\t\t\t\tstate.quoted = true;\n//\t\t\t\tquotingCharacterDisposition = QuotingCharacterDisposition.OPEN;\n//\t\t\t}\n//\t\t\telse if ( state.quoted && dialectCloseQuote.equals( token ) ) {\n//\t\t\t\tstate.quoted = false;\n//\t\t\t\tquotingCharacterDisposition = QuotingCharacterDisposition.CLOSE;\n//\t\t\t}\n//\n//\t\t\tif ( state.quoted ) {\n//\t\t\t\tquotedBuffer.append( token );\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// if we were previously processing quoted state and just encountered the close quote, then handle that\n//\t\t\t// quoted text\n//\t\t\tif ( quotingCharacterDisposition == QuotingCharacterDisposition.CLOSE ) {\n//\t\t\t\ttoken = quotedBuffer.toString();\n//\t\t\t\tquotedBuffer.setLength( 0 );\n//\t\t\t\tresult.append( placeholder ).append( '.' )\n//\t\t\t\t\t\t.append( dialectOpenQuote ).append( token ).append( dialectCloseQuote );\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// Special processing for ANSI SQL EXTRACT function\n//\t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n//\t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n//\t\t\t\tfinal String source = renderWhereStringTemplate(\n//\t\t\t\t\t\textractUntil( tokens, \")\" ),\n//\t\t\t\t\t\tplaceholder,\n//\t\t\t\t\t\tdialect,\n//\t\t\t\t\t\tfunctionRegistry\n//\t\t\t\t);\n//\t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n//\n//\t\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// Special processing for ANSI SQL TRIM function\n//\t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n//\t\t\t\tList<String> operands = new ArrayList<String>();\n//\t\t\t\tStringBuilder builder = new StringBuilder();\n//\n//\t\t\t\tboolean hasMoreOperands = true;\n//\t\t\t\tString operandToken = tokens.nextToken();\n//\t\t\t\tboolean quoted = false;\n//\t\t\t\twhile ( hasMoreOperands ) {\n//\t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n//\t\t\t\t\tif ( isQuote ) {\n//\t\t\t\t\t\tquoted = !quoted;\n//\t\t\t\t\t\tif ( !quoted ) {\n//\t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n//\t\t\t\t\t\t\tbuilder.setLength( 0 );\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse {\n//\t\t\t\t\t\t\tbuilder.append( '\\'' );\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t\telse if ( quoted ) {\n//\t\t\t\t\t\tbuilder.append( operandToken );\n//\t\t\t\t\t}\n//\t\t\t\t\telse if ( operandToken.length() == 1 && Character.isWhitespace( operandToken.charAt( 0 ) ) ) {\n//\t\t\t\t\t\t// do nothing\n//\t\t\t\t\t}\n//\t\t\t\t\telse {\n//\t\t\t\t\t\toperands.add( operandToken );\n//\t\t\t\t\t}\n//\t\t\t\t\toperandToken = tokens.nextToken();\n//\t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ! \")\".equals( operandToken );\n//\t\t\t\t}\n//\n//\t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n//\t\t\t\tresult.append( \"trim(\" );\n//\t\t\t\tif ( trimOperands.trimSpec != null ) {\n//\t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n//\t\t\t\t}\n//\t\t\t\tif ( trimOperands.trimChar != null ) {\n//\t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n//\t\t\t\t\t\tresult.append( trimOperands.trimChar );\n//\t\t\t\t\t}\n//\t\t\t\t\telse {\n//\t\t\t\t\t\tresult.append(\n//\t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, functionRegistry )\n//\t\t\t\t\t\t);\n//\t\t\t\t\t}\n//\t\t\t\t\tresult.append( ' ' );\n//\t\t\t\t}\n//\t\t\t\tif ( trimOperands.from != null ) {\n//\t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n//\t\t\t\t}\n//\t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n//\t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char are specified\n//\t\t\t\t\tresult.append( \"from \" );\n//\t\t\t\t}\n//\n//\t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, functionRegistry ) )\n//\t\t\t\t\t\t.append( ')' );\n//\n//\t\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\n//\t\t\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\n//\t\t\tif ( Character.isWhitespace( token.charAt( 0 ) ) ) {\n//\t\t\t\tresult.append( token );\n//\t\t\t}\n//\t\t\telse if ( state.beforeTable ) {\n//\t\t\t\tresult.append( token );\n//\t\t\t\tstate.beforeTable = false;\n//\t\t\t\tstate.afterFromTable = true;\n//\t\t\t}\n//\t\t\telse if ( state.afterFromTable ) {\n//\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n//\t\t\t\t\tstate.afterFromTable = false;\n//\t\t\t\t}\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\t\t\telse if ( isNamedParameter(token) ) {\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\t\t\telse if ( isIdentifier(token, dialect)\n//\t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect , functionRegistry) ) {\n//\t\t\t\tresult.append(placeholder)\n//\t\t\t\t\t\t.append('.')\n//\t\t\t\t\t\t.append( dialect.quote(token) );\n//\t\t\t}\n//\t\t\telse {\n//\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n//\t\t\t\t\tstate.beforeTable = true;\n//\t\t\t\t\tstate.inFromClause = true;\n//\t\t\t\t}\n//\t\t\t\telse if ( state.inFromClause && \",\".equals(lcToken) ) {\n//\t\t\t\t\tstate.beforeTable = true;\n//\t\t\t\t}\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\n//\t\t\t//Yuck:\n//\t\t\tif ( state.inFromClause\n//\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n//\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n//\t\t\t\tstate.inFromClause = false;\n//\t\t\t}\n//\t\t}\n//\n//\t\treturn result.toString();\n//\t}\n//\n//\tprivate static class ProcessingState {\n//\t\tboolean quoted = false;\n//\t\tboolean quotedIdentifier = false;\n//\t\tboolean beforeTable = false;\n//\t\tboolean inFromClause = false;\n//\t\tboolean afterFromTable = false;\n//\t}\n//\n//\tprivate static enum QuotingCharacterDisposition { NONE, OPEN, CLOSE }\n\n\tprivate static class TrimOperands {\n\t\tprivate final String trimSpec;\n\t\tprivate final String trimChar;\n\t\tprivate final String from;\n\t\tprivate final String trimSource;\n\n\t\tprivate TrimOperands(List<String> operands) {\n\t\t\tfinal int size = operands.size();\n\t\t\tif ( size == 1 ) {\n\t\t\t\ttrimSpec = null;\n\t\t\t\ttrimChar = null;\n\t\t\t\tfrom = null;\n\t\t\t\ttrimSource = operands.get(0);\n\t\t\t}\n\t\t\telse if ( size == 4 ) {\n\t\t\t\ttrimSpec = operands.get(0);\n\t\t\t\ttrimChar = operands.get(1);\n\t\t\t\tfrom = operands.get(2);\n\t\t\t\ttrimSource = operands.get(3);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( size < 1 || size > 4 ) {\n\t\t\t\t\tthrow new HibernateException( \"Unexpected number of trim function operands : \" + size );\n\t\t\t\t}\n\n\t\t\t\t// trim-source will always be the last operand\n\t\t\t\ttrimSource = operands.get( size - 1 );\n\n\t\t\t\t// ANSI SQL says that more than one operand means that the FROM is required\n\t\t\t\tif ( ! \"from\".equals( operands.get( size - 2 ) ) ) {\n\t\t\t\t\tthrow new HibernateException( \"Expecting FROM, found : \" + operands.get( size - 2 ) );\n\t\t\t\t}\n\t\t\t\tfrom = operands.get( size - 2 );\n\n\t\t\t\t// trim-spec, if there is one will always be the first operand\n\t\t\t\tif ( \"leading\".equalsIgnoreCase( operands.get(0) )\n\t\t\t\t\t\t|| \"trailing\".equalsIgnoreCase( operands.get(0) )\n\t\t\t\t\t\t|| \"both\".equalsIgnoreCase( operands.get(0) ) ) {\n\t\t\t\t\ttrimSpec = operands.get(0);\n\t\t\t\t\ttrimChar = null;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttrimSpec = null;\n\t\t\t\t\tif ( size - 2 == 0 ) {\n\t\t\t\t\t\ttrimChar = null;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttrimChar = operands.get( 0 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static String extractUntil(StringTokenizer tokens, String delimiter) {\n\t\tfinal StringBuilder valueBuilder = new StringBuilder();\n\t\tString token = tokens.nextToken();\n\t\twhile ( ! delimiter.equalsIgnoreCase( token ) ) {\n\t\t\tvalueBuilder.append( token );\n\t\t\ttoken = tokens.nextToken();\n\t\t}\n\t\treturn valueBuilder.toString().trim();\n\t}\n\n\tprivate static boolean isNamedParameter(String token) {\n\t\treturn token.startsWith( \":\" );\n\t}\n\n\tprivate static boolean isFunctionOrKeyword(\n\t\t\tString lcToken,\n\t\t\tString nextToken,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\tif ( \"(\".equals( nextToken ) ) {\n\t\t\treturn true;\n\t\t}\n\t\telse if ( \"date\".equals( lcToken ) || \"time\".equals( lcToken ) ) {\n\t\t\t// these can be column names on some databases\n\t\t\t// TODO: treat 'current date' as a function\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\treturn KEYWORDS.contains( lcToken )\n\t\t\t\t|| isType( lcToken, typeConfiguration )\n\t\t\t\t|| isFunction( lcToken, nextToken, functionRegistry )\n\t\t\t\t|| dialect.getKeywords().contains( lcToken )\n\t\t\t\t|| FUNCTION_KEYWORDS.contains( lcToken );\n\t\t}\n\t}\n\n\tprivate static boolean isType(String lcToken, TypeConfiguration typeConfiguration) {\n\t\treturn typeConfiguration.getDdlTypeRegistry().isTypeNameRegistered( lcToken );\n\t}\n\n\tprivate static boolean isFunction(String lcToken, String nextToken, SqmFunctionRegistry functionRegistry) {\n\t\t// checking for \"(\" is currently redundant because it is checked before getting here;\n\t\t// doing the check anyhow, in case that earlier check goes away;\n\t\tif ( \"(\".equals( nextToken ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tfinal SqmFunctionDescriptor function = functionRegistry.findFunctionDescriptor( lcToken );\n\t\treturn function != null;\n\t}\n\n\tprivate static boolean isIdentifier(String token) {\n\t\tif ( isBoolean( token ) ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn token.charAt( 0 ) == '`'\n\t\t\t|| ( //allow any identifier quoted with backtick\n\t\t\t\tisLetter( token.charAt( 0 ) ) && //only recognizes identifiers beginning with a letter\n\t\t\t\t\t\ttoken.indexOf( '.' ) < 0\n\t\t\t);\n\t}\n\n\tprivate static boolean isBoolean(String token) {\n\t\treturn \"true\".equals( token ) || \"false\".equals( token );\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private static boolean isExtractFunction(String lcToken, String nextToken) {\n\t\treturn \"extract\".equals(lcToken) && \"(\".equals(nextToken);\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.sql.Template#extractUntil\n methodBody: private static String extractUntil(StringTokenizer tokens, String delimiter) {\nStringBuilder valueBuilder=new StringBuilder();\nString token=tokens.nextToken();\nwhile(!delimiter.equalsIgnoreCase(token)){valueBuilder.append(token);\ntoken=tokens.nextToken();\n}return valueBuilder.toString().trim();\n}",
            "methodSignature: org.hibernate.sql.Template#renderWhereStringTemplate\n methodBody: public static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\nString symbols=PUNCTUATION + WHITESPACE + dialect.openQuote() + dialect.closeQuote();\nStringTokenizer tokens=new StringTokenizer(sqlWhereString,symbols,true);\nStringBuilder result=new StringBuilder();\nboolean quoted=false;\nboolean quotedIdentifier=false;\nboolean beforeTable=false;\nboolean inFromClause=false;\nboolean afterFromTable=false;\nboolean hasMore=tokens.hasMoreTokens();\nString nextToken=hasMore ? tokens.nextToken() : null;\nwhile(hasMore){String token=nextToken;\nString lcToken=token.toLowerCase(Locale.ROOT);\nhasMore=tokens.hasMoreTokens();\nnextToken=hasMore ? tokens.nextToken() : null;\nboolean isQuoteCharacter=false;\nif(!quotedIdentifier && \"'\".equals(token)){quoted=!quoted;\nisQuoteCharacter=true;\n}if(!quoted){boolean isOpenQuote;\nif(\"`\".equals(token)){isOpenQuote=!quotedIdentifier;\ntoken=lcToken=isOpenQuote ? Character.toString(dialect.openQuote()) : Character.toString(dialect.closeQuote());\nquotedIdentifier=isOpenQuote;\nisQuoteCharacter=true;\n}if(!quotedIdentifier && (dialect.openQuote() == token.charAt(0))){isOpenQuote=true;\nquotedIdentifier=true;\nisQuoteCharacter=true;\n}if(quotedIdentifier && (dialect.closeQuote() == token.charAt(0))){quotedIdentifier=false;\nisQuoteCharacter=true;\nisOpenQuote=false;\n}if(LITERAL_PREFIXES.contains(lcToken)){if(\"'\".equals(nextToken)){result.append(token);\ncontinue;\n}if(nextToken != null && Character.isWhitespace(nextToken.charAt(0))){final StringBuilder additionalTokens=new StringBuilder();\nTimeZoneTokens possibleNextToken=null;\ndo(nextToken != null && possibleNextToken.isToken(nextToken)){possibleNextToken=possibleNextToken == null ? TimeZoneTokens.getPossibleNextTokens(lcToken) : possibleNextToken.nextToken();\ndo(nextToken != null && Character.isWhitespace(nextToken.charAt(0))){additionalTokens.append(nextToken);\nhasMore=tokens.hasMoreTokens();\nnextToken=tokens.nextToken();\n}}if(\"'\".equals(nextToken)){result.append(token);\nresult.append(additionalTokens);\ncontinue;\n}{isOpenQuote=false;\n}}{isOpenQuote=false;\n}}{isOpenQuote=false;\n}if(isOpenQuote){result.append(placeholder).append('.');\n}}if(\"extract\".equals(lcToken) && \"(\".equals(nextToken)){final String field=extractUntil(tokens,\"from\");\nfinal String source=renderWhereStringTemplate(extractUntil(tokens,\")\"),placeholder,dialect,typeConfiguration,functionRegistry);\nresult.append(\"extract(\").append(field).append(\" from \").append(source).append(')');\nhasMore=tokens.hasMoreTokens();\nnextToken=hasMore ? tokens.nextToken() : null;\ncontinue;\n}if(\"trim\".equals(lcToken) && \"(\".equals(nextToken)){List<String> operands=new ArrayList<>();\nStringBuilder builder=new StringBuilder();\nboolean hasMoreOperands=true;\nString operandToken=tokens.nextToken();\nswitch(operandToken.toLowerCase(Locale.ROOT))case \"leading\":case \"trailing\":case \"both\":operands.add(operandToken);\nif(hasMoreOperands=tokens.hasMoreTokens()){operandToken=tokens.nextToken();\n}break;\nboolean quotedOperand=false;\nint parenthesis=0;\nwhile(hasMoreOperands){final boolean isQuote=\"'\".equals(operandToken);\nif(isQuote){quotedOperand=!quotedOperand;\nif(!quotedOperand){operands.add(builder.append('\\'').toString());\nbuilder.setLength(0);\n}{builder.append('\\'');\n}}if(quotedOperand){builder.append(operandToken);\n}if(parenthesis != 0){builder.append(operandToken);\nswitch(operandToken)case \"(\":parenthesis++;\nbreak;\ncase \")\":parenthesis--;\nbreak;\n}{builder.append(operandToken);\nswitch(operandToken.toLowerCase(Locale.ROOT))case \"(\":parenthesis++;\nbreak;\ncase \")\":parenthesis--;\nbreak;\ncase \"from\":if(builder.length() != 0){operands.add(builder.substring(0,builder.length() - 4));\nbuilder.setLength(0);\noperands.add(operandToken);\n}break;\n}operandToken=tokens.nextToken();\nhasMoreOperands=tokens.hasMoreTokens() && (parenthesis != 0 || !\")\".equals(operandToken));\n}if(builder.length() != 0){operands.add(builder.toString());\n}TrimOperands trimOperands=new TrimOperands(operands);\nresult.append(\"trim(\");\nif(trimOperands.trimSpec != null){result.append(trimOperands.trimSpec).append(' ');\n}if(trimOperands.trimChar != null){if(trimOperands.trimChar.startsWith(\"'\") && trimOperands.trimChar.endsWith(\"'\")){result.append(trimOperands.trimChar);\n}{result.append(renderWhereStringTemplate(trimOperands.trimSpec,placeholder,dialect,typeConfiguration,functionRegistry));\n}result.append(' ');\n}if(trimOperands.from != null){result.append(trimOperands.from).append(' ');\n}if(trimOperands.trimSpec != null || trimOperands.trimChar != null){result.append(\"from \");\n}result.append(renderWhereStringTemplate(trimOperands.trimSource,placeholder,dialect,typeConfiguration,functionRegistry)).append(')');\nhasMore=tokens.hasMoreTokens();\nnextToken=hasMore ? tokens.nextToken() : null;\ncontinue;\n}boolean quotedOrWhitespace=quoted || quotedIdentifier || isQuoteCharacter || Character.isWhitespace(token.charAt(0));\nif(quotedOrWhitespace){result.append(token);\n}if(beforeTable){result.append(token);\nbeforeTable=false;\nafterFromTable=true;\n}if(afterFromTable){if(!\"as\".equals(lcToken)){afterFromTable=false;\n}result.append(token);\n}if(isNamedParameter(token)){result.append(token);\n}if(isIdentifier(token) && !isFunctionOrKeyword(lcToken,nextToken,dialect,typeConfiguration,functionRegistry)){result.append(placeholder).append('.').append(dialect.quote(token));\n}{if(BEFORE_TABLE_KEYWORDS.contains(lcToken)){beforeTable=true;\ninFromClause=true;\n}if(inFromClause && \",\".equals(lcToken)){beforeTable=true;\n}if(isBoolean(token)){token=dialect.toBooleanValueString(Boolean.parseBoolean(token));\n}result.append(token);\n}if(inFromClause && KEYWORDS.contains(lcToken) && !BEFORE_TABLE_KEYWORDS.contains(lcToken)){inFromClause=false;\n}}return result.toString();\n}",
            "methodSignature: org.hibernate.sql.Template.TimeZoneTokens#isToken\n methodBody: public boolean isToken(String token) {\nreturn this != NONE && name().equalsIgnoreCase(token);\n}",
            "methodSignature: org.hibernate.sql.Template#isBoolean\n methodBody: private static boolean isBoolean(String token) {\nreturn \"true\".equals(token) || \"false\".equals(token);\n}",
            "methodSignature: org.hibernate.sql.Template.TimeZoneTokens#nextToken\n methodBody: public TimeZoneTokens nextToken() {\nif(this == WITH){return TIME;\n}if(this == TIME){return ZONE;\n}{return NONE;\n}}",
            "methodSignature: org.hibernate.sql.Template.TimeZoneTokens#getPossibleNextTokens\n methodBody: static TimeZoneTokens getPossibleNextTokens(String lctoken) {\nswitch(lctoken)case \"time\":case \"timestamp\":return WITH;\ndefault:return NONE;\n}",
            "methodSignature: org.hibernate.sql.Template#isIdentifier\n methodBody: private static boolean isIdentifier(String token) {\nif(isBoolean(token)){return false;\n}return token.charAt(0) == '`' || (Character.isLetter(token.charAt(0)) && token.indexOf('.') < 0);\n}",
            "methodSignature: org.hibernate.sql.Template#isNamedParameter\n methodBody: private static boolean isNamedParameter(String token) {\nreturn token.startsWith(\":\");\n}",
            "methodSignature: org.hibernate.sql.Template#isFunctionOrKeyword\n methodBody: private static boolean isFunctionOrKeyword(\n\t\t\tString lcToken,\n\t\t\tString nextToken,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\nreturn \"(\".equals(nextToken) || KEYWORDS.contains(lcToken) || isType(lcToken,typeConfiguration) || isFunction(lcToken,nextToken,functionRegistry) || dialect.getKeywords().contains(lcToken) || FUNCTION_KEYWORDS.contains(lcToken);\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n\t * named parameters.\n\t *\n\t * @param sqlWhereString The string into which to interpolate the placeholder value\n\t * @param placeholder The value to be interpolated into the sqlWhereString\n\t * @param dialect The dialect to apply\n\t * @param functionRegistry The registry of all sql functions\n\t * @return The rendered sql fragment\n\t */\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\n\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n\t\t//\t\tidentifier references.\n\n\t\tfinal String symbols = PUNCTUATION + WHITESPACE + dialect.openQuote() + dialect.closeQuote();\n\t\tfinal StringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n\t\tfinal StringBuilder result = new StringBuilder();\n\n\t\tboolean quoted = false;\n\t\tboolean quotedIdentifier = false;\n\t\tboolean beforeTable = false;\n\t\tboolean inFromClause = false;\n\t\tboolean afterFromTable = false;\n\n\t\tboolean hasMore = tokens.hasMoreTokens();\n\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n\t\twhile ( hasMore ) {\n\t\t\tString token = nextToken;\n\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\tboolean isQuoteCharacter = false;\n\n\t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n\t\t\t\tquoted = !quoted;\n\t\t\t\tisQuoteCharacter = true;\n\t\t\t}\n\n\t\t\tif ( !quoted ) {\n\t\t\t\tfinal boolean isOpenQuote;\n\t\t\t\tif ( \"`\".equals(token) ) {\n\t\t\t\t\tisOpenQuote = !quotedIdentifier;\n\t\t\t\t\ttoken = lcToken = isOpenQuote\n\t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n\t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n\t\t\t\t\tquotedIdentifier = isOpenQuote;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( !quotedIdentifier && dialect.openQuote()==token.charAt(0) ) {\n\t\t\t\t\tisOpenQuote = true;\n\t\t\t\t\tquotedIdentifier = true;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( quotedIdentifier && dialect.closeQuote()==token.charAt(0) ) {\n\t\t\t\t\tquotedIdentifier = false;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\tif ( isOpenQuote ) {\n\t\t\t\t\tresult.append( placeholder ).append( '.' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinal boolean quotedOrWhitespace =\n\t\t\t\t\tquoted || quotedIdentifier || isQuoteCharacter\n\t\t\t\t\t\t\t|| token.isBlank();\n\t\t\tif ( quotedOrWhitespace ) {\n\t\t\t\tresult.append( token );\n\t\t\t}\n\t\t\telse if ( beforeTable ) {\n\t\t\t\tresult.append( token );\n\t\t\t\tbeforeTable = false;\n\t\t\t\tafterFromTable = true;\n\t\t\t}\n\t\t\telse if ( afterFromTable ) {\n\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n\t\t\t\t\tafterFromTable = false;\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isNamedParameter(token) ) {\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isExtractFunction( lcToken, nextToken ) ) {\n\t\t\t\t// Special processing for ANSI SQL EXTRACT function\n\t\t\t\thandleExtractFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\t\t\t}\n\t\t\telse if ( isTrimFunction( lcToken, nextToken ) ) {\n\t\t\t\t// Special processing for ANSI SQL TRIM function\n\t\t\t\thandleTrimFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\t\t\t}\n\t\t\telse if ( isIdentifier(token)\n\t\t\t\t\t&& !isFunctionOrKeyword( lcToken, nextToken, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t\t&& !isLiteral( lcToken, nextToken, sqlWhereString, symbols, tokens ) ) {\n\t\t\t\tresult.append(placeholder)\n\t\t\t\t\t\t.append('.')\n\t\t\t\t\t\t.append( dialect.quote(token) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t\tinFromClause = true;\n\t\t\t\t}\n\t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t}\n\t\t\t\tif ( isBoolean( token ) ) {\n\t\t\t\t\ttoken = dialect.toBooleanValueString( parseBoolean( token ) );\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\n\t\t\t//Yuck:\n\t\t\tif ( inFromClause\n\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n\t\t\t\tinFromClause = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result.toString();\n\t}\nprivate static boolean isExtractFunction(String lcToken, String nextToken) {\n\t\treturn \"extract\".equals(lcToken) && \"(\".equals(nextToken);\n\t}",
        "diffSourceCode": "-  119: \t/**\n-  120: \t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n-  121: \t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n-  122: \t * named parameters.\n-  123: \t *\n-  124: \t * @param sqlWhereString The string into which to interpolate the placeholder value\n-  125: \t * @param placeholder The value to be interpolated into the sqlWhereString\n-  126: \t * @param dialect The dialect to apply\n-  127: \t * @param functionRegistry The registry of all sql functions\n-  128: \t * @return The rendered sql fragment\n-  129: \t */\n-  130: \tpublic static String renderWhereStringTemplate(\n-  131: \t\t\tString sqlWhereString,\n-  132: \t\t\tString placeholder,\n-  133: \t\t\tDialect dialect,\n-  134: \t\t\tTypeConfiguration typeConfiguration,\n-  135: \t\t\tSqmFunctionRegistry functionRegistry) {\n-  136: \n-  137: \t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n-  138: \t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n-  139: \t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n-  140: \t\t//\t\tidentifier references.\n-  141: \n-  142: \t\tString symbols = PUNCTUATION +\n-  143: \t\t\t\tWHITESPACE +\n-  144: \t\t\t\tdialect.openQuote() +\n-  145: \t\t\t\tdialect.closeQuote();\n-  146: \t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n-  147: \t\tStringBuilder result = new StringBuilder();\n+  119: \t\treturn renderWhereStringTemplate( sqlWhereString, TEMPLATE, dialect, typeConfiguration, functionRegistry );\n+  120: \t}\n+  121: \n+  122: \t/**\n+  123: \t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n+  124: \t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n+  125: \t * named parameters.\n+  126: \t *\n+  127: \t * @param sqlWhereString The string into which to interpolate the placeholder value\n+  128: \t * @param placeholder The value to be interpolated into the sqlWhereString\n+  129: \t * @param dialect The dialect to apply\n+  130: \t * @param functionRegistry The registry of all sql functions\n+  131: \t * @return The rendered sql fragment\n+  132: \t */\n+  133: \tpublic static String renderWhereStringTemplate(\n+  134: \t\t\tString sqlWhereString,\n+  135: \t\t\tString placeholder,\n+  136: \t\t\tDialect dialect,\n+  137: \t\t\tTypeConfiguration typeConfiguration,\n+  138: \t\t\tSqmFunctionRegistry functionRegistry) {\n+  139: \n+  140: \t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n+  141: \t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n+  142: \t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n+  143: \t\t//\t\tidentifier references.\n+  144: \n+  145: \t\tfinal String symbols = PUNCTUATION + WHITESPACE + dialect.openQuote() + dialect.closeQuote();\n+  146: \t\tfinal StringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n+  147: \t\tfinal StringBuilder result = new StringBuilder();\n   148: \n   149: \t\tboolean quoted = false;\n   150: \t\tboolean quotedIdentifier = false;\n   151: \t\tboolean beforeTable = false;\n   152: \t\tboolean inFromClause = false;\n   153: \t\tboolean afterFromTable = false;\n   154: \n   155: \t\tboolean hasMore = tokens.hasMoreTokens();\n   156: \t\tString nextToken = hasMore ? tokens.nextToken() : null;\n   157: \t\twhile ( hasMore ) {\n   158: \t\t\tString token = nextToken;\n   159: \t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n   160: \t\t\thasMore = tokens.hasMoreTokens();\n   161: \t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n   162: \n   163: \t\t\tboolean isQuoteCharacter = false;\n   164: \n   165: \t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n   166: \t\t\t\tquoted = !quoted;\n   167: \t\t\t\tisQuoteCharacter = true;\n   168: \t\t\t}\n   169: \n   170: \t\t\tif ( !quoted ) {\n-  171: \t\t\t\tboolean isOpenQuote;\n+  171: \t\t\t\tfinal boolean isOpenQuote;\n   172: \t\t\t\tif ( \"`\".equals(token) ) {\n   173: \t\t\t\t\tisOpenQuote = !quotedIdentifier;\n   174: \t\t\t\t\ttoken = lcToken = isOpenQuote\n   175: \t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n   176: \t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n   177: \t\t\t\t\tquotedIdentifier = isOpenQuote;\n   178: \t\t\t\t\tisQuoteCharacter = true;\n   179: \t\t\t\t}\n-  180: \t\t\t\telse if ( !quotedIdentifier && ( dialect.openQuote()==token.charAt(0) ) ) {\n+  180: \t\t\t\telse if ( !quotedIdentifier && dialect.openQuote()==token.charAt(0) ) {\n   181: \t\t\t\t\tisOpenQuote = true;\n   182: \t\t\t\t\tquotedIdentifier = true;\n   183: \t\t\t\t\tisQuoteCharacter = true;\n   184: \t\t\t\t}\n-  185: \t\t\t\telse if ( quotedIdentifier && ( dialect.closeQuote()==token.charAt(0) ) ) {\n+  185: \t\t\t\telse if ( quotedIdentifier && dialect.closeQuote()==token.charAt(0) ) {\n   186: \t\t\t\t\tquotedIdentifier = false;\n   187: \t\t\t\t\tisQuoteCharacter = true;\n   188: \t\t\t\t\tisOpenQuote = false;\n   189: \t\t\t\t}\n-  190: \t\t\t\telse if ( LITERAL_PREFIXES.contains( lcToken ) ) {\n-  191: \t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n-  192: \t\t\t\t\t\t// Don't prefix a literal\n-  193: \t\t\t\t\t\tresult.append( token );\n-  194: \t\t\t\t\t\tcontinue;\n-  195: \t\t\t\t\t}\n-  196: \t\t\t\t\telse if ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) ) {\n-  197: \t\t\t\t\t\tfinal StringBuilder additionalTokens = new StringBuilder();\n-  198: \t\t\t\t\t\tTimeZoneTokens possibleNextToken = null;\n-  199: \t\t\t\t\t\tdo {\n-  200: \t\t\t\t\t\t\tpossibleNextToken = possibleNextToken == null\n-  201: \t\t\t\t\t\t\t\t\t? TimeZoneTokens.getPossibleNextTokens( lcToken )\n-  202: \t\t\t\t\t\t\t\t\t: possibleNextToken.nextToken();\n-  203: \t\t\t\t\t\t\tdo {\n-  204: \t\t\t\t\t\t\t\tadditionalTokens.append( nextToken );\n-  205: \t\t\t\t\t\t\t\thasMore = tokens.hasMoreTokens();\n-  206: \t\t\t\t\t\t\t\tnextToken = tokens.nextToken();\n-  207: \t\t\t\t\t\t\t} while ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) );\n-  208: \t\t\t\t\t\t} while ( nextToken != null && possibleNextToken.isToken( nextToken ) );\n-  209: \t\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n-  210: \t\t\t\t\t\t\t// Don't prefix a literal\n-  211: \t\t\t\t\t\t\tresult.append( token );\n-  212: \t\t\t\t\t\t\tresult.append( additionalTokens );\n-  213: \t\t\t\t\t\t\tcontinue;\n-  214: \t\t\t\t\t\t}\n-  215: \t\t\t\t\t\telse {\n-  216: \t\t\t\t\t\t\tisOpenQuote = false;\n-  217: \t\t\t\t\t\t}\n-  218: \t\t\t\t\t}\n-  219: \t\t\t\t\telse {\n-  220: \t\t\t\t\t\tisOpenQuote = false;\n-  221: \t\t\t\t\t}\n-  222: \t\t\t\t}\n-  223: \t\t\t\telse {\n-  224: \t\t\t\t\tisOpenQuote = false;\n-  225: \t\t\t\t}\n-  226: \n-  227: \t\t\t\tif ( isOpenQuote ) {\n-  228: \t\t\t\t\tresult.append( placeholder ).append( '.' );\n-  229: \t\t\t\t}\n-  230: \t\t\t}\n-  231: \n-  232: \t\t\t// Special processing for ANSI SQL EXTRACT function\n-  233: \t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n-  234: \t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n-  235: \t\t\t\tfinal String source = renderWhereStringTemplate(\n-  236: \t\t\t\t\t\textractUntil( tokens, \")\" ),\n-  237: \t\t\t\t\t\tplaceholder,\n-  238: \t\t\t\t\t\tdialect,\n-  239: \t\t\t\t\t\ttypeConfiguration,\n-  240: \t\t\t\t\t\tfunctionRegistry\n-  241: \t\t\t\t);\n-  242: \t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n-  243: \n-  244: \t\t\t\thasMore = tokens.hasMoreTokens();\n-  245: \t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n-  246: \n-  247: \t\t\t\tcontinue;\n-  248: \t\t\t}\n-  249: \n-  250: \t\t\t// Special processing for ANSI SQL TRIM function\n-  251: \t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n-  252: \t\t\t\tList<String> operands = new ArrayList<>();\n-  253: \t\t\t\tStringBuilder builder = new StringBuilder();\n-  254: \n-  255: \t\t\t\tboolean hasMoreOperands = true;\n-  256: \t\t\t\tString operandToken = tokens.nextToken();\n-  257: \t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n-  258: \t\t\t\t\tcase \"leading\":\n-  259: \t\t\t\t\tcase \"trailing\":\n-  260: \t\t\t\t\tcase \"both\":\n-  261: \t\t\t\t\t\toperands.add( operandToken );\n-  262: \t\t\t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n-  263: \t\t\t\t\t\t\toperandToken = tokens.nextToken();\n-  264: \t\t\t\t\t\t}\n-  265: \t\t\t\t\t\tbreak;\n-  266: \t\t\t\t}\n-  267: \t\t\t\tboolean quotedOperand = false;\n-  268: \t\t\t\tint parenthesis = 0;\n-  269: \t\t\t\twhile ( hasMoreOperands ) {\n-  270: \t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n-  271: \t\t\t\t\tif ( isQuote ) {\n-  272: \t\t\t\t\t\tquotedOperand = !quotedOperand;\n-  273: \t\t\t\t\t\tif ( !quotedOperand ) {\n-  274: \t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n-  275: \t\t\t\t\t\t\tbuilder.setLength( 0 );\n-  276: \t\t\t\t\t\t}\n-  277: \t\t\t\t\t\telse {\n-  278: \t\t\t\t\t\t\tbuilder.append( '\\'' );\n-  279: \t\t\t\t\t\t}\n-  280: \t\t\t\t\t}\n-  281: \t\t\t\t\telse if ( quotedOperand ) {\n-  282: \t\t\t\t\t\tbuilder.append( operandToken );\n-  283: \t\t\t\t\t}\n-  284: \t\t\t\t\telse if ( parenthesis != 0 ) {\n-  285: \t\t\t\t\t\tbuilder.append( operandToken );\n-  286: \t\t\t\t\t\tswitch ( operandToken ) {\n-  287: \t\t\t\t\t\t\tcase \"(\":\n-  288: \t\t\t\t\t\t\t\tparenthesis++;\n-  289: \t\t\t\t\t\t\t\tbreak;\n-  290: \t\t\t\t\t\t\tcase \")\":\n-  291: \t\t\t\t\t\t\t\tparenthesis--;\n-  292: \t\t\t\t\t\t\t\tbreak;\n-  293: \t\t\t\t\t\t}\n-  294: \t\t\t\t\t}\n-  295: \t\t\t\t\telse {\n-  296: \t\t\t\t\t\tbuilder.append( operandToken );\n-  297: \t\t\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n-  298: \t\t\t\t\t\t\tcase \"(\":\n-  299: \t\t\t\t\t\t\t\tparenthesis++;\n-  300: \t\t\t\t\t\t\t\tbreak;\n-  301: \t\t\t\t\t\t\tcase \")\":\n-  302: \t\t\t\t\t\t\t\tparenthesis--;\n-  303: \t\t\t\t\t\t\t\tbreak;\n-  304: \t\t\t\t\t\t\tcase \"from\":\n-  305: \t\t\t\t\t\t\t\tif ( builder.length() != 0 ) {\n-  306: \t\t\t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n-  307: \t\t\t\t\t\t\t\t\tbuilder.setLength( 0 );\n-  308: \t\t\t\t\t\t\t\t\toperands.add( operandToken );\n-  309: \t\t\t\t\t\t\t\t}\n-  310: \t\t\t\t\t\t\t\tbreak;\n-  311: \t\t\t\t\t\t}\n-  312: \t\t\t\t\t}\n-  313: \t\t\t\t\toperandToken = tokens.nextToken();\n-  314: \t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n-  315: \t\t\t\t}\n-  316: \t\t\t\tif ( builder.length() != 0 ) {\n-  317: \t\t\t\t\toperands.add( builder.toString() );\n-  318: \t\t\t\t}\n-  319: \n-  320: \t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n-  321: \t\t\t\tresult.append( \"trim(\" );\n-  322: \t\t\t\tif ( trimOperands.trimSpec != null ) {\n-  323: \t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n-  324: \t\t\t\t}\n-  325: \t\t\t\tif ( trimOperands.trimChar != null ) {\n-  326: \t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n-  327: \t\t\t\t\t\tresult.append( trimOperands.trimChar );\n-  328: \t\t\t\t\t}\n-  329: \t\t\t\t\telse {\n-  330: \t\t\t\t\t\tresult.append(\n-  331: \t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n-  332: \t\t\t\t\t\t);\n-  333: \t\t\t\t\t}\n-  334: \t\t\t\t\tresult.append( ' ' );\n-  335: \t\t\t\t}\n-  336: \t\t\t\tif ( trimOperands.from != null ) {\n-  337: \t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n-  338: \t\t\t\t}\n-  339: \t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n-  340: \t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char is specified\n-  341: \t\t\t\t\tresult.append( \"from \" );\n-  342: \t\t\t\t}\n-  343: \n-  344: \t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, typeConfiguration, functionRegistry ) )\n-  345: \t\t\t\t\t\t.append( ')' );\n-  346: \n-  347: \t\t\t\thasMore = tokens.hasMoreTokens();\n-  348: \t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n-  349: \n-  350: \t\t\t\tcontinue;\n-  351: \t\t\t}\n-  352: \n-  353: \t\t\tboolean quotedOrWhitespace = quoted || quotedIdentifier || isQuoteCharacter\n-  354: \t\t\t\t\t|| Character.isWhitespace( token.charAt(0) );\n-  355: \n-  356: \t\t\tif ( quotedOrWhitespace ) {\n-  357: \t\t\t\tresult.append( token );\n+  190: \t\t\t\telse {\n+  191: \t\t\t\t\tisOpenQuote = false;\n+  192: \t\t\t\t}\n+  193: \t\t\t\tif ( isOpenQuote ) {\n+  194: \t\t\t\t\tresult.append( placeholder ).append( '.' );\n+  195: \t\t\t\t}\n+  196: \t\t\t}\n+  197: \n+  198: \t\t\tfinal boolean quotedOrWhitespace =\n+  199: \t\t\t\t\tquoted || quotedIdentifier || isQuoteCharacter\n+  200: \t\t\t\t\t\t\t|| token.isBlank();\n+  201: \t\t\tif ( quotedOrWhitespace ) {\n+  202: \t\t\t\tresult.append( token );\n+  203: \t\t\t}\n+  204: \t\t\telse if ( beforeTable ) {\n+  205: \t\t\t\tresult.append( token );\n+  206: \t\t\t\tbeforeTable = false;\n+  207: \t\t\t\tafterFromTable = true;\n+  208: \t\t\t}\n+  209: \t\t\telse if ( afterFromTable ) {\n+  210: \t\t\t\tif ( !\"as\".equals(lcToken) ) {\n+  211: \t\t\t\t\tafterFromTable = false;\n+  212: \t\t\t\t}\n+  213: \t\t\t\tresult.append(token);\n+  214: \t\t\t}\n+  215: \t\t\telse if ( isNamedParameter(token) ) {\n+  216: \t\t\t\tresult.append(token);\n+  217: \t\t\t}\n+  218: \t\t\telse if ( isExtractFunction( lcToken, nextToken ) ) {\n+  219: \t\t\t\t// Special processing for ANSI SQL EXTRACT function\n+  220: \t\t\t\thandleExtractFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n+  221: \t\t\t\thasMore = tokens.hasMoreTokens();\n+  222: \t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n+  223: \t\t\t}\n+  224: \t\t\telse if ( isTrimFunction( lcToken, nextToken ) ) {\n+  225: \t\t\t\t// Special processing for ANSI SQL TRIM function\n+  226: \t\t\t\thandleTrimFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n+  227: \t\t\t\thasMore = tokens.hasMoreTokens();\n+  228: \t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n+  229: \t\t\t}\n+  230: \t\t\telse if ( isIdentifier(token)\n+  231: \t\t\t\t\t&& !isFunctionOrKeyword( lcToken, nextToken, dialect, typeConfiguration, functionRegistry )\n+  232: \t\t\t\t\t&& !isLiteral( lcToken, nextToken, sqlWhereString, symbols, tokens ) ) {\n+  233: \t\t\t\tresult.append(placeholder)\n+  234: \t\t\t\t\t\t.append('.')\n+  235: \t\t\t\t\t\t.append( dialect.quote(token) );\n+  236: \t\t\t}\n+  237: \t\t\telse {\n+  238: \t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n+  239: \t\t\t\t\tbeforeTable = true;\n+  240: \t\t\t\t\tinFromClause = true;\n+  241: \t\t\t\t}\n+  242: \t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n+  243: \t\t\t\t\tbeforeTable = true;\n+  244: \t\t\t\t}\n+  245: \t\t\t\tif ( isBoolean( token ) ) {\n+  246: \t\t\t\t\ttoken = dialect.toBooleanValueString( parseBoolean( token ) );\n+  247: \t\t\t\t}\n+  248: \t\t\t\tresult.append(token);\n+  249: \t\t\t}\n+  250: \n+  251: \t\t\t//Yuck:\n+  252: \t\t\tif ( inFromClause\n+  253: \t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n+  254: \t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n+  255: \t\t\t\tinFromClause = false;\n+  256: \t\t\t}\n+  257: \t\t}\n+  258: \n+  259: \t\treturn result.toString();\n+  260: \t}\n+  261: \n+  262: \tprivate static boolean isTrimFunction(String lcToken, String nextToken) {\n+  263: \t\treturn \"trim\".equals(lcToken) && \"(\".equals(nextToken);\n+  264: \t}\n+  265: \n+  266: \tprivate static boolean isExtractFunction(String lcToken, String nextToken) {\n+  267: \t\treturn \"extract\".equals(lcToken) && \"(\".equals(nextToken);\n+  268: \t}\n+  269: \n+  270: \tprivate static boolean isLiteral(\n+  271: \t\t\tString lcToken, String next,\n+  272: \t\t\tString sqlWhereString, String symbols, StringTokenizer tokens) {\n+  273: \t\tif ( LITERAL_PREFIXES.contains( lcToken ) && next != null ) {\n+  274: \t\t\t// easy cases first\n+  275: \t\t\tif ( \"'\".equals(next) ) {\n+  276: \t\t\t\treturn true;\n+  277: \t\t\t}\n+  278: \t\t\telse if ( !next.isBlank() ) {\n+  279: \t\t\t\treturn false;\n+  280: \t\t\t}\n+  281: \t\t\telse {\n+  282: \t\t\t\t// we need to look ahead in the token stream\n+  283: \t\t\t\t// to find the first non-blank token\n+  284: \t\t\t\tfinal StringTokenizer lookahead =\n+  285: \t\t\t\t\t\tnew StringTokenizer( sqlWhereString, symbols, true );\n+  286: \t\t\t\twhile ( lookahead.countTokens() > tokens.countTokens()+1 ) {\n+  287: \t\t\t\t\tlookahead.nextToken();\n+  288: \t\t\t\t}\n+  289: \t\t\t\tif ( lookahead.hasMoreTokens() ) {\n+  290: \t\t\t\t\tString nextToken;\n+  291: \t\t\t\t\tdo {\n+  292: \t\t\t\t\t\tnextToken = lookahead.nextToken().toLowerCase(Locale.ROOT);\n+  293: \t\t\t\t\t}\n+  294: \t\t\t\t\twhile ( nextToken.isBlank() && lookahead.hasMoreTokens() );\n+  295: \t\t\t\t\treturn \"'\".equals( nextToken )\n+  296: \t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"with\".equals( nextToken )\n+  297: \t\t\t\t\t\t|| lcToken.equals( \"timestamp\" ) && \"with\".equals( nextToken )\n+  298: \t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"zone\".equals( nextToken );\n+  299: \t\t\t\t}\n+  300: \t\t\t\telse {\n+  301: \t\t\t\t\treturn false;\n+  302: \t\t\t\t}\n+  303: \t\t\t}\n+  304: \t\t}\n+  305: \t\telse {\n+  306: \t\t\treturn false;\n+  307: \t\t}\n+  308: \t}\n+  309: \n+  310: \tprivate static void handleTrimFunction(\n+  311: \t\t\tString placeholder, Dialect dialect,\n+  312: \t\t\tTypeConfiguration typeConfiguration,\n+  313: \t\t\tSqmFunctionRegistry functionRegistry,\n+  314: \t\t\tStringTokenizer tokens,\n+  315: \t\t\tStringBuilder result) {\n+  316: \t\tfinal List<String> operands = new ArrayList<>();\n+  317: \t\tfinal StringBuilder builder = new StringBuilder();\n+  318: \n+  319: \t\tboolean hasMoreOperands = true;\n+  320: \t\tString operandToken = tokens.nextToken();\n+  321: \t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n+  322: \t\t\tcase \"leading\":\n+  323: \t\t\tcase \"trailing\":\n+  324: \t\t\tcase \"both\":\n+  325: \t\t\t\toperands.add( operandToken );\n+  326: \t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n+  327: \t\t\t\t\toperandToken = tokens.nextToken();\n+  328: \t\t\t\t}\n+  329: \t\t\t\tbreak;\n+  330: \t\t}\n+  331: \t\tboolean quotedOperand = false;\n+  332: \t\tint parenthesis = 0;\n+  333: \t\twhile ( hasMoreOperands ) {\n+  334: \t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n+  335: \t\t\tif ( isQuote ) {\n+  336: \t\t\t\tquotedOperand = !quotedOperand;\n+  337: \t\t\t\tif ( !quotedOperand ) {\n+  338: \t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n+  339: \t\t\t\t\tbuilder.setLength( 0 );\n+  340: \t\t\t\t}\n+  341: \t\t\t\telse {\n+  342: \t\t\t\t\tbuilder.append( '\\'' );\n+  343: \t\t\t\t}\n+  344: \t\t\t}\n+  345: \t\t\telse if ( quotedOperand ) {\n+  346: \t\t\t\tbuilder.append( operandToken );\n+  347: \t\t\t}\n+  348: \t\t\telse if ( parenthesis != 0 ) {\n+  349: \t\t\t\tbuilder.append( operandToken );\n+  350: \t\t\t\tswitch ( operandToken ) {\n+  351: \t\t\t\t\tcase \"(\":\n+  352: \t\t\t\t\t\tparenthesis++;\n+  353: \t\t\t\t\t\tbreak;\n+  354: \t\t\t\t\tcase \")\":\n+  355: \t\t\t\t\t\tparenthesis--;\n+  356: \t\t\t\t\t\tbreak;\n+  357: \t\t\t\t}\n   358: \t\t\t}\n-  359: \t\t\telse if ( beforeTable ) {\n-  360: \t\t\t\tresult.append( token );\n-  361: \t\t\t\tbeforeTable = false;\n-  362: \t\t\t\tafterFromTable = true;\n-  363: \t\t\t}\n-  364: \t\t\telse if ( afterFromTable ) {\n-  365: \t\t\t\tif ( !\"as\".equals(lcToken) ) {\n-  366: \t\t\t\t\tafterFromTable = false;\n-  367: \t\t\t\t}\n-  368: \t\t\t\tresult.append(token);\n-  369: \t\t\t}\n-  370: \t\t\telse if ( isNamedParameter(token) ) {\n-  371: \t\t\t\tresult.append(token);\n-  372: \t\t\t}\n-  373: \t\t\telse if ( isIdentifier(token)\n-  374: \t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect, typeConfiguration, functionRegistry) ) {\n-  375: \t\t\t\tresult.append(placeholder)\n-  376: \t\t\t\t\t\t.append('.')\n-  377: \t\t\t\t\t\t.append( dialect.quote(token) );\n-  378: \t\t\t}\n-  379: \t\t\telse {\n-  380: \t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n-  381: \t\t\t\t\tbeforeTable = true;\n-  382: \t\t\t\t\tinFromClause = true;\n-  383: \t\t\t\t}\n-  384: \t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n-  385: \t\t\t\t\tbeforeTable = true;\n-  386: \t\t\t\t}\n-  387: \t\t\t\tif ( isBoolean( token ) ) {\n-  388: \t\t\t\t\ttoken = dialect.toBooleanValueString( Boolean.parseBoolean( token ) );\n-  389: \t\t\t\t}\n-  390: \t\t\t\tresult.append(token);\n-  391: \t\t\t}\n-  392: \n-  393: \t\t\t//Yuck:\n-  394: \t\t\tif ( inFromClause\n-  395: \t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n-  396: \t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n-  397: \t\t\t\tinFromClause = false;\n+  359: \t\t\telse {\n+  360: \t\t\t\tbuilder.append( operandToken );\n+  361: \t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n+  362: \t\t\t\t\tcase \"(\":\n+  363: \t\t\t\t\t\tparenthesis++;\n+  364: \t\t\t\t\t\tbreak;\n+  365: \t\t\t\t\tcase \")\":\n+  366: \t\t\t\t\t\tparenthesis--;\n+  367: \t\t\t\t\t\tbreak;\n+  368: \t\t\t\t\tcase \"from\":\n+  369: \t\t\t\t\t\tif ( !builder.isEmpty() ) {\n+  370: \t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n+  371: \t\t\t\t\t\t\tbuilder.setLength( 0 );\n+  372: \t\t\t\t\t\t\toperands.add( operandToken );\n+  373: \t\t\t\t\t\t}\n+  374: \t\t\t\t\t\tbreak;\n+  375: \t\t\t\t}\n+  376: \t\t\t}\n+  377: \t\t\toperandToken = tokens.nextToken();\n+  378: \t\t\thasMoreOperands = tokens.hasMoreTokens()\n+  379: \t\t\t\t\t&& ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n+  380: \t\t}\n+  381: \t\tif ( !builder.isEmpty() ) {\n+  382: \t\t\toperands.add( builder.toString() );\n+  383: \t\t}\n+  384: \n+  385: \t\tfinal TrimOperands trimOperands = new TrimOperands( operands );\n+  386: \t\tresult.append( \"trim(\" );\n+  387: \t\tif ( trimOperands.trimSpec != null ) {\n+  388: \t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n+  389: \t\t}\n+  390: \t\tif ( trimOperands.trimChar != null ) {\n+  391: \t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n+  392: \t\t\t\tresult.append( trimOperands.trimChar );\n+  393: \t\t\t}\n+  394: \t\t\telse {\n+  395: \t\t\t\tresult.append(\n+  396: \t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n+  397: \t\t\t\t);\n   398: \t\t\t}\n-  399: \t\t}\n-  400: \n-  401: \t\treturn result.toString();\n-  402: \t}\n+  399: \t\t\tresult.append( ' ' );\n+  400: \t\t}\n+  401: \t\tif ( trimOperands.from != null ) {\n+  402: \t\t\tresult.append( trimOperands.from ).append( ' ' );\n",
        "uniqueId": "35f96d6e901dbd071b375d809521ef6f1c979868_119_402_266_268_122_260",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 1,
                "covered": 289
            },
            "BRANCH": {
                "missed": 2,
                "covered": 74
            },
            "LINE": {
                "missed": 0,
                "covered": 79
            },
            "COMPLEXITY": {
                "missed": 2,
                "covered": 37
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\npublic static String renderTransformerReadFragment(\n        String fragment,\n        String... columnNames) {\n    // NOTE : would need access to SessionFactoryImplementor to make this configurable\n    for (String columnName : columnNames) {\n        fragment = fragment.replace(columnName, TEMPLATE + '.' + columnName);\n    }\n    return fragment;\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n\t * named parameters.\n\t *\n\t * @param sqlWhereString The string into which to interpolate the placeholder value\n\t * @param placeholder The value to be interpolated into the sqlWhereString\n\t * @param dialect The dialect to apply\n\t * @param functionRegistry The registry of all sql functions\n\t * @return The rendered sql fragment\n\t */\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\n\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n\t\t//\t\tidentifier references.\n\n\t\tString symbols = PUNCTUATION +\n\t\t\t\tWHITESPACE +\n\t\t\t\tdialect.openQuote() +\n\t\t\t\tdialect.closeQuote();\n\t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n\t\tStringBuilder result = new StringBuilder();\n\n\t\tboolean quoted = false;\n\t\tboolean quotedIdentifier = false;\n\t\tboolean beforeTable = false;\n\t\tboolean inFromClause = false;\n\t\tboolean afterFromTable = false;\n\n\t\tboolean hasMore = tokens.hasMoreTokens();\n\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n\t\twhile ( hasMore ) {\n\t\t\tString token = nextToken;\n\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\tboolean isQuoteCharacter = false;\n\n\t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n\t\t\t\tquoted = !quoted;\n\t\t\t\tisQuoteCharacter = true;\n\t\t\t}\n\n\t\t\tif ( !quoted ) {\n\t\t\t\tboolean isOpenQuote;\n\t\t\t\tif ( \"`\".equals(token) ) {\n\t\t\t\t\tisOpenQuote = !quotedIdentifier;\n\t\t\t\t\ttoken = lcToken = isOpenQuote\n\t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n\t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n\t\t\t\t\tquotedIdentifier = isOpenQuote;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( !quotedIdentifier && ( dialect.openQuote()==token.charAt(0) ) ) {\n\t\t\t\t\tisOpenQuote = true;\n\t\t\t\t\tquotedIdentifier = true;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( quotedIdentifier && ( dialect.closeQuote()==token.charAt(0) ) ) {\n\t\t\t\t\tquotedIdentifier = false;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\telse if ( LITERAL_PREFIXES.contains( lcToken ) ) {\n\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n\t\t\t\t\t\t// Don't prefix a literal\n\t\t\t\t\t\tresult.append( token );\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) ) {\n\t\t\t\t\t\tfinal StringBuilder additionalTokens = new StringBuilder();\n\t\t\t\t\t\tTimeZoneTokens possibleNextToken = null;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tpossibleNextToken = possibleNextToken == null\n\t\t\t\t\t\t\t\t\t? TimeZoneTokens.getPossibleNextTokens( lcToken )\n\t\t\t\t\t\t\t\t\t: possibleNextToken.nextToken();\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tadditionalTokens.append( nextToken );\n\t\t\t\t\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\t\t\t\t\tnextToken = tokens.nextToken();\n\t\t\t\t\t\t\t} while ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) );\n\t\t\t\t\t\t} while ( nextToken != null && possibleNextToken.isToken( nextToken ) );\n\t\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n\t\t\t\t\t\t\t// Don't prefix a literal\n\t\t\t\t\t\t\tresult.append( token );\n\t\t\t\t\t\t\tresult.append( additionalTokens );\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\n\t\t\t\tif ( isOpenQuote ) {\n\t\t\t\t\tresult.append( placeholder ).append( '.' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Special processing for ANSI SQL EXTRACT function\n\t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n\t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n\t\t\t\tfinal String source = renderWhereStringTemplate(\n\t\t\t\t\t\textractUntil( tokens, \")\" ),\n\t\t\t\t\t\tplaceholder,\n\t\t\t\t\t\tdialect,\n\t\t\t\t\t\ttypeConfiguration,\n\t\t\t\t\t\tfunctionRegistry\n\t\t\t\t);\n\t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Special processing for ANSI SQL TRIM function\n\t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n\t\t\t\tList<String> operands = new ArrayList<>();\n\t\t\t\tStringBuilder builder = new StringBuilder();\n\n\t\t\t\tboolean hasMoreOperands = true;\n\t\t\t\tString operandToken = tokens.nextToken();\n\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\tcase \"leading\":\n\t\t\t\t\tcase \"trailing\":\n\t\t\t\t\tcase \"both\":\n\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n\t\t\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tboolean quotedOperand = false;\n\t\t\t\tint parenthesis = 0;\n\t\t\t\twhile ( hasMoreOperands ) {\n\t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n\t\t\t\t\tif ( isQuote ) {\n\t\t\t\t\t\tquotedOperand = !quotedOperand;\n\t\t\t\t\t\tif ( !quotedOperand ) {\n\t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbuilder.append( '\\'' );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if ( quotedOperand ) {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( parenthesis != 0 ) {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t\tswitch ( operandToken ) {\n\t\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"from\":\n\t\t\t\t\t\t\t\tif ( builder.length() != 0 ) {\n\t\t\t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n\t\t\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n\t\t\t\t}\n\t\t\t\tif ( builder.length() != 0 ) {\n\t\t\t\t\toperands.add( builder.toString() );\n\t\t\t\t}\n\n\t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n\t\t\t\tresult.append( \"trim(\" );\n\t\t\t\tif ( trimOperands.trimSpec != null ) {\n\t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n\t\t\t\t}\n\t\t\t\tif ( trimOperands.trimChar != null ) {\n\t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n\t\t\t\t\t\tresult.append( trimOperands.trimChar );\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresult.append(\n\t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tresult.append( ' ' );\n\t\t\t\t}\n\t\t\t\tif ( trimOperands.from != null ) {\n\t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n\t\t\t\t}\n\t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n\t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char is specified\n\t\t\t\t\tresult.append( \"from \" );\n\t\t\t\t}\n\n\t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, typeConfiguration, functionRegistry ) )\n\t\t\t\t\t\t.append( ')' );\n\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tboolean quotedOrWhitespace = quoted || quotedIdentifier || isQuoteCharacter\n\t\t\t\t\t|| Character.isWhitespace( token.charAt(0) );\n\n\t\t\tif ( quotedOrWhitespace ) {\n\t\t\t\tresult.append( token );\n\t\t\t}\n\t\t\telse if ( beforeTable ) {\n\t\t\t\tresult.append( token );\n\t\t\t\tbeforeTable = false;\n\t\t\t\tafterFromTable = true;\n\t\t\t}\n\t\t\telse if ( afterFromTable ) {\n\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n\t\t\t\t\tafterFromTable = false;\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isNamedParameter(token) ) {\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isIdentifier(token)\n\t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect, typeConfiguration, functionRegistry) ) {\n\t\t\t\tresult.append(placeholder)\n\t\t\t\t\t\t.append('.')\n\t\t\t\t\t\t.append( dialect.quote(token) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t\tinFromClause = true;\n\t\t\t\t}\n\t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t}\n\t\t\t\tif ( isBoolean( token ) ) {\n\t\t\t\t\ttoken = dialect.toBooleanValueString( Boolean.parseBoolean( token ) );\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\n\t\t\t//Yuck:\n\t\t\tif ( inFromClause\n\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n\t\t\t\tinFromClause = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result.toString();\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.sql;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.query.sqm.function.SqmFunctionDescriptor;\nimport org.hibernate.query.sqm.function.SqmFunctionRegistry;\nimport org.hibernate.type.spi.TypeConfiguration;\n\nimport static org.hibernate.internal.util.StringHelper.WHITESPACE;\n\n/**\n * Parses SQL fragments specified in mapping documents.\n *\n * @author Gavin King\n */\npublic final class Template {\n\n\tprivate static final Set<String> KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> BEFORE_TABLE_KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> FUNCTION_KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> LITERAL_PREFIXES = new HashSet<>();\n\tpublic static final String PUNCTUATION = \"=><!+-*/()',|&`\";\n\n\tstatic {\n\t\tKEYWORDS.add(\"and\");\n\t\tKEYWORDS.add(\"or\");\n\t\tKEYWORDS.add(\"not\");\n\t\tKEYWORDS.add(\"like\");\n\t\tKEYWORDS.add(\"escape\");\n\t\tKEYWORDS.add(\"is\");\n\t\tKEYWORDS.add(\"in\");\n\t\tKEYWORDS.add(\"between\");\n\t\tKEYWORDS.add(\"null\");\n\t\tKEYWORDS.add(\"select\");\n\t\tKEYWORDS.add(\"distinct\");\n\t\tKEYWORDS.add(\"from\");\n\t\tKEYWORDS.add(\"join\");\n\t\tKEYWORDS.add(\"inner\");\n\t\tKEYWORDS.add(\"outer\");\n\t\tKEYWORDS.add(\"left\");\n\t\tKEYWORDS.add(\"right\");\n\t\tKEYWORDS.add(\"on\");\n\t\tKEYWORDS.add(\"where\");\n\t\tKEYWORDS.add(\"having\");\n\t\tKEYWORDS.add(\"group\");\n\t\tKEYWORDS.add(\"order\");\n\t\tKEYWORDS.add(\"by\");\n\t\tKEYWORDS.add(\"desc\");\n\t\tKEYWORDS.add(\"asc\");\n\t\tKEYWORDS.add(\"limit\");\n\t\tKEYWORDS.add(\"any\");\n\t\tKEYWORDS.add(\"some\");\n\t\tKEYWORDS.add(\"exists\");\n\t\tKEYWORDS.add(\"all\");\n\t\tKEYWORDS.add(\"union\");\n\t\tKEYWORDS.add(\"minus\");\n\t\tKEYWORDS.add(\"except\");\n\t\tKEYWORDS.add(\"intersect\");\n\t\tKEYWORDS.add(\"partition\");\n\n\t\tBEFORE_TABLE_KEYWORDS.add(\"from\");\n\t\tBEFORE_TABLE_KEYWORDS.add(\"join\");\n\n\t\tFUNCTION_KEYWORDS.add(\"as\");\n\t\tFUNCTION_KEYWORDS.add(\"leading\");\n\t\tFUNCTION_KEYWORDS.add(\"trailing\");\n\t\tFUNCTION_KEYWORDS.add(\"from\");\n\t\tFUNCTION_KEYWORDS.add(\"case\");\n\t\tFUNCTION_KEYWORDS.add(\"when\");\n\t\tFUNCTION_KEYWORDS.add(\"then\");\n\t\tFUNCTION_KEYWORDS.add(\"else\");\n\t\tFUNCTION_KEYWORDS.add(\"end\");\n\n\t\tLITERAL_PREFIXES.add(\"n\");\n\t\tLITERAL_PREFIXES.add(\"x\");\n\t\tLITERAL_PREFIXES.add(\"varbyte\");\n\t\tLITERAL_PREFIXES.add(\"bx\");\n\t\tLITERAL_PREFIXES.add(\"bytea\");\n\t\tLITERAL_PREFIXES.add(\"date\");\n\t\tLITERAL_PREFIXES.add(\"time\");\n\t\tLITERAL_PREFIXES.add(\"timestamp\");\n\t}\n\n\tpublic static final String TEMPLATE = \"$PlaceHolder$\";\n\n\tprivate Template() {}\n\n\tpublic static String renderTransformerReadFragment(\n\t\t\tString fragment,\n\t\t\tString... columnNames) {\n\t\t// NOTE : would need access to SessionFactoryImplementor to make this configurable\n\t\tfor ( String columnName : columnNames ) {\n\t\t\tfragment = fragment.replace( columnName, TEMPLATE + '.' + columnName );\n\t\t}\n\t\treturn fragment;\n\t}\n\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn renderWhereStringTemplate( sqlWhereString, TEMPLATE, dialect, typeConfiguration, functionRegistry );\n\t}\n\n\t/**\n\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n\t * named parameters.\n\t *\n\t * @param sqlWhereString The string into which to interpolate the placeholder value\n\t * @param placeholder The value to be interpolated into the sqlWhereString\n\t * @param dialect The dialect to apply\n\t * @param functionRegistry The registry of all sql functions\n\t * @return The rendered sql fragment\n\t */\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\n\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n\t\t//\t\tidentifier references.\n\n\t\tString symbols = PUNCTUATION +\n\t\t\t\tWHITESPACE +\n\t\t\t\tdialect.openQuote() +\n\t\t\t\tdialect.closeQuote();\n\t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n\t\tStringBuilder result = new StringBuilder();\n\n\t\tboolean quoted = false;\n\t\tboolean quotedIdentifier = false;\n\t\tboolean beforeTable = false;\n\t\tboolean inFromClause = false;\n\t\tboolean afterFromTable = false;\n\n\t\tboolean hasMore = tokens.hasMoreTokens();\n\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n\t\twhile ( hasMore ) {\n\t\t\tString token = nextToken;\n\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\tboolean isQuoteCharacter = false;\n\n\t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n\t\t\t\tquoted = !quoted;\n\t\t\t\tisQuoteCharacter = true;\n\t\t\t}\n\n\t\t\tif ( !quoted ) {\n\t\t\t\tboolean isOpenQuote;\n\t\t\t\tif ( \"`\".equals(token) ) {\n\t\t\t\t\tisOpenQuote = !quotedIdentifier;\n\t\t\t\t\ttoken = lcToken = isOpenQuote\n\t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n\t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n\t\t\t\t\tquotedIdentifier = isOpenQuote;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( !quotedIdentifier && ( dialect.openQuote()==token.charAt(0) ) ) {\n\t\t\t\t\tisOpenQuote = true;\n\t\t\t\t\tquotedIdentifier = true;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( quotedIdentifier && ( dialect.closeQuote()==token.charAt(0) ) ) {\n\t\t\t\t\tquotedIdentifier = false;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\telse if ( LITERAL_PREFIXES.contains( lcToken ) ) {\n\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n\t\t\t\t\t\t// Don't prefix a literal\n\t\t\t\t\t\tresult.append( token );\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) ) {\n\t\t\t\t\t\tfinal StringBuilder additionalTokens = new StringBuilder();\n\t\t\t\t\t\tTimeZoneTokens possibleNextToken = null;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tpossibleNextToken = possibleNextToken == null\n\t\t\t\t\t\t\t\t\t? TimeZoneTokens.getPossibleNextTokens( lcToken )\n\t\t\t\t\t\t\t\t\t: possibleNextToken.nextToken();\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tadditionalTokens.append( nextToken );\n\t\t\t\t\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\t\t\t\t\tnextToken = tokens.nextToken();\n\t\t\t\t\t\t\t} while ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) );\n\t\t\t\t\t\t} while ( nextToken != null && possibleNextToken.isToken( nextToken ) );\n\t\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n\t\t\t\t\t\t\t// Don't prefix a literal\n\t\t\t\t\t\t\tresult.append( token );\n\t\t\t\t\t\t\tresult.append( additionalTokens );\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\n\t\t\t\tif ( isOpenQuote ) {\n\t\t\t\t\tresult.append( placeholder ).append( '.' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Special processing for ANSI SQL EXTRACT function\n\t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n\t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n\t\t\t\tfinal String source = renderWhereStringTemplate(\n\t\t\t\t\t\textractUntil( tokens, \")\" ),\n\t\t\t\t\t\tplaceholder,\n\t\t\t\t\t\tdialect,\n\t\t\t\t\t\ttypeConfiguration,\n\t\t\t\t\t\tfunctionRegistry\n\t\t\t\t);\n\t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Special processing for ANSI SQL TRIM function\n\t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n\t\t\t\tList<String> operands = new ArrayList<>();\n\t\t\t\tStringBuilder builder = new StringBuilder();\n\n\t\t\t\tboolean hasMoreOperands = true;\n\t\t\t\tString operandToken = tokens.nextToken();\n\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\tcase \"leading\":\n\t\t\t\t\tcase \"trailing\":\n\t\t\t\t\tcase \"both\":\n\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n\t\t\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tboolean quotedOperand = false;\n\t\t\t\tint parenthesis = 0;\n\t\t\t\twhile ( hasMoreOperands ) {\n\t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n\t\t\t\t\tif ( isQuote ) {\n\t\t\t\t\t\tquotedOperand = !quotedOperand;\n\t\t\t\t\t\tif ( !quotedOperand ) {\n\t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbuilder.append( '\\'' );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if ( quotedOperand ) {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( parenthesis != 0 ) {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t\tswitch ( operandToken ) {\n\t\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"from\":\n\t\t\t\t\t\t\t\tif ( builder.length() != 0 ) {\n\t\t\t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n\t\t\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n\t\t\t\t}\n\t\t\t\tif ( builder.length() != 0 ) {\n\t\t\t\t\toperands.add( builder.toString() );\n\t\t\t\t}\n\n\t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n\t\t\t\tresult.append( \"trim(\" );\n\t\t\t\tif ( trimOperands.trimSpec != null ) {\n\t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n\t\t\t\t}\n\t\t\t\tif ( trimOperands.trimChar != null ) {\n\t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n\t\t\t\t\t\tresult.append( trimOperands.trimChar );\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresult.append(\n\t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tresult.append( ' ' );\n\t\t\t\t}\n\t\t\t\tif ( trimOperands.from != null ) {\n\t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n\t\t\t\t}\n\t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n\t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char is specified\n\t\t\t\t\tresult.append( \"from \" );\n\t\t\t\t}\n\n\t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, typeConfiguration, functionRegistry ) )\n\t\t\t\t\t\t.append( ')' );\n\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tboolean quotedOrWhitespace = quoted || quotedIdentifier || isQuoteCharacter\n\t\t\t\t\t|| Character.isWhitespace( token.charAt(0) );\n\n\t\t\tif ( quotedOrWhitespace ) {\n\t\t\t\tresult.append( token );\n\t\t\t}\n\t\t\telse if ( beforeTable ) {\n\t\t\t\tresult.append( token );\n\t\t\t\tbeforeTable = false;\n\t\t\t\tafterFromTable = true;\n\t\t\t}\n\t\t\telse if ( afterFromTable ) {\n\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n\t\t\t\t\tafterFromTable = false;\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isNamedParameter(token) ) {\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isIdentifier(token)\n\t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect, typeConfiguration, functionRegistry) ) {\n\t\t\t\tresult.append(placeholder)\n\t\t\t\t\t\t.append('.')\n\t\t\t\t\t\t.append( dialect.quote(token) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t\tinFromClause = true;\n\t\t\t\t}\n\t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t}\n\t\t\t\tif ( isBoolean( token ) ) {\n\t\t\t\t\ttoken = dialect.toBooleanValueString( Boolean.parseBoolean( token ) );\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\n\t\t\t//Yuck:\n\t\t\tif ( inFromClause\n\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n\t\t\t\tinFromClause = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result.toString();\n\t}\n\n\tprivate enum TimeZoneTokens {\n\t\tNONE,\n\t\tWITH,\n\t\tTIME,\n\t\tZONE;\n\n\t\tstatic TimeZoneTokens getPossibleNextTokens(String lctoken) {\n\t\t\tswitch ( lctoken ) {\n\t\t\t\tcase \"time\":\n\t\t\t\tcase \"timestamp\":\n\t\t\t\t\treturn WITH;\n\t\t\t\tdefault:\n\t\t\t\t\treturn NONE;\n\t\t\t}\n\t\t}\n\n\t\tpublic TimeZoneTokens nextToken() {\n\t\t\tif ( this == WITH ) {\n\t\t\t\treturn TIME;\n\t\t\t}\n\t\t\telse if ( this == TIME ) {\n\t\t\t\treturn ZONE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn NONE;\n\t\t\t}\n\t\t}\n\n\t\tpublic boolean isToken(String token) {\n\t\t\treturn this != NONE && name().equalsIgnoreCase( token );\n\t\t}\n\t}\n\n\tpublic static List<String> collectColumnNames(\n\t\t\tString sql,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn collectColumnNames( renderWhereStringTemplate( sql, dialect, typeConfiguration, functionRegistry ) );\n\t}\n\n\tpublic static List<String> collectColumnNames(String template) {\n\t\tfinal List<String> names = new ArrayList<>();\n\t\tint begin = 0;\n\t\tint match;\n\t\twhile ( ( match = template.indexOf(TEMPLATE, begin) ) >= 0 ) {\n\t\t\tint start = match + TEMPLATE.length() + 1;\n\t\t\tfor ( int loc = start;; loc++ ) {\n\t\t\t\tif ( loc == template.length() - 1 ) {\n\t\t\t\t\tnames.add( template.substring( start ) );\n\t\t\t\t\tbegin = template.length();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar ch = template.charAt( loc );\n\t\t\t\t\tif ( PUNCTUATION.indexOf(ch) >= 0 || WHITESPACE.indexOf(ch) >= 0 ) {\n\t\t\t\t\t\tnames.add( template.substring( start, loc ) );\n\t\t\t\t\t\tbegin = loc;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn names;\n\t}\n\n//\t/**\n//\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n//\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n//\t * named parameters.\n//\t *\n//\t * @param sqlWhereString The string into which to interpolate the placeholder value\n//\t * @param placeholder The value to be interpolated into the sqlWhereString\n//\t * @param dialect The dialect to apply\n//\t * @param functionRegistry The registry of all sql functions\n//\t *\n//\t * @return The rendered sql fragment\n//\t */\n//\tpublic static String renderWhereStringTemplate(\n//\t\t\tString sqlWhereString,\n//\t\t\tString placeholder,\n//\t\t\tDialect dialect,\n//\t\t\tSQLFunctionRegistry functionRegistry) {\n//\n//\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n//\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n//\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n//\t\t//\t\tidentifier references.\n//\n//\t\tfinal String dialectOpenQuote = Character.toString( dialect.openQuote() );\n//\t\tfinal String dialectCloseQuote = Character.toString( dialect.closeQuote() );\n//\n//\t\tString symbols = new StringBuilder()\n//\t\t\t\t.append( \"=><!+-*/()',|&`\" )\n//\t\t\t\t.append( StringHelper.WHITESPACE )\n//\t\t\t\t.append( dialect.openQuote() )\n//\t\t\t\t.append( dialect.closeQuote() )\n//\t\t\t\t.toString();\n//\t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n//\t\tProcessingState state = new ProcessingState();\n//\n//\t\tStringBuilder quotedBuffer = new StringBuilder();\n//\t\tStringBuilder result = new StringBuilder();\n//\n//\t\tboolean hasMore = tokens.hasMoreTokens();\n//\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n//\t\twhile ( hasMore ) {\n//\t\t\tString token = nextToken;\n//\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n//\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t// First, determine quoting which might be based on either:\n//\t\t\t// \t\t1) back-tick\n//\t\t\t// \t\t2) single quote (ANSI SQL standard)\n//\t\t\t// \t\t3) or dialect defined quote character(s)\n//\t\t\tQuotingCharacterDisposition quotingCharacterDisposition = QuotingCharacterDisposition.NONE;\n//\t\t\tif ( \"`\".equals( token ) ) {\n//\t\t\t\tstate.quoted = !state.quoted;\n//\t\t\t\tquotingCharacterDisposition = state.quoted\n//\t\t\t\t\t\t? QuotingCharacterDisposition.OPEN\n//\t\t\t\t\t\t: QuotingCharacterDisposition.CLOSE;\n//\t\t\t\t// replace token with the appropriate dialect quoting char\n//\t\t\t\ttoken = lcToken = ( quotingCharacterDisposition == QuotingCharacterDisposition.OPEN )\n//\t\t\t\t\t\t? dialectOpenQuote\n//\t\t\t\t\t\t: dialectCloseQuote;\n//\t\t\t}\n//\t\t\telse if ( \"'\".equals( token ) ) {\n//\t\t\t\tstate.quoted = !state.quoted;\n//\t\t\t\tquotingCharacterDisposition = state.quoted\n//\t\t\t\t\t\t? QuotingCharacterDisposition.OPEN\n//\t\t\t\t\t\t: QuotingCharacterDisposition.CLOSE;\n//\t\t\t}\n//\t\t\telse if ( !state.quoted && dialectOpenQuote.equals( token ) ) {\n//\t\t\t\tstate.quoted = true;\n//\t\t\t\tquotingCharacterDisposition = QuotingCharacterDisposition.OPEN;\n//\t\t\t}\n//\t\t\telse if ( state.quoted && dialectCloseQuote.equals( token ) ) {\n//\t\t\t\tstate.quoted = false;\n//\t\t\t\tquotingCharacterDisposition = QuotingCharacterDisposition.CLOSE;\n//\t\t\t}\n//\n//\t\t\tif ( state.quoted ) {\n//\t\t\t\tquotedBuffer.append( token );\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// if we were previously processing quoted state and just encountered the close quote, then handle that\n//\t\t\t// quoted text\n//\t\t\tif ( quotingCharacterDisposition == QuotingCharacterDisposition.CLOSE ) {\n//\t\t\t\ttoken = quotedBuffer.toString();\n//\t\t\t\tquotedBuffer.setLength( 0 );\n//\t\t\t\tresult.append( placeholder ).append( '.' )\n//\t\t\t\t\t\t.append( dialectOpenQuote ).append( token ).append( dialectCloseQuote );\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// Special processing for ANSI SQL EXTRACT function\n//\t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n//\t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n//\t\t\t\tfinal String source = renderWhereStringTemplate(\n//\t\t\t\t\t\textractUntil( tokens, \")\" ),\n//\t\t\t\t\t\tplaceholder,\n//\t\t\t\t\t\tdialect,\n//\t\t\t\t\t\tfunctionRegistry\n//\t\t\t\t);\n//\t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n//\n//\t\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// Special processing for ANSI SQL TRIM function\n//\t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n//\t\t\t\tList<String> operands = new ArrayList<String>();\n//\t\t\t\tStringBuilder builder = new StringBuilder();\n//\n//\t\t\t\tboolean hasMoreOperands = true;\n//\t\t\t\tString operandToken = tokens.nextToken();\n//\t\t\t\tboolean quoted = false;\n//\t\t\t\twhile ( hasMoreOperands ) {\n//\t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n//\t\t\t\t\tif ( isQuote ) {\n//\t\t\t\t\t\tquoted = !quoted;\n//\t\t\t\t\t\tif ( !quoted ) {\n//\t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n//\t\t\t\t\t\t\tbuilder.setLength( 0 );\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse {\n//\t\t\t\t\t\t\tbuilder.append( '\\'' );\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t\telse if ( quoted ) {\n//\t\t\t\t\t\tbuilder.append( operandToken );\n//\t\t\t\t\t}\n//\t\t\t\t\telse if ( operandToken.length() == 1 && Character.isWhitespace( operandToken.charAt( 0 ) ) ) {\n//\t\t\t\t\t\t// do nothing\n//\t\t\t\t\t}\n//\t\t\t\t\telse {\n//\t\t\t\t\t\toperands.add( operandToken );\n//\t\t\t\t\t}\n//\t\t\t\t\toperandToken = tokens.nextToken();\n//\t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ! \")\".equals( operandToken );\n//\t\t\t\t}\n//\n//\t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n//\t\t\t\tresult.append( \"trim(\" );\n//\t\t\t\tif ( trimOperands.trimSpec != null ) {\n//\t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n//\t\t\t\t}\n//\t\t\t\tif ( trimOperands.trimChar != null ) {\n//\t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n//\t\t\t\t\t\tresult.append( trimOperands.trimChar );\n//\t\t\t\t\t}\n//\t\t\t\t\telse {\n//\t\t\t\t\t\tresult.append(\n//\t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, functionRegistry )\n//\t\t\t\t\t\t);\n//\t\t\t\t\t}\n//\t\t\t\t\tresult.append( ' ' );\n//\t\t\t\t}\n//\t\t\t\tif ( trimOperands.from != null ) {\n//\t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n//\t\t\t\t}\n//\t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n//\t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char are specified\n//\t\t\t\t\tresult.append( \"from \" );\n//\t\t\t\t}\n//\n//\t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, functionRegistry ) )\n//\t\t\t\t\t\t.append( ')' );\n//\n//\t\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\n//\t\t\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\n//\t\t\tif ( Character.isWhitespace( token.charAt( 0 ) ) ) {\n//\t\t\t\tresult.append( token );\n//\t\t\t}\n//\t\t\telse if ( state.beforeTable ) {\n//\t\t\t\tresult.append( token );\n//\t\t\t\tstate.beforeTable = false;\n//\t\t\t\tstate.afterFromTable = true;\n//\t\t\t}\n//\t\t\telse if ( state.afterFromTable ) {\n//\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n//\t\t\t\t\tstate.afterFromTable = false;\n//\t\t\t\t}\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\t\t\telse if ( isNamedParameter(token) ) {\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\t\t\telse if ( isIdentifier(token, dialect)\n//\t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect , functionRegistry) ) {\n//\t\t\t\tresult.append(placeholder)\n//\t\t\t\t\t\t.append('.')\n//\t\t\t\t\t\t.append( dialect.quote(token) );\n//\t\t\t}\n//\t\t\telse {\n//\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n//\t\t\t\t\tstate.beforeTable = true;\n//\t\t\t\t\tstate.inFromClause = true;\n//\t\t\t\t}\n//\t\t\t\telse if ( state.inFromClause && \",\".equals(lcToken) ) {\n//\t\t\t\t\tstate.beforeTable = true;\n//\t\t\t\t}\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\n//\t\t\t//Yuck:\n//\t\t\tif ( state.inFromClause\n//\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n//\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n//\t\t\t\tstate.inFromClause = false;\n//\t\t\t}\n//\t\t}\n//\n//\t\treturn result.toString();\n//\t}\n//\n//\tprivate static class ProcessingState {\n//\t\tboolean quoted = false;\n//\t\tboolean quotedIdentifier = false;\n//\t\tboolean beforeTable = false;\n//\t\tboolean inFromClause = false;\n//\t\tboolean afterFromTable = false;\n//\t}\n//\n//\tprivate static enum QuotingCharacterDisposition { NONE, OPEN, CLOSE }\n\n\tprivate static class TrimOperands {\n\t\tprivate final String trimSpec;\n\t\tprivate final String trimChar;\n\t\tprivate final String from;\n\t\tprivate final String trimSource;\n\n\t\tprivate TrimOperands(List<String> operands) {\n\t\t\tfinal int size = operands.size();\n\t\t\tif ( size == 1 ) {\n\t\t\t\ttrimSpec = null;\n\t\t\t\ttrimChar = null;\n\t\t\t\tfrom = null;\n\t\t\t\ttrimSource = operands.get(0);\n\t\t\t}\n\t\t\telse if ( size == 4 ) {\n\t\t\t\ttrimSpec = operands.get(0);\n\t\t\t\ttrimChar = operands.get(1);\n\t\t\t\tfrom = operands.get(2);\n\t\t\t\ttrimSource = operands.get(3);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( size < 1 || size > 4 ) {\n\t\t\t\t\tthrow new HibernateException( \"Unexpected number of trim function operands : \" + size );\n\t\t\t\t}\n\n\t\t\t\t// trim-source will always be the last operand\n\t\t\t\ttrimSource = operands.get( size - 1 );\n\n\t\t\t\t// ANSI SQL says that more than one operand means that the FROM is required\n\t\t\t\tif ( ! \"from\".equals( operands.get( size - 2 ) ) ) {\n\t\t\t\t\tthrow new HibernateException( \"Expecting FROM, found : \" + operands.get( size - 2 ) );\n\t\t\t\t}\n\t\t\t\tfrom = operands.get( size - 2 );\n\n\t\t\t\t// trim-spec, if there is one will always be the first operand\n\t\t\t\tif ( \"leading\".equalsIgnoreCase( operands.get(0) )\n\t\t\t\t\t\t|| \"trailing\".equalsIgnoreCase( operands.get(0) )\n\t\t\t\t\t\t|| \"both\".equalsIgnoreCase( operands.get(0) ) ) {\n\t\t\t\t\ttrimSpec = operands.get(0);\n\t\t\t\t\ttrimChar = null;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttrimSpec = null;\n\t\t\t\t\tif ( size - 2 == 0 ) {\n\t\t\t\t\t\ttrimChar = null;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttrimChar = operands.get( 0 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static String extractUntil(StringTokenizer tokens, String delimiter) {\n\t\tStringBuilder valueBuilder = new StringBuilder();\n\t\tString token = tokens.nextToken();\n\t\twhile ( ! delimiter.equalsIgnoreCase( token ) ) {\n\t\t\tvalueBuilder.append( token );\n\t\t\ttoken = tokens.nextToken();\n\t\t}\n\t\treturn valueBuilder.toString().trim();\n\t}\n\n\tprivate static boolean isNamedParameter(String token) {\n\t\treturn token.startsWith( \":\" );\n\t}\n\n\tprivate static boolean isFunctionOrKeyword(\n\t\t\tString lcToken,\n\t\t\tString nextToken,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn \"(\".equals( nextToken ) ||\n\t\t\t\tKEYWORDS.contains( lcToken ) ||\n\t\t\t\tisType( lcToken, typeConfiguration ) ||\n\t\t\t\tisFunction( lcToken, nextToken, functionRegistry ) ||\n\t\t\t\tdialect.getKeywords().contains( lcToken ) ||\n\t\t\t\tFUNCTION_KEYWORDS.contains( lcToken );\n\t}\n\n\tprivate static boolean isType(String lcToken, TypeConfiguration typeConfiguration) {\n\t\treturn typeConfiguration.getDdlTypeRegistry().isTypeNameRegistered( lcToken );\n\t}\n\n\tprivate static boolean isFunction(String lcToken, String nextToken, SqmFunctionRegistry functionRegistry) {\n\t\t// checking for \"(\" is currently redundant because it is checked before getting here;\n\t\t// doing the check anyhow, in case that earlier check goes away;\n\t\tif ( \"(\".equals( nextToken ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tfinal SqmFunctionDescriptor function = functionRegistry.findFunctionDescriptor( lcToken );\n\t\treturn function != null;\n\t}\n\n\tprivate static boolean isIdentifier(String token) {\n\t\tif ( isBoolean( token ) ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn token.charAt( 0 ) == '`' || ( //allow any identifier quoted with backtick\n\t\t\t\tCharacter.isLetter( token.charAt( 0 ) ) && //only recognizes identifiers beginning with a letter\n\t\t\t\t\t\ttoken.indexOf( '.' ) < 0\n\t\t);\n\t}\n\n\tprivate static boolean isBoolean(String token) {\n\t\treturn \"true\".equals( token ) || \"false\".equals( token );\n\t}\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate isTrimFunction(lcToken String, nextToken String) : boolean extracted from public renderWhereStringTemplate(sqlWhereString String, placeholder String, dialect Dialect, typeConfiguration TypeConfiguration, functionRegistry SqmFunctionRegistry) : String in class org.hibernate.sql.Template",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
                "startLine": 119,
                "endLine": 402,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
                "startLine": 122,
                "endLine": 260,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
                "startLine": 262,
                "endLine": 264,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n\t * named parameters.\n\t *\n\t * @param sqlWhereString The string into which to interpolate the placeholder value\n\t * @param placeholder The value to be interpolated into the sqlWhereString\n\t * @param dialect The dialect to apply\n\t * @param functionRegistry The registry of all sql functions\n\t * @return The rendered sql fragment\n\t */\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\n\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n\t\t//\t\tidentifier references.\n\n\t\tString symbols = PUNCTUATION +\n\t\t\t\tWHITESPACE +\n\t\t\t\tdialect.openQuote() +\n\t\t\t\tdialect.closeQuote();\n\t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n\t\tStringBuilder result = new StringBuilder();\n\n\t\tboolean quoted = false;\n\t\tboolean quotedIdentifier = false;\n\t\tboolean beforeTable = false;\n\t\tboolean inFromClause = false;\n\t\tboolean afterFromTable = false;\n\n\t\tboolean hasMore = tokens.hasMoreTokens();\n\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n\t\twhile ( hasMore ) {\n\t\t\tString token = nextToken;\n\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\tboolean isQuoteCharacter = false;\n\n\t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n\t\t\t\tquoted = !quoted;\n\t\t\t\tisQuoteCharacter = true;\n\t\t\t}\n\n\t\t\tif ( !quoted ) {\n\t\t\t\tboolean isOpenQuote;\n\t\t\t\tif ( \"`\".equals(token) ) {\n\t\t\t\t\tisOpenQuote = !quotedIdentifier;\n\t\t\t\t\ttoken = lcToken = isOpenQuote\n\t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n\t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n\t\t\t\t\tquotedIdentifier = isOpenQuote;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( !quotedIdentifier && ( dialect.openQuote()==token.charAt(0) ) ) {\n\t\t\t\t\tisOpenQuote = true;\n\t\t\t\t\tquotedIdentifier = true;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( quotedIdentifier && ( dialect.closeQuote()==token.charAt(0) ) ) {\n\t\t\t\t\tquotedIdentifier = false;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\telse if ( LITERAL_PREFIXES.contains( lcToken ) ) {\n\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n\t\t\t\t\t\t// Don't prefix a literal\n\t\t\t\t\t\tresult.append( token );\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) ) {\n\t\t\t\t\t\tfinal StringBuilder additionalTokens = new StringBuilder();\n\t\t\t\t\t\tTimeZoneTokens possibleNextToken = null;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tpossibleNextToken = possibleNextToken == null\n\t\t\t\t\t\t\t\t\t? TimeZoneTokens.getPossibleNextTokens( lcToken )\n\t\t\t\t\t\t\t\t\t: possibleNextToken.nextToken();\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tadditionalTokens.append( nextToken );\n\t\t\t\t\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\t\t\t\t\tnextToken = tokens.nextToken();\n\t\t\t\t\t\t\t} while ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) );\n\t\t\t\t\t\t} while ( nextToken != null && possibleNextToken.isToken( nextToken ) );\n\t\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n\t\t\t\t\t\t\t// Don't prefix a literal\n\t\t\t\t\t\t\tresult.append( token );\n\t\t\t\t\t\t\tresult.append( additionalTokens );\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\n\t\t\t\tif ( isOpenQuote ) {\n\t\t\t\t\tresult.append( placeholder ).append( '.' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Special processing for ANSI SQL EXTRACT function\n\t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n\t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n\t\t\t\tfinal String source = renderWhereStringTemplate(\n\t\t\t\t\t\textractUntil( tokens, \")\" ),\n\t\t\t\t\t\tplaceholder,\n\t\t\t\t\t\tdialect,\n\t\t\t\t\t\ttypeConfiguration,\n\t\t\t\t\t\tfunctionRegistry\n\t\t\t\t);\n\t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Special processing for ANSI SQL TRIM function\n\t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n\t\t\t\tList<String> operands = new ArrayList<>();\n\t\t\t\tStringBuilder builder = new StringBuilder();\n\n\t\t\t\tboolean hasMoreOperands = true;\n\t\t\t\tString operandToken = tokens.nextToken();\n\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\tcase \"leading\":\n\t\t\t\t\tcase \"trailing\":\n\t\t\t\t\tcase \"both\":\n\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n\t\t\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tboolean quotedOperand = false;\n\t\t\t\tint parenthesis = 0;\n\t\t\t\twhile ( hasMoreOperands ) {\n\t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n\t\t\t\t\tif ( isQuote ) {\n\t\t\t\t\t\tquotedOperand = !quotedOperand;\n\t\t\t\t\t\tif ( !quotedOperand ) {\n\t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbuilder.append( '\\'' );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if ( quotedOperand ) {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( parenthesis != 0 ) {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t\tswitch ( operandToken ) {\n\t\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"from\":\n\t\t\t\t\t\t\t\tif ( builder.length() != 0 ) {\n\t\t\t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n\t\t\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n\t\t\t\t}\n\t\t\t\tif ( builder.length() != 0 ) {\n\t\t\t\t\toperands.add( builder.toString() );\n\t\t\t\t}\n\n\t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n\t\t\t\tresult.append( \"trim(\" );\n\t\t\t\tif ( trimOperands.trimSpec != null ) {\n\t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n\t\t\t\t}\n\t\t\t\tif ( trimOperands.trimChar != null ) {\n\t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n\t\t\t\t\t\tresult.append( trimOperands.trimChar );\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresult.append(\n\t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tresult.append( ' ' );\n\t\t\t\t}\n\t\t\t\tif ( trimOperands.from != null ) {\n\t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n\t\t\t\t}\n\t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n\t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char is specified\n\t\t\t\t\tresult.append( \"from \" );\n\t\t\t\t}\n\n\t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, typeConfiguration, functionRegistry ) )\n\t\t\t\t\t\t.append( ')' );\n\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tboolean quotedOrWhitespace = quoted || quotedIdentifier || isQuoteCharacter\n\t\t\t\t\t|| Character.isWhitespace( token.charAt(0) );\n\n\t\t\tif ( quotedOrWhitespace ) {\n\t\t\t\tresult.append( token );\n\t\t\t}\n\t\t\telse if ( beforeTable ) {\n\t\t\t\tresult.append( token );\n\t\t\t\tbeforeTable = false;\n\t\t\t\tafterFromTable = true;\n\t\t\t}\n\t\t\telse if ( afterFromTable ) {\n\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n\t\t\t\t\tafterFromTable = false;\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isNamedParameter(token) ) {\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isIdentifier(token)\n\t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect, typeConfiguration, functionRegistry) ) {\n\t\t\t\tresult.append(placeholder)\n\t\t\t\t\t\t.append('.')\n\t\t\t\t\t\t.append( dialect.quote(token) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t\tinFromClause = true;\n\t\t\t\t}\n\t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t}\n\t\t\t\tif ( isBoolean( token ) ) {\n\t\t\t\t\ttoken = dialect.toBooleanValueString( Boolean.parseBoolean( token ) );\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\n\t\t\t//Yuck:\n\t\t\tif ( inFromClause\n\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n\t\t\t\tinFromClause = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result.toString();\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
        "isPureRefactoring": true,
        "commitId": "35f96d6e901dbd071b375d809521ef6f1c979868",
        "packageNameBefore": "org.hibernate.sql",
        "classNameBefore": "org.hibernate.sql.Template",
        "methodNameBefore": "org.hibernate.sql.Template#renderWhereStringTemplate",
        "invokedMethod": "methodSignature: org.hibernate.sql.Template#extractUntil\n methodBody: private static String extractUntil(StringTokenizer tokens, String delimiter) {\nStringBuilder valueBuilder=new StringBuilder();\nString token=tokens.nextToken();\nwhile(!delimiter.equalsIgnoreCase(token)){valueBuilder.append(token);\ntoken=tokens.nextToken();\n}return valueBuilder.toString().trim();\n}\nmethodSignature: org.hibernate.sql.Template#renderWhereStringTemplate\n methodBody: public static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\nString symbols=PUNCTUATION + WHITESPACE + dialect.openQuote() + dialect.closeQuote();\nStringTokenizer tokens=new StringTokenizer(sqlWhereString,symbols,true);\nStringBuilder result=new StringBuilder();\nboolean quoted=false;\nboolean quotedIdentifier=false;\nboolean beforeTable=false;\nboolean inFromClause=false;\nboolean afterFromTable=false;\nboolean hasMore=tokens.hasMoreTokens();\nString nextToken=hasMore ? tokens.nextToken() : null;\nwhile(hasMore){String token=nextToken;\nString lcToken=token.toLowerCase(Locale.ROOT);\nhasMore=tokens.hasMoreTokens();\nnextToken=hasMore ? tokens.nextToken() : null;\nboolean isQuoteCharacter=false;\nif(!quotedIdentifier && \"'\".equals(token)){quoted=!quoted;\nisQuoteCharacter=true;\n}if(!quoted){boolean isOpenQuote;\nif(\"`\".equals(token)){isOpenQuote=!quotedIdentifier;\ntoken=lcToken=isOpenQuote ? Character.toString(dialect.openQuote()) : Character.toString(dialect.closeQuote());\nquotedIdentifier=isOpenQuote;\nisQuoteCharacter=true;\n}if(!quotedIdentifier && (dialect.openQuote() == token.charAt(0))){isOpenQuote=true;\nquotedIdentifier=true;\nisQuoteCharacter=true;\n}if(quotedIdentifier && (dialect.closeQuote() == token.charAt(0))){quotedIdentifier=false;\nisQuoteCharacter=true;\nisOpenQuote=false;\n}if(LITERAL_PREFIXES.contains(lcToken)){if(\"'\".equals(nextToken)){result.append(token);\ncontinue;\n}if(nextToken != null && Character.isWhitespace(nextToken.charAt(0))){final StringBuilder additionalTokens=new StringBuilder();\nTimeZoneTokens possibleNextToken=null;\ndo(nextToken != null && possibleNextToken.isToken(nextToken)){possibleNextToken=possibleNextToken == null ? TimeZoneTokens.getPossibleNextTokens(lcToken) : possibleNextToken.nextToken();\ndo(nextToken != null && Character.isWhitespace(nextToken.charAt(0))){additionalTokens.append(nextToken);\nhasMore=tokens.hasMoreTokens();\nnextToken=tokens.nextToken();\n}}if(\"'\".equals(nextToken)){result.append(token);\nresult.append(additionalTokens);\ncontinue;\n}{isOpenQuote=false;\n}}{isOpenQuote=false;\n}}{isOpenQuote=false;\n}if(isOpenQuote){result.append(placeholder).append('.');\n}}if(\"extract\".equals(lcToken) && \"(\".equals(nextToken)){final String field=extractUntil(tokens,\"from\");\nfinal String source=renderWhereStringTemplate(extractUntil(tokens,\")\"),placeholder,dialect,typeConfiguration,functionRegistry);\nresult.append(\"extract(\").append(field).append(\" from \").append(source).append(')');\nhasMore=tokens.hasMoreTokens();\nnextToken=hasMore ? tokens.nextToken() : null;\ncontinue;\n}if(\"trim\".equals(lcToken) && \"(\".equals(nextToken)){List<String> operands=new ArrayList<>();\nStringBuilder builder=new StringBuilder();\nboolean hasMoreOperands=true;\nString operandToken=tokens.nextToken();\nswitch(operandToken.toLowerCase(Locale.ROOT))case \"leading\":case \"trailing\":case \"both\":operands.add(operandToken);\nif(hasMoreOperands=tokens.hasMoreTokens()){operandToken=tokens.nextToken();\n}break;\nboolean quotedOperand=false;\nint parenthesis=0;\nwhile(hasMoreOperands){final boolean isQuote=\"'\".equals(operandToken);\nif(isQuote){quotedOperand=!quotedOperand;\nif(!quotedOperand){operands.add(builder.append('\\'').toString());\nbuilder.setLength(0);\n}{builder.append('\\'');\n}}if(quotedOperand){builder.append(operandToken);\n}if(parenthesis != 0){builder.append(operandToken);\nswitch(operandToken)case \"(\":parenthesis++;\nbreak;\ncase \")\":parenthesis--;\nbreak;\n}{builder.append(operandToken);\nswitch(operandToken.toLowerCase(Locale.ROOT))case \"(\":parenthesis++;\nbreak;\ncase \")\":parenthesis--;\nbreak;\ncase \"from\":if(builder.length() != 0){operands.add(builder.substring(0,builder.length() - 4));\nbuilder.setLength(0);\noperands.add(operandToken);\n}break;\n}operandToken=tokens.nextToken();\nhasMoreOperands=tokens.hasMoreTokens() && (parenthesis != 0 || !\")\".equals(operandToken));\n}if(builder.length() != 0){operands.add(builder.toString());\n}TrimOperands trimOperands=new TrimOperands(operands);\nresult.append(\"trim(\");\nif(trimOperands.trimSpec != null){result.append(trimOperands.trimSpec).append(' ');\n}if(trimOperands.trimChar != null){if(trimOperands.trimChar.startsWith(\"'\") && trimOperands.trimChar.endsWith(\"'\")){result.append(trimOperands.trimChar);\n}{result.append(renderWhereStringTemplate(trimOperands.trimSpec,placeholder,dialect,typeConfiguration,functionRegistry));\n}result.append(' ');\n}if(trimOperands.from != null){result.append(trimOperands.from).append(' ');\n}if(trimOperands.trimSpec != null || trimOperands.trimChar != null){result.append(\"from \");\n}result.append(renderWhereStringTemplate(trimOperands.trimSource,placeholder,dialect,typeConfiguration,functionRegistry)).append(')');\nhasMore=tokens.hasMoreTokens();\nnextToken=hasMore ? tokens.nextToken() : null;\ncontinue;\n}boolean quotedOrWhitespace=quoted || quotedIdentifier || isQuoteCharacter || Character.isWhitespace(token.charAt(0));\nif(quotedOrWhitespace){result.append(token);\n}if(beforeTable){result.append(token);\nbeforeTable=false;\nafterFromTable=true;\n}if(afterFromTable){if(!\"as\".equals(lcToken)){afterFromTable=false;\n}result.append(token);\n}if(isNamedParameter(token)){result.append(token);\n}if(isIdentifier(token) && !isFunctionOrKeyword(lcToken,nextToken,dialect,typeConfiguration,functionRegistry)){result.append(placeholder).append('.').append(dialect.quote(token));\n}{if(BEFORE_TABLE_KEYWORDS.contains(lcToken)){beforeTable=true;\ninFromClause=true;\n}if(inFromClause && \",\".equals(lcToken)){beforeTable=true;\n}if(isBoolean(token)){token=dialect.toBooleanValueString(Boolean.parseBoolean(token));\n}result.append(token);\n}if(inFromClause && KEYWORDS.contains(lcToken) && !BEFORE_TABLE_KEYWORDS.contains(lcToken)){inFromClause=false;\n}}return result.toString();\n}\nmethodSignature: org.hibernate.sql.Template.TimeZoneTokens#isToken\n methodBody: public boolean isToken(String token) {\nreturn this != NONE && name().equalsIgnoreCase(token);\n}\nmethodSignature: org.hibernate.sql.Template#isBoolean\n methodBody: private static boolean isBoolean(String token) {\nreturn \"true\".equals(token) || \"false\".equals(token);\n}\nmethodSignature: org.hibernate.sql.Template.TimeZoneTokens#nextToken\n methodBody: public TimeZoneTokens nextToken() {\nif(this == WITH){return TIME;\n}if(this == TIME){return ZONE;\n}{return NONE;\n}}\nmethodSignature: org.hibernate.sql.Template.TimeZoneTokens#getPossibleNextTokens\n methodBody: static TimeZoneTokens getPossibleNextTokens(String lctoken) {\nswitch(lctoken)case \"time\":case \"timestamp\":return WITH;\ndefault:return NONE;\n}\nmethodSignature: org.hibernate.sql.Template#isIdentifier\n methodBody: private static boolean isIdentifier(String token) {\nif(isBoolean(token)){return false;\n}return token.charAt(0) == '`' || (Character.isLetter(token.charAt(0)) && token.indexOf('.') < 0);\n}\nmethodSignature: org.hibernate.sql.Template#isNamedParameter\n methodBody: private static boolean isNamedParameter(String token) {\nreturn token.startsWith(\":\");\n}\nmethodSignature: org.hibernate.sql.Template#isFunctionOrKeyword\n methodBody: private static boolean isFunctionOrKeyword(\n\t\t\tString lcToken,\n\t\t\tString nextToken,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\nreturn \"(\".equals(nextToken) || KEYWORDS.contains(lcToken) || isType(lcToken,typeConfiguration) || isFunction(lcToken,nextToken,functionRegistry) || dialect.getKeywords().contains(lcToken) || FUNCTION_KEYWORDS.contains(lcToken);\n}",
        "classSignatureBefore": "public final class Template ",
        "methodNameBeforeSet": [
            "org.hibernate.sql.Template#renderWhereStringTemplate"
        ],
        "classNameBeforeSet": [
            "org.hibernate.sql.Template"
        ],
        "classSignatureBeforeSet": [
            "public final class Template "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.sql;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.query.sqm.function.SqmFunctionDescriptor;\nimport org.hibernate.query.sqm.function.SqmFunctionRegistry;\nimport org.hibernate.type.spi.TypeConfiguration;\n\nimport static org.hibernate.internal.util.StringHelper.WHITESPACE;\n\n/**\n * Parses SQL fragments specified in mapping documents.\n *\n * @author Gavin King\n */\npublic final class Template {\n\n\tprivate static final Set<String> KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> BEFORE_TABLE_KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> FUNCTION_KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> LITERAL_PREFIXES = new HashSet<>();\n\tpublic static final String PUNCTUATION = \"=><!+-*/()',|&`\";\n\n\tstatic {\n\t\tKEYWORDS.add(\"and\");\n\t\tKEYWORDS.add(\"or\");\n\t\tKEYWORDS.add(\"not\");\n\t\tKEYWORDS.add(\"like\");\n\t\tKEYWORDS.add(\"escape\");\n\t\tKEYWORDS.add(\"is\");\n\t\tKEYWORDS.add(\"in\");\n\t\tKEYWORDS.add(\"between\");\n\t\tKEYWORDS.add(\"null\");\n\t\tKEYWORDS.add(\"select\");\n\t\tKEYWORDS.add(\"distinct\");\n\t\tKEYWORDS.add(\"from\");\n\t\tKEYWORDS.add(\"join\");\n\t\tKEYWORDS.add(\"inner\");\n\t\tKEYWORDS.add(\"outer\");\n\t\tKEYWORDS.add(\"left\");\n\t\tKEYWORDS.add(\"right\");\n\t\tKEYWORDS.add(\"on\");\n\t\tKEYWORDS.add(\"where\");\n\t\tKEYWORDS.add(\"having\");\n\t\tKEYWORDS.add(\"group\");\n\t\tKEYWORDS.add(\"order\");\n\t\tKEYWORDS.add(\"by\");\n\t\tKEYWORDS.add(\"desc\");\n\t\tKEYWORDS.add(\"asc\");\n\t\tKEYWORDS.add(\"limit\");\n\t\tKEYWORDS.add(\"any\");\n\t\tKEYWORDS.add(\"some\");\n\t\tKEYWORDS.add(\"exists\");\n\t\tKEYWORDS.add(\"all\");\n\t\tKEYWORDS.add(\"union\");\n\t\tKEYWORDS.add(\"minus\");\n\t\tKEYWORDS.add(\"except\");\n\t\tKEYWORDS.add(\"intersect\");\n\t\tKEYWORDS.add(\"partition\");\n\n\t\tBEFORE_TABLE_KEYWORDS.add(\"from\");\n\t\tBEFORE_TABLE_KEYWORDS.add(\"join\");\n\n\t\tFUNCTION_KEYWORDS.add(\"as\");\n\t\tFUNCTION_KEYWORDS.add(\"leading\");\n\t\tFUNCTION_KEYWORDS.add(\"trailing\");\n\t\tFUNCTION_KEYWORDS.add(\"from\");\n\t\tFUNCTION_KEYWORDS.add(\"case\");\n\t\tFUNCTION_KEYWORDS.add(\"when\");\n\t\tFUNCTION_KEYWORDS.add(\"then\");\n\t\tFUNCTION_KEYWORDS.add(\"else\");\n\t\tFUNCTION_KEYWORDS.add(\"end\");\n\n\t\tLITERAL_PREFIXES.add(\"n\");\n\t\tLITERAL_PREFIXES.add(\"x\");\n\t\tLITERAL_PREFIXES.add(\"varbyte\");\n\t\tLITERAL_PREFIXES.add(\"bx\");\n\t\tLITERAL_PREFIXES.add(\"bytea\");\n\t\tLITERAL_PREFIXES.add(\"date\");\n\t\tLITERAL_PREFIXES.add(\"time\");\n\t\tLITERAL_PREFIXES.add(\"timestamp\");\n\t}\n\n\tpublic static final String TEMPLATE = \"$PlaceHolder$\";\n\n\tprivate Template() {}\n\n\tpublic static String renderTransformerReadFragment(\n\t\t\tString fragment,\n\t\t\tString... columnNames) {\n\t\t// NOTE : would need access to SessionFactoryImplementor to make this configurable\n\t\tfor ( String columnName : columnNames ) {\n\t\t\tfragment = fragment.replace( columnName, TEMPLATE + '.' + columnName );\n\t\t}\n\t\treturn fragment;\n\t}\n\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn renderWhereStringTemplate( sqlWhereString, TEMPLATE, dialect, typeConfiguration, functionRegistry );\n\t}\n\n\t/**\n\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n\t * named parameters.\n\t *\n\t * @param sqlWhereString The string into which to interpolate the placeholder value\n\t * @param placeholder The value to be interpolated into the sqlWhereString\n\t * @param dialect The dialect to apply\n\t * @param functionRegistry The registry of all sql functions\n\t * @return The rendered sql fragment\n\t */\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\n\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n\t\t//\t\tidentifier references.\n\n\t\tString symbols = PUNCTUATION +\n\t\t\t\tWHITESPACE +\n\t\t\t\tdialect.openQuote() +\n\t\t\t\tdialect.closeQuote();\n\t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n\t\tStringBuilder result = new StringBuilder();\n\n\t\tboolean quoted = false;\n\t\tboolean quotedIdentifier = false;\n\t\tboolean beforeTable = false;\n\t\tboolean inFromClause = false;\n\t\tboolean afterFromTable = false;\n\n\t\tboolean hasMore = tokens.hasMoreTokens();\n\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n\t\twhile ( hasMore ) {\n\t\t\tString token = nextToken;\n\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\tboolean isQuoteCharacter = false;\n\n\t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n\t\t\t\tquoted = !quoted;\n\t\t\t\tisQuoteCharacter = true;\n\t\t\t}\n\n\t\t\tif ( !quoted ) {\n\t\t\t\tboolean isOpenQuote;\n\t\t\t\tif ( \"`\".equals(token) ) {\n\t\t\t\t\tisOpenQuote = !quotedIdentifier;\n\t\t\t\t\ttoken = lcToken = isOpenQuote\n\t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n\t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n\t\t\t\t\tquotedIdentifier = isOpenQuote;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( !quotedIdentifier && ( dialect.openQuote()==token.charAt(0) ) ) {\n\t\t\t\t\tisOpenQuote = true;\n\t\t\t\t\tquotedIdentifier = true;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( quotedIdentifier && ( dialect.closeQuote()==token.charAt(0) ) ) {\n\t\t\t\t\tquotedIdentifier = false;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\telse if ( LITERAL_PREFIXES.contains( lcToken ) ) {\n\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n\t\t\t\t\t\t// Don't prefix a literal\n\t\t\t\t\t\tresult.append( token );\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) ) {\n\t\t\t\t\t\tfinal StringBuilder additionalTokens = new StringBuilder();\n\t\t\t\t\t\tTimeZoneTokens possibleNextToken = null;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tpossibleNextToken = possibleNextToken == null\n\t\t\t\t\t\t\t\t\t? TimeZoneTokens.getPossibleNextTokens( lcToken )\n\t\t\t\t\t\t\t\t\t: possibleNextToken.nextToken();\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tadditionalTokens.append( nextToken );\n\t\t\t\t\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\t\t\t\t\tnextToken = tokens.nextToken();\n\t\t\t\t\t\t\t} while ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) );\n\t\t\t\t\t\t} while ( nextToken != null && possibleNextToken.isToken( nextToken ) );\n\t\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n\t\t\t\t\t\t\t// Don't prefix a literal\n\t\t\t\t\t\t\tresult.append( token );\n\t\t\t\t\t\t\tresult.append( additionalTokens );\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\n\t\t\t\tif ( isOpenQuote ) {\n\t\t\t\t\tresult.append( placeholder ).append( '.' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Special processing for ANSI SQL EXTRACT function\n\t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n\t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n\t\t\t\tfinal String source = renderWhereStringTemplate(\n\t\t\t\t\t\textractUntil( tokens, \")\" ),\n\t\t\t\t\t\tplaceholder,\n\t\t\t\t\t\tdialect,\n\t\t\t\t\t\ttypeConfiguration,\n\t\t\t\t\t\tfunctionRegistry\n\t\t\t\t);\n\t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Special processing for ANSI SQL TRIM function\n\t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n\t\t\t\tList<String> operands = new ArrayList<>();\n\t\t\t\tStringBuilder builder = new StringBuilder();\n\n\t\t\t\tboolean hasMoreOperands = true;\n\t\t\t\tString operandToken = tokens.nextToken();\n\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\tcase \"leading\":\n\t\t\t\t\tcase \"trailing\":\n\t\t\t\t\tcase \"both\":\n\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n\t\t\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tboolean quotedOperand = false;\n\t\t\t\tint parenthesis = 0;\n\t\t\t\twhile ( hasMoreOperands ) {\n\t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n\t\t\t\t\tif ( isQuote ) {\n\t\t\t\t\t\tquotedOperand = !quotedOperand;\n\t\t\t\t\t\tif ( !quotedOperand ) {\n\t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbuilder.append( '\\'' );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if ( quotedOperand ) {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( parenthesis != 0 ) {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t\tswitch ( operandToken ) {\n\t\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"from\":\n\t\t\t\t\t\t\t\tif ( builder.length() != 0 ) {\n\t\t\t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n\t\t\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n\t\t\t\t}\n\t\t\t\tif ( builder.length() != 0 ) {\n\t\t\t\t\toperands.add( builder.toString() );\n\t\t\t\t}\n\n\t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n\t\t\t\tresult.append( \"trim(\" );\n\t\t\t\tif ( trimOperands.trimSpec != null ) {\n\t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n\t\t\t\t}\n\t\t\t\tif ( trimOperands.trimChar != null ) {\n\t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n\t\t\t\t\t\tresult.append( trimOperands.trimChar );\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresult.append(\n\t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tresult.append( ' ' );\n\t\t\t\t}\n\t\t\t\tif ( trimOperands.from != null ) {\n\t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n\t\t\t\t}\n\t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n\t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char is specified\n\t\t\t\t\tresult.append( \"from \" );\n\t\t\t\t}\n\n\t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, typeConfiguration, functionRegistry ) )\n\t\t\t\t\t\t.append( ')' );\n\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tboolean quotedOrWhitespace = quoted || quotedIdentifier || isQuoteCharacter\n\t\t\t\t\t|| Character.isWhitespace( token.charAt(0) );\n\n\t\t\tif ( quotedOrWhitespace ) {\n\t\t\t\tresult.append( token );\n\t\t\t}\n\t\t\telse if ( beforeTable ) {\n\t\t\t\tresult.append( token );\n\t\t\t\tbeforeTable = false;\n\t\t\t\tafterFromTable = true;\n\t\t\t}\n\t\t\telse if ( afterFromTable ) {\n\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n\t\t\t\t\tafterFromTable = false;\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isNamedParameter(token) ) {\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isIdentifier(token)\n\t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect, typeConfiguration, functionRegistry) ) {\n\t\t\t\tresult.append(placeholder)\n\t\t\t\t\t\t.append('.')\n\t\t\t\t\t\t.append( dialect.quote(token) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t\tinFromClause = true;\n\t\t\t\t}\n\t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t}\n\t\t\t\tif ( isBoolean( token ) ) {\n\t\t\t\t\ttoken = dialect.toBooleanValueString( Boolean.parseBoolean( token ) );\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\n\t\t\t//Yuck:\n\t\t\tif ( inFromClause\n\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n\t\t\t\tinFromClause = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result.toString();\n\t}\n\n\tprivate enum TimeZoneTokens {\n\t\tNONE,\n\t\tWITH,\n\t\tTIME,\n\t\tZONE;\n\n\t\tstatic TimeZoneTokens getPossibleNextTokens(String lctoken) {\n\t\t\tswitch ( lctoken ) {\n\t\t\t\tcase \"time\":\n\t\t\t\tcase \"timestamp\":\n\t\t\t\t\treturn WITH;\n\t\t\t\tdefault:\n\t\t\t\t\treturn NONE;\n\t\t\t}\n\t\t}\n\n\t\tpublic TimeZoneTokens nextToken() {\n\t\t\tif ( this == WITH ) {\n\t\t\t\treturn TIME;\n\t\t\t}\n\t\t\telse if ( this == TIME ) {\n\t\t\t\treturn ZONE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn NONE;\n\t\t\t}\n\t\t}\n\n\t\tpublic boolean isToken(String token) {\n\t\t\treturn this != NONE && name().equalsIgnoreCase( token );\n\t\t}\n\t}\n\n\tpublic static List<String> collectColumnNames(\n\t\t\tString sql,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn collectColumnNames( renderWhereStringTemplate( sql, dialect, typeConfiguration, functionRegistry ) );\n\t}\n\n\tpublic static List<String> collectColumnNames(String template) {\n\t\tfinal List<String> names = new ArrayList<>();\n\t\tint begin = 0;\n\t\tint match;\n\t\twhile ( ( match = template.indexOf(TEMPLATE, begin) ) >= 0 ) {\n\t\t\tint start = match + TEMPLATE.length() + 1;\n\t\t\tfor ( int loc = start;; loc++ ) {\n\t\t\t\tif ( loc == template.length() - 1 ) {\n\t\t\t\t\tnames.add( template.substring( start ) );\n\t\t\t\t\tbegin = template.length();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar ch = template.charAt( loc );\n\t\t\t\t\tif ( PUNCTUATION.indexOf(ch) >= 0 || WHITESPACE.indexOf(ch) >= 0 ) {\n\t\t\t\t\t\tnames.add( template.substring( start, loc ) );\n\t\t\t\t\t\tbegin = loc;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn names;\n\t}\n\n//\t/**\n//\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n//\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n//\t * named parameters.\n//\t *\n//\t * @param sqlWhereString The string into which to interpolate the placeholder value\n//\t * @param placeholder The value to be interpolated into the sqlWhereString\n//\t * @param dialect The dialect to apply\n//\t * @param functionRegistry The registry of all sql functions\n//\t *\n//\t * @return The rendered sql fragment\n//\t */\n//\tpublic static String renderWhereStringTemplate(\n//\t\t\tString sqlWhereString,\n//\t\t\tString placeholder,\n//\t\t\tDialect dialect,\n//\t\t\tSQLFunctionRegistry functionRegistry) {\n//\n//\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n//\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n//\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n//\t\t//\t\tidentifier references.\n//\n//\t\tfinal String dialectOpenQuote = Character.toString( dialect.openQuote() );\n//\t\tfinal String dialectCloseQuote = Character.toString( dialect.closeQuote() );\n//\n//\t\tString symbols = new StringBuilder()\n//\t\t\t\t.append( \"=><!+-*/()',|&`\" )\n//\t\t\t\t.append( StringHelper.WHITESPACE )\n//\t\t\t\t.append( dialect.openQuote() )\n//\t\t\t\t.append( dialect.closeQuote() )\n//\t\t\t\t.toString();\n//\t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n//\t\tProcessingState state = new ProcessingState();\n//\n//\t\tStringBuilder quotedBuffer = new StringBuilder();\n//\t\tStringBuilder result = new StringBuilder();\n//\n//\t\tboolean hasMore = tokens.hasMoreTokens();\n//\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n//\t\twhile ( hasMore ) {\n//\t\t\tString token = nextToken;\n//\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n//\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t// First, determine quoting which might be based on either:\n//\t\t\t// \t\t1) back-tick\n//\t\t\t// \t\t2) single quote (ANSI SQL standard)\n//\t\t\t// \t\t3) or dialect defined quote character(s)\n//\t\t\tQuotingCharacterDisposition quotingCharacterDisposition = QuotingCharacterDisposition.NONE;\n//\t\t\tif ( \"`\".equals( token ) ) {\n//\t\t\t\tstate.quoted = !state.quoted;\n//\t\t\t\tquotingCharacterDisposition = state.quoted\n//\t\t\t\t\t\t? QuotingCharacterDisposition.OPEN\n//\t\t\t\t\t\t: QuotingCharacterDisposition.CLOSE;\n//\t\t\t\t// replace token with the appropriate dialect quoting char\n//\t\t\t\ttoken = lcToken = ( quotingCharacterDisposition == QuotingCharacterDisposition.OPEN )\n//\t\t\t\t\t\t? dialectOpenQuote\n//\t\t\t\t\t\t: dialectCloseQuote;\n//\t\t\t}\n//\t\t\telse if ( \"'\".equals( token ) ) {\n//\t\t\t\tstate.quoted = !state.quoted;\n//\t\t\t\tquotingCharacterDisposition = state.quoted\n//\t\t\t\t\t\t? QuotingCharacterDisposition.OPEN\n//\t\t\t\t\t\t: QuotingCharacterDisposition.CLOSE;\n//\t\t\t}\n//\t\t\telse if ( !state.quoted && dialectOpenQuote.equals( token ) ) {\n//\t\t\t\tstate.quoted = true;\n//\t\t\t\tquotingCharacterDisposition = QuotingCharacterDisposition.OPEN;\n//\t\t\t}\n//\t\t\telse if ( state.quoted && dialectCloseQuote.equals( token ) ) {\n//\t\t\t\tstate.quoted = false;\n//\t\t\t\tquotingCharacterDisposition = QuotingCharacterDisposition.CLOSE;\n//\t\t\t}\n//\n//\t\t\tif ( state.quoted ) {\n//\t\t\t\tquotedBuffer.append( token );\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// if we were previously processing quoted state and just encountered the close quote, then handle that\n//\t\t\t// quoted text\n//\t\t\tif ( quotingCharacterDisposition == QuotingCharacterDisposition.CLOSE ) {\n//\t\t\t\ttoken = quotedBuffer.toString();\n//\t\t\t\tquotedBuffer.setLength( 0 );\n//\t\t\t\tresult.append( placeholder ).append( '.' )\n//\t\t\t\t\t\t.append( dialectOpenQuote ).append( token ).append( dialectCloseQuote );\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// Special processing for ANSI SQL EXTRACT function\n//\t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n//\t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n//\t\t\t\tfinal String source = renderWhereStringTemplate(\n//\t\t\t\t\t\textractUntil( tokens, \")\" ),\n//\t\t\t\t\t\tplaceholder,\n//\t\t\t\t\t\tdialect,\n//\t\t\t\t\t\tfunctionRegistry\n//\t\t\t\t);\n//\t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n//\n//\t\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// Special processing for ANSI SQL TRIM function\n//\t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n//\t\t\t\tList<String> operands = new ArrayList<String>();\n//\t\t\t\tStringBuilder builder = new StringBuilder();\n//\n//\t\t\t\tboolean hasMoreOperands = true;\n//\t\t\t\tString operandToken = tokens.nextToken();\n//\t\t\t\tboolean quoted = false;\n//\t\t\t\twhile ( hasMoreOperands ) {\n//\t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n//\t\t\t\t\tif ( isQuote ) {\n//\t\t\t\t\t\tquoted = !quoted;\n//\t\t\t\t\t\tif ( !quoted ) {\n//\t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n//\t\t\t\t\t\t\tbuilder.setLength( 0 );\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse {\n//\t\t\t\t\t\t\tbuilder.append( '\\'' );\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t\telse if ( quoted ) {\n//\t\t\t\t\t\tbuilder.append( operandToken );\n//\t\t\t\t\t}\n//\t\t\t\t\telse if ( operandToken.length() == 1 && Character.isWhitespace( operandToken.charAt( 0 ) ) ) {\n//\t\t\t\t\t\t// do nothing\n//\t\t\t\t\t}\n//\t\t\t\t\telse {\n//\t\t\t\t\t\toperands.add( operandToken );\n//\t\t\t\t\t}\n//\t\t\t\t\toperandToken = tokens.nextToken();\n//\t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ! \")\".equals( operandToken );\n//\t\t\t\t}\n//\n//\t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n//\t\t\t\tresult.append( \"trim(\" );\n//\t\t\t\tif ( trimOperands.trimSpec != null ) {\n//\t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n//\t\t\t\t}\n//\t\t\t\tif ( trimOperands.trimChar != null ) {\n//\t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n//\t\t\t\t\t\tresult.append( trimOperands.trimChar );\n//\t\t\t\t\t}\n//\t\t\t\t\telse {\n//\t\t\t\t\t\tresult.append(\n//\t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, functionRegistry )\n//\t\t\t\t\t\t);\n//\t\t\t\t\t}\n//\t\t\t\t\tresult.append( ' ' );\n//\t\t\t\t}\n//\t\t\t\tif ( trimOperands.from != null ) {\n//\t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n//\t\t\t\t}\n//\t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n//\t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char are specified\n//\t\t\t\t\tresult.append( \"from \" );\n//\t\t\t\t}\n//\n//\t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, functionRegistry ) )\n//\t\t\t\t\t\t.append( ')' );\n//\n//\t\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\n//\t\t\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\n//\t\t\tif ( Character.isWhitespace( token.charAt( 0 ) ) ) {\n//\t\t\t\tresult.append( token );\n//\t\t\t}\n//\t\t\telse if ( state.beforeTable ) {\n//\t\t\t\tresult.append( token );\n//\t\t\t\tstate.beforeTable = false;\n//\t\t\t\tstate.afterFromTable = true;\n//\t\t\t}\n//\t\t\telse if ( state.afterFromTable ) {\n//\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n//\t\t\t\t\tstate.afterFromTable = false;\n//\t\t\t\t}\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\t\t\telse if ( isNamedParameter(token) ) {\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\t\t\telse if ( isIdentifier(token, dialect)\n//\t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect , functionRegistry) ) {\n//\t\t\t\tresult.append(placeholder)\n//\t\t\t\t\t\t.append('.')\n//\t\t\t\t\t\t.append( dialect.quote(token) );\n//\t\t\t}\n//\t\t\telse {\n//\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n//\t\t\t\t\tstate.beforeTable = true;\n//\t\t\t\t\tstate.inFromClause = true;\n//\t\t\t\t}\n//\t\t\t\telse if ( state.inFromClause && \",\".equals(lcToken) ) {\n//\t\t\t\t\tstate.beforeTable = true;\n//\t\t\t\t}\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\n//\t\t\t//Yuck:\n//\t\t\tif ( state.inFromClause\n//\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n//\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n//\t\t\t\tstate.inFromClause = false;\n//\t\t\t}\n//\t\t}\n//\n//\t\treturn result.toString();\n//\t}\n//\n//\tprivate static class ProcessingState {\n//\t\tboolean quoted = false;\n//\t\tboolean quotedIdentifier = false;\n//\t\tboolean beforeTable = false;\n//\t\tboolean inFromClause = false;\n//\t\tboolean afterFromTable = false;\n//\t}\n//\n//\tprivate static enum QuotingCharacterDisposition { NONE, OPEN, CLOSE }\n\n\tprivate static class TrimOperands {\n\t\tprivate final String trimSpec;\n\t\tprivate final String trimChar;\n\t\tprivate final String from;\n\t\tprivate final String trimSource;\n\n\t\tprivate TrimOperands(List<String> operands) {\n\t\t\tfinal int size = operands.size();\n\t\t\tif ( size == 1 ) {\n\t\t\t\ttrimSpec = null;\n\t\t\t\ttrimChar = null;\n\t\t\t\tfrom = null;\n\t\t\t\ttrimSource = operands.get(0);\n\t\t\t}\n\t\t\telse if ( size == 4 ) {\n\t\t\t\ttrimSpec = operands.get(0);\n\t\t\t\ttrimChar = operands.get(1);\n\t\t\t\tfrom = operands.get(2);\n\t\t\t\ttrimSource = operands.get(3);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( size < 1 || size > 4 ) {\n\t\t\t\t\tthrow new HibernateException( \"Unexpected number of trim function operands : \" + size );\n\t\t\t\t}\n\n\t\t\t\t// trim-source will always be the last operand\n\t\t\t\ttrimSource = operands.get( size - 1 );\n\n\t\t\t\t// ANSI SQL says that more than one operand means that the FROM is required\n\t\t\t\tif ( ! \"from\".equals( operands.get( size - 2 ) ) ) {\n\t\t\t\t\tthrow new HibernateException( \"Expecting FROM, found : \" + operands.get( size - 2 ) );\n\t\t\t\t}\n\t\t\t\tfrom = operands.get( size - 2 );\n\n\t\t\t\t// trim-spec, if there is one will always be the first operand\n\t\t\t\tif ( \"leading\".equalsIgnoreCase( operands.get(0) )\n\t\t\t\t\t\t|| \"trailing\".equalsIgnoreCase( operands.get(0) )\n\t\t\t\t\t\t|| \"both\".equalsIgnoreCase( operands.get(0) ) ) {\n\t\t\t\t\ttrimSpec = operands.get(0);\n\t\t\t\t\ttrimChar = null;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttrimSpec = null;\n\t\t\t\t\tif ( size - 2 == 0 ) {\n\t\t\t\t\t\ttrimChar = null;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttrimChar = operands.get( 0 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static String extractUntil(StringTokenizer tokens, String delimiter) {\n\t\tStringBuilder valueBuilder = new StringBuilder();\n\t\tString token = tokens.nextToken();\n\t\twhile ( ! delimiter.equalsIgnoreCase( token ) ) {\n\t\t\tvalueBuilder.append( token );\n\t\t\ttoken = tokens.nextToken();\n\t\t}\n\t\treturn valueBuilder.toString().trim();\n\t}\n\n\tprivate static boolean isNamedParameter(String token) {\n\t\treturn token.startsWith( \":\" );\n\t}\n\n\tprivate static boolean isFunctionOrKeyword(\n\t\t\tString lcToken,\n\t\t\tString nextToken,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn \"(\".equals( nextToken ) ||\n\t\t\t\tKEYWORDS.contains( lcToken ) ||\n\t\t\t\tisType( lcToken, typeConfiguration ) ||\n\t\t\t\tisFunction( lcToken, nextToken, functionRegistry ) ||\n\t\t\t\tdialect.getKeywords().contains( lcToken ) ||\n\t\t\t\tFUNCTION_KEYWORDS.contains( lcToken );\n\t}\n\n\tprivate static boolean isType(String lcToken, TypeConfiguration typeConfiguration) {\n\t\treturn typeConfiguration.getDdlTypeRegistry().isTypeNameRegistered( lcToken );\n\t}\n\n\tprivate static boolean isFunction(String lcToken, String nextToken, SqmFunctionRegistry functionRegistry) {\n\t\t// checking for \"(\" is currently redundant because it is checked before getting here;\n\t\t// doing the check anyhow, in case that earlier check goes away;\n\t\tif ( \"(\".equals( nextToken ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tfinal SqmFunctionDescriptor function = functionRegistry.findFunctionDescriptor( lcToken );\n\t\treturn function != null;\n\t}\n\n\tprivate static boolean isIdentifier(String token) {\n\t\tif ( isBoolean( token ) ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn token.charAt( 0 ) == '`' || ( //allow any identifier quoted with backtick\n\t\t\t\tCharacter.isLetter( token.charAt( 0 ) ) && //only recognizes identifiers beginning with a letter\n\t\t\t\t\t\ttoken.indexOf( '.' ) < 0\n\t\t);\n\t}\n\n\tprivate static boolean isBoolean(String token) {\n\t\treturn \"true\".equals( token ) || \"false\".equals( token );\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/sql/Template.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.sql;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.query.sqm.function.SqmFunctionDescriptor;\nimport org.hibernate.query.sqm.function.SqmFunctionRegistry;\nimport org.hibernate.type.spi.TypeConfiguration;\n\nimport static java.lang.Boolean.parseBoolean;\nimport static java.lang.Character.isLetter;\nimport static org.hibernate.internal.util.StringHelper.WHITESPACE;\n\n/**\n * Parses SQL fragments specified in mapping documents.\n *\n * @author Gavin King\n */\npublic final class Template {\n\n\tprivate static final Set<String> KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> BEFORE_TABLE_KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> FUNCTION_KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> LITERAL_PREFIXES = new HashSet<>();\n\tpublic static final String PUNCTUATION = \"=><!+-*/()',|&`\";\n\n\tstatic {\n\t\tKEYWORDS.add(\"and\");\n\t\tKEYWORDS.add(\"or\");\n\t\tKEYWORDS.add(\"not\");\n\t\tKEYWORDS.add(\"like\");\n\t\tKEYWORDS.add(\"escape\");\n\t\tKEYWORDS.add(\"is\");\n\t\tKEYWORDS.add(\"in\");\n\t\tKEYWORDS.add(\"between\");\n\t\tKEYWORDS.add(\"null\");\n\t\tKEYWORDS.add(\"select\");\n\t\tKEYWORDS.add(\"distinct\");\n\t\tKEYWORDS.add(\"from\");\n\t\tKEYWORDS.add(\"join\");\n\t\tKEYWORDS.add(\"inner\");\n\t\tKEYWORDS.add(\"outer\");\n\t\tKEYWORDS.add(\"left\");\n\t\tKEYWORDS.add(\"right\");\n\t\tKEYWORDS.add(\"on\");\n\t\tKEYWORDS.add(\"where\");\n\t\tKEYWORDS.add(\"having\");\n\t\tKEYWORDS.add(\"group\");\n\t\tKEYWORDS.add(\"order\");\n\t\tKEYWORDS.add(\"by\");\n\t\tKEYWORDS.add(\"desc\");\n\t\tKEYWORDS.add(\"asc\");\n\t\tKEYWORDS.add(\"limit\");\n\t\tKEYWORDS.add(\"any\");\n\t\tKEYWORDS.add(\"some\");\n\t\tKEYWORDS.add(\"exists\");\n\t\tKEYWORDS.add(\"all\");\n\t\tKEYWORDS.add(\"union\");\n\t\tKEYWORDS.add(\"minus\");\n\t\tKEYWORDS.add(\"except\");\n\t\tKEYWORDS.add(\"intersect\");\n\t\tKEYWORDS.add(\"partition\");\n\n\t\tBEFORE_TABLE_KEYWORDS.add(\"from\");\n\t\tBEFORE_TABLE_KEYWORDS.add(\"join\");\n\n\t\tFUNCTION_KEYWORDS.add(\"as\");\n\t\tFUNCTION_KEYWORDS.add(\"leading\");\n\t\tFUNCTION_KEYWORDS.add(\"trailing\");\n\t\tFUNCTION_KEYWORDS.add(\"from\");\n\t\tFUNCTION_KEYWORDS.add(\"case\");\n\t\tFUNCTION_KEYWORDS.add(\"when\");\n\t\tFUNCTION_KEYWORDS.add(\"then\");\n\t\tFUNCTION_KEYWORDS.add(\"else\");\n\t\tFUNCTION_KEYWORDS.add(\"end\");\n\n\t\tLITERAL_PREFIXES.add(\"n\");\n\t\tLITERAL_PREFIXES.add(\"x\");\n\t\tLITERAL_PREFIXES.add(\"varbyte\");\n\t\tLITERAL_PREFIXES.add(\"bx\");\n\t\tLITERAL_PREFIXES.add(\"bytea\");\n\t\tLITERAL_PREFIXES.add(\"date\");\n\t\tLITERAL_PREFIXES.add(\"time\");\n\t\tLITERAL_PREFIXES.add(\"timestamp\");\n\t\tLITERAL_PREFIXES.add(\"zone\");\n\t}\n\n\tpublic static final String TEMPLATE = \"$PlaceHolder$\";\n\n\tprivate Template() {}\n\n\tpublic static String renderTransformerReadFragment(\n\t\t\tString fragment,\n\t\t\tString... columnNames) {\n\t\t// NOTE : would need access to SessionFactoryImplementor to make this configurable\n\t\tfor ( String columnName : columnNames ) {\n\t\t\tfragment = fragment.replace( columnName, TEMPLATE + '.' + columnName );\n\t\t}\n\t\treturn fragment;\n\t}\n\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn renderWhereStringTemplate( sqlWhereString, TEMPLATE, dialect, typeConfiguration, functionRegistry );\n\t}\n\n\t/**\n\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n\t * named parameters.\n\t *\n\t * @param sqlWhereString The string into which to interpolate the placeholder value\n\t * @param placeholder The value to be interpolated into the sqlWhereString\n\t * @param dialect The dialect to apply\n\t * @param functionRegistry The registry of all sql functions\n\t * @return The rendered sql fragment\n\t */\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\n\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n\t\t//\t\tidentifier references.\n\n\t\tfinal String symbols = PUNCTUATION + WHITESPACE + dialect.openQuote() + dialect.closeQuote();\n\t\tfinal StringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n\t\tfinal StringBuilder result = new StringBuilder();\n\n\t\tboolean quoted = false;\n\t\tboolean quotedIdentifier = false;\n\t\tboolean beforeTable = false;\n\t\tboolean inFromClause = false;\n\t\tboolean afterFromTable = false;\n\n\t\tboolean hasMore = tokens.hasMoreTokens();\n\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n\t\twhile ( hasMore ) {\n\t\t\tString token = nextToken;\n\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\tboolean isQuoteCharacter = false;\n\n\t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n\t\t\t\tquoted = !quoted;\n\t\t\t\tisQuoteCharacter = true;\n\t\t\t}\n\n\t\t\tif ( !quoted ) {\n\t\t\t\tfinal boolean isOpenQuote;\n\t\t\t\tif ( \"`\".equals(token) ) {\n\t\t\t\t\tisOpenQuote = !quotedIdentifier;\n\t\t\t\t\ttoken = lcToken = isOpenQuote\n\t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n\t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n\t\t\t\t\tquotedIdentifier = isOpenQuote;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( !quotedIdentifier && dialect.openQuote()==token.charAt(0) ) {\n\t\t\t\t\tisOpenQuote = true;\n\t\t\t\t\tquotedIdentifier = true;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( quotedIdentifier && dialect.closeQuote()==token.charAt(0) ) {\n\t\t\t\t\tquotedIdentifier = false;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\tif ( isOpenQuote ) {\n\t\t\t\t\tresult.append( placeholder ).append( '.' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinal boolean quotedOrWhitespace =\n\t\t\t\t\tquoted || quotedIdentifier || isQuoteCharacter\n\t\t\t\t\t\t\t|| token.isBlank();\n\t\t\tif ( quotedOrWhitespace ) {\n\t\t\t\tresult.append( token );\n\t\t\t}\n\t\t\telse if ( beforeTable ) {\n\t\t\t\tresult.append( token );\n\t\t\t\tbeforeTable = false;\n\t\t\t\tafterFromTable = true;\n\t\t\t}\n\t\t\telse if ( afterFromTable ) {\n\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n\t\t\t\t\tafterFromTable = false;\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isNamedParameter(token) ) {\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isExtractFunction( lcToken, nextToken ) ) {\n\t\t\t\t// Special processing for ANSI SQL EXTRACT function\n\t\t\t\thandleExtractFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\t\t\t}\n\t\t\telse if ( isTrimFunction( lcToken, nextToken ) ) {\n\t\t\t\t// Special processing for ANSI SQL TRIM function\n\t\t\t\thandleTrimFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\t\t\t}\n\t\t\telse if ( isIdentifier(token)\n\t\t\t\t\t&& !isFunctionOrKeyword( lcToken, nextToken, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t\t&& !isLiteral( lcToken, nextToken, sqlWhereString, symbols, tokens ) ) {\n\t\t\t\tresult.append(placeholder)\n\t\t\t\t\t\t.append('.')\n\t\t\t\t\t\t.append( dialect.quote(token) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t\tinFromClause = true;\n\t\t\t\t}\n\t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t}\n\t\t\t\tif ( isBoolean( token ) ) {\n\t\t\t\t\ttoken = dialect.toBooleanValueString( parseBoolean( token ) );\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\n\t\t\t//Yuck:\n\t\t\tif ( inFromClause\n\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n\t\t\t\tinFromClause = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result.toString();\n\t}\n\n\tprivate static boolean isTrimFunction(String lcToken, String nextToken) {\n\t\treturn \"trim\".equals(lcToken) && \"(\".equals(nextToken);\n\t}\n\n\tprivate static boolean isExtractFunction(String lcToken, String nextToken) {\n\t\treturn \"extract\".equals(lcToken) && \"(\".equals(nextToken);\n\t}\n\n\tprivate static boolean isLiteral(\n\t\t\tString lcToken, String next,\n\t\t\tString sqlWhereString, String symbols, StringTokenizer tokens) {\n\t\tif ( LITERAL_PREFIXES.contains( lcToken ) && next != null ) {\n\t\t\t// easy cases first\n\t\t\tif ( \"'\".equals(next) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if ( !next.isBlank() ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// we need to look ahead in the token stream\n\t\t\t\t// to find the first non-blank token\n\t\t\t\tfinal StringTokenizer lookahead =\n\t\t\t\t\t\tnew StringTokenizer( sqlWhereString, symbols, true );\n\t\t\t\twhile ( lookahead.countTokens() > tokens.countTokens()+1 ) {\n\t\t\t\t\tlookahead.nextToken();\n\t\t\t\t}\n\t\t\t\tif ( lookahead.hasMoreTokens() ) {\n\t\t\t\t\tString nextToken;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tnextToken = lookahead.nextToken().toLowerCase(Locale.ROOT);\n\t\t\t\t\t}\n\t\t\t\t\twhile ( nextToken.isBlank() && lookahead.hasMoreTokens() );\n\t\t\t\t\treturn \"'\".equals( nextToken )\n\t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"with\".equals( nextToken )\n\t\t\t\t\t\t|| lcToken.equals( \"timestamp\" ) && \"with\".equals( nextToken )\n\t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"zone\".equals( nextToken );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate static void handleTrimFunction(\n\t\t\tString placeholder, Dialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry,\n\t\t\tStringTokenizer tokens,\n\t\t\tStringBuilder result) {\n\t\tfinal List<String> operands = new ArrayList<>();\n\t\tfinal StringBuilder builder = new StringBuilder();\n\n\t\tboolean hasMoreOperands = true;\n\t\tString operandToken = tokens.nextToken();\n\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\tcase \"leading\":\n\t\t\tcase \"trailing\":\n\t\t\tcase \"both\":\n\t\t\t\toperands.add( operandToken );\n\t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tboolean quotedOperand = false;\n\t\tint parenthesis = 0;\n\t\twhile ( hasMoreOperands ) {\n\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n\t\t\tif ( isQuote ) {\n\t\t\t\tquotedOperand = !quotedOperand;\n\t\t\t\tif ( !quotedOperand ) {\n\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuilder.append( '\\'' );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( quotedOperand ) {\n\t\t\t\tbuilder.append( operandToken );\n\t\t\t}\n\t\t\telse if ( parenthesis != 0 ) {\n\t\t\t\tbuilder.append( operandToken );\n\t\t\t\tswitch ( operandToken ) {\n\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \")\":\n\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbuilder.append( operandToken );\n\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \")\":\n\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"from\":\n\t\t\t\t\t\tif ( !builder.isEmpty() ) {\n\t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\toperandToken = tokens.nextToken();\n\t\t\thasMoreOperands = tokens.hasMoreTokens()\n\t\t\t\t\t&& ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n\t\t}\n\t\tif ( !builder.isEmpty() ) {\n\t\t\toperands.add( builder.toString() );\n\t\t}\n\n\t\tfinal TrimOperands trimOperands = new TrimOperands( operands );\n\t\tresult.append( \"trim(\" );\n\t\tif ( trimOperands.trimSpec != null ) {\n\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n\t\t}\n\t\tif ( trimOperands.trimChar != null ) {\n\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n\t\t\t\tresult.append( trimOperands.trimChar );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult.append(\n\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t);\n\t\t\t}\n\t\t\tresult.append( ' ' );\n\t\t}\n\t\tif ( trimOperands.from != null ) {\n\t\t\tresult.append( trimOperands.from ).append( ' ' );\n\t\t}\n\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char is specified\n\t\t\tresult.append( \"from \" );\n\t\t}\n\n\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, typeConfiguration, functionRegistry ) )\n\t\t\t\t.append( ')' );\n\t}\n\n\tprivate static void handleExtractFunction(\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry,\n\t\t\tStringTokenizer tokens,\n\t\t\tStringBuilder result) {\n\t\tfinal String field = extractUntil( tokens, \"from\" );\n\t\tfinal String source = renderWhereStringTemplate(\n\t\t\t\textractUntil( tokens, \")\" ),\n\t\t\t\tplaceholder,\n\t\t\t\tdialect,\n\t\t\t\ttypeConfiguration,\n\t\t\t\tfunctionRegistry\n\t\t);\n\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n\t}\n\n\tpublic static List<String> collectColumnNames(\n\t\t\tString sql,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn collectColumnNames( renderWhereStringTemplate( sql, dialect, typeConfiguration, functionRegistry ) );\n\t}\n\n\tpublic static List<String> collectColumnNames(String template) {\n\t\tfinal List<String> names = new ArrayList<>();\n\t\tint begin = 0;\n\t\tint match;\n\t\twhile ( ( match = template.indexOf(TEMPLATE, begin) ) >= 0 ) {\n\t\t\tint start = match + TEMPLATE.length() + 1;\n\t\t\tfor ( int loc = start;; loc++ ) {\n\t\t\t\tif ( loc == template.length() - 1 ) {\n\t\t\t\t\tnames.add( template.substring( start ) );\n\t\t\t\t\tbegin = template.length();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar ch = template.charAt( loc );\n\t\t\t\t\tif ( PUNCTUATION.indexOf(ch) >= 0 || WHITESPACE.indexOf(ch) >= 0 ) {\n\t\t\t\t\t\tnames.add( template.substring( start, loc ) );\n\t\t\t\t\t\tbegin = loc;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn names;\n\t}\n\n//\t/**\n//\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n//\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n//\t * named parameters.\n//\t *\n//\t * @param sqlWhereString The string into which to interpolate the placeholder value\n//\t * @param placeholder The value to be interpolated into the sqlWhereString\n//\t * @param dialect The dialect to apply\n//\t * @param functionRegistry The registry of all sql functions\n//\t *\n//\t * @return The rendered sql fragment\n//\t */\n//\tpublic static String renderWhereStringTemplate(\n//\t\t\tString sqlWhereString,\n//\t\t\tString placeholder,\n//\t\t\tDialect dialect,\n//\t\t\tSQLFunctionRegistry functionRegistry) {\n//\n//\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n//\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n//\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n//\t\t//\t\tidentifier references.\n//\n//\t\tfinal String dialectOpenQuote = Character.toString( dialect.openQuote() );\n//\t\tfinal String dialectCloseQuote = Character.toString( dialect.closeQuote() );\n//\n//\t\tString symbols = new StringBuilder()\n//\t\t\t\t.append( \"=><!+-*/()',|&`\" )\n//\t\t\t\t.append( StringHelper.WHITESPACE )\n//\t\t\t\t.append( dialect.openQuote() )\n//\t\t\t\t.append( dialect.closeQuote() )\n//\t\t\t\t.toString();\n//\t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n//\t\tProcessingState state = new ProcessingState();\n//\n//\t\tStringBuilder quotedBuffer = new StringBuilder();\n//\t\tStringBuilder result = new StringBuilder();\n//\n//\t\tboolean hasMore = tokens.hasMoreTokens();\n//\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n//\t\twhile ( hasMore ) {\n//\t\t\tString token = nextToken;\n//\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n//\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t// First, determine quoting which might be based on either:\n//\t\t\t// \t\t1) back-tick\n//\t\t\t// \t\t2) single quote (ANSI SQL standard)\n//\t\t\t// \t\t3) or dialect defined quote character(s)\n//\t\t\tQuotingCharacterDisposition quotingCharacterDisposition = QuotingCharacterDisposition.NONE;\n//\t\t\tif ( \"`\".equals( token ) ) {\n//\t\t\t\tstate.quoted = !state.quoted;\n//\t\t\t\tquotingCharacterDisposition = state.quoted\n//\t\t\t\t\t\t? QuotingCharacterDisposition.OPEN\n//\t\t\t\t\t\t: QuotingCharacterDisposition.CLOSE;\n//\t\t\t\t// replace token with the appropriate dialect quoting char\n//\t\t\t\ttoken = lcToken = ( quotingCharacterDisposition == QuotingCharacterDisposition.OPEN )\n//\t\t\t\t\t\t? dialectOpenQuote\n//\t\t\t\t\t\t: dialectCloseQuote;\n//\t\t\t}\n//\t\t\telse if ( \"'\".equals( token ) ) {\n//\t\t\t\tstate.quoted = !state.quoted;\n//\t\t\t\tquotingCharacterDisposition = state.quoted\n//\t\t\t\t\t\t? QuotingCharacterDisposition.OPEN\n//\t\t\t\t\t\t: QuotingCharacterDisposition.CLOSE;\n//\t\t\t}\n//\t\t\telse if ( !state.quoted && dialectOpenQuote.equals( token ) ) {\n//\t\t\t\tstate.quoted = true;\n//\t\t\t\tquotingCharacterDisposition = QuotingCharacterDisposition.OPEN;\n//\t\t\t}\n//\t\t\telse if ( state.quoted && dialectCloseQuote.equals( token ) ) {\n//\t\t\t\tstate.quoted = false;\n//\t\t\t\tquotingCharacterDisposition = QuotingCharacterDisposition.CLOSE;\n//\t\t\t}\n//\n//\t\t\tif ( state.quoted ) {\n//\t\t\t\tquotedBuffer.append( token );\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// if we were previously processing quoted state and just encountered the close quote, then handle that\n//\t\t\t// quoted text\n//\t\t\tif ( quotingCharacterDisposition == QuotingCharacterDisposition.CLOSE ) {\n//\t\t\t\ttoken = quotedBuffer.toString();\n//\t\t\t\tquotedBuffer.setLength( 0 );\n//\t\t\t\tresult.append( placeholder ).append( '.' )\n//\t\t\t\t\t\t.append( dialectOpenQuote ).append( token ).append( dialectCloseQuote );\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// Special processing for ANSI SQL EXTRACT function\n//\t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n//\t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n//\t\t\t\tfinal String source = renderWhereStringTemplate(\n//\t\t\t\t\t\textractUntil( tokens, \")\" ),\n//\t\t\t\t\t\tplaceholder,\n//\t\t\t\t\t\tdialect,\n//\t\t\t\t\t\tfunctionRegistry\n//\t\t\t\t);\n//\t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n//\n//\t\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// Special processing for ANSI SQL TRIM function\n//\t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n//\t\t\t\tList<String> operands = new ArrayList<String>();\n//\t\t\t\tStringBuilder builder = new StringBuilder();\n//\n//\t\t\t\tboolean hasMoreOperands = true;\n//\t\t\t\tString operandToken = tokens.nextToken();\n//\t\t\t\tboolean quoted = false;\n//\t\t\t\twhile ( hasMoreOperands ) {\n//\t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n//\t\t\t\t\tif ( isQuote ) {\n//\t\t\t\t\t\tquoted = !quoted;\n//\t\t\t\t\t\tif ( !quoted ) {\n//\t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n//\t\t\t\t\t\t\tbuilder.setLength( 0 );\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse {\n//\t\t\t\t\t\t\tbuilder.append( '\\'' );\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t\telse if ( quoted ) {\n//\t\t\t\t\t\tbuilder.append( operandToken );\n//\t\t\t\t\t}\n//\t\t\t\t\telse if ( operandToken.length() == 1 && Character.isWhitespace( operandToken.charAt( 0 ) ) ) {\n//\t\t\t\t\t\t// do nothing\n//\t\t\t\t\t}\n//\t\t\t\t\telse {\n//\t\t\t\t\t\toperands.add( operandToken );\n//\t\t\t\t\t}\n//\t\t\t\t\toperandToken = tokens.nextToken();\n//\t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ! \")\".equals( operandToken );\n//\t\t\t\t}\n//\n//\t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n//\t\t\t\tresult.append( \"trim(\" );\n//\t\t\t\tif ( trimOperands.trimSpec != null ) {\n//\t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n//\t\t\t\t}\n//\t\t\t\tif ( trimOperands.trimChar != null ) {\n//\t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n//\t\t\t\t\t\tresult.append( trimOperands.trimChar );\n//\t\t\t\t\t}\n//\t\t\t\t\telse {\n//\t\t\t\t\t\tresult.append(\n//\t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, functionRegistry )\n//\t\t\t\t\t\t);\n//\t\t\t\t\t}\n//\t\t\t\t\tresult.append( ' ' );\n//\t\t\t\t}\n//\t\t\t\tif ( trimOperands.from != null ) {\n//\t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n//\t\t\t\t}\n//\t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n//\t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char are specified\n//\t\t\t\t\tresult.append( \"from \" );\n//\t\t\t\t}\n//\n//\t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, functionRegistry ) )\n//\t\t\t\t\t\t.append( ')' );\n//\n//\t\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\n//\t\t\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\n//\t\t\tif ( Character.isWhitespace( token.charAt( 0 ) ) ) {\n//\t\t\t\tresult.append( token );\n//\t\t\t}\n//\t\t\telse if ( state.beforeTable ) {\n//\t\t\t\tresult.append( token );\n//\t\t\t\tstate.beforeTable = false;\n//\t\t\t\tstate.afterFromTable = true;\n//\t\t\t}\n//\t\t\telse if ( state.afterFromTable ) {\n//\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n//\t\t\t\t\tstate.afterFromTable = false;\n//\t\t\t\t}\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\t\t\telse if ( isNamedParameter(token) ) {\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\t\t\telse if ( isIdentifier(token, dialect)\n//\t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect , functionRegistry) ) {\n//\t\t\t\tresult.append(placeholder)\n//\t\t\t\t\t\t.append('.')\n//\t\t\t\t\t\t.append( dialect.quote(token) );\n//\t\t\t}\n//\t\t\telse {\n//\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n//\t\t\t\t\tstate.beforeTable = true;\n//\t\t\t\t\tstate.inFromClause = true;\n//\t\t\t\t}\n//\t\t\t\telse if ( state.inFromClause && \",\".equals(lcToken) ) {\n//\t\t\t\t\tstate.beforeTable = true;\n//\t\t\t\t}\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\n//\t\t\t//Yuck:\n//\t\t\tif ( state.inFromClause\n//\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n//\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n//\t\t\t\tstate.inFromClause = false;\n//\t\t\t}\n//\t\t}\n//\n//\t\treturn result.toString();\n//\t}\n//\n//\tprivate static class ProcessingState {\n//\t\tboolean quoted = false;\n//\t\tboolean quotedIdentifier = false;\n//\t\tboolean beforeTable = false;\n//\t\tboolean inFromClause = false;\n//\t\tboolean afterFromTable = false;\n//\t}\n//\n//\tprivate static enum QuotingCharacterDisposition { NONE, OPEN, CLOSE }\n\n\tprivate static class TrimOperands {\n\t\tprivate final String trimSpec;\n\t\tprivate final String trimChar;\n\t\tprivate final String from;\n\t\tprivate final String trimSource;\n\n\t\tprivate TrimOperands(List<String> operands) {\n\t\t\tfinal int size = operands.size();\n\t\t\tif ( size == 1 ) {\n\t\t\t\ttrimSpec = null;\n\t\t\t\ttrimChar = null;\n\t\t\t\tfrom = null;\n\t\t\t\ttrimSource = operands.get(0);\n\t\t\t}\n\t\t\telse if ( size == 4 ) {\n\t\t\t\ttrimSpec = operands.get(0);\n\t\t\t\ttrimChar = operands.get(1);\n\t\t\t\tfrom = operands.get(2);\n\t\t\t\ttrimSource = operands.get(3);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( size < 1 || size > 4 ) {\n\t\t\t\t\tthrow new HibernateException( \"Unexpected number of trim function operands : \" + size );\n\t\t\t\t}\n\n\t\t\t\t// trim-source will always be the last operand\n\t\t\t\ttrimSource = operands.get( size - 1 );\n\n\t\t\t\t// ANSI SQL says that more than one operand means that the FROM is required\n\t\t\t\tif ( ! \"from\".equals( operands.get( size - 2 ) ) ) {\n\t\t\t\t\tthrow new HibernateException( \"Expecting FROM, found : \" + operands.get( size - 2 ) );\n\t\t\t\t}\n\t\t\t\tfrom = operands.get( size - 2 );\n\n\t\t\t\t// trim-spec, if there is one will always be the first operand\n\t\t\t\tif ( \"leading\".equalsIgnoreCase( operands.get(0) )\n\t\t\t\t\t\t|| \"trailing\".equalsIgnoreCase( operands.get(0) )\n\t\t\t\t\t\t|| \"both\".equalsIgnoreCase( operands.get(0) ) ) {\n\t\t\t\t\ttrimSpec = operands.get(0);\n\t\t\t\t\ttrimChar = null;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttrimSpec = null;\n\t\t\t\t\tif ( size - 2 == 0 ) {\n\t\t\t\t\t\ttrimChar = null;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttrimChar = operands.get( 0 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static String extractUntil(StringTokenizer tokens, String delimiter) {\n\t\tfinal StringBuilder valueBuilder = new StringBuilder();\n\t\tString token = tokens.nextToken();\n\t\twhile ( ! delimiter.equalsIgnoreCase( token ) ) {\n\t\t\tvalueBuilder.append( token );\n\t\t\ttoken = tokens.nextToken();\n\t\t}\n\t\treturn valueBuilder.toString().trim();\n\t}\n\n\tprivate static boolean isNamedParameter(String token) {\n\t\treturn token.startsWith( \":\" );\n\t}\n\n\tprivate static boolean isFunctionOrKeyword(\n\t\t\tString lcToken,\n\t\t\tString nextToken,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\tif ( \"(\".equals( nextToken ) ) {\n\t\t\treturn true;\n\t\t}\n\t\telse if ( \"date\".equals( lcToken ) || \"time\".equals( lcToken ) ) {\n\t\t\t// these can be column names on some databases\n\t\t\t// TODO: treat 'current date' as a function\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\treturn KEYWORDS.contains( lcToken )\n\t\t\t\t|| isType( lcToken, typeConfiguration )\n\t\t\t\t|| isFunction( lcToken, nextToken, functionRegistry )\n\t\t\t\t|| dialect.getKeywords().contains( lcToken )\n\t\t\t\t|| FUNCTION_KEYWORDS.contains( lcToken );\n\t\t}\n\t}\n\n\tprivate static boolean isType(String lcToken, TypeConfiguration typeConfiguration) {\n\t\treturn typeConfiguration.getDdlTypeRegistry().isTypeNameRegistered( lcToken );\n\t}\n\n\tprivate static boolean isFunction(String lcToken, String nextToken, SqmFunctionRegistry functionRegistry) {\n\t\t// checking for \"(\" is currently redundant because it is checked before getting here;\n\t\t// doing the check anyhow, in case that earlier check goes away;\n\t\tif ( \"(\".equals( nextToken ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tfinal SqmFunctionDescriptor function = functionRegistry.findFunctionDescriptor( lcToken );\n\t\treturn function != null;\n\t}\n\n\tprivate static boolean isIdentifier(String token) {\n\t\tif ( isBoolean( token ) ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn token.charAt( 0 ) == '`'\n\t\t\t|| ( //allow any identifier quoted with backtick\n\t\t\t\tisLetter( token.charAt( 0 ) ) && //only recognizes identifiers beginning with a letter\n\t\t\t\t\t\ttoken.indexOf( '.' ) < 0\n\t\t\t);\n\t}\n\n\tprivate static boolean isBoolean(String token) {\n\t\treturn \"true\".equals( token ) || \"false\".equals( token );\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private static boolean isTrimFunction(String lcToken, String nextToken) {\n\t\treturn \"trim\".equals(lcToken) && \"(\".equals(nextToken);\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.sql.Template#extractUntil\n methodBody: private static String extractUntil(StringTokenizer tokens, String delimiter) {\nStringBuilder valueBuilder=new StringBuilder();\nString token=tokens.nextToken();\nwhile(!delimiter.equalsIgnoreCase(token)){valueBuilder.append(token);\ntoken=tokens.nextToken();\n}return valueBuilder.toString().trim();\n}",
            "methodSignature: org.hibernate.sql.Template#renderWhereStringTemplate\n methodBody: public static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\nString symbols=PUNCTUATION + WHITESPACE + dialect.openQuote() + dialect.closeQuote();\nStringTokenizer tokens=new StringTokenizer(sqlWhereString,symbols,true);\nStringBuilder result=new StringBuilder();\nboolean quoted=false;\nboolean quotedIdentifier=false;\nboolean beforeTable=false;\nboolean inFromClause=false;\nboolean afterFromTable=false;\nboolean hasMore=tokens.hasMoreTokens();\nString nextToken=hasMore ? tokens.nextToken() : null;\nwhile(hasMore){String token=nextToken;\nString lcToken=token.toLowerCase(Locale.ROOT);\nhasMore=tokens.hasMoreTokens();\nnextToken=hasMore ? tokens.nextToken() : null;\nboolean isQuoteCharacter=false;\nif(!quotedIdentifier && \"'\".equals(token)){quoted=!quoted;\nisQuoteCharacter=true;\n}if(!quoted){boolean isOpenQuote;\nif(\"`\".equals(token)){isOpenQuote=!quotedIdentifier;\ntoken=lcToken=isOpenQuote ? Character.toString(dialect.openQuote()) : Character.toString(dialect.closeQuote());\nquotedIdentifier=isOpenQuote;\nisQuoteCharacter=true;\n}if(!quotedIdentifier && (dialect.openQuote() == token.charAt(0))){isOpenQuote=true;\nquotedIdentifier=true;\nisQuoteCharacter=true;\n}if(quotedIdentifier && (dialect.closeQuote() == token.charAt(0))){quotedIdentifier=false;\nisQuoteCharacter=true;\nisOpenQuote=false;\n}if(LITERAL_PREFIXES.contains(lcToken)){if(\"'\".equals(nextToken)){result.append(token);\ncontinue;\n}if(nextToken != null && Character.isWhitespace(nextToken.charAt(0))){final StringBuilder additionalTokens=new StringBuilder();\nTimeZoneTokens possibleNextToken=null;\ndo(nextToken != null && possibleNextToken.isToken(nextToken)){possibleNextToken=possibleNextToken == null ? TimeZoneTokens.getPossibleNextTokens(lcToken) : possibleNextToken.nextToken();\ndo(nextToken != null && Character.isWhitespace(nextToken.charAt(0))){additionalTokens.append(nextToken);\nhasMore=tokens.hasMoreTokens();\nnextToken=tokens.nextToken();\n}}if(\"'\".equals(nextToken)){result.append(token);\nresult.append(additionalTokens);\ncontinue;\n}{isOpenQuote=false;\n}}{isOpenQuote=false;\n}}{isOpenQuote=false;\n}if(isOpenQuote){result.append(placeholder).append('.');\n}}if(\"extract\".equals(lcToken) && \"(\".equals(nextToken)){final String field=extractUntil(tokens,\"from\");\nfinal String source=renderWhereStringTemplate(extractUntil(tokens,\")\"),placeholder,dialect,typeConfiguration,functionRegistry);\nresult.append(\"extract(\").append(field).append(\" from \").append(source).append(')');\nhasMore=tokens.hasMoreTokens();\nnextToken=hasMore ? tokens.nextToken() : null;\ncontinue;\n}if(\"trim\".equals(lcToken) && \"(\".equals(nextToken)){List<String> operands=new ArrayList<>();\nStringBuilder builder=new StringBuilder();\nboolean hasMoreOperands=true;\nString operandToken=tokens.nextToken();\nswitch(operandToken.toLowerCase(Locale.ROOT))case \"leading\":case \"trailing\":case \"both\":operands.add(operandToken);\nif(hasMoreOperands=tokens.hasMoreTokens()){operandToken=tokens.nextToken();\n}break;\nboolean quotedOperand=false;\nint parenthesis=0;\nwhile(hasMoreOperands){final boolean isQuote=\"'\".equals(operandToken);\nif(isQuote){quotedOperand=!quotedOperand;\nif(!quotedOperand){operands.add(builder.append('\\'').toString());\nbuilder.setLength(0);\n}{builder.append('\\'');\n}}if(quotedOperand){builder.append(operandToken);\n}if(parenthesis != 0){builder.append(operandToken);\nswitch(operandToken)case \"(\":parenthesis++;\nbreak;\ncase \")\":parenthesis--;\nbreak;\n}{builder.append(operandToken);\nswitch(operandToken.toLowerCase(Locale.ROOT))case \"(\":parenthesis++;\nbreak;\ncase \")\":parenthesis--;\nbreak;\ncase \"from\":if(builder.length() != 0){operands.add(builder.substring(0,builder.length() - 4));\nbuilder.setLength(0);\noperands.add(operandToken);\n}break;\n}operandToken=tokens.nextToken();\nhasMoreOperands=tokens.hasMoreTokens() && (parenthesis != 0 || !\")\".equals(operandToken));\n}if(builder.length() != 0){operands.add(builder.toString());\n}TrimOperands trimOperands=new TrimOperands(operands);\nresult.append(\"trim(\");\nif(trimOperands.trimSpec != null){result.append(trimOperands.trimSpec).append(' ');\n}if(trimOperands.trimChar != null){if(trimOperands.trimChar.startsWith(\"'\") && trimOperands.trimChar.endsWith(\"'\")){result.append(trimOperands.trimChar);\n}{result.append(renderWhereStringTemplate(trimOperands.trimSpec,placeholder,dialect,typeConfiguration,functionRegistry));\n}result.append(' ');\n}if(trimOperands.from != null){result.append(trimOperands.from).append(' ');\n}if(trimOperands.trimSpec != null || trimOperands.trimChar != null){result.append(\"from \");\n}result.append(renderWhereStringTemplate(trimOperands.trimSource,placeholder,dialect,typeConfiguration,functionRegistry)).append(')');\nhasMore=tokens.hasMoreTokens();\nnextToken=hasMore ? tokens.nextToken() : null;\ncontinue;\n}boolean quotedOrWhitespace=quoted || quotedIdentifier || isQuoteCharacter || Character.isWhitespace(token.charAt(0));\nif(quotedOrWhitespace){result.append(token);\n}if(beforeTable){result.append(token);\nbeforeTable=false;\nafterFromTable=true;\n}if(afterFromTable){if(!\"as\".equals(lcToken)){afterFromTable=false;\n}result.append(token);\n}if(isNamedParameter(token)){result.append(token);\n}if(isIdentifier(token) && !isFunctionOrKeyword(lcToken,nextToken,dialect,typeConfiguration,functionRegistry)){result.append(placeholder).append('.').append(dialect.quote(token));\n}{if(BEFORE_TABLE_KEYWORDS.contains(lcToken)){beforeTable=true;\ninFromClause=true;\n}if(inFromClause && \",\".equals(lcToken)){beforeTable=true;\n}if(isBoolean(token)){token=dialect.toBooleanValueString(Boolean.parseBoolean(token));\n}result.append(token);\n}if(inFromClause && KEYWORDS.contains(lcToken) && !BEFORE_TABLE_KEYWORDS.contains(lcToken)){inFromClause=false;\n}}return result.toString();\n}",
            "methodSignature: org.hibernate.sql.Template.TimeZoneTokens#isToken\n methodBody: public boolean isToken(String token) {\nreturn this != NONE && name().equalsIgnoreCase(token);\n}",
            "methodSignature: org.hibernate.sql.Template#isBoolean\n methodBody: private static boolean isBoolean(String token) {\nreturn \"true\".equals(token) || \"false\".equals(token);\n}",
            "methodSignature: org.hibernate.sql.Template.TimeZoneTokens#nextToken\n methodBody: public TimeZoneTokens nextToken() {\nif(this == WITH){return TIME;\n}if(this == TIME){return ZONE;\n}{return NONE;\n}}",
            "methodSignature: org.hibernate.sql.Template.TimeZoneTokens#getPossibleNextTokens\n methodBody: static TimeZoneTokens getPossibleNextTokens(String lctoken) {\nswitch(lctoken)case \"time\":case \"timestamp\":return WITH;\ndefault:return NONE;\n}",
            "methodSignature: org.hibernate.sql.Template#isIdentifier\n methodBody: private static boolean isIdentifier(String token) {\nif(isBoolean(token)){return false;\n}return token.charAt(0) == '`' || (Character.isLetter(token.charAt(0)) && token.indexOf('.') < 0);\n}",
            "methodSignature: org.hibernate.sql.Template#isNamedParameter\n methodBody: private static boolean isNamedParameter(String token) {\nreturn token.startsWith(\":\");\n}",
            "methodSignature: org.hibernate.sql.Template#isFunctionOrKeyword\n methodBody: private static boolean isFunctionOrKeyword(\n\t\t\tString lcToken,\n\t\t\tString nextToken,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\nreturn \"(\".equals(nextToken) || KEYWORDS.contains(lcToken) || isType(lcToken,typeConfiguration) || isFunction(lcToken,nextToken,functionRegistry) || dialect.getKeywords().contains(lcToken) || FUNCTION_KEYWORDS.contains(lcToken);\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n\t * named parameters.\n\t *\n\t * @param sqlWhereString The string into which to interpolate the placeholder value\n\t * @param placeholder The value to be interpolated into the sqlWhereString\n\t * @param dialect The dialect to apply\n\t * @param functionRegistry The registry of all sql functions\n\t * @return The rendered sql fragment\n\t */\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\n\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n\t\t//\t\tidentifier references.\n\n\t\tfinal String symbols = PUNCTUATION + WHITESPACE + dialect.openQuote() + dialect.closeQuote();\n\t\tfinal StringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n\t\tfinal StringBuilder result = new StringBuilder();\n\n\t\tboolean quoted = false;\n\t\tboolean quotedIdentifier = false;\n\t\tboolean beforeTable = false;\n\t\tboolean inFromClause = false;\n\t\tboolean afterFromTable = false;\n\n\t\tboolean hasMore = tokens.hasMoreTokens();\n\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n\t\twhile ( hasMore ) {\n\t\t\tString token = nextToken;\n\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\tboolean isQuoteCharacter = false;\n\n\t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n\t\t\t\tquoted = !quoted;\n\t\t\t\tisQuoteCharacter = true;\n\t\t\t}\n\n\t\t\tif ( !quoted ) {\n\t\t\t\tfinal boolean isOpenQuote;\n\t\t\t\tif ( \"`\".equals(token) ) {\n\t\t\t\t\tisOpenQuote = !quotedIdentifier;\n\t\t\t\t\ttoken = lcToken = isOpenQuote\n\t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n\t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n\t\t\t\t\tquotedIdentifier = isOpenQuote;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( !quotedIdentifier && dialect.openQuote()==token.charAt(0) ) {\n\t\t\t\t\tisOpenQuote = true;\n\t\t\t\t\tquotedIdentifier = true;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( quotedIdentifier && dialect.closeQuote()==token.charAt(0) ) {\n\t\t\t\t\tquotedIdentifier = false;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\tif ( isOpenQuote ) {\n\t\t\t\t\tresult.append( placeholder ).append( '.' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinal boolean quotedOrWhitespace =\n\t\t\t\t\tquoted || quotedIdentifier || isQuoteCharacter\n\t\t\t\t\t\t\t|| token.isBlank();\n\t\t\tif ( quotedOrWhitespace ) {\n\t\t\t\tresult.append( token );\n\t\t\t}\n\t\t\telse if ( beforeTable ) {\n\t\t\t\tresult.append( token );\n\t\t\t\tbeforeTable = false;\n\t\t\t\tafterFromTable = true;\n\t\t\t}\n\t\t\telse if ( afterFromTable ) {\n\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n\t\t\t\t\tafterFromTable = false;\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isNamedParameter(token) ) {\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isExtractFunction( lcToken, nextToken ) ) {\n\t\t\t\t// Special processing for ANSI SQL EXTRACT function\n\t\t\t\thandleExtractFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\t\t\t}\n\t\t\telse if ( isTrimFunction( lcToken, nextToken ) ) {\n\t\t\t\t// Special processing for ANSI SQL TRIM function\n\t\t\t\thandleTrimFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\t\t\t}\n\t\t\telse if ( isIdentifier(token)\n\t\t\t\t\t&& !isFunctionOrKeyword( lcToken, nextToken, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t\t&& !isLiteral( lcToken, nextToken, sqlWhereString, symbols, tokens ) ) {\n\t\t\t\tresult.append(placeholder)\n\t\t\t\t\t\t.append('.')\n\t\t\t\t\t\t.append( dialect.quote(token) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t\tinFromClause = true;\n\t\t\t\t}\n\t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t}\n\t\t\t\tif ( isBoolean( token ) ) {\n\t\t\t\t\ttoken = dialect.toBooleanValueString( parseBoolean( token ) );\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\n\t\t\t//Yuck:\n\t\t\tif ( inFromClause\n\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n\t\t\t\tinFromClause = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result.toString();\n\t}\nprivate static boolean isTrimFunction(String lcToken, String nextToken) {\n\t\treturn \"trim\".equals(lcToken) && \"(\".equals(nextToken);\n\t}",
        "diffSourceCode": "-  119: \t/**\n-  120: \t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n-  121: \t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n-  122: \t * named parameters.\n-  123: \t *\n-  124: \t * @param sqlWhereString The string into which to interpolate the placeholder value\n-  125: \t * @param placeholder The value to be interpolated into the sqlWhereString\n-  126: \t * @param dialect The dialect to apply\n-  127: \t * @param functionRegistry The registry of all sql functions\n-  128: \t * @return The rendered sql fragment\n-  129: \t */\n-  130: \tpublic static String renderWhereStringTemplate(\n-  131: \t\t\tString sqlWhereString,\n-  132: \t\t\tString placeholder,\n-  133: \t\t\tDialect dialect,\n-  134: \t\t\tTypeConfiguration typeConfiguration,\n-  135: \t\t\tSqmFunctionRegistry functionRegistry) {\n-  136: \n-  137: \t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n-  138: \t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n-  139: \t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n-  140: \t\t//\t\tidentifier references.\n-  141: \n-  142: \t\tString symbols = PUNCTUATION +\n-  143: \t\t\t\tWHITESPACE +\n-  144: \t\t\t\tdialect.openQuote() +\n-  145: \t\t\t\tdialect.closeQuote();\n-  146: \t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n-  147: \t\tStringBuilder result = new StringBuilder();\n+  119: \t\treturn renderWhereStringTemplate( sqlWhereString, TEMPLATE, dialect, typeConfiguration, functionRegistry );\n+  120: \t}\n+  121: \n+  122: \t/**\n+  123: \t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n+  124: \t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n+  125: \t * named parameters.\n+  126: \t *\n+  127: \t * @param sqlWhereString The string into which to interpolate the placeholder value\n+  128: \t * @param placeholder The value to be interpolated into the sqlWhereString\n+  129: \t * @param dialect The dialect to apply\n+  130: \t * @param functionRegistry The registry of all sql functions\n+  131: \t * @return The rendered sql fragment\n+  132: \t */\n+  133: \tpublic static String renderWhereStringTemplate(\n+  134: \t\t\tString sqlWhereString,\n+  135: \t\t\tString placeholder,\n+  136: \t\t\tDialect dialect,\n+  137: \t\t\tTypeConfiguration typeConfiguration,\n+  138: \t\t\tSqmFunctionRegistry functionRegistry) {\n+  139: \n+  140: \t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n+  141: \t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n+  142: \t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n+  143: \t\t//\t\tidentifier references.\n+  144: \n+  145: \t\tfinal String symbols = PUNCTUATION + WHITESPACE + dialect.openQuote() + dialect.closeQuote();\n+  146: \t\tfinal StringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n+  147: \t\tfinal StringBuilder result = new StringBuilder();\n   148: \n   149: \t\tboolean quoted = false;\n   150: \t\tboolean quotedIdentifier = false;\n   151: \t\tboolean beforeTable = false;\n   152: \t\tboolean inFromClause = false;\n   153: \t\tboolean afterFromTable = false;\n   154: \n   155: \t\tboolean hasMore = tokens.hasMoreTokens();\n   156: \t\tString nextToken = hasMore ? tokens.nextToken() : null;\n   157: \t\twhile ( hasMore ) {\n   158: \t\t\tString token = nextToken;\n   159: \t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n   160: \t\t\thasMore = tokens.hasMoreTokens();\n   161: \t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n   162: \n   163: \t\t\tboolean isQuoteCharacter = false;\n   164: \n   165: \t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n   166: \t\t\t\tquoted = !quoted;\n   167: \t\t\t\tisQuoteCharacter = true;\n   168: \t\t\t}\n   169: \n   170: \t\t\tif ( !quoted ) {\n-  171: \t\t\t\tboolean isOpenQuote;\n+  171: \t\t\t\tfinal boolean isOpenQuote;\n   172: \t\t\t\tif ( \"`\".equals(token) ) {\n   173: \t\t\t\t\tisOpenQuote = !quotedIdentifier;\n   174: \t\t\t\t\ttoken = lcToken = isOpenQuote\n   175: \t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n   176: \t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n   177: \t\t\t\t\tquotedIdentifier = isOpenQuote;\n   178: \t\t\t\t\tisQuoteCharacter = true;\n   179: \t\t\t\t}\n-  180: \t\t\t\telse if ( !quotedIdentifier && ( dialect.openQuote()==token.charAt(0) ) ) {\n+  180: \t\t\t\telse if ( !quotedIdentifier && dialect.openQuote()==token.charAt(0) ) {\n   181: \t\t\t\t\tisOpenQuote = true;\n   182: \t\t\t\t\tquotedIdentifier = true;\n   183: \t\t\t\t\tisQuoteCharacter = true;\n   184: \t\t\t\t}\n-  185: \t\t\t\telse if ( quotedIdentifier && ( dialect.closeQuote()==token.charAt(0) ) ) {\n+  185: \t\t\t\telse if ( quotedIdentifier && dialect.closeQuote()==token.charAt(0) ) {\n   186: \t\t\t\t\tquotedIdentifier = false;\n   187: \t\t\t\t\tisQuoteCharacter = true;\n   188: \t\t\t\t\tisOpenQuote = false;\n   189: \t\t\t\t}\n-  190: \t\t\t\telse if ( LITERAL_PREFIXES.contains( lcToken ) ) {\n-  191: \t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n-  192: \t\t\t\t\t\t// Don't prefix a literal\n-  193: \t\t\t\t\t\tresult.append( token );\n-  194: \t\t\t\t\t\tcontinue;\n-  195: \t\t\t\t\t}\n-  196: \t\t\t\t\telse if ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) ) {\n-  197: \t\t\t\t\t\tfinal StringBuilder additionalTokens = new StringBuilder();\n-  198: \t\t\t\t\t\tTimeZoneTokens possibleNextToken = null;\n-  199: \t\t\t\t\t\tdo {\n-  200: \t\t\t\t\t\t\tpossibleNextToken = possibleNextToken == null\n-  201: \t\t\t\t\t\t\t\t\t? TimeZoneTokens.getPossibleNextTokens( lcToken )\n-  202: \t\t\t\t\t\t\t\t\t: possibleNextToken.nextToken();\n-  203: \t\t\t\t\t\t\tdo {\n-  204: \t\t\t\t\t\t\t\tadditionalTokens.append( nextToken );\n-  205: \t\t\t\t\t\t\t\thasMore = tokens.hasMoreTokens();\n-  206: \t\t\t\t\t\t\t\tnextToken = tokens.nextToken();\n-  207: \t\t\t\t\t\t\t} while ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) );\n-  208: \t\t\t\t\t\t} while ( nextToken != null && possibleNextToken.isToken( nextToken ) );\n-  209: \t\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n-  210: \t\t\t\t\t\t\t// Don't prefix a literal\n-  211: \t\t\t\t\t\t\tresult.append( token );\n-  212: \t\t\t\t\t\t\tresult.append( additionalTokens );\n-  213: \t\t\t\t\t\t\tcontinue;\n-  214: \t\t\t\t\t\t}\n-  215: \t\t\t\t\t\telse {\n-  216: \t\t\t\t\t\t\tisOpenQuote = false;\n-  217: \t\t\t\t\t\t}\n-  218: \t\t\t\t\t}\n-  219: \t\t\t\t\telse {\n-  220: \t\t\t\t\t\tisOpenQuote = false;\n-  221: \t\t\t\t\t}\n-  222: \t\t\t\t}\n-  223: \t\t\t\telse {\n-  224: \t\t\t\t\tisOpenQuote = false;\n-  225: \t\t\t\t}\n-  226: \n-  227: \t\t\t\tif ( isOpenQuote ) {\n-  228: \t\t\t\t\tresult.append( placeholder ).append( '.' );\n-  229: \t\t\t\t}\n-  230: \t\t\t}\n-  231: \n-  232: \t\t\t// Special processing for ANSI SQL EXTRACT function\n-  233: \t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n-  234: \t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n-  235: \t\t\t\tfinal String source = renderWhereStringTemplate(\n-  236: \t\t\t\t\t\textractUntil( tokens, \")\" ),\n-  237: \t\t\t\t\t\tplaceholder,\n-  238: \t\t\t\t\t\tdialect,\n-  239: \t\t\t\t\t\ttypeConfiguration,\n-  240: \t\t\t\t\t\tfunctionRegistry\n-  241: \t\t\t\t);\n-  242: \t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n-  243: \n-  244: \t\t\t\thasMore = tokens.hasMoreTokens();\n-  245: \t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n-  246: \n-  247: \t\t\t\tcontinue;\n-  248: \t\t\t}\n-  249: \n-  250: \t\t\t// Special processing for ANSI SQL TRIM function\n-  251: \t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n-  252: \t\t\t\tList<String> operands = new ArrayList<>();\n-  253: \t\t\t\tStringBuilder builder = new StringBuilder();\n-  254: \n-  255: \t\t\t\tboolean hasMoreOperands = true;\n-  256: \t\t\t\tString operandToken = tokens.nextToken();\n-  257: \t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n-  258: \t\t\t\t\tcase \"leading\":\n-  259: \t\t\t\t\tcase \"trailing\":\n-  260: \t\t\t\t\tcase \"both\":\n-  261: \t\t\t\t\t\toperands.add( operandToken );\n-  262: \t\t\t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n-  263: \t\t\t\t\t\t\toperandToken = tokens.nextToken();\n-  264: \t\t\t\t\t\t}\n-  265: \t\t\t\t\t\tbreak;\n-  266: \t\t\t\t}\n-  267: \t\t\t\tboolean quotedOperand = false;\n-  268: \t\t\t\tint parenthesis = 0;\n-  269: \t\t\t\twhile ( hasMoreOperands ) {\n-  270: \t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n-  271: \t\t\t\t\tif ( isQuote ) {\n-  272: \t\t\t\t\t\tquotedOperand = !quotedOperand;\n-  273: \t\t\t\t\t\tif ( !quotedOperand ) {\n-  274: \t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n-  275: \t\t\t\t\t\t\tbuilder.setLength( 0 );\n-  276: \t\t\t\t\t\t}\n-  277: \t\t\t\t\t\telse {\n-  278: \t\t\t\t\t\t\tbuilder.append( '\\'' );\n-  279: \t\t\t\t\t\t}\n-  280: \t\t\t\t\t}\n-  281: \t\t\t\t\telse if ( quotedOperand ) {\n-  282: \t\t\t\t\t\tbuilder.append( operandToken );\n-  283: \t\t\t\t\t}\n-  284: \t\t\t\t\telse if ( parenthesis != 0 ) {\n-  285: \t\t\t\t\t\tbuilder.append( operandToken );\n-  286: \t\t\t\t\t\tswitch ( operandToken ) {\n-  287: \t\t\t\t\t\t\tcase \"(\":\n-  288: \t\t\t\t\t\t\t\tparenthesis++;\n-  289: \t\t\t\t\t\t\t\tbreak;\n-  290: \t\t\t\t\t\t\tcase \")\":\n-  291: \t\t\t\t\t\t\t\tparenthesis--;\n-  292: \t\t\t\t\t\t\t\tbreak;\n-  293: \t\t\t\t\t\t}\n-  294: \t\t\t\t\t}\n-  295: \t\t\t\t\telse {\n-  296: \t\t\t\t\t\tbuilder.append( operandToken );\n-  297: \t\t\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n-  298: \t\t\t\t\t\t\tcase \"(\":\n-  299: \t\t\t\t\t\t\t\tparenthesis++;\n-  300: \t\t\t\t\t\t\t\tbreak;\n-  301: \t\t\t\t\t\t\tcase \")\":\n-  302: \t\t\t\t\t\t\t\tparenthesis--;\n-  303: \t\t\t\t\t\t\t\tbreak;\n-  304: \t\t\t\t\t\t\tcase \"from\":\n-  305: \t\t\t\t\t\t\t\tif ( builder.length() != 0 ) {\n-  306: \t\t\t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n-  307: \t\t\t\t\t\t\t\t\tbuilder.setLength( 0 );\n-  308: \t\t\t\t\t\t\t\t\toperands.add( operandToken );\n-  309: \t\t\t\t\t\t\t\t}\n-  310: \t\t\t\t\t\t\t\tbreak;\n-  311: \t\t\t\t\t\t}\n-  312: \t\t\t\t\t}\n-  313: \t\t\t\t\toperandToken = tokens.nextToken();\n-  314: \t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n-  315: \t\t\t\t}\n-  316: \t\t\t\tif ( builder.length() != 0 ) {\n-  317: \t\t\t\t\toperands.add( builder.toString() );\n-  318: \t\t\t\t}\n-  319: \n-  320: \t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n-  321: \t\t\t\tresult.append( \"trim(\" );\n-  322: \t\t\t\tif ( trimOperands.trimSpec != null ) {\n-  323: \t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n-  324: \t\t\t\t}\n-  325: \t\t\t\tif ( trimOperands.trimChar != null ) {\n-  326: \t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n-  327: \t\t\t\t\t\tresult.append( trimOperands.trimChar );\n-  328: \t\t\t\t\t}\n-  329: \t\t\t\t\telse {\n-  330: \t\t\t\t\t\tresult.append(\n-  331: \t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n-  332: \t\t\t\t\t\t);\n-  333: \t\t\t\t\t}\n-  334: \t\t\t\t\tresult.append( ' ' );\n-  335: \t\t\t\t}\n-  336: \t\t\t\tif ( trimOperands.from != null ) {\n-  337: \t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n-  338: \t\t\t\t}\n-  339: \t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n-  340: \t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char is specified\n-  341: \t\t\t\t\tresult.append( \"from \" );\n-  342: \t\t\t\t}\n-  343: \n-  344: \t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, typeConfiguration, functionRegistry ) )\n-  345: \t\t\t\t\t\t.append( ')' );\n-  346: \n-  347: \t\t\t\thasMore = tokens.hasMoreTokens();\n-  348: \t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n-  349: \n-  350: \t\t\t\tcontinue;\n-  351: \t\t\t}\n-  352: \n-  353: \t\t\tboolean quotedOrWhitespace = quoted || quotedIdentifier || isQuoteCharacter\n-  354: \t\t\t\t\t|| Character.isWhitespace( token.charAt(0) );\n-  355: \n-  356: \t\t\tif ( quotedOrWhitespace ) {\n-  357: \t\t\t\tresult.append( token );\n+  190: \t\t\t\telse {\n+  191: \t\t\t\t\tisOpenQuote = false;\n+  192: \t\t\t\t}\n+  193: \t\t\t\tif ( isOpenQuote ) {\n+  194: \t\t\t\t\tresult.append( placeholder ).append( '.' );\n+  195: \t\t\t\t}\n+  196: \t\t\t}\n+  197: \n+  198: \t\t\tfinal boolean quotedOrWhitespace =\n+  199: \t\t\t\t\tquoted || quotedIdentifier || isQuoteCharacter\n+  200: \t\t\t\t\t\t\t|| token.isBlank();\n+  201: \t\t\tif ( quotedOrWhitespace ) {\n+  202: \t\t\t\tresult.append( token );\n+  203: \t\t\t}\n+  204: \t\t\telse if ( beforeTable ) {\n+  205: \t\t\t\tresult.append( token );\n+  206: \t\t\t\tbeforeTable = false;\n+  207: \t\t\t\tafterFromTable = true;\n+  208: \t\t\t}\n+  209: \t\t\telse if ( afterFromTable ) {\n+  210: \t\t\t\tif ( !\"as\".equals(lcToken) ) {\n+  211: \t\t\t\t\tafterFromTable = false;\n+  212: \t\t\t\t}\n+  213: \t\t\t\tresult.append(token);\n+  214: \t\t\t}\n+  215: \t\t\telse if ( isNamedParameter(token) ) {\n+  216: \t\t\t\tresult.append(token);\n+  217: \t\t\t}\n+  218: \t\t\telse if ( isExtractFunction( lcToken, nextToken ) ) {\n+  219: \t\t\t\t// Special processing for ANSI SQL EXTRACT function\n+  220: \t\t\t\thandleExtractFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n+  221: \t\t\t\thasMore = tokens.hasMoreTokens();\n+  222: \t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n+  223: \t\t\t}\n+  224: \t\t\telse if ( isTrimFunction( lcToken, nextToken ) ) {\n+  225: \t\t\t\t// Special processing for ANSI SQL TRIM function\n+  226: \t\t\t\thandleTrimFunction( placeholder, dialect, typeConfiguration, functionRegistry, tokens, result );\n+  227: \t\t\t\thasMore = tokens.hasMoreTokens();\n+  228: \t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n+  229: \t\t\t}\n+  230: \t\t\telse if ( isIdentifier(token)\n+  231: \t\t\t\t\t&& !isFunctionOrKeyword( lcToken, nextToken, dialect, typeConfiguration, functionRegistry )\n+  232: \t\t\t\t\t&& !isLiteral( lcToken, nextToken, sqlWhereString, symbols, tokens ) ) {\n+  233: \t\t\t\tresult.append(placeholder)\n+  234: \t\t\t\t\t\t.append('.')\n+  235: \t\t\t\t\t\t.append( dialect.quote(token) );\n+  236: \t\t\t}\n+  237: \t\t\telse {\n+  238: \t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n+  239: \t\t\t\t\tbeforeTable = true;\n+  240: \t\t\t\t\tinFromClause = true;\n+  241: \t\t\t\t}\n+  242: \t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n+  243: \t\t\t\t\tbeforeTable = true;\n+  244: \t\t\t\t}\n+  245: \t\t\t\tif ( isBoolean( token ) ) {\n+  246: \t\t\t\t\ttoken = dialect.toBooleanValueString( parseBoolean( token ) );\n+  247: \t\t\t\t}\n+  248: \t\t\t\tresult.append(token);\n+  249: \t\t\t}\n+  250: \n+  251: \t\t\t//Yuck:\n+  252: \t\t\tif ( inFromClause\n+  253: \t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n+  254: \t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n+  255: \t\t\t\tinFromClause = false;\n+  256: \t\t\t}\n+  257: \t\t}\n+  258: \n+  259: \t\treturn result.toString();\n+  260: \t}\n+  261: \n+  262: \tprivate static boolean isTrimFunction(String lcToken, String nextToken) {\n+  263: \t\treturn \"trim\".equals(lcToken) && \"(\".equals(nextToken);\n+  264: \t}\n+  265: \n+  266: \tprivate static boolean isExtractFunction(String lcToken, String nextToken) {\n+  267: \t\treturn \"extract\".equals(lcToken) && \"(\".equals(nextToken);\n+  268: \t}\n+  269: \n+  270: \tprivate static boolean isLiteral(\n+  271: \t\t\tString lcToken, String next,\n+  272: \t\t\tString sqlWhereString, String symbols, StringTokenizer tokens) {\n+  273: \t\tif ( LITERAL_PREFIXES.contains( lcToken ) && next != null ) {\n+  274: \t\t\t// easy cases first\n+  275: \t\t\tif ( \"'\".equals(next) ) {\n+  276: \t\t\t\treturn true;\n+  277: \t\t\t}\n+  278: \t\t\telse if ( !next.isBlank() ) {\n+  279: \t\t\t\treturn false;\n+  280: \t\t\t}\n+  281: \t\t\telse {\n+  282: \t\t\t\t// we need to look ahead in the token stream\n+  283: \t\t\t\t// to find the first non-blank token\n+  284: \t\t\t\tfinal StringTokenizer lookahead =\n+  285: \t\t\t\t\t\tnew StringTokenizer( sqlWhereString, symbols, true );\n+  286: \t\t\t\twhile ( lookahead.countTokens() > tokens.countTokens()+1 ) {\n+  287: \t\t\t\t\tlookahead.nextToken();\n+  288: \t\t\t\t}\n+  289: \t\t\t\tif ( lookahead.hasMoreTokens() ) {\n+  290: \t\t\t\t\tString nextToken;\n+  291: \t\t\t\t\tdo {\n+  292: \t\t\t\t\t\tnextToken = lookahead.nextToken().toLowerCase(Locale.ROOT);\n+  293: \t\t\t\t\t}\n+  294: \t\t\t\t\twhile ( nextToken.isBlank() && lookahead.hasMoreTokens() );\n+  295: \t\t\t\t\treturn \"'\".equals( nextToken )\n+  296: \t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"with\".equals( nextToken )\n+  297: \t\t\t\t\t\t|| lcToken.equals( \"timestamp\" ) && \"with\".equals( nextToken )\n+  298: \t\t\t\t\t\t|| lcToken.equals( \"time\" ) && \"zone\".equals( nextToken );\n+  299: \t\t\t\t}\n+  300: \t\t\t\telse {\n+  301: \t\t\t\t\treturn false;\n+  302: \t\t\t\t}\n+  303: \t\t\t}\n+  304: \t\t}\n+  305: \t\telse {\n+  306: \t\t\treturn false;\n+  307: \t\t}\n+  308: \t}\n+  309: \n+  310: \tprivate static void handleTrimFunction(\n+  311: \t\t\tString placeholder, Dialect dialect,\n+  312: \t\t\tTypeConfiguration typeConfiguration,\n+  313: \t\t\tSqmFunctionRegistry functionRegistry,\n+  314: \t\t\tStringTokenizer tokens,\n+  315: \t\t\tStringBuilder result) {\n+  316: \t\tfinal List<String> operands = new ArrayList<>();\n+  317: \t\tfinal StringBuilder builder = new StringBuilder();\n+  318: \n+  319: \t\tboolean hasMoreOperands = true;\n+  320: \t\tString operandToken = tokens.nextToken();\n+  321: \t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n+  322: \t\t\tcase \"leading\":\n+  323: \t\t\tcase \"trailing\":\n+  324: \t\t\tcase \"both\":\n+  325: \t\t\t\toperands.add( operandToken );\n+  326: \t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n+  327: \t\t\t\t\toperandToken = tokens.nextToken();\n+  328: \t\t\t\t}\n+  329: \t\t\t\tbreak;\n+  330: \t\t}\n+  331: \t\tboolean quotedOperand = false;\n+  332: \t\tint parenthesis = 0;\n+  333: \t\twhile ( hasMoreOperands ) {\n+  334: \t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n+  335: \t\t\tif ( isQuote ) {\n+  336: \t\t\t\tquotedOperand = !quotedOperand;\n+  337: \t\t\t\tif ( !quotedOperand ) {\n+  338: \t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n+  339: \t\t\t\t\tbuilder.setLength( 0 );\n+  340: \t\t\t\t}\n+  341: \t\t\t\telse {\n+  342: \t\t\t\t\tbuilder.append( '\\'' );\n+  343: \t\t\t\t}\n+  344: \t\t\t}\n+  345: \t\t\telse if ( quotedOperand ) {\n+  346: \t\t\t\tbuilder.append( operandToken );\n+  347: \t\t\t}\n+  348: \t\t\telse if ( parenthesis != 0 ) {\n+  349: \t\t\t\tbuilder.append( operandToken );\n+  350: \t\t\t\tswitch ( operandToken ) {\n+  351: \t\t\t\t\tcase \"(\":\n+  352: \t\t\t\t\t\tparenthesis++;\n+  353: \t\t\t\t\t\tbreak;\n+  354: \t\t\t\t\tcase \")\":\n+  355: \t\t\t\t\t\tparenthesis--;\n+  356: \t\t\t\t\t\tbreak;\n+  357: \t\t\t\t}\n   358: \t\t\t}\n-  359: \t\t\telse if ( beforeTable ) {\n-  360: \t\t\t\tresult.append( token );\n-  361: \t\t\t\tbeforeTable = false;\n-  362: \t\t\t\tafterFromTable = true;\n-  363: \t\t\t}\n-  364: \t\t\telse if ( afterFromTable ) {\n-  365: \t\t\t\tif ( !\"as\".equals(lcToken) ) {\n-  366: \t\t\t\t\tafterFromTable = false;\n-  367: \t\t\t\t}\n-  368: \t\t\t\tresult.append(token);\n-  369: \t\t\t}\n-  370: \t\t\telse if ( isNamedParameter(token) ) {\n-  371: \t\t\t\tresult.append(token);\n-  372: \t\t\t}\n-  373: \t\t\telse if ( isIdentifier(token)\n-  374: \t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect, typeConfiguration, functionRegistry) ) {\n-  375: \t\t\t\tresult.append(placeholder)\n-  376: \t\t\t\t\t\t.append('.')\n-  377: \t\t\t\t\t\t.append( dialect.quote(token) );\n-  378: \t\t\t}\n-  379: \t\t\telse {\n-  380: \t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n-  381: \t\t\t\t\tbeforeTable = true;\n-  382: \t\t\t\t\tinFromClause = true;\n-  383: \t\t\t\t}\n-  384: \t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n-  385: \t\t\t\t\tbeforeTable = true;\n-  386: \t\t\t\t}\n-  387: \t\t\t\tif ( isBoolean( token ) ) {\n-  388: \t\t\t\t\ttoken = dialect.toBooleanValueString( Boolean.parseBoolean( token ) );\n-  389: \t\t\t\t}\n-  390: \t\t\t\tresult.append(token);\n-  391: \t\t\t}\n-  392: \n-  393: \t\t\t//Yuck:\n-  394: \t\t\tif ( inFromClause\n-  395: \t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n-  396: \t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n-  397: \t\t\t\tinFromClause = false;\n+  359: \t\t\telse {\n+  360: \t\t\t\tbuilder.append( operandToken );\n+  361: \t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n+  362: \t\t\t\t\tcase \"(\":\n+  363: \t\t\t\t\t\tparenthesis++;\n+  364: \t\t\t\t\t\tbreak;\n+  365: \t\t\t\t\tcase \")\":\n+  366: \t\t\t\t\t\tparenthesis--;\n+  367: \t\t\t\t\t\tbreak;\n+  368: \t\t\t\t\tcase \"from\":\n+  369: \t\t\t\t\t\tif ( !builder.isEmpty() ) {\n+  370: \t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n+  371: \t\t\t\t\t\t\tbuilder.setLength( 0 );\n+  372: \t\t\t\t\t\t\toperands.add( operandToken );\n+  373: \t\t\t\t\t\t}\n+  374: \t\t\t\t\t\tbreak;\n+  375: \t\t\t\t}\n+  376: \t\t\t}\n+  377: \t\t\toperandToken = tokens.nextToken();\n+  378: \t\t\thasMoreOperands = tokens.hasMoreTokens()\n+  379: \t\t\t\t\t&& ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n+  380: \t\t}\n+  381: \t\tif ( !builder.isEmpty() ) {\n+  382: \t\t\toperands.add( builder.toString() );\n+  383: \t\t}\n+  384: \n+  385: \t\tfinal TrimOperands trimOperands = new TrimOperands( operands );\n+  386: \t\tresult.append( \"trim(\" );\n+  387: \t\tif ( trimOperands.trimSpec != null ) {\n+  388: \t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n+  389: \t\t}\n+  390: \t\tif ( trimOperands.trimChar != null ) {\n+  391: \t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n+  392: \t\t\t\tresult.append( trimOperands.trimChar );\n+  393: \t\t\t}\n+  394: \t\t\telse {\n+  395: \t\t\t\tresult.append(\n+  396: \t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n+  397: \t\t\t\t);\n   398: \t\t\t}\n-  399: \t\t}\n-  400: \n-  401: \t\treturn result.toString();\n-  402: \t}\n+  399: \t\t\tresult.append( ' ' );\n+  400: \t\t}\n+  401: \t\tif ( trimOperands.from != null ) {\n+  402: \t\t\tresult.append( trimOperands.from ).append( ' ' );\n",
        "uniqueId": "35f96d6e901dbd071b375d809521ef6f1c979868_119_402_262_264_122_260",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 1,
                "covered": 289
            },
            "BRANCH": {
                "missed": 2,
                "covered": 74
            },
            "LINE": {
                "missed": 0,
                "covered": 79
            },
            "COMPLEXITY": {
                "missed": 2,
                "covered": 37
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\npublic static String renderTransformerReadFragment(\n        String fragment,\n        String... columnNames) {\n    // NOTE : would need access to SessionFactoryImplementor to make this configurable\n    for (String columnName : columnNames) {\n        fragment = fragment.replace(columnName, TEMPLATE + '.' + columnName);\n    }\n    return fragment;\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n\t * named parameters.\n\t *\n\t * @param sqlWhereString The string into which to interpolate the placeholder value\n\t * @param placeholder The value to be interpolated into the sqlWhereString\n\t * @param dialect The dialect to apply\n\t * @param functionRegistry The registry of all sql functions\n\t * @return The rendered sql fragment\n\t */\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\n\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n\t\t//\t\tidentifier references.\n\n\t\tString symbols = PUNCTUATION +\n\t\t\t\tWHITESPACE +\n\t\t\t\tdialect.openQuote() +\n\t\t\t\tdialect.closeQuote();\n\t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n\t\tStringBuilder result = new StringBuilder();\n\n\t\tboolean quoted = false;\n\t\tboolean quotedIdentifier = false;\n\t\tboolean beforeTable = false;\n\t\tboolean inFromClause = false;\n\t\tboolean afterFromTable = false;\n\n\t\tboolean hasMore = tokens.hasMoreTokens();\n\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n\t\twhile ( hasMore ) {\n\t\t\tString token = nextToken;\n\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\tboolean isQuoteCharacter = false;\n\n\t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n\t\t\t\tquoted = !quoted;\n\t\t\t\tisQuoteCharacter = true;\n\t\t\t}\n\n\t\t\tif ( !quoted ) {\n\t\t\t\tboolean isOpenQuote;\n\t\t\t\tif ( \"`\".equals(token) ) {\n\t\t\t\t\tisOpenQuote = !quotedIdentifier;\n\t\t\t\t\ttoken = lcToken = isOpenQuote\n\t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n\t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n\t\t\t\t\tquotedIdentifier = isOpenQuote;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( !quotedIdentifier && ( dialect.openQuote()==token.charAt(0) ) ) {\n\t\t\t\t\tisOpenQuote = true;\n\t\t\t\t\tquotedIdentifier = true;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( quotedIdentifier && ( dialect.closeQuote()==token.charAt(0) ) ) {\n\t\t\t\t\tquotedIdentifier = false;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\telse if ( LITERAL_PREFIXES.contains( lcToken ) ) {\n\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n\t\t\t\t\t\t// Don't prefix a literal\n\t\t\t\t\t\tresult.append( token );\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) ) {\n\t\t\t\t\t\tfinal StringBuilder additionalTokens = new StringBuilder();\n\t\t\t\t\t\tTimeZoneTokens possibleNextToken = null;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tpossibleNextToken = possibleNextToken == null\n\t\t\t\t\t\t\t\t\t? TimeZoneTokens.getPossibleNextTokens( lcToken )\n\t\t\t\t\t\t\t\t\t: possibleNextToken.nextToken();\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tadditionalTokens.append( nextToken );\n\t\t\t\t\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\t\t\t\t\tnextToken = tokens.nextToken();\n\t\t\t\t\t\t\t} while ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) );\n\t\t\t\t\t\t} while ( nextToken != null && possibleNextToken.isToken( nextToken ) );\n\t\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n\t\t\t\t\t\t\t// Don't prefix a literal\n\t\t\t\t\t\t\tresult.append( token );\n\t\t\t\t\t\t\tresult.append( additionalTokens );\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\n\t\t\t\tif ( isOpenQuote ) {\n\t\t\t\t\tresult.append( placeholder ).append( '.' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Special processing for ANSI SQL EXTRACT function\n\t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n\t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n\t\t\t\tfinal String source = renderWhereStringTemplate(\n\t\t\t\t\t\textractUntil( tokens, \")\" ),\n\t\t\t\t\t\tplaceholder,\n\t\t\t\t\t\tdialect,\n\t\t\t\t\t\ttypeConfiguration,\n\t\t\t\t\t\tfunctionRegistry\n\t\t\t\t);\n\t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Special processing for ANSI SQL TRIM function\n\t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n\t\t\t\tList<String> operands = new ArrayList<>();\n\t\t\t\tStringBuilder builder = new StringBuilder();\n\n\t\t\t\tboolean hasMoreOperands = true;\n\t\t\t\tString operandToken = tokens.nextToken();\n\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\tcase \"leading\":\n\t\t\t\t\tcase \"trailing\":\n\t\t\t\t\tcase \"both\":\n\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n\t\t\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tboolean quotedOperand = false;\n\t\t\t\tint parenthesis = 0;\n\t\t\t\twhile ( hasMoreOperands ) {\n\t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n\t\t\t\t\tif ( isQuote ) {\n\t\t\t\t\t\tquotedOperand = !quotedOperand;\n\t\t\t\t\t\tif ( !quotedOperand ) {\n\t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbuilder.append( '\\'' );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if ( quotedOperand ) {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( parenthesis != 0 ) {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t\tswitch ( operandToken ) {\n\t\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"from\":\n\t\t\t\t\t\t\t\tif ( builder.length() != 0 ) {\n\t\t\t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n\t\t\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n\t\t\t\t}\n\t\t\t\tif ( builder.length() != 0 ) {\n\t\t\t\t\toperands.add( builder.toString() );\n\t\t\t\t}\n\n\t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n\t\t\t\tresult.append( \"trim(\" );\n\t\t\t\tif ( trimOperands.trimSpec != null ) {\n\t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n\t\t\t\t}\n\t\t\t\tif ( trimOperands.trimChar != null ) {\n\t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n\t\t\t\t\t\tresult.append( trimOperands.trimChar );\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresult.append(\n\t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tresult.append( ' ' );\n\t\t\t\t}\n\t\t\t\tif ( trimOperands.from != null ) {\n\t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n\t\t\t\t}\n\t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n\t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char is specified\n\t\t\t\t\tresult.append( \"from \" );\n\t\t\t\t}\n\n\t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, typeConfiguration, functionRegistry ) )\n\t\t\t\t\t\t.append( ')' );\n\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tboolean quotedOrWhitespace = quoted || quotedIdentifier || isQuoteCharacter\n\t\t\t\t\t|| Character.isWhitespace( token.charAt(0) );\n\n\t\t\tif ( quotedOrWhitespace ) {\n\t\t\t\tresult.append( token );\n\t\t\t}\n\t\t\telse if ( beforeTable ) {\n\t\t\t\tresult.append( token );\n\t\t\t\tbeforeTable = false;\n\t\t\t\tafterFromTable = true;\n\t\t\t}\n\t\t\telse if ( afterFromTable ) {\n\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n\t\t\t\t\tafterFromTable = false;\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isNamedParameter(token) ) {\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isIdentifier(token)\n\t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect, typeConfiguration, functionRegistry) ) {\n\t\t\t\tresult.append(placeholder)\n\t\t\t\t\t\t.append('.')\n\t\t\t\t\t\t.append( dialect.quote(token) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t\tinFromClause = true;\n\t\t\t\t}\n\t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t}\n\t\t\t\tif ( isBoolean( token ) ) {\n\t\t\t\t\ttoken = dialect.toBooleanValueString( Boolean.parseBoolean( token ) );\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\n\t\t\t//Yuck:\n\t\t\tif ( inFromClause\n\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n\t\t\t\tinFromClause = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result.toString();\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.sql;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.query.sqm.function.SqmFunctionDescriptor;\nimport org.hibernate.query.sqm.function.SqmFunctionRegistry;\nimport org.hibernate.type.spi.TypeConfiguration;\n\nimport static org.hibernate.internal.util.StringHelper.WHITESPACE;\n\n/**\n * Parses SQL fragments specified in mapping documents.\n *\n * @author Gavin King\n */\npublic final class Template {\n\n\tprivate static final Set<String> KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> BEFORE_TABLE_KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> FUNCTION_KEYWORDS = new HashSet<>();\n\tprivate static final Set<String> LITERAL_PREFIXES = new HashSet<>();\n\tpublic static final String PUNCTUATION = \"=><!+-*/()',|&`\";\n\n\tstatic {\n\t\tKEYWORDS.add(\"and\");\n\t\tKEYWORDS.add(\"or\");\n\t\tKEYWORDS.add(\"not\");\n\t\tKEYWORDS.add(\"like\");\n\t\tKEYWORDS.add(\"escape\");\n\t\tKEYWORDS.add(\"is\");\n\t\tKEYWORDS.add(\"in\");\n\t\tKEYWORDS.add(\"between\");\n\t\tKEYWORDS.add(\"null\");\n\t\tKEYWORDS.add(\"select\");\n\t\tKEYWORDS.add(\"distinct\");\n\t\tKEYWORDS.add(\"from\");\n\t\tKEYWORDS.add(\"join\");\n\t\tKEYWORDS.add(\"inner\");\n\t\tKEYWORDS.add(\"outer\");\n\t\tKEYWORDS.add(\"left\");\n\t\tKEYWORDS.add(\"right\");\n\t\tKEYWORDS.add(\"on\");\n\t\tKEYWORDS.add(\"where\");\n\t\tKEYWORDS.add(\"having\");\n\t\tKEYWORDS.add(\"group\");\n\t\tKEYWORDS.add(\"order\");\n\t\tKEYWORDS.add(\"by\");\n\t\tKEYWORDS.add(\"desc\");\n\t\tKEYWORDS.add(\"asc\");\n\t\tKEYWORDS.add(\"limit\");\n\t\tKEYWORDS.add(\"any\");\n\t\tKEYWORDS.add(\"some\");\n\t\tKEYWORDS.add(\"exists\");\n\t\tKEYWORDS.add(\"all\");\n\t\tKEYWORDS.add(\"union\");\n\t\tKEYWORDS.add(\"minus\");\n\t\tKEYWORDS.add(\"except\");\n\t\tKEYWORDS.add(\"intersect\");\n\t\tKEYWORDS.add(\"partition\");\n\n\t\tBEFORE_TABLE_KEYWORDS.add(\"from\");\n\t\tBEFORE_TABLE_KEYWORDS.add(\"join\");\n\n\t\tFUNCTION_KEYWORDS.add(\"as\");\n\t\tFUNCTION_KEYWORDS.add(\"leading\");\n\t\tFUNCTION_KEYWORDS.add(\"trailing\");\n\t\tFUNCTION_KEYWORDS.add(\"from\");\n\t\tFUNCTION_KEYWORDS.add(\"case\");\n\t\tFUNCTION_KEYWORDS.add(\"when\");\n\t\tFUNCTION_KEYWORDS.add(\"then\");\n\t\tFUNCTION_KEYWORDS.add(\"else\");\n\t\tFUNCTION_KEYWORDS.add(\"end\");\n\n\t\tLITERAL_PREFIXES.add(\"n\");\n\t\tLITERAL_PREFIXES.add(\"x\");\n\t\tLITERAL_PREFIXES.add(\"varbyte\");\n\t\tLITERAL_PREFIXES.add(\"bx\");\n\t\tLITERAL_PREFIXES.add(\"bytea\");\n\t\tLITERAL_PREFIXES.add(\"date\");\n\t\tLITERAL_PREFIXES.add(\"time\");\n\t\tLITERAL_PREFIXES.add(\"timestamp\");\n\t}\n\n\tpublic static final String TEMPLATE = \"$PlaceHolder$\";\n\n\tprivate Template() {}\n\n\tpublic static String renderTransformerReadFragment(\n\t\t\tString fragment,\n\t\t\tString... columnNames) {\n\t\t// NOTE : would need access to SessionFactoryImplementor to make this configurable\n\t\tfor ( String columnName : columnNames ) {\n\t\t\tfragment = fragment.replace( columnName, TEMPLATE + '.' + columnName );\n\t\t}\n\t\treturn fragment;\n\t}\n\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn renderWhereStringTemplate( sqlWhereString, TEMPLATE, dialect, typeConfiguration, functionRegistry );\n\t}\n\n\t/**\n\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n\t * named parameters.\n\t *\n\t * @param sqlWhereString The string into which to interpolate the placeholder value\n\t * @param placeholder The value to be interpolated into the sqlWhereString\n\t * @param dialect The dialect to apply\n\t * @param functionRegistry The registry of all sql functions\n\t * @return The rendered sql fragment\n\t */\n\tpublic static String renderWhereStringTemplate(\n\t\t\tString sqlWhereString,\n\t\t\tString placeholder,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\n\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n\t\t//\t\tidentifier references.\n\n\t\tString symbols = PUNCTUATION +\n\t\t\t\tWHITESPACE +\n\t\t\t\tdialect.openQuote() +\n\t\t\t\tdialect.closeQuote();\n\t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n\t\tStringBuilder result = new StringBuilder();\n\n\t\tboolean quoted = false;\n\t\tboolean quotedIdentifier = false;\n\t\tboolean beforeTable = false;\n\t\tboolean inFromClause = false;\n\t\tboolean afterFromTable = false;\n\n\t\tboolean hasMore = tokens.hasMoreTokens();\n\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n\t\twhile ( hasMore ) {\n\t\t\tString token = nextToken;\n\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\tboolean isQuoteCharacter = false;\n\n\t\t\tif ( !quotedIdentifier && \"'\".equals(token) ) {\n\t\t\t\tquoted = !quoted;\n\t\t\t\tisQuoteCharacter = true;\n\t\t\t}\n\n\t\t\tif ( !quoted ) {\n\t\t\t\tboolean isOpenQuote;\n\t\t\t\tif ( \"`\".equals(token) ) {\n\t\t\t\t\tisOpenQuote = !quotedIdentifier;\n\t\t\t\t\ttoken = lcToken = isOpenQuote\n\t\t\t\t\t\t\t? Character.toString( dialect.openQuote() )\n\t\t\t\t\t\t\t: Character.toString( dialect.closeQuote() );\n\t\t\t\t\tquotedIdentifier = isOpenQuote;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( !quotedIdentifier && ( dialect.openQuote()==token.charAt(0) ) ) {\n\t\t\t\t\tisOpenQuote = true;\n\t\t\t\t\tquotedIdentifier = true;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t}\n\t\t\t\telse if ( quotedIdentifier && ( dialect.closeQuote()==token.charAt(0) ) ) {\n\t\t\t\t\tquotedIdentifier = false;\n\t\t\t\t\tisQuoteCharacter = true;\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\t\t\t\telse if ( LITERAL_PREFIXES.contains( lcToken ) ) {\n\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n\t\t\t\t\t\t// Don't prefix a literal\n\t\t\t\t\t\tresult.append( token );\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) ) {\n\t\t\t\t\t\tfinal StringBuilder additionalTokens = new StringBuilder();\n\t\t\t\t\t\tTimeZoneTokens possibleNextToken = null;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tpossibleNextToken = possibleNextToken == null\n\t\t\t\t\t\t\t\t\t? TimeZoneTokens.getPossibleNextTokens( lcToken )\n\t\t\t\t\t\t\t\t\t: possibleNextToken.nextToken();\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tadditionalTokens.append( nextToken );\n\t\t\t\t\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\t\t\t\t\tnextToken = tokens.nextToken();\n\t\t\t\t\t\t\t} while ( nextToken != null && Character.isWhitespace( nextToken.charAt( 0 ) ) );\n\t\t\t\t\t\t} while ( nextToken != null && possibleNextToken.isToken( nextToken ) );\n\t\t\t\t\t\tif ( \"'\".equals( nextToken ) ) {\n\t\t\t\t\t\t\t// Don't prefix a literal\n\t\t\t\t\t\t\tresult.append( token );\n\t\t\t\t\t\t\tresult.append( additionalTokens );\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisOpenQuote = false;\n\t\t\t\t}\n\n\t\t\t\tif ( isOpenQuote ) {\n\t\t\t\t\tresult.append( placeholder ).append( '.' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Special processing for ANSI SQL EXTRACT function\n\t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n\t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n\t\t\t\tfinal String source = renderWhereStringTemplate(\n\t\t\t\t\t\textractUntil( tokens, \")\" ),\n\t\t\t\t\t\tplaceholder,\n\t\t\t\t\t\tdialect,\n\t\t\t\t\t\ttypeConfiguration,\n\t\t\t\t\t\tfunctionRegistry\n\t\t\t\t);\n\t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Special processing for ANSI SQL TRIM function\n\t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n\t\t\t\tList<String> operands = new ArrayList<>();\n\t\t\t\tStringBuilder builder = new StringBuilder();\n\n\t\t\t\tboolean hasMoreOperands = true;\n\t\t\t\tString operandToken = tokens.nextToken();\n\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\tcase \"leading\":\n\t\t\t\t\tcase \"trailing\":\n\t\t\t\t\tcase \"both\":\n\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\tif ( hasMoreOperands = tokens.hasMoreTokens() ) {\n\t\t\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tboolean quotedOperand = false;\n\t\t\t\tint parenthesis = 0;\n\t\t\t\twhile ( hasMoreOperands ) {\n\t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n\t\t\t\t\tif ( isQuote ) {\n\t\t\t\t\t\tquotedOperand = !quotedOperand;\n\t\t\t\t\t\tif ( !quotedOperand ) {\n\t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbuilder.append( '\\'' );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if ( quotedOperand ) {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( parenthesis != 0 ) {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t\tswitch ( operandToken ) {\n\t\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbuilder.append( operandToken );\n\t\t\t\t\t\tswitch ( operandToken.toLowerCase( Locale.ROOT ) ) {\n\t\t\t\t\t\t\tcase \"(\":\n\t\t\t\t\t\t\t\tparenthesis++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \")\":\n\t\t\t\t\t\t\t\tparenthesis--;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"from\":\n\t\t\t\t\t\t\t\tif ( builder.length() != 0 ) {\n\t\t\t\t\t\t\t\t\toperands.add( builder.substring( 0, builder.length() - 4 ) );\n\t\t\t\t\t\t\t\t\tbuilder.setLength( 0 );\n\t\t\t\t\t\t\t\t\toperands.add( operandToken );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\toperandToken = tokens.nextToken();\n\t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ( parenthesis != 0 || ! \")\".equals( operandToken ) );\n\t\t\t\t}\n\t\t\t\tif ( builder.length() != 0 ) {\n\t\t\t\t\toperands.add( builder.toString() );\n\t\t\t\t}\n\n\t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n\t\t\t\tresult.append( \"trim(\" );\n\t\t\t\tif ( trimOperands.trimSpec != null ) {\n\t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n\t\t\t\t}\n\t\t\t\tif ( trimOperands.trimChar != null ) {\n\t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n\t\t\t\t\t\tresult.append( trimOperands.trimChar );\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresult.append(\n\t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, typeConfiguration, functionRegistry )\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tresult.append( ' ' );\n\t\t\t\t}\n\t\t\t\tif ( trimOperands.from != null ) {\n\t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n\t\t\t\t}\n\t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n\t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char is specified\n\t\t\t\t\tresult.append( \"from \" );\n\t\t\t\t}\n\n\t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, typeConfiguration, functionRegistry ) )\n\t\t\t\t\t\t.append( ')' );\n\n\t\t\t\thasMore = tokens.hasMoreTokens();\n\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tboolean quotedOrWhitespace = quoted || quotedIdentifier || isQuoteCharacter\n\t\t\t\t\t|| Character.isWhitespace( token.charAt(0) );\n\n\t\t\tif ( quotedOrWhitespace ) {\n\t\t\t\tresult.append( token );\n\t\t\t}\n\t\t\telse if ( beforeTable ) {\n\t\t\t\tresult.append( token );\n\t\t\t\tbeforeTable = false;\n\t\t\t\tafterFromTable = true;\n\t\t\t}\n\t\t\telse if ( afterFromTable ) {\n\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n\t\t\t\t\tafterFromTable = false;\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isNamedParameter(token) ) {\n\t\t\t\tresult.append(token);\n\t\t\t}\n\t\t\telse if ( isIdentifier(token)\n\t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect, typeConfiguration, functionRegistry) ) {\n\t\t\t\tresult.append(placeholder)\n\t\t\t\t\t\t.append('.')\n\t\t\t\t\t\t.append( dialect.quote(token) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t\tinFromClause = true;\n\t\t\t\t}\n\t\t\t\telse if ( inFromClause && \",\".equals(lcToken) ) {\n\t\t\t\t\tbeforeTable = true;\n\t\t\t\t}\n\t\t\t\tif ( isBoolean( token ) ) {\n\t\t\t\t\ttoken = dialect.toBooleanValueString( Boolean.parseBoolean( token ) );\n\t\t\t\t}\n\t\t\t\tresult.append(token);\n\t\t\t}\n\n\t\t\t//Yuck:\n\t\t\tif ( inFromClause\n\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n\t\t\t\tinFromClause = false;\n\t\t\t}\n\t\t}\n\n\t\treturn result.toString();\n\t}\n\n\tprivate enum TimeZoneTokens {\n\t\tNONE,\n\t\tWITH,\n\t\tTIME,\n\t\tZONE;\n\n\t\tstatic TimeZoneTokens getPossibleNextTokens(String lctoken) {\n\t\t\tswitch ( lctoken ) {\n\t\t\t\tcase \"time\":\n\t\t\t\tcase \"timestamp\":\n\t\t\t\t\treturn WITH;\n\t\t\t\tdefault:\n\t\t\t\t\treturn NONE;\n\t\t\t}\n\t\t}\n\n\t\tpublic TimeZoneTokens nextToken() {\n\t\t\tif ( this == WITH ) {\n\t\t\t\treturn TIME;\n\t\t\t}\n\t\t\telse if ( this == TIME ) {\n\t\t\t\treturn ZONE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn NONE;\n\t\t\t}\n\t\t}\n\n\t\tpublic boolean isToken(String token) {\n\t\t\treturn this != NONE && name().equalsIgnoreCase( token );\n\t\t}\n\t}\n\n\tpublic static List<String> collectColumnNames(\n\t\t\tString sql,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn collectColumnNames( renderWhereStringTemplate( sql, dialect, typeConfiguration, functionRegistry ) );\n\t}\n\n\tpublic static List<String> collectColumnNames(String template) {\n\t\tfinal List<String> names = new ArrayList<>();\n\t\tint begin = 0;\n\t\tint match;\n\t\twhile ( ( match = template.indexOf(TEMPLATE, begin) ) >= 0 ) {\n\t\t\tint start = match + TEMPLATE.length() + 1;\n\t\t\tfor ( int loc = start;; loc++ ) {\n\t\t\t\tif ( loc == template.length() - 1 ) {\n\t\t\t\t\tnames.add( template.substring( start ) );\n\t\t\t\t\tbegin = template.length();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar ch = template.charAt( loc );\n\t\t\t\t\tif ( PUNCTUATION.indexOf(ch) >= 0 || WHITESPACE.indexOf(ch) >= 0 ) {\n\t\t\t\t\t\tnames.add( template.substring( start, loc ) );\n\t\t\t\t\t\tbegin = loc;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn names;\n\t}\n\n//\t/**\n//\t * Takes the where condition provided in the mapping attribute and interpolates the alias.\n//\t * Handles sub-selects, quoted identifiers, quoted strings, expressions, SQL functions,\n//\t * named parameters.\n//\t *\n//\t * @param sqlWhereString The string into which to interpolate the placeholder value\n//\t * @param placeholder The value to be interpolated into the sqlWhereString\n//\t * @param dialect The dialect to apply\n//\t * @param functionRegistry The registry of all sql functions\n//\t *\n//\t * @return The rendered sql fragment\n//\t */\n//\tpublic static String renderWhereStringTemplate(\n//\t\t\tString sqlWhereString,\n//\t\t\tString placeholder,\n//\t\t\tDialect dialect,\n//\t\t\tSQLFunctionRegistry functionRegistry) {\n//\n//\t\t// IMPL NOTE : The basic process here is to tokenize the incoming string and to iterate over each token\n//\t\t//\t\tin turn.  As we process each token, we set a series of flags used to indicate the type of context in\n//\t\t// \t\twhich the tokens occur.  Depending on the state of those flags we decide whether we need to qualify\n//\t\t//\t\tidentifier references.\n//\n//\t\tfinal String dialectOpenQuote = Character.toString( dialect.openQuote() );\n//\t\tfinal String dialectCloseQuote = Character.toString( dialect.closeQuote() );\n//\n//\t\tString symbols = new StringBuilder()\n//\t\t\t\t.append( \"=><!+-*/()',|&`\" )\n//\t\t\t\t.append( StringHelper.WHITESPACE )\n//\t\t\t\t.append( dialect.openQuote() )\n//\t\t\t\t.append( dialect.closeQuote() )\n//\t\t\t\t.toString();\n//\t\tStringTokenizer tokens = new StringTokenizer( sqlWhereString, symbols, true );\n//\t\tProcessingState state = new ProcessingState();\n//\n//\t\tStringBuilder quotedBuffer = new StringBuilder();\n//\t\tStringBuilder result = new StringBuilder();\n//\n//\t\tboolean hasMore = tokens.hasMoreTokens();\n//\t\tString nextToken = hasMore ? tokens.nextToken() : null;\n//\t\twhile ( hasMore ) {\n//\t\t\tString token = nextToken;\n//\t\t\tString lcToken = token.toLowerCase(Locale.ROOT);\n//\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t// First, determine quoting which might be based on either:\n//\t\t\t// \t\t1) back-tick\n//\t\t\t// \t\t2) single quote (ANSI SQL standard)\n//\t\t\t// \t\t3) or dialect defined quote character(s)\n//\t\t\tQuotingCharacterDisposition quotingCharacterDisposition = QuotingCharacterDisposition.NONE;\n//\t\t\tif ( \"`\".equals( token ) ) {\n//\t\t\t\tstate.quoted = !state.quoted;\n//\t\t\t\tquotingCharacterDisposition = state.quoted\n//\t\t\t\t\t\t? QuotingCharacterDisposition.OPEN\n//\t\t\t\t\t\t: QuotingCharacterDisposition.CLOSE;\n//\t\t\t\t// replace token with the appropriate dialect quoting char\n//\t\t\t\ttoken = lcToken = ( quotingCharacterDisposition == QuotingCharacterDisposition.OPEN )\n//\t\t\t\t\t\t? dialectOpenQuote\n//\t\t\t\t\t\t: dialectCloseQuote;\n//\t\t\t}\n//\t\t\telse if ( \"'\".equals( token ) ) {\n//\t\t\t\tstate.quoted = !state.quoted;\n//\t\t\t\tquotingCharacterDisposition = state.quoted\n//\t\t\t\t\t\t? QuotingCharacterDisposition.OPEN\n//\t\t\t\t\t\t: QuotingCharacterDisposition.CLOSE;\n//\t\t\t}\n//\t\t\telse if ( !state.quoted && dialectOpenQuote.equals( token ) ) {\n//\t\t\t\tstate.quoted = true;\n//\t\t\t\tquotingCharacterDisposition = QuotingCharacterDisposition.OPEN;\n//\t\t\t}\n//\t\t\telse if ( state.quoted && dialectCloseQuote.equals( token ) ) {\n//\t\t\t\tstate.quoted = false;\n//\t\t\t\tquotingCharacterDisposition = QuotingCharacterDisposition.CLOSE;\n//\t\t\t}\n//\n//\t\t\tif ( state.quoted ) {\n//\t\t\t\tquotedBuffer.append( token );\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// if we were previously processing quoted state and just encountered the close quote, then handle that\n//\t\t\t// quoted text\n//\t\t\tif ( quotingCharacterDisposition == QuotingCharacterDisposition.CLOSE ) {\n//\t\t\t\ttoken = quotedBuffer.toString();\n//\t\t\t\tquotedBuffer.setLength( 0 );\n//\t\t\t\tresult.append( placeholder ).append( '.' )\n//\t\t\t\t\t\t.append( dialectOpenQuote ).append( token ).append( dialectCloseQuote );\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// Special processing for ANSI SQL EXTRACT function\n//\t\t\tif ( \"extract\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n//\t\t\t\tfinal String field = extractUntil( tokens, \"from\" );\n//\t\t\t\tfinal String source = renderWhereStringTemplate(\n//\t\t\t\t\t\textractUntil( tokens, \")\" ),\n//\t\t\t\t\t\tplaceholder,\n//\t\t\t\t\t\tdialect,\n//\t\t\t\t\t\tfunctionRegistry\n//\t\t\t\t);\n//\t\t\t\tresult.append( \"extract(\" ).append( field ).append( \" from \" ).append( source ).append( ')' );\n//\n//\t\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\t\t\t// Special processing for ANSI SQL TRIM function\n//\t\t\tif ( \"trim\".equals( lcToken ) && \"(\".equals( nextToken ) ) {\n//\t\t\t\tList<String> operands = new ArrayList<String>();\n//\t\t\t\tStringBuilder builder = new StringBuilder();\n//\n//\t\t\t\tboolean hasMoreOperands = true;\n//\t\t\t\tString operandToken = tokens.nextToken();\n//\t\t\t\tboolean quoted = false;\n//\t\t\t\twhile ( hasMoreOperands ) {\n//\t\t\t\t\tfinal boolean isQuote = \"'\".equals( operandToken );\n//\t\t\t\t\tif ( isQuote ) {\n//\t\t\t\t\t\tquoted = !quoted;\n//\t\t\t\t\t\tif ( !quoted ) {\n//\t\t\t\t\t\t\toperands.add( builder.append( '\\'' ).toString() );\n//\t\t\t\t\t\t\tbuilder.setLength( 0 );\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse {\n//\t\t\t\t\t\t\tbuilder.append( '\\'' );\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t\telse if ( quoted ) {\n//\t\t\t\t\t\tbuilder.append( operandToken );\n//\t\t\t\t\t}\n//\t\t\t\t\telse if ( operandToken.length() == 1 && Character.isWhitespace( operandToken.charAt( 0 ) ) ) {\n//\t\t\t\t\t\t// do nothing\n//\t\t\t\t\t}\n//\t\t\t\t\telse {\n//\t\t\t\t\t\toperands.add( operandToken );\n//\t\t\t\t\t}\n//\t\t\t\t\toperandToken = tokens.nextToken();\n//\t\t\t\t\thasMoreOperands = tokens.hasMoreTokens() && ! \")\".equals( operandToken );\n//\t\t\t\t}\n//\n//\t\t\t\tTrimOperands trimOperands = new TrimOperands( operands );\n//\t\t\t\tresult.append( \"trim(\" );\n//\t\t\t\tif ( trimOperands.trimSpec != null ) {\n//\t\t\t\t\tresult.append( trimOperands.trimSpec ).append( ' ' );\n//\t\t\t\t}\n//\t\t\t\tif ( trimOperands.trimChar != null ) {\n//\t\t\t\t\tif ( trimOperands.trimChar.startsWith( \"'\" ) && trimOperands.trimChar.endsWith( \"'\" ) ) {\n//\t\t\t\t\t\tresult.append( trimOperands.trimChar );\n//\t\t\t\t\t}\n//\t\t\t\t\telse {\n//\t\t\t\t\t\tresult.append(\n//\t\t\t\t\t\t\t\trenderWhereStringTemplate( trimOperands.trimSpec, placeholder, dialect, functionRegistry )\n//\t\t\t\t\t\t);\n//\t\t\t\t\t}\n//\t\t\t\t\tresult.append( ' ' );\n//\t\t\t\t}\n//\t\t\t\tif ( trimOperands.from != null ) {\n//\t\t\t\t\tresult.append( trimOperands.from ).append( ' ' );\n//\t\t\t\t}\n//\t\t\t\telse if ( trimOperands.trimSpec != null || trimOperands.trimChar != null ) {\n//\t\t\t\t\t// I think ANSI SQL says that the 'from' is not optional if either trim-spec or trim-char are specified\n//\t\t\t\t\tresult.append( \"from \" );\n//\t\t\t\t}\n//\n//\t\t\t\tresult.append( renderWhereStringTemplate( trimOperands.trimSource, placeholder, dialect, functionRegistry ) )\n//\t\t\t\t\t\t.append( ')' );\n//\n//\t\t\t\thasMore = tokens.hasMoreTokens();\n//\t\t\t\tnextToken = hasMore ? tokens.nextToken() : null;\n//\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\n//\n//\t\t\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\n//\t\t\tif ( Character.isWhitespace( token.charAt( 0 ) ) ) {\n//\t\t\t\tresult.append( token );\n//\t\t\t}\n//\t\t\telse if ( state.beforeTable ) {\n//\t\t\t\tresult.append( token );\n//\t\t\t\tstate.beforeTable = false;\n//\t\t\t\tstate.afterFromTable = true;\n//\t\t\t}\n//\t\t\telse if ( state.afterFromTable ) {\n//\t\t\t\tif ( !\"as\".equals(lcToken) ) {\n//\t\t\t\t\tstate.afterFromTable = false;\n//\t\t\t\t}\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\t\t\telse if ( isNamedParameter(token) ) {\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\t\t\telse if ( isIdentifier(token, dialect)\n//\t\t\t\t\t&& !isFunctionOrKeyword(lcToken, nextToken, dialect , functionRegistry) ) {\n//\t\t\t\tresult.append(placeholder)\n//\t\t\t\t\t\t.append('.')\n//\t\t\t\t\t\t.append( dialect.quote(token) );\n//\t\t\t}\n//\t\t\telse {\n//\t\t\t\tif ( BEFORE_TABLE_KEYWORDS.contains(lcToken) ) {\n//\t\t\t\t\tstate.beforeTable = true;\n//\t\t\t\t\tstate.inFromClause = true;\n//\t\t\t\t}\n//\t\t\t\telse if ( state.inFromClause && \",\".equals(lcToken) ) {\n//\t\t\t\t\tstate.beforeTable = true;\n//\t\t\t\t}\n//\t\t\t\tresult.append(token);\n//\t\t\t}\n//\n//\t\t\t//Yuck:\n//\t\t\tif ( state.inFromClause\n//\t\t\t\t\t&& KEYWORDS.contains( lcToken ) //\"as\" is not in KEYWORDS\n//\t\t\t\t\t&& !BEFORE_TABLE_KEYWORDS.contains( lcToken ) ) {\n//\t\t\t\tstate.inFromClause = false;\n//\t\t\t}\n//\t\t}\n//\n//\t\treturn result.toString();\n//\t}\n//\n//\tprivate static class ProcessingState {\n//\t\tboolean quoted = false;\n//\t\tboolean quotedIdentifier = false;\n//\t\tboolean beforeTable = false;\n//\t\tboolean inFromClause = false;\n//\t\tboolean afterFromTable = false;\n//\t}\n//\n//\tprivate static enum QuotingCharacterDisposition { NONE, OPEN, CLOSE }\n\n\tprivate static class TrimOperands {\n\t\tprivate final String trimSpec;\n\t\tprivate final String trimChar;\n\t\tprivate final String from;\n\t\tprivate final String trimSource;\n\n\t\tprivate TrimOperands(List<String> operands) {\n\t\t\tfinal int size = operands.size();\n\t\t\tif ( size == 1 ) {\n\t\t\t\ttrimSpec = null;\n\t\t\t\ttrimChar = null;\n\t\t\t\tfrom = null;\n\t\t\t\ttrimSource = operands.get(0);\n\t\t\t}\n\t\t\telse if ( size == 4 ) {\n\t\t\t\ttrimSpec = operands.get(0);\n\t\t\t\ttrimChar = operands.get(1);\n\t\t\t\tfrom = operands.get(2);\n\t\t\t\ttrimSource = operands.get(3);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( size < 1 || size > 4 ) {\n\t\t\t\t\tthrow new HibernateException( \"Unexpected number of trim function operands : \" + size );\n\t\t\t\t}\n\n\t\t\t\t// trim-source will always be the last operand\n\t\t\t\ttrimSource = operands.get( size - 1 );\n\n\t\t\t\t// ANSI SQL says that more than one operand means that the FROM is required\n\t\t\t\tif ( ! \"from\".equals( operands.get( size - 2 ) ) ) {\n\t\t\t\t\tthrow new HibernateException( \"Expecting FROM, found : \" + operands.get( size - 2 ) );\n\t\t\t\t}\n\t\t\t\tfrom = operands.get( size - 2 );\n\n\t\t\t\t// trim-spec, if there is one will always be the first operand\n\t\t\t\tif ( \"leading\".equalsIgnoreCase( operands.get(0) )\n\t\t\t\t\t\t|| \"trailing\".equalsIgnoreCase( operands.get(0) )\n\t\t\t\t\t\t|| \"both\".equalsIgnoreCase( operands.get(0) ) ) {\n\t\t\t\t\ttrimSpec = operands.get(0);\n\t\t\t\t\ttrimChar = null;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttrimSpec = null;\n\t\t\t\t\tif ( size - 2 == 0 ) {\n\t\t\t\t\t\ttrimChar = null;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttrimChar = operands.get( 0 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static String extractUntil(StringTokenizer tokens, String delimiter) {\n\t\tStringBuilder valueBuilder = new StringBuilder();\n\t\tString token = tokens.nextToken();\n\t\twhile ( ! delimiter.equalsIgnoreCase( token ) ) {\n\t\t\tvalueBuilder.append( token );\n\t\t\ttoken = tokens.nextToken();\n\t\t}\n\t\treturn valueBuilder.toString().trim();\n\t}\n\n\tprivate static boolean isNamedParameter(String token) {\n\t\treturn token.startsWith( \":\" );\n\t}\n\n\tprivate static boolean isFunctionOrKeyword(\n\t\t\tString lcToken,\n\t\t\tString nextToken,\n\t\t\tDialect dialect,\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tSqmFunctionRegistry functionRegistry) {\n\t\treturn \"(\".equals( nextToken ) ||\n\t\t\t\tKEYWORDS.contains( lcToken ) ||\n\t\t\t\tisType( lcToken, typeConfiguration ) ||\n\t\t\t\tisFunction( lcToken, nextToken, functionRegistry ) ||\n\t\t\t\tdialect.getKeywords().contains( lcToken ) ||\n\t\t\t\tFUNCTION_KEYWORDS.contains( lcToken );\n\t}\n\n\tprivate static boolean isType(String lcToken, TypeConfiguration typeConfiguration) {\n\t\treturn typeConfiguration.getDdlTypeRegistry().isTypeNameRegistered( lcToken );\n\t}\n\n\tprivate static boolean isFunction(String lcToken, String nextToken, SqmFunctionRegistry functionRegistry) {\n\t\t// checking for \"(\" is currently redundant because it is checked before getting here;\n\t\t// doing the check anyhow, in case that earlier check goes away;\n\t\tif ( \"(\".equals( nextToken ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tfinal SqmFunctionDescriptor function = functionRegistry.findFunctionDescriptor( lcToken );\n\t\treturn function != null;\n\t}\n\n\tprivate static boolean isIdentifier(String token) {\n\t\tif ( isBoolean( token ) ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn token.charAt( 0 ) == '`' || ( //allow any identifier quoted with backtick\n\t\t\t\tCharacter.isLetter( token.charAt( 0 ) ) && //only recognizes identifiers beginning with a letter\n\t\t\t\t\t\ttoken.indexOf( '.' ) < 0\n\t\t);\n\t}\n\n\tprivate static boolean isBoolean(String token) {\n\t\treturn \"true\".equals( token ) || \"false\".equals( token );\n\t}\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate setupStatementInspector(jpa Jpa, integrationSettings Map<String,Object>) : void extracted from public findEntityManagerFactoryScope(testScope Object, emfAnnWrapper Optional<Jpa>, context ExtensionContext) : EntityManagerFactoryScope in class org.hibernate.testing.orm.junit.EntityManagerFactoryExtension",
        "diffLocations": [
            {
                "filePath": "hibernate-testing/src/main/java/org/hibernate/testing/orm/junit/EntityManagerFactoryExtension.java",
                "startLine": 66,
                "endLine": 203,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-testing/src/main/java/org/hibernate/testing/orm/junit/EntityManagerFactoryExtension.java",
                "startLine": 61,
                "endLine": 91,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-testing/src/main/java/org/hibernate/testing/orm/junit/EntityManagerFactoryExtension.java",
                "startLine": 181,
                "endLine": 189,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public static EntityManagerFactoryScope findEntityManagerFactoryScope(\n\t\t\tObject testScope,\n\t\t\tOptional<Jpa> emfAnnWrapper,\n\t\t\tExtensionContext context) {\n\n\t\tif ( emfAnnWrapper.isEmpty() ) {\n\t\t\t// No annotation on the test class, should be on the test methods\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n\t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n\t\tif ( existing != null ) {\n\t\t\treturn existing;\n\t\t}\n\n\t\tif ( !context.getElement().isPresent() ) {\n\t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \" + context.getDisplayName() );\n\t\t}\n\t\tfinal Jpa emfAnn = emfAnnWrapper.get();\n\n\t\tfinal PersistenceUnitInfoImpl pui = new PersistenceUnitInfoImpl( emfAnn.persistenceUnitName() );\n\t\t( (Map<Object, Object>) Environment.getProperties() ).forEach(\n\t\t\t\t(key, value) ->\n\t\t\t\t\t\tpui.getProperties().put( key, value )\n\t\t);\n\n\t\tpui.setTransactionType( emfAnn.transactionType() );\n\t\tpui.setCacheMode( emfAnn.sharedCacheMode() );\n\t\tpui.setValidationMode( emfAnn.validationMode() );\n\t\tpui.setExcludeUnlistedClasses( emfAnn.excludeUnlistedClasses() );\n\n\t\t// JpaCompliance\n\t\tpui.getProperties().put( AvailableSettings.JPA_COMPLIANCE, emfAnn.jpaComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_QUERY_COMPLIANCE, emfAnn.queryComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, emfAnn.transactionComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_CLOSED_COMPLIANCE, emfAnn.closedComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_PROXY_COMPLIANCE, emfAnn.proxyComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_CACHING_COMPLIANCE, emfAnn.cacheComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, emfAnn.generatorScopeComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, emfAnn.orderByMappingComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, emfAnn.loadByIdComplianceEnabled() );\n\n\t\tfinal Setting[] properties = emfAnn.properties();\n\t\tfor ( int i = 0; i < properties.length; i++ ) {\n\t\t\tfinal Setting property = properties[i];\n\t\t\tpui.getProperties().setProperty( property.name(), property.value() );\n\t\t}\n\n\t\tpui.getProperties().setProperty(\n\t\t\t\tAvailableSettings.GENERATE_STATISTICS,\n\t\t\t\tBoolean.toString( emfAnn.generateStatistics() )\n\t\t);\n\n\t\tif ( emfAnn.exportSchema() ) {\n\t\t\tpui.getProperties().setProperty(\n\t\t\t\t\tAvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,\n\t\t\t\t\tAction.CREATE_DROP.getExternalHbm2ddlName()\n\t\t\t);\n\t\t}\n\n\t\tif ( emfAnn.annotatedPackageNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( emfAnn.annotatedPackageNames() );\n\t\t}\n\n\t\tif ( emfAnn.annotatedClassNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClassNames() );\n\t\t}\n\n\t\tif ( emfAnn.annotatedClasses().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.annotatedClasses().length; i++ ) {\n\t\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClasses()[i].getName() );\n\t\t\t}\n\t\t}\n\n\t\tif ( emfAnn.xmlMappings().length > 0 ) {\n\t\t\tpui.applyMappingFiles( emfAnn.xmlMappings() );\n\t\t}\n\n\t\tif ( emfAnn.standardModels().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.standardModels().length; i++ ) {\n\t\t\t\tfinal StandardDomainModel standardDomainModel = emfAnn.standardModels()[i];\n\t\t\t\tfor ( int i1 = 0; i1 < standardDomainModel.getDescriptor().getAnnotatedClasses().length; i1++ ) {\n\t\t\t\t\tfinal Class<?> annotatedClass = standardDomainModel.getDescriptor().getAnnotatedClasses()[i1];\n\t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( emfAnn.modelDescriptorClasses().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.modelDescriptorClasses().length; i++ ) {\n\t\t\t\tfinal Class<? extends DomainModelDescriptor> modelDescriptorClass = emfAnn.modelDescriptorClasses()[i];\n\t\t\t\tfinal DomainModelDescriptor domainModelDescriptor = instantiateDomainModelDescriptor(\n\t\t\t\t\t\tmodelDescriptorClass );\n\t\t\t\tfor ( int i1 = 0; i1 < domainModelDescriptor.getAnnotatedClasses().length; i1++ ) {\n\t\t\t\t\tfinal Class<?> annotatedClass = domainModelDescriptor.getAnnotatedClasses()[i1];\n\t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfinal Map<String, Object> integrationSettings = new HashMap<>();\n\n\t\tintegrationSettings.put( PersistentTableStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( GlobalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( LocalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tfor ( int i = 0; i < emfAnn.integrationSettings().length; i++ ) {\n\t\t\tfinal Setting setting = emfAnn.integrationSettings()[i];\n\t\t\tintegrationSettings.put( setting.name(), setting.value() );\n\t\t}\n\n\t\tfor ( SettingProvider providerAnn : emfAnn.settingProviders() ) {\n\t\t\tfinal Class<? extends SettingProvider.Provider<?>> providerImpl = providerAnn.provider();\n\t\t\ttry {\n\t\t\t\tfinal SettingProvider.Provider<?> provider = providerImpl.getConstructor().newInstance();\n\t\t\t\tintegrationSettings.put( providerAnn.settingName(), provider.getSetting() );\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tlog.error( \"Error obtaining setting provider for \" + providerImpl.getName(), e );\n\t\t\t}\n\t\t}\n\n\t\t// statement inspector\n\t\tif ( emfAnn.useCollectingStatementInspector() ) {\n\t\t\tString inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n\t\t\tif ( !(inspectorSetting == null || inspectorSetting.isBlank()) ) {\n\t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n\t\t\t}\n\t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n\t\t}\n\n\t\tServiceRegistryUtil.applySettings( integrationSettings );\n\t\tfinal EntityManagerFactoryScopeImpl scope = new EntityManagerFactoryScopeImpl( pui, integrationSettings );\n\n\t\tstore.put( EMF_KEY, scope );\n\n\t\treturn scope;\n\t}",
        "filePathBefore": "hibernate-testing/src/main/java/org/hibernate/testing/orm/junit/EntityManagerFactoryExtension.java",
        "isPureRefactoring": true,
        "commitId": "4781c09d0df0eb4ce05b2fa0d2a12747023ae024",
        "packageNameBefore": "org.hibernate.testing.orm.junit",
        "classNameBefore": "org.hibernate.testing.orm.junit.EntityManagerFactoryExtension",
        "methodNameBefore": "org.hibernate.testing.orm.junit.EntityManagerFactoryExtension#findEntityManagerFactoryScope",
        "invokedMethod": "methodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#setValidationMode\n methodBody: public void setValidationMode(String validationMode) {\nsetValidationMode(ValidationMode.valueOf(validationMode));\n}\nmethodSignature: org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}\nmethodSignature: org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor#getName\n methodBody: public String getName() {\nreturn persistenceUnitInfo.getPersistenceUnitName();\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setTransactionType\n methodBody: public void setTransactionType(PersistenceUnitTransactionType transactionType) {\nthis.transactionType=transactionType;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest#applySettings\n methodBody: protected void applySettings(Map<Object, Object> settings) {\nString[] mappings=getMappings();\nif(mappings != null){settings.put(AvailableSettings.HBM_XML_FILES,String.join(\",\",mappings));\n}}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setValidationMode\n methodBody: public void setValidationMode(ValidationMode validationMode) {\nthis.validationMode=validationMode;\n}\nmethodSignature: org.hibernate.collection.spi.AbstractPersistentCollection.SetProxy#isEmpty\n methodBody: public boolean isEmpty() {\nreturn set.isEmpty();\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#applyMappingFiles\n methodBody: public void applyMappingFiles(String... mappingFiles) {\nif(this.mappingFiles == null){this.mappingFiles=new ArrayList<>();\n}Collections.addAll(this.mappingFiles,mappingFiles);\n}\nmethodSignature: org.hibernate.testing.util.jpa.DelegatingPersistenceUnitInfo#getProperties\n methodBody: public Properties getProperties() {\nreturn delegate.getProperties();\n}\nmethodSignature: org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentList#get\n methodBody: public E get(int index) {\nif(index < 0){throw new ArrayIndexOutOfBoundsException(\"negative index\");\n}final Object result=readElementByIndex(index);\nreturn result == UNKNOWN ? list.get(index) : (E)result;\n}\nmethodSignature: org.hibernate.orm.test.bootstrap.BootstrapTest.PersistenceUnitInfoImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest.TestingPersistenceUnitDescriptorImpl#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.jpa.boot.spi.PersistenceConfigurationDescriptor#getName\n methodBody: public String getName() {\nreturn persistenceConfiguration.name();\n}\nmethodSignature: org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor#getProperties\n methodBody: public Properties getProperties() {\nreturn persistenceUnitInfo.getProperties();\n}\nmethodSignature: org.hibernate.jpa.boot.spi.PersistenceUnitDescriptor#getProperties\n methodBody: Properties getProperties();\nmethodSignature: org.hibernate.testing.orm.junit.BaseSessionFactoryFunctionalTest#getAnnotatedClasses\n methodBody: protected Class[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}\nmethodSignature: org.hibernate.testing.orm.junit.BaseSessionFactoryFunctionalTest#applySettings\n methodBody: protected void applySettings(StandardServiceRegistryBuilder builder) {\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoAdapter#getProperties\n methodBody: public Properties getProperties() {\nif(properties == null){properties=new Properties();\n}return properties;\n}\nmethodSignature: org.hibernate.testing.util.jpa.DelegatingPersistenceUnitInfo#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn delegate.excludeUnlistedClasses();\n}\nmethodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoAdapter#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setCacheMode\n methodBody: public void setCacheMode(SharedCacheMode cacheMode) {\nthis.cacheMode=cacheMode;\n}\nmethodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.orm.test.jpa.BaseEntityManagerFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn excludeUnlistedClasses;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}\nmethodSignature: org.hibernate.collection.spi.AbstractPersistentCollection.ListProxy#get\n methodBody: public E get(int i) {\nreturn list.get(i);\n}\nmethodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoAdapter#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}\nmethodSignature: org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}\nmethodSignature: org.hibernate.orm.test.bootstrap.BootstrapTest.PersistenceUnitInfoImpl#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}\nmethodSignature: org.hibernate.jpa.boot.spi.PersistenceConfigurationDescriptor#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitDescriptorAdapter#getProperties\n methodBody: public Properties getProperties() {\nif(properties == null){properties=new Properties();\n}return properties;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentBag#get\n methodBody: public E get(int i) {\nread();\nreturn bag.get(i);\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoAdapter#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setExcludeUnlistedClasses\n methodBody: public void setExcludeUnlistedClasses(boolean excludeUnlistedClasses) {\nthis.excludeUnlistedClasses=excludeUnlistedClasses;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentList#toString\n methodBody: public String toString() {\nread();\nreturn list.toString();\n}\nmethodSignature: org.hibernate.testing.junit4.BaseCoreFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentBag#getElement\n methodBody: public Object getElement(Object entry) {\nreturn entry;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentBag#isEmpty\n methodBody: public boolean isEmpty() {\nreturn readSize() ? getCachedSize() == 0 : bag.isEmpty();\n}\nmethodSignature: org.hibernate.orm.test.jpa.xml.versions.JpaXsdVersionsTest.PersistenceUnitInfoImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}\nmethodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#setTransactionType\n methodBody: public void setTransactionType(PersistenceUnitTransactionType transactionType) {\nthis.transactionType=transactionType;\n}\nmethodSignature: org.hibernate.orm.test.jpa.EntityManagerTest#getAnnotatedClasses\n methodBody: public Class[] getAnnotatedClasses() {\nreturn new Class[]{Item.class,Distributor.class,Wallet.class};\n}\nmethodSignature: org.hibernate.orm.test.jpa.BaseEntityManagerFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest#exportSchema\n methodBody: protected boolean exportSchema() {\nreturn true;\n}\nmethodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}\nmethodSignature: org.hibernate.internal.SessionFactoryImpl#getProperties\n methodBody: public Map<String, Object> getProperties() {\nvalidateNotClosed();\nreturn settings;\n}\nmethodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoPropertiesWrapper#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}\nmethodSignature: org.hibernate.orm.test.jpa.xml.versions.JpaXsdVersionsTest.PersistenceUnitInfoImpl#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}\nmethodSignature: org.hibernate.jpa.boot.spi.PersistenceUnitDescriptor#getName\n methodBody: String getName();\nmethodSignature: org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn null;\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitDescriptorAdapter#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryExtension#locateExtensionStore\n methodBody: private static ExtensionContext.Store locateExtensionStore(Object testScope, ExtensionContext context) {\nreturn JUnitHelper.locateExtensionStore(EntityManagerFactoryExtension.class,context,testScope);\n}\nmethodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#setExcludeUnlistedClasses\n methodBody: public void setExcludeUnlistedClasses(boolean excludeUnlistedClasses) {\nthis.excludeUnlistedClasses=excludeUnlistedClasses;\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#applyManagedClassNames\n methodBody: public void applyManagedClassNames(String... managedClassNames) {\nif(this.managedClassNames == null){this.managedClassNames=new ArrayList<>();\n}Collections.addAll(this.managedClassNames,managedClassNames);\n}\nmethodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoPropertiesWrapper#getProperties\n methodBody: public Properties getProperties() {\nif(properties == null){properties=new Properties();\n}return properties;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentList#getElement\n methodBody: public Object getElement(Object entry) {\nreturn entry;\n}\nmethodSignature: org.hibernate.orm.test.jpa.BaseEntityManagerFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn null;\n}\nmethodSignature: org.hibernate.internal.SessionFactoryImpl#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest.TestingPersistenceUnitDescriptorImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn null;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentList#isEmpty\n methodBody: public boolean isEmpty() {\nreturn readSize() ? getCachedSize() == 0 : list.isEmpty();\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryExtension#instantiateDomainModelDescriptor\n methodBody: private static DomainModelDescriptor instantiateDomainModelDescriptor(Class<? extends DomainModelDescriptor> modelDescriptorClass) {\ntryfinal Field[] declaredFields=modelDescriptorClass.getDeclaredFields();\nfor(int i=0; i < declaredFields.length; i++){final Field field=declaredFields[i];\nif(ReflectHelper.isStaticField(field)){final Object value=field.get(null);\nif(value instanceof DomainModelDescriptor){return (DomainModelDescriptor)value;\n}}}catch(IllegalAccessException e)throw new RuntimeException(\"Problem accessing DomainModelDescriptor fields : \" + modelDescriptorClass.getName(),e);\ntryreturn modelDescriptorClass.getConstructor(null).newInstance(null);\ncatch(InstantiationException|IllegalAccessException|InvocationTargetException|NoSuchMethodException e)throw new RuntimeException(\"Problem instantiation DomainModelDescriptor : \" + modelDescriptorClass.getName(),e);\n}\nmethodSignature: org.hibernate.testing.orm.junit.BaseSessionFactoryFunctionalTest#exportSchema\n methodBody: protected boolean exportSchema() {\nreturn true;\n}\nmethodSignature: org.hibernate.collection.spi.AbstractPersistentCollection.ListProxy#isEmpty\n methodBody: public boolean isEmpty() {\nreturn list.isEmpty();\n}\nmethodSignature: org.hibernate.collection.spi.PersistentBag#toString\n methodBody: public String toString() {\nread();\nreturn bag.toString();\n}",
        "classSignatureBefore": "public class EntityManagerFactoryExtension\n\t\timplements TestInstancePostProcessor, BeforeEachCallback, TestExecutionExceptionHandler ",
        "methodNameBeforeSet": [
            "org.hibernate.testing.orm.junit.EntityManagerFactoryExtension#findEntityManagerFactoryScope"
        ],
        "classNameBeforeSet": [
            "org.hibernate.testing.orm.junit.EntityManagerFactoryExtension"
        ],
        "classSignatureBeforeSet": [
            "public class EntityManagerFactoryExtension\n\t\timplements TestInstancePostProcessor, BeforeEachCallback, TestExecutionExceptionHandler "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Overlapped refactoring - can be identical by undoing the overlapped refactoring\n- Rename Variable-",
                "description": "Rename Variable on top of the extract method - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.testing.orm.junit;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport jakarta.persistence.spi.PersistenceUnitInfo;\n\nimport org.hibernate.SessionFactoryObserver;\nimport org.hibernate.boot.registry.StandardServiceRegistry;\nimport org.hibernate.boot.spi.MetadataImplementor;\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.cfg.Environment;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.internal.util.ReflectHelper;\nimport org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor;\nimport org.hibernate.jpa.boot.spi.Bootstrap;\nimport org.hibernate.jpa.boot.spi.EntityManagerFactoryBuilder;\nimport org.hibernate.query.sqm.mutation.internal.temptable.GlobalTemporaryTableMutationStrategy;\nimport org.hibernate.query.sqm.mutation.internal.temptable.LocalTemporaryTableMutationStrategy;\nimport org.hibernate.query.sqm.mutation.internal.temptable.PersistentTableStrategy;\nimport org.hibernate.tool.schema.Action;\nimport org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator;\nimport org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator.ActionGrouping;\n\nimport org.hibernate.testing.jdbc.SQLStatementInspector;\nimport org.hibernate.testing.orm.domain.DomainModelDescriptor;\nimport org.hibernate.testing.orm.domain.StandardDomainModel;\nimport org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl;\nimport org.hibernate.testing.util.ServiceRegistryUtil;\nimport org.junit.jupiter.api.extension.BeforeEachCallback;\nimport org.junit.jupiter.api.extension.ExtensionContext;\nimport org.junit.jupiter.api.extension.TestExecutionExceptionHandler;\nimport org.junit.jupiter.api.extension.TestInstancePostProcessor;\nimport org.junit.platform.commons.support.AnnotationSupport;\n\nimport org.jboss.logging.Logger;\n\n/**\n * hibernate-testing implementation of a few JUnit5 contracts to support SessionFactory-based testing,\n * including argument injection (or see {@link SessionFactoryScopeAware})\n *\n * @author Steve Ebersole\n *\n * @see DomainModelExtension\n * @see SessionFactoryExtension\n */\npublic class EntityManagerFactoryExtension\n\t\timplements TestInstancePostProcessor, BeforeEachCallback, TestExecutionExceptionHandler {\n\n\tprivate static final Logger log = Logger.getLogger( EntityManagerFactoryExtension.class );\n\tprivate static final String EMF_KEY = EntityManagerFactoryScope.class.getName();\n\n\tprivate static ExtensionContext.Store locateExtensionStore(Object testScope, ExtensionContext context) {\n\t\treturn JUnitHelper.locateExtensionStore( EntityManagerFactoryExtension.class, context, testScope );\n\t}\n\n\tpublic static EntityManagerFactoryScope findEntityManagerFactoryScope(\n\t\t\tObject testScope,\n\t\t\tOptional<Jpa> emfAnnWrapper,\n\t\t\tExtensionContext context) {\n\n\t\tif ( emfAnnWrapper.isEmpty() ) {\n\t\t\t// No annotation on the test class, should be on the test methods\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n\t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n\t\tif ( existing != null ) {\n\t\t\treturn existing;\n\t\t}\n\n\t\tif ( !context.getElement().isPresent() ) {\n\t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \" + context.getDisplayName() );\n\t\t}\n\t\tfinal Jpa emfAnn = emfAnnWrapper.get();\n\n\t\tfinal PersistenceUnitInfoImpl pui = new PersistenceUnitInfoImpl( emfAnn.persistenceUnitName() );\n\t\t( (Map<Object, Object>) Environment.getProperties() ).forEach(\n\t\t\t\t(key, value) ->\n\t\t\t\t\t\tpui.getProperties().put( key, value )\n\t\t);\n\n\t\tpui.setTransactionType( emfAnn.transactionType() );\n\t\tpui.setCacheMode( emfAnn.sharedCacheMode() );\n\t\tpui.setValidationMode( emfAnn.validationMode() );\n\t\tpui.setExcludeUnlistedClasses( emfAnn.excludeUnlistedClasses() );\n\n\t\t// JpaCompliance\n\t\tpui.getProperties().put( AvailableSettings.JPA_COMPLIANCE, emfAnn.jpaComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_QUERY_COMPLIANCE, emfAnn.queryComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, emfAnn.transactionComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_CLOSED_COMPLIANCE, emfAnn.closedComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_PROXY_COMPLIANCE, emfAnn.proxyComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_CACHING_COMPLIANCE, emfAnn.cacheComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, emfAnn.generatorScopeComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, emfAnn.orderByMappingComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, emfAnn.loadByIdComplianceEnabled() );\n\n\t\tfinal Setting[] properties = emfAnn.properties();\n\t\tfor ( int i = 0; i < properties.length; i++ ) {\n\t\t\tfinal Setting property = properties[i];\n\t\t\tpui.getProperties().setProperty( property.name(), property.value() );\n\t\t}\n\n\t\tpui.getProperties().setProperty(\n\t\t\t\tAvailableSettings.GENERATE_STATISTICS,\n\t\t\t\tBoolean.toString( emfAnn.generateStatistics() )\n\t\t);\n\n\t\tif ( emfAnn.exportSchema() ) {\n\t\t\tpui.getProperties().setProperty(\n\t\t\t\t\tAvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,\n\t\t\t\t\tAction.CREATE_DROP.getExternalHbm2ddlName()\n\t\t\t);\n\t\t}\n\n\t\tif ( emfAnn.annotatedPackageNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( emfAnn.annotatedPackageNames() );\n\t\t}\n\n\t\tif ( emfAnn.annotatedClassNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClassNames() );\n\t\t}\n\n\t\tif ( emfAnn.annotatedClasses().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.annotatedClasses().length; i++ ) {\n\t\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClasses()[i].getName() );\n\t\t\t}\n\t\t}\n\n\t\tif ( emfAnn.xmlMappings().length > 0 ) {\n\t\t\tpui.applyMappingFiles( emfAnn.xmlMappings() );\n\t\t}\n\n\t\tif ( emfAnn.standardModels().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.standardModels().length; i++ ) {\n\t\t\t\tfinal StandardDomainModel standardDomainModel = emfAnn.standardModels()[i];\n\t\t\t\tfor ( int i1 = 0; i1 < standardDomainModel.getDescriptor().getAnnotatedClasses().length; i1++ ) {\n\t\t\t\t\tfinal Class<?> annotatedClass = standardDomainModel.getDescriptor().getAnnotatedClasses()[i1];\n\t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( emfAnn.modelDescriptorClasses().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.modelDescriptorClasses().length; i++ ) {\n\t\t\t\tfinal Class<? extends DomainModelDescriptor> modelDescriptorClass = emfAnn.modelDescriptorClasses()[i];\n\t\t\t\tfinal DomainModelDescriptor domainModelDescriptor = instantiateDomainModelDescriptor(\n\t\t\t\t\t\tmodelDescriptorClass );\n\t\t\t\tfor ( int i1 = 0; i1 < domainModelDescriptor.getAnnotatedClasses().length; i1++ ) {\n\t\t\t\t\tfinal Class<?> annotatedClass = domainModelDescriptor.getAnnotatedClasses()[i1];\n\t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfinal Map<String, Object> integrationSettings = new HashMap<>();\n\n\t\tintegrationSettings.put( PersistentTableStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( GlobalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( LocalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tfor ( int i = 0; i < emfAnn.integrationSettings().length; i++ ) {\n\t\t\tfinal Setting setting = emfAnn.integrationSettings()[i];\n\t\t\tintegrationSettings.put( setting.name(), setting.value() );\n\t\t}\n\n\t\tfor ( SettingProvider providerAnn : emfAnn.settingProviders() ) {\n\t\t\tfinal Class<? extends SettingProvider.Provider<?>> providerImpl = providerAnn.provider();\n\t\t\ttry {\n\t\t\t\tfinal SettingProvider.Provider<?> provider = providerImpl.getConstructor().newInstance();\n\t\t\t\tintegrationSettings.put( providerAnn.settingName(), provider.getSetting() );\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tlog.error( \"Error obtaining setting provider for \" + providerImpl.getName(), e );\n\t\t\t}\n\t\t}\n\n\t\t// statement inspector\n\t\tif ( emfAnn.useCollectingStatementInspector() ) {\n\t\t\tString inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n\t\t\tif ( !(inspectorSetting == null || inspectorSetting.isBlank()) ) {\n\t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n\t\t\t}\n\t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n\t\t}\n\n\t\tServiceRegistryUtil.applySettings( integrationSettings );\n\t\tfinal EntityManagerFactoryScopeImpl scope = new EntityManagerFactoryScopeImpl( pui, integrationSettings );\n\n\t\tstore.put( EMF_KEY, scope );\n\n\t\treturn scope;\n\t}\n\n\tprivate static DomainModelDescriptor instantiateDomainModelDescriptor(Class<? extends DomainModelDescriptor> modelDescriptorClass) {\n\t\t// first, see if it has a static singleton reference and use that if so\n\t\ttry {\n\t\t\tfinal Field[] declaredFields = modelDescriptorClass.getDeclaredFields();\n\t\t\tfor ( int i = 0; i < declaredFields.length; i++ ) {\n\t\t\t\tfinal Field field = declaredFields[i];\n\t\t\t\tif ( ReflectHelper.isStaticField( field ) ) {\n\t\t\t\t\tfinal Object value = field.get( null );\n\t\t\t\t\tif ( value instanceof DomainModelDescriptor ) {\n\t\t\t\t\t\treturn (DomainModelDescriptor) value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalAccessException e) {\n\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\"Problem accessing DomainModelDescriptor fields : \" + modelDescriptorClass.getName(),\n\t\t\t\t\te\n\t\t\t);\n\t\t}\n\n\t\t// no singleton field, try to instantiate it via reflection\n\t\ttry {\n\t\t\treturn modelDescriptorClass.getConstructor( null ).newInstance( null );\n\t\t}\n\t\tcatch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {\n\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\"Problem instantiation DomainModelDescriptor : \" + modelDescriptorClass.getName(),\n\t\t\t\t\te\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate static void prepareSchemaExport(\n\t\t\tSessionFactoryImplementor sessionFactory,\n\t\t\tMetadataImplementor model) {\n\t\tfinal Map<String, Object> baseProperties = sessionFactory.getProperties();\n\n\t\tfinal Set<ActionGrouping> groupings = ActionGrouping.interpret( model, baseProperties );\n\t\tif ( !groupings.isEmpty() ) {\n\t\t\t// the properties contained explicit settings for auto schema tooling - skip the annotation\n\t\t\treturn;\n\t\t}\n\n\t\tfinal HashMap<String,Object> settings = new HashMap<>( baseProperties );\n\t\tsettings.put( AvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION, Action.CREATE_DROP );\n\n\t\tfinal StandardServiceRegistry serviceRegistry = model.getMetadataBuildingOptions().getServiceRegistry();\n\n\n\t\tSchemaManagementToolCoordinator.process(\n\t\t\t\tmodel,\n\t\t\t\tserviceRegistry,\n\t\t\t\tsettings,\n\t\t\t\taction -> sessionFactory.addObserver(\n\t\t\t\t\t\tnew SessionFactoryObserver() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void sessionFactoryClosing(org.hibernate.SessionFactory factory) {\n\t\t\t\t\t\t\t\taction.perform( serviceRegistry );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t)\n\t\t);\n\t}\n\n\t@Override\n\tpublic void beforeEach(ExtensionContext context) {\n\t\tlog.tracef( \"#beforeEach(%s)\", context.getDisplayName() );\n\t\tfinal Optional<Jpa> emfAnnWrapper = AnnotationSupport.findAnnotation(\n\t\t\t\tcontext.getRequiredTestMethod(),\n\t\t\t\tJpa.class\n\t\t);\n\n\t\tif ( emfAnnWrapper.isEmpty() ) {\n\t\t\t// assume the annotation is defined on the class-level...\n\t\t\treturn;\n\t\t}\n\n\t\tfindEntityManagerFactoryScope( context.getRequiredTestMethod(), emfAnnWrapper, context );\n\t}\n\n\t@Override\n\tpublic void postProcessTestInstance(Object testInstance, ExtensionContext context) {\n\t\tlog.tracef( \"#postProcessTestInstance(%s, %s)\", testInstance, context.getDisplayName() );\n\n\t\tfinal Optional<Jpa> emfAnnWrapper = AnnotationSupport.findAnnotation(\n\t\t\t\tcontext.getRequiredTestClass(),\n\t\t\t\tJpa.class\n\t\t);\n\n\t\tfindEntityManagerFactoryScope( testInstance, emfAnnWrapper, context );\n\t}\n\n\t@Override\n\tpublic void handleTestExecutionException(ExtensionContext context, Throwable throwable) throws Throwable {\n\t\tlog.tracef( \"#handleTestExecutionException(%s, %s)\", context.getDisplayName(), throwable );\n\n\t\ttry {\n\t\t\tfinal Object testInstance = context.getRequiredTestInstance();\n\t\t\tfinal ExtensionContext.Store store = locateExtensionStore( testInstance, context );\n\t\t\tfinal EntityManagerFactoryScopeImpl scope = (EntityManagerFactoryScopeImpl) store.get( EMF_KEY );\n\t\t\tscope.releaseEntityManagerFactory();\n\t\t}\n\t\tcatch (Exception ignore) {\n\t\t}\n\n\t\tthrow throwable;\n\t}\n\n\tprivate static class EntityManagerFactoryScopeImpl extends AbstractEntityManagerFactoryScope {\n\t\tprivate final PersistenceUnitInfo persistenceUnitInfo;\n\t\tprivate final Map<String, Object> integrationSettings;\n\n\t\tprivate EntityManagerFactoryScopeImpl(\n\t\t\t\tPersistenceUnitInfo persistenceUnitInfo,\n\t\t\t\tMap<String, Object> integrationSettings) {\n\t\t\tthis.persistenceUnitInfo = persistenceUnitInfo;\n\t\t\tthis.integrationSettings = integrationSettings;\n\t\t}\n\n\t\tprotected jakarta.persistence.EntityManagerFactory createEntityManagerFactory() {\n\t\t\tfinal EntityManagerFactoryBuilder emfBuilder = Bootstrap.getEntityManagerFactoryBuilder(\n\t\t\t\t\tnew PersistenceUnitInfoDescriptor( persistenceUnitInfo ),\n\t\t\t\t\tintegrationSettings\n\t\t\t);\n\n\t\t\treturn emfBuilder.build();\n\t\t}\n\t}\n}\n",
        "filePathAfter": "hibernate-testing/src/main/java/org/hibernate/testing/orm/junit/EntityManagerFactoryExtension.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.testing.orm.junit;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Properties;\n\nimport jakarta.persistence.spi.PersistenceUnitInfo;\n\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.cfg.Environment;\nimport org.hibernate.internal.util.ReflectHelper;\nimport org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor;\nimport org.hibernate.query.sqm.mutation.internal.temptable.GlobalTemporaryTableMutationStrategy;\nimport org.hibernate.query.sqm.mutation.internal.temptable.LocalTemporaryTableMutationStrategy;\nimport org.hibernate.query.sqm.mutation.internal.temptable.PersistentTableStrategy;\nimport org.hibernate.tool.schema.Action;\n\nimport org.hibernate.testing.jdbc.SQLStatementInspector;\nimport org.hibernate.testing.orm.domain.DomainModelDescriptor;\nimport org.hibernate.testing.orm.domain.StandardDomainModel;\nimport org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl;\nimport org.hibernate.testing.util.ServiceRegistryUtil;\nimport org.junit.jupiter.api.extension.BeforeEachCallback;\nimport org.junit.jupiter.api.extension.ExtensionContext;\nimport org.junit.jupiter.api.extension.TestExecutionExceptionHandler;\nimport org.junit.jupiter.api.extension.TestInstancePostProcessor;\n\nimport org.jboss.logging.Logger;\n\nimport static org.hibernate.jpa.boot.spi.Bootstrap.getEntityManagerFactoryBuilder;\nimport static org.junit.platform.commons.support.AnnotationSupport.findAnnotation;\n\n/**\n * hibernate-testing implementation of a few JUnit5 contracts to support SessionFactory-based testing,\n * including argument injection (or see {@link SessionFactoryScopeAware})\n *\n * @author Steve Ebersole\n *\n * @see DomainModelExtension\n * @see SessionFactoryExtension\n */\npublic class EntityManagerFactoryExtension\n\t\timplements TestInstancePostProcessor, BeforeEachCallback, TestExecutionExceptionHandler {\n\n\tprivate static final Logger log = Logger.getLogger( EntityManagerFactoryExtension.class );\n\tprivate static final String EMF_KEY = EntityManagerFactoryScope.class.getName();\n\n\tprivate static ExtensionContext.Store locateExtensionStore(Object testScope, ExtensionContext context) {\n\t\treturn JUnitHelper.locateExtensionStore( EntityManagerFactoryExtension.class, context, testScope );\n\t}\n\n\tpublic static EntityManagerFactoryScope findEntityManagerFactoryScope(\n\t\t\tObject testScope, Optional<Jpa> optionalJpa, ExtensionContext context) {\n\n\t\tif ( optionalJpa.isEmpty() ) {\n\t\t\t// No annotation on the test class, should be on the test methods\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n\t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n\t\tif ( existing != null ) {\n\t\t\treturn existing;\n\t\t}\n\t\tif ( context.getElement().isEmpty() ) {\n\t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \"\n\t\t\t\t\t+ context.getDisplayName() );\n\t\t}\n\n\t\tfinal Jpa jpa = optionalJpa.get();\n\t\tfinal PersistenceUnitInfoImpl pui = createPersistenceUnitInfo( jpa );\n\t\tcollectProperties( pui, jpa );\n\t\tmanagedClassesAndMappings( jpa, pui );\n\t\tfinal Map<String, Object> integrationSettings = collectIntegrationSettings( jpa );\n\t\t// statement inspector\n\t\tsetupStatementInspector( jpa, integrationSettings );\n\t\tServiceRegistryUtil.applySettings( integrationSettings );\n\t\tfinal EntityManagerFactoryScopeImpl scope =\n\t\t\t\tnew EntityManagerFactoryScopeImpl( pui, integrationSettings );\n\t\tstore.put( EMF_KEY, scope );\n\t\treturn scope;\n\t}\n\n\tprivate static void collectProperties(PersistenceUnitInfoImpl pui, Jpa jpa) {\n\t\tfinal Properties properties = pui.getProperties();\n\t\tproperties.putAll( Environment.getProperties() );\n\t\t// JpaCompliance\n\t\tsetJpaComplianceProperties( properties, jpa );\n\t\tfor ( Setting property : jpa.properties() ) {\n\t\t\tproperties.setProperty( property.name(), property.value() );\n\t\t}\n\t\tproperties.setProperty(\n\t\t\t\tAvailableSettings.GENERATE_STATISTICS,\n\t\t\t\tBoolean.toString( jpa.generateStatistics() )\n\t\t);\n\t\tif ( jpa.exportSchema() ) {\n\t\t\tproperties.setProperty(\n\t\t\t\t\tAvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,\n\t\t\t\t\tAction.CREATE_DROP.getExternalHbm2ddlName()\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate static PersistenceUnitInfoImpl createPersistenceUnitInfo(Jpa jpa) {\n\t\tfinal PersistenceUnitInfoImpl pui =\n\t\t\t\tnew PersistenceUnitInfoImpl( jpa.persistenceUnitName() );\n\t\tpui.setTransactionType( jpa.transactionType() );\n\t\tpui.setCacheMode( jpa.sharedCacheMode() );\n\t\tpui.setValidationMode( jpa.validationMode() );\n\t\tpui.setExcludeUnlistedClasses( jpa.excludeUnlistedClasses() );\n\t\treturn pui;\n\t}\n\n\tprivate static void managedClassesAndMappings(Jpa jpa, PersistenceUnitInfoImpl pui) {\n\t\tif ( jpa.annotatedPackageNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( jpa.annotatedPackageNames() );\n\t\t}\n\n\t\tif ( jpa.annotatedClassNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( jpa.annotatedClassNames() );\n\t\t}\n\n\t\tif ( jpa.annotatedClasses().length > 0 ) {\n\t\t\tfor (int i = 0; i < jpa.annotatedClasses().length; i++ ) {\n\t\t\t\tpui.applyManagedClassNames( jpa.annotatedClasses()[i].getName() );\n\t\t\t}\n\t\t}\n\n\t\tif ( jpa.xmlMappings().length > 0 ) {\n\t\t\tpui.applyMappingFiles( jpa.xmlMappings() );\n\t\t}\n\n\t\tfor ( StandardDomainModel standardDomainModel : jpa.standardModels() ) {\n\t\t\tfor ( Class<?> annotatedClass : standardDomainModel.getDescriptor().getAnnotatedClasses() ) {\n\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t}\n\t\t}\n\n\t\tfor ( Class<? extends DomainModelDescriptor> modelDescriptorClass :\n\t\t\t\tjpa.modelDescriptorClasses() ) {\n\t\t\tfinal DomainModelDescriptor domainModelDescriptor =\n\t\t\t\t\tinstantiateDomainModelDescriptor( modelDescriptorClass );\n\t\t\tfinal Class<?>[] annotatedClasses = domainModelDescriptor.getAnnotatedClasses();\n\t\t\tfor ( Class<?> annotatedClass : annotatedClasses ) {\n\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static Map<String, Object> collectIntegrationSettings(Jpa jpa) {\n\t\tfinal Map<String, Object> integrationSettings = new HashMap<>();\n\t\tintegrationSettings.put( PersistentTableStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( GlobalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( LocalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tfinal Setting[] settings = jpa.integrationSettings();\n\t\tfor ( Setting setting : settings ) {\n\t\t\tintegrationSettings.put( setting.name(), setting.value() );\n\t\t}\n\t\tfor ( SettingProvider providerAnn : jpa.settingProviders() ) {\n\t\t\tfinal Class<? extends SettingProvider.Provider<?>> providerImpl = providerAnn.provider();\n\t\t\ttry {\n\t\t\t\tintegrationSettings.put( providerAnn.settingName(),\n\t\t\t\t\t\tproviderImpl.getConstructor().newInstance().getSetting() );\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tlog.error( \"Error obtaining setting provider for \" + providerImpl.getName(), e );\n\t\t\t}\n\t\t}\n\t\treturn integrationSettings;\n\t}\n\n\tprivate static void setupStatementInspector(Jpa jpa, Map<String, Object> integrationSettings) {\n\t\tif ( jpa.useCollectingStatementInspector() ) {\n\t\t\tfinal String inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n\t\t\tif ( inspectorSetting != null && !inspectorSetting.isBlank() ) {\n\t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n\t\t\t}\n\t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n\t\t}\n\t}\n\n\tprivate static void setJpaComplianceProperties(Properties properties, Jpa jpa) {\n\t\tproperties.put( AvailableSettings.JPA_COMPLIANCE, jpa.jpaComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_QUERY_COMPLIANCE, jpa.queryComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, jpa.transactionComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_CLOSED_COMPLIANCE, jpa.closedComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_PROXY_COMPLIANCE, jpa.proxyComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_CACHING_COMPLIANCE, jpa.cacheComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, jpa.generatorScopeComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, jpa.orderByMappingComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, jpa.loadByIdComplianceEnabled() );\n\t}\n\n\tprivate static DomainModelDescriptor instantiateDomainModelDescriptor(\n\t\t\tClass<? extends DomainModelDescriptor> modelDescriptorClass) {\n\t\t// first, see if it has a static singleton reference and use that if so\n\t\ttry {\n\t\t\tfor ( Field field : modelDescriptorClass.getDeclaredFields() ) {\n\t\t\t\tif ( ReflectHelper.isStaticField(field) ) {\n\t\t\t\t\tfinal Object value = field.get( null );\n\t\t\t\t\tif ( value instanceof DomainModelDescriptor descriptor ) {\n\t\t\t\t\t\treturn descriptor;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalAccessException e) {\n\t\t\tthrow new RuntimeException( \"Problem accessing DomainModelDescriptor fields : \"\n\t\t\t\t\t+ modelDescriptorClass.getName(), e );\n\t\t}\n\n\t\t// no singleton field, try to instantiate it via reflection\n\t\ttry {\n\t\t\treturn modelDescriptorClass.getConstructor( null ).newInstance( null );\n\t\t}\n\t\tcatch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {\n\t\t\tthrow new RuntimeException( \"Problem instantiation DomainModelDescriptor : \"\n\t\t\t\t\t+ modelDescriptorClass.getName(), e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void beforeEach(ExtensionContext context) {\n\t\tlog.tracef( \"#beforeEach(%s)\", context.getDisplayName() );\n\t\tfinal Optional<Jpa> optionalJpa = findAnnotation( context.getRequiredTestMethod(), Jpa.class );\n\t\tif ( optionalJpa.isPresent() ) {\n\t\t\tfindEntityManagerFactoryScope( context.getRequiredTestMethod(), optionalJpa, context );\n\t\t}\n\t\t// else assume the annotation is defined on the class-level...\n\t}\n\n\t@Override\n\tpublic void postProcessTestInstance(Object testInstance, ExtensionContext context) {\n\t\tlog.tracef( \"#postProcessTestInstance(%s, %s)\", testInstance, context.getDisplayName() );\n\t\tfinal Optional<Jpa> optionalJpa = findAnnotation( context.getRequiredTestClass(), Jpa.class );\n\t\tfindEntityManagerFactoryScope( testInstance, optionalJpa, context );\n\t}\n\n\t@Override\n\tpublic void handleTestExecutionException(ExtensionContext context, Throwable throwable) throws Throwable {\n\t\tlog.tracef( \"#handleTestExecutionException(%s, %s)\", context.getDisplayName(), throwable );\n\t\ttry {\n\t\t\tfinal ExtensionContext.Store store = locateExtensionStore( context.getRequiredTestInstance(), context );\n\t\t\tfinal EntityManagerFactoryScopeImpl scope = (EntityManagerFactoryScopeImpl) store.get( EMF_KEY );\n\t\t\tscope.releaseEntityManagerFactory();\n\t\t}\n\t\tcatch (Exception ignore) {\n\t\t}\n\t\tthrow throwable;\n\t}\n\n\tprivate static class EntityManagerFactoryScopeImpl extends AbstractEntityManagerFactoryScope {\n\t\tprivate final PersistenceUnitInfo persistenceUnitInfo;\n\t\tprivate final Map<String, Object> integrationSettings;\n\n\t\tprivate EntityManagerFactoryScopeImpl(\n\t\t\t\tPersistenceUnitInfo persistenceUnitInfo,\n\t\t\t\tMap<String, Object> integrationSettings) {\n\t\t\tthis.persistenceUnitInfo = persistenceUnitInfo;\n\t\t\tthis.integrationSettings = integrationSettings;\n\t\t}\n\n\t\tprotected jakarta.persistence.EntityManagerFactory createEntityManagerFactory() {\n\t\t\tfinal PersistenceUnitInfoDescriptor descriptor = new PersistenceUnitInfoDescriptor( persistenceUnitInfo );\n\t\t\treturn getEntityManagerFactoryBuilder( descriptor, integrationSettings ).build();\n\t\t}\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private static void setupStatementInspector(Jpa jpa, Map<String, Object> integrationSettings) {\n\t\tif ( jpa.useCollectingStatementInspector() ) {\n\t\t\tfinal String inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n\t\t\tif ( inspectorSetting != null && !inspectorSetting.isBlank() ) {\n\t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n\t\t\t}\n\t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n\t\t}\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#setValidationMode\n methodBody: public void setValidationMode(String validationMode) {\nsetValidationMode(ValidationMode.valueOf(validationMode));\n}",
            "methodSignature: org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}",
            "methodSignature: org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor#getName\n methodBody: public String getName() {\nreturn persistenceUnitInfo.getPersistenceUnitName();\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setTransactionType\n methodBody: public void setTransactionType(PersistenceUnitTransactionType transactionType) {\nthis.transactionType=transactionType;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest#applySettings\n methodBody: protected void applySettings(Map<Object, Object> settings) {\nString[] mappings=getMappings();\nif(mappings != null){settings.put(AvailableSettings.HBM_XML_FILES,String.join(\",\",mappings));\n}}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setValidationMode\n methodBody: public void setValidationMode(ValidationMode validationMode) {\nthis.validationMode=validationMode;\n}",
            "methodSignature: org.hibernate.collection.spi.AbstractPersistentCollection.SetProxy#isEmpty\n methodBody: public boolean isEmpty() {\nreturn set.isEmpty();\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#applyMappingFiles\n methodBody: public void applyMappingFiles(String... mappingFiles) {\nif(this.mappingFiles == null){this.mappingFiles=new ArrayList<>();\n}Collections.addAll(this.mappingFiles,mappingFiles);\n}",
            "methodSignature: org.hibernate.testing.util.jpa.DelegatingPersistenceUnitInfo#getProperties\n methodBody: public Properties getProperties() {\nreturn delegate.getProperties();\n}",
            "methodSignature: org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentList#get\n methodBody: public E get(int index) {\nif(index < 0){throw new ArrayIndexOutOfBoundsException(\"negative index\");\n}final Object result=readElementByIndex(index);\nreturn result == UNKNOWN ? list.get(index) : (E)result;\n}",
            "methodSignature: org.hibernate.orm.test.bootstrap.BootstrapTest.PersistenceUnitInfoImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest.TestingPersistenceUnitDescriptorImpl#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.jpa.boot.spi.PersistenceConfigurationDescriptor#getName\n methodBody: public String getName() {\nreturn persistenceConfiguration.name();\n}",
            "methodSignature: org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor#getProperties\n methodBody: public Properties getProperties() {\nreturn persistenceUnitInfo.getProperties();\n}",
            "methodSignature: org.hibernate.jpa.boot.spi.PersistenceUnitDescriptor#getProperties\n methodBody: Properties getProperties();",
            "methodSignature: org.hibernate.testing.orm.junit.BaseSessionFactoryFunctionalTest#getAnnotatedClasses\n methodBody: protected Class[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.BaseSessionFactoryFunctionalTest#applySettings\n methodBody: protected void applySettings(StandardServiceRegistryBuilder builder) {\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoAdapter#getProperties\n methodBody: public Properties getProperties() {\nif(properties == null){properties=new Properties();\n}return properties;\n}",
            "methodSignature: org.hibernate.testing.util.jpa.DelegatingPersistenceUnitInfo#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn delegate.excludeUnlistedClasses();\n}",
            "methodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoAdapter#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setCacheMode\n methodBody: public void setCacheMode(SharedCacheMode cacheMode) {\nthis.cacheMode=cacheMode;\n}",
            "methodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.orm.test.jpa.BaseEntityManagerFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn excludeUnlistedClasses;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}",
            "methodSignature: org.hibernate.collection.spi.AbstractPersistentCollection.ListProxy#get\n methodBody: public E get(int i) {\nreturn list.get(i);\n}",
            "methodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoAdapter#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}",
            "methodSignature: org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}",
            "methodSignature: org.hibernate.orm.test.bootstrap.BootstrapTest.PersistenceUnitInfoImpl#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}",
            "methodSignature: org.hibernate.jpa.boot.spi.PersistenceConfigurationDescriptor#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitDescriptorAdapter#getProperties\n methodBody: public Properties getProperties() {\nif(properties == null){properties=new Properties();\n}return properties;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentBag#get\n methodBody: public E get(int i) {\nread();\nreturn bag.get(i);\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoAdapter#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setExcludeUnlistedClasses\n methodBody: public void setExcludeUnlistedClasses(boolean excludeUnlistedClasses) {\nthis.excludeUnlistedClasses=excludeUnlistedClasses;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentList#toString\n methodBody: public String toString() {\nread();\nreturn list.toString();\n}",
            "methodSignature: org.hibernate.testing.junit4.BaseCoreFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentBag#getElement\n methodBody: public Object getElement(Object entry) {\nreturn entry;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentBag#isEmpty\n methodBody: public boolean isEmpty() {\nreturn readSize() ? getCachedSize() == 0 : bag.isEmpty();\n}",
            "methodSignature: org.hibernate.orm.test.jpa.xml.versions.JpaXsdVersionsTest.PersistenceUnitInfoImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}",
            "methodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#setTransactionType\n methodBody: public void setTransactionType(PersistenceUnitTransactionType transactionType) {\nthis.transactionType=transactionType;\n}",
            "methodSignature: org.hibernate.orm.test.jpa.EntityManagerTest#getAnnotatedClasses\n methodBody: public Class[] getAnnotatedClasses() {\nreturn new Class[]{Item.class,Distributor.class,Wallet.class};\n}",
            "methodSignature: org.hibernate.orm.test.jpa.BaseEntityManagerFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest#exportSchema\n methodBody: protected boolean exportSchema() {\nreturn true;\n}",
            "methodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}",
            "methodSignature: org.hibernate.internal.SessionFactoryImpl#getProperties\n methodBody: public Map<String, Object> getProperties() {\nvalidateNotClosed();\nreturn settings;\n}",
            "methodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoPropertiesWrapper#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}",
            "methodSignature: org.hibernate.orm.test.jpa.xml.versions.JpaXsdVersionsTest.PersistenceUnitInfoImpl#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}",
            "methodSignature: org.hibernate.jpa.boot.spi.PersistenceUnitDescriptor#getName\n methodBody: String getName();",
            "methodSignature: org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn null;\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitDescriptorAdapter#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryExtension#locateExtensionStore\n methodBody: private static ExtensionContext.Store locateExtensionStore(Object testScope, ExtensionContext context) {\nreturn JUnitHelper.locateExtensionStore(EntityManagerFactoryExtension.class,context,testScope);\n}",
            "methodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#setExcludeUnlistedClasses\n methodBody: public void setExcludeUnlistedClasses(boolean excludeUnlistedClasses) {\nthis.excludeUnlistedClasses=excludeUnlistedClasses;\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#applyManagedClassNames\n methodBody: public void applyManagedClassNames(String... managedClassNames) {\nif(this.managedClassNames == null){this.managedClassNames=new ArrayList<>();\n}Collections.addAll(this.managedClassNames,managedClassNames);\n}",
            "methodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoPropertiesWrapper#getProperties\n methodBody: public Properties getProperties() {\nif(properties == null){properties=new Properties();\n}return properties;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentList#getElement\n methodBody: public Object getElement(Object entry) {\nreturn entry;\n}",
            "methodSignature: org.hibernate.orm.test.jpa.BaseEntityManagerFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn null;\n}",
            "methodSignature: org.hibernate.internal.SessionFactoryImpl#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest.TestingPersistenceUnitDescriptorImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn null;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentList#isEmpty\n methodBody: public boolean isEmpty() {\nreturn readSize() ? getCachedSize() == 0 : list.isEmpty();\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryExtension#instantiateDomainModelDescriptor\n methodBody: private static DomainModelDescriptor instantiateDomainModelDescriptor(Class<? extends DomainModelDescriptor> modelDescriptorClass) {\ntryfinal Field[] declaredFields=modelDescriptorClass.getDeclaredFields();\nfor(int i=0; i < declaredFields.length; i++){final Field field=declaredFields[i];\nif(ReflectHelper.isStaticField(field)){final Object value=field.get(null);\nif(value instanceof DomainModelDescriptor){return (DomainModelDescriptor)value;\n}}}catch(IllegalAccessException e)throw new RuntimeException(\"Problem accessing DomainModelDescriptor fields : \" + modelDescriptorClass.getName(),e);\ntryreturn modelDescriptorClass.getConstructor(null).newInstance(null);\ncatch(InstantiationException|IllegalAccessException|InvocationTargetException|NoSuchMethodException e)throw new RuntimeException(\"Problem instantiation DomainModelDescriptor : \" + modelDescriptorClass.getName(),e);\n}",
            "methodSignature: org.hibernate.testing.orm.junit.BaseSessionFactoryFunctionalTest#exportSchema\n methodBody: protected boolean exportSchema() {\nreturn true;\n}",
            "methodSignature: org.hibernate.collection.spi.AbstractPersistentCollection.ListProxy#isEmpty\n methodBody: public boolean isEmpty() {\nreturn list.isEmpty();\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentBag#toString\n methodBody: public String toString() {\nread();\nreturn bag.toString();\n}"
        ],
        "sourceCodeAfterRefactoring": "public static EntityManagerFactoryScope findEntityManagerFactoryScope(\n\t\t\tObject testScope, Optional<Jpa> optionalJpa, ExtensionContext context) {\n\n\t\tif ( optionalJpa.isEmpty() ) {\n\t\t\t// No annotation on the test class, should be on the test methods\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n\t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n\t\tif ( existing != null ) {\n\t\t\treturn existing;\n\t\t}\n\t\tif ( context.getElement().isEmpty() ) {\n\t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \"\n\t\t\t\t\t+ context.getDisplayName() );\n\t\t}\n\n\t\tfinal Jpa jpa = optionalJpa.get();\n\t\tfinal PersistenceUnitInfoImpl pui = createPersistenceUnitInfo( jpa );\n\t\tcollectProperties( pui, jpa );\n\t\tmanagedClassesAndMappings( jpa, pui );\n\t\tfinal Map<String, Object> integrationSettings = collectIntegrationSettings( jpa );\n\t\t// statement inspector\n\t\tsetupStatementInspector( jpa, integrationSettings );\n\t\tServiceRegistryUtil.applySettings( integrationSettings );\n\t\tfinal EntityManagerFactoryScopeImpl scope =\n\t\t\t\tnew EntityManagerFactoryScopeImpl( pui, integrationSettings );\n\t\tstore.put( EMF_KEY, scope );\n\t\treturn scope;\n\t}\nprivate static void setupStatementInspector(Jpa jpa, Map<String, Object> integrationSettings) {\n\t\tif ( jpa.useCollectingStatementInspector() ) {\n\t\t\tfinal String inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n\t\t\tif ( inspectorSetting != null && !inspectorSetting.isBlank() ) {\n\t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n\t\t\t}\n\t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n\t\t}\n\t}",
        "diffSourceCode": "-   61: \n-   62: \tprivate static ExtensionContext.Store locateExtensionStore(Object testScope, ExtensionContext context) {\n-   63: \t\treturn JUnitHelper.locateExtensionStore( EntityManagerFactoryExtension.class, context, testScope );\n-   64: \t}\n-   65: \n-   66: \tpublic static EntityManagerFactoryScope findEntityManagerFactoryScope(\n-   67: \t\t\tObject testScope,\n-   68: \t\t\tOptional<Jpa> emfAnnWrapper,\n-   69: \t\t\tExtensionContext context) {\n-   70: \n-   71: \t\tif ( emfAnnWrapper.isEmpty() ) {\n-   72: \t\t\t// No annotation on the test class, should be on the test methods\n-   73: \t\t\treturn null;\n-   74: \t\t}\n-   75: \n-   76: \t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n-   77: \t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n-   78: \t\tif ( existing != null ) {\n-   79: \t\t\treturn existing;\n-   80: \t\t}\n-   81: \n-   82: \t\tif ( !context.getElement().isPresent() ) {\n-   83: \t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \" + context.getDisplayName() );\n-   84: \t\t}\n-   85: \t\tfinal Jpa emfAnn = emfAnnWrapper.get();\n-   86: \n-   87: \t\tfinal PersistenceUnitInfoImpl pui = new PersistenceUnitInfoImpl( emfAnn.persistenceUnitName() );\n-   88: \t\t( (Map<Object, Object>) Environment.getProperties() ).forEach(\n-   89: \t\t\t\t(key, value) ->\n-   90: \t\t\t\t\t\tpui.getProperties().put( key, value )\n-   91: \t\t);\n+   61: \tpublic static EntityManagerFactoryScope findEntityManagerFactoryScope(\n+   62: \t\t\tObject testScope, Optional<Jpa> optionalJpa, ExtensionContext context) {\n+   63: \n+   64: \t\tif ( optionalJpa.isEmpty() ) {\n+   65: \t\t\t// No annotation on the test class, should be on the test methods\n+   66: \t\t\treturn null;\n+   67: \t\t}\n+   68: \n+   69: \t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n+   70: \t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n+   71: \t\tif ( existing != null ) {\n+   72: \t\t\treturn existing;\n+   73: \t\t}\n+   74: \t\tif ( context.getElement().isEmpty() ) {\n+   75: \t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \"\n+   76: \t\t\t\t\t+ context.getDisplayName() );\n+   77: \t\t}\n+   78: \n+   79: \t\tfinal Jpa jpa = optionalJpa.get();\n+   80: \t\tfinal PersistenceUnitInfoImpl pui = createPersistenceUnitInfo( jpa );\n+   81: \t\tcollectProperties( pui, jpa );\n+   82: \t\tmanagedClassesAndMappings( jpa, pui );\n+   83: \t\tfinal Map<String, Object> integrationSettings = collectIntegrationSettings( jpa );\n+   84: \t\t// statement inspector\n+   85: \t\tsetupStatementInspector( jpa, integrationSettings );\n+   86: \t\tServiceRegistryUtil.applySettings( integrationSettings );\n+   87: \t\tfinal EntityManagerFactoryScopeImpl scope =\n+   88: \t\t\t\tnew EntityManagerFactoryScopeImpl( pui, integrationSettings );\n+   89: \t\tstore.put( EMF_KEY, scope );\n+   90: \t\treturn scope;\n+   91: \t}\n    92: \n-   93: \t\tpui.setTransactionType( emfAnn.transactionType() );\n-   94: \t\tpui.setCacheMode( emfAnn.sharedCacheMode() );\n-   95: \t\tpui.setValidationMode( emfAnn.validationMode() );\n-   96: \t\tpui.setExcludeUnlistedClasses( emfAnn.excludeUnlistedClasses() );\n-   97: \n-   98: \t\t// JpaCompliance\n-   99: \t\tpui.getProperties().put( AvailableSettings.JPA_COMPLIANCE, emfAnn.jpaComplianceEnabled() );\n-  100: \t\tpui.getProperties().put( AvailableSettings.JPA_QUERY_COMPLIANCE, emfAnn.queryComplianceEnabled() );\n-  101: \t\tpui.getProperties().put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, emfAnn.transactionComplianceEnabled() );\n-  102: \t\tpui.getProperties().put( AvailableSettings.JPA_CLOSED_COMPLIANCE, emfAnn.closedComplianceEnabled() );\n-  103: \t\tpui.getProperties().put( AvailableSettings.JPA_PROXY_COMPLIANCE, emfAnn.proxyComplianceEnabled() );\n-  104: \t\tpui.getProperties().put( AvailableSettings.JPA_CACHING_COMPLIANCE, emfAnn.cacheComplianceEnabled() );\n-  105: \t\tpui.getProperties().put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, emfAnn.generatorScopeComplianceEnabled() );\n-  106: \t\tpui.getProperties().put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, emfAnn.orderByMappingComplianceEnabled() );\n-  107: \t\tpui.getProperties().put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, emfAnn.loadByIdComplianceEnabled() );\n-  108: \n-  109: \t\tfinal Setting[] properties = emfAnn.properties();\n-  110: \t\tfor ( int i = 0; i < properties.length; i++ ) {\n-  111: \t\t\tfinal Setting property = properties[i];\n-  112: \t\t\tpui.getProperties().setProperty( property.name(), property.value() );\n-  113: \t\t}\n-  114: \n-  115: \t\tpui.getProperties().setProperty(\n-  116: \t\t\t\tAvailableSettings.GENERATE_STATISTICS,\n-  117: \t\t\t\tBoolean.toString( emfAnn.generateStatistics() )\n-  118: \t\t);\n-  119: \n-  120: \t\tif ( emfAnn.exportSchema() ) {\n-  121: \t\t\tpui.getProperties().setProperty(\n-  122: \t\t\t\t\tAvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,\n-  123: \t\t\t\t\tAction.CREATE_DROP.getExternalHbm2ddlName()\n-  124: \t\t\t);\n-  125: \t\t}\n-  126: \n-  127: \t\tif ( emfAnn.annotatedPackageNames().length > 0 ) {\n-  128: \t\t\tpui.applyManagedClassNames( emfAnn.annotatedPackageNames() );\n-  129: \t\t}\n-  130: \n-  131: \t\tif ( emfAnn.annotatedClassNames().length > 0 ) {\n-  132: \t\t\tpui.applyManagedClassNames( emfAnn.annotatedClassNames() );\n-  133: \t\t}\n-  134: \n-  135: \t\tif ( emfAnn.annotatedClasses().length > 0 ) {\n-  136: \t\t\tfor ( int i = 0; i < emfAnn.annotatedClasses().length; i++ ) {\n-  137: \t\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClasses()[i].getName() );\n-  138: \t\t\t}\n-  139: \t\t}\n-  140: \n-  141: \t\tif ( emfAnn.xmlMappings().length > 0 ) {\n-  142: \t\t\tpui.applyMappingFiles( emfAnn.xmlMappings() );\n-  143: \t\t}\n-  144: \n-  145: \t\tif ( emfAnn.standardModels().length > 0 ) {\n-  146: \t\t\tfor ( int i = 0; i < emfAnn.standardModels().length; i++ ) {\n-  147: \t\t\t\tfinal StandardDomainModel standardDomainModel = emfAnn.standardModels()[i];\n-  148: \t\t\t\tfor ( int i1 = 0; i1 < standardDomainModel.getDescriptor().getAnnotatedClasses().length; i1++ ) {\n-  149: \t\t\t\t\tfinal Class<?> annotatedClass = standardDomainModel.getDescriptor().getAnnotatedClasses()[i1];\n-  150: \t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n-  151: \t\t\t\t}\n-  152: \t\t\t}\n-  153: \t\t}\n-  154: \n-  155: \t\tif ( emfAnn.modelDescriptorClasses().length > 0 ) {\n-  156: \t\t\tfor ( int i = 0; i < emfAnn.modelDescriptorClasses().length; i++ ) {\n-  157: \t\t\t\tfinal Class<? extends DomainModelDescriptor> modelDescriptorClass = emfAnn.modelDescriptorClasses()[i];\n-  158: \t\t\t\tfinal DomainModelDescriptor domainModelDescriptor = instantiateDomainModelDescriptor(\n-  159: \t\t\t\t\t\tmodelDescriptorClass );\n-  160: \t\t\t\tfor ( int i1 = 0; i1 < domainModelDescriptor.getAnnotatedClasses().length; i1++ ) {\n-  161: \t\t\t\t\tfinal Class<?> annotatedClass = domainModelDescriptor.getAnnotatedClasses()[i1];\n-  162: \t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n-  163: \t\t\t\t}\n-  164: \t\t\t}\n-  165: \t\t}\n-  166: \n-  167: \t\tfinal Map<String, Object> integrationSettings = new HashMap<>();\n-  168: \n-  169: \t\tintegrationSettings.put( PersistentTableStrategy.DROP_ID_TABLES, \"true\" );\n-  170: \t\tintegrationSettings.put( GlobalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n-  171: \t\tintegrationSettings.put( LocalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n-  172: \t\tfor ( int i = 0; i < emfAnn.integrationSettings().length; i++ ) {\n-  173: \t\t\tfinal Setting setting = emfAnn.integrationSettings()[i];\n-  174: \t\t\tintegrationSettings.put( setting.name(), setting.value() );\n-  175: \t\t}\n-  176: \n-  177: \t\tfor ( SettingProvider providerAnn : emfAnn.settingProviders() ) {\n-  178: \t\t\tfinal Class<? extends SettingProvider.Provider<?>> providerImpl = providerAnn.provider();\n-  179: \t\t\ttry {\n-  180: \t\t\t\tfinal SettingProvider.Provider<?> provider = providerImpl.getConstructor().newInstance();\n-  181: \t\t\t\tintegrationSettings.put( providerAnn.settingName(), provider.getSetting() );\n-  182: \t\t\t}\n-  183: \t\t\tcatch (Exception e) {\n-  184: \t\t\t\tlog.error( \"Error obtaining setting provider for \" + providerImpl.getName(), e );\n-  185: \t\t\t}\n-  186: \t\t}\n-  187: \n-  188: \t\t// statement inspector\n-  189: \t\tif ( emfAnn.useCollectingStatementInspector() ) {\n-  190: \t\t\tString inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n-  191: \t\t\tif ( !(inspectorSetting == null || inspectorSetting.isBlank()) ) {\n-  192: \t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n-  193: \t\t\t}\n-  194: \t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n-  195: \t\t}\n-  196: \n-  197: \t\tServiceRegistryUtil.applySettings( integrationSettings );\n-  198: \t\tfinal EntityManagerFactoryScopeImpl scope = new EntityManagerFactoryScopeImpl( pui, integrationSettings );\n-  199: \n-  200: \t\tstore.put( EMF_KEY, scope );\n-  201: \n-  202: \t\treturn scope;\n-  203: \t}\n+   93: \tprivate static void collectProperties(PersistenceUnitInfoImpl pui, Jpa jpa) {\n+   94: \t\tfinal Properties properties = pui.getProperties();\n+   95: \t\tproperties.putAll( Environment.getProperties() );\n+   96: \t\t// JpaCompliance\n+   97: \t\tsetJpaComplianceProperties( properties, jpa );\n+   98: \t\tfor ( Setting property : jpa.properties() ) {\n+   99: \t\t\tproperties.setProperty( property.name(), property.value() );\n+  100: \t\t}\n+  101: \t\tproperties.setProperty(\n+  102: \t\t\t\tAvailableSettings.GENERATE_STATISTICS,\n+  103: \t\t\t\tBoolean.toString( jpa.generateStatistics() )\n+  104: \t\t);\n+  105: \t\tif ( jpa.exportSchema() ) {\n+  106: \t\t\tproperties.setProperty(\n+  107: \t\t\t\t\tAvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,\n+  108: \t\t\t\t\tAction.CREATE_DROP.getExternalHbm2ddlName()\n+  109: \t\t\t);\n+  110: \t\t}\n+  111: \t}\n+  112: \n+  113: \tprivate static PersistenceUnitInfoImpl createPersistenceUnitInfo(Jpa jpa) {\n+  114: \t\tfinal PersistenceUnitInfoImpl pui =\n+  115: \t\t\t\tnew PersistenceUnitInfoImpl( jpa.persistenceUnitName() );\n+  116: \t\tpui.setTransactionType( jpa.transactionType() );\n+  117: \t\tpui.setCacheMode( jpa.sharedCacheMode() );\n+  118: \t\tpui.setValidationMode( jpa.validationMode() );\n+  119: \t\tpui.setExcludeUnlistedClasses( jpa.excludeUnlistedClasses() );\n+  120: \t\treturn pui;\n+  121: \t}\n+  122: \n+  123: \tprivate static void managedClassesAndMappings(Jpa jpa, PersistenceUnitInfoImpl pui) {\n+  124: \t\tif ( jpa.annotatedPackageNames().length > 0 ) {\n+  125: \t\t\tpui.applyManagedClassNames( jpa.annotatedPackageNames() );\n+  126: \t\t}\n+  127: \n+  128: \t\tif ( jpa.annotatedClassNames().length > 0 ) {\n+  129: \t\t\tpui.applyManagedClassNames( jpa.annotatedClassNames() );\n+  130: \t\t}\n+  131: \n+  132: \t\tif ( jpa.annotatedClasses().length > 0 ) {\n+  133: \t\t\tfor (int i = 0; i < jpa.annotatedClasses().length; i++ ) {\n+  134: \t\t\t\tpui.applyManagedClassNames( jpa.annotatedClasses()[i].getName() );\n+  135: \t\t\t}\n+  136: \t\t}\n+  137: \n+  138: \t\tif ( jpa.xmlMappings().length > 0 ) {\n+  139: \t\t\tpui.applyMappingFiles( jpa.xmlMappings() );\n+  140: \t\t}\n+  141: \n+  142: \t\tfor ( StandardDomainModel standardDomainModel : jpa.standardModels() ) {\n+  143: \t\t\tfor ( Class<?> annotatedClass : standardDomainModel.getDescriptor().getAnnotatedClasses() ) {\n+  144: \t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n+  145: \t\t\t}\n+  146: \t\t}\n+  147: \n+  148: \t\tfor ( Class<? extends DomainModelDescriptor> modelDescriptorClass :\n+  149: \t\t\t\tjpa.modelDescriptorClasses() ) {\n+  150: \t\t\tfinal DomainModelDescriptor domainModelDescriptor =\n+  151: \t\t\t\t\tinstantiateDomainModelDescriptor( modelDescriptorClass );\n+  152: \t\t\tfinal Class<?>[] annotatedClasses = domainModelDescriptor.getAnnotatedClasses();\n+  153: \t\t\tfor ( Class<?> annotatedClass : annotatedClasses ) {\n+  154: \t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n+  155: \t\t\t}\n+  156: \t\t}\n+  157: \t}\n+  158: \n+  159: \tprivate static Map<String, Object> collectIntegrationSettings(Jpa jpa) {\n+  160: \t\tfinal Map<String, Object> integrationSettings = new HashMap<>();\n+  161: \t\tintegrationSettings.put( PersistentTableStrategy.DROP_ID_TABLES, \"true\" );\n+  162: \t\tintegrationSettings.put( GlobalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n+  163: \t\tintegrationSettings.put( LocalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n+  164: \t\tfinal Setting[] settings = jpa.integrationSettings();\n+  165: \t\tfor ( Setting setting : settings ) {\n+  166: \t\t\tintegrationSettings.put( setting.name(), setting.value() );\n+  167: \t\t}\n+  168: \t\tfor ( SettingProvider providerAnn : jpa.settingProviders() ) {\n+  169: \t\t\tfinal Class<? extends SettingProvider.Provider<?>> providerImpl = providerAnn.provider();\n+  170: \t\t\ttry {\n+  171: \t\t\t\tintegrationSettings.put( providerAnn.settingName(),\n+  172: \t\t\t\t\t\tproviderImpl.getConstructor().newInstance().getSetting() );\n+  173: \t\t\t}\n+  174: \t\t\tcatch (Exception e) {\n+  175: \t\t\t\tlog.error( \"Error obtaining setting provider for \" + providerImpl.getName(), e );\n+  176: \t\t\t}\n+  177: \t\t}\n+  178: \t\treturn integrationSettings;\n+  179: \t}\n+  180: \n+  181: \tprivate static void setupStatementInspector(Jpa jpa, Map<String, Object> integrationSettings) {\n+  182: \t\tif ( jpa.useCollectingStatementInspector() ) {\n+  183: \t\t\tfinal String inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n+  184: \t\t\tif ( inspectorSetting != null && !inspectorSetting.isBlank() ) {\n+  185: \t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n+  186: \t\t\t}\n+  187: \t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n+  188: \t\t}\n+  189: \t}\n+  190: \n+  191: \tprivate static void setJpaComplianceProperties(Properties properties, Jpa jpa) {\n+  192: \t\tproperties.put( AvailableSettings.JPA_COMPLIANCE, jpa.jpaComplianceEnabled() );\n+  193: \t\tproperties.put( AvailableSettings.JPA_QUERY_COMPLIANCE, jpa.queryComplianceEnabled() );\n+  194: \t\tproperties.put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, jpa.transactionComplianceEnabled() );\n+  195: \t\tproperties.put( AvailableSettings.JPA_CLOSED_COMPLIANCE, jpa.closedComplianceEnabled() );\n+  196: \t\tproperties.put( AvailableSettings.JPA_PROXY_COMPLIANCE, jpa.proxyComplianceEnabled() );\n+  197: \t\tproperties.put( AvailableSettings.JPA_CACHING_COMPLIANCE, jpa.cacheComplianceEnabled() );\n+  198: \t\tproperties.put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, jpa.generatorScopeComplianceEnabled() );\n+  199: \t\tproperties.put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, jpa.orderByMappingComplianceEnabled() );\n+  200: \t\tproperties.put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, jpa.loadByIdComplianceEnabled() );\n+  201: \t}\n+  202: \n+  203: \tprivate static DomainModelDescriptor instantiateDomainModelDescriptor(\n",
        "uniqueId": "4781c09d0df0eb4ce05b2fa0d2a12747023ae024_66_203_181_189_61_91",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 186,
                "covered": 250
            },
            "BRANCH": {
                "missed": 24,
                "covered": 18
            },
            "LINE": {
                "missed": 29,
                "covered": 49
            },
            "COMPLEXITY": {
                "missed": 18,
                "covered": 4
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\nprivate static ExtensionContext.Store locateExtensionStore(Object testScope, ExtensionContext context) {\n    return JUnitHelper.locateExtensionStore(EntityManagerFactoryExtension.class, context, testScope);\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\npublic static EntityManagerFactoryScope findEntityManagerFactoryScope(\n\t\t\tObject testScope,\n\t\t\tOptional<Jpa> emfAnnWrapper,\n\t\t\tExtensionContext context) {\n\n\t\tif ( emfAnnWrapper.isEmpty() ) {\n\t\t\t// No annotation on the test class, should be on the test methods\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n\t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n\t\tif ( existing != null ) {\n\t\t\treturn existing;\n\t\t}\n\n\t\tif ( !context.getElement().isPresent() ) {\n\t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \" + context.getDisplayName() );\n\t\t}\n\t\tfinal Jpa emfAnn = emfAnnWrapper.get();\n\n\t\tfinal PersistenceUnitInfoImpl pui = new PersistenceUnitInfoImpl( emfAnn.persistenceUnitName() );\n\t\t( (Map<Object, Object>) Environment.getProperties() ).forEach(\n\t\t\t\t(key, value) ->\n\t\t\t\t\t\tpui.getProperties().put( key, value )\n\t\t);\n\n\t\tpui.setTransactionType( emfAnn.transactionType() );\n\t\tpui.setCacheMode( emfAnn.sharedCacheMode() );\n\t\tpui.setValidationMode( emfAnn.validationMode() );\n\t\tpui.setExcludeUnlistedClasses( emfAnn.excludeUnlistedClasses() );\n\n\t\t// JpaCompliance\n\t\tpui.getProperties().put( AvailableSettings.JPA_COMPLIANCE, emfAnn.jpaComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_QUERY_COMPLIANCE, emfAnn.queryComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, emfAnn.transactionComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_CLOSED_COMPLIANCE, emfAnn.closedComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_PROXY_COMPLIANCE, emfAnn.proxyComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_CACHING_COMPLIANCE, emfAnn.cacheComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, emfAnn.generatorScopeComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, emfAnn.orderByMappingComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, emfAnn.loadByIdComplianceEnabled() );\n\n\t\tfinal Setting[] properties = emfAnn.properties();\n\t\tfor ( int i = 0; i < properties.length; i++ ) {\n\t\t\tfinal Setting property = properties[i];\n\t\t\tpui.getProperties().setProperty( property.name(), property.value() );\n\t\t}\n\n\t\tpui.getProperties().setProperty(\n\t\t\t\tAvailableSettings.GENERATE_STATISTICS,\n\t\t\t\tBoolean.toString( emfAnn.generateStatistics() )\n\t\t);\n\n\t\tif ( emfAnn.exportSchema() ) {\n\t\t\tpui.getProperties().setProperty(\n\t\t\t\t\tAvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,\n\t\t\t\t\tAction.CREATE_DROP.getExternalHbm2ddlName()\n\t\t\t);\n\t\t}\n\n\t\tif ( emfAnn.annotatedPackageNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( emfAnn.annotatedPackageNames() );\n\t\t}\n\n\t\tif ( emfAnn.annotatedClassNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClassNames() );\n\t\t}\n\n\t\tif ( emfAnn.annotatedClasses().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.annotatedClasses().length; i++ ) {\n\t\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClasses()[i].getName() );\n\t\t\t}\n\t\t}\n\n\t\tif ( emfAnn.xmlMappings().length > 0 ) {\n\t\t\tpui.applyMappingFiles( emfAnn.xmlMappings() );\n\t\t}\n\n\t\tif ( emfAnn.standardModels().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.standardModels().length; i++ ) {\n\t\t\t\tfinal StandardDomainModel standardDomainModel = emfAnn.standardModels()[i];\n\t\t\t\tfor ( int i1 = 0; i1 < standardDomainModel.getDescriptor().getAnnotatedClasses().length; i1++ ) {\n\t\t\t\t\tfinal Class<?> annotatedClass = standardDomainModel.getDescriptor().getAnnotatedClasses()[i1];\n\t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( emfAnn.modelDescriptorClasses().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.modelDescriptorClasses().length; i++ ) {\n\t\t\t\tfinal Class<? extends DomainModelDescriptor> modelDescriptorClass = emfAnn.modelDescriptorClasses()[i];\n\t\t\t\tfinal DomainModelDescriptor domainModelDescriptor = instantiateDomainModelDescriptor(\n\t\t\t\t\t\tmodelDescriptorClass );\n\t\t\t\tfor ( int i1 = 0; i1 < domainModelDescriptor.getAnnotatedClasses().length; i1++ ) {\n\t\t\t\t\tfinal Class<?> annotatedClass = domainModelDescriptor.getAnnotatedClasses()[i1];\n\t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfinal Map<String, Object> integrationSettings = new HashMap<>();\n\n\t\tintegrationSettings.put( PersistentTableStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( GlobalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( LocalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tfor ( int i = 0; i < emfAnn.integrationSettings().length; i++ ) {\n\t\t\tfinal Setting setting = emfAnn.integrationSettings()[i];\n\t\t\tintegrationSettings.put( setting.name(), setting.value() );\n\t\t}\n\n\t\tfor ( SettingProvider providerAnn : emfAnn.settingProviders() ) {\n\t\t\tfinal Class<? extends SettingProvider.Provider<?>> providerImpl = providerAnn.provider();\n\t\t\ttry {\n\t\t\t\tfinal SettingProvider.Provider<?> provider = providerImpl.getConstructor().newInstance();\n\t\t\t\tintegrationSettings.put( providerAnn.settingName(), provider.getSetting() );\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tlog.error( \"Error obtaining setting provider for \" + providerImpl.getName(), e );\n\t\t\t}\n\t\t}\n\n\t\t// statement inspector\n\t\tif ( emfAnn.useCollectingStatementInspector() ) {\n\t\t\tString inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n\t\t\tif ( !(inspectorSetting == null || inspectorSetting.isBlank()) ) {\n\t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n\t\t\t}\n\t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n\t\t}\n\n\t\tServiceRegistryUtil.applySettings( integrationSettings );\n\t\tfinal EntityManagerFactoryScopeImpl scope = new EntityManagerFactoryScopeImpl( pui, integrationSettings );\n\n\t\tstore.put( EMF_KEY, scope );\n\n\t\treturn scope;\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.testing.orm.junit;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport jakarta.persistence.spi.PersistenceUnitInfo;\n\nimport org.hibernate.SessionFactoryObserver;\nimport org.hibernate.boot.registry.StandardServiceRegistry;\nimport org.hibernate.boot.spi.MetadataImplementor;\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.cfg.Environment;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.internal.util.ReflectHelper;\nimport org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor;\nimport org.hibernate.jpa.boot.spi.Bootstrap;\nimport org.hibernate.jpa.boot.spi.EntityManagerFactoryBuilder;\nimport org.hibernate.query.sqm.mutation.internal.temptable.GlobalTemporaryTableMutationStrategy;\nimport org.hibernate.query.sqm.mutation.internal.temptable.LocalTemporaryTableMutationStrategy;\nimport org.hibernate.query.sqm.mutation.internal.temptable.PersistentTableStrategy;\nimport org.hibernate.tool.schema.Action;\nimport org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator;\nimport org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator.ActionGrouping;\n\nimport org.hibernate.testing.jdbc.SQLStatementInspector;\nimport org.hibernate.testing.orm.domain.DomainModelDescriptor;\nimport org.hibernate.testing.orm.domain.StandardDomainModel;\nimport org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl;\nimport org.hibernate.testing.util.ServiceRegistryUtil;\nimport org.junit.jupiter.api.extension.BeforeEachCallback;\nimport org.junit.jupiter.api.extension.ExtensionContext;\nimport org.junit.jupiter.api.extension.TestExecutionExceptionHandler;\nimport org.junit.jupiter.api.extension.TestInstancePostProcessor;\nimport org.junit.platform.commons.support.AnnotationSupport;\n\nimport org.jboss.logging.Logger;\n\n/**\n * hibernate-testing implementation of a few JUnit5 contracts to support SessionFactory-based testing,\n * including argument injection (or see {@link SessionFactoryScopeAware})\n *\n * @author Steve Ebersole\n *\n * @see DomainModelExtension\n * @see SessionFactoryExtension\n */\npublic class EntityManagerFactoryExtension\n\t\timplements TestInstancePostProcessor, BeforeEachCallback, TestExecutionExceptionHandler {\n\n\tprivate static final Logger log = Logger.getLogger( EntityManagerFactoryExtension.class );\n\tprivate static final String EMF_KEY = EntityManagerFactoryScope.class.getName();\n\n\tprivate static ExtensionContext.Store locateExtensionStore(Object testScope, ExtensionContext context) {\n\t\treturn JUnitHelper.locateExtensionStore( EntityManagerFactoryExtension.class, context, testScope );\n\t}\n\n\tpublic static EntityManagerFactoryScope findEntityManagerFactoryScope(\n\t\t\tObject testScope,\n\t\t\tOptional<Jpa> emfAnnWrapper,\n\t\t\tExtensionContext context) {\n\n\t\tif ( emfAnnWrapper.isEmpty() ) {\n\t\t\t// No annotation on the test class, should be on the test methods\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n\t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n\t\tif ( existing != null ) {\n\t\t\treturn existing;\n\t\t}\n\n\t\tif ( !context.getElement().isPresent() ) {\n\t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \" + context.getDisplayName() );\n\t\t}\n\t\tfinal Jpa emfAnn = emfAnnWrapper.get();\n\n\t\tfinal PersistenceUnitInfoImpl pui = new PersistenceUnitInfoImpl( emfAnn.persistenceUnitName() );\n\t\t( (Map<Object, Object>) Environment.getProperties() ).forEach(\n\t\t\t\t(key, value) ->\n\t\t\t\t\t\tpui.getProperties().put( key, value )\n\t\t);\n\n\t\tpui.setTransactionType( emfAnn.transactionType() );\n\t\tpui.setCacheMode( emfAnn.sharedCacheMode() );\n\t\tpui.setValidationMode( emfAnn.validationMode() );\n\t\tpui.setExcludeUnlistedClasses( emfAnn.excludeUnlistedClasses() );\n\n\t\t// JpaCompliance\n\t\tpui.getProperties().put( AvailableSettings.JPA_COMPLIANCE, emfAnn.jpaComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_QUERY_COMPLIANCE, emfAnn.queryComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, emfAnn.transactionComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_CLOSED_COMPLIANCE, emfAnn.closedComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_PROXY_COMPLIANCE, emfAnn.proxyComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_CACHING_COMPLIANCE, emfAnn.cacheComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, emfAnn.generatorScopeComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, emfAnn.orderByMappingComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, emfAnn.loadByIdComplianceEnabled() );\n\n\t\tfinal Setting[] properties = emfAnn.properties();\n\t\tfor ( int i = 0; i < properties.length; i++ ) {\n\t\t\tfinal Setting property = properties[i];\n\t\t\tpui.getProperties().setProperty( property.name(), property.value() );\n\t\t}\n\n\t\tpui.getProperties().setProperty(\n\t\t\t\tAvailableSettings.GENERATE_STATISTICS,\n\t\t\t\tBoolean.toString( emfAnn.generateStatistics() )\n\t\t);\n\n\t\tif ( emfAnn.exportSchema() ) {\n\t\t\tpui.getProperties().setProperty(\n\t\t\t\t\tAvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,\n\t\t\t\t\tAction.CREATE_DROP.getExternalHbm2ddlName()\n\t\t\t);\n\t\t}\n\n\t\tif ( emfAnn.annotatedPackageNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( emfAnn.annotatedPackageNames() );\n\t\t}\n\n\t\tif ( emfAnn.annotatedClassNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClassNames() );\n\t\t}\n\n\t\tif ( emfAnn.annotatedClasses().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.annotatedClasses().length; i++ ) {\n\t\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClasses()[i].getName() );\n\t\t\t}\n\t\t}\n\n\t\tif ( emfAnn.xmlMappings().length > 0 ) {\n\t\t\tpui.applyMappingFiles( emfAnn.xmlMappings() );\n\t\t}\n\n\t\tif ( emfAnn.standardModels().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.standardModels().length; i++ ) {\n\t\t\t\tfinal StandardDomainModel standardDomainModel = emfAnn.standardModels()[i];\n\t\t\t\tfor ( int i1 = 0; i1 < standardDomainModel.getDescriptor().getAnnotatedClasses().length; i1++ ) {\n\t\t\t\t\tfinal Class<?> annotatedClass = standardDomainModel.getDescriptor().getAnnotatedClasses()[i1];\n\t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( emfAnn.modelDescriptorClasses().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.modelDescriptorClasses().length; i++ ) {\n\t\t\t\tfinal Class<? extends DomainModelDescriptor> modelDescriptorClass = emfAnn.modelDescriptorClasses()[i];\n\t\t\t\tfinal DomainModelDescriptor domainModelDescriptor = instantiateDomainModelDescriptor(\n\t\t\t\t\t\tmodelDescriptorClass );\n\t\t\t\tfor ( int i1 = 0; i1 < domainModelDescriptor.getAnnotatedClasses().length; i1++ ) {\n\t\t\t\t\tfinal Class<?> annotatedClass = domainModelDescriptor.getAnnotatedClasses()[i1];\n\t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfinal Map<String, Object> integrationSettings = new HashMap<>();\n\n\t\tintegrationSettings.put( PersistentTableStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( GlobalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( LocalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tfor ( int i = 0; i < emfAnn.integrationSettings().length; i++ ) {\n\t\t\tfinal Setting setting = emfAnn.integrationSettings()[i];\n\t\t\tintegrationSettings.put( setting.name(), setting.value() );\n\t\t}\n\n\t\tfor ( SettingProvider providerAnn : emfAnn.settingProviders() ) {\n\t\t\tfinal Class<? extends SettingProvider.Provider<?>> providerImpl = providerAnn.provider();\n\t\t\ttry {\n\t\t\t\tfinal SettingProvider.Provider<?> provider = providerImpl.getConstructor().newInstance();\n\t\t\t\tintegrationSettings.put( providerAnn.settingName(), provider.getSetting() );\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tlog.error( \"Error obtaining setting provider for \" + providerImpl.getName(), e );\n\t\t\t}\n\t\t}\n\n\t\t// statement inspector\n\t\tif ( emfAnn.useCollectingStatementInspector() ) {\n\t\t\tString inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n\t\t\tif ( !(inspectorSetting == null || inspectorSetting.isBlank()) ) {\n\t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n\t\t\t}\n\t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n\t\t}\n\n\t\tServiceRegistryUtil.applySettings( integrationSettings );\n\t\tfinal EntityManagerFactoryScopeImpl scope = new EntityManagerFactoryScopeImpl( pui, integrationSettings );\n\n\t\tstore.put( EMF_KEY, scope );\n\n\t\treturn scope;\n\t}\n\n\tprivate static DomainModelDescriptor instantiateDomainModelDescriptor(Class<? extends DomainModelDescriptor> modelDescriptorClass) {\n\t\t// first, see if it has a static singleton reference and use that if so\n\t\ttry {\n\t\t\tfinal Field[] declaredFields = modelDescriptorClass.getDeclaredFields();\n\t\t\tfor ( int i = 0; i < declaredFields.length; i++ ) {\n\t\t\t\tfinal Field field = declaredFields[i];\n\t\t\t\tif ( ReflectHelper.isStaticField( field ) ) {\n\t\t\t\t\tfinal Object value = field.get( null );\n\t\t\t\t\tif ( value instanceof DomainModelDescriptor ) {\n\t\t\t\t\t\treturn (DomainModelDescriptor) value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalAccessException e) {\n\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\"Problem accessing DomainModelDescriptor fields : \" + modelDescriptorClass.getName(),\n\t\t\t\t\te\n\t\t\t);\n\t\t}\n\n\t\t// no singleton field, try to instantiate it via reflection\n\t\ttry {\n\t\t\treturn modelDescriptorClass.getConstructor( null ).newInstance( null );\n\t\t}\n\t\tcatch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {\n\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\"Problem instantiation DomainModelDescriptor : \" + modelDescriptorClass.getName(),\n\t\t\t\t\te\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate static void prepareSchemaExport(\n\t\t\tSessionFactoryImplementor sessionFactory,\n\t\t\tMetadataImplementor model) {\n\t\tfinal Map<String, Object> baseProperties = sessionFactory.getProperties();\n\n\t\tfinal Set<ActionGrouping> groupings = ActionGrouping.interpret( model, baseProperties );\n\t\tif ( !groupings.isEmpty() ) {\n\t\t\t// the properties contained explicit settings for auto schema tooling - skip the annotation\n\t\t\treturn;\n\t\t}\n\n\t\tfinal HashMap<String,Object> settings = new HashMap<>( baseProperties );\n\t\tsettings.put( AvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION, Action.CREATE_DROP );\n\n\t\tfinal StandardServiceRegistry serviceRegistry = model.getMetadataBuildingOptions().getServiceRegistry();\n\n\n\t\tSchemaManagementToolCoordinator.process(\n\t\t\t\tmodel,\n\t\t\t\tserviceRegistry,\n\t\t\t\tsettings,\n\t\t\t\taction -> sessionFactory.addObserver(\n\t\t\t\t\t\tnew SessionFactoryObserver() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void sessionFactoryClosing(org.hibernate.SessionFactory factory) {\n\t\t\t\t\t\t\t\taction.perform( serviceRegistry );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t)\n\t\t);\n\t}\n\n\t@Override\n\tpublic void beforeEach(ExtensionContext context) {\n\t\tlog.tracef( \"#beforeEach(%s)\", context.getDisplayName() );\n\t\tfinal Optional<Jpa> emfAnnWrapper = AnnotationSupport.findAnnotation(\n\t\t\t\tcontext.getRequiredTestMethod(),\n\t\t\t\tJpa.class\n\t\t);\n\n\t\tif ( emfAnnWrapper.isEmpty() ) {\n\t\t\t// assume the annotation is defined on the class-level...\n\t\t\treturn;\n\t\t}\n\n\t\tfindEntityManagerFactoryScope( context.getRequiredTestMethod(), emfAnnWrapper, context );\n\t}\n\n\t@Override\n\tpublic void postProcessTestInstance(Object testInstance, ExtensionContext context) {\n\t\tlog.tracef( \"#postProcessTestInstance(%s, %s)\", testInstance, context.getDisplayName() );\n\n\t\tfinal Optional<Jpa> emfAnnWrapper = AnnotationSupport.findAnnotation(\n\t\t\t\tcontext.getRequiredTestClass(),\n\t\t\t\tJpa.class\n\t\t);\n\n\t\tfindEntityManagerFactoryScope( testInstance, emfAnnWrapper, context );\n\t}\n\n\t@Override\n\tpublic void handleTestExecutionException(ExtensionContext context, Throwable throwable) throws Throwable {\n\t\tlog.tracef( \"#handleTestExecutionException(%s, %s)\", context.getDisplayName(), throwable );\n\n\t\ttry {\n\t\t\tfinal Object testInstance = context.getRequiredTestInstance();\n\t\t\tfinal ExtensionContext.Store store = locateExtensionStore( testInstance, context );\n\t\t\tfinal EntityManagerFactoryScopeImpl scope = (EntityManagerFactoryScopeImpl) store.get( EMF_KEY );\n\t\t\tscope.releaseEntityManagerFactory();\n\t\t}\n\t\tcatch (Exception ignore) {\n\t\t}\n\n\t\tthrow throwable;\n\t}\n\n\tprivate static class EntityManagerFactoryScopeImpl extends AbstractEntityManagerFactoryScope {\n\t\tprivate final PersistenceUnitInfo persistenceUnitInfo;\n\t\tprivate final Map<String, Object> integrationSettings;\n\n\t\tprivate EntityManagerFactoryScopeImpl(\n\t\t\t\tPersistenceUnitInfo persistenceUnitInfo,\n\t\t\t\tMap<String, Object> integrationSettings) {\n\t\t\tthis.persistenceUnitInfo = persistenceUnitInfo;\n\t\t\tthis.integrationSettings = integrationSettings;\n\t\t}\n\n\t\tprotected jakarta.persistence.EntityManagerFactory createEntityManagerFactory() {\n\t\t\tfinal EntityManagerFactoryBuilder emfBuilder = Bootstrap.getEntityManagerFactoryBuilder(\n\t\t\t\t\tnew PersistenceUnitInfoDescriptor( persistenceUnitInfo ),\n\t\t\t\t\tintegrationSettings\n\t\t\t);\n\n\t\t\treturn emfBuilder.build();\n\t\t}\n\t}\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate isLegalFirstChar(first char) : boolean extracted from public toIdentifier(text String, quote boolean, quoteOnNonIdentifierChar boolean) : Identifier in class org.hibernate.boot.model.naming.Identifier",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/boot/model/naming/Identifier.java",
                "startLine": 67,
                "endLine": 123,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/boot/model/naming/Identifier.java",
                "startLine": 112,
                "endLine": 126,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/boot/model/naming/Identifier.java",
                "startLine": 136,
                "endLine": 140,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n\t * Means to generate an {@link Identifier} instance from its simple text form.\n\t * <p>\n\t * If passed text is {@code null}, {@code null} is returned.\n\t * <p>\n\t * If passed text is surrounded in quote markers, the generated Identifier\n\t * is considered quoted.  Quote markers include back-ticks (`),\n\t * double-quotes (\") and brackets ([ and ]).\n\t *\n\t * @param text The text form\n\t * @param quote Whether to quote unquoted text forms\n\t * @param quoteOnNonIdentifierChar Controls whether to treat the result as quoted if text contains characters that are invalid for identifiers\n\t *\n\t * @return The identifier form, or {@code null} if text was {@code null}\n\t */\n\tpublic static Identifier toIdentifier(String text, boolean quote, boolean quoteOnNonIdentifierChar) {\n\t\tif ( isBlank( text ) ) {\n\t\t\treturn null;\n\t\t}\n\t\tint start = 0;\n\t\tint end = text.length();\n\t\twhile ( start < end ) {\n\t\t\tif ( !isWhitespace( text.charAt( start ) ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstart++;\n\t\t}\n\t\twhile ( start < end ) {\n\t\t\tif ( !isWhitespace( text.charAt( end - 1 ) ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tend--;\n\t\t}\n\t\tif ( isQuoted( text, start, end ) ) {\n\t\t\tstart++;\n\t\t\tend--;\n\t\t\tquote = true;\n\t\t}\n\t\telse if ( quoteOnNonIdentifierChar && !quote ) {\n\t\t\t// Check the letters to determine if we must quote the text\n\t\t\tchar c = text.charAt( start );\n\t\t\tif ( !isLetter( c ) && c != '_' ) {\n\t\t\t\t// SQL identifiers must begin with a letter or underscore\n\t\t\t\tquote = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor ( int i = start + 1; i < end; i++ ) {\n\t\t\t\t\tc = text.charAt( i );\n\t\t\t\t\tif ( !isLetterOrDigit( c ) && c != '_' ) {\n\t\t\t\t\t\tquote = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new Identifier( text.substring( start, end ), quote );\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/boot/model/naming/Identifier.java",
        "isPureRefactoring": true,
        "commitId": "e14ead0c0f0916cc8fdb8895e2cc481754a75583",
        "packageNameBefore": "org.hibernate.boot.model.naming",
        "classNameBefore": "org.hibernate.boot.model.naming.Identifier",
        "methodNameBefore": "org.hibernate.boot.model.naming.Identifier#toIdentifier",
        "invokedMethod": "methodSignature: org.hibernate.boot.model.naming.Identifier#isQuoted\n methodBody: public boolean isQuoted() {\nreturn isQuoted;\n}",
        "classSignatureBefore": "public class Identifier implements Comparable<Identifier> ",
        "methodNameBeforeSet": [
            "org.hibernate.boot.model.naming.Identifier#toIdentifier"
        ],
        "classNameBeforeSet": [
            "org.hibernate.boot.model.naming.Identifier"
        ],
        "classSignatureBeforeSet": [
            "public class Identifier implements Comparable<Identifier> "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Overlapped refactoring - can be identical by undoing the overlapped refactoring\n- Inline Variable-",
                "description": "Inline Variable on top of the extracted method - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.boot.model.naming;\n\nimport java.util.Locale;\n\nimport org.hibernate.dialect.Dialect;\n\nimport static java.lang.Character.isLetter;\nimport static java.lang.Character.isLetterOrDigit;\nimport static java.lang.Character.isWhitespace;\nimport static org.hibernate.internal.util.StringHelper.isBlank;\nimport static org.hibernate.internal.util.StringHelper.isEmpty;\n\n/**\n * Models an identifier (name), which may or may not be quoted.\n *\n * @author Steve Ebersole\n */\npublic class Identifier implements Comparable<Identifier> {\n\tprivate final String text;\n\tprivate final boolean isQuoted;\n\n\t/**\n\t * Means to generate an {@link Identifier} instance from its simple text form.\n\t * <p>\n\t * If passed text is {@code null}, {@code null} is returned.\n\t * <p>\n\t * If passed text is surrounded in quote markers, the generated Identifier\n\t * is considered quoted.  Quote markers include back-ticks (`),\n\t * double-quotes (\") and brackets ([ and ]).\n\t *\n\t * If the text, after trimming, contains a character that is not a valid identifier character,\n\t * the identifier is treated as quoted.\n\t *\n\t * @param text The text form\n\t *\n\t * @return The identifier form, or {@code null} if text was {@code null}\n\t */\n\tpublic static Identifier toIdentifier(String text) {\n\t\treturn toIdentifier( text, false );\n\t}\n\n\t/**\n\t * Means to generate an {@link Identifier} instance from its simple text form.\n\t * <p>\n\t * If passed text is {@code null}, {@code null} is returned.\n\t * <p>\n\t * If passed text is surrounded in quote markers, the generated Identifier\n\t * is considered quoted.  Quote markers include back-ticks (`),\n\t * double-quotes (\") and brackets ([ and ]).\n\t *\n\t * If the text, after trimming, contains a character that is not a valid identifier character,\n\t * the identifier is treated as quoted.\n\t *\n\t * @param text The text form\n\t * @param quote Whether to quote unquoted text forms\n\t *\n\t * @return The identifier form, or {@code null} if text was {@code null}\n\t */\n\tpublic static Identifier toIdentifier(String text, boolean quote) {\n\t\treturn toIdentifier( text, quote, true );\n\t}\n\n\t/**\n\t * Means to generate an {@link Identifier} instance from its simple text form.\n\t * <p>\n\t * If passed text is {@code null}, {@code null} is returned.\n\t * <p>\n\t * If passed text is surrounded in quote markers, the generated Identifier\n\t * is considered quoted.  Quote markers include back-ticks (`),\n\t * double-quotes (\") and brackets ([ and ]).\n\t *\n\t * @param text The text form\n\t * @param quote Whether to quote unquoted text forms\n\t * @param quoteOnNonIdentifierChar Controls whether to treat the result as quoted if text contains characters that are invalid for identifiers\n\t *\n\t * @return The identifier form, or {@code null} if text was {@code null}\n\t */\n\tpublic static Identifier toIdentifier(String text, boolean quote, boolean quoteOnNonIdentifierChar) {\n\t\tif ( isBlank( text ) ) {\n\t\t\treturn null;\n\t\t}\n\t\tint start = 0;\n\t\tint end = text.length();\n\t\twhile ( start < end ) {\n\t\t\tif ( !isWhitespace( text.charAt( start ) ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstart++;\n\t\t}\n\t\twhile ( start < end ) {\n\t\t\tif ( !isWhitespace( text.charAt( end - 1 ) ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tend--;\n\t\t}\n\t\tif ( isQuoted( text, start, end ) ) {\n\t\t\tstart++;\n\t\t\tend--;\n\t\t\tquote = true;\n\t\t}\n\t\telse if ( quoteOnNonIdentifierChar && !quote ) {\n\t\t\t// Check the letters to determine if we must quote the text\n\t\t\tchar c = text.charAt( start );\n\t\t\tif ( !isLetter( c ) && c != '_' ) {\n\t\t\t\t// SQL identifiers must begin with a letter or underscore\n\t\t\t\tquote = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor ( int i = start + 1; i < end; i++ ) {\n\t\t\t\t\tc = text.charAt( i );\n\t\t\t\t\tif ( !isLetterOrDigit( c ) && c != '_' ) {\n\t\t\t\t\t\tquote = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new Identifier( text.substring( start, end ), quote );\n\t}\n\n\t/**\n\t * Is the given identifier text considered quoted.  The following patterns are\n\t * recognized as quoted:<ul>\n\t *     <li>{@code `name`}</li>\n\t *     <li>{@code [name]}</li>\n\t *     <li>{@code \"name\"}</li>\n\t * </ul>\n\t * <p>\n\t * That final form using double-quote (\") is the JPA-defined quoting pattern.  Although\n\t * it is the standard, it makes for ugly declarations.\n\t *\n\t * @return {@code true} if the given identifier text is considered quoted; {@code false} otherwise.\n\t */\n\tpublic static boolean isQuoted(String name) {\n\t\treturn isQuoted( name, 0, name.length() );\n\t}\n\n\tpublic static boolean isQuoted(String name, int start, int end) {\n\t\tif ( start + 2 < end ) {\n\t\t\tswitch ( name.charAt( start ) ) {\n\t\t\t\tcase '`':\n\t\t\t\t\treturn name.charAt( end - 1 ) == '`';\n\t\t\t\tcase '[':\n\t\t\t\t\treturn name.charAt( end - 1 ) == ']';\n\t\t\t\tcase '\"':\n\t\t\t\t\treturn name.charAt( end - 1 ) == '\"';\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static String unQuote(String name) {\n\t\tassert isQuoted( name );\n\n\t\treturn name.substring( 1, name.length() - 1 );\n\t}\n\n\t/**\n\t * Constructs an identifier instance.\n\t *\n\t * @param text The identifier text.\n\t * @param quoted Is this a quoted identifier?\n\t */\n\tpublic Identifier(String text, boolean quoted) {\n\t\tif ( isEmpty( text ) ) {\n\t\t\tthrow new IllegalIdentifierException( \"Identifier text cannot be null\" );\n\t\t}\n\t\tif ( isQuoted( text ) ) {\n\t\t\tthrow new IllegalIdentifierException( \"Identifier text should not contain quote markers (` or \\\")\" );\n\t\t}\n\t\tthis.text = text;\n\t\tthis.isQuoted = quoted;\n\t}\n\n\t/**\n\t * Constructs an unquoted identifier instance.\n\t *\n\t * @param text The identifier text.\n\t */\n\tprotected Identifier(String text) {\n\t\tthis.text = text;\n\t\tthis.isQuoted = false;\n\t}\n\n\t/**\n\t * Get the identifiers name (text)\n\t *\n\t * @return The name\n\t */\n\tpublic String getText() {\n\t\treturn text;\n\t}\n\n\t/**\n\t * Is this a quoted identifier?\n\t *\n\t * @return True if this is a quote identifier; false otherwise.\n\t */\n\tpublic boolean isQuoted() {\n\t\treturn isQuoted;\n\t}\n\n\t/**\n\t * If this is a quoted identifier, then return the identifier name\n\t * enclosed in dialect-specific open- and end-quotes; otherwise,\n\t * simply return the unquoted identifier.\n\t *\n\t * @param dialect The dialect whose dialect-specific quoting should be used.\n\t *\n\t * @return if quoted, identifier name enclosed in dialect-specific open- and\n\t * end-quotes; otherwise, the unquoted identifier.\n\t */\n\tpublic String render(Dialect dialect) {\n\t\treturn isQuoted\n\t\t\t\t? dialect.toQuotedIdentifier( getText() )\n\t\t\t\t: getText();\n\t}\n\n\tpublic String render() {\n\t\treturn isQuoted\n\t\t\t\t? '`' + getText() + '`'\n\t\t\t\t: getText();\n\t}\n\n\tpublic String getCanonicalName() {\n\t\treturn isQuoted ? text : text.toLowerCase( Locale.ENGLISH );\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn render();\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif ( !(o instanceof Identifier that) ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn getCanonicalName().equals( that.getCanonicalName() );\n\t}\n\n\tpublic boolean matches(String name) {\n\t\treturn isQuoted()\n\t\t\t\t? text.equals( name )\n\t\t\t\t: text.equalsIgnoreCase( name );\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn isQuoted ? text.hashCode() : text.toLowerCase( Locale.ENGLISH ).hashCode();\n\t}\n\n\tpublic static boolean areEqual(Identifier id1, Identifier id2) {\n\t\tif ( id1 == null ) {\n\t\t\treturn id2 == null;\n\t\t}\n\t\telse {\n\t\t\treturn id1.equals( id2 );\n\t\t}\n\t}\n\n\tpublic static Identifier quote(Identifier identifier) {\n\t\treturn identifier.isQuoted()\n\t\t\t\t? identifier\n\t\t\t\t: Identifier.toIdentifier( identifier.getText(), true );\n\t}\n\n\t@Override\n\tpublic int compareTo(Identifier o) {\n\t\treturn getCanonicalName().compareTo( o.getCanonicalName() );\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/boot/model/naming/Identifier.java",
        "sourceCodeAfterForWhole": "/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.boot.model.naming;\n\nimport java.util.Locale;\nimport java.util.Objects;\n\nimport org.hibernate.dialect.Dialect;\n\nimport static java.lang.Character.isLetter;\nimport static java.lang.Character.isLetterOrDigit;\nimport static java.lang.Character.isWhitespace;\nimport static org.hibernate.internal.util.StringHelper.isBlank;\nimport static org.hibernate.internal.util.StringHelper.isEmpty;\n\n/**\n * Models an identifier (name), which may or may not be quoted.\n *\n * @author Steve Ebersole\n */\npublic class Identifier implements Comparable<Identifier> {\n\tprivate final String text;\n\tprivate final boolean isQuoted;\n\n\t/**\n\t * Means to generate an {@link Identifier} instance from its simple text form.\n\t * <p>\n\t * If passed text is {@code null}, {@code null} is returned.\n\t * <p>\n\t * If passed text is surrounded in quote markers, the generated Identifier\n\t * is considered quoted.  Quote markers include back-ticks (`),\n\t * double-quotes (\") and brackets ([ and ]).\n\t *\n\t * If the text, after trimming, contains a character that is not a valid identifier character,\n\t * the identifier is treated as quoted.\n\t *\n\t * @param text The text form\n\t *\n\t * @return The identifier form, or {@code null} if text was {@code null}\n\t */\n\tpublic static Identifier toIdentifier(String text) {\n\t\treturn toIdentifier( text, false );\n\t}\n\n\t/**\n\t * Means to generate an {@link Identifier} instance from its simple text form.\n\t * <p>\n\t * If passed text is {@code null}, {@code null} is returned.\n\t * <p>\n\t * If passed text is surrounded in quote markers, the generated Identifier\n\t * is considered quoted.  Quote markers include back-ticks (`),\n\t * double-quotes (\") and brackets ([ and ]).\n\t *\n\t * If the text, after trimming, contains a character that is not a valid identifier character,\n\t * the identifier is treated as quoted.\n\t *\n\t * @param text The text form\n\t * @param quote Whether to quote unquoted text forms\n\t *\n\t * @return The identifier form, or {@code null} if text was {@code null}\n\t */\n\tpublic static Identifier toIdentifier(String text, boolean quote) {\n\t\treturn toIdentifier( text, quote, true );\n\t}\n\n\t/**\n\t * Means to generate an {@link Identifier} instance from its simple text form.\n\t * <p>\n\t * If passed {@code text} is {@code null}, {@code null} is returned.\n\t * <p>\n\t * If passed {@code text} is surrounded in quote markers, the returned Identifier\n\t * is considered quoted. Quote markers include back-ticks (`), double-quotes (\"),\n\t * and brackets ([ and ]).\n\t *\n\t * @param text The text form\n\t * @param quote Whether to quote unquoted text forms\n\t * @param autoquote Whether to quote the result if it contains special characters\n\t *\n\t * @return The identifier form, or {@code null} if text was {@code null}\n\t */\n\tpublic static Identifier toIdentifier(String text, boolean quote, boolean autoquote) {\n\t\tif ( isBlank( text ) ) {\n\t\t\treturn null;\n\t\t}\n\t\tint start = 0;\n\t\tint end = text.length();\n\t\twhile ( start < end ) {\n\t\t\tif ( !isWhitespace( text.charAt( start ) ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstart++;\n\t\t}\n\t\twhile ( start < end ) {\n\t\t\tif ( !isWhitespace( text.charAt( end - 1 ) ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tend--;\n\t\t}\n\t\tif ( isQuoted( text, start, end ) ) {\n\t\t\tstart++;\n\t\t\tend--;\n\t\t\tquote = true;\n\t\t}\n\t\telse if ( autoquote && !quote ) {\n\t\t\tquote = autoquote( text, start, end );\n\t\t}\n\t\treturn new Identifier( text.substring( start, end ), quote );\n\t}\n\n\tprivate static boolean autoquote(String text, int start, int end) {\n\t\t// Check the letters to determine if we must quote the text\n\t\tif ( !isLegalFirstChar( text.charAt( start ) ) ) {\n\t\t\t// SQL identifiers must begin with a letter or underscore\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tfor ( int i = start + 1; i < end; i++ ) {\n\t\t\t\tif ( !isLegalChar( text.charAt( i ) ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate static boolean isLegalChar(char current) {\n\t\treturn isLetterOrDigit( current )\n\t\t\t// every database also allows _ here\n\t\t\t|| current == '_'\n\t\t\t// every database except HSQLDB also allows $ here\n\t\t\t|| current == '$';\n\t}\n\n\tprivate static boolean isLegalFirstChar(char first) {\n\t\treturn isLetter( first )\n\t\t\t// many databases also allow _ here\n\t\t\t|| first == '_';\n\t}\n\n\t/**\n\t * Is the given identifier text considered quoted.  The following patterns are\n\t * recognized as quoted:<ul>\n\t *     <li>{@code `name`}</li>\n\t *     <li>{@code [name]}</li>\n\t *     <li>{@code \"name\"}</li>\n\t * </ul>\n\t * <p>\n\t * That final form using double-quote (\") is the JPA-defined quoting pattern.  Although\n\t * it is the standard, it makes for ugly declarations.\n\t *\n\t * @return {@code true} if the given identifier text is considered quoted; {@code false} otherwise.\n\t */\n\tpublic static boolean isQuoted(String name) {\n\t\treturn isQuoted( name, 0, name.length() );\n\t}\n\n\tpublic static boolean isQuoted(String name, int start, int end) {\n\t\tif ( start + 2 < end ) {\n\t\t\tfinal char first = name.charAt( start );\n\t\t\tfinal char last = name.charAt( end - 1 );\n\t\t\treturn switch ( first ) {\n\t\t\t\tcase '`' -> last == '`';\n\t\t\t\tcase '[' -> last == ']';\n\t\t\t\tcase '\"' -> last == '\"';\n\t\t\t\tdefault -> false;\n\t\t\t};\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tpublic static String unQuote(String name) {\n\t\tassert isQuoted( name );\n\t\treturn name.substring( 1, name.length() - 1 );\n\t}\n\n\t/**\n\t * Constructs an identifier instance.\n\t *\n\t * @param text The identifier text.\n\t * @param quoted Is this a quoted identifier?\n\t */\n\tpublic Identifier(String text, boolean quoted) {\n\t\tif ( isEmpty( text ) ) {\n\t\t\tthrow new IllegalIdentifierException( \"Identifier text cannot be null\" );\n\t\t}\n\t\tif ( isQuoted( text ) ) {\n\t\t\tthrow new IllegalIdentifierException( \"Identifier text should not contain quote markers (` or \\\")\" );\n\t\t}\n\t\tthis.text = text;\n\t\tthis.isQuoted = quoted;\n\t}\n\n\t/**\n\t * Constructs an unquoted identifier instance.\n\t *\n\t * @param text The identifier text.\n\t */\n\tprotected Identifier(String text) {\n\t\tthis.text = text;\n\t\tthis.isQuoted = false;\n\t}\n\n\t/**\n\t * Get the identifiers name (text)\n\t *\n\t * @return The name\n\t */\n\tpublic String getText() {\n\t\treturn text;\n\t}\n\n\t/**\n\t * Is this a quoted identifier?\n\t *\n\t * @return True if this is a quote identifier; false otherwise.\n\t */\n\tpublic boolean isQuoted() {\n\t\treturn isQuoted;\n\t}\n\n\t/**\n\t * If this is a quoted identifier, then return the identifier name\n\t * enclosed in dialect-specific open- and end-quotes; otherwise,\n\t * simply return the unquoted identifier.\n\t *\n\t * @param dialect The dialect whose dialect-specific quoting should be used.\n\t *\n\t * @return if quoted, identifier name enclosed in dialect-specific open- and\n\t * end-quotes; otherwise, the unquoted identifier.\n\t */\n\tpublic String render(Dialect dialect) {\n\t\treturn isQuoted\n\t\t\t\t? dialect.toQuotedIdentifier( getText() )\n\t\t\t\t: getText();\n\t}\n\n\tpublic String render() {\n\t\treturn isQuoted\n\t\t\t\t? '`' + getText() + '`'\n\t\t\t\t: getText();\n\t}\n\n\tpublic String getCanonicalName() {\n\t\treturn isQuoted ? text : text.toLowerCase( Locale.ENGLISH );\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn render();\n\t}\n\n\t@Override\n\tpublic boolean equals(Object object) {\n\t\treturn object instanceof Identifier that\n\t\t\t&& getCanonicalName().equals( that.getCanonicalName() );\n\t}\n\n\tpublic boolean matches(String name) {\n\t\treturn isQuoted()\n\t\t\t\t? text.equals( name )\n\t\t\t\t: text.equalsIgnoreCase( name );\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn isQuoted\n\t\t\t\t? text.hashCode()\n\t\t\t\t: text.toLowerCase( Locale.ENGLISH ).hashCode();\n\t}\n\n\tpublic static boolean areEqual(Identifier id1, Identifier id2) {\n\t\treturn Objects.equals( id1, id2 );\n\t}\n\n\tpublic static Identifier quote(Identifier identifier) {\n\t\treturn identifier.isQuoted()\n\t\t\t\t? identifier\n\t\t\t\t: Identifier.toIdentifier( identifier.getText(), true );\n\t}\n\n\t@Override\n\tpublic int compareTo(Identifier identifier) {\n\t\treturn getCanonicalName().compareTo( identifier.getCanonicalName() );\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private static boolean isLegalFirstChar(char first) {\n\t\treturn isLetter( first )\n\t\t\t// many databases also allow _ here\n\t\t\t|| first == '_';\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.boot.model.naming.Identifier#isQuoted\n methodBody: public boolean isQuoted() {\nreturn isQuoted;\n}"
        ],
        "sourceCodeAfterRefactoring": "private static boolean autoquote(String text, int start, int end) {\n\t\t// Check the letters to determine if we must quote the text\n\t\tif ( !isLegalFirstChar( text.charAt( start ) ) ) {\n\t\t\t// SQL identifiers must begin with a letter or underscore\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tfor ( int i = start + 1; i < end; i++ ) {\n\t\t\t\tif ( !isLegalChar( text.charAt( i ) ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\nprivate static boolean isLegalFirstChar(char first) {\n\t\treturn isLetter( first )\n\t\t\t// many databases also allow _ here\n\t\t\t|| first == '_';\n\t}",
        "diffSourceCode": "-   67: \t/**\n-   68: \t * Means to generate an {@link Identifier} instance from its simple text form.\n-   69: \t * <p>\n-   70: \t * If passed text is {@code null}, {@code null} is returned.\n-   71: \t * <p>\n-   72: \t * If passed text is surrounded in quote markers, the generated Identifier\n-   73: \t * is considered quoted.  Quote markers include back-ticks (`),\n-   74: \t * double-quotes (\") and brackets ([ and ]).\n-   75: \t *\n-   76: \t * @param text The text form\n-   77: \t * @param quote Whether to quote unquoted text forms\n-   78: \t * @param quoteOnNonIdentifierChar Controls whether to treat the result as quoted if text contains characters that are invalid for identifiers\n-   79: \t *\n-   80: \t * @return The identifier form, or {@code null} if text was {@code null}\n-   81: \t */\n-   82: \tpublic static Identifier toIdentifier(String text, boolean quote, boolean quoteOnNonIdentifierChar) {\n-   83: \t\tif ( isBlank( text ) ) {\n-   84: \t\t\treturn null;\n-   85: \t\t}\n-   86: \t\tint start = 0;\n-   87: \t\tint end = text.length();\n-   88: \t\twhile ( start < end ) {\n-   89: \t\t\tif ( !isWhitespace( text.charAt( start ) ) ) {\n-   90: \t\t\t\tbreak;\n-   91: \t\t\t}\n-   92: \t\t\tstart++;\n-   93: \t\t}\n-   94: \t\twhile ( start < end ) {\n-   95: \t\t\tif ( !isWhitespace( text.charAt( end - 1 ) ) ) {\n-   96: \t\t\t\tbreak;\n-   97: \t\t\t}\n-   98: \t\t\tend--;\n-   99: \t\t}\n-  100: \t\tif ( isQuoted( text, start, end ) ) {\n-  101: \t\t\tstart++;\n-  102: \t\t\tend--;\n-  103: \t\t\tquote = true;\n-  104: \t\t}\n-  105: \t\telse if ( quoteOnNonIdentifierChar && !quote ) {\n-  106: \t\t\t// Check the letters to determine if we must quote the text\n-  107: \t\t\tchar c = text.charAt( start );\n-  108: \t\t\tif ( !isLetter( c ) && c != '_' ) {\n-  109: \t\t\t\t// SQL identifiers must begin with a letter or underscore\n-  110: \t\t\t\tquote = true;\n-  111: \t\t\t}\n-  112: \t\t\telse {\n-  113: \t\t\t\tfor ( int i = start + 1; i < end; i++ ) {\n-  114: \t\t\t\t\tc = text.charAt( i );\n-  115: \t\t\t\t\tif ( !isLetterOrDigit( c ) && c != '_' ) {\n-  116: \t\t\t\t\t\tquote = true;\n-  117: \t\t\t\t\t\tbreak;\n-  118: \t\t\t\t\t}\n-  119: \t\t\t\t}\n-  120: \t\t\t}\n-  121: \t\t}\n-  122: \t\treturn new Identifier( text.substring( start, end ), quote );\n-  123: \t}\n-  124: \n-  125: \t/**\n-  126: \t * Is the given identifier text considered quoted.  The following patterns are\n-  136: \t * @return {@code true} if the given identifier text is considered quoted; {@code false} otherwise.\n-  137: \t */\n-  138: \tpublic static boolean isQuoted(String name) {\n-  139: \t\treturn isQuoted( name, 0, name.length() );\n+   67: \n+   68: \t/**\n+   69: \t * Means to generate an {@link Identifier} instance from its simple text form.\n+   70: \t * <p>\n+   71: \t * If passed {@code text} is {@code null}, {@code null} is returned.\n+   72: \t * <p>\n+   73: \t * If passed {@code text} is surrounded in quote markers, the returned Identifier\n+   74: \t * is considered quoted. Quote markers include back-ticks (`), double-quotes (\"),\n+   75: \t * and brackets ([ and ]).\n+   76: \t *\n+   77: \t * @param text The text form\n+   78: \t * @param quote Whether to quote unquoted text forms\n+   79: \t * @param autoquote Whether to quote the result if it contains special characters\n+   80: \t *\n+   81: \t * @return The identifier form, or {@code null} if text was {@code null}\n+   82: \t */\n+   83: \tpublic static Identifier toIdentifier(String text, boolean quote, boolean autoquote) {\n+   84: \t\tif ( isBlank( text ) ) {\n+   85: \t\t\treturn null;\n+   86: \t\t}\n+   87: \t\tint start = 0;\n+   88: \t\tint end = text.length();\n+   89: \t\twhile ( start < end ) {\n+   90: \t\t\tif ( !isWhitespace( text.charAt( start ) ) ) {\n+   91: \t\t\t\tbreak;\n+   92: \t\t\t}\n+   93: \t\t\tstart++;\n+   94: \t\t}\n+   95: \t\twhile ( start < end ) {\n+   96: \t\t\tif ( !isWhitespace( text.charAt( end - 1 ) ) ) {\n+   97: \t\t\t\tbreak;\n+   98: \t\t\t}\n+   99: \t\t\tend--;\n+  100: \t\t}\n+  101: \t\tif ( isQuoted( text, start, end ) ) {\n+  102: \t\t\tstart++;\n+  103: \t\t\tend--;\n+  104: \t\t\tquote = true;\n+  105: \t\t}\n+  106: \t\telse if ( autoquote && !quote ) {\n+  107: \t\t\tquote = autoquote( text, start, end );\n+  108: \t\t}\n+  109: \t\treturn new Identifier( text.substring( start, end ), quote );\n+  110: \t}\n+  111: \n+  112: \tprivate static boolean autoquote(String text, int start, int end) {\n+  113: \t\t// Check the letters to determine if we must quote the text\n+  114: \t\tif ( !isLegalFirstChar( text.charAt( start ) ) ) {\n+  115: \t\t\t// SQL identifiers must begin with a letter or underscore\n+  116: \t\t\treturn true;\n+  117: \t\t}\n+  118: \t\telse {\n+  119: \t\t\tfor ( int i = start + 1; i < end; i++ ) {\n+  120: \t\t\t\tif ( !isLegalChar( text.charAt( i ) ) ) {\n+  121: \t\t\t\t\treturn true;\n+  122: \t\t\t\t}\n+  123: \t\t\t}\n+  124: \t\t}\n+  125: \t\treturn false;\n+  126: \t}\n+  136: \tprivate static boolean isLegalFirstChar(char first) {\n+  137: \t\treturn isLetter( first )\n+  138: \t\t\t// many databases also allow _ here\n+  139: \t\t\t|| first == '_';\n   140: \t}\n",
        "uniqueId": "e14ead0c0f0916cc8fdb8895e2cc481754a75583_67_123_136_140_112_126",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 92
            },
            "BRANCH": {
                "missed": 2,
                "covered": 24
            },
            "LINE": {
                "missed": 0,
                "covered": 26
            },
            "COMPLEXITY": {
                "missed": 2,
                "covered": 12
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\n/**\n * Extracted method to check if the given character is a valid identifier character.\n *\n * @param c The character to check\n * @return True if the character is a valid identifier character, false otherwise\n */\nprivate static boolean isValidIdentifierChar(char c) {\n    return isLetterOrDigit(c) || c == '_';\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n\t * Means to generate an {@link Identifier} instance from its simple text form.\n\t * <p>\n\t * If passed text is {@code null}, {@code null} is returned.\n\t * <p>\n\t * If passed text is surrounded in quote markers, the generated Identifier\n\t * is considered quoted.  Quote markers include back-ticks (`),\n\t * double-quotes (\") and brackets ([ and ]).\n\t *\n\t * @param text The text form\n\t * @param quote Whether to quote unquoted text forms\n\t * @param quoteOnNonIdentifierChar Controls whether to treat the result as quoted if text contains characters that are invalid for identifiers\n\t *\n\t * @return The identifier form, or {@code null} if text was {@code null}\n\t */\n\tpublic static Identifier toIdentifier(String text, boolean quote, boolean quoteOnNonIdentifierChar) {\n\t\tif ( isBlank( text ) ) {\n\t\t\treturn null;\n\t\t}\n\t\tint start = 0;\n\t\tint end = text.length();\n\t\twhile ( start < end ) {\n\t\t\tif ( !isWhitespace( text.charAt( start ) ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstart++;\n\t\t}\n\t\twhile ( start < end ) {\n\t\t\tif ( !isWhitespace( text.charAt( end - 1 ) ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tend--;\n\t\t}\n\t\tif ( isQuoted( text, start, end ) ) {\n\t\t\tstart++;\n\t\t\tend--;\n\t\t\tquote = true;\n\t\t}\n\t\telse if ( quoteOnNonIdentifierChar && !quote ) {\n\t\t\t// Check the letters to determine if we must quote the text\n\t\t\tchar c = text.charAt( start );\n\t\t\tif ( !isLetter( c ) && c != '_' ) {\n\t\t\t\t// SQL identifiers must begin with a letter or underscore\n\t\t\t\tquote = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor ( int i = start + 1; i < end; i++ ) {\n\t\t\t\t\tc = text.charAt( i );\n\t\t\t\t\tif ( !isLetterOrDigit( c ) && c != '_' ) {\n\t\t\t\t\t\tquote = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new Identifier( text.substring( start, end ), quote );\n\t}\n\nClass content:\n/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.boot.model.naming;\n\nimport java.util.Locale;\n\nimport org.hibernate.dialect.Dialect;\n\nimport static java.lang.Character.isLetter;\nimport static java.lang.Character.isLetterOrDigit;\nimport static java.lang.Character.isWhitespace;\nimport static org.hibernate.internal.util.StringHelper.isBlank;\nimport static org.hibernate.internal.util.StringHelper.isEmpty;\n\n/**\n * Models an identifier (name), which may or may not be quoted.\n *\n * @author Steve Ebersole\n */\npublic class Identifier implements Comparable<Identifier> {\n\tprivate final String text;\n\tprivate final boolean isQuoted;\n\n\t/**\n\t * Means to generate an {@link Identifier} instance from its simple text form.\n\t * <p>\n\t * If passed text is {@code null}, {@code null} is returned.\n\t * <p>\n\t * If passed text is surrounded in quote markers, the generated Identifier\n\t * is considered quoted.  Quote markers include back-ticks (`),\n\t * double-quotes (\") and brackets ([ and ]).\n\t *\n\t * If the text, after trimming, contains a character that is not a valid identifier character,\n\t * the identifier is treated as quoted.\n\t *\n\t * @param text The text form\n\t *\n\t * @return The identifier form, or {@code null} if text was {@code null}\n\t */\n\tpublic static Identifier toIdentifier(String text) {\n\t\treturn toIdentifier( text, false );\n\t}\n\n\t/**\n\t * Means to generate an {@link Identifier} instance from its simple text form.\n\t * <p>\n\t * If passed text is {@code null}, {@code null} is returned.\n\t * <p>\n\t * If passed text is surrounded in quote markers, the generated Identifier\n\t * is considered quoted.  Quote markers include back-ticks (`),\n\t * double-quotes (\") and brackets ([ and ]).\n\t *\n\t * If the text, after trimming, contains a character that is not a valid identifier character,\n\t * the identifier is treated as quoted.\n\t *\n\t * @param text The text form\n\t * @param quote Whether to quote unquoted text forms\n\t *\n\t * @return The identifier form, or {@code null} if text was {@code null}\n\t */\n\tpublic static Identifier toIdentifier(String text, boolean quote) {\n\t\treturn toIdentifier( text, quote, true );\n\t}\n\n\t/**\n\t * Means to generate an {@link Identifier} instance from its simple text form.\n\t * <p>\n\t * If passed text is {@code null}, {@code null} is returned.\n\t * <p>\n\t * If passed text is surrounded in quote markers, the generated Identifier\n\t * is considered quoted.  Quote markers include back-ticks (`),\n\t * double-quotes (\") and brackets ([ and ]).\n\t *\n\t * @param text The text form\n\t * @param quote Whether to quote unquoted text forms\n\t * @param quoteOnNonIdentifierChar Controls whether to treat the result as quoted if text contains characters that are invalid for identifiers\n\t *\n\t * @return The identifier form, or {@code null} if text was {@code null}\n\t */\n\tpublic static Identifier toIdentifier(String text, boolean quote, boolean quoteOnNonIdentifierChar) {\n\t\tif ( isBlank( text ) ) {\n\t\t\treturn null;\n\t\t}\n\t\tint start = 0;\n\t\tint end = text.length();\n\t\twhile ( start < end ) {\n\t\t\tif ( !isWhitespace( text.charAt( start ) ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstart++;\n\t\t}\n\t\twhile ( start < end ) {\n\t\t\tif ( !isWhitespace( text.charAt( end - 1 ) ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tend--;\n\t\t}\n\t\tif ( isQuoted( text, start, end ) ) {\n\t\t\tstart++;\n\t\t\tend--;\n\t\t\tquote = true;\n\t\t}\n\t\telse if ( quoteOnNonIdentifierChar && !quote ) {\n\t\t\t// Check the letters to determine if we must quote the text\n\t\t\tchar c = text.charAt( start );\n\t\t\tif ( !isLetter( c ) && c != '_' ) {\n\t\t\t\t// SQL identifiers must begin with a letter or underscore\n\t\t\t\tquote = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor ( int i = start + 1; i < end; i++ ) {\n\t\t\t\t\tc = text.charAt( i );\n\t\t\t\t\tif ( !isLetterOrDigit( c ) && c != '_' ) {\n\t\t\t\t\t\tquote = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new Identifier( text.substring( start, end ), quote );\n\t}\n\n\t/**\n\t * Is the given identifier text considered quoted.  The following patterns are\n\t * recognized as quoted:<ul>\n\t *     <li>{@code `name`}</li>\n\t *     <li>{@code [name]}</li>\n\t *     <li>{@code \"name\"}</li>\n\t * </ul>\n\t * <p>\n\t * That final form using double-quote (\") is the JPA-defined quoting pattern.  Although\n\t * it is the standard, it makes for ugly declarations.\n\t *\n\t * @return {@code true} if the given identifier text is considered quoted; {@code false} otherwise.\n\t */\n\tpublic static boolean isQuoted(String name) {\n\t\treturn isQuoted( name, 0, name.length() );\n\t}\n\n\tpublic static boolean isQuoted(String name, int start, int end) {\n\t\tif ( start + 2 < end ) {\n\t\t\tswitch ( name.charAt( start ) ) {\n\t\t\t\tcase '`':\n\t\t\t\t\treturn name.charAt( end - 1 ) == '`';\n\t\t\t\tcase '[':\n\t\t\t\t\treturn name.charAt( end - 1 ) == ']';\n\t\t\t\tcase '\"':\n\t\t\t\t\treturn name.charAt( end - 1 ) == '\"';\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static String unQuote(String name) {\n\t\tassert isQuoted( name );\n\n\t\treturn name.substring( 1, name.length() - 1 );\n\t}\n\n\t/**\n\t * Constructs an identifier instance.\n\t *\n\t * @param text The identifier text.\n\t * @param quoted Is this a quoted identifier?\n\t */\n\tpublic Identifier(String text, boolean quoted) {\n\t\tif ( isEmpty( text ) ) {\n\t\t\tthrow new IllegalIdentifierException( \"Identifier text cannot be null\" );\n\t\t}\n\t\tif ( isQuoted( text ) ) {\n\t\t\tthrow new IllegalIdentifierException( \"Identifier text should not contain quote markers (` or \\\")\" );\n\t\t}\n\t\tthis.text = text;\n\t\tthis.isQuoted = quoted;\n\t}\n\n\t/**\n\t * Constructs an unquoted identifier instance.\n\t *\n\t * @param text The identifier text.\n\t */\n\tprotected Identifier(String text) {\n\t\tthis.text = text;\n\t\tthis.isQuoted = false;\n\t}\n\n\t/**\n\t * Get the identifiers name (text)\n\t *\n\t * @return The name\n\t */\n\tpublic String getText() {\n\t\treturn text;\n\t}\n\n\t/**\n\t * Is this a quoted identifier?\n\t *\n\t * @return True if this is a quote identifier; false otherwise.\n\t */\n\tpublic boolean isQuoted() {\n\t\treturn isQuoted;\n\t}\n\n\t/**\n\t * If this is a quoted identifier, then return the identifier name\n\t * enclosed in dialect-specific open- and end-quotes; otherwise,\n\t * simply return the unquoted identifier.\n\t *\n\t * @param dialect The dialect whose dialect-specific quoting should be used.\n\t *\n\t * @return if quoted, identifier name enclosed in dialect-specific open- and\n\t * end-quotes; otherwise, the unquoted identifier.\n\t */\n\tpublic String render(Dialect dialect) {\n\t\treturn isQuoted\n\t\t\t\t? dialect.toQuotedIdentifier( getText() )\n\t\t\t\t: getText();\n\t}\n\n\tpublic String render() {\n\t\treturn isQuoted\n\t\t\t\t? '`' + getText() + '`'\n\t\t\t\t: getText();\n\t}\n\n\tpublic String getCanonicalName() {\n\t\treturn isQuoted ? text : text.toLowerCase( Locale.ENGLISH );\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn render();\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif ( !(o instanceof Identifier that) ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn getCanonicalName().equals( that.getCanonicalName() );\n\t}\n\n\tpublic boolean matches(String name) {\n\t\treturn isQuoted()\n\t\t\t\t? text.equals( name )\n\t\t\t\t: text.equalsIgnoreCase( name );\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn isQuoted ? text.hashCode() : text.toLowerCase( Locale.ENGLISH ).hashCode();\n\t}\n\n\tpublic static boolean areEqual(Identifier id1, Identifier id2) {\n\t\tif ( id1 == null ) {\n\t\t\treturn id2 == null;\n\t\t}\n\t\telse {\n\t\t\treturn id1.equals( id2 );\n\t\t}\n\t}\n\n\tpublic static Identifier quote(Identifier identifier) {\n\t\treturn identifier.isQuoted()\n\t\t\t\t? identifier\n\t\t\t\t: Identifier.toIdentifier( identifier.getText(), true );\n\t}\n\n\t@Override\n\tpublic int compareTo(Identifier o) {\n\t\treturn getCanonicalName().compareTo( o.getCanonicalName() );\n\t}\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprotected buildEntityAssembler(entityInitializer EntityInitializer<?>) : EntityAssembler<?> extracted from public createAssembler(parent InitializerParent<?>, creationState AssemblerCreationState) : DomainResultAssembler<?> in class org.hibernate.sql.results.graph.entity.internal.EntityFetchJoinedImpl",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/results/graph/entity/internal/EntityFetchJoinedImpl.java",
                "startLine": 128,
                "endLine": 135,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/results/graph/entity/internal/EntityFetchJoinedImpl.java",
                "startLine": 128,
                "endLine": 133,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/results/graph/entity/internal/EntityFetchJoinedImpl.java",
                "startLine": 135,
                "endLine": 140,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic DomainResultAssembler<?> createAssembler(\n\t\t\tInitializerParent<?> parent,\n\t\t\tAssemblerCreationState creationState) {\n\t\treturn new EntityAssembler<>( getFetchedMapping().getJavaType(),\n\t\t\t\tcreationState.resolveInitializer( this, parent, this )\n\t\t\t\t\t\t.asEntityInitializer() );\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/sql/results/graph/entity/internal/EntityFetchJoinedImpl.java",
        "isPureRefactoring": true,
        "commitId": "1fe23ae2edc8ae660d4a9923efb610b383fd0c3d",
        "packageNameBefore": "org.hibernate.sql.results.graph.entity.internal",
        "classNameBefore": "org.hibernate.sql.results.graph.entity.internal.EntityFetchJoinedImpl",
        "methodNameBefore": "org.hibernate.sql.results.graph.entity.internal.EntityFetchJoinedImpl#createAssembler",
        "invokedMethod": "methodSignature: org.hibernate.sql.results.graph.entity.internal.AbstractNonJoinedEntityFetch#getFetchedMapping\n methodBody: public ToOneAttributeMapping getFetchedMapping() {\nreturn fetchedModelPart;\n}\nmethodSignature: org.hibernate.sql.results.graph.entity.internal.EntityFetchJoinedImpl#getFetchedMapping\n methodBody: public EntityValuedFetchable getFetchedMapping() {\nreturn getEntityValuedModelPart();\n}",
        "classSignatureBefore": "public class EntityFetchJoinedImpl implements EntityFetch, FetchParent, InitializerProducer<EntityFetchJoinedImpl> ",
        "methodNameBeforeSet": [
            "org.hibernate.sql.results.graph.entity.internal.EntityFetchJoinedImpl#createAssembler"
        ],
        "classNameBeforeSet": [
            "org.hibernate.sql.results.graph.entity.internal.EntityFetchJoinedImpl"
        ],
        "classSignatureBeforeSet": [
            "public class EntityFetchJoinedImpl implements EntityFetch, FetchParent, InitializerProducer<EntityFetchJoinedImpl> "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics",
                "description": "All the mappings are matched! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.sql.results.graph.entity.internal;\n\nimport java.util.BitSet;\n\nimport org.hibernate.annotations.NotFoundAction;\nimport org.hibernate.engine.FetchTiming;\nimport org.hibernate.metamodel.mapping.internal.EntityCollectionPart;\nimport org.hibernate.metamodel.mapping.internal.ToOneAttributeMapping;\nimport org.hibernate.spi.NavigablePath;\nimport org.hibernate.sql.ast.tree.from.TableGroup;\nimport org.hibernate.sql.results.graph.AssemblerCreationState;\nimport org.hibernate.sql.results.graph.DomainResult;\nimport org.hibernate.sql.results.graph.DomainResultAssembler;\nimport org.hibernate.sql.results.graph.DomainResultCreationState;\nimport org.hibernate.sql.results.graph.Fetch;\nimport org.hibernate.sql.results.graph.FetchParent;\nimport org.hibernate.sql.results.graph.Fetchable;\nimport org.hibernate.sql.results.graph.Initializer;\nimport org.hibernate.sql.results.graph.InitializerParent;\nimport org.hibernate.sql.results.graph.InitializerProducer;\nimport org.hibernate.sql.results.graph.entity.EntityFetch;\nimport org.hibernate.sql.results.graph.entity.EntityInitializer;\nimport org.hibernate.sql.results.graph.entity.EntityValuedFetchable;\nimport org.hibernate.sql.results.graph.internal.ImmutableFetchList;\n\n/**\n * @author Andrea Boriero\n * @author Steve Ebersole\n */\npublic class EntityFetchJoinedImpl implements EntityFetch, FetchParent, InitializerProducer<EntityFetchJoinedImpl> {\n\tprivate final FetchParent fetchParent;\n\tprivate final EntityValuedFetchable fetchContainer;\n\tprivate final EntityResultImpl entityResult;\n\tprivate final DomainResult<?> keyResult;\n\tprivate final NotFoundAction notFoundAction;\n\tprivate final boolean isAffectedByFilter;\n\n\tprivate final String sourceAlias;\n\n\tpublic EntityFetchJoinedImpl(\n\t\t\tFetchParent fetchParent,\n\t\t\tToOneAttributeMapping toOneMapping,\n\t\t\tTableGroup tableGroup,\n\t\t\tDomainResult<?> keyResult,\n\t\t\tboolean isAffectedByFilter,\n\t\t\tNavigablePath navigablePath,\n\t\t\tDomainResultCreationState creationState) {\n\t\tthis.fetchContainer = toOneMapping;\n\t\tthis.fetchParent = fetchParent;\n\t\tthis.keyResult = keyResult;\n\t\tthis.notFoundAction = toOneMapping.getNotFoundAction();\n\t\tthis.sourceAlias = tableGroup.getSourceAlias();\n\t\tthis.isAffectedByFilter = isAffectedByFilter;\n\t\tthis.entityResult = new EntityResultImpl(\n\t\t\t\tnavigablePath,\n\t\t\t\ttoOneMapping,\n\t\t\t\ttableGroup,\n\t\t\t\tnull\n\t\t);\n\n\t\tthis.entityResult.afterInitialize( this, creationState );\n\t}\n\n\tpublic EntityFetchJoinedImpl(\n\t\t\tFetchParent fetchParent,\n\t\t\tEntityCollectionPart collectionPart,\n\t\t\tTableGroup tableGroup,\n\t\t\tNavigablePath navigablePath,\n\t\t\tDomainResultCreationState creationState) {\n\t\tthis.fetchContainer = collectionPart;\n\t\tthis.fetchParent = fetchParent;\n\t\tthis.notFoundAction = collectionPart.getNotFoundAction();\n\t\tthis.keyResult = null;\n\t\tthis.sourceAlias = tableGroup.getSourceAlias();\n\t\tthis.isAffectedByFilter = false;\n\t\tthis.entityResult = new EntityResultImpl(\n\t\t\t\tnavigablePath,\n\t\t\t\tcollectionPart,\n\t\t\t\ttableGroup,\n\t\t\t\tnull\n\t\t);\n\n\t\tthis.entityResult.afterInitialize( this, creationState );\n\t}\n\n\t/**\n\t * For Hibernate Reactive\n\t */\n\tprotected EntityFetchJoinedImpl(EntityFetchJoinedImpl original) {\n\t\tthis.fetchContainer = original.fetchContainer;\n\t\tthis.fetchParent = original.fetchParent;\n\t\tthis.entityResult = original.entityResult;\n\t\tthis.keyResult = original.keyResult;\n\t\tthis.notFoundAction = original.notFoundAction;\n\t\tthis.isAffectedByFilter = original.isAffectedByFilter;\n\t\tthis.sourceAlias = original.sourceAlias;\n\t}\n\n\t@Override\n\tpublic EntityValuedFetchable getEntityValuedModelPart() {\n\t\treturn fetchContainer;\n\t}\n\n\t@Override\n\tpublic EntityValuedFetchable getReferencedModePart() {\n\t\treturn getEntityValuedModelPart();\n\t}\n\n\t@Override\n\tpublic EntityValuedFetchable getReferencedMappingType() {\n\t\treturn getEntityValuedModelPart();\n\t}\n\n\t@Override\n\tpublic EntityValuedFetchable getFetchedMapping() {\n\t\treturn getEntityValuedModelPart();\n\t}\n\n\t@Override\n\tpublic FetchParent getFetchParent() {\n\t\treturn fetchParent;\n\t}\n\n\t@Override\n\tpublic DomainResultAssembler<?> createAssembler(\n\t\t\tInitializerParent<?> parent,\n\t\t\tAssemblerCreationState creationState) {\n\t\treturn new EntityAssembler<>( getFetchedMapping().getJavaType(),\n\t\t\t\tcreationState.resolveInitializer( this, parent, this )\n\t\t\t\t\t\t.asEntityInitializer() );\n\t}\n\n\t@Override\n\tpublic Initializer<?> createInitializer(\n\t\t\tEntityFetchJoinedImpl resultGraphNode,\n\t\t\tInitializerParent<?> parent,\n\t\t\tAssemblerCreationState creationState) {\n\t\treturn resultGraphNode.createInitializer( parent, creationState );\n\t}\n\n\t@Override\n\tpublic EntityInitializer<?> createInitializer(InitializerParent<?> parent, AssemblerCreationState creationState) {\n\t\treturn new EntityInitializerImpl(\n\t\t\t\tthis,\n\t\t\t\tsourceAlias,\n\t\t\t\tentityResult.getIdentifierFetch(),\n\t\t\t\tentityResult.getDiscriminatorFetch(),\n\t\t\t\tkeyResult,\n\t\t\t\tentityResult.getRowIdResult(),\n\t\t\t\tnotFoundAction,\n\t\t\t\tisAffectedByFilter,\n\t\t\t\tparent,\n\t\t\t\tfalse,\n\t\t\t\tcreationState\n\t\t);\n\t}\n\n\t@Override\n\tpublic FetchTiming getTiming() {\n\t\treturn FetchTiming.IMMEDIATE;\n\t}\n\n\t@Override\n\tpublic boolean hasTableGroup() {\n\t\treturn true;\n\t}\n\n\tpublic EntityResultImpl getEntityResult() {\n\t\treturn entityResult;\n\t}\n\n\t@Override\n\tpublic NavigablePath getNavigablePath() {\n\t\treturn entityResult.getNavigablePath();\n\t}\n\n\t@Override\n\tpublic ImmutableFetchList getFetches() {\n\t\treturn entityResult.getFetches();\n\t}\n\n\t@Override\n\tpublic Fetch findFetch(Fetchable fetchable) {\n\t\treturn entityResult.findFetch( fetchable );\n\t}\n\n\t@Override\n\tpublic boolean hasJoinFetches() {\n\t\treturn entityResult.hasJoinFetches();\n\t}\n\n\t@Override\n\tpublic boolean containsCollectionFetches() {\n\t\treturn entityResult.containsCollectionFetches();\n\t}\n\n\t@Override\n\tpublic void collectValueIndexesToCache(BitSet valueIndexes) {\n\t\tentityResult.collectValueIndexesToCache( valueIndexes );\n\t}\n\n\t/*\n\t * BEGIN: For Hibernate Reactive\n\t */\n\tprotected DomainResult<?> getKeyResult() {\n\t\treturn keyResult;\n\t}\n\n\tprotected NotFoundAction getNotFoundAction() {\n\t\treturn notFoundAction;\n\t}\n\n\tprotected boolean isAffectedByFilter() {\n\t\treturn isAffectedByFilter;\n\t}\n\n\tprotected String getSourceAlias() {\n\t\treturn sourceAlias;\n\t}\n\t/*\n\t * END: Hibernate Reactive: make sure values are accessible from subclass\n\t */\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/sql/results/graph/entity/internal/EntityFetchJoinedImpl.java",
        "sourceCodeAfterForWhole": "/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.sql.results.graph.entity.internal;\n\nimport java.util.BitSet;\n\nimport org.hibernate.annotations.NotFoundAction;\nimport org.hibernate.engine.FetchTiming;\nimport org.hibernate.metamodel.mapping.internal.EntityCollectionPart;\nimport org.hibernate.metamodel.mapping.internal.ToOneAttributeMapping;\nimport org.hibernate.spi.NavigablePath;\nimport org.hibernate.sql.ast.tree.from.TableGroup;\nimport org.hibernate.sql.results.graph.AssemblerCreationState;\nimport org.hibernate.sql.results.graph.DomainResult;\nimport org.hibernate.sql.results.graph.DomainResultAssembler;\nimport org.hibernate.sql.results.graph.DomainResultCreationState;\nimport org.hibernate.sql.results.graph.Fetch;\nimport org.hibernate.sql.results.graph.FetchParent;\nimport org.hibernate.sql.results.graph.Fetchable;\nimport org.hibernate.sql.results.graph.Initializer;\nimport org.hibernate.sql.results.graph.InitializerParent;\nimport org.hibernate.sql.results.graph.InitializerProducer;\nimport org.hibernate.sql.results.graph.entity.EntityFetch;\nimport org.hibernate.sql.results.graph.entity.EntityInitializer;\nimport org.hibernate.sql.results.graph.entity.EntityValuedFetchable;\nimport org.hibernate.sql.results.graph.internal.ImmutableFetchList;\n\n/**\n * @author Andrea Boriero\n * @author Steve Ebersole\n */\npublic class EntityFetchJoinedImpl implements EntityFetch, FetchParent, InitializerProducer<EntityFetchJoinedImpl> {\n\tprivate final FetchParent fetchParent;\n\tprivate final EntityValuedFetchable fetchContainer;\n\tprivate final EntityResultImpl entityResult;\n\tprivate final DomainResult<?> keyResult;\n\tprivate final NotFoundAction notFoundAction;\n\tprivate final boolean isAffectedByFilter;\n\n\tprivate final String sourceAlias;\n\n\tpublic EntityFetchJoinedImpl(\n\t\t\tFetchParent fetchParent,\n\t\t\tToOneAttributeMapping toOneMapping,\n\t\t\tTableGroup tableGroup,\n\t\t\tDomainResult<?> keyResult,\n\t\t\tboolean isAffectedByFilter,\n\t\t\tNavigablePath navigablePath,\n\t\t\tDomainResultCreationState creationState) {\n\t\tthis.fetchContainer = toOneMapping;\n\t\tthis.fetchParent = fetchParent;\n\t\tthis.keyResult = keyResult;\n\t\tthis.notFoundAction = toOneMapping.getNotFoundAction();\n\t\tthis.sourceAlias = tableGroup.getSourceAlias();\n\t\tthis.isAffectedByFilter = isAffectedByFilter;\n\t\tthis.entityResult = new EntityResultImpl(\n\t\t\t\tnavigablePath,\n\t\t\t\ttoOneMapping,\n\t\t\t\ttableGroup,\n\t\t\t\tnull\n\t\t);\n\n\t\tthis.entityResult.afterInitialize( this, creationState );\n\t}\n\n\tpublic EntityFetchJoinedImpl(\n\t\t\tFetchParent fetchParent,\n\t\t\tEntityCollectionPart collectionPart,\n\t\t\tTableGroup tableGroup,\n\t\t\tNavigablePath navigablePath,\n\t\t\tDomainResultCreationState creationState) {\n\t\tthis.fetchContainer = collectionPart;\n\t\tthis.fetchParent = fetchParent;\n\t\tthis.notFoundAction = collectionPart.getNotFoundAction();\n\t\tthis.keyResult = null;\n\t\tthis.sourceAlias = tableGroup.getSourceAlias();\n\t\tthis.isAffectedByFilter = false;\n\t\tthis.entityResult = new EntityResultImpl(\n\t\t\t\tnavigablePath,\n\t\t\t\tcollectionPart,\n\t\t\t\ttableGroup,\n\t\t\t\tnull\n\t\t);\n\n\t\tthis.entityResult.afterInitialize( this, creationState );\n\t}\n\n\t/**\n\t * For Hibernate Reactive\n\t */\n\tprotected EntityFetchJoinedImpl(EntityFetchJoinedImpl original) {\n\t\tthis.fetchContainer = original.fetchContainer;\n\t\tthis.fetchParent = original.fetchParent;\n\t\tthis.entityResult = original.entityResult;\n\t\tthis.keyResult = original.keyResult;\n\t\tthis.notFoundAction = original.notFoundAction;\n\t\tthis.isAffectedByFilter = original.isAffectedByFilter;\n\t\tthis.sourceAlias = original.sourceAlias;\n\t}\n\n\t@Override\n\tpublic EntityValuedFetchable getEntityValuedModelPart() {\n\t\treturn fetchContainer;\n\t}\n\n\t@Override\n\tpublic EntityValuedFetchable getReferencedModePart() {\n\t\treturn getEntityValuedModelPart();\n\t}\n\n\t@Override\n\tpublic EntityValuedFetchable getReferencedMappingType() {\n\t\treturn getEntityValuedModelPart();\n\t}\n\n\t@Override\n\tpublic EntityValuedFetchable getFetchedMapping() {\n\t\treturn getEntityValuedModelPart();\n\t}\n\n\t@Override\n\tpublic FetchParent getFetchParent() {\n\t\treturn fetchParent;\n\t}\n\n\t@Override\n\tpublic DomainResultAssembler<?> createAssembler(\n\t\t\tInitializerParent<?> parent,\n\t\t\tAssemblerCreationState creationState) {\n\t\treturn buildEntityAssembler( creationState.resolveInitializer( this, parent, this ).asEntityInitializer() );\n\t}\n\n\t/**\n\t * Used by Hibernate Reactive\n\t */\n\tprotected EntityAssembler<?> buildEntityAssembler(EntityInitializer<?> entityInitializer) {\n\t\treturn new EntityAssembler<>( getFetchedMapping().getJavaType(), entityInitializer );\n\t}\n\n\t@Override\n\tpublic Initializer<?> createInitializer(\n\t\t\tEntityFetchJoinedImpl resultGraphNode,\n\t\t\tInitializerParent<?> parent,\n\t\t\tAssemblerCreationState creationState) {\n\t\treturn resultGraphNode.createInitializer( parent, creationState );\n\t}\n\n\t@Override\n\tpublic EntityInitializer<?> createInitializer(InitializerParent<?> parent, AssemblerCreationState creationState) {\n\t\treturn new EntityInitializerImpl(\n\t\t\t\tthis,\n\t\t\t\tsourceAlias,\n\t\t\t\tentityResult.getIdentifierFetch(),\n\t\t\t\tentityResult.getDiscriminatorFetch(),\n\t\t\t\tkeyResult,\n\t\t\t\tentityResult.getRowIdResult(),\n\t\t\t\tnotFoundAction,\n\t\t\t\tisAffectedByFilter,\n\t\t\t\tparent,\n\t\t\t\tfalse,\n\t\t\t\tcreationState\n\t\t);\n\t}\n\n\t@Override\n\tpublic FetchTiming getTiming() {\n\t\treturn FetchTiming.IMMEDIATE;\n\t}\n\n\t@Override\n\tpublic boolean hasTableGroup() {\n\t\treturn true;\n\t}\n\n\tpublic EntityResultImpl getEntityResult() {\n\t\treturn entityResult;\n\t}\n\n\t@Override\n\tpublic NavigablePath getNavigablePath() {\n\t\treturn entityResult.getNavigablePath();\n\t}\n\n\t@Override\n\tpublic ImmutableFetchList getFetches() {\n\t\treturn entityResult.getFetches();\n\t}\n\n\t@Override\n\tpublic Fetch findFetch(Fetchable fetchable) {\n\t\treturn entityResult.findFetch( fetchable );\n\t}\n\n\t@Override\n\tpublic boolean hasJoinFetches() {\n\t\treturn entityResult.hasJoinFetches();\n\t}\n\n\t@Override\n\tpublic boolean containsCollectionFetches() {\n\t\treturn entityResult.containsCollectionFetches();\n\t}\n\n\t@Override\n\tpublic void collectValueIndexesToCache(BitSet valueIndexes) {\n\t\tentityResult.collectValueIndexesToCache( valueIndexes );\n\t}\n\n\t/*\n\t * BEGIN: For Hibernate Reactive\n\t */\n\tprotected DomainResult<?> getKeyResult() {\n\t\treturn keyResult;\n\t}\n\n\tprotected NotFoundAction getNotFoundAction() {\n\t\treturn notFoundAction;\n\t}\n\n\tprotected boolean isAffectedByFilter() {\n\t\treturn isAffectedByFilter;\n\t}\n\n\tprotected String getSourceAlias() {\n\t\treturn sourceAlias;\n\t}\n\t/*\n\t * END: Hibernate Reactive: make sure values are accessible from subclass\n\t */\n}\n",
        "diffSourceCodeSet": [
            "/**\n\t * Used by Hibernate Reactive\n\t */\n\tprotected EntityAssembler<?> buildEntityAssembler(EntityInitializer<?> entityInitializer) {\n\t\treturn new EntityAssembler<>( getFetchedMapping().getJavaType(), entityInitializer );\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.sql.results.graph.entity.internal.AbstractNonJoinedEntityFetch#getFetchedMapping\n methodBody: public ToOneAttributeMapping getFetchedMapping() {\nreturn fetchedModelPart;\n}",
            "methodSignature: org.hibernate.sql.results.graph.entity.internal.EntityFetchJoinedImpl#getFetchedMapping\n methodBody: public EntityValuedFetchable getFetchedMapping() {\nreturn getEntityValuedModelPart();\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\tpublic DomainResultAssembler<?> createAssembler(\n\t\t\tInitializerParent<?> parent,\n\t\t\tAssemblerCreationState creationState) {\n\t\treturn buildEntityAssembler( creationState.resolveInitializer( this, parent, this ).asEntityInitializer() );\n\t}\n/**\n\t * Used by Hibernate Reactive\n\t */\n\tprotected EntityAssembler<?> buildEntityAssembler(EntityInitializer<?> entityInitializer) {\n\t\treturn new EntityAssembler<>( getFetchedMapping().getJavaType(), entityInitializer );\n\t}",
        "diffSourceCode": "   128: \t@Override\n   129: \tpublic DomainResultAssembler<?> createAssembler(\n   130: \t\t\tInitializerParent<?> parent,\n   131: \t\t\tAssemblerCreationState creationState) {\n-  132: \t\treturn new EntityAssembler<>( getFetchedMapping().getJavaType(),\n-  133: \t\t\t\tcreationState.resolveInitializer( this, parent, this )\n-  134: \t\t\t\t\t\t.asEntityInitializer() );\n-  135: \t}\n-  136: \n-  137: \t@Override\n-  138: \tpublic Initializer<?> createInitializer(\n-  139: \t\t\tEntityFetchJoinedImpl resultGraphNode,\n-  140: \t\t\tInitializerParent<?> parent,\n+  132: \t\treturn buildEntityAssembler( creationState.resolveInitializer( this, parent, this ).asEntityInitializer() );\n+  133: \t}\n+  134: \n+  135: \t/**\n+  136: \t * Used by Hibernate Reactive\n+  137: \t */\n+  138: \tprotected EntityAssembler<?> buildEntityAssembler(EntityInitializer<?> entityInitializer) {\n+  139: \t\treturn new EntityAssembler<>( getFetchedMapping().getJavaType(), entityInitializer );\n+  140: \t}\n",
        "uniqueId": "1fe23ae2edc8ae660d4a9923efb610b383fd0c3d_128_135_135_140_128_133",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 13
            },
            "LINE": {
                "missed": 0,
                "covered": 3
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\nprivate EntityAssembler<?> createEntityAssembler(AssemblerCreationState creationState, InitializerParent<?> parent) {\n    return new EntityAssembler<>(getFetchedMapping().getJavaType(),\n            creationState.resolveInitializer(this, parent, this)\n                    .asEntityInitializer());\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Override\n\tpublic DomainResultAssembler<?> createAssembler(\n\t\t\tInitializerParent<?> parent,\n\t\t\tAssemblerCreationState creationState) {\n\t\treturn new EntityAssembler<>( getFetchedMapping().getJavaType(),\n\t\t\t\tcreationState.resolveInitializer( this, parent, this )\n\t\t\t\t\t\t.asEntityInitializer() );\n\t}\n\nClass content:\n/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.sql.results.graph.entity.internal;\n\nimport java.util.BitSet;\n\nimport org.hibernate.annotations.NotFoundAction;\nimport org.hibernate.engine.FetchTiming;\nimport org.hibernate.metamodel.mapping.internal.EntityCollectionPart;\nimport org.hibernate.metamodel.mapping.internal.ToOneAttributeMapping;\nimport org.hibernate.spi.NavigablePath;\nimport org.hibernate.sql.ast.tree.from.TableGroup;\nimport org.hibernate.sql.results.graph.AssemblerCreationState;\nimport org.hibernate.sql.results.graph.DomainResult;\nimport org.hibernate.sql.results.graph.DomainResultAssembler;\nimport org.hibernate.sql.results.graph.DomainResultCreationState;\nimport org.hibernate.sql.results.graph.Fetch;\nimport org.hibernate.sql.results.graph.FetchParent;\nimport org.hibernate.sql.results.graph.Fetchable;\nimport org.hibernate.sql.results.graph.Initializer;\nimport org.hibernate.sql.results.graph.InitializerParent;\nimport org.hibernate.sql.results.graph.InitializerProducer;\nimport org.hibernate.sql.results.graph.entity.EntityFetch;\nimport org.hibernate.sql.results.graph.entity.EntityInitializer;\nimport org.hibernate.sql.results.graph.entity.EntityValuedFetchable;\nimport org.hibernate.sql.results.graph.internal.ImmutableFetchList;\n\n/**\n * @author Andrea Boriero\n * @author Steve Ebersole\n */\npublic class EntityFetchJoinedImpl implements EntityFetch, FetchParent, InitializerProducer<EntityFetchJoinedImpl> {\n\tprivate final FetchParent fetchParent;\n\tprivate final EntityValuedFetchable fetchContainer;\n\tprivate final EntityResultImpl entityResult;\n\tprivate final DomainResult<?> keyResult;\n\tprivate final NotFoundAction notFoundAction;\n\tprivate final boolean isAffectedByFilter;\n\n\tprivate final String sourceAlias;\n\n\tpublic EntityFetchJoinedImpl(\n\t\t\tFetchParent fetchParent,\n\t\t\tToOneAttributeMapping toOneMapping,\n\t\t\tTableGroup tableGroup,\n\t\t\tDomainResult<?> keyResult,\n\t\t\tboolean isAffectedByFilter,\n\t\t\tNavigablePath navigablePath,\n\t\t\tDomainResultCreationState creationState) {\n\t\tthis.fetchContainer = toOneMapping;\n\t\tthis.fetchParent = fetchParent;\n\t\tthis.keyResult = keyResult;\n\t\tthis.notFoundAction = toOneMapping.getNotFoundAction();\n\t\tthis.sourceAlias = tableGroup.getSourceAlias();\n\t\tthis.isAffectedByFilter = isAffectedByFilter;\n\t\tthis.entityResult = new EntityResultImpl(\n\t\t\t\tnavigablePath,\n\t\t\t\ttoOneMapping,\n\t\t\t\ttableGroup,\n\t\t\t\tnull\n\t\t);\n\n\t\tthis.entityResult.afterInitialize( this, creationState );\n\t}\n\n\tpublic EntityFetchJoinedImpl(\n\t\t\tFetchParent fetchParent,\n\t\t\tEntityCollectionPart collectionPart,\n\t\t\tTableGroup tableGroup,\n\t\t\tNavigablePath navigablePath,\n\t\t\tDomainResultCreationState creationState) {\n\t\tthis.fetchContainer = collectionPart;\n\t\tthis.fetchParent = fetchParent;\n\t\tthis.notFoundAction = collectionPart.getNotFoundAction();\n\t\tthis.keyResult = null;\n\t\tthis.sourceAlias = tableGroup.getSourceAlias();\n\t\tthis.isAffectedByFilter = false;\n\t\tthis.entityResult = new EntityResultImpl(\n\t\t\t\tnavigablePath,\n\t\t\t\tcollectionPart,\n\t\t\t\ttableGroup,\n\t\t\t\tnull\n\t\t);\n\n\t\tthis.entityResult.afterInitialize( this, creationState );\n\t}\n\n\t/**\n\t * For Hibernate Reactive\n\t */\n\tprotected EntityFetchJoinedImpl(EntityFetchJoinedImpl original) {\n\t\tthis.fetchContainer = original.fetchContainer;\n\t\tthis.fetchParent = original.fetchParent;\n\t\tthis.entityResult = original.entityResult;\n\t\tthis.keyResult = original.keyResult;\n\t\tthis.notFoundAction = original.notFoundAction;\n\t\tthis.isAffectedByFilter = original.isAffectedByFilter;\n\t\tthis.sourceAlias = original.sourceAlias;\n\t}\n\n\t@Override\n\tpublic EntityValuedFetchable getEntityValuedModelPart() {\n\t\treturn fetchContainer;\n\t}\n\n\t@Override\n\tpublic EntityValuedFetchable getReferencedModePart() {\n\t\treturn getEntityValuedModelPart();\n\t}\n\n\t@Override\n\tpublic EntityValuedFetchable getReferencedMappingType() {\n\t\treturn getEntityValuedModelPart();\n\t}\n\n\t@Override\n\tpublic EntityValuedFetchable getFetchedMapping() {\n\t\treturn getEntityValuedModelPart();\n\t}\n\n\t@Override\n\tpublic FetchParent getFetchParent() {\n\t\treturn fetchParent;\n\t}\n\n\t@Override\n\tpublic DomainResultAssembler<?> createAssembler(\n\t\t\tInitializerParent<?> parent,\n\t\t\tAssemblerCreationState creationState) {\n\t\treturn new EntityAssembler<>( getFetchedMapping().getJavaType(),\n\t\t\t\tcreationState.resolveInitializer( this, parent, this )\n\t\t\t\t\t\t.asEntityInitializer() );\n\t}\n\n\t@Override\n\tpublic Initializer<?> createInitializer(\n\t\t\tEntityFetchJoinedImpl resultGraphNode,\n\t\t\tInitializerParent<?> parent,\n\t\t\tAssemblerCreationState creationState) {\n\t\treturn resultGraphNode.createInitializer( parent, creationState );\n\t}\n\n\t@Override\n\tpublic EntityInitializer<?> createInitializer(InitializerParent<?> parent, AssemblerCreationState creationState) {\n\t\treturn new EntityInitializerImpl(\n\t\t\t\tthis,\n\t\t\t\tsourceAlias,\n\t\t\t\tentityResult.getIdentifierFetch(),\n\t\t\t\tentityResult.getDiscriminatorFetch(),\n\t\t\t\tkeyResult,\n\t\t\t\tentityResult.getRowIdResult(),\n\t\t\t\tnotFoundAction,\n\t\t\t\tisAffectedByFilter,\n\t\t\t\tparent,\n\t\t\t\tfalse,\n\t\t\t\tcreationState\n\t\t);\n\t}\n\n\t@Override\n\tpublic FetchTiming getTiming() {\n\t\treturn FetchTiming.IMMEDIATE;\n\t}\n\n\t@Override\n\tpublic boolean hasTableGroup() {\n\t\treturn true;\n\t}\n\n\tpublic EntityResultImpl getEntityResult() {\n\t\treturn entityResult;\n\t}\n\n\t@Override\n\tpublic NavigablePath getNavigablePath() {\n\t\treturn entityResult.getNavigablePath();\n\t}\n\n\t@Override\n\tpublic ImmutableFetchList getFetches() {\n\t\treturn entityResult.getFetches();\n\t}\n\n\t@Override\n\tpublic Fetch findFetch(Fetchable fetchable) {\n\t\treturn entityResult.findFetch( fetchable );\n\t}\n\n\t@Override\n\tpublic boolean hasJoinFetches() {\n\t\treturn entityResult.hasJoinFetches();\n\t}\n\n\t@Override\n\tpublic boolean containsCollectionFetches() {\n\t\treturn entityResult.containsCollectionFetches();\n\t}\n\n\t@Override\n\tpublic void collectValueIndexesToCache(BitSet valueIndexes) {\n\t\tentityResult.collectValueIndexesToCache( valueIndexes );\n\t}\n\n\t/*\n\t * BEGIN: For Hibernate Reactive\n\t */\n\tprotected DomainResult<?> getKeyResult() {\n\t\treturn keyResult;\n\t}\n\n\tprotected NotFoundAction getNotFoundAction() {\n\t\treturn notFoundAction;\n\t}\n\n\tprotected boolean isAffectedByFilter() {\n\t\treturn isAffectedByFilter;\n\t}\n\n\tprotected String getSourceAlias() {\n\t\treturn sourceAlias;\n\t}\n\t/*\n\t * END: Hibernate Reactive: make sure values are accessible from subclass\n\t */\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate registerAllCallbacks(persistentClass PersistentClass, registryBuilder CallbackRegistryImpl.Builder, entityClass Class<?>, beanRegistry ManagedBeanRegistry) : void extracted from public buildCallbackRegistry(options SessionFactoryOptions, serviceRegistry ServiceRegistry, entityBindings Collection<PersistentClass>) : CallbackRegistry in class org.hibernate.jpa.event.internal.CallbacksFactory",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/jpa/event/internal/CallbacksFactory.java",
                "startLine": 32,
                "endLine": 73,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/jpa/event/internal/CallbacksFactory.java",
                "startLine": 32,
                "endLine": 65,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/jpa/event/internal/CallbacksFactory.java",
                "startLine": 67,
                "endLine": 79,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public static CallbackRegistry buildCallbackRegistry(SessionFactoryOptions options, ServiceRegistry serviceRegistry, Collection<PersistentClass> entityBindings) {\n\t\tif ( !jpaCallBacksEnabled( options ) ) {\n\t\t\treturn new EmptyCallbackRegistryImpl();\n\t\t}\n\t\tManagedBeanRegistry beanRegistry = serviceRegistry.getService( ManagedBeanRegistry.class );\n\t\tCallbackRegistryImpl.Builder registryBuilder = new CallbackRegistryImpl.Builder();\n\t\tSet<Class<?>> entityClasses = new HashSet<>();\n\n\t\tfor ( PersistentClass persistentClass : entityBindings ) {\n\t\t\tif ( persistentClass.getClassName() == null ) {\n\t\t\t\t// we can have dynamic (non-java class) mapping\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tClass<?> entityClass = persistentClass.getMappedClass();\n\n\t\t\tif ( !entityClasses.add( entityClass ) ) {\n\t\t\t\t// this most likely means we have a class mapped multiple times using the hbm.xml\n\t\t\t\t// \"entity name\" feature\n\t\t\t\tif ( log.isDebugEnabled() ) {\n\t\t\t\t\tlog.debugf(\n\t\t\t\t\t\t\t\"Class [%s] already has callbacks registered; \" +\n\t\t\t\t\t\t\t\t\t\"assuming this means the class was mapped twice \" +\n\t\t\t\t\t\t\t\t\t\"(using hbm.xml entity-name support) - skipping subsequent registrations\" +\n\t\t\t\t\t\t\t\t\t\"to avoid duplicates\",\n\t\t\t\t\t\t\tentityClass.getName()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tregistryBuilder.registerCallbacks( persistentClass.getMappedClass(),\n\t\t\t\t\tbuildCallbacks( persistentClass.getCallbackDefinitions(), beanRegistry ) );\n\n\t\t\tfor ( Property property : persistentClass.getDeclaredProperties() ) {\n\t\t\t\tregistryBuilder.registerCallbacks( persistentClass.getMappedClass(),\n\t\t\t\t\t\tbuildCallbacks( property.getCallbackDefinitions(), beanRegistry ) );\n\t\t\t}\n\t\t}\n\n\t\treturn registryBuilder.build();\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/jpa/event/internal/CallbacksFactory.java",
        "isPureRefactoring": true,
        "commitId": "ddeaffc917fb82e84461691605baab7d12962cd2",
        "packageNameBefore": "org.hibernate.jpa.event.internal",
        "classNameBefore": "org.hibernate.jpa.event.internal.CallbacksFactory",
        "methodNameBefore": "org.hibernate.jpa.event.internal.CallbacksFactory#buildCallbackRegistry",
        "invokedMethod": "methodSignature: org.hibernate.jpa.event.internal.CallbacksFactory#buildCallbacks\n methodBody: private static Callback[] buildCallbacks(List<CallbackDefinition> callbackDefinitions,\n\t\t\tManagedBeanRegistry beanRegistry) {\nif(callbackDefinitions == null || callbackDefinitions.isEmpty()){return null;\n}List<Callback> callbacks=new ArrayList<>();\nfor(CallbackDefinition definition: callbackDefinitions){callbacks.add(definition.createCallback(beanRegistry));\n}return callbacks.toArray(new Callback[0]);\n}\nmethodSignature: org.hibernate.jpa.event.internal.CallbacksFactory#jpaCallBacksEnabled\n methodBody: private static boolean jpaCallBacksEnabled(SessionFactoryOptions options) {\nreturn options.areJPACallbacksEnabled();\n}",
        "classSignatureBefore": "public final class CallbacksFactory ",
        "methodNameBeforeSet": [
            "org.hibernate.jpa.event.internal.CallbacksFactory#buildCallbackRegistry"
        ],
        "classNameBeforeSet": [
            "org.hibernate.jpa.event.internal.CallbacksFactory"
        ],
        "classSignatureBeforeSet": [
            "public final class CallbacksFactory "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.jpa.event.internal;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.hibernate.boot.spi.SessionFactoryOptions;\nimport org.hibernate.jpa.event.spi.Callback;\nimport org.hibernate.jpa.event.spi.CallbackDefinition;\nimport org.hibernate.jpa.event.spi.CallbackRegistry;\nimport org.hibernate.mapping.PersistentClass;\nimport org.hibernate.mapping.Property;\nimport org.hibernate.resource.beans.spi.ManagedBeanRegistry;\nimport org.hibernate.service.ServiceRegistry;\n\nimport org.jboss.logging.Logger;\n\n/**\n * The intent of this class is to use a lighter implementation\n * when JPA callbacks are disabled via\n * {@link SessionFactoryOptions#areJPACallbacksEnabled()}\n */\npublic final class CallbacksFactory {\n\tprivate static final Logger log = Logger.getLogger( CallbacksFactory.class );\n\n\tpublic static CallbackRegistry buildCallbackRegistry(SessionFactoryOptions options, ServiceRegistry serviceRegistry, Collection<PersistentClass> entityBindings) {\n\t\tif ( !jpaCallBacksEnabled( options ) ) {\n\t\t\treturn new EmptyCallbackRegistryImpl();\n\t\t}\n\t\tManagedBeanRegistry beanRegistry = serviceRegistry.getService( ManagedBeanRegistry.class );\n\t\tCallbackRegistryImpl.Builder registryBuilder = new CallbackRegistryImpl.Builder();\n\t\tSet<Class<?>> entityClasses = new HashSet<>();\n\n\t\tfor ( PersistentClass persistentClass : entityBindings ) {\n\t\t\tif ( persistentClass.getClassName() == null ) {\n\t\t\t\t// we can have dynamic (non-java class) mapping\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tClass<?> entityClass = persistentClass.getMappedClass();\n\n\t\t\tif ( !entityClasses.add( entityClass ) ) {\n\t\t\t\t// this most likely means we have a class mapped multiple times using the hbm.xml\n\t\t\t\t// \"entity name\" feature\n\t\t\t\tif ( log.isDebugEnabled() ) {\n\t\t\t\t\tlog.debugf(\n\t\t\t\t\t\t\t\"Class [%s] already has callbacks registered; \" +\n\t\t\t\t\t\t\t\t\t\"assuming this means the class was mapped twice \" +\n\t\t\t\t\t\t\t\t\t\"(using hbm.xml entity-name support) - skipping subsequent registrations\" +\n\t\t\t\t\t\t\t\t\t\"to avoid duplicates\",\n\t\t\t\t\t\t\tentityClass.getName()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tregistryBuilder.registerCallbacks( persistentClass.getMappedClass(),\n\t\t\t\t\tbuildCallbacks( persistentClass.getCallbackDefinitions(), beanRegistry ) );\n\n\t\t\tfor ( Property property : persistentClass.getDeclaredProperties() ) {\n\t\t\t\tregistryBuilder.registerCallbacks( persistentClass.getMappedClass(),\n\t\t\t\t\t\tbuildCallbacks( property.getCallbackDefinitions(), beanRegistry ) );\n\t\t\t}\n\t\t}\n\n\t\treturn registryBuilder.build();\n\t}\n\n\tprivate static Callback[] buildCallbacks(List<CallbackDefinition> callbackDefinitions,\n\t\t\tManagedBeanRegistry beanRegistry) {\n\t\tif ( callbackDefinitions == null || callbackDefinitions.isEmpty() ) {\n\t\t\treturn null;\n\t\t}\n\t\tList<Callback> callbacks = new ArrayList<>();\n\t\tfor ( CallbackDefinition definition : callbackDefinitions ) {\n\t\t\tcallbacks.add( definition.createCallback( beanRegistry ) );\n\t\t}\n\t\treturn callbacks.toArray( new Callback[0] );\n\t}\n\n\tprivate static boolean jpaCallBacksEnabled(SessionFactoryOptions options) {\n\t\treturn options.areJPACallbacksEnabled();\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/jpa/event/internal/CallbacksFactory.java",
        "sourceCodeAfterForWhole": "/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.jpa.event.internal;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.hibernate.boot.spi.SessionFactoryOptions;\nimport org.hibernate.jpa.event.spi.Callback;\nimport org.hibernate.jpa.event.spi.CallbackDefinition;\nimport org.hibernate.jpa.event.spi.CallbackRegistry;\nimport org.hibernate.mapping.PersistentClass;\nimport org.hibernate.mapping.Property;\nimport org.hibernate.resource.beans.spi.ManagedBeanRegistry;\nimport org.hibernate.service.ServiceRegistry;\n\nimport org.jboss.logging.Logger;\n\n/**\n * The intent of this class is to use a lighter implementation\n * when JPA callbacks are disabled via\n * {@link SessionFactoryOptions#areJPACallbacksEnabled()}\n */\npublic final class CallbacksFactory {\n\tprivate static final Logger log = Logger.getLogger( CallbacksFactory.class );\n\n\tpublic static CallbackRegistry buildCallbackRegistry(\n\t\t\tSessionFactoryOptions options, ServiceRegistry serviceRegistry, Collection<PersistentClass> entityBindings) {\n\t\tif ( !options.areJPACallbacksEnabled() ) {\n\t\t\treturn new EmptyCallbackRegistryImpl();\n\t\t}\n\t\tfinal ManagedBeanRegistry beanRegistry = serviceRegistry.getService( ManagedBeanRegistry.class );\n\t\tfinal CallbackRegistryImpl.Builder registryBuilder = new CallbackRegistryImpl.Builder();\n\t\tfinal Set<Class<?>> entityClasses = new HashSet<>();\n\n\t\tfor ( PersistentClass persistentClass : entityBindings ) {\n\t\t\tif ( persistentClass.getClassName() != null ) {\n\t\t\t\tfinal Class<?> entityClass = persistentClass.getMappedClass();\n\t\t\t\tif ( !entityClasses.add( entityClass ) ) {\n\t\t\t\t\t// this most likely means we have a class mapped multiple\n\t\t\t\t\t// times using the hbm.xml \"entity name\" feature\n\t\t\t\t\tif ( log.isDebugEnabled() ) {\n\t\t\t\t\t\tlog.debugf(\n\t\t\t\t\t\t\t\t\"Class [%s] already has callbacks registered; \" +\n\t\t\t\t\t\t\t\t\"assuming this means the class was mapped twice \" +\n\t\t\t\t\t\t\t\t\"(using hbm.xml entity-name support) - skipping subsequent registrations\" +\n\t\t\t\t\t\t\t\t\"to avoid duplicates\",\n\t\t\t\t\t\t\t\tentityClass.getName()\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tregisterAllCallbacks( persistentClass, registryBuilder, entityClass, beanRegistry );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// else we can have dynamic (non-java class) mapping\n\t\t}\n\n\t\treturn registryBuilder.build();\n\t}\n\n\tprivate static void registerAllCallbacks(\n\t\t\tPersistentClass persistentClass,\n\t\t\tCallbackRegistryImpl.Builder registryBuilder,\n\t\t\tClass<?> entityClass,\n\t\t\tManagedBeanRegistry beanRegistry) {\n\t\tregistryBuilder.registerCallbacks( entityClass,\n\t\t\t\tbuildCallbacks( persistentClass.getCallbackDefinitions(), beanRegistry ) );\n\n\t\tfor ( Property property : persistentClass.getDeclaredProperties() ) {\n\t\t\tregistryBuilder.registerCallbacks( entityClass,\n\t\t\t\t\tbuildCallbacks( property.getCallbackDefinitions(), beanRegistry ) );\n\t\t}\n\t}\n\n\tprivate static Callback[] buildCallbacks(List<CallbackDefinition> callbackDefinitions,\n\t\t\tManagedBeanRegistry beanRegistry) {\n\t\tif ( callbackDefinitions == null || callbackDefinitions.isEmpty() ) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tfinal List<Callback> callbacks = new ArrayList<>();\n\t\t\tfor ( CallbackDefinition definition : callbackDefinitions ) {\n\t\t\t\tcallbacks.add( definition.createCallback( beanRegistry ) );\n\t\t\t}\n\t\t\treturn callbacks.toArray( new Callback[0] );\n\t\t}\n\t}\n\n}\n",
        "diffSourceCodeSet": [
            "private static void registerAllCallbacks(\n\t\t\tPersistentClass persistentClass,\n\t\t\tCallbackRegistryImpl.Builder registryBuilder,\n\t\t\tClass<?> entityClass,\n\t\t\tManagedBeanRegistry beanRegistry) {\n\t\tregistryBuilder.registerCallbacks( entityClass,\n\t\t\t\tbuildCallbacks( persistentClass.getCallbackDefinitions(), beanRegistry ) );\n\n\t\tfor ( Property property : persistentClass.getDeclaredProperties() ) {\n\t\t\tregistryBuilder.registerCallbacks( entityClass,\n\t\t\t\t\tbuildCallbacks( property.getCallbackDefinitions(), beanRegistry ) );\n\t\t}\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.jpa.event.internal.CallbacksFactory#buildCallbacks\n methodBody: private static Callback[] buildCallbacks(List<CallbackDefinition> callbackDefinitions,\n\t\t\tManagedBeanRegistry beanRegistry) {\nif(callbackDefinitions == null || callbackDefinitions.isEmpty()){return null;\n}List<Callback> callbacks=new ArrayList<>();\nfor(CallbackDefinition definition: callbackDefinitions){callbacks.add(definition.createCallback(beanRegistry));\n}return callbacks.toArray(new Callback[0]);\n}",
            "methodSignature: org.hibernate.jpa.event.internal.CallbacksFactory#jpaCallBacksEnabled\n methodBody: private static boolean jpaCallBacksEnabled(SessionFactoryOptions options) {\nreturn options.areJPACallbacksEnabled();\n}"
        ],
        "sourceCodeAfterRefactoring": "public static CallbackRegistry buildCallbackRegistry(\n\t\t\tSessionFactoryOptions options, ServiceRegistry serviceRegistry, Collection<PersistentClass> entityBindings) {\n\t\tif ( !options.areJPACallbacksEnabled() ) {\n\t\t\treturn new EmptyCallbackRegistryImpl();\n\t\t}\n\t\tfinal ManagedBeanRegistry beanRegistry = serviceRegistry.getService( ManagedBeanRegistry.class );\n\t\tfinal CallbackRegistryImpl.Builder registryBuilder = new CallbackRegistryImpl.Builder();\n\t\tfinal Set<Class<?>> entityClasses = new HashSet<>();\n\n\t\tfor ( PersistentClass persistentClass : entityBindings ) {\n\t\t\tif ( persistentClass.getClassName() != null ) {\n\t\t\t\tfinal Class<?> entityClass = persistentClass.getMappedClass();\n\t\t\t\tif ( !entityClasses.add( entityClass ) ) {\n\t\t\t\t\t// this most likely means we have a class mapped multiple\n\t\t\t\t\t// times using the hbm.xml \"entity name\" feature\n\t\t\t\t\tif ( log.isDebugEnabled() ) {\n\t\t\t\t\t\tlog.debugf(\n\t\t\t\t\t\t\t\t\"Class [%s] already has callbacks registered; \" +\n\t\t\t\t\t\t\t\t\"assuming this means the class was mapped twice \" +\n\t\t\t\t\t\t\t\t\"(using hbm.xml entity-name support) - skipping subsequent registrations\" +\n\t\t\t\t\t\t\t\t\"to avoid duplicates\",\n\t\t\t\t\t\t\t\tentityClass.getName()\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tregisterAllCallbacks( persistentClass, registryBuilder, entityClass, beanRegistry );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// else we can have dynamic (non-java class) mapping\n\t\t}\n\n\t\treturn registryBuilder.build();\n\t}\nprivate static void registerAllCallbacks(\n\t\t\tPersistentClass persistentClass,\n\t\t\tCallbackRegistryImpl.Builder registryBuilder,\n\t\t\tClass<?> entityClass,\n\t\t\tManagedBeanRegistry beanRegistry) {\n\t\tregistryBuilder.registerCallbacks( entityClass,\n\t\t\t\tbuildCallbacks( persistentClass.getCallbackDefinitions(), beanRegistry ) );\n\n\t\tfor ( Property property : persistentClass.getDeclaredProperties() ) {\n\t\t\tregistryBuilder.registerCallbacks( entityClass,\n\t\t\t\t\tbuildCallbacks( property.getCallbackDefinitions(), beanRegistry ) );\n\t\t}\n\t}",
        "diffSourceCode": "-   32: \tpublic static CallbackRegistry buildCallbackRegistry(SessionFactoryOptions options, ServiceRegistry serviceRegistry, Collection<PersistentClass> entityBindings) {\n-   33: \t\tif ( !jpaCallBacksEnabled( options ) ) {\n-   34: \t\t\treturn new EmptyCallbackRegistryImpl();\n-   35: \t\t}\n-   36: \t\tManagedBeanRegistry beanRegistry = serviceRegistry.getService( ManagedBeanRegistry.class );\n-   37: \t\tCallbackRegistryImpl.Builder registryBuilder = new CallbackRegistryImpl.Builder();\n-   38: \t\tSet<Class<?>> entityClasses = new HashSet<>();\n-   39: \n-   40: \t\tfor ( PersistentClass persistentClass : entityBindings ) {\n-   41: \t\t\tif ( persistentClass.getClassName() == null ) {\n-   42: \t\t\t\t// we can have dynamic (non-java class) mapping\n-   43: \t\t\t\tcontinue;\n-   44: \t\t\t}\n-   45: \n-   46: \t\t\tClass<?> entityClass = persistentClass.getMappedClass();\n-   47: \n-   48: \t\t\tif ( !entityClasses.add( entityClass ) ) {\n-   49: \t\t\t\t// this most likely means we have a class mapped multiple times using the hbm.xml\n-   50: \t\t\t\t// \"entity name\" feature\n-   51: \t\t\t\tif ( log.isDebugEnabled() ) {\n-   52: \t\t\t\t\tlog.debugf(\n-   53: \t\t\t\t\t\t\t\"Class [%s] already has callbacks registered; \" +\n-   54: \t\t\t\t\t\t\t\t\t\"assuming this means the class was mapped twice \" +\n-   55: \t\t\t\t\t\t\t\t\t\"(using hbm.xml entity-name support) - skipping subsequent registrations\" +\n-   56: \t\t\t\t\t\t\t\t\t\"to avoid duplicates\",\n-   57: \t\t\t\t\t\t\tentityClass.getName()\n-   58: \t\t\t\t\t);\n+   32: \tpublic static CallbackRegistry buildCallbackRegistry(\n+   33: \t\t\tSessionFactoryOptions options, ServiceRegistry serviceRegistry, Collection<PersistentClass> entityBindings) {\n+   34: \t\tif ( !options.areJPACallbacksEnabled() ) {\n+   35: \t\t\treturn new EmptyCallbackRegistryImpl();\n+   36: \t\t}\n+   37: \t\tfinal ManagedBeanRegistry beanRegistry = serviceRegistry.getService( ManagedBeanRegistry.class );\n+   38: \t\tfinal CallbackRegistryImpl.Builder registryBuilder = new CallbackRegistryImpl.Builder();\n+   39: \t\tfinal Set<Class<?>> entityClasses = new HashSet<>();\n+   40: \n+   41: \t\tfor ( PersistentClass persistentClass : entityBindings ) {\n+   42: \t\t\tif ( persistentClass.getClassName() != null ) {\n+   43: \t\t\t\tfinal Class<?> entityClass = persistentClass.getMappedClass();\n+   44: \t\t\t\tif ( !entityClasses.add( entityClass ) ) {\n+   45: \t\t\t\t\t// this most likely means we have a class mapped multiple\n+   46: \t\t\t\t\t// times using the hbm.xml \"entity name\" feature\n+   47: \t\t\t\t\tif ( log.isDebugEnabled() ) {\n+   48: \t\t\t\t\t\tlog.debugf(\n+   49: \t\t\t\t\t\t\t\t\"Class [%s] already has callbacks registered; \" +\n+   50: \t\t\t\t\t\t\t\t\"assuming this means the class was mapped twice \" +\n+   51: \t\t\t\t\t\t\t\t\"(using hbm.xml entity-name support) - skipping subsequent registrations\" +\n+   52: \t\t\t\t\t\t\t\t\"to avoid duplicates\",\n+   53: \t\t\t\t\t\t\t\tentityClass.getName()\n+   54: \t\t\t\t\t\t);\n+   55: \t\t\t\t\t}\n+   56: \t\t\t\t}\n+   57: \t\t\t\telse {\n+   58: \t\t\t\t\tregisterAllCallbacks( persistentClass, registryBuilder, entityClass, beanRegistry );\n    59: \t\t\t\t}\n-   60: \t\t\t\tcontinue;\n-   61: \t\t\t}\n-   62: \n-   63: \t\t\tregistryBuilder.registerCallbacks( persistentClass.getMappedClass(),\n-   64: \t\t\t\t\tbuildCallbacks( persistentClass.getCallbackDefinitions(), beanRegistry ) );\n-   65: \n-   66: \t\t\tfor ( Property property : persistentClass.getDeclaredProperties() ) {\n-   67: \t\t\t\tregistryBuilder.registerCallbacks( persistentClass.getMappedClass(),\n-   68: \t\t\t\t\t\tbuildCallbacks( property.getCallbackDefinitions(), beanRegistry ) );\n-   69: \t\t\t}\n-   70: \t\t}\n-   71: \n-   72: \t\treturn registryBuilder.build();\n-   73: \t}\n+   60: \t\t\t}\n+   61: \t\t\t// else we can have dynamic (non-java class) mapping\n+   62: \t\t}\n+   63: \n+   64: \t\treturn registryBuilder.build();\n+   65: \t}\n+   66: \n+   67: \tprivate static void registerAllCallbacks(\n+   68: \t\t\tPersistentClass persistentClass,\n+   69: \t\t\tCallbackRegistryImpl.Builder registryBuilder,\n+   70: \t\t\tClass<?> entityClass,\n+   71: \t\t\tManagedBeanRegistry beanRegistry) {\n+   72: \t\tregistryBuilder.registerCallbacks( entityClass,\n+   73: \t\t\t\tbuildCallbacks( persistentClass.getCallbackDefinitions(), beanRegistry ) );\n    74: \n-   75: \tprivate static Callback[] buildCallbacks(List<CallbackDefinition> callbackDefinitions,\n-   76: \t\t\tManagedBeanRegistry beanRegistry) {\n-   77: \t\tif ( callbackDefinitions == null || callbackDefinitions.isEmpty() ) {\n-   78: \t\t\treturn null;\n-   79: \t\t}\n+   75: \t\tfor ( Property property : persistentClass.getDeclaredProperties() ) {\n+   76: \t\t\tregistryBuilder.registerCallbacks( entityClass,\n+   77: \t\t\t\t\tbuildCallbacks( property.getCallbackDefinitions(), beanRegistry ) );\n+   78: \t\t}\n+   79: \t}\n",
        "uniqueId": "ddeaffc917fb82e84461691605baab7d12962cd2_32_73_67_79_32_65",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 6,
                "covered": 76
            },
            "BRANCH": {
                "missed": 1,
                "covered": 11
            },
            "LINE": {
                "missed": 2,
                "covered": 19
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 6
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\nprivate static void registerEntityCallbacks(PersistentClass persistentClass, CallbackRegistryImpl.Builder registryBuilder, ManagedBeanRegistry beanRegistry) {\n    Class<?> entityClass = persistentClass.getMappedClass();\n\n    if (!entityClasses.add(entityClass)) {\n        if (log.isDebugEnabled()) {\n            log.debugf(\n                    \"Class [%s] already has callbacks registered; \" +\n                            \"assuming this means the class was mapped twice \" +\n                            \"(using hbm.xml entity-name support) - skipping subsequent registrations\" +\n                            \"to avoid duplicates\",\n                    entityClass.getName()\n            );\n        }\n        return;\n    }\n\n    registryBuilder.registerCallbacks(persistentClass.getMappedClass(),\n            buildCallbacks(persistentClass.getCallbackDefinitions(), beanRegistry));\n\n    for (Property property : persistentClass.getDeclaredProperties()) {\n        registryBuilder.registerCallbacks(persistentClass.getMappedClass(),\n                buildCallbacks(property.getCallbackDefinitions(), beanRegistry));\n    }\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\npublic static CallbackRegistry buildCallbackRegistry(SessionFactoryOptions options, ServiceRegistry serviceRegistry, Collection<PersistentClass> entityBindings) {\n\t\tif ( !jpaCallBacksEnabled( options ) ) {\n\t\t\treturn new EmptyCallbackRegistryImpl();\n\t\t}\n\t\tManagedBeanRegistry beanRegistry = serviceRegistry.getService( ManagedBeanRegistry.class );\n\t\tCallbackRegistryImpl.Builder registryBuilder = new CallbackRegistryImpl.Builder();\n\t\tSet<Class<?>> entityClasses = new HashSet<>();\n\n\t\tfor ( PersistentClass persistentClass : entityBindings ) {\n\t\t\tif ( persistentClass.getClassName() == null ) {\n\t\t\t\t// we can have dynamic (non-java class) mapping\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tClass<?> entityClass = persistentClass.getMappedClass();\n\n\t\t\tif ( !entityClasses.add( entityClass ) ) {\n\t\t\t\t// this most likely means we have a class mapped multiple times using the hbm.xml\n\t\t\t\t// \"entity name\" feature\n\t\t\t\tif ( log.isDebugEnabled() ) {\n\t\t\t\t\tlog.debugf(\n\t\t\t\t\t\t\t\"Class [%s] already has callbacks registered; \" +\n\t\t\t\t\t\t\t\t\t\"assuming this means the class was mapped twice \" +\n\t\t\t\t\t\t\t\t\t\"(using hbm.xml entity-name support) - skipping subsequent registrations\" +\n\t\t\t\t\t\t\t\t\t\"to avoid duplicates\",\n\t\t\t\t\t\t\tentityClass.getName()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tregistryBuilder.registerCallbacks( persistentClass.getMappedClass(),\n\t\t\t\t\tbuildCallbacks( persistentClass.getCallbackDefinitions(), beanRegistry ) );\n\n\t\t\tfor ( Property property : persistentClass.getDeclaredProperties() ) {\n\t\t\t\tregistryBuilder.registerCallbacks( persistentClass.getMappedClass(),\n\t\t\t\t\t\tbuildCallbacks( property.getCallbackDefinitions(), beanRegistry ) );\n\t\t\t}\n\t\t}\n\n\t\treturn registryBuilder.build();\n\t}\n\nClass content:\n/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.jpa.event.internal;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.hibernate.boot.spi.SessionFactoryOptions;\nimport org.hibernate.jpa.event.spi.Callback;\nimport org.hibernate.jpa.event.spi.CallbackDefinition;\nimport org.hibernate.jpa.event.spi.CallbackRegistry;\nimport org.hibernate.mapping.PersistentClass;\nimport org.hibernate.mapping.Property;\nimport org.hibernate.resource.beans.spi.ManagedBeanRegistry;\nimport org.hibernate.service.ServiceRegistry;\n\nimport org.jboss.logging.Logger;\n\n/**\n * The intent of this class is to use a lighter implementation\n * when JPA callbacks are disabled via\n * {@link SessionFactoryOptions#areJPACallbacksEnabled()}\n */\npublic final class CallbacksFactory {\n\tprivate static final Logger log = Logger.getLogger( CallbacksFactory.class );\n\n\tpublic static CallbackRegistry buildCallbackRegistry(SessionFactoryOptions options, ServiceRegistry serviceRegistry, Collection<PersistentClass> entityBindings) {\n\t\tif ( !jpaCallBacksEnabled( options ) ) {\n\t\t\treturn new EmptyCallbackRegistryImpl();\n\t\t}\n\t\tManagedBeanRegistry beanRegistry = serviceRegistry.getService( ManagedBeanRegistry.class );\n\t\tCallbackRegistryImpl.Builder registryBuilder = new CallbackRegistryImpl.Builder();\n\t\tSet<Class<?>> entityClasses = new HashSet<>();\n\n\t\tfor ( PersistentClass persistentClass : entityBindings ) {\n\t\t\tif ( persistentClass.getClassName() == null ) {\n\t\t\t\t// we can have dynamic (non-java class) mapping\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tClass<?> entityClass = persistentClass.getMappedClass();\n\n\t\t\tif ( !entityClasses.add( entityClass ) ) {\n\t\t\t\t// this most likely means we have a class mapped multiple times using the hbm.xml\n\t\t\t\t// \"entity name\" feature\n\t\t\t\tif ( log.isDebugEnabled() ) {\n\t\t\t\t\tlog.debugf(\n\t\t\t\t\t\t\t\"Class [%s] already has callbacks registered; \" +\n\t\t\t\t\t\t\t\t\t\"assuming this means the class was mapped twice \" +\n\t\t\t\t\t\t\t\t\t\"(using hbm.xml entity-name support) - skipping subsequent registrations\" +\n\t\t\t\t\t\t\t\t\t\"to avoid duplicates\",\n\t\t\t\t\t\t\tentityClass.getName()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tregistryBuilder.registerCallbacks( persistentClass.getMappedClass(),\n\t\t\t\t\tbuildCallbacks( persistentClass.getCallbackDefinitions(), beanRegistry ) );\n\n\t\t\tfor ( Property property : persistentClass.getDeclaredProperties() ) {\n\t\t\t\tregistryBuilder.registerCallbacks( persistentClass.getMappedClass(),\n\t\t\t\t\t\tbuildCallbacks( property.getCallbackDefinitions(), beanRegistry ) );\n\t\t\t}\n\t\t}\n\n\t\treturn registryBuilder.build();\n\t}\n\n\tprivate static Callback[] buildCallbacks(List<CallbackDefinition> callbackDefinitions,\n\t\t\tManagedBeanRegistry beanRegistry) {\n\t\tif ( callbackDefinitions == null || callbackDefinitions.isEmpty() ) {\n\t\t\treturn null;\n\t\t}\n\t\tList<Callback> callbacks = new ArrayList<>();\n\t\tfor ( CallbackDefinition definition : callbackDefinitions ) {\n\t\t\tcallbacks.add( definition.createCallback( beanRegistry ) );\n\t\t}\n\t\treturn callbacks.toArray( new Callback[0] );\n\t}\n\n\tprivate static boolean jpaCallBacksEnabled(SessionFactoryOptions options) {\n\t\treturn options.areJPACallbacksEnabled();\n\t}\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate instantiateGeneratorBean(identifierValue SimpleValue, generatorStrategy String, configuration Map<String,Object>, context MetadataBuildingContext) : void extracted from private setGeneratorCreator(identifierValue SimpleValue, configuration Map<String,Object>, generatorStrategy String, context MetadataBuildingContext) : void in class org.hibernate.boot.model.internal.GeneratorBinder",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/boot/model/internal/GeneratorBinder.java",
                "startLine": 791,
                "endLine": 816,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/boot/model/internal/GeneratorBinder.java",
                "startLine": 749,
                "endLine": 765,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/boot/model/internal/GeneratorBinder.java",
                "startLine": 767,
                "endLine": 782,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n\t * Set up the {@link GeneratorCreator} for a case where there is no\n\t * generator annotation.\n\t */\n\tprivate static void setGeneratorCreator(\n\t\t\tSimpleValue identifierValue,\n\t\t\tMap<String, Object> configuration,\n\t\t\tString generatorStrategy,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( ASSIGNED_GENERATOR_NAME.equals( generatorStrategy )\n\t\t\t\t|| org.hibernate.id.Assigned.class.getName().equals( generatorStrategy ) ) {\n\t\t\tidentifierValue.setCustomIdGeneratorCreator( ASSIGNED_IDENTIFIER_GENERATOR_CREATOR );\n\t\t}\n\t\telse {\n\t\t\tfinal BeanContainer beanContainer = beanContainer( context );\n\t\t\tidentifierValue.setCustomIdGeneratorCreator( creationContext -> {\n\t\t\t\tfinal Generator identifierGenerator =\n\t\t\t\t\t\tinstantiateGenerator( beanContainer, generatorClass( generatorStrategy, identifierValue ) );\n\t\t\t\tcallConfigure( creationContext, identifierGenerator, configuration, identifierValue );\n\t\t\t\tif ( identifierGenerator instanceof IdentityGenerator) {\n\t\t\t\t\tidentifierValue.setColumnToIdentity();\n\t\t\t\t}\n\t\t\t\treturn identifierGenerator;\n\t\t\t} );\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/boot/model/internal/GeneratorBinder.java",
        "isPureRefactoring": true,
        "commitId": "800a3f0738db7294c9684de8bfe4edce99321acb",
        "packageNameBefore": "org.hibernate.boot.model.internal",
        "classNameBefore": "org.hibernate.boot.model.internal.GeneratorBinder",
        "methodNameBefore": "org.hibernate.boot.model.internal.GeneratorBinder#setGeneratorCreator",
        "invokedMethod": "methodSignature: org.hibernate.boot.model.internal.GeneratorBinder#callConfigure\n methodBody: public static void callConfigure(\n\t\t\tGeneratorCreationContext creationContext,\n\t\t\tGenerator generator,\n\t\t\tMap<String, Object> configuration,\n\t\t\tSimpleValue identifierValue) {\nif(generator instanceof Configurable configurable){final Properties parameters=collectParameters(identifierValue,creationContext.getDatabase().getDialect(),creationContext.getRootClass(),configuration);\nconfigurable.configure(creationContext,parameters);\n}if(generator instanceof ExportableProducer exportableProducer){exportableProducer.registerExportables(creationContext.getDatabase());\n}if(generator instanceof Configurable configurable){configurable.initialize(creationContext.getSqlStringGenerationContext());\n}}\nmethodSignature: org.hibernate.boot.model.internal.GeneratorBinder#beanContainer\n methodBody: public static BeanContainer beanContainer(MetadataBuildingContext buildingContext) {\nreturn Helper.getBeanContainer(buildingContext.getBootstrapContext().getServiceRegistry());\n}\nmethodSignature: org.hibernate.boot.model.internal.GeneratorBinder#instantiateGenerator\n methodBody: public static <T extends Generator> T instantiateGenerator(\n\t\t\tBeanContainer beanContainer,\n\t\t\tClass<T> generatorClass) {\nif(beanContainer != null){return instantiateGeneratorAsBean(beanContainer,generatorClass);\n}{return instantiateGeneratorViaDefaultConstructor(generatorClass);\n}}",
        "classSignatureBefore": "public class GeneratorBinder ",
        "methodNameBeforeSet": [
            "org.hibernate.boot.model.internal.GeneratorBinder#setGeneratorCreator"
        ],
        "classNameBeforeSet": [
            "org.hibernate.boot.model.internal.GeneratorBinder"
        ],
        "classSignatureBeforeSet": [
            "public class GeneratorBinder "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.boot.model.internal;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Member;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.function.BiConsumer;\nimport java.util.function.Consumer;\n\nimport org.hibernate.AnnotationException;\nimport org.hibernate.AssertionFailure;\nimport org.hibernate.MappingException;\nimport org.hibernate.annotations.GenericGenerator;\nimport org.hibernate.annotations.IdGeneratorType;\nimport org.hibernate.annotations.ValueGenerationType;\nimport org.hibernate.boot.model.IdentifierGeneratorDefinition;\nimport org.hibernate.boot.model.relational.ExportableProducer;\nimport org.hibernate.boot.model.source.internal.hbm.MappingDocument;\nimport org.hibernate.boot.models.spi.GlobalRegistrar;\nimport org.hibernate.boot.spi.InFlightMetadataCollector;\nimport org.hibernate.boot.spi.MetadataBuildingContext;\nimport org.hibernate.boot.spi.PropertyData;\nimport org.hibernate.generator.AnnotationBasedGenerator;\nimport org.hibernate.generator.Assigned;\nimport org.hibernate.generator.BeforeExecutionGenerator;\nimport org.hibernate.generator.Generator;\nimport org.hibernate.generator.GeneratorCreationContext;\nimport org.hibernate.generator.OnExecutionGenerator;\nimport org.hibernate.id.Configurable;\nimport org.hibernate.id.IdentifierGenerator;\nimport org.hibernate.id.IdentityGenerator;\nimport org.hibernate.id.PersistentIdentifierGenerator;\nimport org.hibernate.id.enhanced.SequenceStyleGenerator;\nimport org.hibernate.id.uuid.UuidValueGenerator;\nimport org.hibernate.internal.CoreLogging;\nimport org.hibernate.internal.CoreMessageLogger;\nimport org.hibernate.internal.util.StringHelper;\nimport org.hibernate.mapping.GeneratorCreator;\nimport org.hibernate.mapping.KeyValue;\nimport org.hibernate.mapping.PersistentClass;\nimport org.hibernate.mapping.SimpleValue;\nimport org.hibernate.models.spi.AnnotationTarget;\nimport org.hibernate.models.spi.MemberDetails;\nimport org.hibernate.models.spi.SourceModelBuildingContext;\nimport org.hibernate.resource.beans.container.spi.BeanContainer;\nimport org.hibernate.resource.beans.internal.Helper;\n\nimport jakarta.persistence.GeneratedValue;\nimport jakarta.persistence.GenerationType;\nimport jakarta.persistence.SequenceGenerator;\nimport jakarta.persistence.TableGenerator;\nimport jakarta.persistence.Version;\n\nimport static jakarta.persistence.GenerationType.AUTO;\nimport static java.util.Collections.emptyMap;\nimport static org.hibernate.boot.model.internal.AnnotationHelper.extractParameterMap;\nimport static org.hibernate.boot.model.internal.BinderHelper.getPath;\nimport static org.hibernate.boot.model.internal.BinderHelper.isGlobalGeneratorNameGlobal;\nimport static org.hibernate.boot.model.internal.GeneratorParameters.collectParameters;\nimport static org.hibernate.boot.model.internal.GeneratorParameters.interpretSequenceGenerator;\nimport static org.hibernate.boot.model.internal.GeneratorParameters.interpretTableGenerator;\nimport static org.hibernate.boot.model.internal.GeneratorStrategies.generatorClass;\nimport static org.hibernate.id.IdentifierGenerator.GENERATOR_NAME;\nimport static org.hibernate.internal.util.NullnessUtil.castNonNull;\nimport static org.hibernate.internal.util.StringHelper.qualify;\nimport static org.hibernate.internal.util.collections.CollectionHelper.combineUntyped;\nimport static org.hibernate.resource.beans.internal.Helper.allowExtensionsInCdi;\n\n/**\n * Responsible for configuring and instantiating {@link Generator}s.\n *\n * @author Gavin King\n */\npublic class GeneratorBinder {\n\n\tprivate static final CoreMessageLogger LOG = CoreLogging.messageLogger( GeneratorBinder.class );\n\n\tpublic static final String ASSIGNED_GENERATOR_NAME = \"assigned\";\n\tpublic static final GeneratorCreator ASSIGNED_IDENTIFIER_GENERATOR_CREATOR =\n\t\t\tnew GeneratorCreator() {\n\t\t\t\t@Override\n\t\t\t\tpublic Generator createGenerator(GeneratorCreationContext context) {\n\t\t\t\t\treturn new Assigned();\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic boolean isAssigned() {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t};\n\n\t/**\n\t * Create a generator, based on a {@link GeneratedValue} annotation.\n\t */\n\tpublic static void makeIdGenerator(\n\t\t\tSimpleValue identifierValue,\n\t\t\tMemberDetails idAttributeMember,\n\t\t\tString generatorType,\n\t\t\tString generatorName,\n\t\t\tMetadataBuildingContext context,\n\t\t\tMap<String, ? extends IdentifierGeneratorDefinition> localGenerators) {\n\n\t\t//generator settings\n\t\tfinal Map<String,Object> configuration = new HashMap<>();\n\t\tconfiguration.put( GENERATOR_NAME, generatorName );\n\t\tconfiguration.put( PersistentIdentifierGenerator.TABLE, identifierValue.getTable().getName() );\n\t\tif ( identifierValue.getColumnSpan() == 1 ) {\n\t\t\tconfiguration.put( PersistentIdentifierGenerator.PK, identifierValue.getColumns().get(0).getName() );\n\t\t}\n\n\t\tif ( generatorName.isEmpty() ) {\n\t\t\tfinal GeneratedValue generatedValue = idAttributeMember.getDirectAnnotationUsage( GeneratedValue.class );\n\t\t\tif ( generatedValue != null ) {\n\t\t\t\t// The mapping used @GeneratedValue but specified no name.  This is a special case added in JPA 3.2.\n\t\t\t\t// Look for a matching \"implied generator\" based on the GenerationType\n\n\t\t\t\tfinal GenerationType strategy = generatedValue.strategy();\n\t\t\t\tfinal String strategyGeneratorClassName = correspondingGeneratorName( strategy );\n\n\t\t\t\tfinal IdentifierGeneratorDefinition impliedGenerator = determineImpliedGenerator(\n\t\t\t\t\t\tstrategy,\n\t\t\t\t\t\tstrategyGeneratorClassName,\n\t\t\t\t\t\tlocalGenerators\n\t\t\t\t);\n\n\t\t\t\tif ( impliedGenerator != null ) {\n\t\t\t\t\tconfiguration.putAll( impliedGenerator.getParameters() );\n\n\t\t\t\t\tfinal BeanContainer beanContainer = beanContainer( context );\n\t\t\t\t\tidentifierValue.setCustomIdGeneratorCreator( creationContext -> {\n\t\t\t\t\t\tfinal Generator identifierGenerator = instantiateGenerator(\n\t\t\t\t\t\t\t\tbeanContainer,\n\t\t\t\t\t\t\t\tgeneratorClass( strategyGeneratorClassName, identifierValue )\n\t\t\t\t\t\t);\n\t\t\t\t\t\tcallConfigure( creationContext, identifierGenerator, configuration, identifierValue );\n\t\t\t\t\t\tif ( identifierGenerator instanceof IdentityGenerator) {\n\t\t\t\t\t\t\tidentifierValue.setColumnToIdentity();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn identifierGenerator;\n\t\t\t\t\t} );\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfinal String generatorStrategy = determineStrategy(\n\t\t\t\tidAttributeMember,\n\t\t\t\tgeneratorType,\n\t\t\t\tgeneratorName,\n\t\t\t\tcontext,\n\t\t\t\tlocalGenerators,\n\t\t\t\tconfiguration\n\t\t);\n\t\tsetGeneratorCreator( identifierValue, configuration, generatorStrategy, context );\n\t}\n\n\tprivate static IdentifierGeneratorDefinition determineImpliedGenerator(\n\t\t\tGenerationType strategy,\n\t\t\tString strategyGeneratorClassName,\n\t\t\tMap<String, ? extends IdentifierGeneratorDefinition> localGenerators) {\n\t\tif ( localGenerators == null ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( localGenerators.size() == 1 ) {\n\t\t\tfinal IdentifierGeneratorDefinition generatorDefinition = localGenerators.entrySet().iterator().next().getValue();\n\t\t\t// NOTE : a little bit of a special rule here for the case of just one -\n\t\t\t// \t\twe consider it a match, based on strategy, if the strategy is AUTO or matches...\n\t\t\tif ( strategy == AUTO\n\t\t\t\t\t|| isImpliedGenerator( strategy, strategyGeneratorClassName, generatorDefinition ) ) {\n\t\t\t\treturn generatorDefinition;\n\t\t\t}\n\t\t}\n\n\t\tIdentifierGeneratorDefinition matching = null;\n\t\tfor ( Map.Entry<String, ? extends IdentifierGeneratorDefinition> localGeneratorEntry : localGenerators.entrySet() ) {\n\t\t\tif ( isImpliedGenerator( strategy, strategyGeneratorClassName, localGeneratorEntry.getValue() ) ) {\n\t\t\t\tif ( matching != null ) {\n\t\t\t\t\t// we found multiple matching generators\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tmatching = localGeneratorEntry.getValue();\n\t\t\t}\n\t\t}\n\t\treturn matching;\n\t}\n\n\tprivate static boolean isImpliedGenerator(\n\t\t\tGenerationType strategy,\n\t\t\tString strategyGeneratorClassName,\n\t\t\tIdentifierGeneratorDefinition generatorDefinition) {\n\t\treturn generatorDefinition.getStrategy().equals( strategyGeneratorClassName );\n\t}\n\n\tprivate static String correspondingGeneratorName(GenerationType strategy) {\n\t\treturn switch ( strategy ) {\n//\t\t\tcase UUID -> org.hibernate.id.uuid.UuidGenerator.class.getName();\n\t\t\tcase UUID -> UuidValueGenerator.class.getName();\n\t\t\tcase TABLE -> org.hibernate.id.enhanced.TableGenerator.class.getName();\n\t\t\tcase IDENTITY -> null;\n\t\t\tdefault -> SequenceStyleGenerator.class.getName();\n\t\t};\n\t}\n\n\tprivate static String determineStrategy(\n\t\t\tMemberDetails idAttributeMember,\n\t\t\tString generatorType,\n\t\t\tString generatorName,\n\t\t\tMetadataBuildingContext context,\n\t\t\tMap<String, ? extends IdentifierGeneratorDefinition> localGenerators,\n\t\t\tMap<String, Object> configuration) {\n\t\tif ( !generatorName.isEmpty() ) {\n\t\t\t//we have a named generator\n\t\t\tfinal IdentifierGeneratorDefinition definition =\n\t\t\t\t\tmakeIdentifierGeneratorDefinition( generatorName, idAttributeMember, localGenerators, context );\n\t\t\tif ( definition == null ) {\n\t\t\t\tthrow new AnnotationException( \"No id generator was declared with the name '\" + generatorName\n\t\t\t\t\t\t+ \"' specified by '@GeneratedValue'\"\n\t\t\t\t\t\t+ \" (define a named generator using '@SequenceGenerator', '@TableGenerator', or '@GenericGenerator')\" );\n\t\t\t}\n\t\t\t//This is quite vague in the spec but a generator could override the generator choice\n\t\t\tfinal String generatorStrategy =\n\t\t\t\t\tgeneratorType == null\n\t\t\t\t\t\t//yuk! this is a hack not to override 'AUTO' even if generator is set\n\t\t\t\t\t\t|| !definition.getStrategy().equals( \"identity\" )\n\t\t\t\t\t\t\t? definition.getStrategy()\n\t\t\t\t\t\t\t: generatorType;\n\t\t\t//checkIfMatchingGenerator(definition, generatorType, generatorName);\n\t\t\tconfiguration.putAll( definition.getParameters() );\n\t\t\treturn generatorStrategy;\n\t\t}\n\t\telse {\n\t\t\treturn generatorType;\n\t\t}\n\t}\n\n\tprivate static IdentifierGeneratorDefinition makeIdentifierGeneratorDefinition(\n\t\t\tString name,\n\t\t\tMemberDetails idAttributeMember,\n\t\t\tMap<String, ? extends IdentifierGeneratorDefinition> localGenerators,\n\t\t\tMetadataBuildingContext buildingContext) {\n\t\tif ( localGenerators != null ) {\n\t\t\tfinal IdentifierGeneratorDefinition result = localGenerators.get( name );\n\t\t\tif ( result != null ) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tfinal IdentifierGeneratorDefinition globalDefinition =\n\t\t\t\tbuildingContext.getMetadataCollector().getIdentifierGenerator( name );\n\t\tif ( globalDefinition != null ) {\n\t\t\treturn globalDefinition;\n\t\t}\n\n\t\tLOG.debugf( \"Could not resolve explicit IdentifierGeneratorDefinition - using implicit interpretation (%s)\", name );\n\n\t\tfinal GeneratedValue generatedValue = idAttributeMember.getDirectAnnotationUsage( GeneratedValue.class );\n\t\tif ( generatedValue == null ) {\n\t\t\tthrow new AssertionFailure( \"No @GeneratedValue annotation\" );\n\t\t}\n\n\t\treturn IdentifierGeneratorDefinition.createImplicit(\n\t\t\t\tname,\n\t\t\t\tidAttributeMember.getType(),\n\t\t\t\tgeneratedValue.generator(),\n\t\t\t\tinterpretGenerationType( generatedValue )\n\t\t);\n\t}\n\n\tprivate static GenerationType interpretGenerationType(GeneratedValue generatedValueAnn) {\n\t\t// todo (jpa32) : when can this ever be null?\n\t\tfinal GenerationType strategy = generatedValueAnn.strategy();\n\t\treturn strategy == null ? AUTO : strategy;\n\t}\n\n\tpublic static void visitIdGeneratorDefinitions(\n\t\t\tAnnotationTarget annotatedElement,\n\t\t\tConsumer<IdentifierGeneratorDefinition> consumer,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal InFlightMetadataCollector metadataCollector = context.getMetadataCollector();\n\t\tfinal SourceModelBuildingContext sourceModelContext = metadataCollector.getSourceModelBuildingContext();\n\n\t\tannotatedElement.forEachAnnotationUsage( TableGenerator.class, sourceModelContext, (usage) -> {\n\t\t\tfinal IdentifierGeneratorDefinition idGenerator = buildTableIdGenerator( usage );\n\t\t\tconsumer.accept( idGenerator );\n\t\t} );\n\n\t\tannotatedElement.forEachAnnotationUsage( SequenceGenerator.class, sourceModelContext, (usage) -> {\n\t\t\tfinal IdentifierGeneratorDefinition idGenerator = buildSequenceIdGenerator( usage );\n\t\t\tconsumer.accept( idGenerator );\n\t\t} );\n\n\t\tannotatedElement.forEachAnnotationUsage( GenericGenerator.class, sourceModelContext, (usage) -> {\n\t\t\tfinal IdentifierGeneratorDefinition idGenerator = buildIdGenerator( usage );\n\t\t\tconsumer.accept( idGenerator );\n\t\t} );\n\n\t}\n\n\tpublic static void registerGlobalGenerators(\n\t\t\tAnnotationTarget annotatedElement,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( !context.getBootstrapContext().getJpaCompliance().isGlobalGeneratorScopeEnabled() ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal InFlightMetadataCollector metadataCollector = context.getMetadataCollector();\n\t\tvisitIdGeneratorDefinitions(\n\t\t\t\tannotatedElement,\n\t\t\t\t(definition) -> {\n\t\t\t\t\tif ( !definition.getName().isEmpty() ) {\n\t\t\t\t\t\tmetadataCollector.addIdentifierGenerator( definition );\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tcontext\n\t\t);\n\t}\n\n\tprivate static IdentifierGeneratorDefinition buildIdGenerator(GenericGenerator generatorAnnotation) {\n\t\tfinal IdentifierGeneratorDefinition.Builder definitionBuilder =\n\t\t\t\tnew IdentifierGeneratorDefinition.Builder();\n\t\tdefinitionBuilder.setName( generatorAnnotation.name() );\n\t\tfinal Class<? extends Generator> generatorClass = generatorAnnotation.type();\n\t\tfinal String strategy =\n\t\t\t\tgeneratorClass.equals( Generator.class )\n\t\t\t\t\t\t? generatorAnnotation.strategy()\n\t\t\t\t\t\t: generatorClass.getName();\n\t\tdefinitionBuilder.setStrategy( strategy );\n\t\tdefinitionBuilder.addParams( extractParameterMap( generatorAnnotation.parameters() ) );\n\n\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\tLOG.tracev( \"Added generator with name: {0}, strategy: {0}\",\n\t\t\t\t\tdefinitionBuilder.getName(), definitionBuilder.getStrategy() );\n\t\t}\n\n\t\treturn definitionBuilder.build();\n\t}\n\n\tprivate static IdentifierGeneratorDefinition buildSequenceIdGenerator(SequenceGenerator generatorAnnotation) {\n\t\tfinal IdentifierGeneratorDefinition.Builder definitionBuilder = new IdentifierGeneratorDefinition.Builder();\n\t\tinterpretSequenceGenerator( generatorAnnotation, definitionBuilder );\n\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\tLOG.tracev( \"Add sequence generator with name: {0}\", definitionBuilder.getName() );\n\t\t}\n\t\treturn definitionBuilder.build();\n\t}\n\n\tprivate static IdentifierGeneratorDefinition buildTableIdGenerator(TableGenerator generatorAnnotation) {\n\t\tfinal IdentifierGeneratorDefinition.Builder definitionBuilder = new IdentifierGeneratorDefinition.Builder();\n\t\tinterpretTableGenerator( generatorAnnotation, definitionBuilder );\n\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\tLOG.tracev( \"Add sequence generator with name: {0}\", definitionBuilder.getName() );\n\t\t}\n\t\treturn definitionBuilder.build();\n\t}\n\n\tprivate static void checkGeneratorClass(Class<? extends Generator> generatorClass) {\n\t\tif ( !BeforeExecutionGenerator.class.isAssignableFrom( generatorClass )\n\t\t\t\t&& !OnExecutionGenerator.class.isAssignableFrom( generatorClass ) ) {\n\t\t\tthrow new MappingException(\"Generator class '\" + generatorClass.getName()\n\t\t\t\t\t+ \"' must implement either 'BeforeExecutionGenerator' or 'OnExecutionGenerator'\");\n\t\t}\n\t}\n\n\tprivate static void checkGeneratorInterfaces(Class<? extends Generator> generatorClass) {\n\t\t// we don't yet support the additional \"fancy\" operations of\n\t\t// IdentifierGenerator with regular generators, though this\n\t\t// would be extremely easy to add if anyone asks for it\n\t\tif ( IdentifierGenerator.class.isAssignableFrom( generatorClass ) ) {\n\t\t\tthrow new AnnotationException(\"Generator class '\" + generatorClass.getName()\n\t\t\t\t\t+ \"' implements 'IdentifierGenerator' and may not be used with '@ValueGenerationType'\");\n\t\t}\n\t\tif ( ExportableProducer.class.isAssignableFrom( generatorClass ) ) {\n\t\t\tthrow new AnnotationException(\"Generator class '\" + generatorClass.getName()\n\t\t\t\t\t+ \"' implements 'ExportableProducer' and may not be used with '@ValueGenerationType'\");\n\t\t}\n\t}\n\n\t/**\n\t * Return a {@link GeneratorCreator} for an attribute annotated\n\t * with a {@linkplain ValueGenerationType generator annotation}.\n\t */\n\tprivate static GeneratorCreator generatorCreator(\n\t\t\tMemberDetails memberDetails,\n\t\t\tAnnotation annotation,\n\t\t\tBeanContainer beanContainer) {\n\t\tfinal Class<? extends Annotation> annotationType = annotation.annotationType();\n\t\tfinal ValueGenerationType generatorAnnotation = annotationType.getAnnotation( ValueGenerationType.class );\n\t\tassert generatorAnnotation != null;\n\t\tfinal Class<? extends Generator> generatorClass = generatorAnnotation.generatedBy();\n\t\tcheckGeneratorClass( generatorClass );\n\t\tcheckGeneratorInterfaces( generatorClass );\n\t\treturn creationContext -> {\n\t\t\tfinal Generator generator = instantiateGenerator(\n\t\t\t\t\tannotation,\n\t\t\t\t\tbeanContainer,\n\t\t\t\t\tcreationContext,\n\t\t\t\t\tgeneratorClass,\n\t\t\t\t\tmemberDetails,\n\t\t\t\t\tannotationType\n\t\t\t);\n\t\t\tcallInitialize( annotation, memberDetails, creationContext, generator );\n\t\t\t//TODO: callConfigure( creationContext, generator, emptyMap(), identifierValue );\n\t\t\tcheckVersionGenerationAlways( memberDetails, generator );\n\t\t\treturn generator;\n\t\t};\n\t}\n\n\t/**\n\t * Return a {@link GeneratorCreator} for an id attribute annotated\n\t * with an {@linkplain IdGeneratorType id generator annotation}.\n\t */\n\tprivate static GeneratorCreator identifierGeneratorCreator(\n\t\t\tMemberDetails idAttributeMember,\n\t\t\tAnnotation annotation,\n\t\t\tSimpleValue identifierValue,\n\t\t\tBeanContainer beanContainer) {\n\t\tfinal Class<? extends Annotation> annotationType = annotation.annotationType();\n\t\tfinal IdGeneratorType idGeneratorAnnotation = annotationType.getAnnotation( IdGeneratorType.class );\n\t\tassert idGeneratorAnnotation != null;\n\t\tfinal Class<? extends Generator> generatorClass = idGeneratorAnnotation.value();\n\t\tcheckGeneratorClass( generatorClass );\n\t\treturn creationContext -> {\n\t\t\tfinal Generator generator =\n\t\t\t\t\tinstantiateGenerator(\n\t\t\t\t\t\t\tannotation,\n\t\t\t\t\t\t\tbeanContainer,\n\t\t\t\t\t\t\tcreationContext,\n\t\t\t\t\t\t\tgeneratorClass,\n\t\t\t\t\t\t\tidAttributeMember,\n\t\t\t\t\t\t\tannotationType\n\t\t\t\t\t);\n\t\t\tcallInitialize( annotation, idAttributeMember, creationContext, generator );\n\t\t\tcallConfigure( creationContext, generator, emptyMap(), identifierValue );\n\t\t\tcheckIdGeneratorTiming( annotationType, generator );\n\t\t\treturn generator;\n\t\t};\n\t}\n\n\t/**\n\t * Instantiate a {@link Generator}, using the given {@link BeanContainer} if any,\n\t * for the case where the generator was specified using a generator annotation.\n\t *\n\t * @param annotation the generator annotation\n\t * @param beanContainer an optional {@code BeanContainer}\n\t * @param generatorClass a class which implements {@code Generator}\n\t */\n\tprivate static Generator instantiateGenerator(\n\t\t\tAnnotation annotation,\n\t\t\tBeanContainer beanContainer,\n\t\t\tGeneratorCreationContext creationContext,\n\t\t\tClass<? extends Generator> generatorClass,\n\t\t\tMemberDetails memberDetails,\n\t\t\tClass<? extends Annotation> annotationType) {\n\t\tif ( beanContainer != null ) {\n\t\t\treturn instantiateGeneratorAsBean(\n\t\t\t\t\tannotation,\n\t\t\t\t\tbeanContainer,\n\t\t\t\t\tcreationContext,\n\t\t\t\t\tgeneratorClass,\n\t\t\t\t\tmemberDetails,\n\t\t\t\t\tannotationType\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn instantiateGenerator(\n\t\t\t\t\tannotation,\n\t\t\t\t\tmemberDetails,\n\t\t\t\t\tannotationType,\n\t\t\t\t\tcreationContext,\n\t\t\t\t\tgeneratorClass\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Instantiate a {@link Generator}, using the given {@link BeanContainer},\n\t * for the case where the generator was specified using a generator annotation.\n\t *\n\t * @param annotation the generator annotation\n\t * @param beanContainer an optional {@code BeanContainer}\n\t * @param generatorClass a class which implements {@code Generator}\n\t */\n\tprivate static Generator instantiateGeneratorAsBean(\n\t\t\tAnnotation annotation,\n\t\t\tBeanContainer beanContainer,\n\t\t\tGeneratorCreationContext creationContext,\n\t\t\tClass<? extends Generator> generatorClass,\n\t\t\tMemberDetails memberDetails,\n\t\t\tClass<? extends Annotation> annotationType) {\n\t\treturn Helper.getBean(\n\t\t\tbeanContainer,\n\t\t\tgeneratorClass,\n\t\t\tfalse,\n\t\t\ttrue,\n\t\t\t() -> instantiateGenerator(\n\t\t\t\tannotation,\n\t\t\t\tmemberDetails,\n\t\t\t\tannotationType,\n\t\t\t\tcreationContext,\n\t\t\t\tgeneratorClass\n\t\t\t)\n\t\t);\n\t}\n\n\t/**\n\t * Instantiate a {@link Generator}, using the given {@link BeanContainer},\n\t * for the case where no generator annotation is available.\n\t *\n\t * @param beanContainer an optional {@code BeanContainer}\n\t * @param generatorClass a class which implements {@code Generator}\n\t */\n\tprivate static <T extends Generator> T instantiateGeneratorAsBean(\n\t\t\tBeanContainer beanContainer,\n\t\t\tClass<T> generatorClass) {\n\t\treturn Helper.getBean(\n\t\t\tbeanContainer,\n\t\t\tgeneratorClass,\n\t\t\tfalse,\n\t\t\ttrue,\n\t\t\t() -> instantiateGeneratorViaDefaultConstructor( generatorClass )\n\t\t);\n\t}\n\n\t/**\n\t * Instantiate a {@link Generator} by calling an appropriate constructor,\n\t * for the case where the generator was specified using a generator annotation.\n\t * We look for three possible signatures:\n\t * <ol>\n\t *     <li>{@code (Annotation, Member, GeneratorCreationContext)}</li>\n\t *     <li>{@code (Annotation)}</li>\n\t *     <li>{@code ()}</li>\n\t * </ol>\n\t * where {@code Annotation} is the generator annotation type.\n\t *\n\t * @param annotation the generator annotation\n\t * @param generatorClass a class which implements {@code Generator}\n\t */\n\tprivate static <G extends Generator> G instantiateGenerator(\n\t\t\tAnnotation annotation,\n\t\t\tMemberDetails memberDetails,\n\t\t\tClass<? extends Annotation> annotationType,\n\t\t\tGeneratorCreationContext creationContext,\n\t\t\tClass<? extends G> generatorClass) {\n\t\ttry {\n\t\t\ttry {\n\t\t\t\treturn generatorClass.getConstructor( annotationType, Member.class, GeneratorCreationContext.class )\n\t\t\t\t\t\t.newInstance( annotation, memberDetails.toJavaMember(), creationContext);\n\t\t\t}\n\t\t\tcatch (NoSuchMethodException ignore) {\n\t\t\t\ttry {\n\t\t\t\t\treturn generatorClass.getConstructor( annotationType )\n\t\t\t\t\t\t\t.newInstance( annotation );\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchMethodException i) {\n\t\t\t\t\treturn instantiateGeneratorViaDefaultConstructor( generatorClass );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (InvocationTargetException | InstantiationException | IllegalAccessException | IllegalArgumentException e) {\n\t\t\tthrow new org.hibernate.InstantiationException( \"Could not instantiate id generator\", generatorClass, e );\n\t\t}\n\t}\n\n\t/**\n\t * Instantiate a {@link Generator}, using the given {@link BeanContainer} if any,\n\t * or by calling the default constructor otherwise.\n\t *\n\t * @param beanContainer an optional {@code BeanContainer}\n\t * @param generatorClass a class which implements {@code Generator}\n\t */\n\tpublic static <T extends Generator> T instantiateGenerator(\n\t\t\tBeanContainer beanContainer,\n\t\t\tClass<T> generatorClass) {\n\t\tif ( beanContainer != null ) {\n\t\t\treturn instantiateGeneratorAsBean( beanContainer, generatorClass );\n\t\t}\n\t\telse {\n\t\t\treturn instantiateGeneratorViaDefaultConstructor( generatorClass );\n\t\t}\n\t}\n\n\t/**\n\t * Instantiate a {@link Generator} by calling the default constructor.\n\t */\n\tprivate static <G extends Generator> G instantiateGeneratorViaDefaultConstructor(Class<? extends G> generatorClass) {\n\t\ttry {\n\t\t\treturn generatorClass.getDeclaredConstructor().newInstance();\n\t\t}\n\t\tcatch (NoSuchMethodException e) {\n\t\t\tthrow new org.hibernate.InstantiationException( \"No appropriate constructor for id generator class\", generatorClass);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new org.hibernate.InstantiationException( \"Could not instantiate id generator\", generatorClass, e );\n\t\t}\n\t}\n\n\tpublic static <A extends Annotation> void callInitialize(\n\t\t\tA annotation,\n\t\t\tMemberDetails memberDetails,\n\t\t\tGeneratorCreationContext creationContext,\n\t\t\tGenerator generator) {\n\t\tif ( generator instanceof AnnotationBasedGenerator ) {\n\t\t\t// This will cause a CCE in case the generation type doesn't match the annotation type; As this would be\n\t\t\t// a programming error of the generation type developer and thus should show up during testing, we don't\n\t\t\t// check this explicitly; If required, this could be done e.g. using ClassMate\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tfinal AnnotationBasedGenerator<A> generation = (AnnotationBasedGenerator<A>) generator;\n\t\t\tgeneration.initialize( annotation, memberDetails.toJavaMember(), creationContext );\n\t\t}\n\t}\n\n\tprivate static void checkVersionGenerationAlways(MemberDetails property, Generator generator) {\n\t\tif ( property.hasDirectAnnotationUsage( Version.class ) ) {\n\t\t\tif ( !generator.generatesOnInsert() ) {\n\t\t\t\tthrow new AnnotationException(\"Property '\" + property.getName()\n\t\t\t\t\t\t+ \"' is annotated '@Version' but has a 'Generator' which does not generate on inserts\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( !generator.generatesOnUpdate() ) {\n\t\t\t\tthrow new AnnotationException(\"Property '\" + property.getName()\n\t\t\t\t\t\t+ \"' is annotated '@Version' but has a 'Generator' which does not generate on updates\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * If the given {@link Generator} also implements {@link Configurable},\n\t * call its {@link Configurable#configure(GeneratorCreationContext, Properties)\n\t * configure()} method.\n\t */\n\tpublic static void callConfigure(\n\t\t\tGeneratorCreationContext creationContext,\n\t\t\tGenerator generator,\n\t\t\tMap<String, Object> configuration,\n\t\t\tSimpleValue identifierValue) {\n\t\tif ( generator instanceof Configurable configurable ) {\n\t\t\tfinal Properties parameters = collectParameters(\n\t\t\t\t\tidentifierValue,\n\t\t\t\t\tcreationContext.getDatabase().getDialect(),\n\t\t\t\t\tcreationContext.getRootClass(),\n\t\t\t\t\tconfiguration\n\t\t\t);\n\t\t\tconfigurable.configure( creationContext, parameters );\n\t\t}\n\t\tif ( generator instanceof ExportableProducer exportableProducer ) {\n\t\t\texportableProducer.registerExportables( creationContext.getDatabase() );\n\t\t}\n\t\tif ( generator instanceof Configurable configurable ) {\n\t\t\tconfigurable.initialize( creationContext.getSqlStringGenerationContext() );\n\t\t}\n\t}\n\n\tprivate static void checkIdGeneratorTiming(Class<? extends Annotation> annotationType, Generator generator) {\n\t\tif ( !generator.generatesOnInsert() ) {\n\t\t\tthrow new MappingException( \"Annotation '\" + annotationType\n\t\t\t\t\t+ \"' is annotated 'IdGeneratorType' but the given 'Generator' does not generate on inserts\");\n\t\t}\n\t\tif ( generator.generatesOnUpdate() ) {\n\t\t\tthrow new MappingException( \"Annotation '\" + annotationType\n\t\t\t\t\t+ \"' is annotated 'IdGeneratorType' but the given 'Generator' generates on updates (it must generate only on inserts)\");\n\t\t}\n\t}\n\n\t/**\n\t * Create a generator, based on a {@link GeneratedValue} annotation.\n\t */\n\tprivate static void createIdGenerator(\n\t\t\tMemberDetails idMember,\n\t\t\tSimpleValue idValue,\n\t\t\tPersistentClass persistentClass,\n\t\t\tMetadataBuildingContext context) {\n\t\t// NOTE: `generatedValue` is never null here\n\t\tfinal GeneratedValue generatedValue = castNonNull( idMember.getDirectAnnotationUsage( GeneratedValue.class ) );\n\n\t\tfinal InFlightMetadataCollector metadataCollector = context.getMetadataCollector();\n\t\tif ( isGlobalGeneratorNameGlobal( context ) ) {\n\t\t\t// process and register any generators defined on the member.\n\t\t\t// according to JPA these are also global.\n\t\t\tmetadataCollector.getGlobalRegistrations().as( GlobalRegistrar.class ).collectIdGenerators( idMember );\n\t\t\tmetadataCollector.addSecondPass( new StrictIdGeneratorResolverSecondPass(\n\t\t\t\t\tpersistentClass,\n\t\t\t\t\tidValue,\n\t\t\t\t\tidMember,\n\t\t\t\t\tgeneratedValue,\n\t\t\t\t\tcontext\n\t\t\t) );\n\t\t}\n\t\telse {\n\t\t\tmetadataCollector.addSecondPass( new IdGeneratorResolverSecondPass(\n\t\t\t\t\tpersistentClass,\n\t\t\t\t\tidValue,\n\t\t\t\t\tidMember,\n\t\t\t\t\tgeneratedValue,\n\t\t\t\t\tcontext\n\t\t\t) );\n\t\t}\n\t}\n\n\tpublic static void createGeneratorFrom(\n\t\t\tIdentifierGeneratorDefinition defaultedGenerator,\n\t\t\tSimpleValue idValue,\n\t\t\tMap<String, Object> configuration,\n\t\t\tMetadataBuildingContext context) {\n\t\tconfiguration.putAll( defaultedGenerator.getParameters() );\n\n\t\tfinal BeanContainer beanContainer = beanContainer( context );\n\t\tidValue.setCustomIdGeneratorCreator( creationContext -> {\n\t\t\tfinal Generator identifierGenerator = instantiateGenerator(\n\t\t\t\t\tbeanContainer,\n\t\t\t\t\tgeneratorClass( defaultedGenerator.getStrategy(), idValue )\n\t\t\t);\n\t\t\tcallConfigure( creationContext, identifierGenerator, configuration, idValue );\n\t\t\tif ( identifierGenerator instanceof IdentityGenerator) {\n\t\t\t\tidValue.setColumnToIdentity();\n\t\t\t}\n\t\t\treturn identifierGenerator;\n\t\t} );\n\t}\n\n\n\tpublic static void createGeneratorFrom(\n\t\t\tIdentifierGeneratorDefinition defaultedGenerator,\n\t\t\tSimpleValue idValue,\n\t\t\tMetadataBuildingContext context) {\n\t\tcreateGeneratorFrom(\n\t\t\t\tdefaultedGenerator,\n\t\t\t\tidValue,\n\t\t\t\tbuildConfigurationMap( idValue ),\n\t\t\t\tcontext\n\t\t);\n\t}\n\n\tprivate static Map<String, Object> buildConfigurationMap(KeyValue idValue) {\n\t\tfinal Map<String,Object> configuration = new HashMap<>();\n\t\tconfiguration.put( PersistentIdentifierGenerator.TABLE, idValue.getTable().getName() );\n\t\tif ( idValue.getColumnSpan() == 1 ) {\n\t\t\tconfiguration.put( PersistentIdentifierGenerator.PK, idValue.getColumns().get(0).getName() );\n\t\t}\n\t\treturn configuration;\n\t}\n\n\t/**\n\t * Set up the identifier generator for an id defined in a {@code hbm.xml} mapping.\n\t *\n\t * @see org.hibernate.boot.model.source.internal.hbm.ModelBinder\n\t */\n\tpublic static void makeIdGenerator(\n\t\t\tfinal MappingDocument sourceDocument,\n\t\t\tIdentifierGeneratorDefinition definition,\n\t\t\tSimpleValue identifierValue,\n\t\t\tMetadataBuildingContext context) {\n\n\t\tif ( definition != null ) {\n\t\t\t// see if the specified generator name matches a registered <identifier-generator/>\n\t\t\tfinal IdentifierGeneratorDefinition generatorDef =\n\t\t\t\t\tsourceDocument.getMetadataCollector()\n\t\t\t\t\t\t\t.getIdentifierGenerator( definition.getName() );\n\t\t\tfinal Map<String,Object> configuration = new HashMap<>();\n\t\t\tfinal String generatorStrategy;\n\t\t\tif ( generatorDef != null ) {\n\t\t\t\tgeneratorStrategy = generatorDef.getStrategy();\n\t\t\t\tconfiguration.putAll( generatorDef.getParameters() );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgeneratorStrategy = definition.getStrategy();\n\t\t\t}\n\n\t\t\tconfiguration.putAll( definition.getParameters() );\n\n\t\t\tsetGeneratorCreator( identifierValue, configuration, generatorStrategy, context );\n\t\t}\n\t}\n\n\t/**\n\t * Obtain a {@link BeanContainer} to be used for instantiating generators.\n\t */\n\tpublic static BeanContainer beanContainer(MetadataBuildingContext buildingContext) {\n\t\treturn Helper.getBeanContainer( buildingContext.getBootstrapContext().getServiceRegistry() );\n\t}\n\n\t/**\n\t * Set up the {@link GeneratorCreator} for a case where there is no\n\t * generator annotation.\n\t */\n\tprivate static void setGeneratorCreator(\n\t\t\tSimpleValue identifierValue,\n\t\t\tMap<String, Object> configuration,\n\t\t\tString generatorStrategy,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( ASSIGNED_GENERATOR_NAME.equals( generatorStrategy )\n\t\t\t\t|| org.hibernate.id.Assigned.class.getName().equals( generatorStrategy ) ) {\n\t\t\tidentifierValue.setCustomIdGeneratorCreator( ASSIGNED_IDENTIFIER_GENERATOR_CREATOR );\n\t\t}\n\t\telse {\n\t\t\tfinal BeanContainer beanContainer = beanContainer( context );\n\t\t\tidentifierValue.setCustomIdGeneratorCreator( creationContext -> {\n\t\t\t\tfinal Generator identifierGenerator =\n\t\t\t\t\t\tinstantiateGenerator( beanContainer, generatorClass( generatorStrategy, identifierValue ) );\n\t\t\t\tcallConfigure( creationContext, identifierGenerator, configuration, identifierValue );\n\t\t\t\tif ( identifierGenerator instanceof IdentityGenerator) {\n\t\t\t\t\tidentifierValue.setColumnToIdentity();\n\t\t\t\t}\n\t\t\t\treturn identifierGenerator;\n\t\t\t} );\n\t\t}\n\t}\n\n\t/**\n\t * Set up the id generator by considering all annotations of the identifier\n\t * field, including {@linkplain IdGeneratorType id generator annotations},\n\t * and {@link GeneratedValue}.\n\t */\n\tstatic void createIdGeneratorsFromGeneratorAnnotations(\n\t\t\tPropertyHolder propertyHolder,\n\t\t\tPropertyData inferredData,\n\t\t\tSimpleValue idValue,\n\t\t\tMetadataBuildingContext context) {\n\n\t\tfinal SourceModelBuildingContext sourceModelContext =\n\t\t\t\tcontext.getMetadataCollector().getSourceModelBuildingContext();\n\t\tfinal MemberDetails idAttributeMember = inferredData.getAttributeMember();\n\t\tfinal List<? extends Annotation> idGeneratorAnnotations =\n\t\t\t\tidAttributeMember.getMetaAnnotated( IdGeneratorType.class, sourceModelContext );\n\t\tfinal List<? extends Annotation> generatorAnnotations =\n\t\t\t\tidAttributeMember.getMetaAnnotated( ValueGenerationType.class, sourceModelContext );\n\t\t// Since these collections may contain Proxies created by common-annotations module we cannot reliably use simple remove/removeAll\n\t\t// collection methods as those proxies do not implement hashcode/equals and even a simple `a.equals(a)` will return `false`.\n\t\t// Instead, we will check the annotation types, since generator annotations should not be \"repeatable\" we should have only\n\t\t// at most one annotation for a generator:\n\t\tfor ( Annotation id : idGeneratorAnnotations ) {\n\t\t\tgeneratorAnnotations.removeIf( gen -> gen.annotationType().equals( id.annotationType() ) );\n\t\t}\n\n\t\tif ( idGeneratorAnnotations.size() + generatorAnnotations.size() > 1 ) {\n\t\t\tthrow new AnnotationException( String.format(\n\t\t\t\t\tLocale.ROOT,\n\t\t\t\t\t\"Identifier attribute '%s' has too many generator annotations: %s\",\n\t\t\t\t\tgetPath( propertyHolder, inferredData ),\n\t\t\t\t\tcombineUntyped( idGeneratorAnnotations, generatorAnnotations )\n\t\t\t) );\n\t\t}\n\t\tif ( !idGeneratorAnnotations.isEmpty() ) {\n\t\t\tidValue.setCustomIdGeneratorCreator( identifierGeneratorCreator(\n\t\t\t\t\tidAttributeMember,\n\t\t\t\t\tidGeneratorAnnotations.get(0),\n\t\t\t\t\tidValue,\n\t\t\t\t\tbeanContainer( context )\n\t\t\t) );\n\t\t}\n\t\telse if ( !generatorAnnotations.isEmpty() ) {\n//\t\t\tidValue.setCustomGeneratorCreator( generatorCreator( idAttributeMember, generatorAnnotation ) );\n\t\t\tthrow new AnnotationException( String.format(\n\t\t\t\t\tLocale.ROOT,\n\t\t\t\t\t\"Identifier attribute '%s' is annotated '%s' which is not an '@IdGeneratorType'\",\n\t\t\t\t\tgetPath( propertyHolder, inferredData ),\n\t\t\t\t\tgeneratorAnnotations.get(0).annotationType()\n\t\t\t) );\n\t\t}\n\t\telse if ( idAttributeMember.hasDirectAnnotationUsage( GeneratedValue.class ) ) {\n\t\t\tcreateIdGenerator( idAttributeMember, idValue, propertyHolder.getPersistentClass(), context );\n\t\t}\n\t}\n\n\t/**\n\t * Returns the value generation strategy for the given property, if any, by\n\t * considering {@linkplain ValueGenerationType generator type annotations}.\n\t */\n\tstatic GeneratorCreator createValueGeneratorFromAnnotations(\n\t\t\tPropertyHolder holder, String propertyName,\n\t\t\tMemberDetails property, MetadataBuildingContext context) {\n\t\tfinal List<? extends Annotation> generatorAnnotations =\n\t\t\t\tproperty.getMetaAnnotated( ValueGenerationType.class,\n\t\t\t\t\t\tcontext.getMetadataCollector().getSourceModelBuildingContext() );\n\t\treturn switch ( generatorAnnotations.size() ) {\n\t\t\tcase 0 -> null;\n\t\t\tcase 1 -> generatorCreator( property, generatorAnnotations.get(0), beanContainer( context ) );\n\t\t\tdefault -> throw new AnnotationException( \"Property '\" + qualify( holder.getPath(), propertyName )\n\t\t\t\t\t+ \"' has too many generator annotations: \" + generatorAnnotations );\n\t\t};\n\t}\n\n\tpublic static void applyIfNotEmpty(String name, String value, BiConsumer<String,String> consumer) {\n\t\tif ( StringHelper.isNotEmpty( value ) ) {\n\t\t\tconsumer.accept( name, value );\n\t\t}\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/boot/model/internal/GeneratorBinder.java",
        "sourceCodeAfterForWhole": "/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.boot.model.internal;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Member;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.function.BiConsumer;\nimport java.util.function.Consumer;\n\nimport org.hibernate.AnnotationException;\nimport org.hibernate.AssertionFailure;\nimport org.hibernate.MappingException;\nimport org.hibernate.annotations.GenericGenerator;\nimport org.hibernate.annotations.IdGeneratorType;\nimport org.hibernate.annotations.ValueGenerationType;\nimport org.hibernate.boot.model.IdentifierGeneratorDefinition;\nimport org.hibernate.boot.model.relational.ExportableProducer;\nimport org.hibernate.boot.model.source.internal.hbm.MappingDocument;\nimport org.hibernate.boot.models.spi.GlobalRegistrar;\nimport org.hibernate.boot.spi.InFlightMetadataCollector;\nimport org.hibernate.boot.spi.MetadataBuildingContext;\nimport org.hibernate.boot.spi.PropertyData;\nimport org.hibernate.generator.AnnotationBasedGenerator;\nimport org.hibernate.generator.Assigned;\nimport org.hibernate.generator.BeforeExecutionGenerator;\nimport org.hibernate.generator.Generator;\nimport org.hibernate.generator.GeneratorCreationContext;\nimport org.hibernate.generator.OnExecutionGenerator;\nimport org.hibernate.id.Configurable;\nimport org.hibernate.id.IdentifierGenerator;\nimport org.hibernate.id.IdentityGenerator;\nimport org.hibernate.id.PersistentIdentifierGenerator;\nimport org.hibernate.id.enhanced.SequenceStyleGenerator;\nimport org.hibernate.id.uuid.UuidValueGenerator;\nimport org.hibernate.internal.CoreLogging;\nimport org.hibernate.internal.CoreMessageLogger;\nimport org.hibernate.mapping.GeneratorCreator;\nimport org.hibernate.mapping.KeyValue;\nimport org.hibernate.mapping.PersistentClass;\nimport org.hibernate.mapping.SimpleValue;\nimport org.hibernate.models.spi.AnnotationTarget;\nimport org.hibernate.models.spi.MemberDetails;\nimport org.hibernate.models.spi.SourceModelBuildingContext;\nimport org.hibernate.resource.beans.container.spi.BeanContainer;\nimport org.hibernate.resource.beans.internal.Helper;\n\nimport jakarta.persistence.GeneratedValue;\nimport jakarta.persistence.GenerationType;\nimport jakarta.persistence.SequenceGenerator;\nimport jakarta.persistence.TableGenerator;\nimport jakarta.persistence.Version;\n\nimport static jakarta.persistence.GenerationType.AUTO;\nimport static java.util.Collections.emptyMap;\nimport static org.hibernate.boot.model.internal.AnnotationHelper.extractParameterMap;\nimport static org.hibernate.boot.model.internal.BinderHelper.getPath;\nimport static org.hibernate.boot.model.internal.BinderHelper.isGlobalGeneratorNameGlobal;\nimport static org.hibernate.boot.model.internal.GeneratorParameters.collectParameters;\nimport static org.hibernate.boot.model.internal.GeneratorParameters.interpretSequenceGenerator;\nimport static org.hibernate.boot.model.internal.GeneratorParameters.interpretTableGenerator;\nimport static org.hibernate.boot.model.internal.GeneratorStrategies.generatorClass;\nimport static org.hibernate.id.IdentifierGenerator.GENERATOR_NAME;\nimport static org.hibernate.internal.util.NullnessUtil.castNonNull;\nimport static org.hibernate.internal.util.StringHelper.isNotEmpty;\nimport static org.hibernate.internal.util.StringHelper.qualify;\nimport static org.hibernate.internal.util.collections.CollectionHelper.combineUntyped;\n\n/**\n * Responsible for configuring and instantiating {@link Generator}s.\n *\n * @author Gavin King\n */\npublic class GeneratorBinder {\n\n\tprivate static final CoreMessageLogger LOG = CoreLogging.messageLogger( GeneratorBinder.class );\n\n\tpublic static final String ASSIGNED_GENERATOR_NAME = \"assigned\";\n\tpublic static final GeneratorCreator ASSIGNED_IDENTIFIER_GENERATOR_CREATOR =\n\t\t\tnew GeneratorCreator() {\n\t\t\t\t@Override\n\t\t\t\tpublic Generator createGenerator(GeneratorCreationContext context) {\n\t\t\t\t\treturn new Assigned();\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic boolean isAssigned() {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t};\n\n\t/**\n\t * Create a generator, based on a {@link GeneratedValue} annotation.\n\t */\n\tpublic static void makeIdGenerator(\n\t\t\tSimpleValue identifierValue,\n\t\t\tMemberDetails idAttributeMember,\n\t\t\tString generatorType,\n\t\t\tString generatorName,\n\t\t\tMetadataBuildingContext context,\n\t\t\tMap<String, ? extends IdentifierGeneratorDefinition> localGenerators) {\n\n\t\t//generator settings\n\t\tfinal Map<String,Object> configuration = new HashMap<>();\n\t\tconfiguration.put( GENERATOR_NAME, generatorName );\n\t\tconfiguration.put( PersistentIdentifierGenerator.TABLE, identifierValue.getTable().getName() );\n\t\tif ( identifierValue.getColumnSpan() == 1 ) {\n\t\t\tconfiguration.put( PersistentIdentifierGenerator.PK, identifierValue.getColumns().get(0).getName() );\n\t\t}\n\n\t\tif ( generatorName.isEmpty() ) {\n\t\t\tfinal GeneratedValue generatedValue = idAttributeMember.getDirectAnnotationUsage( GeneratedValue.class );\n\t\t\tif ( generatedValue != null ) {\n\t\t\t\t// The mapping used @GeneratedValue but specified no name.  This is a special case added in JPA 3.2.\n\t\t\t\t// Look for a matching \"implied generator\" based on the GenerationType\n\t\t\t\tfinal GenerationType strategy = generatedValue.strategy();\n\t\t\t\tfinal String strategyGeneratorClassName = correspondingGeneratorName( strategy );\n\t\t\t\tfinal IdentifierGeneratorDefinition impliedGenerator =\n\t\t\t\t\t\tdetermineImpliedGenerator( strategy, strategyGeneratorClassName, localGenerators );\n\t\t\t\tif ( impliedGenerator != null ) {\n\t\t\t\t\tconfiguration.putAll( impliedGenerator.getParameters() );\n\t\t\t\t\tinstantiateGeneratorBean( identifierValue, strategyGeneratorClassName, configuration, context );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfinal String generatorStrategy = determineStrategy(\n\t\t\t\tidAttributeMember,\n\t\t\t\tgeneratorType,\n\t\t\t\tgeneratorName,\n\t\t\t\tcontext,\n\t\t\t\tlocalGenerators,\n\t\t\t\tconfiguration\n\t\t);\n\t\tsetGeneratorCreator( identifierValue, configuration, generatorStrategy, context );\n\t}\n\n\tprivate static IdentifierGeneratorDefinition determineImpliedGenerator(\n\t\t\tGenerationType strategy,\n\t\t\tString strategyGeneratorClassName,\n\t\t\tMap<String, ? extends IdentifierGeneratorDefinition> localGenerators) {\n\t\tif ( localGenerators == null ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( localGenerators.size() == 1 ) {\n\t\t\tfinal IdentifierGeneratorDefinition generatorDefinition =\n\t\t\t\t\tlocalGenerators.values().iterator().next();\n\t\t\t// NOTE : a little bit of a special rule here for the case of just one -\n\t\t\t// \t\twe consider it a match, based on strategy, if the strategy is AUTO or matches...\n\t\t\tif ( strategy == AUTO\n\t\t\t\t\t|| isImpliedGenerator( strategy, strategyGeneratorClassName, generatorDefinition ) ) {\n\t\t\t\treturn generatorDefinition;\n\t\t\t}\n\t\t}\n\n\t\tIdentifierGeneratorDefinition matching = null;\n\t\tfor ( IdentifierGeneratorDefinition localGenerator : localGenerators.values() ) {\n\t\t\tif ( isImpliedGenerator( strategy, strategyGeneratorClassName, localGenerator ) ) {\n\t\t\t\tif ( matching != null ) {\n\t\t\t\t\t// we found multiple matching generators\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tmatching = localGenerator;\n\t\t\t}\n\t\t}\n\t\treturn matching;\n\t}\n\n\tprivate static boolean isImpliedGenerator(\n\t\t\tGenerationType strategy,\n\t\t\tString strategyGeneratorClassName,\n\t\t\tIdentifierGeneratorDefinition generatorDefinition) {\n\t\treturn generatorDefinition.getStrategy().equals( strategyGeneratorClassName );\n\t}\n\n\tprivate static String correspondingGeneratorName(GenerationType strategy) {\n\t\treturn switch ( strategy ) {\n//\t\t\tcase UUID -> org.hibernate.id.uuid.UuidGenerator.class.getName();\n\t\t\tcase UUID -> UuidValueGenerator.class.getName();\n\t\t\tcase TABLE -> org.hibernate.id.enhanced.TableGenerator.class.getName();\n\t\t\tcase IDENTITY -> null;\n\t\t\tdefault -> SequenceStyleGenerator.class.getName();\n\t\t};\n\t}\n\n\tprivate static String determineStrategy(\n\t\t\tMemberDetails idAttributeMember,\n\t\t\tString generatorType,\n\t\t\tString generatorName,\n\t\t\tMetadataBuildingContext context,\n\t\t\tMap<String, ? extends IdentifierGeneratorDefinition> localGenerators,\n\t\t\tMap<String, Object> configuration) {\n\t\tif ( !generatorName.isEmpty() ) {\n\t\t\t//we have a named generator\n\t\t\tfinal IdentifierGeneratorDefinition definition =\n\t\t\t\t\tmakeIdentifierGeneratorDefinition( generatorName, idAttributeMember, localGenerators, context );\n\t\t\tif ( definition == null ) {\n\t\t\t\tthrow new AnnotationException( \"No id generator was declared with the name '\" + generatorName\n\t\t\t\t\t\t+ \"' specified by '@GeneratedValue'\"\n\t\t\t\t\t\t+ \" (define a named generator using '@SequenceGenerator', '@TableGenerator', or '@GenericGenerator')\" );\n\t\t\t}\n\t\t\t//This is quite vague in the spec but a generator could override the generator choice\n\t\t\tfinal String generatorStrategy =\n\t\t\t\t\tgeneratorType == null\n\t\t\t\t\t\t//yuk! this is a hack not to override 'AUTO' even if generator is set\n\t\t\t\t\t\t|| !definition.getStrategy().equals( \"identity\" )\n\t\t\t\t\t\t\t? definition.getStrategy()\n\t\t\t\t\t\t\t: generatorType;\n\t\t\t//checkIfMatchingGenerator(definition, generatorType, generatorName);\n\t\t\tconfiguration.putAll( definition.getParameters() );\n\t\t\treturn generatorStrategy;\n\t\t}\n\t\telse {\n\t\t\treturn generatorType;\n\t\t}\n\t}\n\n\tprivate static IdentifierGeneratorDefinition makeIdentifierGeneratorDefinition(\n\t\t\tString name,\n\t\t\tMemberDetails idAttributeMember,\n\t\t\tMap<String, ? extends IdentifierGeneratorDefinition> localGenerators,\n\t\t\tMetadataBuildingContext buildingContext) {\n\t\tif ( localGenerators != null ) {\n\t\t\tfinal IdentifierGeneratorDefinition result = localGenerators.get( name );\n\t\t\tif ( result != null ) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tfinal IdentifierGeneratorDefinition globalDefinition =\n\t\t\t\tbuildingContext.getMetadataCollector().getIdentifierGenerator( name );\n\t\tif ( globalDefinition != null ) {\n\t\t\treturn globalDefinition;\n\t\t}\n\t\telse {\n\t\t\tLOG.debugf( \"Could not resolve explicit IdentifierGeneratorDefinition - using implicit interpretation (%s)\",\n\t\t\t\t\tname );\n\t\t\tfinal GeneratedValue generatedValue = idAttributeMember.getDirectAnnotationUsage( GeneratedValue.class );\n\t\t\tif ( generatedValue == null ) {\n\t\t\t\tthrow new AssertionFailure( \"No @GeneratedValue annotation\" );\n\t\t\t}\n\t\t\treturn IdentifierGeneratorDefinition.createImplicit(\n\t\t\t\t\tname,\n\t\t\t\t\tidAttributeMember.getType(),\n\t\t\t\t\tgeneratedValue.generator(),\n\t\t\t\t\tinterpretGenerationType( generatedValue )\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate static GenerationType interpretGenerationType(GeneratedValue generatedValueAnn) {\n\t\t// todo (jpa32) : when can this ever be null?\n\t\tfinal GenerationType strategy = generatedValueAnn.strategy();\n\t\treturn strategy == null ? AUTO : strategy;\n\t}\n\n\tpublic static void visitIdGeneratorDefinitions(\n\t\t\tAnnotationTarget annotatedElement,\n\t\t\tConsumer<IdentifierGeneratorDefinition> consumer,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal SourceModelBuildingContext sourceModelContext =\n\t\t\t\tcontext.getMetadataCollector().getSourceModelBuildingContext();\n\n\t\tannotatedElement.forEachAnnotationUsage( TableGenerator.class, sourceModelContext,\n\t\t\t\tusage -> consumer.accept( buildTableIdGenerator( usage ) ) );\n\n\t\tannotatedElement.forEachAnnotationUsage( SequenceGenerator.class, sourceModelContext,\n\t\t\t\tusage -> consumer.accept( buildSequenceIdGenerator( usage ) ) );\n\n\t\tannotatedElement.forEachAnnotationUsage( GenericGenerator.class, sourceModelContext,\n\t\t\t\tusage -> consumer.accept( buildIdGenerator( usage ) ) );\n\n\t}\n\n\tpublic static void registerGlobalGenerators(\n\t\t\tAnnotationTarget annotatedElement,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( context.getBootstrapContext().getJpaCompliance().isGlobalGeneratorScopeEnabled() ) {\n\t\t\tfinal InFlightMetadataCollector metadataCollector = context.getMetadataCollector();\n\t\t\tvisitIdGeneratorDefinitions(\n\t\t\t\t\tannotatedElement,\n\t\t\t\t\tdefinition -> {\n\t\t\t\t\t\tif ( !definition.getName().isEmpty() ) {\n\t\t\t\t\t\t\tmetadataCollector.addIdentifierGenerator( definition );\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate static IdentifierGeneratorDefinition buildIdGenerator(GenericGenerator generatorAnnotation) {\n\t\tfinal IdentifierGeneratorDefinition.Builder definitionBuilder =\n\t\t\t\tnew IdentifierGeneratorDefinition.Builder();\n\t\tdefinitionBuilder.setName( generatorAnnotation.name() );\n\t\tfinal Class<? extends Generator> generatorClass = generatorAnnotation.type();\n\t\tfinal String strategy =\n\t\t\t\tgeneratorClass.equals( Generator.class )\n\t\t\t\t\t\t? generatorAnnotation.strategy()\n\t\t\t\t\t\t: generatorClass.getName();\n\t\tdefinitionBuilder.setStrategy( strategy );\n\t\tdefinitionBuilder.addParams( extractParameterMap( generatorAnnotation.parameters() ) );\n\n\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\tLOG.tracev( \"Added generator with name: {0}, strategy: {0}\",\n\t\t\t\t\tdefinitionBuilder.getName(), definitionBuilder.getStrategy() );\n\t\t}\n\n\t\treturn definitionBuilder.build();\n\t}\n\n\tprivate static IdentifierGeneratorDefinition buildSequenceIdGenerator(SequenceGenerator generatorAnnotation) {\n\t\tfinal IdentifierGeneratorDefinition.Builder definitionBuilder = new IdentifierGeneratorDefinition.Builder();\n\t\tinterpretSequenceGenerator( generatorAnnotation, definitionBuilder );\n\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\tLOG.tracev( \"Add sequence generator with name: {0}\", definitionBuilder.getName() );\n\t\t}\n\t\treturn definitionBuilder.build();\n\t}\n\n\tprivate static IdentifierGeneratorDefinition buildTableIdGenerator(TableGenerator generatorAnnotation) {\n\t\tfinal IdentifierGeneratorDefinition.Builder definitionBuilder = new IdentifierGeneratorDefinition.Builder();\n\t\tinterpretTableGenerator( generatorAnnotation, definitionBuilder );\n\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\tLOG.tracev( \"Add sequence generator with name: {0}\", definitionBuilder.getName() );\n\t\t}\n\t\treturn definitionBuilder.build();\n\t}\n\n\tprivate static void checkGeneratorClass(Class<? extends Generator> generatorClass) {\n\t\tif ( !BeforeExecutionGenerator.class.isAssignableFrom( generatorClass )\n\t\t\t\t&& !OnExecutionGenerator.class.isAssignableFrom( generatorClass ) ) {\n\t\t\tthrow new MappingException(\"Generator class '\" + generatorClass.getName()\n\t\t\t\t\t+ \"' must implement either 'BeforeExecutionGenerator' or 'OnExecutionGenerator'\");\n\t\t}\n\t}\n\n\tprivate static void checkGeneratorInterfaces(Class<? extends Generator> generatorClass) {\n\t\t// we don't yet support the additional \"fancy\" operations of\n\t\t// IdentifierGenerator with regular generators, though this\n\t\t// would be extremely easy to add if anyone asks for it\n\t\tif ( IdentifierGenerator.class.isAssignableFrom( generatorClass ) ) {\n\t\t\tthrow new AnnotationException(\"Generator class '\" + generatorClass.getName()\n\t\t\t\t\t+ \"' implements 'IdentifierGenerator' and may not be used with '@ValueGenerationType'\");\n\t\t}\n\t\tif ( ExportableProducer.class.isAssignableFrom( generatorClass ) ) {\n\t\t\tthrow new AnnotationException(\"Generator class '\" + generatorClass.getName()\n\t\t\t\t\t+ \"' implements 'ExportableProducer' and may not be used with '@ValueGenerationType'\");\n\t\t}\n\t}\n\n\t/**\n\t * Return a {@link GeneratorCreator} for an attribute annotated\n\t * with a {@linkplain ValueGenerationType generator annotation}.\n\t */\n\tprivate static GeneratorCreator generatorCreator(\n\t\t\tMemberDetails memberDetails,\n\t\t\tAnnotation annotation,\n\t\t\tBeanContainer beanContainer) {\n\t\tfinal Class<? extends Annotation> annotationType = annotation.annotationType();\n\t\tfinal ValueGenerationType generatorAnnotation = annotationType.getAnnotation( ValueGenerationType.class );\n\t\tassert generatorAnnotation != null;\n\t\tfinal Class<? extends Generator> generatorClass = generatorAnnotation.generatedBy();\n\t\tcheckGeneratorClass( generatorClass );\n\t\tcheckGeneratorInterfaces( generatorClass );\n\t\treturn creationContext -> {\n\t\t\tfinal Generator generator = instantiateGenerator(\n\t\t\t\t\tannotation,\n\t\t\t\t\tbeanContainer,\n\t\t\t\t\tcreationContext,\n\t\t\t\t\tgeneratorClass,\n\t\t\t\t\tmemberDetails,\n\t\t\t\t\tannotationType\n\t\t\t);\n\t\t\tcallInitialize( annotation, memberDetails, creationContext, generator );\n\t\t\t//TODO: callConfigure( creationContext, generator, emptyMap(), identifierValue );\n\t\t\tcheckVersionGenerationAlways( memberDetails, generator );\n\t\t\treturn generator;\n\t\t};\n\t}\n\n\t/**\n\t * Return a {@link GeneratorCreator} for an id attribute annotated\n\t * with an {@linkplain IdGeneratorType id generator annotation}.\n\t */\n\tprivate static GeneratorCreator identifierGeneratorCreator(\n\t\t\tMemberDetails idAttributeMember,\n\t\t\tAnnotation annotation,\n\t\t\tSimpleValue identifierValue,\n\t\t\tBeanContainer beanContainer) {\n\t\tfinal Class<? extends Annotation> annotationType = annotation.annotationType();\n\t\tfinal IdGeneratorType idGeneratorAnnotation = annotationType.getAnnotation( IdGeneratorType.class );\n\t\tassert idGeneratorAnnotation != null;\n\t\tfinal Class<? extends Generator> generatorClass = idGeneratorAnnotation.value();\n\t\tcheckGeneratorClass( generatorClass );\n\t\treturn creationContext -> {\n\t\t\tfinal Generator generator =\n\t\t\t\t\tinstantiateGenerator(\n\t\t\t\t\t\t\tannotation,\n\t\t\t\t\t\t\tbeanContainer,\n\t\t\t\t\t\t\tcreationContext,\n\t\t\t\t\t\t\tgeneratorClass,\n\t\t\t\t\t\t\tidAttributeMember,\n\t\t\t\t\t\t\tannotationType\n\t\t\t\t\t);\n\t\t\tcallInitialize( annotation, idAttributeMember, creationContext, generator );\n\t\t\tcallConfigure( creationContext, generator, emptyMap(), identifierValue );\n\t\t\tcheckIdGeneratorTiming( annotationType, generator );\n\t\t\treturn generator;\n\t\t};\n\t}\n\n\t/**\n\t * Instantiate a {@link Generator}, using the given {@link BeanContainer} if any,\n\t * for the case where the generator was specified using a generator annotation.\n\t *\n\t * @param annotation the generator annotation\n\t * @param beanContainer an optional {@code BeanContainer}\n\t * @param generatorClass a class which implements {@code Generator}\n\t */\n\tprivate static Generator instantiateGenerator(\n\t\t\tAnnotation annotation,\n\t\t\tBeanContainer beanContainer,\n\t\t\tGeneratorCreationContext creationContext,\n\t\t\tClass<? extends Generator> generatorClass,\n\t\t\tMemberDetails memberDetails,\n\t\t\tClass<? extends Annotation> annotationType) {\n\t\tif ( beanContainer != null ) {\n\t\t\treturn instantiateGeneratorAsBean(\n\t\t\t\t\tannotation,\n\t\t\t\t\tbeanContainer,\n\t\t\t\t\tcreationContext,\n\t\t\t\t\tgeneratorClass,\n\t\t\t\t\tmemberDetails,\n\t\t\t\t\tannotationType\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn instantiateGenerator(\n\t\t\t\t\tannotation,\n\t\t\t\t\tmemberDetails,\n\t\t\t\t\tannotationType,\n\t\t\t\t\tcreationContext,\n\t\t\t\t\tgeneratorClass\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Instantiate a {@link Generator}, using the given {@link BeanContainer},\n\t * for the case where the generator was specified using a generator annotation.\n\t *\n\t * @param annotation the generator annotation\n\t * @param beanContainer an optional {@code BeanContainer}\n\t * @param generatorClass a class which implements {@code Generator}\n\t */\n\tprivate static Generator instantiateGeneratorAsBean(\n\t\t\tAnnotation annotation,\n\t\t\tBeanContainer beanContainer,\n\t\t\tGeneratorCreationContext creationContext,\n\t\t\tClass<? extends Generator> generatorClass,\n\t\t\tMemberDetails memberDetails,\n\t\t\tClass<? extends Annotation> annotationType) {\n\t\treturn Helper.getBean(\n\t\t\tbeanContainer,\n\t\t\tgeneratorClass,\n\t\t\tfalse,\n\t\t\ttrue,\n\t\t\t() -> instantiateGenerator(\n\t\t\t\tannotation,\n\t\t\t\tmemberDetails,\n\t\t\t\tannotationType,\n\t\t\t\tcreationContext,\n\t\t\t\tgeneratorClass\n\t\t\t)\n\t\t);\n\t}\n\n\t/**\n\t * Instantiate a {@link Generator}, using the given {@link BeanContainer},\n\t * for the case where no generator annotation is available.\n\t *\n\t * @param beanContainer an optional {@code BeanContainer}\n\t * @param generatorClass a class which implements {@code Generator}\n\t */\n\tprivate static <T extends Generator> T instantiateGeneratorAsBean(\n\t\t\tBeanContainer beanContainer,\n\t\t\tClass<T> generatorClass) {\n\t\treturn Helper.getBean(\n\t\t\tbeanContainer,\n\t\t\tgeneratorClass,\n\t\t\tfalse,\n\t\t\ttrue,\n\t\t\t() -> instantiateGeneratorViaDefaultConstructor( generatorClass )\n\t\t);\n\t}\n\n\t/**\n\t * Instantiate a {@link Generator} by calling an appropriate constructor,\n\t * for the case where the generator was specified using a generator annotation.\n\t * We look for three possible signatures:\n\t * <ol>\n\t *     <li>{@code (Annotation, Member, GeneratorCreationContext)}</li>\n\t *     <li>{@code (Annotation)}</li>\n\t *     <li>{@code ()}</li>\n\t * </ol>\n\t * where {@code Annotation} is the generator annotation type.\n\t *\n\t * @param annotation the generator annotation\n\t * @param generatorClass a class which implements {@code Generator}\n\t */\n\tprivate static <G extends Generator> G instantiateGenerator(\n\t\t\tAnnotation annotation,\n\t\t\tMemberDetails memberDetails,\n\t\t\tClass<? extends Annotation> annotationType,\n\t\t\tGeneratorCreationContext creationContext,\n\t\t\tClass<? extends G> generatorClass) {\n\t\ttry {\n\t\t\ttry {\n\t\t\t\treturn generatorClass.getConstructor( annotationType, Member.class, GeneratorCreationContext.class )\n\t\t\t\t\t\t.newInstance( annotation, memberDetails.toJavaMember(), creationContext);\n\t\t\t}\n\t\t\tcatch (NoSuchMethodException ignore) {\n\t\t\t\ttry {\n\t\t\t\t\treturn generatorClass.getConstructor( annotationType )\n\t\t\t\t\t\t\t.newInstance( annotation );\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchMethodException i) {\n\t\t\t\t\treturn instantiateGeneratorViaDefaultConstructor( generatorClass );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (InvocationTargetException | InstantiationException | IllegalAccessException | IllegalArgumentException e) {\n\t\t\tthrow new org.hibernate.InstantiationException( \"Could not instantiate id generator\", generatorClass, e );\n\t\t}\n\t}\n\n\t/**\n\t * Instantiate a {@link Generator}, using the given {@link BeanContainer} if any,\n\t * or by calling the default constructor otherwise.\n\t *\n\t * @param beanContainer an optional {@code BeanContainer}\n\t * @param generatorClass a class which implements {@code Generator}\n\t */\n\tpublic static <T extends Generator> T instantiateGenerator(\n\t\t\tBeanContainer beanContainer,\n\t\t\tClass<T> generatorClass) {\n\t\treturn beanContainer != null\n\t\t\t\t? instantiateGeneratorAsBean( beanContainer, generatorClass )\n\t\t\t\t: instantiateGeneratorViaDefaultConstructor( generatorClass );\n\t}\n\n\t/**\n\t * Instantiate a {@link Generator} by calling the default constructor.\n\t */\n\tprivate static <G extends Generator> G instantiateGeneratorViaDefaultConstructor(Class<? extends G> generatorClass) {\n\t\ttry {\n\t\t\treturn generatorClass.getDeclaredConstructor().newInstance();\n\t\t}\n\t\tcatch (NoSuchMethodException e) {\n\t\t\tthrow new org.hibernate.InstantiationException( \"No appropriate constructor for id generator class\", generatorClass);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new org.hibernate.InstantiationException( \"Could not instantiate id generator\", generatorClass, e );\n\t\t}\n\t}\n\n\tpublic static <A extends Annotation> void callInitialize(\n\t\t\tA annotation,\n\t\t\tMemberDetails memberDetails,\n\t\t\tGeneratorCreationContext creationContext,\n\t\t\tGenerator generator) {\n\t\tif ( generator instanceof AnnotationBasedGenerator ) {\n\t\t\t// This will cause a CCE in case the generation type doesn't match the annotation type; As this would be\n\t\t\t// a programming error of the generation type developer and thus should show up during testing, we don't\n\t\t\t// check this explicitly; If required, this could be done e.g. using ClassMate\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tfinal AnnotationBasedGenerator<A> generation = (AnnotationBasedGenerator<A>) generator;\n\t\t\tgeneration.initialize( annotation, memberDetails.toJavaMember(), creationContext );\n\t\t}\n\t}\n\n\tprivate static void checkVersionGenerationAlways(MemberDetails property, Generator generator) {\n\t\tif ( property.hasDirectAnnotationUsage( Version.class ) ) {\n\t\t\tif ( !generator.generatesOnInsert() ) {\n\t\t\t\tthrow new AnnotationException(\"Property '\" + property.getName()\n\t\t\t\t\t\t+ \"' is annotated '@Version' but has a 'Generator' which does not generate on inserts\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( !generator.generatesOnUpdate() ) {\n\t\t\t\tthrow new AnnotationException(\"Property '\" + property.getName()\n\t\t\t\t\t\t+ \"' is annotated '@Version' but has a 'Generator' which does not generate on updates\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * If the given {@link Generator} also implements {@link Configurable},\n\t * call its {@link Configurable#configure(GeneratorCreationContext, Properties)\n\t * configure()} method.\n\t */\n\tpublic static void callConfigure(\n\t\t\tGeneratorCreationContext creationContext,\n\t\t\tGenerator generator,\n\t\t\tMap<String, Object> configuration,\n\t\t\tSimpleValue identifierValue) {\n\t\tif ( generator instanceof Configurable configurable ) {\n\t\t\tfinal Properties parameters = collectParameters(\n\t\t\t\t\tidentifierValue,\n\t\t\t\t\tcreationContext.getDatabase().getDialect(),\n\t\t\t\t\tcreationContext.getRootClass(),\n\t\t\t\t\tconfiguration\n\t\t\t);\n\t\t\tconfigurable.configure( creationContext, parameters );\n\t\t}\n\t\tif ( generator instanceof ExportableProducer exportableProducer ) {\n\t\t\texportableProducer.registerExportables( creationContext.getDatabase() );\n\t\t}\n\t\tif ( generator instanceof Configurable configurable ) {\n\t\t\tconfigurable.initialize( creationContext.getSqlStringGenerationContext() );\n\t\t}\n\t}\n\n\tprivate static void checkIdGeneratorTiming(Class<? extends Annotation> annotationType, Generator generator) {\n\t\tif ( !generator.generatesOnInsert() ) {\n\t\t\tthrow new MappingException( \"Annotation '\" + annotationType\n\t\t\t\t\t+ \"' is annotated 'IdGeneratorType' but the given 'Generator' does not generate on inserts\");\n\t\t}\n\t\tif ( generator.generatesOnUpdate() ) {\n\t\t\tthrow new MappingException( \"Annotation '\" + annotationType\n\t\t\t\t\t+ \"' is annotated 'IdGeneratorType' but the given 'Generator' generates on updates (it must generate only on inserts)\");\n\t\t}\n\t}\n\n\t/**\n\t * Create a generator, based on a {@link GeneratedValue} annotation.\n\t */\n\tprivate static void createIdGenerator(\n\t\t\tMemberDetails idMember,\n\t\t\tSimpleValue idValue,\n\t\t\tPersistentClass persistentClass,\n\t\t\tMetadataBuildingContext context) {\n\t\t// NOTE: `generatedValue` is never null here\n\t\tfinal GeneratedValue generatedValue = castNonNull( idMember.getDirectAnnotationUsage( GeneratedValue.class ) );\n\n\t\tfinal InFlightMetadataCollector metadataCollector = context.getMetadataCollector();\n\t\tif ( isGlobalGeneratorNameGlobal( context ) ) {\n\t\t\t// process and register any generators defined on the member.\n\t\t\t// according to JPA these are also global.\n\t\t\tmetadataCollector.getGlobalRegistrations().as( GlobalRegistrar.class ).collectIdGenerators( idMember );\n\t\t\tmetadataCollector.addSecondPass( new StrictIdGeneratorResolverSecondPass(\n\t\t\t\t\tpersistentClass,\n\t\t\t\t\tidValue,\n\t\t\t\t\tidMember,\n\t\t\t\t\tgeneratedValue,\n\t\t\t\t\tcontext\n\t\t\t) );\n\t\t}\n\t\telse {\n\t\t\tmetadataCollector.addSecondPass( new IdGeneratorResolverSecondPass(\n\t\t\t\t\tpersistentClass,\n\t\t\t\t\tidValue,\n\t\t\t\t\tidMember,\n\t\t\t\t\tgeneratedValue,\n\t\t\t\t\tcontext\n\t\t\t) );\n\t\t}\n\t}\n\n\tpublic static void createGeneratorFrom(\n\t\t\tIdentifierGeneratorDefinition defaultedGenerator,\n\t\t\tSimpleValue idValue,\n\t\t\tMap<String, Object> configuration,\n\t\t\tMetadataBuildingContext context) {\n\t\tconfiguration.putAll( defaultedGenerator.getParameters() );\n\t\tinstantiateGeneratorBean( idValue, defaultedGenerator.getStrategy(), configuration, context );\n\t}\n\n\n\tpublic static void createGeneratorFrom(\n\t\t\tIdentifierGeneratorDefinition defaultedGenerator,\n\t\t\tSimpleValue idValue,\n\t\t\tMetadataBuildingContext context) {\n\t\tcreateGeneratorFrom(\n\t\t\t\tdefaultedGenerator,\n\t\t\t\tidValue,\n\t\t\t\tbuildConfigurationMap( idValue ),\n\t\t\t\tcontext\n\t\t);\n\t}\n\n\tprivate static Map<String, Object> buildConfigurationMap(KeyValue idValue) {\n\t\tfinal Map<String,Object> configuration = new HashMap<>();\n\t\tconfiguration.put( PersistentIdentifierGenerator.TABLE, idValue.getTable().getName() );\n\t\tif ( idValue.getColumnSpan() == 1 ) {\n\t\t\tconfiguration.put( PersistentIdentifierGenerator.PK, idValue.getColumns().get(0).getName() );\n\t\t}\n\t\treturn configuration;\n\t}\n\n\t/**\n\t * Set up the identifier generator for an id defined in a {@code hbm.xml} mapping.\n\t *\n\t * @see org.hibernate.boot.model.source.internal.hbm.ModelBinder\n\t */\n\tpublic static void makeIdGenerator(\n\t\t\tfinal MappingDocument sourceDocument,\n\t\t\tIdentifierGeneratorDefinition definition,\n\t\t\tSimpleValue identifierValue,\n\t\t\tMetadataBuildingContext context) {\n\n\t\tif ( definition != null ) {\n\t\t\t// see if the specified generator name matches a registered <identifier-generator/>\n\t\t\tfinal IdentifierGeneratorDefinition generatorDef =\n\t\t\t\t\tsourceDocument.getMetadataCollector()\n\t\t\t\t\t\t\t.getIdentifierGenerator( definition.getName() );\n\t\t\tfinal Map<String,Object> configuration = new HashMap<>();\n\t\t\tfinal String generatorStrategy;\n\t\t\tif ( generatorDef != null ) {\n\t\t\t\tgeneratorStrategy = generatorDef.getStrategy();\n\t\t\t\tconfiguration.putAll( generatorDef.getParameters() );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgeneratorStrategy = definition.getStrategy();\n\t\t\t}\n\n\t\t\tconfiguration.putAll( definition.getParameters() );\n\n\t\t\tsetGeneratorCreator( identifierValue, configuration, generatorStrategy, context );\n\t\t}\n\t}\n\n\t/**\n\t * Obtain a {@link BeanContainer} to be used for instantiating generators.\n\t */\n\tpublic static BeanContainer beanContainer(MetadataBuildingContext buildingContext) {\n\t\treturn Helper.getBeanContainer( buildingContext.getBootstrapContext().getServiceRegistry() );\n\t}\n\n\t/**\n\t * Set up the {@link GeneratorCreator} for a case where there is no\n\t * generator annotation.\n\t */\n\tprivate static void setGeneratorCreator(\n\t\t\tSimpleValue identifierValue,\n\t\t\tMap<String, Object> configuration,\n\t\t\tString generatorStrategy,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( ASSIGNED_GENERATOR_NAME.equals( generatorStrategy )\n\t\t\t\t|| org.hibernate.id.Assigned.class.getName().equals( generatorStrategy ) ) {\n\t\t\tidentifierValue.setCustomIdGeneratorCreator( ASSIGNED_IDENTIFIER_GENERATOR_CREATOR );\n\t\t}\n\t\telse {\n\t\t\tinstantiateGeneratorBean( identifierValue, generatorStrategy, configuration, context );\n\t\t}\n\t}\n\n\tprivate static void instantiateGeneratorBean(\n\t\t\tSimpleValue identifierValue,\n\t\t\tString generatorStrategy,\n\t\t\tMap<String, Object> configuration,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal BeanContainer beanContainer = beanContainer( context );\n\t\tidentifierValue.setCustomIdGeneratorCreator( creationContext -> {\n\t\t\tfinal Generator identifierGenerator =\n\t\t\t\t\tinstantiateGenerator( beanContainer, generatorClass( generatorStrategy, identifierValue ) );\n\t\t\tcallConfigure( creationContext, identifierGenerator, configuration, identifierValue );\n\t\t\tif ( identifierGenerator instanceof IdentityGenerator) {\n\t\t\t\tidentifierValue.setColumnToIdentity();\n\t\t\t}\n\t\t\treturn identifierGenerator;\n\t\t} );\n\t}\n\n\t/**\n\t * Set up the id generator by considering all annotations of the identifier\n\t * field, including {@linkplain IdGeneratorType id generator annotations},\n\t * and {@link GeneratedValue}.\n\t */\n\tstatic void createIdGeneratorsFromGeneratorAnnotations(\n\t\t\tPropertyHolder propertyHolder,\n\t\t\tPropertyData inferredData,\n\t\t\tSimpleValue idValue,\n\t\t\tMetadataBuildingContext context) {\n\n\t\tfinal SourceModelBuildingContext sourceModelContext =\n\t\t\t\tcontext.getMetadataCollector().getSourceModelBuildingContext();\n\t\tfinal MemberDetails idAttributeMember = inferredData.getAttributeMember();\n\t\tfinal List<? extends Annotation> idGeneratorAnnotations =\n\t\t\t\tidAttributeMember.getMetaAnnotated( IdGeneratorType.class, sourceModelContext );\n\t\tfinal List<? extends Annotation> generatorAnnotations =\n\t\t\t\tidAttributeMember.getMetaAnnotated( ValueGenerationType.class, sourceModelContext );\n\t\t// Since these collections may contain Proxies created by common-annotations module we cannot reliably use simple remove/removeAll\n\t\t// collection methods as those proxies do not implement hashcode/equals and even a simple `a.equals(a)` will return `false`.\n\t\t// Instead, we will check the annotation types, since generator annotations should not be \"repeatable\" we should have only\n\t\t// at most one annotation for a generator:\n\t\tfor ( Annotation id : idGeneratorAnnotations ) {\n\t\t\tgeneratorAnnotations.removeIf( gen -> gen.annotationType().equals( id.annotationType() ) );\n\t\t}\n\n\t\tif ( idGeneratorAnnotations.size() + generatorAnnotations.size() > 1 ) {\n\t\t\tthrow new AnnotationException( String.format(\n\t\t\t\t\tLocale.ROOT,\n\t\t\t\t\t\"Identifier attribute '%s' has too many generator annotations: %s\",\n\t\t\t\t\tgetPath( propertyHolder, inferredData ),\n\t\t\t\t\tcombineUntyped( idGeneratorAnnotations, generatorAnnotations )\n\t\t\t) );\n\t\t}\n\t\tif ( !idGeneratorAnnotations.isEmpty() ) {\n\t\t\tidValue.setCustomIdGeneratorCreator( identifierGeneratorCreator(\n\t\t\t\t\tidAttributeMember,\n\t\t\t\t\tidGeneratorAnnotations.get(0),\n\t\t\t\t\tidValue,\n\t\t\t\t\tbeanContainer( context )\n\t\t\t) );\n\t\t}\n\t\telse if ( !generatorAnnotations.isEmpty() ) {\n//\t\t\tidValue.setCustomGeneratorCreator( generatorCreator( idAttributeMember, generatorAnnotation ) );\n\t\t\tthrow new AnnotationException( String.format(\n\t\t\t\t\tLocale.ROOT,\n\t\t\t\t\t\"Identifier attribute '%s' is annotated '%s' which is not an '@IdGeneratorType'\",\n\t\t\t\t\tgetPath( propertyHolder, inferredData ),\n\t\t\t\t\tgeneratorAnnotations.get(0).annotationType()\n\t\t\t) );\n\t\t}\n\t\telse if ( idAttributeMember.hasDirectAnnotationUsage( GeneratedValue.class ) ) {\n\t\t\tcreateIdGenerator( idAttributeMember, idValue, propertyHolder.getPersistentClass(), context );\n\t\t}\n\t}\n\n\t/**\n\t * Returns the value generation strategy for the given property, if any, by\n\t * considering {@linkplain ValueGenerationType generator type annotations}.\n\t */\n\tstatic GeneratorCreator createValueGeneratorFromAnnotations(\n\t\t\tPropertyHolder holder, String propertyName,\n\t\t\tMemberDetails property, MetadataBuildingContext context) {\n\t\tfinal List<? extends Annotation> generatorAnnotations =\n\t\t\t\tproperty.getMetaAnnotated( ValueGenerationType.class,\n\t\t\t\t\t\tcontext.getMetadataCollector().getSourceModelBuildingContext() );\n\t\treturn switch ( generatorAnnotations.size() ) {\n\t\t\tcase 0 -> null;\n\t\t\tcase 1 -> generatorCreator( property, generatorAnnotations.get(0), beanContainer( context ) );\n\t\t\tdefault -> throw new AnnotationException( \"Property '\" + qualify( holder.getPath(), propertyName )\n\t\t\t\t\t+ \"' has too many generator annotations: \" + generatorAnnotations );\n\t\t};\n\t}\n\n\tpublic static void applyIfNotEmpty(String name, String value, BiConsumer<String,String> consumer) {\n\t\tif ( isNotEmpty( value ) ) {\n\t\t\tconsumer.accept( name, value );\n\t\t}\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private static void instantiateGeneratorBean(\n\t\t\tSimpleValue identifierValue,\n\t\t\tString generatorStrategy,\n\t\t\tMap<String, Object> configuration,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal BeanContainer beanContainer = beanContainer( context );\n\t\tidentifierValue.setCustomIdGeneratorCreator( creationContext -> {\n\t\t\tfinal Generator identifierGenerator =\n\t\t\t\t\tinstantiateGenerator( beanContainer, generatorClass( generatorStrategy, identifierValue ) );\n\t\t\tcallConfigure( creationContext, identifierGenerator, configuration, identifierValue );\n\t\t\tif ( identifierGenerator instanceof IdentityGenerator) {\n\t\t\t\tidentifierValue.setColumnToIdentity();\n\t\t\t}\n\t\t\treturn identifierGenerator;\n\t\t} );\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.boot.model.internal.GeneratorBinder#callConfigure\n methodBody: public static void callConfigure(\n\t\t\tGeneratorCreationContext creationContext,\n\t\t\tGenerator generator,\n\t\t\tMap<String, Object> configuration,\n\t\t\tSimpleValue identifierValue) {\nif(generator instanceof Configurable configurable){final Properties parameters=collectParameters(identifierValue,creationContext.getDatabase().getDialect(),creationContext.getRootClass(),configuration);\nconfigurable.configure(creationContext,parameters);\n}if(generator instanceof ExportableProducer exportableProducer){exportableProducer.registerExportables(creationContext.getDatabase());\n}if(generator instanceof Configurable configurable){configurable.initialize(creationContext.getSqlStringGenerationContext());\n}}",
            "methodSignature: org.hibernate.boot.model.internal.GeneratorBinder#beanContainer\n methodBody: public static BeanContainer beanContainer(MetadataBuildingContext buildingContext) {\nreturn Helper.getBeanContainer(buildingContext.getBootstrapContext().getServiceRegistry());\n}",
            "methodSignature: org.hibernate.boot.model.internal.GeneratorBinder#instantiateGenerator\n methodBody: public static <T extends Generator> T instantiateGenerator(\n\t\t\tBeanContainer beanContainer,\n\t\t\tClass<T> generatorClass) {\nif(beanContainer != null){return instantiateGeneratorAsBean(beanContainer,generatorClass);\n}{return instantiateGeneratorViaDefaultConstructor(generatorClass);\n}}"
        ],
        "sourceCodeAfterRefactoring": "/**\n\t * Set up the {@link GeneratorCreator} for a case where there is no\n\t * generator annotation.\n\t */\n\tprivate static void setGeneratorCreator(\n\t\t\tSimpleValue identifierValue,\n\t\t\tMap<String, Object> configuration,\n\t\t\tString generatorStrategy,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( ASSIGNED_GENERATOR_NAME.equals( generatorStrategy )\n\t\t\t\t|| org.hibernate.id.Assigned.class.getName().equals( generatorStrategy ) ) {\n\t\t\tidentifierValue.setCustomIdGeneratorCreator( ASSIGNED_IDENTIFIER_GENERATOR_CREATOR );\n\t\t}\n\t\telse {\n\t\t\tinstantiateGeneratorBean( identifierValue, generatorStrategy, configuration, context );\n\t\t}\n\t}\nprivate static void instantiateGeneratorBean(\n\t\t\tSimpleValue identifierValue,\n\t\t\tString generatorStrategy,\n\t\t\tMap<String, Object> configuration,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal BeanContainer beanContainer = beanContainer( context );\n\t\tidentifierValue.setCustomIdGeneratorCreator( creationContext -> {\n\t\t\tfinal Generator identifierGenerator =\n\t\t\t\t\tinstantiateGenerator( beanContainer, generatorClass( generatorStrategy, identifierValue ) );\n\t\t\tcallConfigure( creationContext, identifierGenerator, configuration, identifierValue );\n\t\t\tif ( identifierGenerator instanceof IdentityGenerator) {\n\t\t\t\tidentifierValue.setColumnToIdentity();\n\t\t\t}\n\t\t\treturn identifierGenerator;\n\t\t} );\n\t}",
        "diffSourceCode": "-  749: \t\treturn configuration;\n-  750: \t}\n-  751: \n-  752: \t/**\n-  753: \t * Set up the identifier generator for an id defined in a {@code hbm.xml} mapping.\n-  754: \t *\n-  755: \t * @see org.hibernate.boot.model.source.internal.hbm.ModelBinder\n-  756: \t */\n-  757: \tpublic static void makeIdGenerator(\n-  758: \t\t\tfinal MappingDocument sourceDocument,\n-  759: \t\t\tIdentifierGeneratorDefinition definition,\n-  760: \t\t\tSimpleValue identifierValue,\n-  761: \t\t\tMetadataBuildingContext context) {\n-  762: \n-  763: \t\tif ( definition != null ) {\n-  764: \t\t\t// see if the specified generator name matches a registered <identifier-generator/>\n-  765: \t\t\tfinal IdentifierGeneratorDefinition generatorDef =\n-  767: \t\t\t\t\t\t\t.getIdentifierGenerator( definition.getName() );\n-  768: \t\t\tfinal Map<String,Object> configuration = new HashMap<>();\n-  769: \t\t\tfinal String generatorStrategy;\n-  770: \t\t\tif ( generatorDef != null ) {\n-  771: \t\t\t\tgeneratorStrategy = generatorDef.getStrategy();\n-  772: \t\t\t\tconfiguration.putAll( generatorDef.getParameters() );\n-  773: \t\t\t}\n-  774: \t\t\telse {\n-  775: \t\t\t\tgeneratorStrategy = definition.getStrategy();\n-  776: \t\t\t}\n-  777: \n-  778: \t\t\tconfiguration.putAll( definition.getParameters() );\n-  779: \n-  780: \t\t\tsetGeneratorCreator( identifierValue, configuration, generatorStrategy, context );\n-  781: \t\t}\n+  749: \t/**\n+  750: \t * Set up the {@link GeneratorCreator} for a case where there is no\n+  751: \t * generator annotation.\n+  752: \t */\n+  753: \tprivate static void setGeneratorCreator(\n+  754: \t\t\tSimpleValue identifierValue,\n+  755: \t\t\tMap<String, Object> configuration,\n+  756: \t\t\tString generatorStrategy,\n+  757: \t\t\tMetadataBuildingContext context) {\n+  758: \t\tif ( ASSIGNED_GENERATOR_NAME.equals( generatorStrategy )\n+  759: \t\t\t\t|| org.hibernate.id.Assigned.class.getName().equals( generatorStrategy ) ) {\n+  760: \t\t\tidentifierValue.setCustomIdGeneratorCreator( ASSIGNED_IDENTIFIER_GENERATOR_CREATOR );\n+  761: \t\t}\n+  762: \t\telse {\n+  763: \t\t\tinstantiateGeneratorBean( identifierValue, generatorStrategy, configuration, context );\n+  764: \t\t}\n+  765: \t}\n+  767: \tprivate static void instantiateGeneratorBean(\n+  768: \t\t\tSimpleValue identifierValue,\n+  769: \t\t\tString generatorStrategy,\n+  770: \t\t\tMap<String, Object> configuration,\n+  771: \t\t\tMetadataBuildingContext context) {\n+  772: \t\tfinal BeanContainer beanContainer = beanContainer( context );\n+  773: \t\tidentifierValue.setCustomIdGeneratorCreator( creationContext -> {\n+  774: \t\t\tfinal Generator identifierGenerator =\n+  775: \t\t\t\t\tinstantiateGenerator( beanContainer, generatorClass( generatorStrategy, identifierValue ) );\n+  776: \t\t\tcallConfigure( creationContext, identifierGenerator, configuration, identifierValue );\n+  777: \t\t\tif ( identifierGenerator instanceof IdentityGenerator) {\n+  778: \t\t\t\tidentifierValue.setColumnToIdentity();\n+  779: \t\t\t}\n+  780: \t\t\treturn identifierGenerator;\n+  781: \t\t} );\n   782: \t}\n-  791: \t/**\n-  792: \t * Set up the {@link GeneratorCreator} for a case where there is no\n-  793: \t * generator annotation.\n-  794: \t */\n-  795: \tprivate static void setGeneratorCreator(\n-  796: \t\t\tSimpleValue identifierValue,\n-  797: \t\t\tMap<String, Object> configuration,\n-  798: \t\t\tString generatorStrategy,\n-  799: \t\t\tMetadataBuildingContext context) {\n-  800: \t\tif ( ASSIGNED_GENERATOR_NAME.equals( generatorStrategy )\n-  801: \t\t\t\t|| org.hibernate.id.Assigned.class.getName().equals( generatorStrategy ) ) {\n-  802: \t\t\tidentifierValue.setCustomIdGeneratorCreator( ASSIGNED_IDENTIFIER_GENERATOR_CREATOR );\n-  803: \t\t}\n-  804: \t\telse {\n-  805: \t\t\tfinal BeanContainer beanContainer = beanContainer( context );\n-  806: \t\t\tidentifierValue.setCustomIdGeneratorCreator( creationContext -> {\n-  807: \t\t\t\tfinal Generator identifierGenerator =\n-  808: \t\t\t\t\t\tinstantiateGenerator( beanContainer, generatorClass( generatorStrategy, identifierValue ) );\n-  809: \t\t\t\tcallConfigure( creationContext, identifierGenerator, configuration, identifierValue );\n-  810: \t\t\t\tif ( identifierGenerator instanceof IdentityGenerator) {\n-  811: \t\t\t\t\tidentifierValue.setColumnToIdentity();\n-  812: \t\t\t\t}\n-  813: \t\t\t\treturn identifierGenerator;\n-  814: \t\t\t} );\n-  815: \t\t}\n-  816: \t}\n+  791: \t\t\tPropertyData inferredData,\n+  792: \t\t\tSimpleValue idValue,\n+  793: \t\t\tMetadataBuildingContext context) {\n+  794: \n+  795: \t\tfinal SourceModelBuildingContext sourceModelContext =\n+  796: \t\t\t\tcontext.getMetadataCollector().getSourceModelBuildingContext();\n+  797: \t\tfinal MemberDetails idAttributeMember = inferredData.getAttributeMember();\n+  798: \t\tfinal List<? extends Annotation> idGeneratorAnnotations =\n+  799: \t\t\t\tidAttributeMember.getMetaAnnotated( IdGeneratorType.class, sourceModelContext );\n+  800: \t\tfinal List<? extends Annotation> generatorAnnotations =\n+  801: \t\t\t\tidAttributeMember.getMetaAnnotated( ValueGenerationType.class, sourceModelContext );\n+  802: \t\t// Since these collections may contain Proxies created by common-annotations module we cannot reliably use simple remove/removeAll\n+  803: \t\t// collection methods as those proxies do not implement hashcode/equals and even a simple `a.equals(a)` will return `false`.\n+  804: \t\t// Instead, we will check the annotation types, since generator annotations should not be \"repeatable\" we should have only\n+  805: \t\t// at most one annotation for a generator:\n+  806: \t\tfor ( Annotation id : idGeneratorAnnotations ) {\n+  807: \t\t\tgeneratorAnnotations.removeIf( gen -> gen.annotationType().equals( id.annotationType() ) );\n+  808: \t\t}\n+  809: \n+  810: \t\tif ( idGeneratorAnnotations.size() + generatorAnnotations.size() > 1 ) {\n+  811: \t\t\tthrow new AnnotationException( String.format(\n+  812: \t\t\t\t\tLocale.ROOT,\n+  813: \t\t\t\t\t\"Identifier attribute '%s' has too many generator annotations: %s\",\n+  814: \t\t\t\t\tgetPath( propertyHolder, inferredData ),\n+  815: \t\t\t\t\tcombineUntyped( idGeneratorAnnotations, generatorAnnotations )\n+  816: \t\t\t) );\n",
        "uniqueId": "800a3f0738db7294c9684de8bfe4edce99321acb_791_816_767_782_749_765",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 24
            },
            "BRANCH": {
                "missed": 0,
                "covered": 4
            },
            "LINE": {
                "missed": 0,
                "covered": 6
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 3
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\n/**\n * Create a generator, based on a {@link GeneratedValue} annotation.\n */\nprivate static void createIdGeneratorFromGeneratedValue(\n        SimpleValue identifierValue,\n        MemberDetails idAttributeMember,\n        String generatorType,\n        String generatorName,\n        MetadataBuildingContext context,\n        Map<String, ? extends IdentifierGeneratorDefinition> localGenerators) {\n\n    //generator settings\n    final Map<String, Object> configuration = new HashMap<>();\n    configuration.put( GENERATOR_NAME, generatorName );\n    configuration.put( PersistentIdentifierGenerator.TABLE, identifierValue.getTable().getName() );\n    if (identifierValue.getColumnSpan() == 1) {\n        configuration.put( PersistentIdentifierGenerator.PK, identifierValue.getColumns().get(0).getName() );\n    }\n\n    if (generatorName.isEmpty()) {\n        final GeneratedValue generatedValue = idAttributeMember.getDirectAnnotationUsage(GeneratedValue.class);\n        if (generatedValue != null) {\n            // The mapping used @GeneratedValue but specified no name. This is a special case added in JPA 3.2.\n            // Look for a matching \"implied generator\" based on the GenerationType\n\n            final GenerationType strategy = generatedValue.strategy();\n            final String strategyGeneratorClassName = correspondingGeneratorName(strategy);\n\n            final IdentifierGeneratorDefinition impliedGenerator = determineImpliedGenerator(\n                    strategy,\n                    strategyGeneratorClassName,\n                    localGenerators\n            );\n\n            if (impliedGenerator != null) {\n                configuration.putAll(impliedGenerator.getParameters());\n\n                final BeanContainer beanContainer = beanContainer(context);\n                identifierValue.setCustomIdGeneratorCreator(creationContext -> {\n                    final Generator identifierGenerator = instantiateGenerator(\n                            beanContainer,\n                            generatorClass(strategyGeneratorClassName, identifierValue)\n                    );\n                    callConfigure(creationContext, identifierGenerator, configuration, identifierValue);\n                    if (identifierGenerator instanceof IdentityGenerator) {\n                        identifierValue.setColumnToIdentity();\n                    }\n                    return identifierGenerator;\n                });\n\n                return;\n            }\n        }\n    }\n\n    final String generatorStrategy = determineStrategy(\n            idAttributeMember,\n            generatorType,\n            generatorName,\n            context,\n            localGenerators,\n            configuration\n    );\n    setGeneratorCreator(identifierValue, configuration, generatorStrategy, context);\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n\t * Set up the {@link GeneratorCreator} for a case where there is no\n\t * generator annotation.\n\t */\n\tprivate static void setGeneratorCreator(\n\t\t\tSimpleValue identifierValue,\n\t\t\tMap<String, Object> configuration,\n\t\t\tString generatorStrategy,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( ASSIGNED_GENERATOR_NAME.equals( generatorStrategy )\n\t\t\t\t|| org.hibernate.id.Assigned.class.getName().equals( generatorStrategy ) ) {\n\t\t\tidentifierValue.setCustomIdGeneratorCreator( ASSIGNED_IDENTIFIER_GENERATOR_CREATOR );\n\t\t}\n\t\telse {\n\t\t\tfinal BeanContainer beanContainer = beanContainer( context );\n\t\t\tidentifierValue.setCustomIdGeneratorCreator( creationContext -> {\n\t\t\t\tfinal Generator identifierGenerator =\n\t\t\t\t\t\tinstantiateGenerator( beanContainer, generatorClass( generatorStrategy, identifierValue ) );\n\t\t\t\tcallConfigure( creationContext, identifierGenerator, configuration, identifierValue );\n\t\t\t\tif ( identifierGenerator instanceof IdentityGenerator) {\n\t\t\t\t\tidentifierValue.setColumnToIdentity();\n\t\t\t\t}\n\t\t\t\treturn identifierGenerator;\n\t\t\t} );\n\t\t}\n\t}\n\nClass content:\n/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.boot.model.internal;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Member;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.function.BiConsumer;\nimport java.util.function.Consumer;\n\nimport org.hibernate.AnnotationException;\nimport org.hibernate.AssertionFailure;\nimport org.hibernate.MappingException;\nimport org.hibernate.annotations.GenericGenerator;\nimport org.hibernate.annotations.IdGeneratorType;\nimport org.hibernate.annotations.ValueGenerationType;\nimport org.hibernate.boot.model.IdentifierGeneratorDefinition;\nimport org.hibernate.boot.model.relational.ExportableProducer;\nimport org.hibernate.boot.model.source.internal.hbm.MappingDocument;\nimport org.hibernate.boot.models.spi.GlobalRegistrar;\nimport org.hibernate.boot.spi.InFlightMetadataCollector;\nimport org.hibernate.boot.spi.MetadataBuildingContext;\nimport org.hibernate.boot.spi.PropertyData;\nimport org.hibernate.generator.AnnotationBasedGenerator;\nimport org.hibernate.generator.Assigned;\nimport org.hibernate.generator.BeforeExecutionGenerator;\nimport org.hibernate.generator.Generator;\nimport org.hibernate.generator.GeneratorCreationContext;\nimport org.hibernate.generator.OnExecutionGenerator;\nimport org.hibernate.id.Configurable;\nimport org.hibernate.id.IdentifierGenerator;\nimport org.hibernate.id.IdentityGenerator;\nimport org.hibernate.id.PersistentIdentifierGenerator;\nimport org.hibernate.id.enhanced.SequenceStyleGenerator;\nimport org.hibernate.id.uuid.UuidValueGenerator;\nimport org.hibernate.internal.CoreLogging;\nimport org.hibernate.internal.CoreMessageLogger;\nimport org.hibernate.internal.util.StringHelper;\nimport org.hibernate.mapping.GeneratorCreator;\nimport org.hibernate.mapping.KeyValue;\nimport org.hibernate.mapping.PersistentClass;\nimport org.hibernate.mapping.SimpleValue;\nimport org.hibernate.models.spi.AnnotationTarget;\nimport org.hibernate.models.spi.MemberDetails;\nimport org.hibernate.models.spi.SourceModelBuildingContext;\nimport org.hibernate.resource.beans.container.spi.BeanContainer;\nimport org.hibernate.resource.beans.internal.Helper;\n\nimport jakarta.persistence.GeneratedValue;\nimport jakarta.persistence.GenerationType;\nimport jakarta.persistence.SequenceGenerator;\nimport jakarta.persistence.TableGenerator;\nimport jakarta.persistence.Version;\n\nimport static jakarta.persistence.GenerationType.AUTO;\nimport static java.util.Collections.emptyMap;\nimport static org.hibernate.boot.model.internal.AnnotationHelper.extractParameterMap;\nimport static org.hibernate.boot.model.internal.BinderHelper.getPath;\nimport static org.hibernate.boot.model.internal.BinderHelper.isGlobalGeneratorNameGlobal;\nimport static org.hibernate.boot.model.internal.GeneratorParameters.collectParameters;\nimport static org.hibernate.boot.model.internal.GeneratorParameters.interpretSequenceGenerator;\nimport static org.hibernate.boot.model.internal.GeneratorParameters.interpretTableGenerator;\nimport static org.hibernate.boot.model.internal.GeneratorStrategies.generatorClass;\nimport static org.hibernate.id.IdentifierGenerator.GENERATOR_NAME;\nimport static org.hibernate.internal.util.NullnessUtil.castNonNull;\nimport static org.hibernate.internal.util.StringHelper.qualify;\nimport static org.hibernate.internal.util.collections.CollectionHelper.combineUntyped;\nimport static org.hibernate.resource.beans.internal.Helper.allowExtensionsInCdi;\n\n/**\n * Responsible for configuring and instantiating {@link Generator}s.\n *\n * @author Gavin King\n */\npublic class GeneratorBinder {\n\n\tprivate static final CoreMessageLogger LOG = CoreLogging.messageLogger( GeneratorBinder.class );\n\n\tpublic static final String ASSIGNED_GENERATOR_NAME = \"assigned\";\n\tpublic static final GeneratorCreator ASSIGNED_IDENTIFIER_GENERATOR_CREATOR =\n\t\t\tnew GeneratorCreator() {\n\t\t\t\t@Override\n\t\t\t\tpublic Generator createGenerator(GeneratorCreationContext context) {\n\t\t\t\t\treturn new Assigned();\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic boolean isAssigned() {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t};\n\n\t/**\n\t * Create a generator, based on a {@link GeneratedValue} annotation.\n\t */\n\tpublic static void makeIdGenerator(\n\t\t\tSimpleValue identifierValue,\n\t\t\tMemberDetails idAttributeMember,\n\t\t\tString generatorType,\n\t\t\tString generatorName,\n\t\t\tMetadataBuildingContext context,\n\t\t\tMap<String, ? extends IdentifierGeneratorDefinition> localGenerators) {\n\n\t\t//generator settings\n\t\tfinal Map<String,Object> configuration = new HashMap<>();\n\t\tconfiguration.put( GENERATOR_NAME, generatorName );\n\t\tconfiguration.put( PersistentIdentifierGenerator.TABLE, identifierValue.getTable().getName() );\n\t\tif ( identifierValue.getColumnSpan() == 1 ) {\n\t\t\tconfiguration.put( PersistentIdentifierGenerator.PK, identifierValue.getColumns().get(0).getName() );\n\t\t}\n\n\t\tif ( generatorName.isEmpty() ) {\n\t\t\tfinal GeneratedValue generatedValue = idAttributeMember.getDirectAnnotationUsage( GeneratedValue.class );\n\t\t\tif ( generatedValue != null ) {\n\t\t\t\t// The mapping used @GeneratedValue but specified no name.  This is a special case added in JPA 3.2.\n\t\t\t\t// Look for a matching \"implied generator\" based on the GenerationType\n\n\t\t\t\tfinal GenerationType strategy = generatedValue.strategy();\n\t\t\t\tfinal String strategyGeneratorClassName = correspondingGeneratorName( strategy );\n\n\t\t\t\tfinal IdentifierGeneratorDefinition impliedGenerator = determineImpliedGenerator(\n\t\t\t\t\t\tstrategy,\n\t\t\t\t\t\tstrategyGeneratorClassName,\n\t\t\t\t\t\tlocalGenerators\n\t\t\t\t);\n\n\t\t\t\tif ( impliedGenerator != null ) {\n\t\t\t\t\tconfiguration.putAll( impliedGenerator.getParameters() );\n\n\t\t\t\t\tfinal BeanContainer beanContainer = beanContainer( context );\n\t\t\t\t\tidentifierValue.setCustomIdGeneratorCreator( creationContext -> {\n\t\t\t\t\t\tfinal Generator identifierGenerator = instantiateGenerator(\n\t\t\t\t\t\t\t\tbeanContainer,\n\t\t\t\t\t\t\t\tgeneratorClass( strategyGeneratorClassName, identifierValue )\n\t\t\t\t\t\t);\n\t\t\t\t\t\tcallConfigure( creationContext, identifierGenerator, configuration, identifierValue );\n\t\t\t\t\t\tif ( identifierGenerator instanceof IdentityGenerator) {\n\t\t\t\t\t\t\tidentifierValue.setColumnToIdentity();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn identifierGenerator;\n\t\t\t\t\t} );\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfinal String generatorStrategy = determineStrategy(\n\t\t\t\tidAttributeMember,\n\t\t\t\tgeneratorType,\n\t\t\t\tgeneratorName,\n\t\t\t\tcontext,\n\t\t\t\tlocalGenerators,\n\t\t\t\tconfiguration\n\t\t);\n\t\tsetGeneratorCreator( identifierValue, configuration, generatorStrategy, context );\n\t}\n\n\tprivate static IdentifierGeneratorDefinition determineImpliedGenerator(\n\t\t\tGenerationType strategy,\n\t\t\tString strategyGeneratorClassName,\n\t\t\tMap<String, ? extends IdentifierGeneratorDefinition> localGenerators) {\n\t\tif ( localGenerators == null ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( localGenerators.size() == 1 ) {\n\t\t\tfinal IdentifierGeneratorDefinition generatorDefinition = localGenerators.entrySet().iterator().next().getValue();\n\t\t\t// NOTE : a little bit of a special rule here for the case of just one -\n\t\t\t// \t\twe consider it a match, based on strategy, if the strategy is AUTO or matches...\n\t\t\tif ( strategy == AUTO\n\t\t\t\t\t|| isImpliedGenerator( strategy, strategyGeneratorClassName, generatorDefinition ) ) {\n\t\t\t\treturn generatorDefinition;\n\t\t\t}\n\t\t}\n\n\t\tIdentifierGeneratorDefinition matching = null;\n\t\tfor ( Map.Entry<String, ? extends IdentifierGeneratorDefinition> localGeneratorEntry : localGenerators.entrySet() ) {\n\t\t\tif ( isImpliedGenerator( strategy, strategyGeneratorClassName, localGeneratorEntry.getValue() ) ) {\n\t\t\t\tif ( matching != null ) {\n\t\t\t\t\t// we found multiple matching generators\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tmatching = localGeneratorEntry.getValue();\n\t\t\t}\n\t\t}\n\t\treturn matching;\n\t}\n\n\tprivate static boolean isImpliedGenerator(\n\t\t\tGenerationType strategy,\n\t\t\tString strategyGeneratorClassName,\n\t\t\tIdentifierGeneratorDefinition generatorDefinition) {\n\t\treturn generatorDefinition.getStrategy().equals( strategyGeneratorClassName );\n\t}\n\n\tprivate static String correspondingGeneratorName(GenerationType strategy) {\n\t\treturn switch ( strategy ) {\n//\t\t\tcase UUID -> org.hibernate.id.uuid.UuidGenerator.class.getName();\n\t\t\tcase UUID -> UuidValueGenerator.class.getName();\n\t\t\tcase TABLE -> org.hibernate.id.enhanced.TableGenerator.class.getName();\n\t\t\tcase IDENTITY -> null;\n\t\t\tdefault -> SequenceStyleGenerator.class.getName();\n\t\t};\n\t}\n\n\tprivate static String determineStrategy(\n\t\t\tMemberDetails idAttributeMember,\n\t\t\tString generatorType,\n\t\t\tString generatorName,\n\t\t\tMetadataBuildingContext context,\n\t\t\tMap<String, ? extends IdentifierGeneratorDefinition> localGenerators,\n\t\t\tMap<String, Object> configuration) {\n\t\tif ( !generatorName.isEmpty() ) {\n\t\t\t//we have a named generator\n\t\t\tfinal IdentifierGeneratorDefinition definition =\n\t\t\t\t\tmakeIdentifierGeneratorDefinition( generatorName, idAttributeMember, localGenerators, context );\n\t\t\tif ( definition == null ) {\n\t\t\t\tthrow new AnnotationException( \"No id generator was declared with the name '\" + generatorName\n\t\t\t\t\t\t+ \"' specified by '@GeneratedValue'\"\n\t\t\t\t\t\t+ \" (define a named generator using '@SequenceGenerator', '@TableGenerator', or '@GenericGenerator')\" );\n\t\t\t}\n\t\t\t//This is quite vague in the spec but a generator could override the generator choice\n\t\t\tfinal String generatorStrategy =\n\t\t\t\t\tgeneratorType == null\n\t\t\t\t\t\t//yuk! this is a hack not to override 'AUTO' even if generator is set\n\t\t\t\t\t\t|| !definition.getStrategy().equals( \"identity\" )\n\t\t\t\t\t\t\t? definition.getStrategy()\n\t\t\t\t\t\t\t: generatorType;\n\t\t\t//checkIfMatchingGenerator(definition, generatorType, generatorName);\n\t\t\tconfiguration.putAll( definition.getParameters() );\n\t\t\treturn generatorStrategy;\n\t\t}\n\t\telse {\n\t\t\treturn generatorType;\n\t\t}\n\t}\n\n\tprivate static IdentifierGeneratorDefinition makeIdentifierGeneratorDefinition(\n\t\t\tString name,\n\t\t\tMemberDetails idAttributeMember,\n\t\t\tMap<String, ? extends IdentifierGeneratorDefinition> localGenerators,\n\t\t\tMetadataBuildingContext buildingContext) {\n\t\tif ( localGenerators != null ) {\n\t\t\tfinal IdentifierGeneratorDefinition result = localGenerators.get( name );\n\t\t\tif ( result != null ) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tfinal IdentifierGeneratorDefinition globalDefinition =\n\t\t\t\tbuildingContext.getMetadataCollector().getIdentifierGenerator( name );\n\t\tif ( globalDefinition != null ) {\n\t\t\treturn globalDefinition;\n\t\t}\n\n\t\tLOG.debugf( \"Could not resolve explicit IdentifierGeneratorDefinition - using implicit interpretation (%s)\", name );\n\n\t\tfinal GeneratedValue generatedValue = idAttributeMember.getDirectAnnotationUsage( GeneratedValue.class );\n\t\tif ( generatedValue == null ) {\n\t\t\tthrow new AssertionFailure( \"No @GeneratedValue annotation\" );\n\t\t}\n\n\t\treturn IdentifierGeneratorDefinition.createImplicit(\n\t\t\t\tname,\n\t\t\t\tidAttributeMember.getType(),\n\t\t\t\tgeneratedValue.generator(),\n\t\t\t\tinterpretGenerationType( generatedValue )\n\t\t);\n\t}\n\n\tprivate static GenerationType interpretGenerationType(GeneratedValue generatedValueAnn) {\n\t\t// todo (jpa32) : when can this ever be null?\n\t\tfinal GenerationType strategy = generatedValueAnn.strategy();\n\t\treturn strategy == null ? AUTO : strategy;\n\t}\n\n\tpublic static void visitIdGeneratorDefinitions(\n\t\t\tAnnotationTarget annotatedElement,\n\t\t\tConsumer<IdentifierGeneratorDefinition> consumer,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal InFlightMetadataCollector metadataCollector = context.getMetadataCollector();\n\t\tfinal SourceModelBuildingContext sourceModelContext = metadataCollector.getSourceModelBuildingContext();\n\n\t\tannotatedElement.forEachAnnotationUsage( TableGenerator.class, sourceModelContext, (usage) -> {\n\t\t\tfinal IdentifierGeneratorDefinition idGenerator = buildTableIdGenerator( usage );\n\t\t\tconsumer.accept( idGenerator );\n\t\t} );\n\n\t\tannotatedElement.forEachAnnotationUsage( SequenceGenerator.class, sourceModelContext, (usage) -> {\n\t\t\tfinal IdentifierGeneratorDefinition idGenerator = buildSequenceIdGenerator( usage );\n\t\t\tconsumer.accept( idGenerator );\n\t\t} );\n\n\t\tannotatedElement.forEachAnnotationUsage( GenericGenerator.class, sourceModelContext, (usage) -> {\n\t\t\tfinal IdentifierGeneratorDefinition idGenerator = buildIdGenerator( usage );\n\t\t\tconsumer.accept( idGenerator );\n\t\t} );\n\n\t}\n\n\tpublic static void registerGlobalGenerators(\n\t\t\tAnnotationTarget annotatedElement,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( !context.getBootstrapContext().getJpaCompliance().isGlobalGeneratorScopeEnabled() ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal InFlightMetadataCollector metadataCollector = context.getMetadataCollector();\n\t\tvisitIdGeneratorDefinitions(\n\t\t\t\tannotatedElement,\n\t\t\t\t(definition) -> {\n\t\t\t\t\tif ( !definition.getName().isEmpty() ) {\n\t\t\t\t\t\tmetadataCollector.addIdentifierGenerator( definition );\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tcontext\n\t\t);\n\t}\n\n\tprivate static IdentifierGeneratorDefinition buildIdGenerator(GenericGenerator generatorAnnotation) {\n\t\tfinal IdentifierGeneratorDefinition.Builder definitionBuilder =\n\t\t\t\tnew IdentifierGeneratorDefinition.Builder();\n\t\tdefinitionBuilder.setName( generatorAnnotation.name() );\n\t\tfinal Class<? extends Generator> generatorClass = generatorAnnotation.type();\n\t\tfinal String strategy =\n\t\t\t\tgeneratorClass.equals( Generator.class )\n\t\t\t\t\t\t? generatorAnnotation.strategy()\n\t\t\t\t\t\t: generatorClass.getName();\n\t\tdefinitionBuilder.setStrategy( strategy );\n\t\tdefinitionBuilder.addParams( extractParameterMap( generatorAnnotation.parameters() ) );\n\n\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\tLOG.tracev( \"Added generator with name: {0}, strategy: {0}\",\n\t\t\t\t\tdefinitionBuilder.getName(), definitionBuilder.getStrategy() );\n\t\t}\n\n\t\treturn definitionBuilder.build();\n\t}\n\n\tprivate static IdentifierGeneratorDefinition buildSequenceIdGenerator(SequenceGenerator generatorAnnotation) {\n\t\tfinal IdentifierGeneratorDefinition.Builder definitionBuilder = new IdentifierGeneratorDefinition.Builder();\n\t\tinterpretSequenceGenerator( generatorAnnotation, definitionBuilder );\n\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\tLOG.tracev( \"Add sequence generator with name: {0}\", definitionBuilder.getName() );\n\t\t}\n\t\treturn definitionBuilder.build();\n\t}\n\n\tprivate static IdentifierGeneratorDefinition buildTableIdGenerator(TableGenerator generatorAnnotation) {\n\t\tfinal IdentifierGeneratorDefinition.Builder definitionBuilder = new IdentifierGeneratorDefinition.Builder();\n\t\tinterpretTableGenerator( generatorAnnotation, definitionBuilder );\n\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\tLOG.tracev( \"Add sequence generator with name: {0}\", definitionBuilder.getName() );\n\t\t}\n\t\treturn definitionBuilder.build();\n\t}\n\n\tprivate static void checkGeneratorClass(Class<? extends Generator> generatorClass) {\n\t\tif ( !BeforeExecutionGenerator.class.isAssignableFrom( generatorClass )\n\t\t\t\t&& !OnExecutionGenerator.class.isAssignableFrom( generatorClass ) ) {\n\t\t\tthrow new MappingException(\"Generator class '\" + generatorClass.getName()\n\t\t\t\t\t+ \"' must implement either 'BeforeExecutionGenerator' or 'OnExecutionGenerator'\");\n\t\t}\n\t}\n\n\tprivate static void checkGeneratorInterfaces(Class<? extends Generator> generatorClass) {\n\t\t// we don't yet support the additional \"fancy\" operations of\n\t\t// IdentifierGenerator with regular generators, though this\n\t\t// would be extremely easy to add if anyone asks for it\n\t\tif ( IdentifierGenerator.class.isAssignableFrom( generatorClass ) ) {\n\t\t\tthrow new AnnotationException(\"Generator class '\" + generatorClass.getName()\n\t\t\t\t\t+ \"' implements 'IdentifierGenerator' and may not be used with '@ValueGenerationType'\");\n\t\t}\n\t\tif ( ExportableProducer.class.isAssignableFrom( generatorClass ) ) {\n\t\t\tthrow new AnnotationException(\"Generator class '\" + generatorClass.getName()\n\t\t\t\t\t+ \"' implements 'ExportableProducer' and may not be used with '@ValueGenerationType'\");\n\t\t}\n\t}\n\n\t/**\n\t * Return a {@link GeneratorCreator} for an attribute annotated\n\t * with a {@linkplain ValueGenerationType generator annotation}.\n\t */\n\tprivate static GeneratorCreator generatorCreator(\n\t\t\tMemberDetails memberDetails,\n\t\t\tAnnotation annotation,\n\t\t\tBeanContainer beanContainer) {\n\t\tfinal Class<? extends Annotation> annotationType = annotation.annotationType();\n\t\tfinal ValueGenerationType generatorAnnotation = annotationType.getAnnotation( ValueGenerationType.class );\n\t\tassert generatorAnnotation != null;\n\t\tfinal Class<? extends Generator> generatorClass = generatorAnnotation.generatedBy();\n\t\tcheckGeneratorClass( generatorClass );\n\t\tcheckGeneratorInterfaces( generatorClass );\n\t\treturn creationContext -> {\n\t\t\tfinal Generator generator = instantiateGenerator(\n\t\t\t\t\tannotation,\n\t\t\t\t\tbeanContainer,\n\t\t\t\t\tcreationContext,\n\t\t\t\t\tgeneratorClass,\n\t\t\t\t\tmemberDetails,\n\t\t\t\t\tannotationType\n\t\t\t);\n\t\t\tcallInitialize( annotation, memberDetails, creationContext, generator );\n\t\t\t//TODO: callConfigure( creationContext, generator, emptyMap(), identifierValue );\n\t\t\tcheckVersionGenerationAlways( memberDetails, generator );\n\t\t\treturn generator;\n\t\t};\n\t}\n\n\t/**\n\t * Return a {@link GeneratorCreator} for an id attribute annotated\n\t * with an {@linkplain IdGeneratorType id generator annotation}.\n\t */\n\tprivate static GeneratorCreator identifierGeneratorCreator(\n\t\t\tMemberDetails idAttributeMember,\n\t\t\tAnnotation annotation,\n\t\t\tSimpleValue identifierValue,\n\t\t\tBeanContainer beanContainer) {\n\t\tfinal Class<? extends Annotation> annotationType = annotation.annotationType();\n\t\tfinal IdGeneratorType idGeneratorAnnotation = annotationType.getAnnotation( IdGeneratorType.class );\n\t\tassert idGeneratorAnnotation != null;\n\t\tfinal Class<? extends Generator> generatorClass = idGeneratorAnnotation.value();\n\t\tcheckGeneratorClass( generatorClass );\n\t\treturn creationContext -> {\n\t\t\tfinal Generator generator =\n\t\t\t\t\tinstantiateGenerator(\n\t\t\t\t\t\t\tannotation,\n\t\t\t\t\t\t\tbeanContainer,\n\t\t\t\t\t\t\tcreationContext,\n\t\t\t\t\t\t\tgeneratorClass,\n\t\t\t\t\t\t\tidAttributeMember,\n\t\t\t\t\t\t\tannotationType\n\t\t\t\t\t);\n\t\t\tcallInitialize( annotation, idAttributeMember, creationContext, generator );\n\t\t\tcallConfigure( creationContext, generator, emptyMap(), identifierValue );\n\t\t\tcheckIdGeneratorTiming( annotationType, generator );\n\t\t\treturn generator;\n\t\t};\n\t}\n\n\t/**\n\t * Instantiate a {@link Generator}, using the given {@link BeanContainer} if any,\n\t * for the case where the generator was specified using a generator annotation.\n\t *\n\t * @param annotation the generator annotation\n\t * @param beanContainer an optional {@code BeanContainer}\n\t * @param generatorClass a class which implements {@code Generator}\n\t */\n\tprivate static Generator instantiateGenerator(\n\t\t\tAnnotation annotation,\n\t\t\tBeanContainer beanContainer,\n\t\t\tGeneratorCreationContext creationContext,\n\t\t\tClass<? extends Generator> generatorClass,\n\t\t\tMemberDetails memberDetails,\n\t\t\tClass<? extends Annotation> annotationType) {\n\t\tif ( beanContainer != null ) {\n\t\t\treturn instantiateGeneratorAsBean(\n\t\t\t\t\tannotation,\n\t\t\t\t\tbeanContainer,\n\t\t\t\t\tcreationContext,\n\t\t\t\t\tgeneratorClass,\n\t\t\t\t\tmemberDetails,\n\t\t\t\t\tannotationType\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn instantiateGenerator(\n\t\t\t\t\tannotation,\n\t\t\t\t\tmemberDetails,\n\t\t\t\t\tannotationType,\n\t\t\t\t\tcreationContext,\n\t\t\t\t\tgeneratorClass\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Instantiate a {@link Generator}, using the given {@link BeanContainer},\n\t * for the case where the generator was specified using a generator annotation.\n\t *\n\t * @param annotation the generator annotation\n\t * @param beanContainer an optional {@code BeanContainer}\n\t * @param generatorClass a class which implements {@code Generator}\n\t */\n\tprivate static Generator instantiateGeneratorAsBean(\n\t\t\tAnnotation annotation,\n\t\t\tBeanContainer beanContainer,\n\t\t\tGeneratorCreationContext creationContext,\n\t\t\tClass<? extends Generator> generatorClass,\n\t\t\tMemberDetails memberDetails,\n\t\t\tClass<? extends Annotation> annotationType) {\n\t\treturn Helper.getBean(\n\t\t\tbeanContainer,\n\t\t\tgeneratorClass,\n\t\t\tfalse,\n\t\t\ttrue,\n\t\t\t() -> instantiateGenerator(\n\t\t\t\tannotation,\n\t\t\t\tmemberDetails,\n\t\t\t\tannotationType,\n\t\t\t\tcreationContext,\n\t\t\t\tgeneratorClass\n\t\t\t)\n\t\t);\n\t}\n\n\t/**\n\t * Instantiate a {@link Generator}, using the given {@link BeanContainer},\n\t * for the case where no generator annotation is available.\n\t *\n\t * @param beanContainer an optional {@code BeanContainer}\n\t * @param generatorClass a class which implements {@code Generator}\n\t */\n\tprivate static <T extends Generator> T instantiateGeneratorAsBean(\n\t\t\tBeanContainer beanContainer,\n\t\t\tClass<T> generatorClass) {\n\t\treturn Helper.getBean(\n\t\t\tbeanContainer,\n\t\t\tgeneratorClass,\n\t\t\tfalse,\n\t\t\ttrue,\n\t\t\t() -> instantiateGeneratorViaDefaultConstructor( generatorClass )\n\t\t);\n\t}\n\n\t/**\n\t * Instantiate a {@link Generator} by calling an appropriate constructor,\n\t * for the case where the generator was specified using a generator annotation.\n\t * We look for three possible signatures:\n\t * <ol>\n\t *     <li>{@code (Annotation, Member, GeneratorCreationContext)}</li>\n\t *     <li>{@code (Annotation)}</li>\n\t *     <li>{@code ()}</li>\n\t * </ol>\n\t * where {@code Annotation} is the generator annotation type.\n\t *\n\t * @param annotation the generator annotation\n\t * @param generatorClass a class which implements {@code Generator}\n\t */\n\tprivate static <G extends Generator> G instantiateGenerator(\n\t\t\tAnnotation annotation,\n\t\t\tMemberDetails memberDetails,\n\t\t\tClass<? extends Annotation> annotationType,\n\t\t\tGeneratorCreationContext creationContext,\n\t\t\tClass<? extends G> generatorClass) {\n\t\ttry {\n\t\t\ttry {\n\t\t\t\treturn generatorClass.getConstructor( annotationType, Member.class, GeneratorCreationContext.class )\n\t\t\t\t\t\t.newInstance( annotation, memberDetails.toJavaMember(), creationContext);\n\t\t\t}\n\t\t\tcatch (NoSuchMethodException ignore) {\n\t\t\t\ttry {\n\t\t\t\t\treturn generatorClass.getConstructor( annotationType )\n\t\t\t\t\t\t\t.newInstance( annotation );\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchMethodException i) {\n\t\t\t\t\treturn instantiateGeneratorViaDefaultConstructor( generatorClass );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (InvocationTargetException | InstantiationException | IllegalAccessException | IllegalArgumentException e) {\n\t\t\tthrow new org.hibernate.InstantiationException( \"Could not instantiate id generator\", generatorClass, e );\n\t\t}\n\t}\n\n\t/**\n\t * Instantiate a {@link Generator}, using the given {@link BeanContainer} if any,\n\t * or by calling the default constructor otherwise.\n\t *\n\t * @param beanContainer an optional {@code BeanContainer}\n\t * @param generatorClass a class which implements {@code Generator}\n\t */\n\tpublic static <T extends Generator> T instantiateGenerator(\n\t\t\tBeanContainer beanContainer,\n\t\t\tClass<T> generatorClass) {\n\t\tif ( beanContainer != null ) {\n\t\t\treturn instantiateGeneratorAsBean( beanContainer, generatorClass );\n\t\t}\n\t\telse {\n\t\t\treturn instantiateGeneratorViaDefaultConstructor( generatorClass );\n\t\t}\n\t}\n\n\t/**\n\t * Instantiate a {@link Generator} by calling the default constructor.\n\t */\n\tprivate static <G extends Generator> G instantiateGeneratorViaDefaultConstructor(Class<? extends G> generatorClass) {\n\t\ttry {\n\t\t\treturn generatorClass.getDeclaredConstructor().newInstance();\n\t\t}\n\t\tcatch (NoSuchMethodException e) {\n\t\t\tthrow new org.hibernate.InstantiationException( \"No appropriate constructor for id generator class\", generatorClass);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new org.hibernate.InstantiationException( \"Could not instantiate id generator\", generatorClass, e );\n\t\t}\n\t}\n\n\tpublic static <A extends Annotation> void callInitialize(\n\t\t\tA annotation,\n\t\t\tMemberDetails memberDetails,\n\t\t\tGeneratorCreationContext creationContext,\n\t\t\tGenerator generator) {\n\t\tif ( generator instanceof AnnotationBasedGenerator ) {\n\t\t\t// This will cause a CCE in case the generation type doesn't match the annotation type; As this would be\n\t\t\t// a programming error of the generation type developer and thus should show up during testing, we don't\n\t\t\t// check this explicitly; If required, this could be done e.g. using ClassMate\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tfinal AnnotationBasedGenerator<A> generation = (AnnotationBasedGenerator<A>) generator;\n\t\t\tgeneration.initialize( annotation, memberDetails.toJavaMember(), creationContext );\n\t\t}\n\t}\n\n\tprivate static void checkVersionGenerationAlways(MemberDetails property, Generator generator) {\n\t\tif ( property.hasDirectAnnotationUsage( Version.class ) ) {\n\t\t\tif ( !generator.generatesOnInsert() ) {\n\t\t\t\tthrow new AnnotationException(\"Property '\" + property.getName()\n\t\t\t\t\t\t+ \"' is annotated '@Version' but has a 'Generator' which does not generate on inserts\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tif ( !generator.generatesOnUpdate() ) {\n\t\t\t\tthrow new AnnotationException(\"Property '\" + property.getName()\n\t\t\t\t\t\t+ \"' is annotated '@Version' but has a 'Generator' which does not generate on updates\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * If the given {@link Generator} also implements {@link Configurable},\n\t * call its {@link Configurable#configure(GeneratorCreationContext, Properties)\n\t * configure()} method.\n\t */\n\tpublic static void callConfigure(\n\t\t\tGeneratorCreationContext creationContext,\n\t\t\tGenerator generator,\n\t\t\tMap<String, Object> configuration,\n\t\t\tSimpleValue identifierValue) {\n\t\tif ( generator instanceof Configurable configurable ) {\n\t\t\tfinal Properties parameters = collectParameters(\n\t\t\t\t\tidentifierValue,\n\t\t\t\t\tcreationContext.getDatabase().getDialect(),\n\t\t\t\t\tcreationContext.getRootClass(),\n\t\t\t\t\tconfiguration\n\t\t\t);\n\t\t\tconfigurable.configure( creationContext, parameters );\n\t\t}\n\t\tif ( generator instanceof ExportableProducer exportableProducer ) {\n\t\t\texportableProducer.registerExportables( creationContext.getDatabase() );\n\t\t}\n\t\tif ( generator instanceof Configurable configurable ) {\n\t\t\tconfigurable.initialize( creationContext.getSqlStringGenerationContext() );\n\t\t}\n\t}\n\n\tprivate static void checkIdGeneratorTiming(Class<? extends Annotation> annotationType, Generator generator) {\n\t\tif ( !generator.generatesOnInsert() ) {\n\t\t\tthrow new MappingException( \"Annotation '\" + annotationType\n\t\t\t\t\t+ \"' is annotated 'IdGeneratorType' but the given 'Generator' does not generate on inserts\");\n\t\t}\n\t\tif ( generator.generatesOnUpdate() ) {\n\t\t\tthrow new MappingException( \"Annotation '\" + annotationType\n\t\t\t\t\t+ \"' is annotated 'IdGeneratorType' but the given 'Generator' generates on updates (it must generate only on inserts)\");\n\t\t}\n\t}\n\n\t/**\n\t * Create a generator, based on a {@link GeneratedValue} annotation.\n\t */\n\tprivate static void createIdGenerator(\n\t\t\tMemberDetails idMember,\n\t\t\tSimpleValue idValue,\n\t\t\tPersistentClass persistentClass,\n\t\t\tMetadataBuildingContext context) {\n\t\t// NOTE: `generatedValue` is never null here\n\t\tfinal GeneratedValue generatedValue = castNonNull( idMember.getDirectAnnotationUsage( GeneratedValue.class ) );\n\n\t\tfinal InFlightMetadataCollector metadataCollector = context.getMetadataCollector();\n\t\tif ( isGlobalGeneratorNameGlobal( context ) ) {\n\t\t\t// process and register any generators defined on the member.\n\t\t\t// according to JPA these are also global.\n\t\t\tmetadataCollector.getGlobalRegistrations().as( GlobalRegistrar.class ).collectIdGenerators( idMember );\n\t\t\tmetadataCollector.addSecondPass( new StrictIdGeneratorResolverSecondPass(\n\t\t\t\t\tpersistentClass,\n\t\t\t\t\tidValue,\n\t\t\t\t\tidMember,\n\t\t\t\t\tgeneratedValue,\n\t\t\t\t\tcontext\n\t\t\t) );\n\t\t}\n\t\telse {\n\t\t\tmetadataCollector.addSecondPass( new IdGeneratorResolverSecondPass(\n\t\t\t\t\tpersistentClass,\n\t\t\t\t\tidValue,\n\t\t\t\t\tidMember,\n\t\t\t\t\tgeneratedValue,\n\t\t\t\t\tcontext\n\t\t\t) );\n\t\t}\n\t}\n\n\tpublic static void createGeneratorFrom(\n\t\t\tIdentifierGeneratorDefinition defaultedGenerator,\n\t\t\tSimpleValue idValue,\n\t\t\tMap<String, Object> configuration,\n\t\t\tMetadataBuildingContext context) {\n\t\tconfiguration.putAll( defaultedGenerator.getParameters() );\n\n\t\tfinal BeanContainer beanContainer = beanContainer( context );\n\t\tidValue.setCustomIdGeneratorCreator( creationContext -> {\n\t\t\tfinal Generator identifierGenerator = instantiateGenerator(\n\t\t\t\t\tbeanContainer,\n\t\t\t\t\tgeneratorClass( defaultedGenerator.getStrategy(), idValue )\n\t\t\t);\n\t\t\tcallConfigure( creationContext, identifierGenerator, configuration, idValue );\n\t\t\tif ( identifierGenerator instanceof IdentityGenerator) {\n\t\t\t\tidValue.setColumnToIdentity();\n\t\t\t}\n\t\t\treturn identifierGenerator;\n\t\t} );\n\t}\n\n\n\tpublic static void createGeneratorFrom(\n\t\t\tIdentifierGeneratorDefinition defaultedGenerator,\n\t\t\tSimpleValue idValue,\n\t\t\tMetadataBuildingContext context) {\n\t\tcreateGeneratorFrom(\n\t\t\t\tdefaultedGenerator,\n\t\t\t\tidValue,\n\t\t\t\tbuildConfigurationMap( idValue ),\n\t\t\t\tcontext\n\t\t);\n\t}\n\n\tprivate static Map<String, Object> buildConfigurationMap(KeyValue idValue) {\n\t\tfinal Map<String,Object> configuration = new HashMap<>();\n\t\tconfiguration.put( PersistentIdentifierGenerator.TABLE, idValue.getTable().getName() );\n\t\tif ( idValue.getColumnSpan() == 1 ) {\n\t\t\tconfiguration.put( PersistentIdentifierGenerator.PK, idValue.getColumns().get(0).getName() );\n\t\t}\n\t\treturn configuration;\n\t}\n\n\t/**\n\t * Set up the identifier generator for an id defined in a {@code hbm.xml} mapping.\n\t *\n\t * @see org.hibernate.boot.model.source.internal.hbm.ModelBinder\n\t */\n\tpublic static void makeIdGenerator(\n\t\t\tfinal MappingDocument sourceDocument,\n\t\t\tIdentifierGeneratorDefinition definition,\n\t\t\tSimpleValue identifierValue,\n\t\t\tMetadataBuildingContext context) {\n\n\t\tif ( definition != null ) {\n\t\t\t// see if the specified generator name matches a registered <identifier-generator/>\n\t\t\tfinal IdentifierGeneratorDefinition generatorDef =\n\t\t\t\t\tsourceDocument.getMetadataCollector()\n\t\t\t\t\t\t\t.getIdentifierGenerator( definition.getName() );\n\t\t\tfinal Map<String,Object> configuration = new HashMap<>();\n\t\t\tfinal String generatorStrategy;\n\t\t\tif ( generatorDef != null ) {\n\t\t\t\tgeneratorStrategy = generatorDef.getStrategy();\n\t\t\t\tconfiguration.putAll( generatorDef.getParameters() );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgeneratorStrategy = definition.getStrategy();\n\t\t\t}\n\n\t\t\tconfiguration.putAll( definition.getParameters() );\n\n\t\t\tsetGeneratorCreator( identifierValue, configuration, generatorStrategy, context );\n\t\t}\n\t}\n\n\t/**\n\t * Obtain a {@link BeanContainer} to be used for instantiating generators.\n\t */\n\tpublic static BeanContainer beanContainer(MetadataBuildingContext buildingContext) {\n\t\treturn Helper.getBeanContainer( buildingContext.getBootstrapContext().getServiceRegistry() );\n\t}\n\n\t/**\n\t * Set up the {@link GeneratorCreator} for a case where there is no\n\t * generator annotation.\n\t */\n\tprivate static void setGeneratorCreator(\n\t\t\tSimpleValue identifierValue,\n\t\t\tMap<String, Object> configuration,\n\t\t\tString generatorStrategy,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( ASSIGNED_GENERATOR_NAME.equals( generatorStrategy )\n\t\t\t\t|| org.hibernate.id.Assigned.class.getName().equals( generatorStrategy ) ) {\n\t\t\tidentifierValue.setCustomIdGeneratorCreator( ASSIGNED_IDENTIFIER_GENERATOR_CREATOR );\n\t\t}\n\t\telse {\n\t\t\tfinal BeanContainer beanContainer = beanContainer( context );\n\t\t\tidentifierValue.setCustomIdGeneratorCreator( creationContext -> {\n\t\t\t\tfinal Generator identifierGenerator =\n\t\t\t\t\t\tinstantiateGenerator( beanContainer, generatorClass( generatorStrategy, identifierValue ) );\n\t\t\t\tcallConfigure( creationContext, identifierGenerator, configuration, identifierValue );\n\t\t\t\tif ( identifierGenerator instanceof IdentityGenerator) {\n\t\t\t\t\tidentifierValue.setColumnToIdentity();\n\t\t\t\t}\n\t\t\t\treturn identifierGenerator;\n\t\t\t} );\n\t\t}\n\t}\n\n\t/**\n\t * Set up the id generator by considering all annotations of the identifier\n\t * field, including {@linkplain IdGeneratorType id generator annotations},\n\t * and {@link GeneratedValue}.\n\t */\n\tstatic void createIdGeneratorsFromGeneratorAnnotations(\n\t\t\tPropertyHolder propertyHolder,\n\t\t\tPropertyData inferredData,\n\t\t\tSimpleValue idValue,\n\t\t\tMetadataBuildingContext context) {\n\n\t\tfinal SourceModelBuildingContext sourceModelContext =\n\t\t\t\tcontext.getMetadataCollector().getSourceModelBuildingContext();\n\t\tfinal MemberDetails idAttributeMember = inferredData.getAttributeMember();\n\t\tfinal List<? extends Annotation> idGeneratorAnnotations =\n\t\t\t\tidAttributeMember.getMetaAnnotated( IdGeneratorType.class, sourceModelContext );\n\t\tfinal List<? extends Annotation> generatorAnnotations =\n\t\t\t\tidAttributeMember.getMetaAnnotated( ValueGenerationType.class, sourceModelContext );\n\t\t// Since these collections may contain Proxies created by common-annotations module we cannot reliably use simple remove/removeAll\n\t\t// collection methods as those proxies do not implement hashcode/equals and even a simple `a.equals(a)` will return `false`.\n\t\t// Instead, we will check the annotation types, since generator annotations should not be \"repeatable\" we should have only\n\t\t// at most one annotation for a generator:\n\t\tfor ( Annotation id : idGeneratorAnnotations ) {\n\t\t\tgeneratorAnnotations.removeIf( gen -> gen.annotationType().equals( id.annotationType() ) );\n\t\t}\n\n\t\tif ( idGeneratorAnnotations.size() + generatorAnnotations.size() > 1 ) {\n\t\t\tthrow new AnnotationException( String.format(\n\t\t\t\t\tLocale.ROOT,\n\t\t\t\t\t\"Identifier attribute '%s' has too many generator annotations: %s\",\n\t\t\t\t\tgetPath( propertyHolder, inferredData ),\n\t\t\t\t\tcombineUntyped( idGeneratorAnnotations, generatorAnnotations )\n\t\t\t) );\n\t\t}\n\t\tif ( !idGeneratorAnnotations.isEmpty() ) {\n\t\t\tidValue.setCustomIdGeneratorCreator( identifierGeneratorCreator(\n\t\t\t\t\tidAttributeMember,\n\t\t\t\t\tidGeneratorAnnotations.get(0),\n\t\t\t\t\tidValue,\n\t\t\t\t\tbeanContainer( context )\n\t\t\t) );\n\t\t}\n\t\telse if ( !generatorAnnotations.isEmpty() ) {\n//\t\t\tidValue.setCustomGeneratorCreator( generatorCreator( idAttributeMember, generatorAnnotation ) );\n\t\t\tthrow new AnnotationException( String.format(\n\t\t\t\t\tLocale.ROOT,\n\t\t\t\t\t\"Identifier attribute '%s' is annotated '%s' which is not an '@IdGeneratorType'\",\n\t\t\t\t\tgetPath( propertyHolder, inferredData ),\n\t\t\t\t\tgeneratorAnnotations.get(0).annotationType()\n\t\t\t) );\n\t\t}\n\t\telse if ( idAttributeMember.hasDirectAnnotationUsage( GeneratedValue.class ) ) {\n\t\t\tcreateIdGenerator( idAttributeMember, idValue, propertyHolder.getPersistentClass(), context );\n\t\t}\n\t}\n\n\t/**\n\t * Returns the value generation strategy for the given property, if any, by\n\t * considering {@linkplain ValueGenerationType generator type annotations}.\n\t */\n\tstatic GeneratorCreator createValueGeneratorFromAnnotations(\n\t\t\tPropertyHolder holder, String propertyName,\n\t\t\tMemberDetails property, MetadataBuildingContext context) {\n\t\tfinal List<? extends Annotation> generatorAnnotations =\n\t\t\t\tproperty.getMetaAnnotated( ValueGenerationType.class,\n\t\t\t\t\t\tcontext.getMetadataCollector().getSourceModelBuildingContext() );\n\t\treturn switch ( generatorAnnotations.size() ) {\n\t\t\tcase 0 -> null;\n\t\t\tcase 1 -> generatorCreator( property, generatorAnnotations.get(0), beanContainer( context ) );\n\t\t\tdefault -> throw new AnnotationException( \"Property '\" + qualify( holder.getPath(), propertyName )\n\t\t\t\t\t+ \"' has too many generator annotations: \" + generatorAnnotations );\n\t\t};\n\t}\n\n\tpublic static void applyIfNotEmpty(String name, String value, BiConsumer<String,String> consumer) {\n\t\tif ( StringHelper.isNotEmpty( value ) ) {\n\t\t\tconsumer.accept( name, value );\n\t\t}\n\t}\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate getTransactionAdapterPreferringTransactionManager() : JtaTransactionAdapter extracted from private makePhysicalTransactionDelegate() : TransactionDriverControlImpl in class org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/resource/transaction/backend/jta/internal/JtaTransactionCoordinatorImpl.java",
                "startLine": 223,
                "endLine": 250,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/resource/transaction/backend/jta/internal/JtaTransactionCoordinatorImpl.java",
                "startLine": 214,
                "endLine": 227,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/resource/transaction/backend/jta/internal/JtaTransactionCoordinatorImpl.java",
                "startLine": 229,
                "endLine": 236,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private TransactionDriverControlImpl makePhysicalTransactionDelegate() {\n\t\tJtaTransactionAdapter adapter;\n\n\t\tif ( preferUserTransactions ) {\n\t\t\tadapter = makeUserTransactionAdapter();\n\n\t\t\tif ( adapter == null ) {\n\t\t\t\tlog.debug( \"Unable to access UserTransaction, attempting to use TransactionManager instead\" );\n\t\t\t\tadapter = makeTransactionManagerAdapter();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tadapter = makeTransactionManagerAdapter();\n\n\t\t\tif ( adapter == null ) {\n\t\t\t\tlog.debug( \"Unable to access TransactionManager, attempting to use UserTransaction instead\" );\n\t\t\t\tadapter = makeUserTransactionAdapter();\n\t\t\t}\n\t\t}\n\n\t\tif ( adapter == null ) {\n\t\t\tthrow new JtaPlatformInaccessibleException(\n\t\t\t\t\t\"Unable to access TransactionManager or UserTransaction to make physical transaction delegate\"\n\t\t\t);\n\t\t}\n\n\t\treturn new TransactionDriverControlImpl( adapter );\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/resource/transaction/backend/jta/internal/JtaTransactionCoordinatorImpl.java",
        "isPureRefactoring": true,
        "commitId": "453f0ff0749136eac008f9c16fb7742de7ccbadb",
        "packageNameBefore": "org.hibernate.resource.transaction.backend.jta.internal",
        "classNameBefore": "org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl",
        "methodNameBefore": "org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl#makePhysicalTransactionDelegate",
        "invokedMethod": "methodSignature: org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl#makeTransactionManagerAdapter\n methodBody: private JtaTransactionAdapter makeTransactionManagerAdapter() {\ntryfinal TransactionManager transactionManager=jtaPlatform.retrieveTransactionManager();\nif(transactionManager == null){log.debug(\"JtaPlatform#retrieveTransactionManager returned null\");\n}{return new JtaTransactionAdapterTransactionManagerImpl(transactionManager);\n}catch(Exception exception)log.debugf(\"JtaPlatform#retrieveTransactionManager threw an exception [%s]\",exception.getMessage());\nreturn null;\n}\nmethodSignature: org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl#makeUserTransactionAdapter\n methodBody: private JtaTransactionAdapter makeUserTransactionAdapter() {\ntryfinal UserTransaction userTransaction=jtaPlatform.retrieveUserTransaction();\nif(userTransaction == null){log.debug(\"JtaPlatform#retrieveUserTransaction returned null\");\n}{return new JtaTransactionAdapterUserTransactionImpl(userTransaction);\n}catch(Exception exception)log.debugf(\"JtaPlatform#retrieveUserTransaction threw an exception [%s]\",exception.getMessage());\nreturn null;\n}",
        "classSignatureBefore": "public class JtaTransactionCoordinatorImpl implements TransactionCoordinator, SynchronizationCallbackTarget ",
        "methodNameBeforeSet": [
            "org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl#makePhysicalTransactionDelegate"
        ],
        "classNameBeforeSet": [
            "org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl"
        ],
        "classSignatureBeforeSet": [
            "public class JtaTransactionCoordinatorImpl implements TransactionCoordinator, SynchronizationCallbackTarget "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": " Severe changes",
                "description": "Return expression has been added within the Extract Method mechanics - with non-mapped leaves",
                "mappingState": 2
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.resource.transaction.backend.jta.internal;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport jakarta.transaction.Status;\nimport jakarta.transaction.TransactionManager;\nimport jakarta.transaction.UserTransaction;\n\nimport org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform;\nimport org.hibernate.resource.transaction.spi.IsolationDelegate;\nimport org.hibernate.jpa.spi.JpaCompliance;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\nimport org.hibernate.resource.transaction.TransactionRequiredForJoinException;\nimport org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization;\nimport org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinator;\nimport org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorNonTrackingImpl;\nimport org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorTrackingImpl;\nimport org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackTarget;\nimport org.hibernate.resource.transaction.internal.SynchronizationRegistryStandardImpl;\nimport org.hibernate.resource.transaction.spi.SynchronizationRegistry;\nimport org.hibernate.resource.transaction.spi.TransactionCoordinator;\nimport org.hibernate.resource.transaction.spi.TransactionCoordinatorBuilder;\nimport org.hibernate.resource.transaction.spi.TransactionCoordinatorOwner;\nimport org.hibernate.resource.transaction.spi.TransactionObserver;\nimport org.hibernate.resource.transaction.spi.TransactionStatus;\n\nimport org.jboss.logging.Logger;\n\nimport static java.util.Collections.addAll;\nimport static java.util.Collections.emptyList;\nimport static org.hibernate.internal.CoreLogging.logger;\nimport static org.hibernate.resource.transaction.spi.TransactionStatus.ACTIVE;\nimport static org.hibernate.resource.transaction.spi.TransactionStatus.NOT_ACTIVE;\n\n/**\n * An implementation of TransactionCoordinator based on managing a transaction through the JTA API (either TM or UT)\n *\n * @author Steve Ebersole\n */\npublic class JtaTransactionCoordinatorImpl implements TransactionCoordinator, SynchronizationCallbackTarget {\n\tprivate static final Logger log = logger( JtaTransactionCoordinatorImpl.class );\n\n\tprivate final TransactionCoordinatorBuilder transactionCoordinatorBuilder;\n\tprivate final TransactionCoordinatorOwner transactionCoordinatorOwner;\n\tprivate final JtaPlatform jtaPlatform;\n\tprivate final boolean autoJoinTransactions;\n\tprivate final boolean preferUserTransactions;\n\tprivate final boolean performJtaThreadTracking;\n\n\tprivate boolean synchronizationRegistered;\n\tprivate SynchronizationCallbackCoordinator callbackCoordinator;\n\tprivate TransactionDriverControlImpl physicalTransactionDelegate;\n\n\tprivate final SynchronizationRegistryStandardImpl synchronizationRegistry = new SynchronizationRegistryStandardImpl();\n\n\tprivate int timeOut = -1;\n\n\tprivate transient List<TransactionObserver> observers = null;\n\n\t/**\n\t * Construct a JtaTransactionCoordinatorImpl instance.  package-protected to ensure access goes through\n\t * builder.\n\t *\n\t * @param owner The transactionCoordinatorOwner\n\t * @param autoJoinTransactions Should JTA transactions be auto-joined?  Or should we wait for explicit join calls?\n\t */\n\tJtaTransactionCoordinatorImpl(\n\t\t\tTransactionCoordinatorBuilder transactionCoordinatorBuilder,\n\t\t\tTransactionCoordinatorOwner owner,\n\t\t\tboolean autoJoinTransactions,\n\t\t\tJtaPlatform jtaPlatform) {\n\t\tthis.transactionCoordinatorBuilder = transactionCoordinatorBuilder;\n\t\tthis.transactionCoordinatorOwner = owner;\n\t\tthis.autoJoinTransactions = autoJoinTransactions;\n\n\t\tfinal JdbcSessionContext jdbcSessionContext = owner.getJdbcSessionOwner().getJdbcSessionContext();\n\n\t\tthis.jtaPlatform = jtaPlatform;\n\n\t\tthis.preferUserTransactions = jdbcSessionContext.isPreferUserTransaction();\n\t\tthis.performJtaThreadTracking = jdbcSessionContext.isJtaTrackByThread();\n\n\t\tsynchronizationRegistered = false;\n\n\t\tpulse();\n\t}\n\n\tpublic JtaTransactionCoordinatorImpl(\n\t\t\tTransactionCoordinatorBuilder transactionCoordinatorBuilder,\n\t\t\tTransactionCoordinatorOwner owner,\n\t\t\tboolean autoJoinTransactions,\n\t\t\tJtaPlatform jtaPlatform,\n\t\t\tboolean preferUserTransactions,\n\t\t\tboolean performJtaThreadTracking,\n\t\t\tTransactionObserver... observers) {\n\t\tthis.transactionCoordinatorBuilder = transactionCoordinatorBuilder;\n\t\tthis.transactionCoordinatorOwner = owner;\n\t\tthis.autoJoinTransactions = autoJoinTransactions;\n\t\tthis.jtaPlatform = jtaPlatform;\n\t\tthis.preferUserTransactions = preferUserTransactions;\n\t\tthis.performJtaThreadTracking = performJtaThreadTracking;\n\n\t\tif ( observers != null ) {\n\t\t\tthis.observers = new ArrayList<>( observers.length );\n\t\t\taddAll( this.observers, observers );\n\t\t}\n\n\t\tsynchronizationRegistered = false;\n\n\t\tpulse();\n\t}\n\n\t/**\n\t * Needed because while iterating the observers list and executing the before/update callbacks,\n\t * some observers might get removed from the list.\n\t * Yet try to not allocate anything for when the list is empty, as this is a common case.\n\t *\n\t * @return TransactionObserver\n\t */\n\tprivate Iterable<TransactionObserver> observers() {\n\t\treturn observers == null ? emptyList() : new ArrayList<>( observers );\n\t}\n\n\tpublic SynchronizationCallbackCoordinator getSynchronizationCallbackCoordinator() {\n\t\tif ( callbackCoordinator == null ) {\n\t\t\tcallbackCoordinator = performJtaThreadTracking\n\t\t\t\t\t? new SynchronizationCallbackCoordinatorTrackingImpl( this )\n\t\t\t\t\t: new SynchronizationCallbackCoordinatorNonTrackingImpl( this );\n\t\t}\n\t\treturn callbackCoordinator;\n\t}\n\n\t@Override\n\tpublic void pulse() {\n\t\tif ( !autoJoinTransactions ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( synchronizationRegistered ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Can we register a synchronization according to the JtaPlatform?\n\t\tif ( !jtaPlatform.canRegisterSynchronization() ) {\n\t\t\tlog.trace( \"JTA platform says we cannot currently register synchronization; skipping\" );\n\t\t\treturn;\n\t\t}\n\n\t\tjoinJtaTransaction();\n\t}\n\n\t/**\n\t * Join to the JTA transaction.  Note that the underlying meaning of joining in JTA environments is to register the\n\t * RegisteredSynchronization with the JTA system\n\t */\n\tprivate void joinJtaTransaction() {\n\t\tif ( synchronizationRegistered ) {\n\t\t\treturn;\n\t\t}\n\n\t\tjtaPlatform.registerSynchronization( new RegisteredSynchronization( getSynchronizationCallbackCoordinator() ) );\n\t\tgetSynchronizationCallbackCoordinator().synchronizationRegistered();\n\t\tsynchronizationRegistered = true;\n\t\tlog.debug( \"Hibernate RegisteredSynchronization successfully registered with JTA platform\" );\n\n\t\t// report entering into a \"transactional context\"\n\t\tgetTransactionCoordinatorOwner().startTransactionBoundary();\n\t}\n\n\t@Override\n\tpublic void explicitJoin() {\n\t\tif ( synchronizationRegistered ) {\n\t\t\tlog.debug( \"JTA transaction was already joined (RegisteredSynchronization already registered)\" );\n\t\t\treturn;\n\t\t}\n\n\t\tif ( getTransactionDriverControl().getStatus() != ACTIVE ) {\n\t\t\tthrow new TransactionRequiredForJoinException(\n\t\t\t\t\t\"Explicitly joining a JTA transaction requires a JTA transaction be currently active\"\n\t\t\t);\n\t\t}\n\n\t\tjoinJtaTransaction();\n\t}\n\n\t@Override\n\tpublic boolean isJoined() {\n\t\treturn synchronizationRegistered;\n\t}\n\n\t/**\n\t * Is the RegisteredSynchronization used by Hibernate for unified JTA Synchronization callbacks registered for this\n\t * coordinator?\n\t *\n\t * @return {@code true} indicates that a RegisteredSynchronization is currently registered for this coordinator;\n\t * {@code false} indicates it is not (yet) registered.\n\t */\n\tpublic boolean isSynchronizationRegistered() {\n\t\treturn synchronizationRegistered;\n\t}\n\n\tpublic TransactionCoordinatorOwner getTransactionCoordinatorOwner(){\n\t\treturn this.transactionCoordinatorOwner;\n\t}\n\n\t@Override\n\tpublic JpaCompliance getJpaCompliance() {\n\t\treturn transactionCoordinatorOwner.getJdbcSessionOwner().getJdbcSessionContext().getJpaCompliance();\n\t}\n\n\t@Override\n\tpublic TransactionDriver getTransactionDriverControl() {\n\t\tif ( physicalTransactionDelegate == null ) {\n\t\t\tphysicalTransactionDelegate = makePhysicalTransactionDelegate();\n\t\t}\n\t\treturn physicalTransactionDelegate;\n\t}\n\n\tprivate TransactionDriverControlImpl makePhysicalTransactionDelegate() {\n\t\tJtaTransactionAdapter adapter;\n\n\t\tif ( preferUserTransactions ) {\n\t\t\tadapter = makeUserTransactionAdapter();\n\n\t\t\tif ( adapter == null ) {\n\t\t\t\tlog.debug( \"Unable to access UserTransaction, attempting to use TransactionManager instead\" );\n\t\t\t\tadapter = makeTransactionManagerAdapter();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tadapter = makeTransactionManagerAdapter();\n\n\t\t\tif ( adapter == null ) {\n\t\t\t\tlog.debug( \"Unable to access TransactionManager, attempting to use UserTransaction instead\" );\n\t\t\t\tadapter = makeUserTransactionAdapter();\n\t\t\t}\n\t\t}\n\n\t\tif ( adapter == null ) {\n\t\t\tthrow new JtaPlatformInaccessibleException(\n\t\t\t\t\t\"Unable to access TransactionManager or UserTransaction to make physical transaction delegate\"\n\t\t\t);\n\t\t}\n\n\t\treturn new TransactionDriverControlImpl( adapter );\n\t}\n\n\tprivate JtaTransactionAdapter makeUserTransactionAdapter() {\n\t\ttry {\n\t\t\tfinal UserTransaction userTransaction = jtaPlatform.retrieveUserTransaction();\n\t\t\tif ( userTransaction == null ) {\n\t\t\t\tlog.debug( \"JtaPlatform#retrieveUserTransaction returned null\" );\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new JtaTransactionAdapterUserTransactionImpl( userTransaction );\n\t\t\t}\n\t\t}\n\t\tcatch ( Exception exception ) {\n\t\t\tlog.debugf( \"JtaPlatform#retrieveUserTransaction threw an exception [%s]\", exception.getMessage() );\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate JtaTransactionAdapter makeTransactionManagerAdapter() {\n\t\ttry {\n\t\t\tfinal TransactionManager transactionManager = jtaPlatform.retrieveTransactionManager();\n\t\t\tif ( transactionManager == null ) {\n\t\t\t\tlog.debug( \"JtaPlatform#retrieveTransactionManager returned null\" );\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new JtaTransactionAdapterTransactionManagerImpl( transactionManager );\n\t\t\t}\n\t\t}\n\t\tcatch ( Exception exception ) {\n\t\t\tlog.debugf( \"JtaPlatform#retrieveTransactionManager threw an exception [%s]\", exception.getMessage() );\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic SynchronizationRegistry getLocalSynchronizations() {\n\t\treturn synchronizationRegistry;\n\t}\n\n\t@Override\n\tpublic boolean isActive() {\n\t\treturn transactionCoordinatorOwner.isActive();\n\t}\n\n\tpublic boolean isJtaTransactionCurrentlyActive() {\n\t\treturn getTransactionDriverControl().getStatus() == ACTIVE;\n\t}\n\n\t@Override\n\tpublic IsolationDelegate createIsolationDelegate() {\n\t\treturn new JtaIsolationDelegate( transactionCoordinatorOwner, jtaPlatform.retrieveTransactionManager() );\n\t}\n\n\t@Override\n\tpublic TransactionCoordinatorBuilder getTransactionCoordinatorBuilder() {\n\t\treturn transactionCoordinatorBuilder;\n\t}\n\n\t@Override\n\tpublic void setTimeOut(int seconds) {\n\t\tthis.timeOut = seconds;\n\t\tphysicalTransactionDelegate.jtaTransactionAdapter.setTimeOut( seconds );\n\t}\n\n\t@Override\n\tpublic int getTimeOut() {\n\t\treturn timeOut;\n\t}\n\n\t@Override\n\tpublic void invalidate() {\n\t\tif ( physicalTransactionDelegate != null ) {\n\t\t\tphysicalTransactionDelegate.invalidate();\n\t\t}\n\t\tphysicalTransactionDelegate = null;\n\t}\n\n\t// SynchronizationCallbackTarget ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\t@Override\n\tpublic void beforeCompletion() {\n\t\ttry {\n\t\t\ttransactionCoordinatorOwner.beforeTransactionCompletion();\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\tphysicalTransactionDelegate.markRollbackOnly();\n\t\t\tthrow e;\n\t\t}\n\t\tfinally {\n\t\t\tsynchronizationRegistry.notifySynchronizationsBeforeTransactionCompletion();\n\t\t\tfor ( TransactionObserver observer : observers() ) {\n\t\t\t\tobserver.beforeCompletion();\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void afterCompletion(boolean successful, boolean delayed) {\n\t\tif ( !transactionCoordinatorOwner.isActive() ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal int statusToSend =  successful ? Status.STATUS_COMMITTED : Status.STATUS_UNKNOWN;\n\t\tsynchronizationRegistry.notifySynchronizationsAfterTransactionCompletion( statusToSend );\n\n//\t\tafterCompletionAction.doAction( this, statusToSend );\n\n\t\ttransactionCoordinatorOwner.afterTransactionCompletion( successful, delayed );\n\n\t\tfor ( TransactionObserver observer : observers() ) {\n\t\t\tobserver.afterCompletion( successful, delayed );\n\t\t}\n\n\t\tsynchronizationRegistered = false;\n\t}\n\n\tpublic void addObserver(TransactionObserver observer) {\n\t\tif ( observers == null ) {\n\t\t\tobservers = new ArrayList<>( 3 ); //These lists are typically very small.\n\t\t}\n\t\tobservers.add( observer );\n\t}\n\n\t@Override\n\tpublic void removeObserver(TransactionObserver observer) {\n\t\tif ( observers != null ) {\n\t\t\tobservers.remove( observer );\n\t\t}\n\t}\n\n\t/**\n\t * Implementation of the LocalInflow for this TransactionCoordinator.  Allows the\n\t * local transaction ({@link org.hibernate.Transaction} to callback into this\n\t * TransactionCoordinator for the purpose of driving the underlying JTA transaction.\n\t */\n\tpublic class TransactionDriverControlImpl implements TransactionDriver {\n\t\tprivate final JtaTransactionAdapter jtaTransactionAdapter;\n\t\tprivate boolean invalid;\n\n\t\tpublic TransactionDriverControlImpl(JtaTransactionAdapter jtaTransactionAdapter) {\n\t\t\tthis.jtaTransactionAdapter = jtaTransactionAdapter;\n\t\t}\n\n\t\tprotected void invalidate() {\n\t\t\tinvalid = true;\n\t\t}\n\n\t\t@Override\n\t\tpublic void begin() {\n\t\t\terrorIfInvalid();\n\n\t\t\tjtaTransactionAdapter.begin();\n\t\t\tJtaTransactionCoordinatorImpl.this.joinJtaTransaction();\n\t\t}\n\n\t\tprotected void errorIfInvalid() {\n\t\t\tif ( invalid ) {\n\t\t\t\tthrow new IllegalStateException( \"Physical-transaction delegate is no longer valid\" );\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void commit() {\n\t\t\terrorIfInvalid();\n\t\t\tgetTransactionCoordinatorOwner().flushBeforeTransactionCompletion();\n\n\t\t\t// we don't have to perform any before/after completion processing here.  We leave that for\n\t\t\t// the Synchronization callbacks\n\t\t\tjtaTransactionAdapter.commit();\n\t\t}\n\n\t\t@Override\n\t\tpublic void rollback() {\n\t\t\terrorIfInvalid();\n\n\t\t\t// we don't have to perform any after completion processing here.  We leave that for\n\t\t\t// the Synchronization callbacks\n\t\t\tjtaTransactionAdapter.rollback();\n\t\t}\n\n\t\t@Override\n\t\tpublic TransactionStatus getStatus() {\n\t\t\treturn jtaTransactionAdapter.getStatus();\n\t\t}\n\n\t\t@Override\n\t\tpublic void markRollbackOnly() {\n\t\t\tif ( jtaTransactionAdapter.getStatus() != NOT_ACTIVE  ) {\n\t\t\t\tjtaTransactionAdapter.markRollbackOnly();\n\t\t\t}\n\t\t}\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/resource/transaction/backend/jta/internal/JtaTransactionCoordinatorImpl.java",
        "sourceCodeAfterForWhole": "/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.resource.transaction.backend.jta.internal;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport jakarta.transaction.Status;\nimport jakarta.transaction.TransactionManager;\nimport jakarta.transaction.UserTransaction;\n\nimport org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform;\nimport org.hibernate.resource.transaction.spi.IsolationDelegate;\nimport org.hibernate.jpa.spi.JpaCompliance;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\nimport org.hibernate.resource.transaction.TransactionRequiredForJoinException;\nimport org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization;\nimport org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinator;\nimport org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorNonTrackingImpl;\nimport org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorTrackingImpl;\nimport org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackTarget;\nimport org.hibernate.resource.transaction.internal.SynchronizationRegistryStandardImpl;\nimport org.hibernate.resource.transaction.spi.SynchronizationRegistry;\nimport org.hibernate.resource.transaction.spi.TransactionCoordinator;\nimport org.hibernate.resource.transaction.spi.TransactionCoordinatorBuilder;\nimport org.hibernate.resource.transaction.spi.TransactionCoordinatorOwner;\nimport org.hibernate.resource.transaction.spi.TransactionObserver;\nimport org.hibernate.resource.transaction.spi.TransactionStatus;\n\nimport org.jboss.logging.Logger;\n\nimport static java.util.Collections.addAll;\nimport static java.util.Collections.emptyList;\nimport static org.hibernate.internal.CoreLogging.logger;\nimport static org.hibernate.resource.transaction.spi.TransactionStatus.ACTIVE;\nimport static org.hibernate.resource.transaction.spi.TransactionStatus.NOT_ACTIVE;\n\n/**\n * An implementation of TransactionCoordinator based on managing a transaction through the JTA API (either TM or UT)\n *\n * @author Steve Ebersole\n */\npublic class JtaTransactionCoordinatorImpl implements TransactionCoordinator, SynchronizationCallbackTarget {\n\tprivate static final Logger log = logger( JtaTransactionCoordinatorImpl.class );\n\n\tprivate final TransactionCoordinatorBuilder transactionCoordinatorBuilder;\n\tprivate final TransactionCoordinatorOwner transactionCoordinatorOwner;\n\tprivate final JtaPlatform jtaPlatform;\n\tprivate final boolean autoJoinTransactions;\n\tprivate final boolean preferUserTransactions;\n\tprivate final boolean performJtaThreadTracking;\n\n\tprivate boolean synchronizationRegistered;\n\tprivate SynchronizationCallbackCoordinator callbackCoordinator;\n\tprivate TransactionDriverControlImpl physicalTransactionDelegate;\n\n\tprivate final SynchronizationRegistryStandardImpl synchronizationRegistry = new SynchronizationRegistryStandardImpl();\n\n\tprivate int timeOut = -1;\n\n\tprivate transient List<TransactionObserver> observers = null;\n\n\t/**\n\t * Construct a JtaTransactionCoordinatorImpl instance.  package-protected to ensure access goes through\n\t * builder.\n\t *\n\t * @param owner The transactionCoordinatorOwner\n\t * @param autoJoinTransactions Should JTA transactions be auto-joined?  Or should we wait for explicit join calls?\n\t */\n\tJtaTransactionCoordinatorImpl(\n\t\t\tTransactionCoordinatorBuilder transactionCoordinatorBuilder,\n\t\t\tTransactionCoordinatorOwner owner,\n\t\t\tboolean autoJoinTransactions,\n\t\t\tJtaPlatform jtaPlatform) {\n\t\tthis.transactionCoordinatorBuilder = transactionCoordinatorBuilder;\n\t\tthis.transactionCoordinatorOwner = owner;\n\t\tthis.autoJoinTransactions = autoJoinTransactions;\n\n\t\tfinal JdbcSessionContext jdbcSessionContext = owner.getJdbcSessionOwner().getJdbcSessionContext();\n\n\t\tthis.jtaPlatform = jtaPlatform;\n\n\t\tthis.preferUserTransactions = jdbcSessionContext.isPreferUserTransaction();\n\t\tthis.performJtaThreadTracking = jdbcSessionContext.isJtaTrackByThread();\n\n\t\tsynchronizationRegistered = false;\n\n\t\tpulse();\n\t}\n\n\tpublic JtaTransactionCoordinatorImpl(\n\t\t\tTransactionCoordinatorBuilder transactionCoordinatorBuilder,\n\t\t\tTransactionCoordinatorOwner owner,\n\t\t\tboolean autoJoinTransactions,\n\t\t\tJtaPlatform jtaPlatform,\n\t\t\tboolean preferUserTransactions,\n\t\t\tboolean performJtaThreadTracking,\n\t\t\tTransactionObserver... observers) {\n\t\tthis.transactionCoordinatorBuilder = transactionCoordinatorBuilder;\n\t\tthis.transactionCoordinatorOwner = owner;\n\t\tthis.autoJoinTransactions = autoJoinTransactions;\n\t\tthis.jtaPlatform = jtaPlatform;\n\t\tthis.preferUserTransactions = preferUserTransactions;\n\t\tthis.performJtaThreadTracking = performJtaThreadTracking;\n\n\t\tif ( observers != null ) {\n\t\t\tthis.observers = new ArrayList<>( observers.length );\n\t\t\taddAll( this.observers, observers );\n\t\t}\n\n\t\tsynchronizationRegistered = false;\n\n\t\tpulse();\n\t}\n\n\t/**\n\t * Needed because while iterating the observers list and executing the before/update callbacks,\n\t * some observers might get removed from the list.\n\t * Yet try to not allocate anything for when the list is empty, as this is a common case.\n\t *\n\t * @return TransactionObserver\n\t */\n\tprivate Iterable<TransactionObserver> observers() {\n\t\treturn observers == null ? emptyList() : new ArrayList<>( observers );\n\t}\n\n\tpublic SynchronizationCallbackCoordinator getSynchronizationCallbackCoordinator() {\n\t\tif ( callbackCoordinator == null ) {\n\t\t\tcallbackCoordinator = performJtaThreadTracking\n\t\t\t\t\t? new SynchronizationCallbackCoordinatorTrackingImpl( this )\n\t\t\t\t\t: new SynchronizationCallbackCoordinatorNonTrackingImpl( this );\n\t\t}\n\t\treturn callbackCoordinator;\n\t}\n\n\t@Override\n\tpublic void pulse() {\n\t\tif ( autoJoinTransactions && !synchronizationRegistered ) {\n\t\t\t// Can we register a synchronization according to the JtaPlatform?\n\t\t\tif ( !jtaPlatform.canRegisterSynchronization() ) {\n\t\t\t\tlog.trace( \"JTA platform says we cannot currently register synchronization; skipping\" );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tjoinJtaTransaction();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Join to the JTA transaction.  Note that the underlying meaning of joining in JTA environments is to register the\n\t * RegisteredSynchronization with the JTA system\n\t */\n\tprivate void joinJtaTransaction() {\n\t\tif ( !synchronizationRegistered ) {\n\t\t\tjtaPlatform.registerSynchronization(\n\t\t\t\t\tnew RegisteredSynchronization( getSynchronizationCallbackCoordinator() ) );\n\t\t\tgetSynchronizationCallbackCoordinator().synchronizationRegistered();\n\t\t\tsynchronizationRegistered = true;\n\t\t\tlog.debug( \"Hibernate RegisteredSynchronization successfully registered with JTA platform\" );\n\t\t\t// report entering into a \"transactional context\"\n\t\t\tgetTransactionCoordinatorOwner().startTransactionBoundary();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void explicitJoin() {\n\t\tif ( synchronizationRegistered ) {\n\t\t\tlog.debug( \"JTA transaction was already joined (RegisteredSynchronization already registered)\" );\n\t\t}\n\t\telse {\n\t\t\tif ( getTransactionDriverControl().getStatus() != ACTIVE ) {\n\t\t\t\tthrow new TransactionRequiredForJoinException(\n\t\t\t\t\t\t\"Explicitly joining a JTA transaction requires a JTA transaction be currently active\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tjoinJtaTransaction();\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isJoined() {\n\t\treturn synchronizationRegistered;\n\t}\n\n\t/**\n\t * Is the RegisteredSynchronization used by Hibernate for unified JTA Synchronization callbacks registered for this\n\t * coordinator?\n\t *\n\t * @return {@code true} indicates that a RegisteredSynchronization is currently registered for this coordinator;\n\t * {@code false} indicates it is not (yet) registered.\n\t */\n\tpublic boolean isSynchronizationRegistered() {\n\t\treturn synchronizationRegistered;\n\t}\n\n\tpublic TransactionCoordinatorOwner getTransactionCoordinatorOwner(){\n\t\treturn transactionCoordinatorOwner;\n\t}\n\n\t@Override\n\tpublic JpaCompliance getJpaCompliance() {\n\t\treturn transactionCoordinatorOwner.getJdbcSessionOwner().getJdbcSessionContext().getJpaCompliance();\n\t}\n\n\t@Override\n\tpublic TransactionDriver getTransactionDriverControl() {\n\t\tif ( physicalTransactionDelegate == null ) {\n\t\t\tphysicalTransactionDelegate = makePhysicalTransactionDelegate();\n\t\t}\n\t\treturn physicalTransactionDelegate;\n\t}\n\n\tprivate TransactionDriverControlImpl makePhysicalTransactionDelegate() {\n\t\tfinal JtaTransactionAdapter adapter =\n\t\t\t\tpreferUserTransactions\n\t\t\t\t\t\t? getTransactionAdapterPreferringUserTransaction()\n\t\t\t\t\t\t: getTransactionAdapterPreferringTransactionManager();\n\t\tif ( adapter == null ) {\n\t\t\tthrow new JtaPlatformInaccessibleException(\n\t\t\t\t\t\"Unable to access TransactionManager or UserTransaction to make physical transaction delegate\"\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn new TransactionDriverControlImpl( adapter );\n\t\t}\n\t}\n\n\tprivate JtaTransactionAdapter getTransactionAdapterPreferringTransactionManager() {\n\t\tfinal JtaTransactionAdapter adapter = makeTransactionManagerAdapter();\n\t\tif ( adapter == null ) {\n\t\t\tlog.debug( \"Unable to access TransactionManager, attempting to use UserTransaction instead\" );\n\t\t\treturn makeUserTransactionAdapter();\n\t\t}\n\t\treturn adapter;\n\t}\n\n\tprivate JtaTransactionAdapter getTransactionAdapterPreferringUserTransaction() {\n\t\tfinal JtaTransactionAdapter adapter = makeUserTransactionAdapter();\n\t\tif ( adapter == null ) {\n\t\t\tlog.debug( \"Unable to access UserTransaction, attempting to use TransactionManager instead\" );\n\t\t\treturn makeTransactionManagerAdapter();\n\t\t}\n\t\treturn adapter;\n\t}\n\n\tprivate JtaTransactionAdapter makeUserTransactionAdapter() {\n\t\ttry {\n\t\t\tfinal UserTransaction userTransaction = jtaPlatform.retrieveUserTransaction();\n\t\t\tif ( userTransaction == null ) {\n\t\t\t\tlog.debug( \"JtaPlatform#retrieveUserTransaction returned null\" );\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new JtaTransactionAdapterUserTransactionImpl( userTransaction );\n\t\t\t}\n\t\t}\n\t\tcatch ( Exception exception ) {\n\t\t\tlog.debugf( \"JtaPlatform#retrieveUserTransaction threw an exception [%s]\", exception.getMessage() );\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate JtaTransactionAdapter makeTransactionManagerAdapter() {\n\t\ttry {\n\t\t\tfinal TransactionManager transactionManager = jtaPlatform.retrieveTransactionManager();\n\t\t\tif ( transactionManager == null ) {\n\t\t\t\tlog.debug( \"JtaPlatform#retrieveTransactionManager returned null\" );\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new JtaTransactionAdapterTransactionManagerImpl( transactionManager );\n\t\t\t}\n\t\t}\n\t\tcatch ( Exception exception ) {\n\t\t\tlog.debugf( \"JtaPlatform#retrieveTransactionManager threw an exception [%s]\", exception.getMessage() );\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@Override\n\tpublic SynchronizationRegistry getLocalSynchronizations() {\n\t\treturn synchronizationRegistry;\n\t}\n\n\t@Override\n\tpublic boolean isActive() {\n\t\treturn transactionCoordinatorOwner.isActive();\n\t}\n\n\tpublic boolean isJtaTransactionCurrentlyActive() {\n\t\treturn getTransactionDriverControl().getStatus() == ACTIVE;\n\t}\n\n\t@Override\n\tpublic IsolationDelegate createIsolationDelegate() {\n\t\treturn new JtaIsolationDelegate( transactionCoordinatorOwner, jtaPlatform.retrieveTransactionManager() );\n\t}\n\n\t@Override\n\tpublic TransactionCoordinatorBuilder getTransactionCoordinatorBuilder() {\n\t\treturn transactionCoordinatorBuilder;\n\t}\n\n\t@Override\n\tpublic void setTimeOut(int seconds) {\n\t\tthis.timeOut = seconds;\n\t\tphysicalTransactionDelegate.jtaTransactionAdapter.setTimeOut( seconds );\n\t}\n\n\t@Override\n\tpublic int getTimeOut() {\n\t\treturn timeOut;\n\t}\n\n\t@Override\n\tpublic void invalidate() {\n\t\tif ( physicalTransactionDelegate != null ) {\n\t\t\tphysicalTransactionDelegate.invalidate();\n\t\t}\n\t\tphysicalTransactionDelegate = null;\n\t}\n\n\t// SynchronizationCallbackTarget ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\t@Override\n\tpublic void beforeCompletion() {\n\t\ttry {\n\t\t\ttransactionCoordinatorOwner.beforeTransactionCompletion();\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\tphysicalTransactionDelegate.markRollbackOnly();\n\t\t\tthrow e;\n\t\t}\n\t\tfinally {\n\t\t\tsynchronizationRegistry.notifySynchronizationsBeforeTransactionCompletion();\n\t\t\tfor ( TransactionObserver observer : observers() ) {\n\t\t\t\tobserver.beforeCompletion();\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void afterCompletion(boolean successful, boolean delayed) {\n\t\tif ( !transactionCoordinatorOwner.isActive() ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal int statusToSend =  successful ? Status.STATUS_COMMITTED : Status.STATUS_UNKNOWN;\n\t\tsynchronizationRegistry.notifySynchronizationsAfterTransactionCompletion( statusToSend );\n\n//\t\tafterCompletionAction.doAction( this, statusToSend );\n\n\t\ttransactionCoordinatorOwner.afterTransactionCompletion( successful, delayed );\n\n\t\tfor ( TransactionObserver observer : observers() ) {\n\t\t\tobserver.afterCompletion( successful, delayed );\n\t\t}\n\n\t\tsynchronizationRegistered = false;\n\t}\n\n\tpublic void addObserver(TransactionObserver observer) {\n\t\tif ( observers == null ) {\n\t\t\tobservers = new ArrayList<>( 3 ); //These lists are typically very small.\n\t\t}\n\t\tobservers.add( observer );\n\t}\n\n\t@Override\n\tpublic void removeObserver(TransactionObserver observer) {\n\t\tif ( observers != null ) {\n\t\t\tobservers.remove( observer );\n\t\t}\n\t}\n\n\t/**\n\t * Implementation of the LocalInflow for this TransactionCoordinator.  Allows the\n\t * local transaction ({@link org.hibernate.Transaction} to callback into this\n\t * TransactionCoordinator for the purpose of driving the underlying JTA transaction.\n\t */\n\tpublic class TransactionDriverControlImpl implements TransactionDriver {\n\t\tprivate final JtaTransactionAdapter jtaTransactionAdapter;\n\t\tprivate boolean invalid;\n\n\t\tpublic TransactionDriverControlImpl(JtaTransactionAdapter jtaTransactionAdapter) {\n\t\t\tthis.jtaTransactionAdapter = jtaTransactionAdapter;\n\t\t}\n\n\t\tprotected void invalidate() {\n\t\t\tinvalid = true;\n\t\t}\n\n\t\t@Override\n\t\tpublic void begin() {\n\t\t\terrorIfInvalid();\n\t\t\tjtaTransactionAdapter.begin();\n\t\t\tJtaTransactionCoordinatorImpl.this.joinJtaTransaction();\n\t\t}\n\n\t\tprotected void errorIfInvalid() {\n\t\t\tif ( invalid ) {\n\t\t\t\tthrow new IllegalStateException( \"Physical-transaction delegate is no longer valid\" );\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void commit() {\n\t\t\terrorIfInvalid();\n\t\t\tgetTransactionCoordinatorOwner().flushBeforeTransactionCompletion();\n\t\t\t// we don't have to perform any before/after completion processing here.  We leave that for\n\t\t\t// the Synchronization callbacks\n\t\t\tjtaTransactionAdapter.commit();\n\t\t}\n\n\t\t@Override\n\t\tpublic void rollback() {\n\t\t\terrorIfInvalid();\n\t\t\t// we don't have to perform any after completion processing here.  We leave that for\n\t\t\t// the Synchronization callbacks\n\t\t\tjtaTransactionAdapter.rollback();\n\t\t}\n\n\t\t@Override\n\t\tpublic TransactionStatus getStatus() {\n\t\t\treturn jtaTransactionAdapter.getStatus();\n\t\t}\n\n\t\t@Override\n\t\tpublic void markRollbackOnly() {\n\t\t\tif ( jtaTransactionAdapter.getStatus() != NOT_ACTIVE  ) {\n\t\t\t\tjtaTransactionAdapter.markRollbackOnly();\n\t\t\t}\n\t\t}\n\t}\n\n}\n",
        "diffSourceCodeSet": [
            "private JtaTransactionAdapter getTransactionAdapterPreferringTransactionManager() {\n\t\tfinal JtaTransactionAdapter adapter = makeTransactionManagerAdapter();\n\t\tif ( adapter == null ) {\n\t\t\tlog.debug( \"Unable to access TransactionManager, attempting to use UserTransaction instead\" );\n\t\t\treturn makeUserTransactionAdapter();\n\t\t}\n\t\treturn adapter;\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl#makeTransactionManagerAdapter\n methodBody: private JtaTransactionAdapter makeTransactionManagerAdapter() {\ntryfinal TransactionManager transactionManager=jtaPlatform.retrieveTransactionManager();\nif(transactionManager == null){log.debug(\"JtaPlatform#retrieveTransactionManager returned null\");\n}{return new JtaTransactionAdapterTransactionManagerImpl(transactionManager);\n}catch(Exception exception)log.debugf(\"JtaPlatform#retrieveTransactionManager threw an exception [%s]\",exception.getMessage());\nreturn null;\n}",
            "methodSignature: org.hibernate.resource.transaction.backend.jta.internal.JtaTransactionCoordinatorImpl#makeUserTransactionAdapter\n methodBody: private JtaTransactionAdapter makeUserTransactionAdapter() {\ntryfinal UserTransaction userTransaction=jtaPlatform.retrieveUserTransaction();\nif(userTransaction == null){log.debug(\"JtaPlatform#retrieveUserTransaction returned null\");\n}{return new JtaTransactionAdapterUserTransactionImpl(userTransaction);\n}catch(Exception exception)log.debugf(\"JtaPlatform#retrieveUserTransaction threw an exception [%s]\",exception.getMessage());\nreturn null;\n}"
        ],
        "sourceCodeAfterRefactoring": "private TransactionDriverControlImpl makePhysicalTransactionDelegate() {\n\t\tfinal JtaTransactionAdapter adapter =\n\t\t\t\tpreferUserTransactions\n\t\t\t\t\t\t? getTransactionAdapterPreferringUserTransaction()\n\t\t\t\t\t\t: getTransactionAdapterPreferringTransactionManager();\n\t\tif ( adapter == null ) {\n\t\t\tthrow new JtaPlatformInaccessibleException(\n\t\t\t\t\t\"Unable to access TransactionManager or UserTransaction to make physical transaction delegate\"\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn new TransactionDriverControlImpl( adapter );\n\t\t}\n\t}\nprivate JtaTransactionAdapter getTransactionAdapterPreferringTransactionManager() {\n\t\tfinal JtaTransactionAdapter adapter = makeTransactionManagerAdapter();\n\t\tif ( adapter == null ) {\n\t\t\tlog.debug( \"Unable to access TransactionManager, attempting to use UserTransaction instead\" );\n\t\t\treturn makeUserTransactionAdapter();\n\t\t}\n\t\treturn adapter;\n\t}",
        "diffSourceCode": "-  214: \n-  215: \t@Override\n-  216: \tpublic TransactionDriver getTransactionDriverControl() {\n-  217: \t\tif ( physicalTransactionDelegate == null ) {\n-  218: \t\t\tphysicalTransactionDelegate = makePhysicalTransactionDelegate();\n-  219: \t\t}\n-  220: \t\treturn physicalTransactionDelegate;\n-  221: \t}\n-  222: \n-  223: \tprivate TransactionDriverControlImpl makePhysicalTransactionDelegate() {\n-  224: \t\tJtaTransactionAdapter adapter;\n-  225: \n-  226: \t\tif ( preferUserTransactions ) {\n-  227: \t\t\tadapter = makeUserTransactionAdapter();\n+  214: \tprivate TransactionDriverControlImpl makePhysicalTransactionDelegate() {\n+  215: \t\tfinal JtaTransactionAdapter adapter =\n+  216: \t\t\t\tpreferUserTransactions\n+  217: \t\t\t\t\t\t? getTransactionAdapterPreferringUserTransaction()\n+  218: \t\t\t\t\t\t: getTransactionAdapterPreferringTransactionManager();\n+  219: \t\tif ( adapter == null ) {\n+  220: \t\t\tthrow new JtaPlatformInaccessibleException(\n+  221: \t\t\t\t\t\"Unable to access TransactionManager or UserTransaction to make physical transaction delegate\"\n+  222: \t\t\t);\n+  223: \t\t}\n+  224: \t\telse {\n+  225: \t\t\treturn new TransactionDriverControlImpl( adapter );\n+  226: \t\t}\n+  227: \t}\n   228: \n-  229: \t\t\tif ( adapter == null ) {\n-  230: \t\t\t\tlog.debug( \"Unable to access UserTransaction, attempting to use TransactionManager instead\" );\n-  231: \t\t\t\tadapter = makeTransactionManagerAdapter();\n-  232: \t\t\t}\n-  233: \t\t}\n-  234: \t\telse {\n-  235: \t\t\tadapter = makeTransactionManagerAdapter();\n-  236: \n-  237: \t\t\tif ( adapter == null ) {\n-  238: \t\t\t\tlog.debug( \"Unable to access TransactionManager, attempting to use UserTransaction instead\" );\n-  239: \t\t\t\tadapter = makeUserTransactionAdapter();\n-  240: \t\t\t}\n-  241: \t\t}\n-  242: \n-  243: \t\tif ( adapter == null ) {\n-  244: \t\t\tthrow new JtaPlatformInaccessibleException(\n-  245: \t\t\t\t\t\"Unable to access TransactionManager or UserTransaction to make physical transaction delegate\"\n-  246: \t\t\t);\n-  247: \t\t}\n-  248: \n-  249: \t\treturn new TransactionDriverControlImpl( adapter );\n-  250: \t}\n+  229: \tprivate JtaTransactionAdapter getTransactionAdapterPreferringTransactionManager() {\n+  230: \t\tfinal JtaTransactionAdapter adapter = makeTransactionManagerAdapter();\n+  231: \t\tif ( adapter == null ) {\n+  232: \t\t\tlog.debug( \"Unable to access TransactionManager, attempting to use UserTransaction instead\" );\n+  233: \t\t\treturn makeUserTransactionAdapter();\n+  234: \t\t}\n+  235: \t\treturn adapter;\n+  236: \t}\n+  237: \n+  238: \tprivate JtaTransactionAdapter getTransactionAdapterPreferringUserTransaction() {\n+  239: \t\tfinal JtaTransactionAdapter adapter = makeUserTransactionAdapter();\n+  240: \t\tif ( adapter == null ) {\n+  241: \t\t\tlog.debug( \"Unable to access UserTransaction, attempting to use TransactionManager instead\" );\n+  242: \t\t\treturn makeTransactionManagerAdapter();\n+  243: \t\t}\n+  244: \t\treturn adapter;\n+  245: \t}\n+  246: \n+  247: \tprivate JtaTransactionAdapter makeUserTransactionAdapter() {\n+  248: \t\ttry {\n+  249: \t\t\tfinal UserTransaction userTransaction = jtaPlatform.retrieveUserTransaction();\n+  250: \t\t\tif ( userTransaction == null ) {\n",
        "uniqueId": "453f0ff0749136eac008f9c16fb7742de7ccbadb_223_250_229_236_214_227",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 7,
                "covered": 32
            },
            "BRANCH": {
                "missed": 1,
                "covered": 7
            },
            "LINE": {
                "missed": 2,
                "covered": 10
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 4
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "refactoringMinerResult": true,
        "compileAndTestResult": true,
        "refactoredCode": "##########################\nprivate TransactionDriverControlImpl makePhysicalTransactionDelegate() {\n\t\tJtaTransactionAdapter adapter = getTransactionAdapter();\n\n\t\tif (adapter == null) {\n\t\t\tthrow new JtaPlatformInaccessibleException(\n\t\t\t\t\t\"Unable to access TransactionManager or UserTransaction to make physical transaction delegate\"\n\t\t\t);\n\t\t}\n\n\t\treturn new TransactionDriverControlImpl(adapter);\n\t}\n\nprivate JtaTransactionAdapter getTransactionAdapter() {\n\t\tJtaTransactionAdapter adapter;\n\n\t\tif (preferUserTransactions) {\n\t\t\tadapter = makeUserTransactionAdapter();\n\n\t\t\tif (adapter == null) {\n\t\t\t\tlog.debug(\"Unable to access UserTransaction, attempting to use TransactionManager instead\");\n\t\t\t\tadapter = makeTransactionManagerAdapter();\n\t\t\t}\n\t\t} else {\n\t\t\tadapter = makeTransactionManagerAdapter();\n\n\t\t\tif (adapter == null) {\n\t\t\t\tlog.debug(\"Unable to access TransactionManager, attempting to use UserTransaction instead\");\n\t\t\t\tadapter = makeUserTransactionAdapter();\n\t\t\t}\n\t\t}\n\n\t\treturn adapter;\n\t}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprivate TransactionDriverControlImpl makePhysicalTransactionDelegate() {\n\t\tJtaTransactionAdapter adapter;\n\n\t\tif ( preferUserTransactions ) {\n\t\t\tadapter = makeUserTransactionAdapter();\n\n\t\t\tif ( adapter == null ) {\n\t\t\t\tlog.debug( \"Unable to access UserTransaction, attempting to use TransactionManager instead\" );\n\t\t\t\tadapter = makeTransactionManagerAdapter();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tadapter = makeTransactionManagerAdapter();\n\n\t\t\tif ( adapter == null ) {\n\t\t\t\tlog.debug( \"Unable to access TransactionManager, attempting to use UserTransaction instead\" );\n\t\t\t\tadapter = makeUserTransactionAdapter();\n\t\t\t}\n\t\t}\n\n\t\tif ( adapter == null ) {\n\t\t\tthrow new JtaPlatformInaccessibleException(\n\t\t\t\t\t\"Unable to access TransactionManager or UserTransaction to make physical transaction delegate\"\n\t\t\t);\n\t\t}\n\n\t\treturn new TransactionDriverControlImpl( adapter );\n\t}\n\nClass content:\n/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.resource.transaction.backend.jta.internal;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport jakarta.transaction.Status;\nimport jakarta.transaction.TransactionManager;\nimport jakarta.transaction.UserTransaction;\n\nimport org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform;\nimport org.hibernate.resource.transaction.spi.IsolationDelegate;\nimport org.hibernate.jpa.spi.JpaCompliance;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\nimport org.hibernate.resource.transaction.TransactionRequiredForJoinException;\nimport org.hibernate.resource.transaction.backend.jta.internal.synchronization.RegisteredSynchronization;\nimport org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinator;\nimport org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorNonTrackingImpl;\nimport org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackCoordinatorTrackingImpl;\nimport org.hibernate.resource.transaction.backend.jta.internal.synchronization.SynchronizationCallbackTarget;\nimport org.hibernate.resource.transaction.internal.SynchronizationRegistryStandardImpl;\nimport org.hibernate.resource.transaction.spi.SynchronizationRegistry;\nimport org.hibernate.resource.transaction.spi.TransactionCoordinator;\nimport org.hibernate.resource.transaction.spi.TransactionCoordinatorBuilder;\nimport org.hibernate.resource.transaction.spi.TransactionCoordinatorOwner;\nimport org.hibernate.resource.transaction.spi.TransactionObserver;\nimport org.hibernate.resource.transaction.spi.TransactionStatus;\n\nimport org.jboss.logging.Logger;\n\nimport static java.util.Collections.addAll;\nimport static java.util.Collections.emptyList;\nimport static org.hibernate.internal.CoreLogging.logger;\nimport static org.hibernate.resource.transaction.spi.TransactionStatus.ACTIVE;\nimport static org.hibernate.resource.transaction.spi.TransactionStatus.NOT_ACTIVE;\n\n/**\n * An implementation of TransactionCoordinator based on managing a transaction through the JTA API (either TM or UT)\n *\n * @author Steve Ebersole\n */\npublic class JtaTransactionCoordinatorImpl implements TransactionCoordinator, SynchronizationCallbackTarget {\n\tprivate static final Logger log = logger( JtaTransactionCoordinatorImpl.class );\n\n\tprivate final TransactionCoordinatorBuilder transactionCoordinatorBuilder;\n\tprivate final TransactionCoordinatorOwner transactionCoordinatorOwner;\n\tprivate final JtaPlatform jtaPlatform;\n\tprivate final boolean autoJoinTransactions;\n\tprivate final boolean preferUserTransactions;\n\tprivate final boolean performJtaThreadTracking;\n\n\tprivate boolean synchronizationRegistered;\n\tprivate SynchronizationCallbackCoordinator callbackCoordinator;\n\tprivate TransactionDriverControlImpl physicalTransactionDelegate;\n\n\tprivate final SynchronizationRegistryStandardImpl synchronizationRegistry = new SynchronizationRegistryStandardImpl();\n\n\tprivate int timeOut = -1;\n\n\tprivate transient List<TransactionObserver> observers = null;\n\n\t/**\n\t * Construct a JtaTransactionCoordinatorImpl instance.  package-protected to ensure access goes through\n\t * builder.\n\t *\n\t * @param owner The transactionCoordinatorOwner\n\t * @param autoJoinTransactions Should JTA transactions be auto-joined?  Or should we wait for explicit join calls?\n\t */\n\tJtaTransactionCoordinatorImpl(\n\t\t\tTransactionCoordinatorBuilder transactionCoordinatorBuilder,\n\t\t\tTransactionCoordinatorOwner owner,\n\t\t\tboolean autoJoinTransactions,\n\t\t\tJtaPlatform jtaPlatform) {\n\t\tthis.transactionCoordinatorBuilder = transactionCoordinatorBuilder;\n\t\tthis.transactionCoordinatorOwner = owner;\n\t\tthis.autoJoinTransactions = autoJoinTransactions;\n\n\t\tfinal JdbcSessionContext jdbcSessionContext = owner.getJdbcSessionOwner().getJdbcSessionContext();\n\n\t\tthis.jtaPlatform = jtaPlatform;\n\n\t\tthis.preferUserTransactions = jdbcSessionContext.isPreferUserTransaction();\n\t\tthis.performJtaThreadTracking = jdbcSessionContext.isJtaTrackByThread();\n\n\t\tsynchronizationRegistered = false;\n\n\t\tpulse();\n\t}\n\n\tpublic JtaTransactionCoordinatorImpl(\n\t\t\tTransactionCoordinatorBuilder transactionCoordinatorBuilder,\n\t\t\tTransactionCoordinatorOwner owner,\n\t\t\tboolean autoJoinTransactions,\n\t\t\tJtaPlatform jtaPlatform,\n\t\t\tboolean preferUserTransactions,\n\t\t\tboolean performJtaThreadTracking,\n\t\t\tTransactionObserver... observers) {\n\t\tthis.transactionCoordinatorBuilder = transactionCoordinatorBuilder;\n\t\tthis.transactionCoordinatorOwner = owner;\n\t\tthis.autoJoinTransactions = autoJoinTransactions;\n\t\tthis.jtaPlatform = jtaPlatform;\n\t\tthis.preferUserTransactions = preferUserTransactions;\n\t\tthis.performJtaThreadTracking = performJtaThreadTracking;\n\n\t\tif ( observers != null ) {\n\t\t\tthis.observers = new ArrayList<>( observers.length );\n\t\t\taddAll( this.observers, observers );\n\t\t}\n\n\t\tsynchronizationRegistered = false;\n\n\t\tpulse();\n\t}\n\n\t/**\n\t * Needed because while iterating the observers list and executing the before/update callbacks,\n\t * some observers might get removed from the list.\n\t * Yet try to not allocate anything for when the list is empty, as this is a common case.\n\t *\n\t * @return TransactionObserver\n\t */\n\tprivate Iterable<TransactionObserver> observers() {\n\t\treturn observers == null ? emptyList() : new ArrayList<>( observers );\n\t}\n\n\tpublic SynchronizationCallbackCoordinator getSynchronizationCallbackCoordinator() {\n\t\tif ( callbackCoordinator == null ) {\n\t\t\tcallbackCoordinator = performJtaThreadTracking\n\t\t\t\t\t? new SynchronizationCallbackCoordinatorTrackingImpl( this )\n\t\t\t\t\t: new SynchronizationCallbackCoordinatorNonTrackingImpl( this );\n\t\t}\n\t\treturn callbackCoordinator;\n\t}\n\n\t@Override\n\tpublic void pulse() {\n\t\tif ( !autoJoinTransactions ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( synchronizationRegistered ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Can we register a synchronization according to the JtaPlatform?\n\t\tif ( !jtaPlatform.canRegisterSynchronization() ) {\n\t\t\tlog.trace( \"JTA platform says we cannot currently register synchronization; skipping\" );\n\t\t\treturn;\n\t\t}\n\n\t\tjoinJtaTransaction();\n\t}\n\n\t/**\n\t * Join to the JTA transaction.  Note that the underlying meaning of joining in JTA environments is to register the\n\t * RegisteredSynchronization with the JTA system\n\t */\n\tprivate void joinJtaTransaction() {\n\t\tif ( synchronizationRegistered ) {\n\t\t\treturn;\n\t\t}\n\n\t\tjtaPlatform.registerSynchronization( new RegisteredSynchronization( getSynchronizationCallbackCoordinator() ) );\n\t\tgetSynchronizationCallbackCoordinator().synchronizationRegistered();\n\t\tsynchronizationRegistered = true;\n\t\tlog.debug( \"Hibernate RegisteredSynchronization successfully registered with JTA platform\" );\n\n\t\t// report entering into a \"transactional context\"\n\t\tgetTransactionCoordinatorOwner().startTransactionBoundary();\n\t}\n\n\t@Override\n\tpublic void explicitJoin() {\n\t\tif ( synchronizationRegistered ) {\n\t\t\tlog.debug( \"JTA transaction was already joined (RegisteredSynchronization already registered)\" );\n\t\t\treturn;\n\t\t}\n\n\t\tif ( getTransactionDriverControl().getStatus() != ACTIVE ) {\n\t\t\tthrow new TransactionRequiredForJoinException(\n\t\t\t\t\t\"Explicitly joining a JTA transaction requires a JTA transaction be currently active\"\n\t\t\t);\n\t\t}\n\n\t\tjoinJtaTransaction();\n\t}\n\n\t@Override\n\tpublic boolean isJoined() {\n\t\treturn synchronizationRegistered;\n\t}\n\n\t/**\n\t * Is the RegisteredSynchronization used by Hibernate for unified JTA Synchronization callbacks registered for this\n\t * coordinator?\n\t *\n\t * @return {@code true} indicates that a RegisteredSynchronization is currently registered for this coordinator;\n\t * {@code false} indicates it is not (yet) registered.\n\t */\n\tpublic boolean isSynchronizationRegistered() {\n\t\treturn synchronizationRegistered;\n\t}\n\n\tpublic TransactionCoordinatorOwner getTransactionCoordinatorOwner(){\n\t\treturn this.transactionCoordinatorOwner;\n\t}\n\n\t@Override\n\tpublic JpaCompliance getJpaCompliance() {\n\t\treturn transactionCoordinatorOwner.getJdbcSessionOwner().getJdbcSessionContext().getJpaCompliance();\n\t}\n\n\t@Override\n\tpublic TransactionDriver getTransactionDriverControl() {\n\t\tif ( physicalTransactionDelegate == null ) {\n\t\t\tphysicalTransactionDelegate = makePhysicalTransactionDelegate();\n\t\t}\n\t\treturn physicalTransactionDelegate;\n\t}\n\n\tprivate TransactionDriverControlImpl makePhysicalTransactionDelegate() {\n\t\tJtaTransactionAdapter adapter;\n\n\t\tif ( preferUserTransactions ) {\n\t\t\tadapter = makeUserTransactionAdapter();\n\n\t\t\tif ( adapter == null ) {\n\t\t\t\tlog.debug( \"Unable to access UserTransaction, attempting to use TransactionManager instead\" );\n\t\t\t\tadapter = makeTransactionManagerAdapter();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tadapter = makeTransactionManagerAdapter();\n\n\t\t\tif ( adapter == null ) {\n\t\t\t\tlog.debug( \"Unable to access TransactionManager, attempting to use UserTransaction instead\" );\n\t\t\t\tadapter = makeUserTransactionAdapter();\n\t\t\t}\n\t\t}\n\n\t\tif ( adapter == null ) {\n\t\t\tthrow new JtaPlatformInaccessibleException(\n\t\t\t\t\t\"Unable to access TransactionManager or UserTransaction to make physical transaction delegate\"\n\t\t\t);\n\t\t}\n\n\t\treturn new TransactionDriverControlImpl( adapter );\n\t}\n\n\tprivate JtaTransactionAdapter makeUserTransactionAdapter() {\n\t\ttry {\n\t\t\tfinal UserTransaction userTransaction = jtaPlatform.retrieveUserTransaction();\n\t\t\tif ( userTransaction == null ) {\n\t\t\t\tlog.debug( \"JtaPlatform#retrieveUserTransaction returned null\" );\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new JtaTransactionAdapterUserTransactionImpl( userTransaction );\n\t\t\t}\n\t\t}\n\t\tcatch ( Exception exception ) {\n\t\t\tlog.debugf( \"JtaPlatform#retrieveUserTransaction threw an exception [%s]\", exception.getMessage() );\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate JtaTransactionAdapter makeTransactionManagerAdapter() {\n\t\ttry {\n\t\t\tfinal TransactionManager transactionManager = jtaPlatform.retrieveTransactionManager();\n\t\t\tif ( transactionManager == null ) {\n\t\t\t\tlog.debug( \"JtaPlatform#retrieveTransactionManager returned null\" );\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new JtaTransactionAdapterTransactionManagerImpl( transactionManager );\n\t\t\t}\n\t\t}\n\t\tcatch ( Exception exception ) {\n\t\t\tlog.debugf( \"JtaPlatform#retrieveTransactionManager threw an exception [%s]\", exception.getMessage() );\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic SynchronizationRegistry getLocalSynchronizations() {\n\t\treturn synchronizationRegistry;\n\t}\n\n\t@Override\n\tpublic boolean isActive() {\n\t\treturn transactionCoordinatorOwner.isActive();\n\t}\n\n\tpublic boolean isJtaTransactionCurrentlyActive() {\n\t\treturn getTransactionDriverControl().getStatus() == ACTIVE;\n\t}\n\n\t@Override\n\tpublic IsolationDelegate createIsolationDelegate() {\n\t\treturn new JtaIsolationDelegate( transactionCoordinatorOwner, jtaPlatform.retrieveTransactionManager() );\n\t}\n\n\t@Override\n\tpublic TransactionCoordinatorBuilder getTransactionCoordinatorBuilder() {\n\t\treturn transactionCoordinatorBuilder;\n\t}\n\n\t@Override\n\tpublic void setTimeOut(int seconds) {\n\t\tthis.timeOut = seconds;\n\t\tphysicalTransactionDelegate.jtaTransactionAdapter.setTimeOut( seconds );\n\t}\n\n\t@Override\n\tpublic int getTimeOut() {\n\t\treturn timeOut;\n\t}\n\n\t@Override\n\tpublic void invalidate() {\n\t\tif ( physicalTransactionDelegate != null ) {\n\t\t\tphysicalTransactionDelegate.invalidate();\n\t\t}\n\t\tphysicalTransactionDelegate = null;\n\t}\n\n\t// SynchronizationCallbackTarget ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\t@Override\n\tpublic void beforeCompletion() {\n\t\ttry {\n\t\t\ttransactionCoordinatorOwner.beforeTransactionCompletion();\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\tphysicalTransactionDelegate.markRollbackOnly();\n\t\t\tthrow e;\n\t\t}\n\t\tfinally {\n\t\t\tsynchronizationRegistry.notifySynchronizationsBeforeTransactionCompletion();\n\t\t\tfor ( TransactionObserver observer : observers() ) {\n\t\t\t\tobserver.beforeCompletion();\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void afterCompletion(boolean successful, boolean delayed) {\n\t\tif ( !transactionCoordinatorOwner.isActive() ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal int statusToSend =  successful ? Status.STATUS_COMMITTED : Status.STATUS_UNKNOWN;\n\t\tsynchronizationRegistry.notifySynchronizationsAfterTransactionCompletion( statusToSend );\n\n//\t\tafterCompletionAction.doAction( this, statusToSend );\n\n\t\ttransactionCoordinatorOwner.afterTransactionCompletion( successful, delayed );\n\n\t\tfor ( TransactionObserver observer : observers() ) {\n\t\t\tobserver.afterCompletion( successful, delayed );\n\t\t}\n\n\t\tsynchronizationRegistered = false;\n\t}\n\n\tpublic void addObserver(TransactionObserver observer) {\n\t\tif ( observers == null ) {\n\t\t\tobservers = new ArrayList<>( 3 ); //These lists are typically very small.\n\t\t}\n\t\tobservers.add( observer );\n\t}\n\n\t@Override\n\tpublic void removeObserver(TransactionObserver observer) {\n\t\tif ( observers != null ) {\n\t\t\tobservers.remove( observer );\n\t\t}\n\t}\n\n\t/**\n\t * Implementation of the LocalInflow for this TransactionCoordinator.  Allows the\n\t * local transaction ({@link org.hibernate.Transaction} to callback into this\n\t * TransactionCoordinator for the purpose of driving the underlying JTA transaction.\n\t */\n\tpublic class TransactionDriverControlImpl implements TransactionDriver {\n\t\tprivate final JtaTransactionAdapter jtaTransactionAdapter;\n\t\tprivate boolean invalid;\n\n\t\tpublic TransactionDriverControlImpl(JtaTransactionAdapter jtaTransactionAdapter) {\n\t\t\tthis.jtaTransactionAdapter = jtaTransactionAdapter;\n\t\t}\n\n\t\tprotected void invalidate() {\n\t\t\tinvalid = true;\n\t\t}\n\n\t\t@Override\n\t\tpublic void begin() {\n\t\t\terrorIfInvalid();\n\n\t\t\tjtaTransactionAdapter.begin();\n\t\t\tJtaTransactionCoordinatorImpl.this.joinJtaTransaction();\n\t\t}\n\n\t\tprotected void errorIfInvalid() {\n\t\t\tif ( invalid ) {\n\t\t\t\tthrow new IllegalStateException( \"Physical-transaction delegate is no longer valid\" );\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void commit() {\n\t\t\terrorIfInvalid();\n\t\t\tgetTransactionCoordinatorOwner().flushBeforeTransactionCompletion();\n\n\t\t\t// we don't have to perform any before/after completion processing here.  We leave that for\n\t\t\t// the Synchronization callbacks\n\t\t\tjtaTransactionAdapter.commit();\n\t\t}\n\n\t\t@Override\n\t\tpublic void rollback() {\n\t\t\terrorIfInvalid();\n\n\t\t\t// we don't have to perform any after completion processing here.  We leave that for\n\t\t\t// the Synchronization callbacks\n\t\t\tjtaTransactionAdapter.rollback();\n\t\t}\n\n\t\t@Override\n\t\tpublic TransactionStatus getStatus() {\n\t\t\treturn jtaTransactionAdapter.getStatus();\n\t\t}\n\n\t\t@Override\n\t\tpublic void markRollbackOnly() {\n\t\t\tif ( jtaTransactionAdapter.getStatus() != NOT_ACTIVE  ) {\n\t\t\t\tjtaTransactionAdapter.markRollbackOnly();\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic generatedBeforeExecution(entity Object, session SharedSessionContractImplementor) : boolean extracted from public generatedOnExecution(owner Object, session SharedSessionContractImplementor) : boolean in class org.hibernate.orm.test.idgen.userdefined.MixedTimingGeneratorsTest.IdentityOrRandomGenerator",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/idgen/userdefined/MixedTimingGeneratorsTest.java",
                "startLine": 308,
                "endLine": 311,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/idgen/userdefined/MixedTimingGeneratorsTest.java",
                "startLine": 308,
                "endLine": 311,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/idgen/userdefined/MixedTimingGeneratorsTest.java",
                "startLine": 313,
                "endLine": 316,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic boolean generatedOnExecution(Object owner, SharedSessionContractImplementor session) {\n\t\t\treturn !( (RandomEntity) owner ).getName().contains( \"random\" );\n\t\t}",
        "filePathBefore": "hibernate-core/src/test/java/org/hibernate/orm/test/idgen/userdefined/MixedTimingGeneratorsTest.java",
        "isPureRefactoring": true,
        "commitId": "cf0ab77cf2b26ca65db7b538233cab2ba1cbe4d7",
        "packageNameBefore": "org.hibernate.orm.test.idgen.userdefined.MixedTimingGeneratorsTest",
        "classNameBefore": "org.hibernate.orm.test.idgen.userdefined.MixedTimingGeneratorsTest.IdentityOrRandomGenerator",
        "methodNameBefore": "org.hibernate.orm.test.idgen.userdefined.MixedTimingGeneratorsTest.IdentityOrRandomGenerator#generatedOnExecution",
        "invokedMethod": "methodSignature: org.hibernate.orm.test.idgen.userdefined.MixedTimingGeneratorsTest.RandomEntity#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.orm.test.idgen.userdefined.MixedTimingGeneratorsTest.StringGeneratedEntity#getName\n methodBody: public String getName() {\nreturn name;\n}",
        "classSignatureBefore": "public static class IdentityOrRandomGenerator extends IdentityGenerator implements BeforeExecutionGenerator ",
        "methodNameBeforeSet": [
            "org.hibernate.orm.test.idgen.userdefined.MixedTimingGeneratorsTest.IdentityOrRandomGenerator#generatedOnExecution"
        ],
        "classNameBeforeSet": [
            "org.hibernate.orm.test.idgen.userdefined.MixedTimingGeneratorsTest.IdentityOrRandomGenerator"
        ],
        "classSignatureBeforeSet": [
            "public static class IdentityOrRandomGenerator extends IdentityGenerator implements BeforeExecutionGenerator "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.orm.test.idgen.userdefined;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\nimport java.util.EnumSet;\nimport java.util.Properties;\nimport java.util.concurrent.ThreadLocalRandom;\n\nimport org.hibernate.annotations.GenericGenerator;\nimport org.hibernate.annotations.SourceType;\nimport org.hibernate.annotations.ValueGenerationType;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.dialect.OracleDialect;\nimport org.hibernate.dialect.SQLServerDialect;\nimport org.hibernate.dialect.SybaseASEDialect;\nimport org.hibernate.engine.spi.SharedSessionContractImplementor;\nimport org.hibernate.generator.BeforeExecutionGenerator;\nimport org.hibernate.generator.EventType;\nimport org.hibernate.generator.EventTypeSets;\nimport org.hibernate.generator.OnExecutionGenerator;\nimport org.hibernate.id.IdentifierGenerator;\nimport org.hibernate.id.IdentityGenerator;\nimport org.hibernate.persister.entity.EntityPersister;\nimport org.hibernate.service.ServiceRegistry;\nimport org.hibernate.type.Type;\n\nimport org.hibernate.testing.orm.junit.DialectFeatureChecks;\nimport org.hibernate.testing.orm.junit.DomainModel;\nimport org.hibernate.testing.orm.junit.Jira;\nimport org.hibernate.testing.orm.junit.RequiresDialectFeature;\nimport org.hibernate.testing.orm.junit.SessionFactory;\nimport org.hibernate.testing.orm.junit.SessionFactoryScope;\nimport org.hibernate.testing.orm.junit.SkipForDialect;\nimport org.junit.jupiter.api.Test;\n\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.GeneratedValue;\nimport jakarta.persistence.Id;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.hibernate.generator.EventTypeSets.INSERT_ONLY;\n\n/**\n * @author Marco Belladelli\n */\n@DomainModel( annotatedClasses = {\n\t\tMixedTimingGeneratorsTest.AssignedEntity.class,\n\t\tMixedTimingGeneratorsTest.RandomEntity.class,\n\t\tMixedTimingGeneratorsTest.StringGeneratedEntity.class,\n} )\n@SessionFactory\n@RequiresDialectFeature( feature = DialectFeatureChecks.SupportsIdentityColumns.class )\n@Jira( \"https://hibernate.atlassian.net/browse/HHH-17322\" )\npublic class MixedTimingGeneratorsTest {\n\t@Test\n\t@SkipForDialect( dialectClass = SQLServerDialect.class, reason = \"SQLServer does not support setting explicit values for identity columns\" )\n\t@SkipForDialect( dialectClass = OracleDialect.class, reason = \"Oracle does not support setting explicit values for identity columns\" )\n\t@SkipForDialect( dialectClass = SybaseASEDialect.class, reason = \"Sybase does not support setting explicit values for identity columns\" )\n\tpublic void testIdentityOrAssignedId(SessionFactoryScope scope) {\n\t\t// on execution generation\n\t\tscope.inTransaction( session -> session.persist( new AssignedEntity( \"identity\" ) ) );\n\t\tscope.inSession( session -> assertThat( session.createQuery(\n\t\t\t\t\"from AssignedEntity where name = :name\",\n\t\t\t\tAssignedEntity.class\n\t\t).setParameter( \"name\", \"identity\" ).getSingleResult().getId() ).isNotEqualTo( 42L ) );\n\t\t// before execution generation\n\t\tscope.inTransaction( session -> session.persist( new AssignedEntity( 42L, \"assigned\" ) ) );\n\t\tscope.inSession( session -> assertThat( session.createQuery(\n\t\t\t\t\"from AssignedEntity where name = :name\",\n\t\t\t\tAssignedEntity.class\n\t\t).setParameter( \"name\", \"assigned\" ).getSingleResult().getId() ).isEqualTo( 42L ) );\n\t}\n\n\t@Test\n\t@SkipForDialect( dialectClass = SQLServerDialect.class, reason = \"SQLServer does not support setting explicit values for identity columns\" )\n\t@SkipForDialect( dialectClass = OracleDialect.class, reason = \"Oracle does not support setting explicit values for identity columns\" )\n\t@SkipForDialect( dialectClass = SybaseASEDialect.class, reason = \"Sybase does not support setting explicit values for identity columns\" )\n\tpublic void testIdentityOrAssignedIdStateless(SessionFactoryScope scope) {\n\t\t// on execution generation\n\t\tscope.inStatelessTransaction( session -> session.insert( new AssignedEntity( \"stateless_identity\" ) ) );\n\t\tscope.inStatelessSession( session -> assertThat( session.createQuery(\n\t\t\t\t\"from AssignedEntity where name = :name\",\n\t\t\t\tAssignedEntity.class\n\t\t).setParameter( \"name\", \"stateless_identity\" ).getSingleResult().getId() ).isNotEqualTo( 23L ) );\n\t\t// before execution generation\n\t\tscope.inStatelessTransaction( session -> session.insert( new AssignedEntity( 23L, \"stateless_assigned\" ) ) );\n\t\tscope.inStatelessSession( session -> assertThat( session.createQuery(\n\t\t\t\t\"from AssignedEntity where name = :name\",\n\t\t\t\tAssignedEntity.class\n\t\t).setParameter( \"name\", \"stateless_assigned\" ).getSingleResult().getId() ).isEqualTo( 23L ) );\n\t}\n\n\t@Test\n\t@SkipForDialect( dialectClass = SQLServerDialect.class, reason = \"SQLServer does not support setting explicit values for identity columns\" )\n\t@SkipForDialect( dialectClass = OracleDialect.class, reason = \"Oracle does not support setting explicit values for identity columns\" )\n\t@SkipForDialect( dialectClass = SybaseASEDialect.class, reason = \"Sybase does not support setting explicit values for identity columns\" )\n\tpublic void testIdentityOrRandomId(SessionFactoryScope scope) {\n\t\t// on execution generation\n\t\tscope.inTransaction( session -> session.persist( new RandomEntity( \"identity\" ) ) );\n\t\tscope.inSession( session -> assertThat( session.createQuery(\n\t\t\t\t\"from RandomEntity where name = :name\",\n\t\t\t\tRandomEntity.class\n\t\t).setParameter( \"name\", \"identity\" ).getSingleResult().getId() ).isLessThan( 100L ) );\n\t\t// before execution generation\n\t\tscope.inTransaction( session -> session.persist( new RandomEntity( \"random\" ) ) );\n\t\tscope.inSession( session -> assertThat( session.createQuery(\n\t\t\t\t\"from RandomEntity where name = :name\",\n\t\t\t\tRandomEntity.class\n\t\t).setParameter( \"name\", \"random\" ).getSingleResult().getId() ).isGreaterThanOrEqualTo( 100L ) );\n\t}\n\n\t@Test\n\tpublic void testGeneratedPropInsert(SessionFactoryScope scope) {\n\t\t// on execution generation\n\t\tscope.inTransaction( session -> session.persist( new StringGeneratedEntity( 1L, \"literal\" ) ) );\n\t\tscope.inSession( session -> assertThat(\n\t\t\t\tsession.find( StringGeneratedEntity.class, 1L ).getGeneratedProp()\n\t\t).startsWith( \"literal\" ) );\n\t\t// before execution generation\n\t\tscope.inTransaction( session -> session.persist( new StringGeneratedEntity( 2L, \"generated\" ) ) );\n\t\tscope.inSession( session -> assertThat(\n\t\t\t\tsession.find( StringGeneratedEntity.class, 2L ).getGeneratedProp()\n\t\t).startsWith( \"generated\" ) );\n\t}\n\n\t@Test\n\tpublic void testGeneratedPropUpdate(SessionFactoryScope scope) {\n\t\t// on execution generation\n\t\tfinal int literalCount = scope.fromTransaction( session -> {\n\t\t\tfinal StringGeneratedEntity entity = new StringGeneratedEntity( 3L, \"literal_inserted\" );\n\t\t\tsession.persist( entity );\n\t\t\tsession.flush();\n\t\t\tassertThat( entity.getGeneratedProp() ).startsWith( \"literal\" );\n\t\t\tentity.setName( \"literal_updated\" );\n\t\t\treturn Integer.parseInt( entity.getGeneratedProp().split( \"_\" )[1] );\n\t\t} );\n\t\tscope.inSession( session -> {\n\t\t\tfinal StringGeneratedEntity entity = session.find( StringGeneratedEntity.class, 3L );\n\t\t\tfinal String generatedProp = entity.getGeneratedProp();\n\t\t\tassertThat( generatedProp ).startsWith( \"literal\" );\n\t\t\tassertThat( Integer.parseInt( generatedProp.split( \"_\" )[1] ) ).isGreaterThan( literalCount );\n\t\t} );\n\t\t// before execution generation\n\t\tfinal int generatedCount = scope.fromTransaction( session -> {\n\t\t\tfinal StringGeneratedEntity entity = new StringGeneratedEntity( 4L, \"generated_inserted\" );\n\t\t\tsession.persist( entity );\n\t\t\tsession.flush();\n\t\t\tassertThat( entity.getGeneratedProp() ).startsWith( \"generated\" );\n\t\t\tentity.setName( \"generated_updated\" );\n\t\t\treturn Integer.parseInt( entity.getGeneratedProp().split( \"_\" )[1] );\n\t\t} );\n\t\tscope.inSession( session -> {\n\t\t\tfinal StringGeneratedEntity entity = session.find( StringGeneratedEntity.class, 4L );\n\t\t\tfinal String generatedProp = entity.getGeneratedProp();\n\t\t\tassertThat( generatedProp ).startsWith( \"generated\" );\n\t\t\tassertThat( Integer.parseInt( generatedProp.split( \"_\" )[1] ) ).isGreaterThan( generatedCount );\n\t\t} );\n\t}\n\n\t@Entity( name = \"AssignedEntity\" )\n\tpublic static class AssignedEntity {\n\t\t@Id\n\t\t@GeneratedValue( generator = \"identity_or_assigned\" )\n\t\t@GenericGenerator( name = \"identity_or_assigned\", type = IdentityOrAssignedGenerator.class )\n\t\tprivate Long id;\n\n\t\tprivate String name;\n\n\t\tpublic AssignedEntity() {\n\t\t}\n\n\t\tpublic AssignedEntity(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic AssignedEntity(Long id, String name) {\n\t\t\tthis.id = id;\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic Long getId() {\n\t\t\treturn id;\n\t\t}\n\t}\n\n\t@Entity( name = \"RandomEntity\" )\n\tpublic static class RandomEntity {\n\t\t@Id\n\t\t@GeneratedValue( generator = \"identity_or_random\" )\n\t\t@GenericGenerator( name = \"identity_or_random\", type = IdentityOrRandomGenerator.class )\n\t\tprivate Long id;\n\n\t\tprivate String name;\n\n\t\tpublic RandomEntity() {\n\t\t}\n\n\t\tpublic RandomEntity(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic Long getId() {\n\t\t\treturn id;\n\t\t}\n\n\t\tpublic String getName() {\n\t\t\treturn name;\n\t\t}\n\t}\n\n\t@ValueGenerationType( generatedBy = LiteralOrGeneratedStringGenerator.class )\n\t@Retention( RUNTIME )\n\t@Target( { FIELD, METHOD } )\n\tpublic @interface GeneratedString {\n\t\t/**\n\t\t * Specifies how the timestamp is generated. By default, it is generated\n\t\t * in memory, which saves a round trip to the database.\n\t\t */\n\t\tSourceType source() default SourceType.VM;\n\t}\n\n\n\t@Entity( name = \"StringGeneratedEntity\" )\n\tpublic static class StringGeneratedEntity {\n\t\t@Id\n\t\tprivate Long id;\n\n\t\tprivate String name;\n\n\t\t@GeneratedString\n\t\tprivate String generatedProp;\n\n\t\tpublic StringGeneratedEntity() {\n\t\t}\n\n\t\tpublic StringGeneratedEntity(Long id, String name) {\n\t\t\tthis.id = id;\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic String getName() {\n\t\t\treturn name;\n\t\t}\n\n\t\tpublic void setName(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic String getGeneratedProp() {\n\t\t\treturn generatedProp;\n\t\t}\n\t}\n\n\tpublic static class IdentityOrAssignedGenerator extends IdentityGenerator implements IdentifierGenerator {\n\t\t@Override\n\t\tpublic Object generate(SharedSessionContractImplementor session, Object object) {\n\t\t\tfinal EntityPersister entityPersister = session.getEntityPersister( null, object );\n\t\t\treturn entityPersister.getIdentifier( object, session );\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean generatedOnExecution() {\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean generatedOnExecution(Object owner, SharedSessionContractImplementor session) {\n\t\t\treturn generate( session, owner, null, null ) == null;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean allowAssignedIdentifiers() {\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic EnumSet<EventType> getEventTypes() {\n\t\t\treturn INSERT_ONLY;\n\t\t}\n\n\t\t@Override\n\t\tpublic void configure(Type type, Properties params, ServiceRegistry serviceRegistry) {\n\t\t}\n\t}\n\n\tpublic static class IdentityOrRandomGenerator extends IdentityGenerator implements BeforeExecutionGenerator {\n\t\t@Override\n\t\tpublic Object generate(\n\t\t\t\tSharedSessionContractImplementor session,\n\t\t\t\tObject owner,\n\t\t\t\tObject currentValue,\n\t\t\t\tEventType eventType) {\n\t\t\treturn ThreadLocalRandom.current().nextLong( 100, 1_000 );\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean generatedOnExecution() {\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean generatedOnExecution(Object owner, SharedSessionContractImplementor session) {\n\t\t\treturn !( (RandomEntity) owner ).getName().contains( \"random\" );\n\t\t}\n\t}\n\n\tpublic static class LiteralOrGeneratedStringGenerator implements OnExecutionGenerator, BeforeExecutionGenerator {\n\t\tprivate int count;\n\n\t\tpublic LiteralOrGeneratedStringGenerator() {\n\t\t\tcount = 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object generate(\n\t\t\t\tSharedSessionContractImplementor session,\n\t\t\t\tObject owner,\n\t\t\t\tObject currentValue,\n\t\t\t\tEventType eventType) {\n\t\t\treturn \"generated_\" + count++;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean generatedOnExecution() {\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean generatedOnExecution(Object owner, SharedSessionContractImplementor session) {\n\t\t\treturn !( (StringGeneratedEntity) owner ).getName().contains( \"generated\" );\n\t\t}\n\n\t\t@Override\n\t\tpublic EnumSet<EventType> getEventTypes() {\n\t\t\treturn EventTypeSets.ALL;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean referenceColumnsInSql(Dialect dialect) {\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean writePropertyValue() {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic String[] getReferencedColumnValues(Dialect dialect) {\n\t\t\treturn new String[] { \"'literal_\" + count++ + \"'\" };\n\t\t}\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/test/java/org/hibernate/orm/test/idgen/userdefined/MixedTimingGeneratorsTest.java",
        "sourceCodeAfterForWhole": "/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.orm.test.idgen.userdefined;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\nimport java.util.EnumSet;\nimport java.util.Properties;\nimport java.util.concurrent.ThreadLocalRandom;\n\nimport org.hibernate.annotations.GenericGenerator;\nimport org.hibernate.annotations.SourceType;\nimport org.hibernate.annotations.ValueGenerationType;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.dialect.OracleDialect;\nimport org.hibernate.dialect.SQLServerDialect;\nimport org.hibernate.dialect.SybaseASEDialect;\nimport org.hibernate.engine.spi.SharedSessionContractImplementor;\nimport org.hibernate.generator.BeforeExecutionGenerator;\nimport org.hibernate.generator.EventType;\nimport org.hibernate.generator.EventTypeSets;\nimport org.hibernate.generator.OnExecutionGenerator;\nimport org.hibernate.id.IdentifierGenerator;\nimport org.hibernate.id.IdentityGenerator;\nimport org.hibernate.persister.entity.EntityPersister;\nimport org.hibernate.service.ServiceRegistry;\nimport org.hibernate.type.Type;\n\nimport org.hibernate.testing.orm.junit.DialectFeatureChecks;\nimport org.hibernate.testing.orm.junit.DomainModel;\nimport org.hibernate.testing.orm.junit.Jira;\nimport org.hibernate.testing.orm.junit.RequiresDialectFeature;\nimport org.hibernate.testing.orm.junit.SessionFactory;\nimport org.hibernate.testing.orm.junit.SessionFactoryScope;\nimport org.hibernate.testing.orm.junit.SkipForDialect;\nimport org.junit.jupiter.api.Test;\n\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.GeneratedValue;\nimport jakarta.persistence.Id;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.hibernate.generator.EventTypeSets.INSERT_ONLY;\n\n/**\n * @author Marco Belladelli\n */\n@DomainModel( annotatedClasses = {\n\t\tMixedTimingGeneratorsTest.AssignedEntity.class,\n\t\tMixedTimingGeneratorsTest.RandomEntity.class,\n\t\tMixedTimingGeneratorsTest.StringGeneratedEntity.class,\n} )\n@SessionFactory\n@RequiresDialectFeature( feature = DialectFeatureChecks.SupportsIdentityColumns.class )\n@Jira( \"https://hibernate.atlassian.net/browse/HHH-17322\" )\npublic class MixedTimingGeneratorsTest {\n\t@Test\n\t@SkipForDialect( dialectClass = SQLServerDialect.class, reason = \"SQLServer does not support setting explicit values for identity columns\" )\n\t@SkipForDialect( dialectClass = OracleDialect.class, reason = \"Oracle does not support setting explicit values for identity columns\" )\n\t@SkipForDialect( dialectClass = SybaseASEDialect.class, reason = \"Sybase does not support setting explicit values for identity columns\" )\n\tpublic void testIdentityOrAssignedId(SessionFactoryScope scope) {\n\t\t// on execution generation\n\t\tscope.inTransaction( session -> session.persist( new AssignedEntity( \"identity\" ) ) );\n\t\tscope.inSession( session -> assertThat( session.createQuery(\n\t\t\t\t\"from AssignedEntity where name = :name\",\n\t\t\t\tAssignedEntity.class\n\t\t).setParameter( \"name\", \"identity\" ).getSingleResult().getId() ).isNotEqualTo( 42L ) );\n\t\t// before execution generation\n\t\tscope.inTransaction( session -> session.persist( new AssignedEntity( 42L, \"assigned\" ) ) );\n\t\tscope.inSession( session -> assertThat( session.createQuery(\n\t\t\t\t\"from AssignedEntity where name = :name\",\n\t\t\t\tAssignedEntity.class\n\t\t).setParameter( \"name\", \"assigned\" ).getSingleResult().getId() ).isEqualTo( 42L ) );\n\t}\n\n\t@Test\n\t@SkipForDialect( dialectClass = SQLServerDialect.class, reason = \"SQLServer does not support setting explicit values for identity columns\" )\n\t@SkipForDialect( dialectClass = OracleDialect.class, reason = \"Oracle does not support setting explicit values for identity columns\" )\n\t@SkipForDialect( dialectClass = SybaseASEDialect.class, reason = \"Sybase does not support setting explicit values for identity columns\" )\n\tpublic void testIdentityOrAssignedIdStateless(SessionFactoryScope scope) {\n\t\t// on execution generation\n\t\tscope.inStatelessTransaction( session -> session.insert( new AssignedEntity( \"stateless_identity\" ) ) );\n\t\tscope.inStatelessSession( session -> assertThat( session.createQuery(\n\t\t\t\t\"from AssignedEntity where name = :name\",\n\t\t\t\tAssignedEntity.class\n\t\t).setParameter( \"name\", \"stateless_identity\" ).getSingleResult().getId() ).isNotEqualTo( 23L ) );\n\t\t// before execution generation\n\t\tscope.inStatelessTransaction( session -> session.insert( new AssignedEntity( 23L, \"stateless_assigned\" ) ) );\n\t\tscope.inStatelessSession( session -> assertThat( session.createQuery(\n\t\t\t\t\"from AssignedEntity where name = :name\",\n\t\t\t\tAssignedEntity.class\n\t\t).setParameter( \"name\", \"stateless_assigned\" ).getSingleResult().getId() ).isEqualTo( 23L ) );\n\t}\n\n\t@Test\n\t@SkipForDialect( dialectClass = SQLServerDialect.class, reason = \"SQLServer does not support setting explicit values for identity columns\" )\n\t@SkipForDialect( dialectClass = OracleDialect.class, reason = \"Oracle does not support setting explicit values for identity columns\" )\n\t@SkipForDialect( dialectClass = SybaseASEDialect.class, reason = \"Sybase does not support setting explicit values for identity columns\" )\n\tpublic void testIdentityOrRandomId(SessionFactoryScope scope) {\n\t\t// on execution generation\n\t\tscope.inTransaction( session -> session.persist( new RandomEntity( \"identity\" ) ) );\n\t\tscope.inSession( session -> assertThat( session.createQuery(\n\t\t\t\t\"from RandomEntity where name = :name\",\n\t\t\t\tRandomEntity.class\n\t\t).setParameter( \"name\", \"identity\" ).getSingleResult().getId() ).isLessThan( 100L ) );\n\t\t// before execution generation\n\t\tscope.inTransaction( session -> session.persist( new RandomEntity( \"random\" ) ) );\n\t\tscope.inSession( session -> assertThat( session.createQuery(\n\t\t\t\t\"from RandomEntity where name = :name\",\n\t\t\t\tRandomEntity.class\n\t\t).setParameter( \"name\", \"random\" ).getSingleResult().getId() ).isGreaterThanOrEqualTo( 100L ) );\n\t}\n\n\t@Test\n\tpublic void testGeneratedPropInsert(SessionFactoryScope scope) {\n\t\t// on execution generation\n\t\tscope.inTransaction( session -> session.persist( new StringGeneratedEntity( 1L, \"literal\" ) ) );\n\t\tscope.inSession( session -> assertThat(\n\t\t\t\tsession.find( StringGeneratedEntity.class, 1L ).getGeneratedProp()\n\t\t).startsWith( \"literal\" ) );\n\t\t// before execution generation\n\t\tscope.inTransaction( session -> session.persist( new StringGeneratedEntity( 2L, \"generated\" ) ) );\n\t\tscope.inSession( session -> assertThat(\n\t\t\t\tsession.find( StringGeneratedEntity.class, 2L ).getGeneratedProp()\n\t\t).startsWith( \"generated\" ) );\n\t}\n\n\t@Test\n\tpublic void testGeneratedPropUpdate(SessionFactoryScope scope) {\n\t\t// on execution generation\n\t\tfinal int literalCount = scope.fromTransaction( session -> {\n\t\t\tfinal StringGeneratedEntity entity = new StringGeneratedEntity( 3L, \"literal_inserted\" );\n\t\t\tsession.persist( entity );\n\t\t\tsession.flush();\n\t\t\tassertThat( entity.getGeneratedProp() ).startsWith( \"literal\" );\n\t\t\tentity.setName( \"literal_updated\" );\n\t\t\treturn Integer.parseInt( entity.getGeneratedProp().split( \"_\" )[1] );\n\t\t} );\n\t\tscope.inSession( session -> {\n\t\t\tfinal StringGeneratedEntity entity = session.find( StringGeneratedEntity.class, 3L );\n\t\t\tfinal String generatedProp = entity.getGeneratedProp();\n\t\t\tassertThat( generatedProp ).startsWith( \"literal\" );\n\t\t\tassertThat( Integer.parseInt( generatedProp.split( \"_\" )[1] ) ).isGreaterThan( literalCount );\n\t\t} );\n\t\t// before execution generation\n\t\tfinal int generatedCount = scope.fromTransaction( session -> {\n\t\t\tfinal StringGeneratedEntity entity = new StringGeneratedEntity( 4L, \"generated_inserted\" );\n\t\t\tsession.persist( entity );\n\t\t\tsession.flush();\n\t\t\tassertThat( entity.getGeneratedProp() ).startsWith( \"generated\" );\n\t\t\tentity.setName( \"generated_updated\" );\n\t\t\treturn Integer.parseInt( entity.getGeneratedProp().split( \"_\" )[1] );\n\t\t} );\n\t\tscope.inSession( session -> {\n\t\t\tfinal StringGeneratedEntity entity = session.find( StringGeneratedEntity.class, 4L );\n\t\t\tfinal String generatedProp = entity.getGeneratedProp();\n\t\t\tassertThat( generatedProp ).startsWith( \"generated\" );\n\t\t\tassertThat( Integer.parseInt( generatedProp.split( \"_\" )[1] ) ).isGreaterThan( generatedCount );\n\t\t} );\n\t}\n\n\t@Entity( name = \"AssignedEntity\" )\n\tpublic static class AssignedEntity {\n\t\t@Id\n\t\t@GeneratedValue( generator = \"identity_or_assigned\" )\n\t\t@GenericGenerator( name = \"identity_or_assigned\", type = IdentityOrAssignedGenerator.class )\n\t\tprivate Long id;\n\n\t\tprivate String name;\n\n\t\tpublic AssignedEntity() {\n\t\t}\n\n\t\tpublic AssignedEntity(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic AssignedEntity(Long id, String name) {\n\t\t\tthis.id = id;\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic Long getId() {\n\t\t\treturn id;\n\t\t}\n\t}\n\n\t@Entity( name = \"RandomEntity\" )\n\tpublic static class RandomEntity {\n\t\t@Id\n\t\t@GeneratedValue( generator = \"identity_or_random\" )\n\t\t@GenericGenerator( name = \"identity_or_random\", type = IdentityOrRandomGenerator.class )\n\t\tprivate Long id;\n\n\t\tprivate String name;\n\n\t\tpublic RandomEntity() {\n\t\t}\n\n\t\tpublic RandomEntity(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic Long getId() {\n\t\t\treturn id;\n\t\t}\n\n\t\tpublic String getName() {\n\t\t\treturn name;\n\t\t}\n\t}\n\n\t@ValueGenerationType( generatedBy = LiteralOrGeneratedStringGenerator.class )\n\t@Retention( RUNTIME )\n\t@Target( { FIELD, METHOD } )\n\tpublic @interface GeneratedString {\n\t\t/**\n\t\t * Specifies how the timestamp is generated. By default, it is generated\n\t\t * in memory, which saves a round trip to the database.\n\t\t */\n\t\tSourceType source() default SourceType.VM;\n\t}\n\n\n\t@Entity( name = \"StringGeneratedEntity\" )\n\tpublic static class StringGeneratedEntity {\n\t\t@Id\n\t\tprivate Long id;\n\n\t\tprivate String name;\n\n\t\t@GeneratedString\n\t\tprivate String generatedProp;\n\n\t\tpublic StringGeneratedEntity() {\n\t\t}\n\n\t\tpublic StringGeneratedEntity(Long id, String name) {\n\t\t\tthis.id = id;\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic String getName() {\n\t\t\treturn name;\n\t\t}\n\n\t\tpublic void setName(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic String getGeneratedProp() {\n\t\t\treturn generatedProp;\n\t\t}\n\t}\n\n\tpublic static class IdentityOrAssignedGenerator extends IdentityGenerator implements IdentifierGenerator {\n\t\t@Override\n\t\tpublic Object generate(SharedSessionContractImplementor session, Object object) {\n\t\t\tfinal EntityPersister entityPersister = session.getEntityPersister( null, object );\n\t\t\treturn entityPersister.getIdentifier( object, session );\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean generatedOnExecution() {\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean generatedOnExecution(Object owner, SharedSessionContractImplementor session) {\n\t\t\treturn generate( session, owner, null, null ) == null;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean allowAssignedIdentifiers() {\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic EnumSet<EventType> getEventTypes() {\n\t\t\treturn INSERT_ONLY;\n\t\t}\n\n\t\t@Override\n\t\tpublic void configure(Type type, Properties params, ServiceRegistry serviceRegistry) {\n\t\t}\n\t}\n\n\tpublic static class IdentityOrRandomGenerator extends IdentityGenerator implements BeforeExecutionGenerator {\n\t\t@Override\n\t\tpublic Object generate(\n\t\t\t\tSharedSessionContractImplementor session,\n\t\t\t\tObject owner,\n\t\t\t\tObject currentValue,\n\t\t\t\tEventType eventType) {\n\t\t\treturn ThreadLocalRandom.current().nextLong( 100, 1_000 );\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean generatedOnExecution() {\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean generatedOnExecution(Object entity, SharedSessionContractImplementor session) {\n\t\t\treturn !generatedBeforeExecution( entity, session );\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean generatedBeforeExecution(Object entity, SharedSessionContractImplementor session) {\n\t\t\treturn ( (RandomEntity) entity ).getName().contains( \"random\" );\n\t\t}\n\t}\n\n\tpublic static class LiteralOrGeneratedStringGenerator implements OnExecutionGenerator, BeforeExecutionGenerator {\n\t\tprivate int count;\n\n\t\tpublic LiteralOrGeneratedStringGenerator() {\n\t\t\tcount = 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object generate(\n\t\t\t\tSharedSessionContractImplementor session,\n\t\t\t\tObject owner,\n\t\t\t\tObject currentValue,\n\t\t\t\tEventType eventType) {\n\t\t\treturn \"generated_\" + count++;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean generatedOnExecution() {\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean generatedOnExecution(Object entity, SharedSessionContractImplementor session) {\n\t\t\treturn !generatedBeforeExecution( entity, session );\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean generatedBeforeExecution(Object entity, SharedSessionContractImplementor session) {\n\t\t\treturn ( (StringGeneratedEntity) entity ).getName().contains( \"generated\" );\n\t\t}\n\n\t\t@Override\n\t\tpublic EnumSet<EventType> getEventTypes() {\n\t\t\treturn EventTypeSets.ALL;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean referenceColumnsInSql(Dialect dialect) {\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean writePropertyValue() {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic String[] getReferencedColumnValues(Dialect dialect) {\n\t\t\treturn new String[] { \"'literal_\" + count++ + \"'\" };\n\t\t}\n\t}\n}\n",
        "diffSourceCodeSet": [
            "@Override\n\t\tpublic boolean generatedBeforeExecution(Object entity, SharedSessionContractImplementor session) {\n\t\t\treturn ( (RandomEntity) entity ).getName().contains( \"random\" );\n\t\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.orm.test.idgen.userdefined.MixedTimingGeneratorsTest.RandomEntity#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.orm.test.idgen.userdefined.MixedTimingGeneratorsTest.StringGeneratedEntity#getName\n methodBody: public String getName() {\nreturn name;\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\t\tpublic boolean generatedOnExecution(Object entity, SharedSessionContractImplementor session) {\n\t\t\treturn !generatedBeforeExecution( entity, session );\n\t\t}\n@Override\n\t\tpublic boolean generatedBeforeExecution(Object entity, SharedSessionContractImplementor session) {\n\t\t\treturn ( (RandomEntity) entity ).getName().contains( \"random\" );\n\t\t}",
        "diffSourceCode": "   308: \t\t@Override\n-  309: \t\tpublic boolean generatedOnExecution(Object owner, SharedSessionContractImplementor session) {\n-  310: \t\t\treturn !( (RandomEntity) owner ).getName().contains( \"random\" );\n+  309: \t\tpublic boolean generatedOnExecution(Object entity, SharedSessionContractImplementor session) {\n+  310: \t\t\treturn !generatedBeforeExecution( entity, session );\n   311: \t\t}\n-  313: \n-  314: \tpublic static class LiteralOrGeneratedStringGenerator implements OnExecutionGenerator, BeforeExecutionGenerator {\n-  315: \t\tprivate int count;\n-  316: \n+  313: \t\t@Override\n+  314: \t\tpublic boolean generatedBeforeExecution(Object entity, SharedSessionContractImplementor session) {\n+  315: \t\t\treturn ( (RandomEntity) entity ).getName().contains( \"random\" );\n+  316: \t\t}\n",
        "uniqueId": "cf0ab77cf2b26ca65db7b538233cab2ba1cbe4d7_308_311_313_316_308_311",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": true,
        "compileAndTestResult": true,
        "refactoredCode": "##########################\n@Override\npublic boolean generatedOnExecution(Object owner, SharedSessionContractImplementor session) {\n    return isOwnerNameNotContainingRandom((RandomEntity) owner);\n}\n\nprivate boolean isOwnerNameNotContainingRandom(RandomEntity owner) {\n    return !owner.getName().contains(\"random\");\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Override\n\t\tpublic boolean generatedOnExecution(Object owner, SharedSessionContractImplementor session) {\n\t\t\treturn !( (RandomEntity) owner ).getName().contains( \"random\" );\n\t\t}\n\nClass content:\n/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.orm.test.idgen.userdefined;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\nimport java.util.EnumSet;\nimport java.util.Properties;\nimport java.util.concurrent.ThreadLocalRandom;\n\nimport org.hibernate.annotations.GenericGenerator;\nimport org.hibernate.annotations.SourceType;\nimport org.hibernate.annotations.ValueGenerationType;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.dialect.OracleDialect;\nimport org.hibernate.dialect.SQLServerDialect;\nimport org.hibernate.dialect.SybaseASEDialect;\nimport org.hibernate.engine.spi.SharedSessionContractImplementor;\nimport org.hibernate.generator.BeforeExecutionGenerator;\nimport org.hibernate.generator.EventType;\nimport org.hibernate.generator.EventTypeSets;\nimport org.hibernate.generator.OnExecutionGenerator;\nimport org.hibernate.id.IdentifierGenerator;\nimport org.hibernate.id.IdentityGenerator;\nimport org.hibernate.persister.entity.EntityPersister;\nimport org.hibernate.service.ServiceRegistry;\nimport org.hibernate.type.Type;\n\nimport org.hibernate.testing.orm.junit.DialectFeatureChecks;\nimport org.hibernate.testing.orm.junit.DomainModel;\nimport org.hibernate.testing.orm.junit.Jira;\nimport org.hibernate.testing.orm.junit.RequiresDialectFeature;\nimport org.hibernate.testing.orm.junit.SessionFactory;\nimport org.hibernate.testing.orm.junit.SessionFactoryScope;\nimport org.hibernate.testing.orm.junit.SkipForDialect;\nimport org.junit.jupiter.api.Test;\n\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.GeneratedValue;\nimport jakarta.persistence.Id;\n\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.hibernate.generator.EventTypeSets.INSERT_ONLY;\n\n/**\n * @author Marco Belladelli\n */\n@DomainModel( annotatedClasses = {\n\t\tMixedTimingGeneratorsTest.AssignedEntity.class,\n\t\tMixedTimingGeneratorsTest.RandomEntity.class,\n\t\tMixedTimingGeneratorsTest.StringGeneratedEntity.class,\n} )\n@SessionFactory\n@RequiresDialectFeature( feature = DialectFeatureChecks.SupportsIdentityColumns.class )\n@Jira( \"https://hibernate.atlassian.net/browse/HHH-17322\" )\npublic class MixedTimingGeneratorsTest {\n\t@Test\n\t@SkipForDialect( dialectClass = SQLServerDialect.class, reason = \"SQLServer does not support setting explicit values for identity columns\" )\n\t@SkipForDialect( dialectClass = OracleDialect.class, reason = \"Oracle does not support setting explicit values for identity columns\" )\n\t@SkipForDialect( dialectClass = SybaseASEDialect.class, reason = \"Sybase does not support setting explicit values for identity columns\" )\n\tpublic void testIdentityOrAssignedId(SessionFactoryScope scope) {\n\t\t// on execution generation\n\t\tscope.inTransaction( session -> session.persist( new AssignedEntity( \"identity\" ) ) );\n\t\tscope.inSession( session -> assertThat( session.createQuery(\n\t\t\t\t\"from AssignedEntity where name = :name\",\n\t\t\t\tAssignedEntity.class\n\t\t).setParameter( \"name\", \"identity\" ).getSingleResult().getId() ).isNotEqualTo( 42L ) );\n\t\t// before execution generation\n\t\tscope.inTransaction( session -> session.persist( new AssignedEntity( 42L, \"assigned\" ) ) );\n\t\tscope.inSession( session -> assertThat( session.createQuery(\n\t\t\t\t\"from AssignedEntity where name = :name\",\n\t\t\t\tAssignedEntity.class\n\t\t).setParameter( \"name\", \"assigned\" ).getSingleResult().getId() ).isEqualTo( 42L ) );\n\t}\n\n\t@Test\n\t@SkipForDialect( dialectClass = SQLServerDialect.class, reason = \"SQLServer does not support setting explicit values for identity columns\" )\n\t@SkipForDialect( dialectClass = OracleDialect.class, reason = \"Oracle does not support setting explicit values for identity columns\" )\n\t@SkipForDialect( dialectClass = SybaseASEDialect.class, reason = \"Sybase does not support setting explicit values for identity columns\" )\n\tpublic void testIdentityOrAssignedIdStateless(SessionFactoryScope scope) {\n\t\t// on execution generation\n\t\tscope.inStatelessTransaction( session -> session.insert( new AssignedEntity( \"stateless_identity\" ) ) );\n\t\tscope.inStatelessSession( session -> assertThat( session.createQuery(\n\t\t\t\t\"from AssignedEntity where name = :name\",\n\t\t\t\tAssignedEntity.class\n\t\t).setParameter( \"name\", \"stateless_identity\" ).getSingleResult().getId() ).isNotEqualTo( 23L ) );\n\t\t// before execution generation\n\t\tscope.inStatelessTransaction( session -> session.insert( new AssignedEntity( 23L, \"stateless_assigned\" ) ) );\n\t\tscope.inStatelessSession( session -> assertThat( session.createQuery(\n\t\t\t\t\"from AssignedEntity where name = :name\",\n\t\t\t\tAssignedEntity.class\n\t\t).setParameter( \"name\", \"stateless_assigned\" ).getSingleResult().getId() ).isEqualTo( 23L ) );\n\t}\n\n\t@Test\n\t@SkipForDialect( dialectClass = SQLServerDialect.class, reason = \"SQLServer does not support setting explicit values for identity columns\" )\n\t@SkipForDialect( dialectClass = OracleDialect.class, reason = \"Oracle does not support setting explicit values for identity columns\" )\n\t@SkipForDialect( dialectClass = SybaseASEDialect.class, reason = \"Sybase does not support setting explicit values for identity columns\" )\n\tpublic void testIdentityOrRandomId(SessionFactoryScope scope) {\n\t\t// on execution generation\n\t\tscope.inTransaction( session -> session.persist( new RandomEntity( \"identity\" ) ) );\n\t\tscope.inSession( session -> assertThat( session.createQuery(\n\t\t\t\t\"from RandomEntity where name = :name\",\n\t\t\t\tRandomEntity.class\n\t\t).setParameter( \"name\", \"identity\" ).getSingleResult().getId() ).isLessThan( 100L ) );\n\t\t// before execution generation\n\t\tscope.inTransaction( session -> session.persist( new RandomEntity( \"random\" ) ) );\n\t\tscope.inSession( session -> assertThat( session.createQuery(\n\t\t\t\t\"from RandomEntity where name = :name\",\n\t\t\t\tRandomEntity.class\n\t\t).setParameter( \"name\", \"random\" ).getSingleResult().getId() ).isGreaterThanOrEqualTo( 100L ) );\n\t}\n\n\t@Test\n\tpublic void testGeneratedPropInsert(SessionFactoryScope scope) {\n\t\t// on execution generation\n\t\tscope.inTransaction( session -> session.persist( new StringGeneratedEntity( 1L, \"literal\" ) ) );\n\t\tscope.inSession( session -> assertThat(\n\t\t\t\tsession.find( StringGeneratedEntity.class, 1L ).getGeneratedProp()\n\t\t).startsWith( \"literal\" ) );\n\t\t// before execution generation\n\t\tscope.inTransaction( session -> session.persist( new StringGeneratedEntity( 2L, \"generated\" ) ) );\n\t\tscope.inSession( session -> assertThat(\n\t\t\t\tsession.find( StringGeneratedEntity.class, 2L ).getGeneratedProp()\n\t\t).startsWith( \"generated\" ) );\n\t}\n\n\t@Test\n\tpublic void testGeneratedPropUpdate(SessionFactoryScope scope) {\n\t\t// on execution generation\n\t\tfinal int literalCount = scope.fromTransaction( session -> {\n\t\t\tfinal StringGeneratedEntity entity = new StringGeneratedEntity( 3L, \"literal_inserted\" );\n\t\t\tsession.persist( entity );\n\t\t\tsession.flush();\n\t\t\tassertThat( entity.getGeneratedProp() ).startsWith( \"literal\" );\n\t\t\tentity.setName( \"literal_updated\" );\n\t\t\treturn Integer.parseInt( entity.getGeneratedProp().split( \"_\" )[1] );\n\t\t} );\n\t\tscope.inSession( session -> {\n\t\t\tfinal StringGeneratedEntity entity = session.find( StringGeneratedEntity.class, 3L );\n\t\t\tfinal String generatedProp = entity.getGeneratedProp();\n\t\t\tassertThat( generatedProp ).startsWith( \"literal\" );\n\t\t\tassertThat( Integer.parseInt( generatedProp.split( \"_\" )[1] ) ).isGreaterThan( literalCount );\n\t\t} );\n\t\t// before execution generation\n\t\tfinal int generatedCount = scope.fromTransaction( session -> {\n\t\t\tfinal StringGeneratedEntity entity = new StringGeneratedEntity( 4L, \"generated_inserted\" );\n\t\t\tsession.persist( entity );\n\t\t\tsession.flush();\n\t\t\tassertThat( entity.getGeneratedProp() ).startsWith( \"generated\" );\n\t\t\tentity.setName( \"generated_updated\" );\n\t\t\treturn Integer.parseInt( entity.getGeneratedProp().split( \"_\" )[1] );\n\t\t} );\n\t\tscope.inSession( session -> {\n\t\t\tfinal StringGeneratedEntity entity = session.find( StringGeneratedEntity.class, 4L );\n\t\t\tfinal String generatedProp = entity.getGeneratedProp();\n\t\t\tassertThat( generatedProp ).startsWith( \"generated\" );\n\t\t\tassertThat( Integer.parseInt( generatedProp.split( \"_\" )[1] ) ).isGreaterThan( generatedCount );\n\t\t} );\n\t}\n\n\t@Entity( name = \"AssignedEntity\" )\n\tpublic static class AssignedEntity {\n\t\t@Id\n\t\t@GeneratedValue( generator = \"identity_or_assigned\" )\n\t\t@GenericGenerator( name = \"identity_or_assigned\", type = IdentityOrAssignedGenerator.class )\n\t\tprivate Long id;\n\n\t\tprivate String name;\n\n\t\tpublic AssignedEntity() {\n\t\t}\n\n\t\tpublic AssignedEntity(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic AssignedEntity(Long id, String name) {\n\t\t\tthis.id = id;\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic Long getId() {\n\t\t\treturn id;\n\t\t}\n\t}\n\n\t@Entity( name = \"RandomEntity\" )\n\tpublic static class RandomEntity {\n\t\t@Id\n\t\t@GeneratedValue( generator = \"identity_or_random\" )\n\t\t@GenericGenerator( name = \"identity_or_random\", type = IdentityOrRandomGenerator.class )\n\t\tprivate Long id;\n\n\t\tprivate String name;\n\n\t\tpublic RandomEntity() {\n\t\t}\n\n\t\tpublic RandomEntity(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic Long getId() {\n\t\t\treturn id;\n\t\t}\n\n\t\tpublic String getName() {\n\t\t\treturn name;\n\t\t}\n\t}\n\n\t@ValueGenerationType( generatedBy = LiteralOrGeneratedStringGenerator.class )\n\t@Retention( RUNTIME )\n\t@Target( { FIELD, METHOD } )\n\tpublic @interface GeneratedString {\n\t\t/**\n\t\t * Specifies how the timestamp is generated. By default, it is generated\n\t\t * in memory, which saves a round trip to the database.\n\t\t */\n\t\tSourceType source() default SourceType.VM;\n\t}\n\n\n\t@Entity( name = \"StringGeneratedEntity\" )\n\tpublic static class StringGeneratedEntity {\n\t\t@Id\n\t\tprivate Long id;\n\n\t\tprivate String name;\n\n\t\t@GeneratedString\n\t\tprivate String generatedProp;\n\n\t\tpublic StringGeneratedEntity() {\n\t\t}\n\n\t\tpublic StringGeneratedEntity(Long id, String name) {\n\t\t\tthis.id = id;\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic String getName() {\n\t\t\treturn name;\n\t\t}\n\n\t\tpublic void setName(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic String getGeneratedProp() {\n\t\t\treturn generatedProp;\n\t\t}\n\t}\n\n\tpublic static class IdentityOrAssignedGenerator extends IdentityGenerator implements IdentifierGenerator {\n\t\t@Override\n\t\tpublic Object generate(SharedSessionContractImplementor session, Object object) {\n\t\t\tfinal EntityPersister entityPersister = session.getEntityPersister( null, object );\n\t\t\treturn entityPersister.getIdentifier( object, session );\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean generatedOnExecution() {\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean generatedOnExecution(Object owner, SharedSessionContractImplementor session) {\n\t\t\treturn generate( session, owner, null, null ) == null;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean allowAssignedIdentifiers() {\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic EnumSet<EventType> getEventTypes() {\n\t\t\treturn INSERT_ONLY;\n\t\t}\n\n\t\t@Override\n\t\tpublic void configure(Type type, Properties params, ServiceRegistry serviceRegistry) {\n\t\t}\n\t}\n\n\tpublic static class IdentityOrRandomGenerator extends IdentityGenerator implements BeforeExecutionGenerator {\n\t\t@Override\n\t\tpublic Object generate(\n\t\t\t\tSharedSessionContractImplementor session,\n\t\t\t\tObject owner,\n\t\t\t\tObject currentValue,\n\t\t\t\tEventType eventType) {\n\t\t\treturn ThreadLocalRandom.current().nextLong( 100, 1_000 );\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean generatedOnExecution() {\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean generatedOnExecution(Object owner, SharedSessionContractImplementor session) {\n\t\t\treturn !( (RandomEntity) owner ).getName().contains( \"random\" );\n\t\t}\n\t}\n\n\tpublic static class LiteralOrGeneratedStringGenerator implements OnExecutionGenerator, BeforeExecutionGenerator {\n\t\tprivate int count;\n\n\t\tpublic LiteralOrGeneratedStringGenerator() {\n\t\t\tcount = 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object generate(\n\t\t\t\tSharedSessionContractImplementor session,\n\t\t\t\tObject owner,\n\t\t\t\tObject currentValue,\n\t\t\t\tEventType eventType) {\n\t\t\treturn \"generated_\" + count++;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean generatedOnExecution() {\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean generatedOnExecution(Object owner, SharedSessionContractImplementor session) {\n\t\t\treturn !( (StringGeneratedEntity) owner ).getName().contains( \"generated\" );\n\t\t}\n\n\t\t@Override\n\t\tpublic EnumSet<EventType> getEventTypes() {\n\t\t\treturn EventTypeSets.ALL;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean referenceColumnsInSql(Dialect dialect) {\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean writePropertyValue() {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic String[] getReferencedColumnValues(Dialect dialect) {\n\t\t\treturn new String[] { \"'literal_\" + count++ + \"'\" };\n\t\t}\n\t}\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprotected createSettings() : Map<String,Object> extracted from private init() : void in class org.hibernate.orm.test.multitenancy.AbstractMultiTenancyTest",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/multitenancy/AbstractMultiTenancyTest.java",
                "startLine": 67,
                "endLine": 77,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/multitenancy/AbstractMultiTenancyTest.java",
                "startLine": 67,
                "endLine": 71,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/multitenancy/AbstractMultiTenancyTest.java",
                "startLine": 73,
                "endLine": 79,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private void init() {\n\t\tregisterConnectionProvider(FRONT_END_TENANT);\n\t\tregisterConnectionProvider(BACK_END_TENANT);\n\n\t\tMap<String, Object> settings = new HashMap<>();\n\n\t\tsettings.put(AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER,\n\t\t\tnew ConfigurableMultiTenantConnectionProvider(connectionProviderMap));\n\n\t\tsessionFactory = sessionFactory(settings);\n\t}",
        "filePathBefore": "hibernate-core/src/test/java/org/hibernate/orm/test/multitenancy/AbstractMultiTenancyTest.java",
        "isPureRefactoring": true,
        "commitId": "7c315fdbfa45019322e2be4701d6555db886ace7",
        "packageNameBefore": "org.hibernate.orm.test.multitenancy",
        "classNameBefore": "org.hibernate.orm.test.multitenancy.AbstractMultiTenancyTest",
        "methodNameBefore": "org.hibernate.orm.test.multitenancy.AbstractMultiTenancyTest#init",
        "invokedMethod": "methodSignature: org.hibernate.orm.test.multitenancy.AbstractMultiTenancyTest#registerConnectionProvider\n methodBody: protected void registerConnectionProvider(String tenantIdentifier) {\nProperties properties=properties();\nproperties.put(Environment.URL,tenantUrl(properties.getProperty(Environment.URL),tenantIdentifier));\nDriverManagerConnectionProviderImpl connectionProvider=new DriverManagerConnectionProviderImpl();\nconnectionProvider.configure(PropertiesHelper.map(properties));\nconnectionProviderMap.put(tenantIdentifier,connectionProvider);\n}\nmethodSignature: org.hibernate.orm.test.multitenancy.AbstractMultiTenancyTest#sessionFactory\n methodBody: protected SessionFactory sessionFactory(Map<String, Object> settings) {\nServiceRegistryImplementor serviceRegistry=(ServiceRegistryImplementor)ServiceRegistryUtil.serviceRegistryBuilder().applySettings(settings).build();\nMetadataSources metadataSources=new MetadataSources(serviceRegistry);\nfor(Class annotatedClasses: getAnnotatedClasses()){metadataSources.addAnnotatedClass(annotatedClasses);\n}Metadata metadata=metadataSources.buildMetadata();\nHibernateSchemaManagementTool tool=new HibernateSchemaManagementTool();\ntool.injectServices(serviceRegistry);\nnew SchemaDropperImpl(serviceRegistry).doDrop(metadata,serviceRegistry,settings,true,new GenerationTargetToDatabase(new DdlTransactionIsolatorTestingImpl(serviceRegistry,connectionProviderMap.get(FRONT_END_TENANT))),new GenerationTargetToDatabase(new DdlTransactionIsolatorTestingImpl(serviceRegistry,connectionProviderMap.get(BACK_END_TENANT))));\nnew SchemaCreatorImpl(serviceRegistry).doCreation(metadata,serviceRegistry,settings,true,new GenerationTargetToDatabase(new DdlTransactionIsolatorTestingImpl(serviceRegistry,connectionProviderMap.get(FRONT_END_TENANT))),new GenerationTargetToDatabase(new DdlTransactionIsolatorTestingImpl(serviceRegistry,connectionProviderMap.get(BACK_END_TENANT))));\nfinal SessionFactoryBuilder sessionFactoryBuilder=metadata.getSessionFactoryBuilder();\nreturn sessionFactoryBuilder.build();\n}",
        "classSignatureBefore": "public abstract class AbstractMultiTenancyTest extends BaseUnitTestCase ",
        "methodNameBeforeSet": [
            "org.hibernate.orm.test.multitenancy.AbstractMultiTenancyTest#init"
        ],
        "classNameBeforeSet": [
            "org.hibernate.orm.test.multitenancy.AbstractMultiTenancyTest"
        ],
        "classSignatureBeforeSet": [
            "public abstract class AbstractMultiTenancyTest extends BaseUnitTestCase "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "",
                "description": "Argument replaced with return expression - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.orm.test.multitenancy;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.function.Consumer;\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.Id;\n\nimport org.hibernate.Session;\nimport org.hibernate.SessionException;\nimport org.hibernate.SessionFactory;\nimport org.hibernate.Transaction;\nimport org.hibernate.boot.Metadata;\nimport org.hibernate.boot.MetadataSources;\nimport org.hibernate.boot.SessionFactoryBuilder;\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.cfg.Environment;\nimport org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl;\nimport org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;\nimport org.hibernate.internal.util.PropertiesHelper;\nimport org.hibernate.query.Query;\nimport org.hibernate.service.spi.ServiceRegistryImplementor;\nimport org.hibernate.service.spi.Stoppable;\nimport org.hibernate.tool.schema.internal.HibernateSchemaManagementTool;\nimport org.hibernate.tool.schema.internal.SchemaCreatorImpl;\nimport org.hibernate.tool.schema.internal.SchemaDropperImpl;\nimport org.hibernate.tool.schema.internal.exec.GenerationTargetToDatabase;\n\nimport org.hibernate.testing.AfterClassOnce;\nimport org.hibernate.testing.junit4.BaseUnitTestCase;\nimport org.hibernate.testing.orm.junit.JiraKey;\nimport org.hibernate.testing.util.ServiceRegistryUtil;\n\nimport org.hibernate.orm.test.util.DdlTransactionIsolatorTestingImpl;\n\nimport org.junit.After;\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\n\n/**\n * @author Vlad Mihalcea\n */\npublic abstract class AbstractMultiTenancyTest extends BaseUnitTestCase {\n\n\tprotected static final String FRONT_END_TENANT = \"front_end\";\n\tprotected static final String BACK_END_TENANT = \"back_end\";\n\n\tprivate Map<String, ConnectionProvider> connectionProviderMap = new HashMap<>();\n\n\tprivate SessionFactory sessionFactory;\n\n\tpublic AbstractMultiTenancyTest() {\n\t\tinit();\n\t}\n\n\t//tag::multitenacy-hibernate-MultiTenantConnectionProvider-example[]\n\tprivate void init() {\n\t\tregisterConnectionProvider(FRONT_END_TENANT);\n\t\tregisterConnectionProvider(BACK_END_TENANT);\n\n\t\tMap<String, Object> settings = new HashMap<>();\n\n\t\tsettings.put(AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER,\n\t\t\tnew ConfigurableMultiTenantConnectionProvider(connectionProviderMap));\n\n\t\tsessionFactory = sessionFactory(settings);\n\t}\n\t//end::multitenacy-hibernate-MultiTenantConnectionProvider-example[]\n\n\t@AfterClassOnce\n\tpublic void destroy() {\n\t\tsessionFactory.close();\n\t\tfor (ConnectionProvider connectionProvider : connectionProviderMap.values()) {\n\t\t\tif (connectionProvider instanceof Stoppable) {\n\t\t\t\t((Stoppable) connectionProvider).stop();\n\t\t\t}\n\t\t}\n\t}\n\n\t@After\n\tpublic void cleanup() {\n\t\tdoInSession(FRONT_END_TENANT, session -> session.createMutationQuery( \"delete from Person\" ).executeUpdate() );\n\t\tdoInSession(BACK_END_TENANT, session -> session.createMutationQuery( \"delete from Person\" ).executeUpdate() );\n\t}\n\n\t//tag::multitenacy-hibernate-MultiTenantConnectionProvider-example[]\n\n\tprotected void registerConnectionProvider(String tenantIdentifier) {\n\t\tProperties properties = properties();\n\t\tproperties.put(Environment.URL,\n\t\t\ttenantUrl(properties.getProperty(Environment.URL), tenantIdentifier));\n\n\t\tDriverManagerConnectionProviderImpl connectionProvider =\n\t\t\tnew DriverManagerConnectionProviderImpl();\n\t\tconnectionProvider.configure( PropertiesHelper.map(properties) );\n\t\tconnectionProviderMap.put(tenantIdentifier, connectionProvider);\n\t}\n\t//end::multitenacy-hibernate-MultiTenantConnectionProvider-example[]\n\n\t@Test\n\tpublic void testBasicExpectedBehavior() {\n\n\t\t//tag::multitenacy-multitenacy-hibernate-same-entity-example[]\n\t\tdoInSession(FRONT_END_TENANT, session -> {\n\t\t\tPerson person = new Person();\n\t\t\tperson.setId(1L);\n\t\t\tperson.setName(\"John Doe\");\n\t\t\tsession.persist(person);\n\t\t});\n\n\t\tdoInSession(BACK_END_TENANT, session -> {\n\t\t\tPerson person = new Person();\n\t\t\tperson.setId(1L);\n\t\t\tperson.setName(\"John Doe\");\n\t\t\tsession.persist(person);\n\t\t});\n\t\t//end::multitenacy-multitenacy-hibernate-same-entity-example[]\n\t}\n\n\t@Test\n\t@JiraKey( value = \"HHH-17972\")\n\tpublic void testChangeTenantWithoutConnectionReuse() {\n\t\tPerson person = new Person();\n\t\tperson.setId( 1L );\n\t\tperson.setName( \"John Doe\" );\n\t\tPerson person2 = new Person();\n\t\tperson2.setId( 2L );\n\t\tperson2.setName( \"Jane Doe\" );\n\n\t\tTransaction t;\n\t\tSession session = null;\n\t\tSession newSession = null;\n\t\ttry {\n\t\t\tsession = sessionFactory.withOptions().tenantIdentifier( FRONT_END_TENANT ).openSession();\n\t\t\tt = session.beginTransaction();\n\t\t\tsession.persist( person );\n\t\t\tt.commit();\n\n\t\t\tQuery<Person> sessionQuery = session.createQuery( \"from Person\", Person.class );\n\t\t\tassertEquals( 1, sessionQuery.getResultList().size() );\n\t\t\tassertEquals( \"John Doe\", sessionQuery.getResultList().get( 0 ).getName() );\n\n\t\t\tnewSession = session.sessionWithOptions().tenantIdentifier( BACK_END_TENANT ).openSession();\n\t\t\tt = newSession.beginTransaction();\n\t\t\tnewSession.persist( person2 );\n\t\t\tt.commit();\n\n\t\t\tQuery<Person> newSessionQuery = newSession.createQuery( \"from Person\", Person.class );\n\t\t\tassertEquals( 1, newSessionQuery.getResultList().size() );\n\t\t\tassertEquals( \"Jane Doe\", newSessionQuery.getResultList().get( 0 ).getName() );\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.close();\n\t\t\t}\n\t\t\tif (newSession != null) {\n\t\t\t\tnewSession.close();\n\t\t\t}\n\t\t}\n\t}\n\n\t@Test\n\t@JiraKey( value = \"HHH-17972\")\n\tpublic void testChangeTenantWithConnectionReuse() {\n\t\ttry (Session session = sessionFactory.withOptions().tenantIdentifier( FRONT_END_TENANT ).openSession()) {\n\t\t\tAssert.assertThrows( \"Cannot redefine the tenant identifier on a child session if the connection is reused\",\n\t\t\t\t\t\t\t\tSessionException.class,\n\t\t\t\t\t\t\t\t() -> session.sessionWithOptions().tenantIdentifier( BACK_END_TENANT ).connection().openSession()\n\t\t\t);\n\t\t\tAssert.assertThrows( \"Cannot redefine the tenant identifier on a child session if the connection is reused\",\n\t\t\t\t\t\t\t\tSessionException.class,\n\t\t\t\t\t\t\t\t() -> session.sessionWithOptions().connection().tenantIdentifier( BACK_END_TENANT ).openSession()\n\t\t\t);\n\t\t}\n\t}\n\n\tprotected Properties properties() {\n\t\tProperties properties = new Properties();\n\t\tURL propertiesURL = Thread.currentThread().getContextClassLoader().getResource(\"hibernate.properties\");\n\t\ttry(FileInputStream inputStream = new FileInputStream(propertiesURL.getFile())) {\n\t\t\tproperties.load(inputStream);\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\tthrow new IllegalArgumentException(e);\n\t\t}\n\t\treturn properties;\n\t}\n\n\tprotected abstract String tenantUrl(String originalUrl, String tenantIdentifier);\n\n\tprotected SessionFactory sessionFactory(Map<String, Object> settings) {\n\n\t\tServiceRegistryImplementor serviceRegistry = (ServiceRegistryImplementor) ServiceRegistryUtil.serviceRegistryBuilder()\n\t\t\t.applySettings(settings)\n\t\t\t.build();\n\n\t\tMetadataSources metadataSources = new MetadataSources(serviceRegistry);\n\t\tfor(Class annotatedClasses : getAnnotatedClasses()) {\n\t\t\tmetadataSources.addAnnotatedClass(annotatedClasses);\n\t\t}\n\n\t\tMetadata metadata = metadataSources.buildMetadata();\n\n\t\tHibernateSchemaManagementTool tool = new HibernateSchemaManagementTool();\n\t\ttool.injectServices(serviceRegistry);\n\n\t\tnew SchemaDropperImpl( serviceRegistry ).doDrop(\n\t\t\t\tmetadata,\n\t\t\t\tserviceRegistry,\n\t\t\t\tsettings,\n\t\t\t\ttrue,\n\t\t\t\tnew GenerationTargetToDatabase(\n\t\t\t\t\t\tnew DdlTransactionIsolatorTestingImpl(\n\t\t\t\t\t\t\t\tserviceRegistry,\n\t\t\t\t\t\t\t\tconnectionProviderMap.get( FRONT_END_TENANT )\n\t\t\t\t\t\t)\n\t\t\t\t),\n\t\t\t\tnew GenerationTargetToDatabase(\n\t\t\t\t\t\tnew DdlTransactionIsolatorTestingImpl(\n\t\t\t\t\t\t\t\tserviceRegistry,\n\t\t\t\t\t\t\t\tconnectionProviderMap.get( BACK_END_TENANT )\n\t\t\t\t\t\t)\n\t\t\t\t)\n\t\t);\n\n\t\tnew SchemaCreatorImpl( serviceRegistry ).doCreation(\n\t\t\t\tmetadata,\n\t\t\t\tserviceRegistry,\n\t\t\t\tsettings,\n\t\t\t\ttrue,\n\t\t\t\tnew GenerationTargetToDatabase(\n\t\t\t\t\t\tnew DdlTransactionIsolatorTestingImpl(\n\t\t\t\t\t\t\t\tserviceRegistry,\n\t\t\t\t\t\t\t\tconnectionProviderMap.get( FRONT_END_TENANT )\n\t\t\t\t\t\t)\n\t\t\t\t),\n\t\t\t\tnew GenerationTargetToDatabase(\n\t\t\t\t\t\tnew DdlTransactionIsolatorTestingImpl(\n\t\t\t\t\t\t\t\tserviceRegistry,\n\t\t\t\t\t\t\t\tconnectionProviderMap.get( BACK_END_TENANT )\n\t\t\t\t\t\t)\n\t\t\t\t)\n\t\t);\n\n\t\tfinal SessionFactoryBuilder sessionFactoryBuilder = metadata.getSessionFactoryBuilder();\n\t\treturn sessionFactoryBuilder.build();\n\t}\n\n\tprotected Class<?>[] getAnnotatedClasses() {\n\t\treturn new Class<?>[] {\n\t\t\tPerson.class\n\t\t};\n\t}\n\n\t//tag::multitenacy-hibernate-session-example[]\n\tprivate void doInSession(String tenant, Consumer<Session> function) {\n\t\tSession session = null;\n\t\tTransaction txn = null;\n\t\ttry {\n\t\t\tsession = sessionFactory\n\t\t\t\t.withOptions()\n\t\t\t\t.tenantIdentifier(tenant)\n\t\t\t\t.openSession();\n\t\t\ttxn = session.getTransaction();\n\t\t\ttxn.begin();\n\t\t\tfunction.accept(session);\n\t\t\ttxn.commit();\n\t\t} catch (Throwable e) {\n\t\t\tif (txn != null) txn.rollback();\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.close();\n\t\t\t}\n\t\t}\n\t}\n\t//end::multitenacy-hibernate-session-example[]\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person {\n\n\t\t@Id\n\t\tprivate Long id;\n\n\t\tprivate String name;\n\n\t\tpublic Long getId() {\n\t\t\treturn id;\n\t\t}\n\n\t\tpublic void setId(Long id) {\n\t\t\tthis.id = id;\n\t\t}\n\n\t\tpublic String getName() {\n\t\t\treturn name;\n\t\t}\n\n\t\tpublic void setName(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/test/java/org/hibernate/orm/test/multitenancy/AbstractMultiTenancyTest.java",
        "sourceCodeAfterForWhole": "/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.orm.test.multitenancy;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.function.Consumer;\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.Id;\n\nimport org.hibernate.Session;\nimport org.hibernate.SessionException;\nimport org.hibernate.SessionFactory;\nimport org.hibernate.Transaction;\nimport org.hibernate.boot.Metadata;\nimport org.hibernate.boot.MetadataSources;\nimport org.hibernate.boot.SessionFactoryBuilder;\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.cfg.Environment;\nimport org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl;\nimport org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;\nimport org.hibernate.internal.util.PropertiesHelper;\nimport org.hibernate.query.Query;\nimport org.hibernate.service.spi.ServiceRegistryImplementor;\nimport org.hibernate.service.spi.Stoppable;\nimport org.hibernate.tool.schema.internal.HibernateSchemaManagementTool;\nimport org.hibernate.tool.schema.internal.SchemaCreatorImpl;\nimport org.hibernate.tool.schema.internal.SchemaDropperImpl;\nimport org.hibernate.tool.schema.internal.exec.GenerationTargetToDatabase;\n\nimport org.hibernate.testing.AfterClassOnce;\nimport org.hibernate.testing.junit4.BaseUnitTestCase;\nimport org.hibernate.testing.orm.junit.JiraKey;\nimport org.hibernate.testing.util.ServiceRegistryUtil;\n\nimport org.hibernate.orm.test.util.DdlTransactionIsolatorTestingImpl;\n\nimport org.junit.After;\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\n\n/**\n * @author Vlad Mihalcea\n */\npublic abstract class AbstractMultiTenancyTest extends BaseUnitTestCase {\n\n\tprotected static final String FRONT_END_TENANT = \"front_end\";\n\tprotected static final String BACK_END_TENANT = \"back_end\";\n\n\tprotected Map<String, ConnectionProvider> connectionProviderMap = new HashMap<>();\n\n\tprotected SessionFactory sessionFactory;\n\n\tpublic AbstractMultiTenancyTest() {\n\t\tinit();\n\t}\n\n\t//tag::multitenacy-hibernate-MultiTenantConnectionProvider-example[]\n\tprivate void init() {\n\t\tregisterConnectionProvider(FRONT_END_TENANT);\n\t\tregisterConnectionProvider(BACK_END_TENANT);\n\t\tsessionFactory = sessionFactory(createSettings());\n\t}\n\n\tprotected Map<String, Object> createSettings() {\n\t\tMap<String, Object> settings = new HashMap<>();\n\n\t\tsettings.put(AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER,\n\t\t\t\tnew ConfigurableMultiTenantConnectionProvider(connectionProviderMap));\n\t\treturn settings;\n\t}\n\t//end::multitenacy-hibernate-MultiTenantConnectionProvider-example[]\n\n\t@AfterClassOnce\n\tpublic void destroy() {\n\t\tsessionFactory.close();\n\t\tfor (ConnectionProvider connectionProvider : connectionProviderMap.values()) {\n\t\t\tif (connectionProvider instanceof Stoppable) {\n\t\t\t\t((Stoppable) connectionProvider).stop();\n\t\t\t}\n\t\t}\n\t}\n\n\t@After\n\tpublic void cleanup() {\n\t\tdoInSession(FRONT_END_TENANT, session -> session.createMutationQuery( \"delete from Person\" ).executeUpdate() );\n\t\tdoInSession(BACK_END_TENANT, session -> session.createMutationQuery( \"delete from Person\" ).executeUpdate() );\n\t}\n\n\t//tag::multitenacy-hibernate-MultiTenantConnectionProvider-example[]\n\n\tprotected void registerConnectionProvider(String tenantIdentifier) {\n\t\tProperties properties = properties();\n\t\tproperties.put(Environment.URL,\n\t\t\ttenantUrl(properties.getProperty(Environment.URL), tenantIdentifier));\n\n\t\tDriverManagerConnectionProviderImpl connectionProvider =\n\t\t\tnew DriverManagerConnectionProviderImpl();\n\t\tconnectionProvider.configure( PropertiesHelper.map(properties) );\n\t\tconnectionProviderMap.put(tenantIdentifier, connectionProvider);\n\t}\n\t//end::multitenacy-hibernate-MultiTenantConnectionProvider-example[]\n\n\t@Test\n\tpublic void testBasicExpectedBehavior() {\n\n\t\t//tag::multitenacy-multitenacy-hibernate-same-entity-example[]\n\t\tdoInSession(FRONT_END_TENANT, session -> {\n\t\t\tPerson person = new Person();\n\t\t\tperson.setId(1L);\n\t\t\tperson.setName(\"John Doe\");\n\t\t\tsession.persist(person);\n\t\t});\n\n\t\tdoInSession(BACK_END_TENANT, session -> {\n\t\t\tPerson person = new Person();\n\t\t\tperson.setId(1L);\n\t\t\tperson.setName(\"John Doe\");\n\t\t\tsession.persist(person);\n\t\t});\n\t\t//end::multitenacy-multitenacy-hibernate-same-entity-example[]\n\t}\n\n\t@Test\n\t@JiraKey( value = \"HHH-17972\")\n\tpublic void testChangeTenantWithoutConnectionReuse() {\n\t\tPerson person = new Person();\n\t\tperson.setId( 1L );\n\t\tperson.setName( \"John Doe\" );\n\t\tPerson person2 = new Person();\n\t\tperson2.setId( 2L );\n\t\tperson2.setName( \"Jane Doe\" );\n\n\t\tTransaction t;\n\t\tSession session = null;\n\t\tSession newSession = null;\n\t\ttry {\n\t\t\tsession = sessionFactory.withOptions().tenantIdentifier( FRONT_END_TENANT ).openSession();\n\t\t\tt = session.beginTransaction();\n\t\t\tsession.persist( person );\n\t\t\tt.commit();\n\n\t\t\tQuery<Person> sessionQuery = session.createQuery( \"from Person\", Person.class );\n\t\t\tassertEquals( 1, sessionQuery.getResultList().size() );\n\t\t\tassertEquals( \"John Doe\", sessionQuery.getResultList().get( 0 ).getName() );\n\n\t\t\tnewSession = session.sessionWithOptions().tenantIdentifier( BACK_END_TENANT ).openSession();\n\t\t\tt = newSession.beginTransaction();\n\t\t\tnewSession.persist( person2 );\n\t\t\tt.commit();\n\n\t\t\tQuery<Person> newSessionQuery = newSession.createQuery( \"from Person\", Person.class );\n\t\t\tassertEquals( 1, newSessionQuery.getResultList().size() );\n\t\t\tassertEquals( \"Jane Doe\", newSessionQuery.getResultList().get( 0 ).getName() );\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.close();\n\t\t\t}\n\t\t\tif (newSession != null) {\n\t\t\t\tnewSession.close();\n\t\t\t}\n\t\t}\n\t}\n\n\t@Test\n\t@JiraKey( value = \"HHH-17972\")\n\tpublic void testChangeTenantWithConnectionReuse() {\n\t\ttry (Session session = sessionFactory.withOptions().tenantIdentifier( FRONT_END_TENANT ).openSession()) {\n\t\t\tAssert.assertThrows( \"Cannot redefine the tenant identifier on a child session if the connection is reused\",\n\t\t\t\t\t\t\t\tSessionException.class,\n\t\t\t\t\t\t\t\t() -> session.sessionWithOptions().tenantIdentifier( BACK_END_TENANT ).connection().openSession()\n\t\t\t);\n\t\t\tAssert.assertThrows( \"Cannot redefine the tenant identifier on a child session if the connection is reused\",\n\t\t\t\t\t\t\t\tSessionException.class,\n\t\t\t\t\t\t\t\t() -> session.sessionWithOptions().connection().tenantIdentifier( BACK_END_TENANT ).openSession()\n\t\t\t);\n\t\t}\n\t}\n\n\tprotected Properties properties() {\n\t\tProperties properties = new Properties();\n\t\tURL propertiesURL = Thread.currentThread().getContextClassLoader().getResource(\"hibernate.properties\");\n\t\ttry(FileInputStream inputStream = new FileInputStream(propertiesURL.getFile())) {\n\t\t\tproperties.load(inputStream);\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\tthrow new IllegalArgumentException(e);\n\t\t}\n\t\treturn properties;\n\t}\n\n\tprotected abstract String tenantUrl(String originalUrl, String tenantIdentifier);\n\n\tprotected SessionFactory sessionFactory(Map<String, Object> settings) {\n\n\t\tServiceRegistryImplementor serviceRegistry = (ServiceRegistryImplementor) ServiceRegistryUtil.serviceRegistryBuilder()\n\t\t\t.applySettings(settings)\n\t\t\t.build();\n\n\t\tMetadataSources metadataSources = new MetadataSources(serviceRegistry);\n\t\tfor(Class annotatedClasses : getAnnotatedClasses()) {\n\t\t\tmetadataSources.addAnnotatedClass(annotatedClasses);\n\t\t}\n\n\t\tMetadata metadata = metadataSources.buildMetadata();\n\n\t\tHibernateSchemaManagementTool tool = new HibernateSchemaManagementTool();\n\t\ttool.injectServices(serviceRegistry);\n\n\t\tnew SchemaDropperImpl( serviceRegistry ).doDrop(\n\t\t\t\tmetadata,\n\t\t\t\tserviceRegistry,\n\t\t\t\tsettings,\n\t\t\t\ttrue,\n\t\t\t\tnew GenerationTargetToDatabase(\n\t\t\t\t\t\tnew DdlTransactionIsolatorTestingImpl(\n\t\t\t\t\t\t\t\tserviceRegistry,\n\t\t\t\t\t\t\t\tconnectionProviderMap.get( FRONT_END_TENANT )\n\t\t\t\t\t\t)\n\t\t\t\t),\n\t\t\t\tnew GenerationTargetToDatabase(\n\t\t\t\t\t\tnew DdlTransactionIsolatorTestingImpl(\n\t\t\t\t\t\t\t\tserviceRegistry,\n\t\t\t\t\t\t\t\tconnectionProviderMap.get( BACK_END_TENANT )\n\t\t\t\t\t\t)\n\t\t\t\t)\n\t\t);\n\n\t\tnew SchemaCreatorImpl( serviceRegistry ).doCreation(\n\t\t\t\tmetadata,\n\t\t\t\tserviceRegistry,\n\t\t\t\tsettings,\n\t\t\t\ttrue,\n\t\t\t\tnew GenerationTargetToDatabase(\n\t\t\t\t\t\tnew DdlTransactionIsolatorTestingImpl(\n\t\t\t\t\t\t\t\tserviceRegistry,\n\t\t\t\t\t\t\t\tconnectionProviderMap.get( FRONT_END_TENANT )\n\t\t\t\t\t\t)\n\t\t\t\t),\n\t\t\t\tnew GenerationTargetToDatabase(\n\t\t\t\t\t\tnew DdlTransactionIsolatorTestingImpl(\n\t\t\t\t\t\t\t\tserviceRegistry,\n\t\t\t\t\t\t\t\tconnectionProviderMap.get( BACK_END_TENANT )\n\t\t\t\t\t\t)\n\t\t\t\t)\n\t\t);\n\n\t\tfinal SessionFactoryBuilder sessionFactoryBuilder = metadata.getSessionFactoryBuilder();\n\t\treturn sessionFactoryBuilder.build();\n\t}\n\n\tprotected Class<?>[] getAnnotatedClasses() {\n\t\treturn new Class<?>[] {\n\t\t\tPerson.class\n\t\t};\n\t}\n\n\t//tag::multitenacy-hibernate-session-example[]\n\tprivate void doInSession(String tenant, Consumer<Session> function) {\n\t\tSession session = null;\n\t\tTransaction txn = null;\n\t\ttry {\n\t\t\tsession = sessionFactory\n\t\t\t\t.withOptions()\n\t\t\t\t.tenantIdentifier(tenant)\n\t\t\t\t.openSession();\n\t\t\ttxn = session.getTransaction();\n\t\t\ttxn.begin();\n\t\t\tfunction.accept(session);\n\t\t\ttxn.commit();\n\t\t} catch (Throwable e) {\n\t\t\tif (txn != null) txn.rollback();\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.close();\n\t\t\t}\n\t\t}\n\t}\n\t//end::multitenacy-hibernate-session-example[]\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person {\n\n\t\t@Id\n\t\tprivate Long id;\n\n\t\tprivate String name;\n\n\t\tpublic Long getId() {\n\t\t\treturn id;\n\t\t}\n\n\t\tpublic void setId(Long id) {\n\t\t\tthis.id = id;\n\t\t}\n\n\t\tpublic String getName() {\n\t\t\treturn name;\n\t\t}\n\n\t\tpublic void setName(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\t}\n\n}\n",
        "diffSourceCodeSet": [
            "protected Map<String, Object> createSettings() {\n\t\tMap<String, Object> settings = new HashMap<>();\n\n\t\tsettings.put(AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER,\n\t\t\t\tnew ConfigurableMultiTenantConnectionProvider(connectionProviderMap));\n\t\treturn settings;\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.orm.test.multitenancy.AbstractMultiTenancyTest#registerConnectionProvider\n methodBody: protected void registerConnectionProvider(String tenantIdentifier) {\nProperties properties=properties();\nproperties.put(Environment.URL,tenantUrl(properties.getProperty(Environment.URL),tenantIdentifier));\nDriverManagerConnectionProviderImpl connectionProvider=new DriverManagerConnectionProviderImpl();\nconnectionProvider.configure(PropertiesHelper.map(properties));\nconnectionProviderMap.put(tenantIdentifier,connectionProvider);\n}",
            "methodSignature: org.hibernate.orm.test.multitenancy.AbstractMultiTenancyTest#sessionFactory\n methodBody: protected SessionFactory sessionFactory(Map<String, Object> settings) {\nServiceRegistryImplementor serviceRegistry=(ServiceRegistryImplementor)ServiceRegistryUtil.serviceRegistryBuilder().applySettings(settings).build();\nMetadataSources metadataSources=new MetadataSources(serviceRegistry);\nfor(Class annotatedClasses: getAnnotatedClasses()){metadataSources.addAnnotatedClass(annotatedClasses);\n}Metadata metadata=metadataSources.buildMetadata();\nHibernateSchemaManagementTool tool=new HibernateSchemaManagementTool();\ntool.injectServices(serviceRegistry);\nnew SchemaDropperImpl(serviceRegistry).doDrop(metadata,serviceRegistry,settings,true,new GenerationTargetToDatabase(new DdlTransactionIsolatorTestingImpl(serviceRegistry,connectionProviderMap.get(FRONT_END_TENANT))),new GenerationTargetToDatabase(new DdlTransactionIsolatorTestingImpl(serviceRegistry,connectionProviderMap.get(BACK_END_TENANT))));\nnew SchemaCreatorImpl(serviceRegistry).doCreation(metadata,serviceRegistry,settings,true,new GenerationTargetToDatabase(new DdlTransactionIsolatorTestingImpl(serviceRegistry,connectionProviderMap.get(FRONT_END_TENANT))),new GenerationTargetToDatabase(new DdlTransactionIsolatorTestingImpl(serviceRegistry,connectionProviderMap.get(BACK_END_TENANT))));\nfinal SessionFactoryBuilder sessionFactoryBuilder=metadata.getSessionFactoryBuilder();\nreturn sessionFactoryBuilder.build();\n}"
        ],
        "sourceCodeAfterRefactoring": "private void init() {\n\t\tregisterConnectionProvider(FRONT_END_TENANT);\n\t\tregisterConnectionProvider(BACK_END_TENANT);\n\t\tsessionFactory = sessionFactory(createSettings());\n\t}\nprotected Map<String, Object> createSettings() {\n\t\tMap<String, Object> settings = new HashMap<>();\n\n\t\tsettings.put(AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER,\n\t\t\t\tnew ConfigurableMultiTenantConnectionProvider(connectionProviderMap));\n\t\treturn settings;\n\t}",
        "diffSourceCode": "    67: \tprivate void init() {\n    68: \t\tregisterConnectionProvider(FRONT_END_TENANT);\n    69: \t\tregisterConnectionProvider(BACK_END_TENANT);\n-   70: \n-   71: \t\tMap<String, Object> settings = new HashMap<>();\n+   70: \t\tsessionFactory = sessionFactory(createSettings());\n+   71: \t}\n    72: \n-   73: \t\tsettings.put(AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER,\n-   74: \t\t\tnew ConfigurableMultiTenantConnectionProvider(connectionProviderMap));\n+   73: \tprotected Map<String, Object> createSettings() {\n+   74: \t\tMap<String, Object> settings = new HashMap<>();\n    75: \n-   76: \t\tsessionFactory = sessionFactory(settings);\n-   77: \t}\n-   78: \t//end::multitenacy-hibernate-MultiTenantConnectionProvider-example[]\n-   79: \n+   76: \t\tsettings.put(AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER,\n+   77: \t\t\t\tnew ConfigurableMultiTenantConnectionProvider(connectionProviderMap));\n+   78: \t\treturn settings;\n+   79: \t}\n",
        "uniqueId": "7c315fdbfa45019322e2be4701d6555db886ace7_67_77_73_79_67_71",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\nprivate Map<String, Object> createSettings() {\n    Map<String, Object> settings = new HashMap<>();\n    settings.put(AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER,\n            new ConfigurableMultiTenantConnectionProvider(connectionProviderMap));\n    return settings;\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprivate void init() {\n\t\tregisterConnectionProvider(FRONT_END_TENANT);\n\t\tregisterConnectionProvider(BACK_END_TENANT);\n\n\t\tMap<String, Object> settings = new HashMap<>();\n\n\t\tsettings.put(AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER,\n\t\t\tnew ConfigurableMultiTenantConnectionProvider(connectionProviderMap));\n\n\t\tsessionFactory = sessionFactory(settings);\n\t}\n\nClass content:\n/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.orm.test.multitenancy;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.function.Consumer;\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.Id;\n\nimport org.hibernate.Session;\nimport org.hibernate.SessionException;\nimport org.hibernate.SessionFactory;\nimport org.hibernate.Transaction;\nimport org.hibernate.boot.Metadata;\nimport org.hibernate.boot.MetadataSources;\nimport org.hibernate.boot.SessionFactoryBuilder;\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.cfg.Environment;\nimport org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl;\nimport org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;\nimport org.hibernate.internal.util.PropertiesHelper;\nimport org.hibernate.query.Query;\nimport org.hibernate.service.spi.ServiceRegistryImplementor;\nimport org.hibernate.service.spi.Stoppable;\nimport org.hibernate.tool.schema.internal.HibernateSchemaManagementTool;\nimport org.hibernate.tool.schema.internal.SchemaCreatorImpl;\nimport org.hibernate.tool.schema.internal.SchemaDropperImpl;\nimport org.hibernate.tool.schema.internal.exec.GenerationTargetToDatabase;\n\nimport org.hibernate.testing.AfterClassOnce;\nimport org.hibernate.testing.junit4.BaseUnitTestCase;\nimport org.hibernate.testing.orm.junit.JiraKey;\nimport org.hibernate.testing.util.ServiceRegistryUtil;\n\nimport org.hibernate.orm.test.util.DdlTransactionIsolatorTestingImpl;\n\nimport org.junit.After;\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\n\n/**\n * @author Vlad Mihalcea\n */\npublic abstract class AbstractMultiTenancyTest extends BaseUnitTestCase {\n\n\tprotected static final String FRONT_END_TENANT = \"front_end\";\n\tprotected static final String BACK_END_TENANT = \"back_end\";\n\n\tprivate Map<String, ConnectionProvider> connectionProviderMap = new HashMap<>();\n\n\tprivate SessionFactory sessionFactory;\n\n\tpublic AbstractMultiTenancyTest() {\n\t\tinit();\n\t}\n\n\t//tag::multitenacy-hibernate-MultiTenantConnectionProvider-example[]\n\tprivate void init() {\n\t\tregisterConnectionProvider(FRONT_END_TENANT);\n\t\tregisterConnectionProvider(BACK_END_TENANT);\n\n\t\tMap<String, Object> settings = new HashMap<>();\n\n\t\tsettings.put(AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER,\n\t\t\tnew ConfigurableMultiTenantConnectionProvider(connectionProviderMap));\n\n\t\tsessionFactory = sessionFactory(settings);\n\t}\n\t//end::multitenacy-hibernate-MultiTenantConnectionProvider-example[]\n\n\t@AfterClassOnce\n\tpublic void destroy() {\n\t\tsessionFactory.close();\n\t\tfor (ConnectionProvider connectionProvider : connectionProviderMap.values()) {\n\t\t\tif (connectionProvider instanceof Stoppable) {\n\t\t\t\t((Stoppable) connectionProvider).stop();\n\t\t\t}\n\t\t}\n\t}\n\n\t@After\n\tpublic void cleanup() {\n\t\tdoInSession(FRONT_END_TENANT, session -> session.createMutationQuery( \"delete from Person\" ).executeUpdate() );\n\t\tdoInSession(BACK_END_TENANT, session -> session.createMutationQuery( \"delete from Person\" ).executeUpdate() );\n\t}\n\n\t//tag::multitenacy-hibernate-MultiTenantConnectionProvider-example[]\n\n\tprotected void registerConnectionProvider(String tenantIdentifier) {\n\t\tProperties properties = properties();\n\t\tproperties.put(Environment.URL,\n\t\t\ttenantUrl(properties.getProperty(Environment.URL), tenantIdentifier));\n\n\t\tDriverManagerConnectionProviderImpl connectionProvider =\n\t\t\tnew DriverManagerConnectionProviderImpl();\n\t\tconnectionProvider.configure( PropertiesHelper.map(properties) );\n\t\tconnectionProviderMap.put(tenantIdentifier, connectionProvider);\n\t}\n\t//end::multitenacy-hibernate-MultiTenantConnectionProvider-example[]\n\n\t@Test\n\tpublic void testBasicExpectedBehavior() {\n\n\t\t//tag::multitenacy-multitenacy-hibernate-same-entity-example[]\n\t\tdoInSession(FRONT_END_TENANT, session -> {\n\t\t\tPerson person = new Person();\n\t\t\tperson.setId(1L);\n\t\t\tperson.setName(\"John Doe\");\n\t\t\tsession.persist(person);\n\t\t});\n\n\t\tdoInSession(BACK_END_TENANT, session -> {\n\t\t\tPerson person = new Person();\n\t\t\tperson.setId(1L);\n\t\t\tperson.setName(\"John Doe\");\n\t\t\tsession.persist(person);\n\t\t});\n\t\t//end::multitenacy-multitenacy-hibernate-same-entity-example[]\n\t}\n\n\t@Test\n\t@JiraKey( value = \"HHH-17972\")\n\tpublic void testChangeTenantWithoutConnectionReuse() {\n\t\tPerson person = new Person();\n\t\tperson.setId( 1L );\n\t\tperson.setName( \"John Doe\" );\n\t\tPerson person2 = new Person();\n\t\tperson2.setId( 2L );\n\t\tperson2.setName( \"Jane Doe\" );\n\n\t\tTransaction t;\n\t\tSession session = null;\n\t\tSession newSession = null;\n\t\ttry {\n\t\t\tsession = sessionFactory.withOptions().tenantIdentifier( FRONT_END_TENANT ).openSession();\n\t\t\tt = session.beginTransaction();\n\t\t\tsession.persist( person );\n\t\t\tt.commit();\n\n\t\t\tQuery<Person> sessionQuery = session.createQuery( \"from Person\", Person.class );\n\t\t\tassertEquals( 1, sessionQuery.getResultList().size() );\n\t\t\tassertEquals( \"John Doe\", sessionQuery.getResultList().get( 0 ).getName() );\n\n\t\t\tnewSession = session.sessionWithOptions().tenantIdentifier( BACK_END_TENANT ).openSession();\n\t\t\tt = newSession.beginTransaction();\n\t\t\tnewSession.persist( person2 );\n\t\t\tt.commit();\n\n\t\t\tQuery<Person> newSessionQuery = newSession.createQuery( \"from Person\", Person.class );\n\t\t\tassertEquals( 1, newSessionQuery.getResultList().size() );\n\t\t\tassertEquals( \"Jane Doe\", newSessionQuery.getResultList().get( 0 ).getName() );\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.close();\n\t\t\t}\n\t\t\tif (newSession != null) {\n\t\t\t\tnewSession.close();\n\t\t\t}\n\t\t}\n\t}\n\n\t@Test\n\t@JiraKey( value = \"HHH-17972\")\n\tpublic void testChangeTenantWithConnectionReuse() {\n\t\ttry (Session session = sessionFactory.withOptions().tenantIdentifier( FRONT_END_TENANT ).openSession()) {\n\t\t\tAssert.assertThrows( \"Cannot redefine the tenant identifier on a child session if the connection is reused\",\n\t\t\t\t\t\t\t\tSessionException.class,\n\t\t\t\t\t\t\t\t() -> session.sessionWithOptions().tenantIdentifier( BACK_END_TENANT ).connection().openSession()\n\t\t\t);\n\t\t\tAssert.assertThrows( \"Cannot redefine the tenant identifier on a child session if the connection is reused\",\n\t\t\t\t\t\t\t\tSessionException.class,\n\t\t\t\t\t\t\t\t() -> session.sessionWithOptions().connection().tenantIdentifier( BACK_END_TENANT ).openSession()\n\t\t\t);\n\t\t}\n\t}\n\n\tprotected Properties properties() {\n\t\tProperties properties = new Properties();\n\t\tURL propertiesURL = Thread.currentThread().getContextClassLoader().getResource(\"hibernate.properties\");\n\t\ttry(FileInputStream inputStream = new FileInputStream(propertiesURL.getFile())) {\n\t\t\tproperties.load(inputStream);\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\tthrow new IllegalArgumentException(e);\n\t\t}\n\t\treturn properties;\n\t}\n\n\tprotected abstract String tenantUrl(String originalUrl, String tenantIdentifier);\n\n\tprotected SessionFactory sessionFactory(Map<String, Object> settings) {\n\n\t\tServiceRegistryImplementor serviceRegistry = (ServiceRegistryImplementor) ServiceRegistryUtil.serviceRegistryBuilder()\n\t\t\t.applySettings(settings)\n\t\t\t.build();\n\n\t\tMetadataSources metadataSources = new MetadataSources(serviceRegistry);\n\t\tfor(Class annotatedClasses : getAnnotatedClasses()) {\n\t\t\tmetadataSources.addAnnotatedClass(annotatedClasses);\n\t\t}\n\n\t\tMetadata metadata = metadataSources.buildMetadata();\n\n\t\tHibernateSchemaManagementTool tool = new HibernateSchemaManagementTool();\n\t\ttool.injectServices(serviceRegistry);\n\n\t\tnew SchemaDropperImpl( serviceRegistry ).doDrop(\n\t\t\t\tmetadata,\n\t\t\t\tserviceRegistry,\n\t\t\t\tsettings,\n\t\t\t\ttrue,\n\t\t\t\tnew GenerationTargetToDatabase(\n\t\t\t\t\t\tnew DdlTransactionIsolatorTestingImpl(\n\t\t\t\t\t\t\t\tserviceRegistry,\n\t\t\t\t\t\t\t\tconnectionProviderMap.get( FRONT_END_TENANT )\n\t\t\t\t\t\t)\n\t\t\t\t),\n\t\t\t\tnew GenerationTargetToDatabase(\n\t\t\t\t\t\tnew DdlTransactionIsolatorTestingImpl(\n\t\t\t\t\t\t\t\tserviceRegistry,\n\t\t\t\t\t\t\t\tconnectionProviderMap.get( BACK_END_TENANT )\n\t\t\t\t\t\t)\n\t\t\t\t)\n\t\t);\n\n\t\tnew SchemaCreatorImpl( serviceRegistry ).doCreation(\n\t\t\t\tmetadata,\n\t\t\t\tserviceRegistry,\n\t\t\t\tsettings,\n\t\t\t\ttrue,\n\t\t\t\tnew GenerationTargetToDatabase(\n\t\t\t\t\t\tnew DdlTransactionIsolatorTestingImpl(\n\t\t\t\t\t\t\t\tserviceRegistry,\n\t\t\t\t\t\t\t\tconnectionProviderMap.get( FRONT_END_TENANT )\n\t\t\t\t\t\t)\n\t\t\t\t),\n\t\t\t\tnew GenerationTargetToDatabase(\n\t\t\t\t\t\tnew DdlTransactionIsolatorTestingImpl(\n\t\t\t\t\t\t\t\tserviceRegistry,\n\t\t\t\t\t\t\t\tconnectionProviderMap.get( BACK_END_TENANT )\n\t\t\t\t\t\t)\n\t\t\t\t)\n\t\t);\n\n\t\tfinal SessionFactoryBuilder sessionFactoryBuilder = metadata.getSessionFactoryBuilder();\n\t\treturn sessionFactoryBuilder.build();\n\t}\n\n\tprotected Class<?>[] getAnnotatedClasses() {\n\t\treturn new Class<?>[] {\n\t\t\tPerson.class\n\t\t};\n\t}\n\n\t//tag::multitenacy-hibernate-session-example[]\n\tprivate void doInSession(String tenant, Consumer<Session> function) {\n\t\tSession session = null;\n\t\tTransaction txn = null;\n\t\ttry {\n\t\t\tsession = sessionFactory\n\t\t\t\t.withOptions()\n\t\t\t\t.tenantIdentifier(tenant)\n\t\t\t\t.openSession();\n\t\t\ttxn = session.getTransaction();\n\t\t\ttxn.begin();\n\t\t\tfunction.accept(session);\n\t\t\ttxn.commit();\n\t\t} catch (Throwable e) {\n\t\t\tif (txn != null) txn.rollback();\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.close();\n\t\t\t}\n\t\t}\n\t}\n\t//end::multitenacy-hibernate-session-example[]\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person {\n\n\t\t@Id\n\t\tprivate Long id;\n\n\t\tprivate String name;\n\n\t\tpublic Long getId() {\n\t\t\treturn id;\n\t\t}\n\n\t\tpublic void setId(Long id) {\n\t\t\tthis.id = id;\n\t\t}\n\n\t\tpublic String getName() {\n\t\t\treturn name;\n\t\t}\n\n\t\tpublic void setName(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\t}\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate endSlowQueryLogging(sql String, executeStartNanos long) : void extracted from public extract(statement Statement, sql String) : ResultSet in class org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 88,
                "endLine": 114,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 95,
                "endLine": 119,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 225,
                "endLine": 227,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "isPureRefactoring": true,
        "commitId": "7b8c403df746e127f38d3f5f3efb45b941c36af2",
        "packageNameBefore": "org.hibernate.engine.jdbc.internal",
        "classNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "methodNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#extract",
        "invokedMethod": "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}",
        "classSignatureBefore": "public class ResultSetReturnImpl implements ResultSetReturn ",
        "methodNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#extract"
        ],
        "classNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl"
        ],
        "classSignatureBeforeSet": [
            "public class ResultSetReturnImpl implements ResultSetReturn "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final Dialect dialect;\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.dialect = jdbcServices.getDialect();\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcEventHandler;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging(sql, executeStartNanos);\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate EventManager getEventManager() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t}\n\n\tprivate JdbcEventHandler getEventHandler() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler();\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tgetEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tgetEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\tprivate void endSlowQueryLogging(String sql, long executeStartNanos) {\n\t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n\t}\n\n\tprivate long beginSlowQueryLogging() {\n\t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "diffSourceCodeSet": [
            "private void endSlowQueryLogging(String sql, long executeStartNanos) {\n\t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\nprivate void endSlowQueryLogging(String sql, long executeStartNanos) {\n\t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n\t}",
        "diffSourceCode": "-   88: \t@Override\n-   89: \tpublic ResultSet extract(Statement statement, String sql) {\n-   90: \t\tsqlStatementLogger.logStatement( sql );\n-   91: \t\tlong executeStartNanos = 0;\n-   92: \t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n-   93: \t\t\texecuteStartNanos = System.nanoTime();\n-   94: \t\t}\n-   95: \t\ttry {\n-   96: \t\t\tfinal ResultSet rs;\n-   97: \t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n-   98: \t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n-   99: \t\t\ttry {\n-  100: \t\t\t\tjdbcExecuteStatementStart();\n-  101: \t\t\t\trs = statement.executeQuery( sql );\n-  102: \t\t\t}\n-  103: \t\t\tfinally {\n-  104: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n-  105: \t\t\t\tjdbcExecuteStatementEnd();\n-  106: \t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n+   88: \t\tgetEventHandler().jdbcExecuteStatementEnd();\n+   89: \t}\n+   90: \n+   91: \tprivate void jdbcExecuteStatementStart() {\n+   92: \t\tgetEventHandler().jdbcExecuteStatementStart();\n+   93: \t}\n+   94: \n+   95: \t@Override\n+   96: \tpublic ResultSet extract(Statement statement, String sql) {\n+   97: \t\tsqlStatementLogger.logStatement( sql );\n+   98: \t\tlong executeStartNanos = beginSlowQueryLogging();\n+   99: \t\ttry {\n+  100: \t\t\tfinal ResultSet rs;\n+  101: \t\t\tfinal EventManager eventManager = getEventManager();\n+  102: \t\t\tfinal HibernateMonitoringEvent executionEvent =\n+  103: \t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n+  104: \t\t\ttry {\n+  105: \t\t\t\tjdbcExecuteStatementStart();\n+  106: \t\t\t\trs = statement.executeQuery( sql );\n   107: \t\t\t}\n-  108: \t\t\tpostExtract( rs, statement );\n-  109: \t\t\treturn rs;\n-  110: \t\t}\n-  111: \t\tcatch (SQLException e) {\n-  112: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n-  113: \t\t}\n-  114: \t}\n-  115: \n-  116: \t@Override\n-  117: \tpublic ResultSet execute(PreparedStatement statement, String sql) {\n-  118: \t\t// sql logged by StatementPreparerImpl\n-  119: \t\tlong executeStartNanos = 0;\n-  225: \t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n-  226: \t\t}\n+  108: \t\t\tfinally {\n+  109: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n+  110: \t\t\t\tjdbcExecuteStatementEnd();\n+  111: \t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n+  112: \t\t\t}\n+  113: \t\t\tpostExtract( rs, statement );\n+  114: \t\t\treturn rs;\n+  115: \t\t}\n+  116: \t\tcatch (SQLException e) {\n+  117: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n+  118: \t\t}\n+  119: \t}\n+  225: \tprivate void endSlowQueryLogging(String sql, long executeStartNanos) {\n+  226: \t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n   227: \t}\n",
        "uniqueId": "7b8c403df746e127f38d3f5f3efb45b941c36af2_88_114_225_227_95_119",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 43
            },
            "LINE": {
                "missed": 0,
                "covered": 14
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\nprivate void logSlowQuery(String sql, long executeStartNanos) {\n    if (this.sqlStatementLogger.getLogSlowQuery() > 0) {\n        sqlStatementLogger.logSlowQuery(sql, executeStartNanos, context());\n    }\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final Dialect dialect;\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.dialect = jdbcServices.getDialect();\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate getEventManager() : EventManager extracted from public extract(statement Statement, sql String) : ResultSet in class org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 88,
                "endLine": 114,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 95,
                "endLine": 119,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 75,
                "endLine": 77,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "isPureRefactoring": true,
        "commitId": "7b8c403df746e127f38d3f5f3efb45b941c36af2",
        "packageNameBefore": "org.hibernate.engine.jdbc.internal",
        "classNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "methodNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#extract",
        "invokedMethod": "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}",
        "classSignatureBefore": "public class ResultSetReturnImpl implements ResultSetReturn ",
        "methodNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#extract"
        ],
        "classNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl"
        ],
        "classSignatureBeforeSet": [
            "public class ResultSetReturnImpl implements ResultSetReturn "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final Dialect dialect;\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.dialect = jdbcServices.getDialect();\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcEventHandler;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging(sql, executeStartNanos);\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate EventManager getEventManager() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t}\n\n\tprivate JdbcEventHandler getEventHandler() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler();\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tgetEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tgetEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\tprivate void endSlowQueryLogging(String sql, long executeStartNanos) {\n\t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n\t}\n\n\tprivate long beginSlowQueryLogging() {\n\t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "diffSourceCodeSet": [
            "private EventManager getEventManager() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\nprivate EventManager getEventManager() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t}",
        "diffSourceCode": "-   75: \n-   76: \tprivate JdbcSessionContext context() {\n-   77: \t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n-   88: \t@Override\n-   89: \tpublic ResultSet extract(Statement statement, String sql) {\n-   90: \t\tsqlStatementLogger.logStatement( sql );\n-   91: \t\tlong executeStartNanos = 0;\n-   92: \t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n-   93: \t\t\texecuteStartNanos = System.nanoTime();\n-   94: \t\t}\n-   95: \t\ttry {\n-   96: \t\t\tfinal ResultSet rs;\n-   97: \t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n-   98: \t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n-   99: \t\t\ttry {\n-  100: \t\t\t\tjdbcExecuteStatementStart();\n-  101: \t\t\t\trs = statement.executeQuery( sql );\n-  102: \t\t\t}\n-  103: \t\t\tfinally {\n-  104: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n-  105: \t\t\t\tjdbcExecuteStatementEnd();\n-  106: \t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n+   75: \tprivate EventManager getEventManager() {\n+   76: \t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n+   77: \t}\n+   88: \t\tgetEventHandler().jdbcExecuteStatementEnd();\n+   89: \t}\n+   90: \n+   91: \tprivate void jdbcExecuteStatementStart() {\n+   92: \t\tgetEventHandler().jdbcExecuteStatementStart();\n+   93: \t}\n+   94: \n+   95: \t@Override\n+   96: \tpublic ResultSet extract(Statement statement, String sql) {\n+   97: \t\tsqlStatementLogger.logStatement( sql );\n+   98: \t\tlong executeStartNanos = beginSlowQueryLogging();\n+   99: \t\ttry {\n+  100: \t\t\tfinal ResultSet rs;\n+  101: \t\t\tfinal EventManager eventManager = getEventManager();\n+  102: \t\t\tfinal HibernateMonitoringEvent executionEvent =\n+  103: \t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n+  104: \t\t\ttry {\n+  105: \t\t\t\tjdbcExecuteStatementStart();\n+  106: \t\t\t\trs = statement.executeQuery( sql );\n   107: \t\t\t}\n-  108: \t\t\tpostExtract( rs, statement );\n-  109: \t\t\treturn rs;\n-  110: \t\t}\n-  111: \t\tcatch (SQLException e) {\n-  112: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n-  113: \t\t}\n-  114: \t}\n-  115: \n-  116: \t@Override\n-  117: \tpublic ResultSet execute(PreparedStatement statement, String sql) {\n-  118: \t\t// sql logged by StatementPreparerImpl\n-  119: \t\tlong executeStartNanos = 0;\n+  108: \t\t\tfinally {\n+  109: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n+  110: \t\t\t\tjdbcExecuteStatementEnd();\n+  111: \t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n+  112: \t\t\t}\n+  113: \t\t\tpostExtract( rs, statement );\n+  114: \t\t\treturn rs;\n+  115: \t\t}\n+  116: \t\tcatch (SQLException e) {\n+  117: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n+  118: \t\t}\n+  119: \t}\n",
        "uniqueId": "7b8c403df746e127f38d3f5f3efb45b941c36af2_88_114_75_77_95_119",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 43
            },
            "LINE": {
                "missed": 0,
                "covered": 14
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\nprivate void logSlowQuery(String sql, long executeStartNanos) {\n    if (this.sqlStatementLogger.getLogSlowQuery() > 0) {\n        sqlStatementLogger.logSlowQuery(sql, executeStartNanos, context());\n    }\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final Dialect dialect;\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.dialect = jdbcServices.getDialect();\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate endSlowQueryLogging(sql String, executeStartNanos long) : void extracted from public extract(statement PreparedStatement, sql String) : ResultSet in class org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 48,
                "endLine": 74,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 46,
                "endLine": 73,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 225,
                "endLine": 227,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "isPureRefactoring": true,
        "commitId": "7b8c403df746e127f38d3f5f3efb45b941c36af2",
        "packageNameBefore": "org.hibernate.engine.jdbc.internal",
        "classNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "methodNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#extract",
        "invokedMethod": "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}",
        "classSignatureBefore": "public class ResultSetReturnImpl implements ResultSetReturn ",
        "methodNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#extract"
        ],
        "classNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl"
        ],
        "classSignatureBeforeSet": [
            "public class ResultSetReturnImpl implements ResultSetReturn "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final Dialect dialect;\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.dialect = jdbcServices.getDialect();\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcEventHandler;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging(sql, executeStartNanos);\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate EventManager getEventManager() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t}\n\n\tprivate JdbcEventHandler getEventHandler() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler();\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tgetEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tgetEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\tprivate void endSlowQueryLogging(String sql, long executeStartNanos) {\n\t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n\t}\n\n\tprivate long beginSlowQueryLogging() {\n\t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "diffSourceCodeSet": [
            "private void endSlowQueryLogging(String sql, long executeStartNanos) {\n\t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging(sql, executeStartNanos);\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\nprivate void endSlowQueryLogging(String sql, long executeStartNanos) {\n\t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n\t}",
        "diffSourceCode": "-   46: \t}\n-   47: \n-   48: \t@Override\n-   49: \tpublic ResultSet extract(PreparedStatement statement, String sql) {\n-   50: \t\t// IMPL NOTE : SQL logged by caller\n-   51: \t\tlong executeStartNanos = 0;\n-   52: \t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n-   53: \t\t\texecuteStartNanos = System.nanoTime();\n-   54: \t\t}\n-   55: \t\ttry {\n-   56: \t\t\tfinal ResultSet rs;\n-   57: \t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n-   58: \t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n-   59: \t\t\ttry {\n-   60: \t\t\t\tjdbcExecuteStatementStart();\n-   61: \t\t\t\trs = statement.executeQuery();\n-   62: \t\t\t}\n-   63: \t\t\tfinally {\n-   64: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n-   65: \t\t\t\tjdbcExecuteStatementEnd();\n-   66: \t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n-   67: \t\t\t}\n-   68: \t\t\tpostExtract( rs, statement );\n-   69: \t\t\treturn rs;\n-   70: \t\t}\n-   71: \t\tcatch (SQLException e) {\n-   72: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n-   73: \t\t}\n-   74: \t}\n-  225: \t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n-  226: \t\t}\n+   46: \t@Override\n+   47: \tpublic ResultSet extract(PreparedStatement statement, String sql) {\n+   48: \t\t// IMPL NOTE : SQL logged by caller\n+   49: \t\tlong executeStartNanos = 0;\n+   50: \t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n+   51: \t\t\texecuteStartNanos = System.nanoTime();\n+   52: \t\t}\n+   53: \t\ttry {\n+   54: \t\t\tfinal ResultSet rs;\n+   55: \t\t\tfinal EventManager eventManager = getEventManager();\n+   56: \t\t\tfinal HibernateMonitoringEvent executionEvent =\n+   57: \t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n+   58: \t\t\ttry {\n+   59: \t\t\t\tjdbcExecuteStatementStart();\n+   60: \t\t\t\trs = statement.executeQuery();\n+   61: \t\t\t}\n+   62: \t\t\tfinally {\n+   63: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n+   64: \t\t\t\tjdbcExecuteStatementEnd();\n+   65: \t\t\t\tendSlowQueryLogging(sql, executeStartNanos);\n+   66: \t\t\t}\n+   67: \t\t\tpostExtract( rs, statement );\n+   68: \t\t\treturn rs;\n+   69: \t\t}\n+   70: \t\tcatch (SQLException e) {\n+   71: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n+   72: \t\t}\n+   73: \t}\n+   74: \n+  225: \tprivate void endSlowQueryLogging(String sql, long executeStartNanos) {\n+  226: \t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n   227: \t}\n",
        "uniqueId": "7b8c403df746e127f38d3f5f3efb45b941c36af2_48_74_225_227_46_73",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 43
            },
            "LINE": {
                "missed": 0,
                "covered": 14
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\nprivate void logSlowQuery(String sql, long executeStartNanos) {\n    if (this.sqlStatementLogger.getLogSlowQuery() > 0) {\n        sqlStatementLogger.logSlowQuery(sql, executeStartNanos, context());\n    }\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final Dialect dialect;\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.dialect = jdbcServices.getDialect();\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate getEventManager() : EventManager extracted from public extract(statement PreparedStatement, sql String) : ResultSet in class org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 48,
                "endLine": 74,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 46,
                "endLine": 73,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 75,
                "endLine": 77,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "isPureRefactoring": true,
        "commitId": "7b8c403df746e127f38d3f5f3efb45b941c36af2",
        "packageNameBefore": "org.hibernate.engine.jdbc.internal",
        "classNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "methodNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#extract",
        "invokedMethod": "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}",
        "classSignatureBefore": "public class ResultSetReturnImpl implements ResultSetReturn ",
        "methodNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#extract"
        ],
        "classNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl"
        ],
        "classSignatureBeforeSet": [
            "public class ResultSetReturnImpl implements ResultSetReturn "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final Dialect dialect;\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.dialect = jdbcServices.getDialect();\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcEventHandler;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging(sql, executeStartNanos);\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate EventManager getEventManager() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t}\n\n\tprivate JdbcEventHandler getEventHandler() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler();\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tgetEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tgetEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\tprivate void endSlowQueryLogging(String sql, long executeStartNanos) {\n\t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n\t}\n\n\tprivate long beginSlowQueryLogging() {\n\t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "diffSourceCodeSet": [
            "private EventManager getEventManager() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging(sql, executeStartNanos);\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\nprivate EventManager getEventManager() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t}",
        "diffSourceCode": "-   46: \t}\n-   47: \n-   48: \t@Override\n-   49: \tpublic ResultSet extract(PreparedStatement statement, String sql) {\n-   50: \t\t// IMPL NOTE : SQL logged by caller\n-   51: \t\tlong executeStartNanos = 0;\n-   52: \t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n-   53: \t\t\texecuteStartNanos = System.nanoTime();\n-   54: \t\t}\n-   55: \t\ttry {\n-   56: \t\t\tfinal ResultSet rs;\n-   57: \t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n-   58: \t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n-   59: \t\t\ttry {\n-   60: \t\t\t\tjdbcExecuteStatementStart();\n-   61: \t\t\t\trs = statement.executeQuery();\n-   62: \t\t\t}\n-   63: \t\t\tfinally {\n-   64: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n-   65: \t\t\t\tjdbcExecuteStatementEnd();\n-   66: \t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n-   67: \t\t\t}\n-   68: \t\t\tpostExtract( rs, statement );\n-   69: \t\t\treturn rs;\n-   70: \t\t}\n-   71: \t\tcatch (SQLException e) {\n-   72: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n-   73: \t\t}\n-   74: \t}\n-   75: \n-   76: \tprivate JdbcSessionContext context() {\n-   77: \t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n+   46: \t@Override\n+   47: \tpublic ResultSet extract(PreparedStatement statement, String sql) {\n+   48: \t\t// IMPL NOTE : SQL logged by caller\n+   49: \t\tlong executeStartNanos = 0;\n+   50: \t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n+   51: \t\t\texecuteStartNanos = System.nanoTime();\n+   52: \t\t}\n+   53: \t\ttry {\n+   54: \t\t\tfinal ResultSet rs;\n+   55: \t\t\tfinal EventManager eventManager = getEventManager();\n+   56: \t\t\tfinal HibernateMonitoringEvent executionEvent =\n+   57: \t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n+   58: \t\t\ttry {\n+   59: \t\t\t\tjdbcExecuteStatementStart();\n+   60: \t\t\t\trs = statement.executeQuery();\n+   61: \t\t\t}\n+   62: \t\t\tfinally {\n+   63: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n+   64: \t\t\t\tjdbcExecuteStatementEnd();\n+   65: \t\t\t\tendSlowQueryLogging(sql, executeStartNanos);\n+   66: \t\t\t}\n+   67: \t\t\tpostExtract( rs, statement );\n+   68: \t\t\treturn rs;\n+   69: \t\t}\n+   70: \t\tcatch (SQLException e) {\n+   71: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n+   72: \t\t}\n+   73: \t}\n+   74: \n+   75: \tprivate EventManager getEventManager() {\n+   76: \t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n+   77: \t}\n",
        "uniqueId": "7b8c403df746e127f38d3f5f3efb45b941c36af2_48_74_75_77_46_73",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 43
            },
            "LINE": {
                "missed": 0,
                "covered": 14
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\nprivate void logSlowQuery(String sql, long executeStartNanos) {\n    if (this.sqlStatementLogger.getLogSlowQuery() > 0) {\n        sqlStatementLogger.logSlowQuery(sql, executeStartNanos, context());\n    }\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final Dialect dialect;\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.dialect = jdbcServices.getDialect();\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate sequenceInformation(connection Connection, jdbcEnvironment JdbcEnvironment) : Iterable<SequenceInformation> extracted from private fetchSequenceInformation(sequenceName String) : SequenceInformation in class org.hibernate.orm.test.dialect.functional.OracleDialectSequenceInformationTest",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/dialect/functional/OracleDialectSequenceInformationTest.java",
                "startLine": 74,
                "endLine": 110,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/dialect/functional/OracleDialectSequenceInformationTest.java",
                "startLine": 74,
                "endLine": 89,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/dialect/functional/OracleDialectSequenceInformationTest.java",
                "startLine": 95,
                "endLine": 110,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private SequenceInformation fetchSequenceInformation(String sequenceName) throws SQLException {\n\t\treturn TransactionUtil.doWithJDBC(\n\t\t\t\tsessionFactory().getServiceRegistry(),\n\t\t\t\tconnection -> {\n\t\t\t\t\tJdbcEnvironment jdbcEnvironment = sessionFactory().getJdbcServices().getJdbcEnvironment();\n\t\t\t\t\tSequenceInformationExtractorOracleDatabaseImpl sequenceExtractor = SequenceInformationExtractorOracleDatabaseImpl.INSTANCE;\n\t\t\t\t\tIterable<SequenceInformation> sequenceInformations = sequenceExtractor.extractMetadata(\n\t\t\t\t\t\t\tnew ExtractionContext.EmptyExtractionContext() {\n\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic Connection getJdbcConnection() {\n\t\t\t\t\t\t\t\t\treturn connection;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n\t\t\t\t\t\t\t\t\treturn jdbcEnvironment;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t// lets skip system sequences\n\t\t\t\t\tOptional<SequenceInformation> foundSequence = StreamSupport.stream(\n\t\t\t\t\t\t\t\t\tsequenceInformations.spliterator(),\n\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.filter( sequence -> sequenceName.equals( sequence.getSequenceName()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .getSequenceName()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .getText()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .toUpperCase() ) )\n\t\t\t\t\t\t\t.findFirst();\n\n\t\t\t\t\tassertTrue( sequenceName + \" not found\", foundSequence.isPresent() );\n\n\t\t\t\t\treturn foundSequence.get();\n\t\t\t\t}\n\t\t);\n\t}",
        "filePathBefore": "hibernate-core/src/test/java/org/hibernate/orm/test/dialect/functional/OracleDialectSequenceInformationTest.java",
        "isPureRefactoring": true,
        "commitId": "72e42817e3759f3f130eefb302d9aa7a3e0cfa58",
        "packageNameBefore": "org.hibernate.orm.test.dialect.functional",
        "classNameBefore": "org.hibernate.orm.test.dialect.functional.OracleDialectSequenceInformationTest",
        "methodNameBefore": "org.hibernate.orm.test.dialect.functional.OracleDialectSequenceInformationTest#fetchSequenceInformation",
        "invokedMethod": "methodSignature: org.hibernate.query.results.implicit.ImplicitFetchBuilderEntity#equals\n methodBody: public boolean equals(Object o) {\nif(this == o){return true;\n}if(o == null || getClass() != o.getClass()){return false;\n}final ImplicitFetchBuilderEntity that=(ImplicitFetchBuilderEntity)o;\nreturn fetchPath.equals(that.fetchPath) && fetchable.equals(that.fetchable) && fetchBuilders.equals(that.fetchBuilders);\n}\nmethodSignature: org.hibernate.boot.beanvalidation.GroupsPerOperation#get\n methodBody: public Class<?>[] get(Operation operation) {\nreturn groupsPerOperation.get(operation);\n}\nmethodSignature: org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.TemporaryJdbcSessionOwner#getJdbcServices\n methodBody: public JdbcServices getJdbcServices() {\nreturn jdbcServices;\n}\nmethodSignature: org.hibernate.boot.model.relational.QualifiedNameParser.NameParts#equals\n methodBody: public boolean equals(Object o) {\nif(this == o){return true;\n}if(o == null || getClass() != o.getClass()){return false;\n}NameParts that=(NameParts)o;\nreturn Objects.equals(this.getCatalogName(),that.getCatalogName()) && Objects.equals(this.getSchemaName(),that.getSchemaName()) && Objects.equals(this.getObjectName(),that.getObjectName());\n}\nmethodSignature: org.hibernate.engine.jdbc.env.internal.ExtractedDatabaseMetaDataImpl#getJdbcEnvironment\n methodBody: public JdbcEnvironment getJdbcEnvironment() {\nreturn jdbcEnvironment;\n}\nmethodSignature: org.hibernate.metamodel.mapping.SelectablePath#equals\n methodBody: public boolean equals(Object o) {\nif(this == o){return true;\n}if(o == null || getClass() != o.getClass()){return false;\n}SelectablePath that=(SelectablePath)o;\nif(!Objects.equals(parent,that.parent)){return false;\n}return name.equals(that.name);\n}",
        "classSignatureBefore": "public class OracleDialectSequenceInformationTest extends BaseNonConfigCoreFunctionalTestCase ",
        "methodNameBeforeSet": [
            "org.hibernate.orm.test.dialect.functional.OracleDialectSequenceInformationTest#fetchSequenceInformation"
        ],
        "classNameBeforeSet": [
            "org.hibernate.orm.test.dialect.functional.OracleDialectSequenceInformationTest"
        ],
        "classSignatureBeforeSet": [
            "public class OracleDialectSequenceInformationTest extends BaseNonConfigCoreFunctionalTestCase "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.orm.test.dialect.functional;\n\nimport java.math.BigDecimal;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Optional;\nimport java.util.stream.StreamSupport;\n\nimport org.hibernate.dialect.OracleDialect;\nimport org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;\nimport org.hibernate.testing.RequiresDialect;\nimport org.hibernate.testing.TestForIssue;\nimport org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase;\nimport org.hibernate.testing.transaction.TransactionUtil;\n\nimport org.hibernate.tool.schema.extract.internal.SequenceInformationExtractorOracleDatabaseImpl;\nimport org.hibernate.tool.schema.extract.spi.ExtractionContext;\nimport org.hibernate.tool.schema.extract.spi.SequenceInformation;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.hibernate.testing.transaction.TransactionUtil.doInAutoCommit;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\n@RequiresDialect(OracleDialect.class)\n@TestForIssue(jiraKey = \"HHH-13694\")\npublic class OracleDialectSequenceInformationTest extends BaseNonConfigCoreFunctionalTestCase {\n\n\tprivate static final String MIN_SEQUENCE_NAME = \"SEQ_MIN_TEST\";\n\tprivate static final String MAX_SEQUENCE_NAME = \"SEQ_MAX_TEST\";\n\tprivate static final String MIN_VALUE = \"-99999999999999999999999999\";\n\tprivate static final String MAX_VALUE =  \"99999999999999999999999999\";\n\n\t@Before\n\tpublic void prepareTest() throws Exception {\n\t\tdoInAutoCommit(\n\t\t\t\t\"DROP SEQUENCE \" + MIN_SEQUENCE_NAME,\n\t\t\t\t\"CREATE SEQUENCE \" + MIN_SEQUENCE_NAME + \" MINVALUE \" + MIN_VALUE + \" MAXVALUE -1 INCREMENT BY -1\",\n\t\t\t\t\"DROP SEQUENCE \" + MAX_SEQUENCE_NAME,\n\t\t\t\t\"CREATE SEQUENCE \" + MAX_SEQUENCE_NAME + \" MINVALUE 0 MAXVALUE \" + MAX_VALUE + \" INCREMENT BY 1\" );\n\t}\n\n\t@After\n\tpublic void cleanupTest() throws Exception {\n\t\tdoInAutoCommit(\n\t\t\t\t\"DROP SEQUENCE \" + MIN_SEQUENCE_NAME,\n\t\t\t\t\"DROP SEQUENCE \" + MAX_SEQUENCE_NAME );\n\t}\n\n\t@Test\n\tpublic void testExtractSequenceWithMinValueLowerThanLongMinValue() throws SQLException {\n\t\tSequenceInformation sequence = fetchSequenceInformation( MIN_SEQUENCE_NAME );\n\n\t\tassertEquals( -1L, sequence.getIncrementValue().longValue() );\n\t\tassertEquals( new BigDecimal( MIN_VALUE ), sequence.getMinValue() );\n\t}\n\n\t@Test\n\tpublic void testExtractSequenceWithMaxValueGreaterThanLongMaxValue() throws SQLException {\n\t\tSequenceInformation sequence = fetchSequenceInformation( MAX_SEQUENCE_NAME );\n\n\t\tassertEquals( 1L, sequence.getIncrementValue().longValue() );\n\t\tassertEquals( new BigDecimal( MAX_VALUE ), sequence.getMaxValue() );\n\t}\n\n\tprivate SequenceInformation fetchSequenceInformation(String sequenceName) throws SQLException {\n\t\treturn TransactionUtil.doWithJDBC(\n\t\t\t\tsessionFactory().getServiceRegistry(),\n\t\t\t\tconnection -> {\n\t\t\t\t\tJdbcEnvironment jdbcEnvironment = sessionFactory().getJdbcServices().getJdbcEnvironment();\n\t\t\t\t\tSequenceInformationExtractorOracleDatabaseImpl sequenceExtractor = SequenceInformationExtractorOracleDatabaseImpl.INSTANCE;\n\t\t\t\t\tIterable<SequenceInformation> sequenceInformations = sequenceExtractor.extractMetadata(\n\t\t\t\t\t\t\tnew ExtractionContext.EmptyExtractionContext() {\n\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic Connection getJdbcConnection() {\n\t\t\t\t\t\t\t\t\treturn connection;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n\t\t\t\t\t\t\t\t\treturn jdbcEnvironment;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t// lets skip system sequences\n\t\t\t\t\tOptional<SequenceInformation> foundSequence = StreamSupport.stream(\n\t\t\t\t\t\t\t\t\tsequenceInformations.spliterator(),\n\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.filter( sequence -> sequenceName.equals( sequence.getSequenceName()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .getSequenceName()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .getText()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .toUpperCase() ) )\n\t\t\t\t\t\t\t.findFirst();\n\n\t\t\t\t\tassertTrue( sequenceName + \" not found\", foundSequence.isPresent() );\n\n\t\t\t\t\treturn foundSequence.get();\n\t\t\t\t}\n\t\t);\n\t}\n}",
        "filePathAfter": "hibernate-core/src/test/java/org/hibernate/orm/test/dialect/functional/OracleDialectSequenceInformationTest.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.orm.test.dialect.functional;\n\nimport java.math.BigDecimal;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Optional;\n\nimport org.hibernate.dialect.OracleDialect;\nimport org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;\nimport org.hibernate.testing.RequiresDialect;\nimport org.hibernate.testing.TestForIssue;\nimport org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase;\nimport org.hibernate.testing.transaction.TransactionUtil;\n\nimport org.hibernate.tool.schema.extract.internal.SequenceInformationExtractorOracleDatabaseImpl;\nimport org.hibernate.tool.schema.extract.spi.ExtractionContext;\nimport org.hibernate.tool.schema.extract.spi.SequenceInformation;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static java.util.stream.StreamSupport.stream;\nimport static org.hibernate.testing.transaction.TransactionUtil.doInAutoCommit;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\n@RequiresDialect(OracleDialect.class)\n@TestForIssue(jiraKey = \"HHH-13694\")\npublic class OracleDialectSequenceInformationTest extends BaseNonConfigCoreFunctionalTestCase {\n\n\tprivate static final String MIN_SEQUENCE_NAME = \"SEQ_MIN_TEST\";\n\tprivate static final String MAX_SEQUENCE_NAME = \"SEQ_MAX_TEST\";\n\tprivate static final String MIN_VALUE = \"-99999999999999999999999999\";\n\tprivate static final String MAX_VALUE =  \"99999999999999999999999999\";\n\n\t@Before\n\tpublic void prepareTest() throws Exception {\n\t\tdoInAutoCommit(\n\t\t\t\t\"DROP SEQUENCE \" + MIN_SEQUENCE_NAME,\n\t\t\t\t\"CREATE SEQUENCE \" + MIN_SEQUENCE_NAME + \" MINVALUE \" + MIN_VALUE + \" MAXVALUE -1 INCREMENT BY -1\",\n\t\t\t\t\"DROP SEQUENCE \" + MAX_SEQUENCE_NAME,\n\t\t\t\t\"CREATE SEQUENCE \" + MAX_SEQUENCE_NAME + \" MINVALUE 0 MAXVALUE \" + MAX_VALUE + \" INCREMENT BY 1\" );\n\t}\n\n\t@After\n\tpublic void cleanupTest() throws Exception {\n\t\tdoInAutoCommit(\n\t\t\t\t\"DROP SEQUENCE \" + MIN_SEQUENCE_NAME,\n\t\t\t\t\"DROP SEQUENCE \" + MAX_SEQUENCE_NAME );\n\t}\n\n\t@Test\n\tpublic void testExtractSequenceWithMinValueLowerThanLongMinValue() throws SQLException {\n\t\tSequenceInformation sequence = fetchSequenceInformation( MIN_SEQUENCE_NAME );\n\n\t\tassertEquals( -1L, sequence.getIncrementValue().longValue() );\n\t\tassertEquals( new BigDecimal( MIN_VALUE ), sequence.getMinValue() );\n\t}\n\n\t@Test\n\tpublic void testExtractSequenceWithMaxValueGreaterThanLongMaxValue() throws SQLException {\n\t\tSequenceInformation sequence = fetchSequenceInformation( MAX_SEQUENCE_NAME );\n\n\t\tassertEquals( 1L, sequence.getIncrementValue().longValue() );\n\t\tassertEquals( new BigDecimal( MAX_VALUE ), sequence.getMaxValue() );\n\t}\n\n\tprivate SequenceInformation fetchSequenceInformation(String sequenceName) throws SQLException {\n\t\treturn TransactionUtil.doWithJDBC(\n\t\t\t\tsessionFactory().getServiceRegistry(),\n\t\t\t\tconnection -> {\n\t\t\t\t\tfinal JdbcEnvironment jdbcEnvironment =\n\t\t\t\t\t\t\tsessionFactory().getJdbcServices().getJdbcEnvironment();\n\t\t\t\t\t// lets skip system sequences\n\t\t\t\t\tOptional<SequenceInformation> foundSequence =\n\t\t\t\t\t\t\tstream( sequenceInformation( connection, jdbcEnvironment ).spliterator(), false )\n\t\t\t\t\t\t\t.filter( sequence -> isSameSequence( sequenceName, sequence ) )\n\t\t\t\t\t\t\t.findFirst();\n\t\t\t\t\tassertTrue( sequenceName + \" not found\", foundSequence.isPresent() );\n\t\t\t\t\treturn foundSequence.get();\n\t\t\t\t}\n\t\t);\n\t}\n\n\tprivate static boolean isSameSequence(String sequenceName, SequenceInformation sequence) {\n\t\treturn sequenceName.equals( sequence.getSequenceName().getSequenceName().getText().toUpperCase() );\n\t}\n\n\tprivate static Iterable<SequenceInformation> sequenceInformation(Connection connection, JdbcEnvironment jdbcEnvironment)\n\t\t\tthrows SQLException {\n\t\treturn SequenceInformationExtractorOracleDatabaseImpl.INSTANCE.extractMetadata(\n\t\t\t\tnew ExtractionContext.EmptyExtractionContext() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Connection getJdbcConnection() {\n\t\t\t\t\t\treturn connection;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n\t\t\t\t\t\treturn jdbcEnvironment;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n}",
        "diffSourceCodeSet": [
            "private static Iterable<SequenceInformation> sequenceInformation(Connection connection, JdbcEnvironment jdbcEnvironment)\n\t\t\tthrows SQLException {\n\t\treturn SequenceInformationExtractorOracleDatabaseImpl.INSTANCE.extractMetadata(\n\t\t\t\tnew ExtractionContext.EmptyExtractionContext() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Connection getJdbcConnection() {\n\t\t\t\t\t\treturn connection;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n\t\t\t\t\t\treturn jdbcEnvironment;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.query.results.implicit.ImplicitFetchBuilderEntity#equals\n methodBody: public boolean equals(Object o) {\nif(this == o){return true;\n}if(o == null || getClass() != o.getClass()){return false;\n}final ImplicitFetchBuilderEntity that=(ImplicitFetchBuilderEntity)o;\nreturn fetchPath.equals(that.fetchPath) && fetchable.equals(that.fetchable) && fetchBuilders.equals(that.fetchBuilders);\n}",
            "methodSignature: org.hibernate.boot.beanvalidation.GroupsPerOperation#get\n methodBody: public Class<?>[] get(Operation operation) {\nreturn groupsPerOperation.get(operation);\n}",
            "methodSignature: org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.TemporaryJdbcSessionOwner#getJdbcServices\n methodBody: public JdbcServices getJdbcServices() {\nreturn jdbcServices;\n}",
            "methodSignature: org.hibernate.boot.model.relational.QualifiedNameParser.NameParts#equals\n methodBody: public boolean equals(Object o) {\nif(this == o){return true;\n}if(o == null || getClass() != o.getClass()){return false;\n}NameParts that=(NameParts)o;\nreturn Objects.equals(this.getCatalogName(),that.getCatalogName()) && Objects.equals(this.getSchemaName(),that.getSchemaName()) && Objects.equals(this.getObjectName(),that.getObjectName());\n}",
            "methodSignature: org.hibernate.engine.jdbc.env.internal.ExtractedDatabaseMetaDataImpl#getJdbcEnvironment\n methodBody: public JdbcEnvironment getJdbcEnvironment() {\nreturn jdbcEnvironment;\n}",
            "methodSignature: org.hibernate.metamodel.mapping.SelectablePath#equals\n methodBody: public boolean equals(Object o) {\nif(this == o){return true;\n}if(o == null || getClass() != o.getClass()){return false;\n}SelectablePath that=(SelectablePath)o;\nif(!Objects.equals(parent,that.parent)){return false;\n}return name.equals(that.name);\n}"
        ],
        "sourceCodeAfterRefactoring": "private SequenceInformation fetchSequenceInformation(String sequenceName) throws SQLException {\n\t\treturn TransactionUtil.doWithJDBC(\n\t\t\t\tsessionFactory().getServiceRegistry(),\n\t\t\t\tconnection -> {\n\t\t\t\t\tfinal JdbcEnvironment jdbcEnvironment =\n\t\t\t\t\t\t\tsessionFactory().getJdbcServices().getJdbcEnvironment();\n\t\t\t\t\t// lets skip system sequences\n\t\t\t\t\tOptional<SequenceInformation> foundSequence =\n\t\t\t\t\t\t\tstream( sequenceInformation( connection, jdbcEnvironment ).spliterator(), false )\n\t\t\t\t\t\t\t.filter( sequence -> isSameSequence( sequenceName, sequence ) )\n\t\t\t\t\t\t\t.findFirst();\n\t\t\t\t\tassertTrue( sequenceName + \" not found\", foundSequence.isPresent() );\n\t\t\t\t\treturn foundSequence.get();\n\t\t\t\t}\n\t\t);\n\t}\nprivate static Iterable<SequenceInformation> sequenceInformation(Connection connection, JdbcEnvironment jdbcEnvironment)\n\t\t\tthrows SQLException {\n\t\treturn SequenceInformationExtractorOracleDatabaseImpl.INSTANCE.extractMetadata(\n\t\t\t\tnew ExtractionContext.EmptyExtractionContext() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Connection getJdbcConnection() {\n\t\t\t\t\t\treturn connection;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n\t\t\t\t\t\treturn jdbcEnvironment;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}",
        "diffSourceCode": "    74: \tprivate SequenceInformation fetchSequenceInformation(String sequenceName) throws SQLException {\n    75: \t\treturn TransactionUtil.doWithJDBC(\n    76: \t\t\t\tsessionFactory().getServiceRegistry(),\n    77: \t\t\t\tconnection -> {\n-   78: \t\t\t\t\tJdbcEnvironment jdbcEnvironment = sessionFactory().getJdbcServices().getJdbcEnvironment();\n-   79: \t\t\t\t\tSequenceInformationExtractorOracleDatabaseImpl sequenceExtractor = SequenceInformationExtractorOracleDatabaseImpl.INSTANCE;\n-   80: \t\t\t\t\tIterable<SequenceInformation> sequenceInformations = sequenceExtractor.extractMetadata(\n-   81: \t\t\t\t\t\t\tnew ExtractionContext.EmptyExtractionContext() {\n-   82: \n-   83: \t\t\t\t\t\t\t\t@Override\n-   84: \t\t\t\t\t\t\t\tpublic Connection getJdbcConnection() {\n-   85: \t\t\t\t\t\t\t\t\treturn connection;\n-   86: \t\t\t\t\t\t\t\t}\n-   87: \n-   88: \t\t\t\t\t\t\t\t@Override\n-   89: \t\t\t\t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n-   90: \t\t\t\t\t\t\t\t\treturn jdbcEnvironment;\n-   91: \t\t\t\t\t\t\t\t}\n-   92: \t\t\t\t\t\t\t} );\n-   93: \n-   94: \t\t\t\t\t// lets skip system sequences\n-   95: \t\t\t\t\tOptional<SequenceInformation> foundSequence = StreamSupport.stream(\n-   96: \t\t\t\t\t\t\t\t\tsequenceInformations.spliterator(),\n-   97: \t\t\t\t\t\t\t\t\tfalse\n-   98: \t\t\t\t\t\t\t)\n-   99: \t\t\t\t\t\t\t.filter( sequence -> sequenceName.equals( sequence.getSequenceName()\n-  100: \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .getSequenceName()\n-  101: \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .getText()\n-  102: \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .toUpperCase() ) )\n-  103: \t\t\t\t\t\t\t.findFirst();\n-  104: \n-  105: \t\t\t\t\tassertTrue( sequenceName + \" not found\", foundSequence.isPresent() );\n-  106: \n-  107: \t\t\t\t\treturn foundSequence.get();\n+   78: \t\t\t\t\tfinal JdbcEnvironment jdbcEnvironment =\n+   79: \t\t\t\t\t\t\tsessionFactory().getJdbcServices().getJdbcEnvironment();\n+   80: \t\t\t\t\t// lets skip system sequences\n+   81: \t\t\t\t\tOptional<SequenceInformation> foundSequence =\n+   82: \t\t\t\t\t\t\tstream( sequenceInformation( connection, jdbcEnvironment ).spliterator(), false )\n+   83: \t\t\t\t\t\t\t.filter( sequence -> isSameSequence( sequenceName, sequence ) )\n+   84: \t\t\t\t\t\t\t.findFirst();\n+   85: \t\t\t\t\tassertTrue( sequenceName + \" not found\", foundSequence.isPresent() );\n+   86: \t\t\t\t\treturn foundSequence.get();\n+   87: \t\t\t\t}\n+   88: \t\t);\n+   89: \t}\n+   90: \n+   91: \tprivate static boolean isSameSequence(String sequenceName, SequenceInformation sequence) {\n+   92: \t\treturn sequenceName.equals( sequence.getSequenceName().getSequenceName().getText().toUpperCase() );\n+   93: \t}\n+   94: \n+   95: \tprivate static Iterable<SequenceInformation> sequenceInformation(Connection connection, JdbcEnvironment jdbcEnvironment)\n+   96: \t\t\tthrows SQLException {\n+   97: \t\treturn SequenceInformationExtractorOracleDatabaseImpl.INSTANCE.extractMetadata(\n+   98: \t\t\t\tnew ExtractionContext.EmptyExtractionContext() {\n+   99: \t\t\t\t\t@Override\n+  100: \t\t\t\t\tpublic Connection getJdbcConnection() {\n+  101: \t\t\t\t\t\treturn connection;\n+  102: \t\t\t\t\t}\n+  103: \n+  104: \t\t\t\t\t@Override\n+  105: \t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n+  106: \t\t\t\t\t\treturn jdbcEnvironment;\n+  107: \t\t\t\t\t}\n   108: \t\t\t\t}\n   109: \t\t);\n   110: \t}\n",
        "uniqueId": "72e42817e3759f3f130eefb302d9aa7a3e0cfa58_74_110_95_110_74_89",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "refactoringMinerResult": true,
        "compileAndTestResult": true,
        "refactoredCode": "##########################\nprivate SequenceInformation fetchSequenceInformation(String sequenceName) throws SQLException {\n    return TransactionUtil.doWithJDBC(\n            sessionFactory().getServiceRegistry(),\n            connection -> {\n                JdbcEnvironment jdbcEnvironment = sessionFactory().getJdbcServices().getJdbcEnvironment();\n                SequenceInformationExtractorOracleDatabaseImpl sequenceExtractor = SequenceInformationExtractorOracleDatabaseImpl.INSTANCE;\n                Iterable<SequenceInformation> sequenceInformations = sequenceExtractor.extractMetadata(\n                        new ExtractionContext.EmptyExtractionContext() {\n\n                            @Override\n                            public Connection getJdbcConnection() {\n                                return connection;\n                            }\n\n                            @Override\n                            public JdbcEnvironment getJdbcEnvironment() {\n                                return jdbcEnvironment;\n                            }\n                        });\n\n                Optional<SequenceInformation> foundSequence = findSequenceByName(sequenceInformations, sequenceName);\n\n                assertTrue(sequenceName + \" not found\", foundSequence.isPresent());\n\n                return foundSequence.get();\n            }\n    );\n}\n\nprivate Optional<SequenceInformation> findSequenceByName(Iterable<SequenceInformation> sequenceInformations, String sequenceName) {\n    return StreamSupport.stream(\n            sequenceInformations.spliterator(),\n            false\n    )\n            .filter(sequence -> sequenceName.equals(sequence.getSequenceName()\n                    .getSequenceName()\n                    .getText()\n                    .toUpperCase()))\n            .findFirst();\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprivate SequenceInformation fetchSequenceInformation(String sequenceName) throws SQLException {\n\t\treturn TransactionUtil.doWithJDBC(\n\t\t\t\tsessionFactory().getServiceRegistry(),\n\t\t\t\tconnection -> {\n\t\t\t\t\tJdbcEnvironment jdbcEnvironment = sessionFactory().getJdbcServices().getJdbcEnvironment();\n\t\t\t\t\tSequenceInformationExtractorOracleDatabaseImpl sequenceExtractor = SequenceInformationExtractorOracleDatabaseImpl.INSTANCE;\n\t\t\t\t\tIterable<SequenceInformation> sequenceInformations = sequenceExtractor.extractMetadata(\n\t\t\t\t\t\t\tnew ExtractionContext.EmptyExtractionContext() {\n\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic Connection getJdbcConnection() {\n\t\t\t\t\t\t\t\t\treturn connection;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n\t\t\t\t\t\t\t\t\treturn jdbcEnvironment;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t// lets skip system sequences\n\t\t\t\t\tOptional<SequenceInformation> foundSequence = StreamSupport.stream(\n\t\t\t\t\t\t\t\t\tsequenceInformations.spliterator(),\n\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.filter( sequence -> sequenceName.equals( sequence.getSequenceName()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .getSequenceName()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .getText()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .toUpperCase() ) )\n\t\t\t\t\t\t\t.findFirst();\n\n\t\t\t\t\tassertTrue( sequenceName + \" not found\", foundSequence.isPresent() );\n\n\t\t\t\t\treturn foundSequence.get();\n\t\t\t\t}\n\t\t);\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.orm.test.dialect.functional;\n\nimport java.math.BigDecimal;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Optional;\nimport java.util.stream.StreamSupport;\n\nimport org.hibernate.dialect.OracleDialect;\nimport org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;\nimport org.hibernate.testing.RequiresDialect;\nimport org.hibernate.testing.TestForIssue;\nimport org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase;\nimport org.hibernate.testing.transaction.TransactionUtil;\n\nimport org.hibernate.tool.schema.extract.internal.SequenceInformationExtractorOracleDatabaseImpl;\nimport org.hibernate.tool.schema.extract.spi.ExtractionContext;\nimport org.hibernate.tool.schema.extract.spi.SequenceInformation;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.hibernate.testing.transaction.TransactionUtil.doInAutoCommit;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\n@RequiresDialect(OracleDialect.class)\n@TestForIssue(jiraKey = \"HHH-13694\")\npublic class OracleDialectSequenceInformationTest extends BaseNonConfigCoreFunctionalTestCase {\n\n\tprivate static final String MIN_SEQUENCE_NAME = \"SEQ_MIN_TEST\";\n\tprivate static final String MAX_SEQUENCE_NAME = \"SEQ_MAX_TEST\";\n\tprivate static final String MIN_VALUE = \"-99999999999999999999999999\";\n\tprivate static final String MAX_VALUE =  \"99999999999999999999999999\";\n\n\t@Before\n\tpublic void prepareTest() throws Exception {\n\t\tdoInAutoCommit(\n\t\t\t\t\"DROP SEQUENCE \" + MIN_SEQUENCE_NAME,\n\t\t\t\t\"CREATE SEQUENCE \" + MIN_SEQUENCE_NAME + \" MINVALUE \" + MIN_VALUE + \" MAXVALUE -1 INCREMENT BY -1\",\n\t\t\t\t\"DROP SEQUENCE \" + MAX_SEQUENCE_NAME,\n\t\t\t\t\"CREATE SEQUENCE \" + MAX_SEQUENCE_NAME + \" MINVALUE 0 MAXVALUE \" + MAX_VALUE + \" INCREMENT BY 1\" );\n\t}\n\n\t@After\n\tpublic void cleanupTest() throws Exception {\n\t\tdoInAutoCommit(\n\t\t\t\t\"DROP SEQUENCE \" + MIN_SEQUENCE_NAME,\n\t\t\t\t\"DROP SEQUENCE \" + MAX_SEQUENCE_NAME );\n\t}\n\n\t@Test\n\tpublic void testExtractSequenceWithMinValueLowerThanLongMinValue() throws SQLException {\n\t\tSequenceInformation sequence = fetchSequenceInformation( MIN_SEQUENCE_NAME );\n\n\t\tassertEquals( -1L, sequence.getIncrementValue().longValue() );\n\t\tassertEquals( new BigDecimal( MIN_VALUE ), sequence.getMinValue() );\n\t}\n\n\t@Test\n\tpublic void testExtractSequenceWithMaxValueGreaterThanLongMaxValue() throws SQLException {\n\t\tSequenceInformation sequence = fetchSequenceInformation( MAX_SEQUENCE_NAME );\n\n\t\tassertEquals( 1L, sequence.getIncrementValue().longValue() );\n\t\tassertEquals( new BigDecimal( MAX_VALUE ), sequence.getMaxValue() );\n\t}\n\n\tprivate SequenceInformation fetchSequenceInformation(String sequenceName) throws SQLException {\n\t\treturn TransactionUtil.doWithJDBC(\n\t\t\t\tsessionFactory().getServiceRegistry(),\n\t\t\t\tconnection -> {\n\t\t\t\t\tJdbcEnvironment jdbcEnvironment = sessionFactory().getJdbcServices().getJdbcEnvironment();\n\t\t\t\t\tSequenceInformationExtractorOracleDatabaseImpl sequenceExtractor = SequenceInformationExtractorOracleDatabaseImpl.INSTANCE;\n\t\t\t\t\tIterable<SequenceInformation> sequenceInformations = sequenceExtractor.extractMetadata(\n\t\t\t\t\t\t\tnew ExtractionContext.EmptyExtractionContext() {\n\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic Connection getJdbcConnection() {\n\t\t\t\t\t\t\t\t\treturn connection;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n\t\t\t\t\t\t\t\t\treturn jdbcEnvironment;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t// lets skip system sequences\n\t\t\t\t\tOptional<SequenceInformation> foundSequence = StreamSupport.stream(\n\t\t\t\t\t\t\t\t\tsequenceInformations.spliterator(),\n\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.filter( sequence -> sequenceName.equals( sequence.getSequenceName()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .getSequenceName()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .getText()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .toUpperCase() ) )\n\t\t\t\t\t\t\t.findFirst();\n\n\t\t\t\t\tassertTrue( sequenceName + \" not found\", foundSequence.isPresent() );\n\n\t\t\t\t\treturn foundSequence.get();\n\t\t\t\t}\n\t\t);\n\t}\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate isSameSequence(sequenceName String, sequence SequenceInformation) : boolean extracted from private fetchSequenceInformation(sequenceName String) : SequenceInformation in class org.hibernate.orm.test.dialect.functional.OracleDialectSequenceInformationTest",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/dialect/functional/OracleDialectSequenceInformationTest.java",
                "startLine": 74,
                "endLine": 110,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/dialect/functional/OracleDialectSequenceInformationTest.java",
                "startLine": 74,
                "endLine": 89,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/dialect/functional/OracleDialectSequenceInformationTest.java",
                "startLine": 91,
                "endLine": 93,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private SequenceInformation fetchSequenceInformation(String sequenceName) throws SQLException {\n\t\treturn TransactionUtil.doWithJDBC(\n\t\t\t\tsessionFactory().getServiceRegistry(),\n\t\t\t\tconnection -> {\n\t\t\t\t\tJdbcEnvironment jdbcEnvironment = sessionFactory().getJdbcServices().getJdbcEnvironment();\n\t\t\t\t\tSequenceInformationExtractorOracleDatabaseImpl sequenceExtractor = SequenceInformationExtractorOracleDatabaseImpl.INSTANCE;\n\t\t\t\t\tIterable<SequenceInformation> sequenceInformations = sequenceExtractor.extractMetadata(\n\t\t\t\t\t\t\tnew ExtractionContext.EmptyExtractionContext() {\n\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic Connection getJdbcConnection() {\n\t\t\t\t\t\t\t\t\treturn connection;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n\t\t\t\t\t\t\t\t\treturn jdbcEnvironment;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t// lets skip system sequences\n\t\t\t\t\tOptional<SequenceInformation> foundSequence = StreamSupport.stream(\n\t\t\t\t\t\t\t\t\tsequenceInformations.spliterator(),\n\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.filter( sequence -> sequenceName.equals( sequence.getSequenceName()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .getSequenceName()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .getText()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .toUpperCase() ) )\n\t\t\t\t\t\t\t.findFirst();\n\n\t\t\t\t\tassertTrue( sequenceName + \" not found\", foundSequence.isPresent() );\n\n\t\t\t\t\treturn foundSequence.get();\n\t\t\t\t}\n\t\t);\n\t}",
        "filePathBefore": "hibernate-core/src/test/java/org/hibernate/orm/test/dialect/functional/OracleDialectSequenceInformationTest.java",
        "isPureRefactoring": true,
        "commitId": "72e42817e3759f3f130eefb302d9aa7a3e0cfa58",
        "packageNameBefore": "org.hibernate.orm.test.dialect.functional",
        "classNameBefore": "org.hibernate.orm.test.dialect.functional.OracleDialectSequenceInformationTest",
        "methodNameBefore": "org.hibernate.orm.test.dialect.functional.OracleDialectSequenceInformationTest#fetchSequenceInformation",
        "invokedMethod": "methodSignature: org.hibernate.query.results.implicit.ImplicitFetchBuilderEntity#equals\n methodBody: public boolean equals(Object o) {\nif(this == o){return true;\n}if(o == null || getClass() != o.getClass()){return false;\n}final ImplicitFetchBuilderEntity that=(ImplicitFetchBuilderEntity)o;\nreturn fetchPath.equals(that.fetchPath) && fetchable.equals(that.fetchable) && fetchBuilders.equals(that.fetchBuilders);\n}\nmethodSignature: org.hibernate.boot.beanvalidation.GroupsPerOperation#get\n methodBody: public Class<?>[] get(Operation operation) {\nreturn groupsPerOperation.get(operation);\n}\nmethodSignature: org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.TemporaryJdbcSessionOwner#getJdbcServices\n methodBody: public JdbcServices getJdbcServices() {\nreturn jdbcServices;\n}\nmethodSignature: org.hibernate.boot.model.relational.QualifiedNameParser.NameParts#equals\n methodBody: public boolean equals(Object o) {\nif(this == o){return true;\n}if(o == null || getClass() != o.getClass()){return false;\n}NameParts that=(NameParts)o;\nreturn Objects.equals(this.getCatalogName(),that.getCatalogName()) && Objects.equals(this.getSchemaName(),that.getSchemaName()) && Objects.equals(this.getObjectName(),that.getObjectName());\n}\nmethodSignature: org.hibernate.engine.jdbc.env.internal.ExtractedDatabaseMetaDataImpl#getJdbcEnvironment\n methodBody: public JdbcEnvironment getJdbcEnvironment() {\nreturn jdbcEnvironment;\n}\nmethodSignature: org.hibernate.metamodel.mapping.SelectablePath#equals\n methodBody: public boolean equals(Object o) {\nif(this == o){return true;\n}if(o == null || getClass() != o.getClass()){return false;\n}SelectablePath that=(SelectablePath)o;\nif(!Objects.equals(parent,that.parent)){return false;\n}return name.equals(that.name);\n}",
        "classSignatureBefore": "public class OracleDialectSequenceInformationTest extends BaseNonConfigCoreFunctionalTestCase ",
        "methodNameBeforeSet": [
            "org.hibernate.orm.test.dialect.functional.OracleDialectSequenceInformationTest#fetchSequenceInformation"
        ],
        "classNameBeforeSet": [
            "org.hibernate.orm.test.dialect.functional.OracleDialectSequenceInformationTest"
        ],
        "classSignatureBeforeSet": [
            "public class OracleDialectSequenceInformationTest extends BaseNonConfigCoreFunctionalTestCase "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.orm.test.dialect.functional;\n\nimport java.math.BigDecimal;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Optional;\nimport java.util.stream.StreamSupport;\n\nimport org.hibernate.dialect.OracleDialect;\nimport org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;\nimport org.hibernate.testing.RequiresDialect;\nimport org.hibernate.testing.TestForIssue;\nimport org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase;\nimport org.hibernate.testing.transaction.TransactionUtil;\n\nimport org.hibernate.tool.schema.extract.internal.SequenceInformationExtractorOracleDatabaseImpl;\nimport org.hibernate.tool.schema.extract.spi.ExtractionContext;\nimport org.hibernate.tool.schema.extract.spi.SequenceInformation;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.hibernate.testing.transaction.TransactionUtil.doInAutoCommit;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\n@RequiresDialect(OracleDialect.class)\n@TestForIssue(jiraKey = \"HHH-13694\")\npublic class OracleDialectSequenceInformationTest extends BaseNonConfigCoreFunctionalTestCase {\n\n\tprivate static final String MIN_SEQUENCE_NAME = \"SEQ_MIN_TEST\";\n\tprivate static final String MAX_SEQUENCE_NAME = \"SEQ_MAX_TEST\";\n\tprivate static final String MIN_VALUE = \"-99999999999999999999999999\";\n\tprivate static final String MAX_VALUE =  \"99999999999999999999999999\";\n\n\t@Before\n\tpublic void prepareTest() throws Exception {\n\t\tdoInAutoCommit(\n\t\t\t\t\"DROP SEQUENCE \" + MIN_SEQUENCE_NAME,\n\t\t\t\t\"CREATE SEQUENCE \" + MIN_SEQUENCE_NAME + \" MINVALUE \" + MIN_VALUE + \" MAXVALUE -1 INCREMENT BY -1\",\n\t\t\t\t\"DROP SEQUENCE \" + MAX_SEQUENCE_NAME,\n\t\t\t\t\"CREATE SEQUENCE \" + MAX_SEQUENCE_NAME + \" MINVALUE 0 MAXVALUE \" + MAX_VALUE + \" INCREMENT BY 1\" );\n\t}\n\n\t@After\n\tpublic void cleanupTest() throws Exception {\n\t\tdoInAutoCommit(\n\t\t\t\t\"DROP SEQUENCE \" + MIN_SEQUENCE_NAME,\n\t\t\t\t\"DROP SEQUENCE \" + MAX_SEQUENCE_NAME );\n\t}\n\n\t@Test\n\tpublic void testExtractSequenceWithMinValueLowerThanLongMinValue() throws SQLException {\n\t\tSequenceInformation sequence = fetchSequenceInformation( MIN_SEQUENCE_NAME );\n\n\t\tassertEquals( -1L, sequence.getIncrementValue().longValue() );\n\t\tassertEquals( new BigDecimal( MIN_VALUE ), sequence.getMinValue() );\n\t}\n\n\t@Test\n\tpublic void testExtractSequenceWithMaxValueGreaterThanLongMaxValue() throws SQLException {\n\t\tSequenceInformation sequence = fetchSequenceInformation( MAX_SEQUENCE_NAME );\n\n\t\tassertEquals( 1L, sequence.getIncrementValue().longValue() );\n\t\tassertEquals( new BigDecimal( MAX_VALUE ), sequence.getMaxValue() );\n\t}\n\n\tprivate SequenceInformation fetchSequenceInformation(String sequenceName) throws SQLException {\n\t\treturn TransactionUtil.doWithJDBC(\n\t\t\t\tsessionFactory().getServiceRegistry(),\n\t\t\t\tconnection -> {\n\t\t\t\t\tJdbcEnvironment jdbcEnvironment = sessionFactory().getJdbcServices().getJdbcEnvironment();\n\t\t\t\t\tSequenceInformationExtractorOracleDatabaseImpl sequenceExtractor = SequenceInformationExtractorOracleDatabaseImpl.INSTANCE;\n\t\t\t\t\tIterable<SequenceInformation> sequenceInformations = sequenceExtractor.extractMetadata(\n\t\t\t\t\t\t\tnew ExtractionContext.EmptyExtractionContext() {\n\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic Connection getJdbcConnection() {\n\t\t\t\t\t\t\t\t\treturn connection;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n\t\t\t\t\t\t\t\t\treturn jdbcEnvironment;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t// lets skip system sequences\n\t\t\t\t\tOptional<SequenceInformation> foundSequence = StreamSupport.stream(\n\t\t\t\t\t\t\t\t\tsequenceInformations.spliterator(),\n\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.filter( sequence -> sequenceName.equals( sequence.getSequenceName()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .getSequenceName()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .getText()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .toUpperCase() ) )\n\t\t\t\t\t\t\t.findFirst();\n\n\t\t\t\t\tassertTrue( sequenceName + \" not found\", foundSequence.isPresent() );\n\n\t\t\t\t\treturn foundSequence.get();\n\t\t\t\t}\n\t\t);\n\t}\n}",
        "filePathAfter": "hibernate-core/src/test/java/org/hibernate/orm/test/dialect/functional/OracleDialectSequenceInformationTest.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.orm.test.dialect.functional;\n\nimport java.math.BigDecimal;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Optional;\n\nimport org.hibernate.dialect.OracleDialect;\nimport org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;\nimport org.hibernate.testing.RequiresDialect;\nimport org.hibernate.testing.TestForIssue;\nimport org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase;\nimport org.hibernate.testing.transaction.TransactionUtil;\n\nimport org.hibernate.tool.schema.extract.internal.SequenceInformationExtractorOracleDatabaseImpl;\nimport org.hibernate.tool.schema.extract.spi.ExtractionContext;\nimport org.hibernate.tool.schema.extract.spi.SequenceInformation;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static java.util.stream.StreamSupport.stream;\nimport static org.hibernate.testing.transaction.TransactionUtil.doInAutoCommit;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\n@RequiresDialect(OracleDialect.class)\n@TestForIssue(jiraKey = \"HHH-13694\")\npublic class OracleDialectSequenceInformationTest extends BaseNonConfigCoreFunctionalTestCase {\n\n\tprivate static final String MIN_SEQUENCE_NAME = \"SEQ_MIN_TEST\";\n\tprivate static final String MAX_SEQUENCE_NAME = \"SEQ_MAX_TEST\";\n\tprivate static final String MIN_VALUE = \"-99999999999999999999999999\";\n\tprivate static final String MAX_VALUE =  \"99999999999999999999999999\";\n\n\t@Before\n\tpublic void prepareTest() throws Exception {\n\t\tdoInAutoCommit(\n\t\t\t\t\"DROP SEQUENCE \" + MIN_SEQUENCE_NAME,\n\t\t\t\t\"CREATE SEQUENCE \" + MIN_SEQUENCE_NAME + \" MINVALUE \" + MIN_VALUE + \" MAXVALUE -1 INCREMENT BY -1\",\n\t\t\t\t\"DROP SEQUENCE \" + MAX_SEQUENCE_NAME,\n\t\t\t\t\"CREATE SEQUENCE \" + MAX_SEQUENCE_NAME + \" MINVALUE 0 MAXVALUE \" + MAX_VALUE + \" INCREMENT BY 1\" );\n\t}\n\n\t@After\n\tpublic void cleanupTest() throws Exception {\n\t\tdoInAutoCommit(\n\t\t\t\t\"DROP SEQUENCE \" + MIN_SEQUENCE_NAME,\n\t\t\t\t\"DROP SEQUENCE \" + MAX_SEQUENCE_NAME );\n\t}\n\n\t@Test\n\tpublic void testExtractSequenceWithMinValueLowerThanLongMinValue() throws SQLException {\n\t\tSequenceInformation sequence = fetchSequenceInformation( MIN_SEQUENCE_NAME );\n\n\t\tassertEquals( -1L, sequence.getIncrementValue().longValue() );\n\t\tassertEquals( new BigDecimal( MIN_VALUE ), sequence.getMinValue() );\n\t}\n\n\t@Test\n\tpublic void testExtractSequenceWithMaxValueGreaterThanLongMaxValue() throws SQLException {\n\t\tSequenceInformation sequence = fetchSequenceInformation( MAX_SEQUENCE_NAME );\n\n\t\tassertEquals( 1L, sequence.getIncrementValue().longValue() );\n\t\tassertEquals( new BigDecimal( MAX_VALUE ), sequence.getMaxValue() );\n\t}\n\n\tprivate SequenceInformation fetchSequenceInformation(String sequenceName) throws SQLException {\n\t\treturn TransactionUtil.doWithJDBC(\n\t\t\t\tsessionFactory().getServiceRegistry(),\n\t\t\t\tconnection -> {\n\t\t\t\t\tfinal JdbcEnvironment jdbcEnvironment =\n\t\t\t\t\t\t\tsessionFactory().getJdbcServices().getJdbcEnvironment();\n\t\t\t\t\t// lets skip system sequences\n\t\t\t\t\tOptional<SequenceInformation> foundSequence =\n\t\t\t\t\t\t\tstream( sequenceInformation( connection, jdbcEnvironment ).spliterator(), false )\n\t\t\t\t\t\t\t.filter( sequence -> isSameSequence( sequenceName, sequence ) )\n\t\t\t\t\t\t\t.findFirst();\n\t\t\t\t\tassertTrue( sequenceName + \" not found\", foundSequence.isPresent() );\n\t\t\t\t\treturn foundSequence.get();\n\t\t\t\t}\n\t\t);\n\t}\n\n\tprivate static boolean isSameSequence(String sequenceName, SequenceInformation sequence) {\n\t\treturn sequenceName.equals( sequence.getSequenceName().getSequenceName().getText().toUpperCase() );\n\t}\n\n\tprivate static Iterable<SequenceInformation> sequenceInformation(Connection connection, JdbcEnvironment jdbcEnvironment)\n\t\t\tthrows SQLException {\n\t\treturn SequenceInformationExtractorOracleDatabaseImpl.INSTANCE.extractMetadata(\n\t\t\t\tnew ExtractionContext.EmptyExtractionContext() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Connection getJdbcConnection() {\n\t\t\t\t\t\treturn connection;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n\t\t\t\t\t\treturn jdbcEnvironment;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n}",
        "diffSourceCodeSet": [
            "private static boolean isSameSequence(String sequenceName, SequenceInformation sequence) {\n\t\treturn sequenceName.equals( sequence.getSequenceName().getSequenceName().getText().toUpperCase() );\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.query.results.implicit.ImplicitFetchBuilderEntity#equals\n methodBody: public boolean equals(Object o) {\nif(this == o){return true;\n}if(o == null || getClass() != o.getClass()){return false;\n}final ImplicitFetchBuilderEntity that=(ImplicitFetchBuilderEntity)o;\nreturn fetchPath.equals(that.fetchPath) && fetchable.equals(that.fetchable) && fetchBuilders.equals(that.fetchBuilders);\n}",
            "methodSignature: org.hibernate.boot.beanvalidation.GroupsPerOperation#get\n methodBody: public Class<?>[] get(Operation operation) {\nreturn groupsPerOperation.get(operation);\n}",
            "methodSignature: org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.TemporaryJdbcSessionOwner#getJdbcServices\n methodBody: public JdbcServices getJdbcServices() {\nreturn jdbcServices;\n}",
            "methodSignature: org.hibernate.boot.model.relational.QualifiedNameParser.NameParts#equals\n methodBody: public boolean equals(Object o) {\nif(this == o){return true;\n}if(o == null || getClass() != o.getClass()){return false;\n}NameParts that=(NameParts)o;\nreturn Objects.equals(this.getCatalogName(),that.getCatalogName()) && Objects.equals(this.getSchemaName(),that.getSchemaName()) && Objects.equals(this.getObjectName(),that.getObjectName());\n}",
            "methodSignature: org.hibernate.engine.jdbc.env.internal.ExtractedDatabaseMetaDataImpl#getJdbcEnvironment\n methodBody: public JdbcEnvironment getJdbcEnvironment() {\nreturn jdbcEnvironment;\n}",
            "methodSignature: org.hibernate.metamodel.mapping.SelectablePath#equals\n methodBody: public boolean equals(Object o) {\nif(this == o){return true;\n}if(o == null || getClass() != o.getClass()){return false;\n}SelectablePath that=(SelectablePath)o;\nif(!Objects.equals(parent,that.parent)){return false;\n}return name.equals(that.name);\n}"
        ],
        "sourceCodeAfterRefactoring": "private SequenceInformation fetchSequenceInformation(String sequenceName) throws SQLException {\n\t\treturn TransactionUtil.doWithJDBC(\n\t\t\t\tsessionFactory().getServiceRegistry(),\n\t\t\t\tconnection -> {\n\t\t\t\t\tfinal JdbcEnvironment jdbcEnvironment =\n\t\t\t\t\t\t\tsessionFactory().getJdbcServices().getJdbcEnvironment();\n\t\t\t\t\t// lets skip system sequences\n\t\t\t\t\tOptional<SequenceInformation> foundSequence =\n\t\t\t\t\t\t\tstream( sequenceInformation( connection, jdbcEnvironment ).spliterator(), false )\n\t\t\t\t\t\t\t.filter( sequence -> isSameSequence( sequenceName, sequence ) )\n\t\t\t\t\t\t\t.findFirst();\n\t\t\t\t\tassertTrue( sequenceName + \" not found\", foundSequence.isPresent() );\n\t\t\t\t\treturn foundSequence.get();\n\t\t\t\t}\n\t\t);\n\t}\nprivate static boolean isSameSequence(String sequenceName, SequenceInformation sequence) {\n\t\treturn sequenceName.equals( sequence.getSequenceName().getSequenceName().getText().toUpperCase() );\n\t}",
        "diffSourceCode": "    74: \tprivate SequenceInformation fetchSequenceInformation(String sequenceName) throws SQLException {\n    75: \t\treturn TransactionUtil.doWithJDBC(\n    76: \t\t\t\tsessionFactory().getServiceRegistry(),\n    77: \t\t\t\tconnection -> {\n-   78: \t\t\t\t\tJdbcEnvironment jdbcEnvironment = sessionFactory().getJdbcServices().getJdbcEnvironment();\n-   79: \t\t\t\t\tSequenceInformationExtractorOracleDatabaseImpl sequenceExtractor = SequenceInformationExtractorOracleDatabaseImpl.INSTANCE;\n-   80: \t\t\t\t\tIterable<SequenceInformation> sequenceInformations = sequenceExtractor.extractMetadata(\n-   81: \t\t\t\t\t\t\tnew ExtractionContext.EmptyExtractionContext() {\n-   82: \n-   83: \t\t\t\t\t\t\t\t@Override\n-   84: \t\t\t\t\t\t\t\tpublic Connection getJdbcConnection() {\n-   85: \t\t\t\t\t\t\t\t\treturn connection;\n-   86: \t\t\t\t\t\t\t\t}\n-   87: \n-   88: \t\t\t\t\t\t\t\t@Override\n-   89: \t\t\t\t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n-   90: \t\t\t\t\t\t\t\t\treturn jdbcEnvironment;\n-   91: \t\t\t\t\t\t\t\t}\n-   92: \t\t\t\t\t\t\t} );\n-   93: \n-   94: \t\t\t\t\t// lets skip system sequences\n-   95: \t\t\t\t\tOptional<SequenceInformation> foundSequence = StreamSupport.stream(\n-   96: \t\t\t\t\t\t\t\t\tsequenceInformations.spliterator(),\n-   97: \t\t\t\t\t\t\t\t\tfalse\n-   98: \t\t\t\t\t\t\t)\n-   99: \t\t\t\t\t\t\t.filter( sequence -> sequenceName.equals( sequence.getSequenceName()\n-  100: \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .getSequenceName()\n-  101: \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .getText()\n-  102: \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .toUpperCase() ) )\n-  103: \t\t\t\t\t\t\t.findFirst();\n-  104: \n-  105: \t\t\t\t\tassertTrue( sequenceName + \" not found\", foundSequence.isPresent() );\n-  106: \n-  107: \t\t\t\t\treturn foundSequence.get();\n+   78: \t\t\t\t\tfinal JdbcEnvironment jdbcEnvironment =\n+   79: \t\t\t\t\t\t\tsessionFactory().getJdbcServices().getJdbcEnvironment();\n+   80: \t\t\t\t\t// lets skip system sequences\n+   81: \t\t\t\t\tOptional<SequenceInformation> foundSequence =\n+   82: \t\t\t\t\t\t\tstream( sequenceInformation( connection, jdbcEnvironment ).spliterator(), false )\n+   83: \t\t\t\t\t\t\t.filter( sequence -> isSameSequence( sequenceName, sequence ) )\n+   84: \t\t\t\t\t\t\t.findFirst();\n+   85: \t\t\t\t\tassertTrue( sequenceName + \" not found\", foundSequence.isPresent() );\n+   86: \t\t\t\t\treturn foundSequence.get();\n+   87: \t\t\t\t}\n+   88: \t\t);\n+   89: \t}\n+   90: \n+   91: \tprivate static boolean isSameSequence(String sequenceName, SequenceInformation sequence) {\n+   92: \t\treturn sequenceName.equals( sequence.getSequenceName().getSequenceName().getText().toUpperCase() );\n+   93: \t}\n+   94: \n+   95: \tprivate static Iterable<SequenceInformation> sequenceInformation(Connection connection, JdbcEnvironment jdbcEnvironment)\n+   96: \t\t\tthrows SQLException {\n+   97: \t\treturn SequenceInformationExtractorOracleDatabaseImpl.INSTANCE.extractMetadata(\n+   98: \t\t\t\tnew ExtractionContext.EmptyExtractionContext() {\n+   99: \t\t\t\t\t@Override\n+  100: \t\t\t\t\tpublic Connection getJdbcConnection() {\n+  101: \t\t\t\t\t\treturn connection;\n+  102: \t\t\t\t\t}\n+  103: \n+  104: \t\t\t\t\t@Override\n+  105: \t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n+  106: \t\t\t\t\t\treturn jdbcEnvironment;\n+  107: \t\t\t\t\t}\n   108: \t\t\t\t}\n   109: \t\t);\n   110: \t}\n",
        "uniqueId": "72e42817e3759f3f130eefb302d9aa7a3e0cfa58_74_110_91_93_74_89",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": true,
        "compileAndTestResult": true,
        "refactoredCode": "##########################\nprivate SequenceInformation fetchSequenceInformation(String sequenceName) throws SQLException {\n    return TransactionUtil.doWithJDBC(\n            sessionFactory().getServiceRegistry(),\n            connection -> {\n                JdbcEnvironment jdbcEnvironment = sessionFactory().getJdbcServices().getJdbcEnvironment();\n                SequenceInformationExtractorOracleDatabaseImpl sequenceExtractor = SequenceInformationExtractorOracleDatabaseImpl.INSTANCE;\n                Iterable<SequenceInformation> sequenceInformations = sequenceExtractor.extractMetadata(\n                        new ExtractionContext.EmptyExtractionContext() {\n\n                            @Override\n                            public Connection getJdbcConnection() {\n                                return connection;\n                            }\n\n                            @Override\n                            public JdbcEnvironment getJdbcEnvironment() {\n                                return jdbcEnvironment;\n                            }\n                        });\n\n                Optional<SequenceInformation> foundSequence = findSequenceByName(sequenceInformations, sequenceName);\n\n                assertTrue(sequenceName + \" not found\", foundSequence.isPresent());\n\n                return foundSequence.get();\n            }\n    );\n}\n\nprivate Optional<SequenceInformation> findSequenceByName(Iterable<SequenceInformation> sequenceInformations, String sequenceName) {\n    return StreamSupport.stream(\n            sequenceInformations.spliterator(),\n            false\n    )\n            .filter(sequence -> sequenceName.equals(sequence.getSequenceName()\n                    .getSequenceName()\n                    .getText()\n                    .toUpperCase()))\n            .findFirst();\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprivate SequenceInformation fetchSequenceInformation(String sequenceName) throws SQLException {\n\t\treturn TransactionUtil.doWithJDBC(\n\t\t\t\tsessionFactory().getServiceRegistry(),\n\t\t\t\tconnection -> {\n\t\t\t\t\tJdbcEnvironment jdbcEnvironment = sessionFactory().getJdbcServices().getJdbcEnvironment();\n\t\t\t\t\tSequenceInformationExtractorOracleDatabaseImpl sequenceExtractor = SequenceInformationExtractorOracleDatabaseImpl.INSTANCE;\n\t\t\t\t\tIterable<SequenceInformation> sequenceInformations = sequenceExtractor.extractMetadata(\n\t\t\t\t\t\t\tnew ExtractionContext.EmptyExtractionContext() {\n\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic Connection getJdbcConnection() {\n\t\t\t\t\t\t\t\t\treturn connection;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n\t\t\t\t\t\t\t\t\treturn jdbcEnvironment;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t// lets skip system sequences\n\t\t\t\t\tOptional<SequenceInformation> foundSequence = StreamSupport.stream(\n\t\t\t\t\t\t\t\t\tsequenceInformations.spliterator(),\n\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.filter( sequence -> sequenceName.equals( sequence.getSequenceName()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .getSequenceName()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .getText()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .toUpperCase() ) )\n\t\t\t\t\t\t\t.findFirst();\n\n\t\t\t\t\tassertTrue( sequenceName + \" not found\", foundSequence.isPresent() );\n\n\t\t\t\t\treturn foundSequence.get();\n\t\t\t\t}\n\t\t);\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.orm.test.dialect.functional;\n\nimport java.math.BigDecimal;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Optional;\nimport java.util.stream.StreamSupport;\n\nimport org.hibernate.dialect.OracleDialect;\nimport org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;\nimport org.hibernate.testing.RequiresDialect;\nimport org.hibernate.testing.TestForIssue;\nimport org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase;\nimport org.hibernate.testing.transaction.TransactionUtil;\n\nimport org.hibernate.tool.schema.extract.internal.SequenceInformationExtractorOracleDatabaseImpl;\nimport org.hibernate.tool.schema.extract.spi.ExtractionContext;\nimport org.hibernate.tool.schema.extract.spi.SequenceInformation;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.hibernate.testing.transaction.TransactionUtil.doInAutoCommit;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\n@RequiresDialect(OracleDialect.class)\n@TestForIssue(jiraKey = \"HHH-13694\")\npublic class OracleDialectSequenceInformationTest extends BaseNonConfigCoreFunctionalTestCase {\n\n\tprivate static final String MIN_SEQUENCE_NAME = \"SEQ_MIN_TEST\";\n\tprivate static final String MAX_SEQUENCE_NAME = \"SEQ_MAX_TEST\";\n\tprivate static final String MIN_VALUE = \"-99999999999999999999999999\";\n\tprivate static final String MAX_VALUE =  \"99999999999999999999999999\";\n\n\t@Before\n\tpublic void prepareTest() throws Exception {\n\t\tdoInAutoCommit(\n\t\t\t\t\"DROP SEQUENCE \" + MIN_SEQUENCE_NAME,\n\t\t\t\t\"CREATE SEQUENCE \" + MIN_SEQUENCE_NAME + \" MINVALUE \" + MIN_VALUE + \" MAXVALUE -1 INCREMENT BY -1\",\n\t\t\t\t\"DROP SEQUENCE \" + MAX_SEQUENCE_NAME,\n\t\t\t\t\"CREATE SEQUENCE \" + MAX_SEQUENCE_NAME + \" MINVALUE 0 MAXVALUE \" + MAX_VALUE + \" INCREMENT BY 1\" );\n\t}\n\n\t@After\n\tpublic void cleanupTest() throws Exception {\n\t\tdoInAutoCommit(\n\t\t\t\t\"DROP SEQUENCE \" + MIN_SEQUENCE_NAME,\n\t\t\t\t\"DROP SEQUENCE \" + MAX_SEQUENCE_NAME );\n\t}\n\n\t@Test\n\tpublic void testExtractSequenceWithMinValueLowerThanLongMinValue() throws SQLException {\n\t\tSequenceInformation sequence = fetchSequenceInformation( MIN_SEQUENCE_NAME );\n\n\t\tassertEquals( -1L, sequence.getIncrementValue().longValue() );\n\t\tassertEquals( new BigDecimal( MIN_VALUE ), sequence.getMinValue() );\n\t}\n\n\t@Test\n\tpublic void testExtractSequenceWithMaxValueGreaterThanLongMaxValue() throws SQLException {\n\t\tSequenceInformation sequence = fetchSequenceInformation( MAX_SEQUENCE_NAME );\n\n\t\tassertEquals( 1L, sequence.getIncrementValue().longValue() );\n\t\tassertEquals( new BigDecimal( MAX_VALUE ), sequence.getMaxValue() );\n\t}\n\n\tprivate SequenceInformation fetchSequenceInformation(String sequenceName) throws SQLException {\n\t\treturn TransactionUtil.doWithJDBC(\n\t\t\t\tsessionFactory().getServiceRegistry(),\n\t\t\t\tconnection -> {\n\t\t\t\t\tJdbcEnvironment jdbcEnvironment = sessionFactory().getJdbcServices().getJdbcEnvironment();\n\t\t\t\t\tSequenceInformationExtractorOracleDatabaseImpl sequenceExtractor = SequenceInformationExtractorOracleDatabaseImpl.INSTANCE;\n\t\t\t\t\tIterable<SequenceInformation> sequenceInformations = sequenceExtractor.extractMetadata(\n\t\t\t\t\t\t\tnew ExtractionContext.EmptyExtractionContext() {\n\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic Connection getJdbcConnection() {\n\t\t\t\t\t\t\t\t\treturn connection;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n\t\t\t\t\t\t\t\t\treturn jdbcEnvironment;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t// lets skip system sequences\n\t\t\t\t\tOptional<SequenceInformation> foundSequence = StreamSupport.stream(\n\t\t\t\t\t\t\t\t\tsequenceInformations.spliterator(),\n\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.filter( sequence -> sequenceName.equals( sequence.getSequenceName()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .getSequenceName()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .getText()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .toUpperCase() ) )\n\t\t\t\t\t\t\t.findFirst();\n\n\t\t\t\t\tassertTrue( sequenceName + \" not found\", foundSequence.isPresent() );\n\n\t\t\t\t\treturn foundSequence.get();\n\t\t\t\t}\n\t\t);\n\t}\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate sequenceInformation(connection Connection, jdbcEnvironment JdbcEnvironment) : Iterable<SequenceInformation> extracted from private sequenceInformationList() : List<SequenceInformation> in class org.hibernate.engine.jdbc.env.internal.ExtractedDatabaseMetaDataImpl",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/env/internal/ExtractedDatabaseMetaDataImpl.java",
                "startLine": 276,
                "endLine": 319,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/env/internal/ExtractedDatabaseMetaDataImpl.java",
                "startLine": 270,
                "endLine": 295,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/env/internal/ExtractedDatabaseMetaDataImpl.java",
                "startLine": 297,
                "endLine": 311,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "/**\n\t * Get the sequence information List from the database.\n\t *\n\t * @return sequence information List\n\t */\n\tprivate List<SequenceInformation> sequenceInformationList() {\n\t\tfinal JdbcEnvironment jdbcEnvironment = this.jdbcEnvironment;\n\t\tfinal Dialect dialect = this.jdbcEnvironment.getDialect();\n\n\t\tConnection connection = null;\n\t\ttry {\n\t\t\tconnection = connectionAccess.obtainConnection();\n\t\t\tfinal Connection c = connection;\n\t\t\tIterable<SequenceInformation> sequenceInformationIterable = dialect\n\t\t\t\t\t.getSequenceInformationExtractor()\n\t\t\t\t\t.extractMetadata( new ExtractionContext.EmptyExtractionContext() {\n\t\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\t\tpublic Connection getJdbcConnection() {\n\t\t\t\t\t\t\t\t\t\t\treturn c;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n\t\t\t\t\t\t\t\t\t\t\treturn jdbcEnvironment;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\treturn StreamSupport.stream( sequenceInformationIterable.spliterator(), false )\n\t\t\t\t\t.collect( Collectors.toList() );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow new HibernateException( \"Could not fetch the SequenceInformation from the database\", e );\n\t\t}\n\t\tfinally {\n\t\t\tif ( connection != null ) {\n\t\t\t\ttry {\n\t\t\t\t\tconnectionAccess.releaseConnection( connection );\n\t\t\t\t}\n\t\t\t\tcatch (SQLException throwables) {\n\t\t\t\t\t//ignored\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/env/internal/ExtractedDatabaseMetaDataImpl.java",
        "isPureRefactoring": true,
        "commitId": "72e42817e3759f3f130eefb302d9aa7a3e0cfa58",
        "packageNameBefore": "org.hibernate.engine.jdbc.env.internal",
        "classNameBefore": "org.hibernate.engine.jdbc.env.internal.ExtractedDatabaseMetaDataImpl",
        "methodNameBefore": "org.hibernate.engine.jdbc.env.internal.ExtractedDatabaseMetaDataImpl#sequenceInformationList",
        "invokedMethod": "methodSignature: org.hibernate.dialect.H2Dialect#getSequenceInformationExtractor\n methodBody: public SequenceInformationExtractor getSequenceInformationExtractor() {\nreturn sequenceInformationExtractor;\n}\nmethodSignature: org.hibernate.community.dialect.H2LegacyDialect#getSequenceInformationExtractor\n methodBody: public SequenceInformationExtractor getSequenceInformationExtractor() {\nreturn sequenceInformationExtractor;\n}\nmethodSignature: org.hibernate.dialect.Dialect#getSequenceInformationExtractor\n methodBody: public SequenceInformationExtractor getSequenceInformationExtractor() {\nreturn getQuerySequencesString() == null ? SequenceInformationExtractorNoOpImpl.INSTANCE : SequenceInformationExtractorLegacyImpl.INSTANCE;\n}\nmethodSignature: org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.ConnectionProviderJdbcConnectionAccess#obtainConnection\n methodBody: public Connection obtainConnection() throws SQLException {\nreturn connectionProvider.getConnection();\n}\nmethodSignature: org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.MultiTenantConnectionProviderJdbcConnectionAccess#obtainConnection\n methodBody: public Connection obtainConnection() throws SQLException {\nreturn connectionProvider.getAnyConnection();\n}\nmethodSignature: org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.ConnectionProviderJdbcConnectionAccess#releaseConnection\n methodBody: public void releaseConnection(Connection connection) throws SQLException {\nconnectionProvider.closeConnection(connection);\n}\nmethodSignature: org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.MultiTenantConnectionProviderJdbcConnectionAccess#releaseConnection\n methodBody: public void releaseConnection(Connection connection) throws SQLException {\nconnectionProvider.releaseAnyConnection(connection);\n}",
        "classSignatureBefore": "public class ExtractedDatabaseMetaDataImpl implements ExtractedDatabaseMetaData ",
        "methodNameBeforeSet": [
            "org.hibernate.engine.jdbc.env.internal.ExtractedDatabaseMetaDataImpl#sequenceInformationList"
        ],
        "classNameBeforeSet": [
            "org.hibernate.engine.jdbc.env.internal.ExtractedDatabaseMetaDataImpl"
        ],
        "classSignatureBeforeSet": [
            "public class ExtractedDatabaseMetaDataImpl implements ExtractedDatabaseMetaData "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Overlapped refactoring - can be identical by undoing the overlapped refactoring\n- Inline Variable- Severe changes",
                "description": "Return expression has been added within the Extract Method mechanics - with non-mapped leaves",
                "mappingState": 2
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.env.internal;\n\nimport java.sql.Connection;\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.stream.StreamSupport;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.boot.model.source.internal.hbm.CommaSeparatedStringHelper;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.connections.spi.JdbcConnectionAccess;\nimport org.hibernate.engine.jdbc.cursor.internal.StandardRefCursorSupport;\nimport org.hibernate.engine.jdbc.env.spi.ExtractedDatabaseMetaData;\nimport org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;\nimport org.hibernate.engine.jdbc.env.spi.SQLStateType;\nimport org.hibernate.tool.schema.extract.spi.ExtractionContext;\nimport org.hibernate.tool.schema.extract.spi.SequenceInformation;\n\n/**\n * Standard implementation of ExtractedDatabaseMetaData\n *\n * @author Steve Ebersole\n */\npublic class ExtractedDatabaseMetaDataImpl implements ExtractedDatabaseMetaData {\n\n\tprivate final JdbcEnvironment jdbcEnvironment;\n\tprivate final JdbcConnectionAccess connectionAccess;\n\n\tprivate final String connectionCatalogName;\n\tprivate final String connectionSchemaName;\n\n\tprivate final boolean supportsRefCursors;\n\tprivate final boolean supportsNamedParameters;\n\tprivate final boolean supportsScrollableResults;\n\tprivate final boolean supportsGetGeneratedKeys;\n\tprivate final boolean supportsBatchUpdates;\n\tprivate final boolean supportsDataDefinitionInTransaction;\n\tprivate final boolean doesDataDefinitionCauseTransactionCommit;\n\tprivate final SQLStateType sqlStateType;\n\tprivate final boolean jdbcMetadataAccessible;\n\n\n\t//Lazily initialized: loading all sequence information upfront has been\n\t//shown to be too slow in some cases. In this way we only load it\n\t//when there is actual need for these details.\n\tprivate List<SequenceInformation> sequenceInformationList;\n\n\tprivate ExtractedDatabaseMetaDataImpl(\n\t\t\tJdbcEnvironment jdbcEnvironment,\n\t\t\tJdbcConnectionAccess connectionAccess,\n\t\t\tString connectionCatalogName,\n\t\t\tString connectionSchemaName,\n\t\t\tboolean supportsRefCursors,\n\t\t\tboolean supportsNamedParameters,\n\t\t\tboolean supportsScrollableResults,\n\t\t\tboolean supportsGetGeneratedKeys,\n\t\t\tboolean supportsBatchUpdates,\n\t\t\tboolean supportsDataDefinitionInTransaction,\n\t\t\tboolean doesDataDefinitionCauseTransactionCommit,\n\t\t\tSQLStateType sqlStateType,\n\t\t\tboolean jdbcMetadataIsAccessible) {\n\t\tthis.jdbcEnvironment = jdbcEnvironment;\n\t\tthis.connectionAccess = connectionAccess;\n\t\tthis.connectionCatalogName = connectionCatalogName;\n\t\tthis.connectionSchemaName = connectionSchemaName;\n\t\tthis.supportsRefCursors = supportsRefCursors;\n\t\tthis.supportsNamedParameters = supportsNamedParameters;\n\t\tthis.supportsScrollableResults = supportsScrollableResults;\n\t\tthis.supportsGetGeneratedKeys = supportsGetGeneratedKeys;\n\t\tthis.supportsBatchUpdates = supportsBatchUpdates;\n\t\tthis.supportsDataDefinitionInTransaction = supportsDataDefinitionInTransaction;\n\t\tthis.doesDataDefinitionCauseTransactionCommit = doesDataDefinitionCauseTransactionCommit;\n\t\tthis.sqlStateType = sqlStateType;\n\t\tthis.jdbcMetadataAccessible = jdbcMetadataIsAccessible;\n\t}\n\n\t@Override\n\tpublic boolean supportsRefCursors() {\n\t\treturn supportsRefCursors;\n\t}\n\n\t@Override\n\tpublic JdbcEnvironment getJdbcEnvironment() {\n\t\treturn jdbcEnvironment;\n\t}\n\n\t@Override\n\tpublic boolean supportsNamedParameters() {\n\t\treturn supportsNamedParameters;\n\t}\n\n\t@Override\n\tpublic boolean supportsScrollableResults() {\n\t\treturn supportsScrollableResults;\n\t}\n\n\t@Override\n\tpublic boolean supportsGetGeneratedKeys() {\n\t\treturn supportsGetGeneratedKeys;\n\t}\n\n\t@Override\n\tpublic boolean supportsBatchUpdates() {\n\t\treturn supportsBatchUpdates;\n\t}\n\n\t@Override\n\tpublic boolean supportsDataDefinitionInTransaction() {\n\t\treturn supportsDataDefinitionInTransaction;\n\t}\n\n\t@Override\n\tpublic boolean doesDataDefinitionCauseTransactionCommit() {\n\t\treturn doesDataDefinitionCauseTransactionCommit;\n\t}\n\n\t@Override\n\tpublic SQLStateType getSqlStateType() {\n\t\treturn sqlStateType;\n\t}\n\n\t@Override\n\tpublic String getConnectionCatalogName() {\n\t\treturn connectionCatalogName;\n\t}\n\n\t@Override\n\tpublic String getConnectionSchemaName() {\n\t\treturn connectionSchemaName;\n\t}\n\n\t@Override\n\tpublic synchronized List<SequenceInformation> getSequenceInformationList() {\n\t\tif ( jdbcMetadataAccessible ) {\n\t\t\t//Loading the sequence information can take a while on large databases,\n\t\t\t//even minutes in some cases.\n\t\t\t//We trigger this lazily as only certain combinations of configurations,\n\t\t\t//mappings and used features actually trigger any use of such details.\n\t\t\tif ( sequenceInformationList == null ) {\n\t\t\t\tsequenceInformationList = sequenceInformationList();\n\t\t\t}\n\t\t\treturn sequenceInformationList;\n\t\t}\n\t\telse {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t}\n\n\t// For tests\n\tpublic boolean isJdbcMetadataAccessible() {\n\t\treturn jdbcMetadataAccessible;\n\t}\n\n\tpublic static class Builder {\n\t\tprivate final JdbcEnvironment jdbcEnvironment;\n\t\tprivate final boolean jdbcMetadataIsAccessible;\n\t\tprivate final JdbcConnectionAccess connectionAccess;\n\n\t\tprivate String connectionSchemaName;\n\t\tprivate String connectionCatalogName;\n\n\t\tprivate boolean supportsRefCursors;\n\t\tprivate boolean supportsNamedParameters;\n\t\tprivate boolean supportsScrollableResults;\n\t\tprivate boolean supportsGetGeneratedKeys;\n\t\t// In absence of DatabaseMetaData batching updates is assumed to be supported\n\t\tprivate boolean supportsBatchUpdates = true;\n\t\tprivate boolean supportsDataDefinitionInTransaction;\n\t\tprivate boolean doesDataDefinitionCauseTransactionCommit;\n\t\tprivate SQLStateType sqlStateType;\n\n\t\tpublic Builder(JdbcEnvironment jdbcEnvironment, boolean jdbcMetadataIsAccessible, JdbcConnectionAccess connectionAccess) {\n\t\t\tthis.jdbcEnvironment = jdbcEnvironment;\n\t\t\tthis.jdbcMetadataIsAccessible = jdbcMetadataIsAccessible;\n\t\t\tthis.connectionAccess = connectionAccess;\n\t\t}\n\n\t\tpublic Builder apply(DatabaseMetaData databaseMetaData) throws SQLException {\n\t\t\tconnectionCatalogName = databaseMetaData.getConnection().getCatalog();\n\t\t\t// NOTE : databaseMetaData.getConnection().getSchema() would require java 1.7 as baseline\n\t\t\tsupportsRefCursors = StandardRefCursorSupport.supportsRefCursors( databaseMetaData );\n\t\t\tsupportsNamedParameters = databaseMetaData.supportsNamedParameters();\n\t\t\tsupportsScrollableResults = databaseMetaData.supportsResultSetType( ResultSet.TYPE_SCROLL_INSENSITIVE );\n\t\t\tsupportsGetGeneratedKeys = databaseMetaData.supportsGetGeneratedKeys();\n\t\t\tsupportsBatchUpdates = databaseMetaData.supportsBatchUpdates();\n\t\t\tsupportsDataDefinitionInTransaction = !databaseMetaData.dataDefinitionIgnoredInTransactions();\n\t\t\tdoesDataDefinitionCauseTransactionCommit = databaseMetaData.dataDefinitionCausesTransactionCommit();\n\t\t\tsqlStateType = SQLStateType.interpretReportedSQLStateType( databaseMetaData.getSQLStateType() );\n\t\t\treturn this;\n\t\t}\n\n\t\tprivate Set<String> parseKeywords(String extraKeywordsString) {\n\t\t\treturn CommaSeparatedStringHelper.split( extraKeywordsString );\n\t\t}\n\n\t\tpublic Builder setConnectionSchemaName(String connectionSchemaName) {\n\t\t\tthis.connectionSchemaName = connectionSchemaName;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setConnectionCatalogName(String connectionCatalogName) {\n\t\t\tthis.connectionCatalogName = connectionCatalogName;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setSupportsRefCursors(boolean supportsRefCursors) {\n\t\t\tthis.supportsRefCursors = supportsRefCursors;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setSupportsNamedParameters(boolean supportsNamedParameters) {\n\t\t\tthis.supportsNamedParameters = supportsNamedParameters;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setSupportsScrollableResults(boolean supportsScrollableResults) {\n\t\t\tthis.supportsScrollableResults = supportsScrollableResults;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setSupportsGetGeneratedKeys(boolean supportsGetGeneratedKeys) {\n\t\t\tthis.supportsGetGeneratedKeys = supportsGetGeneratedKeys;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setSupportsBatchUpdates(boolean supportsBatchUpdates) {\n\t\t\tthis.supportsBatchUpdates = supportsBatchUpdates;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setSupportsDataDefinitionInTransaction(boolean supportsDataDefinitionInTransaction) {\n\t\t\tthis.supportsDataDefinitionInTransaction = supportsDataDefinitionInTransaction;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setDoesDataDefinitionCauseTransactionCommit(boolean doesDataDefinitionCauseTransactionCommit) {\n\t\t\tthis.doesDataDefinitionCauseTransactionCommit = doesDataDefinitionCauseTransactionCommit;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setSqlStateType(SQLStateType sqlStateType) {\n\t\t\tthis.sqlStateType = sqlStateType;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ExtractedDatabaseMetaDataImpl build() {\n\t\t\treturn new ExtractedDatabaseMetaDataImpl(\n\t\t\t\t\tjdbcEnvironment,\n\t\t\t\t\tconnectionAccess,\n\t\t\t\t\tconnectionCatalogName,\n\t\t\t\t\tconnectionSchemaName,\n\t\t\t\t\tsupportsRefCursors,\n\t\t\t\t\tsupportsNamedParameters,\n\t\t\t\t\tsupportsScrollableResults,\n\t\t\t\t\tsupportsGetGeneratedKeys,\n\t\t\t\t\tsupportsBatchUpdates,\n\t\t\t\t\tsupportsDataDefinitionInTransaction,\n\t\t\t\t\tdoesDataDefinitionCauseTransactionCommit,\n\t\t\t\t\tsqlStateType,\n\t\t\t\t\tjdbcMetadataIsAccessible\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Get the sequence information List from the database.\n\t *\n\t * @return sequence information List\n\t */\n\tprivate List<SequenceInformation> sequenceInformationList() {\n\t\tfinal JdbcEnvironment jdbcEnvironment = this.jdbcEnvironment;\n\t\tfinal Dialect dialect = this.jdbcEnvironment.getDialect();\n\n\t\tConnection connection = null;\n\t\ttry {\n\t\t\tconnection = connectionAccess.obtainConnection();\n\t\t\tfinal Connection c = connection;\n\t\t\tIterable<SequenceInformation> sequenceInformationIterable = dialect\n\t\t\t\t\t.getSequenceInformationExtractor()\n\t\t\t\t\t.extractMetadata( new ExtractionContext.EmptyExtractionContext() {\n\t\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\t\tpublic Connection getJdbcConnection() {\n\t\t\t\t\t\t\t\t\t\t\treturn c;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n\t\t\t\t\t\t\t\t\t\t\treturn jdbcEnvironment;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\treturn StreamSupport.stream( sequenceInformationIterable.spliterator(), false )\n\t\t\t\t\t.collect( Collectors.toList() );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow new HibernateException( \"Could not fetch the SequenceInformation from the database\", e );\n\t\t}\n\t\tfinally {\n\t\t\tif ( connection != null ) {\n\t\t\t\ttry {\n\t\t\t\t\tconnectionAccess.releaseConnection( connection );\n\t\t\t\t}\n\t\t\t\tcatch (SQLException throwables) {\n\t\t\t\t\t//ignored\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/env/internal/ExtractedDatabaseMetaDataImpl.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.env.internal;\n\nimport java.sql.Connection;\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.engine.jdbc.connections.spi.JdbcConnectionAccess;\nimport org.hibernate.engine.jdbc.cursor.internal.StandardRefCursorSupport;\nimport org.hibernate.engine.jdbc.env.spi.ExtractedDatabaseMetaData;\nimport org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;\nimport org.hibernate.engine.jdbc.env.spi.SQLStateType;\nimport org.hibernate.tool.schema.extract.spi.ExtractionContext;\nimport org.hibernate.tool.schema.extract.spi.SequenceInformation;\n\nimport static java.util.stream.StreamSupport.stream;\n\n/**\n * Standard implementation of ExtractedDatabaseMetaData\n *\n * @author Steve Ebersole\n */\npublic class ExtractedDatabaseMetaDataImpl implements ExtractedDatabaseMetaData {\n\n\tprivate final JdbcEnvironment jdbcEnvironment;\n\tprivate final JdbcConnectionAccess connectionAccess;\n\n\tprivate final String connectionCatalogName;\n\tprivate final String connectionSchemaName;\n\n\tprivate final boolean supportsRefCursors;\n\tprivate final boolean supportsNamedParameters;\n\tprivate final boolean supportsScrollableResults;\n\tprivate final boolean supportsGetGeneratedKeys;\n\tprivate final boolean supportsBatchUpdates;\n\tprivate final boolean supportsDataDefinitionInTransaction;\n\tprivate final boolean doesDataDefinitionCauseTransactionCommit;\n\tprivate final SQLStateType sqlStateType;\n\tprivate final boolean jdbcMetadataAccessible;\n\n\n\t//Lazily initialized: loading all sequence information upfront has been\n\t//shown to be too slow in some cases. In this way we only load it\n\t//when there is actual need for these details.\n\tprivate List<SequenceInformation> sequenceInformationList;\n\n\tprivate ExtractedDatabaseMetaDataImpl(\n\t\t\tJdbcEnvironment jdbcEnvironment,\n\t\t\tJdbcConnectionAccess connectionAccess,\n\t\t\tString connectionCatalogName,\n\t\t\tString connectionSchemaName,\n\t\t\tboolean supportsRefCursors,\n\t\t\tboolean supportsNamedParameters,\n\t\t\tboolean supportsScrollableResults,\n\t\t\tboolean supportsGetGeneratedKeys,\n\t\t\tboolean supportsBatchUpdates,\n\t\t\tboolean supportsDataDefinitionInTransaction,\n\t\t\tboolean doesDataDefinitionCauseTransactionCommit,\n\t\t\tSQLStateType sqlStateType,\n\t\t\tboolean jdbcMetadataIsAccessible) {\n\t\tthis.jdbcEnvironment = jdbcEnvironment;\n\t\tthis.connectionAccess = connectionAccess;\n\t\tthis.connectionCatalogName = connectionCatalogName;\n\t\tthis.connectionSchemaName = connectionSchemaName;\n\t\tthis.supportsRefCursors = supportsRefCursors;\n\t\tthis.supportsNamedParameters = supportsNamedParameters;\n\t\tthis.supportsScrollableResults = supportsScrollableResults;\n\t\tthis.supportsGetGeneratedKeys = supportsGetGeneratedKeys;\n\t\tthis.supportsBatchUpdates = supportsBatchUpdates;\n\t\tthis.supportsDataDefinitionInTransaction = supportsDataDefinitionInTransaction;\n\t\tthis.doesDataDefinitionCauseTransactionCommit = doesDataDefinitionCauseTransactionCommit;\n\t\tthis.sqlStateType = sqlStateType;\n\t\tthis.jdbcMetadataAccessible = jdbcMetadataIsAccessible;\n\t}\n\n\t@Override\n\tpublic boolean supportsRefCursors() {\n\t\treturn supportsRefCursors;\n\t}\n\n\t@Override\n\tpublic JdbcEnvironment getJdbcEnvironment() {\n\t\treturn jdbcEnvironment;\n\t}\n\n\t@Override\n\tpublic boolean supportsNamedParameters() {\n\t\treturn supportsNamedParameters;\n\t}\n\n\t@Override\n\tpublic boolean supportsScrollableResults() {\n\t\treturn supportsScrollableResults;\n\t}\n\n\t@Override\n\tpublic boolean supportsGetGeneratedKeys() {\n\t\treturn supportsGetGeneratedKeys;\n\t}\n\n\t@Override\n\tpublic boolean supportsBatchUpdates() {\n\t\treturn supportsBatchUpdates;\n\t}\n\n\t@Override\n\tpublic boolean supportsDataDefinitionInTransaction() {\n\t\treturn supportsDataDefinitionInTransaction;\n\t}\n\n\t@Override\n\tpublic boolean doesDataDefinitionCauseTransactionCommit() {\n\t\treturn doesDataDefinitionCauseTransactionCommit;\n\t}\n\n\t@Override\n\tpublic SQLStateType getSqlStateType() {\n\t\treturn sqlStateType;\n\t}\n\n\t@Override\n\tpublic String getConnectionCatalogName() {\n\t\treturn connectionCatalogName;\n\t}\n\n\t@Override\n\tpublic String getConnectionSchemaName() {\n\t\treturn connectionSchemaName;\n\t}\n\n\t@Override\n\tpublic synchronized List<SequenceInformation> getSequenceInformationList() {\n\t\tif ( jdbcMetadataAccessible ) {\n\t\t\t//Loading the sequence information can take a while on large databases,\n\t\t\t//even minutes in some cases.\n\t\t\t//We trigger this lazily as only certain combinations of configurations,\n\t\t\t//mappings and used features actually trigger any use of such details.\n\t\t\tif ( sequenceInformationList == null ) {\n\t\t\t\tsequenceInformationList = sequenceInformationList();\n\t\t\t}\n\t\t\treturn sequenceInformationList;\n\t\t}\n\t\telse {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t}\n\n\t// For tests\n\tpublic boolean isJdbcMetadataAccessible() {\n\t\treturn jdbcMetadataAccessible;\n\t}\n\n\tpublic static class Builder {\n\t\tprivate final JdbcEnvironment jdbcEnvironment;\n\t\tprivate final boolean jdbcMetadataIsAccessible;\n\t\tprivate final JdbcConnectionAccess connectionAccess;\n\n\t\tprivate String connectionSchemaName;\n\t\tprivate String connectionCatalogName;\n\n\t\tprivate boolean supportsRefCursors;\n\t\tprivate boolean supportsNamedParameters;\n\t\tprivate boolean supportsScrollableResults;\n\t\tprivate boolean supportsGetGeneratedKeys;\n\t\t// In absence of DatabaseMetaData batching updates is assumed to be supported\n\t\tprivate boolean supportsBatchUpdates = true;\n\t\tprivate boolean supportsDataDefinitionInTransaction;\n\t\tprivate boolean doesDataDefinitionCauseTransactionCommit;\n\t\tprivate SQLStateType sqlStateType;\n\n\t\tpublic Builder(JdbcEnvironment jdbcEnvironment, boolean jdbcMetadataIsAccessible, JdbcConnectionAccess connectionAccess) {\n\t\t\tthis.jdbcEnvironment = jdbcEnvironment;\n\t\t\tthis.jdbcMetadataIsAccessible = jdbcMetadataIsAccessible;\n\t\t\tthis.connectionAccess = connectionAccess;\n\t\t}\n\n\t\tpublic Builder apply(DatabaseMetaData databaseMetaData) throws SQLException {\n\t\t\tconnectionCatalogName = databaseMetaData.getConnection().getCatalog();\n\t\t\t// NOTE : databaseMetaData.getConnection().getSchema() would require java 1.7 as baseline\n\t\t\tsupportsRefCursors = StandardRefCursorSupport.supportsRefCursors( databaseMetaData );\n\t\t\tsupportsNamedParameters = databaseMetaData.supportsNamedParameters();\n\t\t\tsupportsScrollableResults = databaseMetaData.supportsResultSetType( ResultSet.TYPE_SCROLL_INSENSITIVE );\n\t\t\tsupportsGetGeneratedKeys = databaseMetaData.supportsGetGeneratedKeys();\n\t\t\tsupportsBatchUpdates = databaseMetaData.supportsBatchUpdates();\n\t\t\tsupportsDataDefinitionInTransaction = !databaseMetaData.dataDefinitionIgnoredInTransactions();\n\t\t\tdoesDataDefinitionCauseTransactionCommit = databaseMetaData.dataDefinitionCausesTransactionCommit();\n\t\t\tsqlStateType = SQLStateType.interpretReportedSQLStateType( databaseMetaData.getSQLStateType() );\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setConnectionSchemaName(String connectionSchemaName) {\n\t\t\tthis.connectionSchemaName = connectionSchemaName;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setConnectionCatalogName(String connectionCatalogName) {\n\t\t\tthis.connectionCatalogName = connectionCatalogName;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setSupportsRefCursors(boolean supportsRefCursors) {\n\t\t\tthis.supportsRefCursors = supportsRefCursors;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setSupportsNamedParameters(boolean supportsNamedParameters) {\n\t\t\tthis.supportsNamedParameters = supportsNamedParameters;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setSupportsScrollableResults(boolean supportsScrollableResults) {\n\t\t\tthis.supportsScrollableResults = supportsScrollableResults;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setSupportsGetGeneratedKeys(boolean supportsGetGeneratedKeys) {\n\t\t\tthis.supportsGetGeneratedKeys = supportsGetGeneratedKeys;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setSupportsBatchUpdates(boolean supportsBatchUpdates) {\n\t\t\tthis.supportsBatchUpdates = supportsBatchUpdates;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setSupportsDataDefinitionInTransaction(boolean supportsDataDefinitionInTransaction) {\n\t\t\tthis.supportsDataDefinitionInTransaction = supportsDataDefinitionInTransaction;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setDoesDataDefinitionCauseTransactionCommit(boolean doesDataDefinitionCauseTransactionCommit) {\n\t\t\tthis.doesDataDefinitionCauseTransactionCommit = doesDataDefinitionCauseTransactionCommit;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setSqlStateType(SQLStateType sqlStateType) {\n\t\t\tthis.sqlStateType = sqlStateType;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ExtractedDatabaseMetaDataImpl build() {\n\t\t\treturn new ExtractedDatabaseMetaDataImpl(\n\t\t\t\t\tjdbcEnvironment,\n\t\t\t\t\tconnectionAccess,\n\t\t\t\t\tconnectionCatalogName,\n\t\t\t\t\tconnectionSchemaName,\n\t\t\t\t\tsupportsRefCursors,\n\t\t\t\t\tsupportsNamedParameters,\n\t\t\t\t\tsupportsScrollableResults,\n\t\t\t\t\tsupportsGetGeneratedKeys,\n\t\t\t\t\tsupportsBatchUpdates,\n\t\t\t\t\tsupportsDataDefinitionInTransaction,\n\t\t\t\t\tdoesDataDefinitionCauseTransactionCommit,\n\t\t\t\t\tsqlStateType,\n\t\t\t\t\tjdbcMetadataIsAccessible\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Get the sequence information List from the database.\n\t *\n\t * @return sequence information List\n\t */\n\tprivate List<SequenceInformation> sequenceInformationList() {\n\t\tConnection connection = null;\n\t\ttry {\n\t\t\tconnection = connectionAccess.obtainConnection();\n\t\t\treturn stream( sequenceInformation( connection, jdbcEnvironment ).spliterator(), false )\n\t\t\t\t\t.collect( Collectors.toList() );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow new HibernateException( \"Could not fetch the SequenceInformation from the database\", e );\n\t\t}\n\t\tfinally {\n\t\t\tif ( connection != null ) {\n\t\t\t\ttry {\n\t\t\t\t\tconnectionAccess.releaseConnection( connection );\n\t\t\t\t}\n\t\t\t\tcatch (SQLException exception) {\n\t\t\t\t\t//ignored\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static Iterable<SequenceInformation> sequenceInformation(Connection connection, JdbcEnvironment jdbcEnvironment)\n\t\t\tthrows SQLException {\n\t\treturn jdbcEnvironment.getDialect().getSequenceInformationExtractor().extractMetadata(\n\t\t\t\tnew ExtractionContext.EmptyExtractionContext() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Connection getJdbcConnection() {\n\t\t\t\t\t\treturn connection;\n\t\t\t\t\t}\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n\t\t\t\t\t\treturn jdbcEnvironment;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private static Iterable<SequenceInformation> sequenceInformation(Connection connection, JdbcEnvironment jdbcEnvironment)\n\t\t\tthrows SQLException {\n\t\treturn jdbcEnvironment.getDialect().getSequenceInformationExtractor().extractMetadata(\n\t\t\t\tnew ExtractionContext.EmptyExtractionContext() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Connection getJdbcConnection() {\n\t\t\t\t\t\treturn connection;\n\t\t\t\t\t}\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n\t\t\t\t\t\treturn jdbcEnvironment;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.dialect.H2Dialect#getSequenceInformationExtractor\n methodBody: public SequenceInformationExtractor getSequenceInformationExtractor() {\nreturn sequenceInformationExtractor;\n}",
            "methodSignature: org.hibernate.community.dialect.H2LegacyDialect#getSequenceInformationExtractor\n methodBody: public SequenceInformationExtractor getSequenceInformationExtractor() {\nreturn sequenceInformationExtractor;\n}",
            "methodSignature: org.hibernate.dialect.Dialect#getSequenceInformationExtractor\n methodBody: public SequenceInformationExtractor getSequenceInformationExtractor() {\nreturn getQuerySequencesString() == null ? SequenceInformationExtractorNoOpImpl.INSTANCE : SequenceInformationExtractorLegacyImpl.INSTANCE;\n}",
            "methodSignature: org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.ConnectionProviderJdbcConnectionAccess#obtainConnection\n methodBody: public Connection obtainConnection() throws SQLException {\nreturn connectionProvider.getConnection();\n}",
            "methodSignature: org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.MultiTenantConnectionProviderJdbcConnectionAccess#obtainConnection\n methodBody: public Connection obtainConnection() throws SQLException {\nreturn connectionProvider.getAnyConnection();\n}",
            "methodSignature: org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.ConnectionProviderJdbcConnectionAccess#releaseConnection\n methodBody: public void releaseConnection(Connection connection) throws SQLException {\nconnectionProvider.closeConnection(connection);\n}",
            "methodSignature: org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator.MultiTenantConnectionProviderJdbcConnectionAccess#releaseConnection\n methodBody: public void releaseConnection(Connection connection) throws SQLException {\nconnectionProvider.releaseAnyConnection(connection);\n}"
        ],
        "sourceCodeAfterRefactoring": "/**\n\t * Get the sequence information List from the database.\n\t *\n\t * @return sequence information List\n\t */\n\tprivate List<SequenceInformation> sequenceInformationList() {\n\t\tConnection connection = null;\n\t\ttry {\n\t\t\tconnection = connectionAccess.obtainConnection();\n\t\t\treturn stream( sequenceInformation( connection, jdbcEnvironment ).spliterator(), false )\n\t\t\t\t\t.collect( Collectors.toList() );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow new HibernateException( \"Could not fetch the SequenceInformation from the database\", e );\n\t\t}\n\t\tfinally {\n\t\t\tif ( connection != null ) {\n\t\t\t\ttry {\n\t\t\t\t\tconnectionAccess.releaseConnection( connection );\n\t\t\t\t}\n\t\t\t\tcatch (SQLException exception) {\n\t\t\t\t\t//ignored\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nprivate static Iterable<SequenceInformation> sequenceInformation(Connection connection, JdbcEnvironment jdbcEnvironment)\n\t\t\tthrows SQLException {\n\t\treturn jdbcEnvironment.getDialect().getSequenceInformationExtractor().extractMetadata(\n\t\t\t\tnew ExtractionContext.EmptyExtractionContext() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Connection getJdbcConnection() {\n\t\t\t\t\t\treturn connection;\n\t\t\t\t\t}\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n\t\t\t\t\t\treturn jdbcEnvironment;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}",
        "diffSourceCode": "-  270: \t\t\t\t\tsqlStateType,\n-  271: \t\t\t\t\tjdbcMetadataIsAccessible\n-  272: \t\t\t);\n-  273: \t\t}\n-  274: \t}\n-  275: \n-  276: \t/**\n-  277: \t * Get the sequence information List from the database.\n-  278: \t *\n-  279: \t * @return sequence information List\n-  280: \t */\n-  281: \tprivate List<SequenceInformation> sequenceInformationList() {\n-  282: \t\tfinal JdbcEnvironment jdbcEnvironment = this.jdbcEnvironment;\n-  283: \t\tfinal Dialect dialect = this.jdbcEnvironment.getDialect();\n-  284: \n-  285: \t\tConnection connection = null;\n-  286: \t\ttry {\n-  287: \t\t\tconnection = connectionAccess.obtainConnection();\n-  288: \t\t\tfinal Connection c = connection;\n-  289: \t\t\tIterable<SequenceInformation> sequenceInformationIterable = dialect\n-  290: \t\t\t\t\t.getSequenceInformationExtractor()\n-  291: \t\t\t\t\t.extractMetadata( new ExtractionContext.EmptyExtractionContext() {\n-  292: \t\t\t\t\t\t\t\t\t\t@Override\n-  293: \t\t\t\t\t\t\t\t\t\tpublic Connection getJdbcConnection() {\n-  294: \t\t\t\t\t\t\t\t\t\t\treturn c;\n-  295: \t\t\t\t\t\t\t\t\t\t}\n+  270: \t/**\n+  271: \t * Get the sequence information List from the database.\n+  272: \t *\n+  273: \t * @return sequence information List\n+  274: \t */\n+  275: \tprivate List<SequenceInformation> sequenceInformationList() {\n+  276: \t\tConnection connection = null;\n+  277: \t\ttry {\n+  278: \t\t\tconnection = connectionAccess.obtainConnection();\n+  279: \t\t\treturn stream( sequenceInformation( connection, jdbcEnvironment ).spliterator(), false )\n+  280: \t\t\t\t\t.collect( Collectors.toList() );\n+  281: \t\t}\n+  282: \t\tcatch (SQLException e) {\n+  283: \t\t\tthrow new HibernateException( \"Could not fetch the SequenceInformation from the database\", e );\n+  284: \t\t}\n+  285: \t\tfinally {\n+  286: \t\t\tif ( connection != null ) {\n+  287: \t\t\t\ttry {\n+  288: \t\t\t\t\tconnectionAccess.releaseConnection( connection );\n+  289: \t\t\t\t}\n+  290: \t\t\t\tcatch (SQLException exception) {\n+  291: \t\t\t\t\t//ignored\n+  292: \t\t\t\t}\n+  293: \t\t\t}\n+  294: \t\t}\n+  295: \t}\n   296: \n-  297: \t\t\t\t\t\t\t\t\t\t@Override\n-  298: \t\t\t\t\t\t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n-  299: \t\t\t\t\t\t\t\t\t\t\treturn jdbcEnvironment;\n-  300: \t\t\t\t\t\t\t\t\t\t}\n-  301: \t\t\t\t\t\t\t\t\t}\n-  302: \t\t\t\t\t);\n-  303: \t\t\treturn StreamSupport.stream( sequenceInformationIterable.spliterator(), false )\n-  304: \t\t\t\t\t.collect( Collectors.toList() );\n-  305: \t\t}\n-  306: \t\tcatch (SQLException e) {\n-  307: \t\t\tthrow new HibernateException( \"Could not fetch the SequenceInformation from the database\", e );\n-  308: \t\t}\n-  309: \t\tfinally {\n-  310: \t\t\tif ( connection != null ) {\n-  311: \t\t\t\ttry {\n-  312: \t\t\t\t\tconnectionAccess.releaseConnection( connection );\n-  313: \t\t\t\t}\n-  314: \t\t\t\tcatch (SQLException throwables) {\n-  315: \t\t\t\t\t//ignored\n-  316: \t\t\t\t}\n-  317: \t\t\t}\n-  318: \t\t}\n-  319: \t}\n+  297: \tprivate static Iterable<SequenceInformation> sequenceInformation(Connection connection, JdbcEnvironment jdbcEnvironment)\n+  298: \t\t\tthrows SQLException {\n+  299: \t\treturn jdbcEnvironment.getDialect().getSequenceInformationExtractor().extractMetadata(\n+  300: \t\t\t\tnew ExtractionContext.EmptyExtractionContext() {\n+  301: \t\t\t\t\t@Override\n+  302: \t\t\t\t\tpublic Connection getJdbcConnection() {\n+  303: \t\t\t\t\t\treturn connection;\n+  304: \t\t\t\t\t}\n+  305: \t\t\t\t\t@Override\n+  306: \t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n+  307: \t\t\t\t\t\treturn jdbcEnvironment;\n+  308: \t\t\t\t\t}\n+  309: \t\t\t\t}\n+  310: \t\t);\n+  311: \t}\n+  312: }\n",
        "uniqueId": "72e42817e3759f3f130eefb302d9aa7a3e0cfa58_276_319_297_311_270_295",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 8,
                "covered": 26
            },
            "BRANCH": {
                "missed": 1,
                "covered": 1
            },
            "LINE": {
                "missed": 3,
                "covered": 7
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\n/**\n * Extracted method to get sequence information List from the database.\n *\n * @param connection the database connection\n * @param dialect the database dialect\n * @param jdbcEnvironment the JDBC environment\n * @param connectionAccess the JDBC connection access\n * @return sequence information List\n */\nprivate List<SequenceInformation> getSequenceInformationList(Connection connection, Dialect dialect, JdbcEnvironment jdbcEnvironment, JdbcConnectionAccess connectionAccess) throws SQLException {\n    final Connection c = connection;\n    Iterable<SequenceInformation> sequenceInformationIterable = dialect\n            .getSequenceInformationExtractor()\n            .extractMetadata(new ExtractionContext.EmptyExtractionContext() {\n                @Override\n                public Connection getJdbcConnection() {\n                    return c;\n                }\n\n                @Override\n                public JdbcEnvironment getJdbcEnvironment() {\n                    return jdbcEnvironment;\n                }\n            });\n    return StreamSupport.stream(sequenceInformationIterable.spliterator(), false)\n            .collect(Collectors.toList());\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n\t * Get the sequence information List from the database.\n\t *\n\t * @return sequence information List\n\t */\n\tprivate List<SequenceInformation> sequenceInformationList() {\n\t\tfinal JdbcEnvironment jdbcEnvironment = this.jdbcEnvironment;\n\t\tfinal Dialect dialect = this.jdbcEnvironment.getDialect();\n\n\t\tConnection connection = null;\n\t\ttry {\n\t\t\tconnection = connectionAccess.obtainConnection();\n\t\t\tfinal Connection c = connection;\n\t\t\tIterable<SequenceInformation> sequenceInformationIterable = dialect\n\t\t\t\t\t.getSequenceInformationExtractor()\n\t\t\t\t\t.extractMetadata( new ExtractionContext.EmptyExtractionContext() {\n\t\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\t\tpublic Connection getJdbcConnection() {\n\t\t\t\t\t\t\t\t\t\t\treturn c;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n\t\t\t\t\t\t\t\t\t\t\treturn jdbcEnvironment;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\treturn StreamSupport.stream( sequenceInformationIterable.spliterator(), false )\n\t\t\t\t\t.collect( Collectors.toList() );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow new HibernateException( \"Could not fetch the SequenceInformation from the database\", e );\n\t\t}\n\t\tfinally {\n\t\t\tif ( connection != null ) {\n\t\t\t\ttry {\n\t\t\t\t\tconnectionAccess.releaseConnection( connection );\n\t\t\t\t}\n\t\t\t\tcatch (SQLException throwables) {\n\t\t\t\t\t//ignored\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.env.internal;\n\nimport java.sql.Connection;\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.stream.StreamSupport;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.boot.model.source.internal.hbm.CommaSeparatedStringHelper;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.connections.spi.JdbcConnectionAccess;\nimport org.hibernate.engine.jdbc.cursor.internal.StandardRefCursorSupport;\nimport org.hibernate.engine.jdbc.env.spi.ExtractedDatabaseMetaData;\nimport org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;\nimport org.hibernate.engine.jdbc.env.spi.SQLStateType;\nimport org.hibernate.tool.schema.extract.spi.ExtractionContext;\nimport org.hibernate.tool.schema.extract.spi.SequenceInformation;\n\n/**\n * Standard implementation of ExtractedDatabaseMetaData\n *\n * @author Steve Ebersole\n */\npublic class ExtractedDatabaseMetaDataImpl implements ExtractedDatabaseMetaData {\n\n\tprivate final JdbcEnvironment jdbcEnvironment;\n\tprivate final JdbcConnectionAccess connectionAccess;\n\n\tprivate final String connectionCatalogName;\n\tprivate final String connectionSchemaName;\n\n\tprivate final boolean supportsRefCursors;\n\tprivate final boolean supportsNamedParameters;\n\tprivate final boolean supportsScrollableResults;\n\tprivate final boolean supportsGetGeneratedKeys;\n\tprivate final boolean supportsBatchUpdates;\n\tprivate final boolean supportsDataDefinitionInTransaction;\n\tprivate final boolean doesDataDefinitionCauseTransactionCommit;\n\tprivate final SQLStateType sqlStateType;\n\tprivate final boolean jdbcMetadataAccessible;\n\n\n\t//Lazily initialized: loading all sequence information upfront has been\n\t//shown to be too slow in some cases. In this way we only load it\n\t//when there is actual need for these details.\n\tprivate List<SequenceInformation> sequenceInformationList;\n\n\tprivate ExtractedDatabaseMetaDataImpl(\n\t\t\tJdbcEnvironment jdbcEnvironment,\n\t\t\tJdbcConnectionAccess connectionAccess,\n\t\t\tString connectionCatalogName,\n\t\t\tString connectionSchemaName,\n\t\t\tboolean supportsRefCursors,\n\t\t\tboolean supportsNamedParameters,\n\t\t\tboolean supportsScrollableResults,\n\t\t\tboolean supportsGetGeneratedKeys,\n\t\t\tboolean supportsBatchUpdates,\n\t\t\tboolean supportsDataDefinitionInTransaction,\n\t\t\tboolean doesDataDefinitionCauseTransactionCommit,\n\t\t\tSQLStateType sqlStateType,\n\t\t\tboolean jdbcMetadataIsAccessible) {\n\t\tthis.jdbcEnvironment = jdbcEnvironment;\n\t\tthis.connectionAccess = connectionAccess;\n\t\tthis.connectionCatalogName = connectionCatalogName;\n\t\tthis.connectionSchemaName = connectionSchemaName;\n\t\tthis.supportsRefCursors = supportsRefCursors;\n\t\tthis.supportsNamedParameters = supportsNamedParameters;\n\t\tthis.supportsScrollableResults = supportsScrollableResults;\n\t\tthis.supportsGetGeneratedKeys = supportsGetGeneratedKeys;\n\t\tthis.supportsBatchUpdates = supportsBatchUpdates;\n\t\tthis.supportsDataDefinitionInTransaction = supportsDataDefinitionInTransaction;\n\t\tthis.doesDataDefinitionCauseTransactionCommit = doesDataDefinitionCauseTransactionCommit;\n\t\tthis.sqlStateType = sqlStateType;\n\t\tthis.jdbcMetadataAccessible = jdbcMetadataIsAccessible;\n\t}\n\n\t@Override\n\tpublic boolean supportsRefCursors() {\n\t\treturn supportsRefCursors;\n\t}\n\n\t@Override\n\tpublic JdbcEnvironment getJdbcEnvironment() {\n\t\treturn jdbcEnvironment;\n\t}\n\n\t@Override\n\tpublic boolean supportsNamedParameters() {\n\t\treturn supportsNamedParameters;\n\t}\n\n\t@Override\n\tpublic boolean supportsScrollableResults() {\n\t\treturn supportsScrollableResults;\n\t}\n\n\t@Override\n\tpublic boolean supportsGetGeneratedKeys() {\n\t\treturn supportsGetGeneratedKeys;\n\t}\n\n\t@Override\n\tpublic boolean supportsBatchUpdates() {\n\t\treturn supportsBatchUpdates;\n\t}\n\n\t@Override\n\tpublic boolean supportsDataDefinitionInTransaction() {\n\t\treturn supportsDataDefinitionInTransaction;\n\t}\n\n\t@Override\n\tpublic boolean doesDataDefinitionCauseTransactionCommit() {\n\t\treturn doesDataDefinitionCauseTransactionCommit;\n\t}\n\n\t@Override\n\tpublic SQLStateType getSqlStateType() {\n\t\treturn sqlStateType;\n\t}\n\n\t@Override\n\tpublic String getConnectionCatalogName() {\n\t\treturn connectionCatalogName;\n\t}\n\n\t@Override\n\tpublic String getConnectionSchemaName() {\n\t\treturn connectionSchemaName;\n\t}\n\n\t@Override\n\tpublic synchronized List<SequenceInformation> getSequenceInformationList() {\n\t\tif ( jdbcMetadataAccessible ) {\n\t\t\t//Loading the sequence information can take a while on large databases,\n\t\t\t//even minutes in some cases.\n\t\t\t//We trigger this lazily as only certain combinations of configurations,\n\t\t\t//mappings and used features actually trigger any use of such details.\n\t\t\tif ( sequenceInformationList == null ) {\n\t\t\t\tsequenceInformationList = sequenceInformationList();\n\t\t\t}\n\t\t\treturn sequenceInformationList;\n\t\t}\n\t\telse {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t}\n\n\t// For tests\n\tpublic boolean isJdbcMetadataAccessible() {\n\t\treturn jdbcMetadataAccessible;\n\t}\n\n\tpublic static class Builder {\n\t\tprivate final JdbcEnvironment jdbcEnvironment;\n\t\tprivate final boolean jdbcMetadataIsAccessible;\n\t\tprivate final JdbcConnectionAccess connectionAccess;\n\n\t\tprivate String connectionSchemaName;\n\t\tprivate String connectionCatalogName;\n\n\t\tprivate boolean supportsRefCursors;\n\t\tprivate boolean supportsNamedParameters;\n\t\tprivate boolean supportsScrollableResults;\n\t\tprivate boolean supportsGetGeneratedKeys;\n\t\t// In absence of DatabaseMetaData batching updates is assumed to be supported\n\t\tprivate boolean supportsBatchUpdates = true;\n\t\tprivate boolean supportsDataDefinitionInTransaction;\n\t\tprivate boolean doesDataDefinitionCauseTransactionCommit;\n\t\tprivate SQLStateType sqlStateType;\n\n\t\tpublic Builder(JdbcEnvironment jdbcEnvironment, boolean jdbcMetadataIsAccessible, JdbcConnectionAccess connectionAccess) {\n\t\t\tthis.jdbcEnvironment = jdbcEnvironment;\n\t\t\tthis.jdbcMetadataIsAccessible = jdbcMetadataIsAccessible;\n\t\t\tthis.connectionAccess = connectionAccess;\n\t\t}\n\n\t\tpublic Builder apply(DatabaseMetaData databaseMetaData) throws SQLException {\n\t\t\tconnectionCatalogName = databaseMetaData.getConnection().getCatalog();\n\t\t\t// NOTE : databaseMetaData.getConnection().getSchema() would require java 1.7 as baseline\n\t\t\tsupportsRefCursors = StandardRefCursorSupport.supportsRefCursors( databaseMetaData );\n\t\t\tsupportsNamedParameters = databaseMetaData.supportsNamedParameters();\n\t\t\tsupportsScrollableResults = databaseMetaData.supportsResultSetType( ResultSet.TYPE_SCROLL_INSENSITIVE );\n\t\t\tsupportsGetGeneratedKeys = databaseMetaData.supportsGetGeneratedKeys();\n\t\t\tsupportsBatchUpdates = databaseMetaData.supportsBatchUpdates();\n\t\t\tsupportsDataDefinitionInTransaction = !databaseMetaData.dataDefinitionIgnoredInTransactions();\n\t\t\tdoesDataDefinitionCauseTransactionCommit = databaseMetaData.dataDefinitionCausesTransactionCommit();\n\t\t\tsqlStateType = SQLStateType.interpretReportedSQLStateType( databaseMetaData.getSQLStateType() );\n\t\t\treturn this;\n\t\t}\n\n\t\tprivate Set<String> parseKeywords(String extraKeywordsString) {\n\t\t\treturn CommaSeparatedStringHelper.split( extraKeywordsString );\n\t\t}\n\n\t\tpublic Builder setConnectionSchemaName(String connectionSchemaName) {\n\t\t\tthis.connectionSchemaName = connectionSchemaName;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setConnectionCatalogName(String connectionCatalogName) {\n\t\t\tthis.connectionCatalogName = connectionCatalogName;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setSupportsRefCursors(boolean supportsRefCursors) {\n\t\t\tthis.supportsRefCursors = supportsRefCursors;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setSupportsNamedParameters(boolean supportsNamedParameters) {\n\t\t\tthis.supportsNamedParameters = supportsNamedParameters;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setSupportsScrollableResults(boolean supportsScrollableResults) {\n\t\t\tthis.supportsScrollableResults = supportsScrollableResults;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setSupportsGetGeneratedKeys(boolean supportsGetGeneratedKeys) {\n\t\t\tthis.supportsGetGeneratedKeys = supportsGetGeneratedKeys;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setSupportsBatchUpdates(boolean supportsBatchUpdates) {\n\t\t\tthis.supportsBatchUpdates = supportsBatchUpdates;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setSupportsDataDefinitionInTransaction(boolean supportsDataDefinitionInTransaction) {\n\t\t\tthis.supportsDataDefinitionInTransaction = supportsDataDefinitionInTransaction;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setDoesDataDefinitionCauseTransactionCommit(boolean doesDataDefinitionCauseTransactionCommit) {\n\t\t\tthis.doesDataDefinitionCauseTransactionCommit = doesDataDefinitionCauseTransactionCommit;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder setSqlStateType(SQLStateType sqlStateType) {\n\t\t\tthis.sqlStateType = sqlStateType;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic ExtractedDatabaseMetaDataImpl build() {\n\t\t\treturn new ExtractedDatabaseMetaDataImpl(\n\t\t\t\t\tjdbcEnvironment,\n\t\t\t\t\tconnectionAccess,\n\t\t\t\t\tconnectionCatalogName,\n\t\t\t\t\tconnectionSchemaName,\n\t\t\t\t\tsupportsRefCursors,\n\t\t\t\t\tsupportsNamedParameters,\n\t\t\t\t\tsupportsScrollableResults,\n\t\t\t\t\tsupportsGetGeneratedKeys,\n\t\t\t\t\tsupportsBatchUpdates,\n\t\t\t\t\tsupportsDataDefinitionInTransaction,\n\t\t\t\t\tdoesDataDefinitionCauseTransactionCommit,\n\t\t\t\t\tsqlStateType,\n\t\t\t\t\tjdbcMetadataIsAccessible\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Get the sequence information List from the database.\n\t *\n\t * @return sequence information List\n\t */\n\tprivate List<SequenceInformation> sequenceInformationList() {\n\t\tfinal JdbcEnvironment jdbcEnvironment = this.jdbcEnvironment;\n\t\tfinal Dialect dialect = this.jdbcEnvironment.getDialect();\n\n\t\tConnection connection = null;\n\t\ttry {\n\t\t\tconnection = connectionAccess.obtainConnection();\n\t\t\tfinal Connection c = connection;\n\t\t\tIterable<SequenceInformation> sequenceInformationIterable = dialect\n\t\t\t\t\t.getSequenceInformationExtractor()\n\t\t\t\t\t.extractMetadata( new ExtractionContext.EmptyExtractionContext() {\n\t\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\t\tpublic Connection getJdbcConnection() {\n\t\t\t\t\t\t\t\t\t\t\treturn c;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\t\tpublic JdbcEnvironment getJdbcEnvironment() {\n\t\t\t\t\t\t\t\t\t\t\treturn jdbcEnvironment;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\treturn StreamSupport.stream( sequenceInformationIterable.spliterator(), false )\n\t\t\t\t\t.collect( Collectors.toList() );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow new HibernateException( \"Could not fetch the SequenceInformation from the database\", e );\n\t\t}\n\t\tfinally {\n\t\t\tif ( connection != null ) {\n\t\t\t\ttry {\n\t\t\t\t\tconnectionAccess.releaseConnection( connection );\n\t\t\t\t}\n\t\t\t\tcatch (SQLException throwables) {\n\t\t\t\t\t//ignored\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate createQueryDefinition(namedNativeQuery org.hibernate.annotations.NamedNativeQuery, registrationName String, resultSetMappingName String, resultClass Class<T>, timeout int, fetchSize int, querySpaces HashSet<String>) : NamedNativeQueryDefinition.Builder<T> extracted from public bindNativeQuery(namedNativeQuery org.hibernate.annotations.NamedNativeQuery, context MetadataBuildingContext) : void in class org.hibernate.boot.model.internal.QueryBinder",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/boot/model/internal/QueryBinder.java",
                "startLine": 205,
                "endLine": 267,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/boot/model/internal/QueryBinder.java",
                "startLine": 211,
                "endLine": 257,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/boot/model/internal/QueryBinder.java",
                "startLine": 259,
                "endLine": 278,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public static void bindNativeQuery(\n\t\t\torg.hibernate.annotations.NamedNativeQuery namedNativeQuery,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( namedNativeQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String registrationName = namedNativeQuery.name();\n\n\t\t//ResultSetMappingDefinition mappingDefinition = mappings.getJdbcValuesMappingProducer( queryAnn.resultSetMapping() );\n\t\tif ( registrationName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedNativeQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tfinal String resultSetMappingName = namedNativeQuery.resultSetMapping();\n\t\tfinal Class<?> resultClassDetails = namedNativeQuery.resultClass();\n\t\tfinal Class<Object> resultClass = resultClassDetails == void.class\n\t\t\t\t? null\n\t\t\t\t: (Class<Object>) resultClassDetails;\n\n\t\tfinal Integer timeout = namedNativeQuery.timeout();\n\t\tfinal Integer fetchSize = namedNativeQuery.fetchSize();\n\n\t\tfinal String[] querySpacesList = namedNativeQuery.querySpaces();\n\t\tfinal HashSet<String> querySpaces = new HashSet<>( determineProperSizing( querySpacesList.length ) );\n\t\tCollections.addAll( querySpaces, querySpacesList );\n\n\t\tfinal NamedNativeQueryDefinition.Builder<?> builder = new NamedNativeQueryDefinition.Builder<>( registrationName )\n\t\t\t\t.setSqlString( namedNativeQuery.query() )\n\t\t\t\t.setResultSetMappingName( resultSetMappingName )\n\t\t\t\t.setResultClass( resultClass )\n\t\t\t\t.setCacheable( namedNativeQuery.cacheable() )\n\t\t\t\t.setCacheRegion( nullIfEmpty( namedNativeQuery.cacheRegion() ) )\n\t\t\t\t.setCacheMode( getCacheMode( namedNativeQuery.cacheRetrieveMode(), namedNativeQuery.cacheStoreMode() ) )\n\t\t\t\t.setTimeout( timeout < 0 ? null : timeout )\n\t\t\t\t.setFetchSize( fetchSize < 0 ? null : fetchSize )\n\t\t\t\t.setFlushMode( getFlushMode( namedNativeQuery.flushMode() ) )\n\t\t\t\t.setReadOnly( namedNativeQuery.readOnly() )\n\t\t\t\t.setQuerySpaces( querySpaces )\n\t\t\t\t.setComment( nullIfEmpty( namedNativeQuery.comment() ) );\n\n\t\tif ( TRUE == namedNativeQuery.callable() ) {\n\t\t\tfinal NamedProcedureCallDefinition definition =\n\t\t\t\t\tcreateStoredProcedure( builder, context, () -> illegalCallSyntax( namedNativeQuery ) );\n\t\t\tcontext.getMetadataCollector().addNamedProcedureCallDefinition( definition );\n\t\t\tDeprecationLogger.DEPRECATION_LOGGER.warn(\n\t\t\t\t\t\"Marking named native queries as callable is no longer supported; use '@jakarta.persistence.NamedStoredProcedureQuery' instead. Ignoring.\"\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tfinal NamedNativeQueryDefinition<?> queryDefinition = builder.build();\n\n\t\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\t\tLOG.debugf(\n\t\t\t\t\t\t\"Binding named native query: %s => %s\",\n\t\t\t\t\t\tqueryDefinition.getRegistrationName(),\n\t\t\t\t\t\tqueryDefinition.getSqlQueryString()\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tcontext.getMetadataCollector().addNamedNativeQuery( queryDefinition );\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/boot/model/internal/QueryBinder.java",
        "isPureRefactoring": true,
        "commitId": "b53728f7278c40ef41e22326f917ca5c718ce6e7",
        "packageNameBefore": "org.hibernate.boot.model.internal",
        "classNameBefore": "org.hibernate.boot.model.internal.QueryBinder",
        "methodNameBefore": "org.hibernate.boot.model.internal.QueryBinder#bindNativeQuery",
        "invokedMethod": "methodSignature: org.hibernate.boot.model.internal.QueryBinder#getCacheMode\n methodBody: private static CacheMode getCacheMode(CacheRetrieveMode cacheRetrieveMode, CacheStoreMode cacheStoreMode) {\nfinal CacheMode cacheMode=CacheMode.fromJpaModes(cacheRetrieveMode,cacheStoreMode);\nreturn cacheMode == null ? CacheMode.NORMAL : cacheMode;\n}\nmethodSignature: org.hibernate.boot.model.internal.QueryBinder#illegalCallSyntax\n methodBody: private static AnnotationException illegalCallSyntax(org.hibernate.annotations.NamedNativeQuery queryAnn) {\nreturn new AnnotationException(\"Callable 'NamedNativeQuery' named '\" + queryAnn.name() + \"' does not use the JDBC call syntax\");\n}\nmethodSignature: org.hibernate.boot.model.internal.QueryBinder#createStoredProcedure\n methodBody: public static NamedProcedureCallDefinition createStoredProcedure(\n\t\t\tNamedNativeQueryDefinition.Builder<?> builder,\n\t\t\tMetadataBuildingContext context,\n\t\t\tSupplier<RuntimeException> exceptionProducer) {\nfinal String sqlString=builder.getSqlString().trim();\nif(!sqlString.startsWith(\"{\") || !sqlString.endsWith(\"}\")){throw exceptionProducer.get();\n}final JdbcCall jdbcCall=parseJdbcCall(sqlString,exceptionProducer);\nfinal SourceModelBuildingContext sourceModelBuildingContext=context.getMetadataCollector().getSourceModelBuildingContext();\nfinal NamedStoredProcedureQueryJpaAnnotation nameStoredProcedureQueryAnn=JpaAnnotations.NAMED_STORED_PROCEDURE_QUERY.createUsage(sourceModelBuildingContext);\nnameStoredProcedureQueryAnn.name(builder.getName());\nnameStoredProcedureQueryAnn.procedureName(jdbcCall.callableName);\nfinal StoredProcedureParameter[] parameters=new StoredProcedureParameter[jdbcCall.parameters.size()];\nnameStoredProcedureQueryAnn.parameters(parameters);\nfor(int i=0; i < jdbcCall.parameters.size(); i++){final StoredProcedureParameterJpaAnnotation param=JpaAnnotations.STORED_PROCEDURE_PARAMETER.createUsage(sourceModelBuildingContext);\nparameters[i]=param;\nfinal String paramName=jdbcCall.parameters.get(i);\nparam.name(paramName);\nparam.mode(ParameterMode.IN);\nfinal String typeName=builder.getParameterTypes().get(paramName);\nfinal ClassDetails classDetails;\nif(StringHelper.isEmpty(typeName)){classDetails=ClassDetails.VOID_CLASS_DETAILS;\n}{final BasicType<Object> registeredType=context.getBootstrapContext().getTypeConfiguration().getBasicTypeRegistry().getRegisteredType(typeName);\nclassDetails=context.getMetadataCollector().getClassDetailsRegistry().getClassDetails(registeredType.getJavaType().getName());\n}param.type(classDetails.toJavaClass());\n}if(builder.getResultSetMappingName() != null){nameStoredProcedureQueryAnn.resultSetMappings(new String[]{builder.getResultSetMappingName()});\n}final Class<?> resultClass=builder.getResultClass();\nif(resultClass != null){nameStoredProcedureQueryAnn.resultClasses(new Class[]{builder.getResultClass()});\n}final List<QueryHintJpaAnnotation> hints=new ArrayList<>();\nif(builder.getQuerySpaces() != null){final QueryHintJpaAnnotation hint=JpaAnnotations.QUERY_HINT.createUsage(sourceModelBuildingContext);\nhint.name(HibernateHints.HINT_NATIVE_SPACES);\nhint.value(String.join(\" \",builder.getQuerySpaces()));\nhints.add(hint);\n}if(jdbcCall.resultParameter){final QueryHintJpaAnnotation hint=JpaAnnotations.QUERY_HINT.createUsage(sourceModelBuildingContext);\nhint.name(HibernateHints.HINT_CALLABLE_FUNCTION);\nhint.value(\"true\");\nhints.add(hint);\n}nameStoredProcedureQueryAnn.hints(hints.toArray(QueryHint[]::new));\nreturn new NamedProcedureCallDefinitionImpl(nameStoredProcedureQueryAnn);\n}\nmethodSignature: org.hibernate.boot.model.internal.QueryBinder#getFlushMode\n methodBody: private static FlushMode getFlushMode(FlushModeType flushModeType) {\nreturn switch (flushModeType) {\ncase ALWAYS ->  yield FlushMode.ALWAYS;\ncase AUTO ->yield FlushMode.AUTO;\ncase COMMIT ->yield FlushMode.COMMIT;\ncase MANUAL ->yield FlushMode.MANUAL;\ncase PERSISTENCE_CONTEXT ->yield null;\n}\n;\n}",
        "classSignatureBefore": "public abstract class QueryBinder ",
        "methodNameBeforeSet": [
            "org.hibernate.boot.model.internal.QueryBinder#bindNativeQuery"
        ],
        "classNameBeforeSet": [
            "org.hibernate.boot.model.internal.QueryBinder"
        ],
        "classSignatureBeforeSet": [
            "public abstract class QueryBinder "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html.\n */\npackage org.hibernate.boot.model.internal;\n\nimport java.lang.invoke.MethodHandles;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.function.Supplier;\n\nimport org.hibernate.AnnotationException;\nimport org.hibernate.CacheMode;\nimport org.hibernate.FlushMode;\nimport org.hibernate.annotations.FlushModeType;\nimport org.hibernate.annotations.HQLSelect;\nimport org.hibernate.annotations.SQLSelect;\nimport org.hibernate.boot.internal.NamedHqlQueryDefinitionImpl;\nimport org.hibernate.boot.internal.NamedProcedureCallDefinitionImpl;\nimport org.hibernate.boot.models.JpaAnnotations;\nimport org.hibernate.boot.models.annotations.internal.NamedStoredProcedureQueryJpaAnnotation;\nimport org.hibernate.boot.models.annotations.internal.QueryHintJpaAnnotation;\nimport org.hibernate.boot.models.annotations.internal.StoredProcedureParameterJpaAnnotation;\nimport org.hibernate.boot.query.NamedHqlQueryDefinition;\nimport org.hibernate.boot.query.NamedNativeQueryDefinition;\nimport org.hibernate.boot.query.NamedProcedureCallDefinition;\nimport org.hibernate.boot.query.SqlResultSetMappingDescriptor;\nimport org.hibernate.boot.registry.classloading.spi.ClassLoaderService;\nimport org.hibernate.boot.spi.MetadataBuildingContext;\nimport org.hibernate.internal.CoreMessageLogger;\nimport org.hibernate.internal.log.DeprecationLogger;\nimport org.hibernate.internal.util.collections.ArrayHelper;\nimport org.hibernate.jpa.HibernateHints;\nimport org.hibernate.models.internal.util.StringHelper;\nimport org.hibernate.models.spi.ClassDetails;\nimport org.hibernate.models.spi.SourceModelBuildingContext;\nimport org.hibernate.query.sql.internal.ParameterParser;\nimport org.hibernate.query.sql.spi.ParameterRecognizer;\nimport org.hibernate.type.BasicType;\n\nimport org.jboss.logging.Logger;\n\nimport jakarta.persistence.CacheRetrieveMode;\nimport jakarta.persistence.CacheStoreMode;\nimport jakarta.persistence.NamedNativeQuery;\nimport jakarta.persistence.NamedQuery;\nimport jakarta.persistence.NamedStoredProcedureQuery;\nimport jakarta.persistence.ParameterMode;\nimport jakarta.persistence.QueryHint;\nimport jakarta.persistence.SqlResultSetMapping;\nimport jakarta.persistence.StoredProcedureParameter;\n\nimport static java.lang.Boolean.TRUE;\nimport static org.hibernate.internal.util.StringHelper.nullIfEmpty;\nimport static org.hibernate.internal.util.collections.CollectionHelper.determineProperSizing;\nimport static org.hibernate.internal.util.collections.CollectionHelper.setOf;\n\n/**\n * Responsible for reading named queries defined in annotations and registering\n * {@link org.hibernate.boot.query.NamedQueryDefinition} objects.\n *\n * @implNote This class is stateless, unlike most of the other \"binders\".\n *\n * @author Emmanuel Bernard\n */\npublic abstract class QueryBinder {\n\tprivate static final CoreMessageLogger LOG = Logger.getMessageLogger( MethodHandles.lookup(), CoreMessageLogger.class, QueryBinder.class.getName() );\n\n\tpublic static void bindQuery(\n\t\t\tNamedQuery namedQuery,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\tif ( namedQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String queryName = namedQuery.name();\n\t\tfinal String queryString = namedQuery.query();\n\n\t\tif ( queryName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named query: %s => %s\", queryName, queryString );\n\t\t}\n\n\t\tfinal QueryHintDefinition hints = new QueryHintDefinition( queryName, namedQuery.hints() );\n\n\t\tfinal NamedHqlQueryDefinition<?> queryMapping = new NamedHqlQueryDefinitionImpl.Builder<>( queryName )\n\t\t\t\t.setHqlString( queryString )\n\t\t\t\t.setResultClass( (Class<Object>) namedQuery.resultClass() )\n\t\t\t\t.setCacheable( hints.getCacheability() )\n\t\t\t\t.setCacheMode( hints.getCacheMode() )\n\t\t\t\t.setCacheRegion( hints.getString( HibernateHints.HINT_CACHE_REGION ) )\n\t\t\t\t.setTimeout( hints.getTimeout() )\n\t\t\t\t.setFetchSize( hints.getInteger( HibernateHints.HINT_FETCH_SIZE ) )\n\t\t\t\t.setFlushMode( hints.getFlushMode() )\n\t\t\t\t.setReadOnly( hints.getBooleanWrapper( HibernateHints.HINT_READ_ONLY ) )\n\t\t\t\t.setLockOptions( hints.determineLockOptions( namedQuery ) )\n\t\t\t\t.setComment( hints.getString( HibernateHints.HINT_COMMENT ) )\n\t\t\t\t.build();\n\n\t\tif ( isDefault ) {\n\t\t\tcontext.getMetadataCollector().addDefaultQuery( queryMapping );\n\t\t}\n\t\telse {\n\t\t\tcontext.getMetadataCollector().addNamedQuery( queryMapping );\n\t\t}\n\t}\n\n\tprivate static Class<Object> loadClass(ClassDetails classDetails, MetadataBuildingContext context) {\n\t\treturn ClassDetails.VOID_CLASS_DETAILS == classDetails\n\t\t\t\t? null\n\t\t\t\t: context.getBootstrapContext()\n\t\t\t\t\t\t.getServiceRegistry()\n\t\t\t\t\t\t.requireService( ClassLoaderService.class )\n\t\t\t\t\t\t.classForName( classDetails.getName() );\n\t}\n\n\tpublic static void bindNativeQuery(\n\t\t\tNamedNativeQuery namedNativeQuery,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\tif ( namedNativeQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String registrationName = namedNativeQuery.name();\n\t\tfinal String queryString = namedNativeQuery.query();\n\n\t\tif ( registrationName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedNativeQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tfinal QueryHintDefinition hints = new QueryHintDefinition( registrationName, namedNativeQuery.hints() );\n\n\t\tfinal String resultSetMappingName = namedNativeQuery.resultSetMapping();\n\t\tfinal Class<?> resultClassDetails = namedNativeQuery.resultClass();\n\t\tfinal Class<Object> resultClass = void.class == resultClassDetails\n\t\t\t\t? null\n\t\t\t\t: (Class<Object>) resultClassDetails;\n\n\t\tfinal NamedNativeQueryDefinition.Builder<?> builder = new NamedNativeQueryDefinition.Builder<>( registrationName )\n\t\t\t\t.setSqlString( queryString )\n\t\t\t\t.setResultClass( resultClass )\n\t\t\t\t.setResultSetMappingName( resultSetMappingName )\n\t\t\t\t.setQuerySpaces( null )\n\t\t\t\t.setCacheable( hints.getCacheability() )\n\t\t\t\t.setCacheMode( hints.getCacheMode() )\n\t\t\t\t.setCacheRegion( hints.getString( HibernateHints.HINT_CACHE_REGION ) )\n\t\t\t\t.setTimeout( hints.getTimeout() )\n\t\t\t\t.setFetchSize( hints.getInteger( HibernateHints.HINT_FETCH_SIZE ) )\n\t\t\t\t.setFlushMode( hints.getFlushMode() )\n\t\t\t\t.setReadOnly( hints.getBooleanWrapper( HibernateHints.HINT_READ_ONLY ) )\n\t\t\t\t.setComment( hints.getString( HibernateHints.HINT_COMMENT ) )\n\t\t\t\t.addHints( hints.getHintsMap() );\n\n\t\tfinal NamedNativeQueryDefinition<?> queryDefinition = builder.build();\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named native query: %s => %s\", queryDefinition.getRegistrationName(), queryDefinition.getSqlQueryString() );\n\t\t}\n\n\t\tif ( isDefault ) {\n\t\t\tcontext.getMetadataCollector().addDefaultNamedNativeQuery( queryDefinition );\n\t\t}\n\t\telse {\n\t\t\tcontext.getMetadataCollector().addNamedNativeQuery( queryDefinition );\n\t\t}\n\t}\n\n\tpublic static void bindNativeQuery(\n\t\t\tString name,\n\t\t\tSQLSelect sqlSelect,\n\t\t\tClassDetails annotatedClass,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal NamedNativeQueryDefinition.Builder<?> builder = new NamedNativeQueryDefinition.Builder<>( name )\n\t\t\t\t.setFlushMode( FlushMode.MANUAL )\n\t\t\t\t.setSqlString( sqlSelect.sql() )\n\t\t\t\t.setQuerySpaces( setOf( sqlSelect.querySpaces() ) );\n\n\t\tif ( annotatedClass != null ) {\n\t\t\tbuilder.setResultClass(\n\t\t\t\t\tcontext.getBootstrapContext().getServiceRegistry().requireService( ClassLoaderService.class )\n\t\t\t\t\t\t\t.classForName( annotatedClass.getClassName() )\n\t\t\t);\n\t\t}\n\n\t\tfinal SqlResultSetMapping resultSetMapping = sqlSelect.resultSetMapping();\n\t\tif ( !ArrayHelper.isEmpty( resultSetMapping.columns() )\n\t\t\t\t|| !ArrayHelper.isEmpty( resultSetMapping.entities() )\n\t\t\t\t|| !ArrayHelper.isEmpty( resultSetMapping.classes() ) ) {\n\t\t\tcontext.getMetadataCollector().addResultSetMapping( SqlResultSetMappingDescriptor.from( resultSetMapping, name ) );\n\t\t\tbuilder.setResultSetMappingName( name );\n\t\t}\n\n\t\tcontext.getMetadataCollector().addNamedNativeQuery( builder.build() );\n\t}\n\n\tpublic static void bindNativeQuery(\n\t\t\torg.hibernate.annotations.NamedNativeQuery namedNativeQuery,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( namedNativeQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String registrationName = namedNativeQuery.name();\n\n\t\t//ResultSetMappingDefinition mappingDefinition = mappings.getJdbcValuesMappingProducer( queryAnn.resultSetMapping() );\n\t\tif ( registrationName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedNativeQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tfinal String resultSetMappingName = namedNativeQuery.resultSetMapping();\n\t\tfinal Class<?> resultClassDetails = namedNativeQuery.resultClass();\n\t\tfinal Class<Object> resultClass = resultClassDetails == void.class\n\t\t\t\t? null\n\t\t\t\t: (Class<Object>) resultClassDetails;\n\n\t\tfinal Integer timeout = namedNativeQuery.timeout();\n\t\tfinal Integer fetchSize = namedNativeQuery.fetchSize();\n\n\t\tfinal String[] querySpacesList = namedNativeQuery.querySpaces();\n\t\tfinal HashSet<String> querySpaces = new HashSet<>( determineProperSizing( querySpacesList.length ) );\n\t\tCollections.addAll( querySpaces, querySpacesList );\n\n\t\tfinal NamedNativeQueryDefinition.Builder<?> builder = new NamedNativeQueryDefinition.Builder<>( registrationName )\n\t\t\t\t.setSqlString( namedNativeQuery.query() )\n\t\t\t\t.setResultSetMappingName( resultSetMappingName )\n\t\t\t\t.setResultClass( resultClass )\n\t\t\t\t.setCacheable( namedNativeQuery.cacheable() )\n\t\t\t\t.setCacheRegion( nullIfEmpty( namedNativeQuery.cacheRegion() ) )\n\t\t\t\t.setCacheMode( getCacheMode( namedNativeQuery.cacheRetrieveMode(), namedNativeQuery.cacheStoreMode() ) )\n\t\t\t\t.setTimeout( timeout < 0 ? null : timeout )\n\t\t\t\t.setFetchSize( fetchSize < 0 ? null : fetchSize )\n\t\t\t\t.setFlushMode( getFlushMode( namedNativeQuery.flushMode() ) )\n\t\t\t\t.setReadOnly( namedNativeQuery.readOnly() )\n\t\t\t\t.setQuerySpaces( querySpaces )\n\t\t\t\t.setComment( nullIfEmpty( namedNativeQuery.comment() ) );\n\n\t\tif ( TRUE == namedNativeQuery.callable() ) {\n\t\t\tfinal NamedProcedureCallDefinition definition =\n\t\t\t\t\tcreateStoredProcedure( builder, context, () -> illegalCallSyntax( namedNativeQuery ) );\n\t\t\tcontext.getMetadataCollector().addNamedProcedureCallDefinition( definition );\n\t\t\tDeprecationLogger.DEPRECATION_LOGGER.warn(\n\t\t\t\t\t\"Marking named native queries as callable is no longer supported; use '@jakarta.persistence.NamedStoredProcedureQuery' instead. Ignoring.\"\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tfinal NamedNativeQueryDefinition<?> queryDefinition = builder.build();\n\n\t\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\t\tLOG.debugf(\n\t\t\t\t\t\t\"Binding named native query: %s => %s\",\n\t\t\t\t\t\tqueryDefinition.getRegistrationName(),\n\t\t\t\t\t\tqueryDefinition.getSqlQueryString()\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tcontext.getMetadataCollector().addNamedNativeQuery( queryDefinition );\n\t\t}\n\t}\n\n\t/**\n\t * Handles legacy cases where a named native query was used to specify a procedure call\n\t *\n\t * @deprecated User should use {@linkplain NamedStoredProcedureQuery} instead\n\t */\n\t@Deprecated\n\tpublic static NamedProcedureCallDefinition createStoredProcedure(\n\t\t\tNamedNativeQueryDefinition.Builder<?> builder,\n\t\t\tMetadataBuildingContext context,\n\t\t\tSupplier<RuntimeException> exceptionProducer) {\n\t\tfinal String sqlString = builder.getSqlString().trim();\n\t\tif ( !sqlString.startsWith( \"{\" ) || !sqlString.endsWith( \"}\" ) ) {\n\t\t\tthrow exceptionProducer.get();\n\t\t}\n\t\tfinal JdbcCall jdbcCall = parseJdbcCall( sqlString, exceptionProducer );\n\n\t\tfinal SourceModelBuildingContext sourceModelBuildingContext = context.getMetadataCollector()\n\t\t\t\t.getSourceModelBuildingContext();\n\t\tfinal NamedStoredProcedureQueryJpaAnnotation nameStoredProcedureQueryAnn = JpaAnnotations.NAMED_STORED_PROCEDURE_QUERY.createUsage( sourceModelBuildingContext );\n\t\tnameStoredProcedureQueryAnn.name( builder.getName() );\n\t\tnameStoredProcedureQueryAnn.procedureName( jdbcCall.callableName );\n\n\t\tfinal StoredProcedureParameter[] parameters = new StoredProcedureParameter[jdbcCall.parameters.size()];\n\t\tnameStoredProcedureQueryAnn.parameters( parameters );\n\n\t\tfor ( int i = 0; i < jdbcCall.parameters.size(); i++ ) {\n\t\t\tfinal StoredProcedureParameterJpaAnnotation param = JpaAnnotations.STORED_PROCEDURE_PARAMETER.createUsage( sourceModelBuildingContext );\n\t\t\tparameters[i] = param;\n\n\t\t\tfinal String paramName = jdbcCall.parameters.get( i );\n\t\t\tparam.name( paramName );\n\t\t\tparam.mode( ParameterMode.IN );\n\n\t\t\tfinal String typeName = builder.getParameterTypes().get( paramName );\n\t\t\tfinal ClassDetails classDetails;\n\t\t\tif ( StringHelper.isEmpty( typeName ) ) {\n\t\t\t\tclassDetails = ClassDetails.VOID_CLASS_DETAILS;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfinal BasicType<Object> registeredType = context.getBootstrapContext()\n\t\t\t\t\t\t.getTypeConfiguration()\n\t\t\t\t\t\t.getBasicTypeRegistry()\n\t\t\t\t\t\t.getRegisteredType( typeName );\n\t\t\t\tclassDetails = context.getMetadataCollector().getClassDetailsRegistry().getClassDetails( registeredType.getJavaType().getName() );\n\t\t\t}\n\t\t\tparam.type( classDetails.toJavaClass() );\n\t\t}\n\n\t\tif ( builder.getResultSetMappingName() != null ) {\n\t\t\tnameStoredProcedureQueryAnn.resultSetMappings( new String[] { builder.getResultSetMappingName() } );\n\t\t}\n\n\t\tfinal Class<?> resultClass = builder.getResultClass();\n\t\tif ( resultClass != null ) {\n\t\t\tnameStoredProcedureQueryAnn.resultClasses( new Class[]{ builder.getResultClass() } );\n\t\t}\n\n\t\tfinal List<QueryHintJpaAnnotation> hints = new ArrayList<>();\n\n\t\tif ( builder.getQuerySpaces() != null ) {\n\t\t\tfinal QueryHintJpaAnnotation hint = JpaAnnotations.QUERY_HINT.createUsage( sourceModelBuildingContext );\n\t\t\thint.name( HibernateHints.HINT_NATIVE_SPACES );\n\t\t\thint.value( String.join( \" \", builder.getQuerySpaces() ) );\n\t\t\thints.add( hint );\n\t\t}\n\n\t\tif ( jdbcCall.resultParameter ) {\n\t\t\t// Mark native queries that have a result parameter as callable functions\n\t\t\tfinal QueryHintJpaAnnotation hint = JpaAnnotations.QUERY_HINT.createUsage( sourceModelBuildingContext );\n\t\t\thint.name( HibernateHints.HINT_CALLABLE_FUNCTION );\n\t\t\thint.value( \"true\" );\n\t\t\thints.add( hint );\n\t\t}\n\n\t\tnameStoredProcedureQueryAnn.hints( hints.toArray(QueryHint[]::new) );\n\n\t\treturn new NamedProcedureCallDefinitionImpl( nameStoredProcedureQueryAnn );\n\t}\n\n\tpublic static void bindQuery(\n\t\t\tString name,\n\t\t\tHQLSelect hqlSelect,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal NamedHqlQueryDefinition<?> hqlQueryDefinition = new NamedHqlQueryDefinition.Builder<>( name )\n\t\t\t\t.setFlushMode( FlushMode.MANUAL )\n\t\t\t\t.setHqlString( hqlSelect.query() )\n\t\t\t\t.build();\n\n\t\tcontext.getMetadataCollector().addNamedQuery( hqlQueryDefinition );\n\t}\n\n\tpublic static void bindQuery(\n\t\t\torg.hibernate.annotations.NamedQuery namedQuery,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( namedQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String registrationName = namedQuery.name();\n\n\t\t//ResultSetMappingDefinition mappingDefinition = mappings.getJdbcValuesMappingProducer( namedQuery.resultSetMapping() );\n\t\tif ( registrationName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tfinal int timeout = namedQuery.timeout();\n\t\tfinal int fetchSize = namedQuery.fetchSize();\n\n\t\tfinal NamedHqlQueryDefinition.Builder<?> builder = new NamedHqlQueryDefinition.Builder<>( registrationName )\n\t\t\t\t.setHqlString( namedQuery.query() )\n\t\t\t\t.setResultClass( (Class<Object>) namedQuery.resultClass() )\n\t\t\t\t.setCacheable( namedQuery.cacheable() )\n\t\t\t\t.setCacheRegion( nullIfEmpty( namedQuery.cacheRegion() ) )\n\t\t\t\t.setCacheMode( getCacheMode( namedQuery.cacheRetrieveMode(), namedQuery.cacheStoreMode() ) )\n\t\t\t\t.setTimeout( timeout < 0 ? null : timeout )\n\t\t\t\t.setFetchSize( fetchSize < 0 ? null : fetchSize )\n\t\t\t\t.setFlushMode( getFlushMode( namedQuery.flushMode() ) )\n\t\t\t\t.setReadOnly( namedQuery.readOnly() )\n\t\t\t\t.setComment( nullIfEmpty( namedQuery.comment() ) );\n\n\t\tfinal NamedHqlQueryDefinitionImpl<?> hqlQueryDefinition = builder.build();\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named query: %s => %s\", hqlQueryDefinition.getRegistrationName(), hqlQueryDefinition.getHqlString() );\n\t\t}\n\n\t\tcontext.getMetadataCollector().addNamedQuery( hqlQueryDefinition );\n\t}\n\n\tprivate static CacheMode getCacheMode(CacheRetrieveMode cacheRetrieveMode, CacheStoreMode cacheStoreMode) {\n\t\tfinal CacheMode cacheMode = CacheMode.fromJpaModes( cacheRetrieveMode, cacheStoreMode );\n\t\treturn cacheMode == null ? CacheMode.NORMAL : cacheMode;\n\t}\n\n\tprivate static FlushMode getFlushMode(FlushModeType flushModeType) {\n\t\treturn switch ( flushModeType ) {\n\t\t\tcase ALWAYS -> FlushMode.ALWAYS;\n\t\t\tcase AUTO -> FlushMode.AUTO;\n\t\t\tcase COMMIT -> FlushMode.COMMIT;\n\t\t\tcase MANUAL -> FlushMode.MANUAL;\n\t\t\tcase PERSISTENCE_CONTEXT -> null;\n\t\t};\n\t}\n\n\tpublic static void bindNamedStoredProcedureQuery(\n\t\t\tNamedStoredProcedureQuery namedStoredProcedureQuery,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\tif ( namedStoredProcedureQuery != null ) {\n\t\t\tif ( namedStoredProcedureQuery.name().isEmpty() ) {\n\t\t\t\tthrow new AnnotationException( \"Class or package level '@NamedStoredProcedureQuery' annotation must specify a 'name'\" );\n\t\t\t}\n\n\t\t\tfinal NamedProcedureCallDefinitionImpl definition = new NamedProcedureCallDefinitionImpl( namedStoredProcedureQuery );\n\t\t\tif ( isDefault ) {\n\t\t\t\tcontext.getMetadataCollector().addDefaultNamedProcedureCall( definition );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcontext.getMetadataCollector().addNamedProcedureCallDefinition( definition );\n\t\t\t}\n\t\t\tLOG.debugf( \"Bound named stored procedure query : %s => %s\", definition.getRegistrationName(), definition.getProcedureName() );\n\t\t}\n\t}\n\n\tpublic static void bindSqlResultSetMapping(\n\t\t\tSqlResultSetMapping resultSetMappingAnn,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\t//no need to handle inSecondPass\n\t\tcontext.getMetadataCollector().addSecondPass( new ResultSetMappingSecondPass( resultSetMappingAnn, context, isDefault ) );\n\t}\n\n\tprivate static class JdbcCall {\n\t\tprivate final String callableName;\n\t\tprivate final boolean resultParameter;\n\t\tprivate final ArrayList<String> parameters;\n\n\t\tpublic JdbcCall(String callableName, boolean resultParameter, ArrayList<String> parameters) {\n\t\t\tthis.callableName = callableName;\n\t\t\tthis.resultParameter = resultParameter;\n\t\t\tthis.parameters = parameters;\n\t\t}\n\t}\n\n\tprivate static JdbcCall parseJdbcCall(String sqlString, Supplier<RuntimeException> exceptionProducer) {\n\t\tString callableName = null;\n\t\tboolean resultParameter = false;\n\t\tint index = skipWhitespace( sqlString, 1 );\n\t\t// Parse the out param `?=` part\n\t\tif ( sqlString.charAt( index ) == '?' ) {\n\t\t\tresultParameter = true;\n\t\t\tindex++;\n\t\t\tindex = skipWhitespace( sqlString, index );\n\t\t\tif ( sqlString.charAt( index ) != '=' ) {\n\t\t\t\tthrow exceptionProducer.get();\n\t\t\t}\n\t\t\tindex++;\n\t\t\tindex = skipWhitespace( sqlString, index );\n\t\t}\n\t\t// Parse the call keyword\n\t\tif ( !sqlString.regionMatches( true, index, \"call\", 0, 4 ) ) {\n\t\t\tthrow exceptionProducer.get();\n\t\t}\n\t\tindex += 4;\n\t\tindex = skipWhitespace( sqlString, index );\n\n\t\t// Parse the procedure name\n\t\tfinal int procedureStart = index;\n\t\tfor ( ; index < sqlString.length(); index++ ) {\n\t\t\tfinal char c = sqlString.charAt( index );\n\t\t\tif ( c == '(' || Character.isWhitespace( c ) ) {\n\t\t\t\tcallableName = sqlString.substring( procedureStart, index );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tindex = skipWhitespace( sqlString, index );\n\t\tfinal ArrayList<String> parameters = new ArrayList<>();\n\t\tParameterParser.parse(\n\t\t\t\tsqlString.substring( index, sqlString.length() - 1 ),\n\t\t\t\tnew ParameterRecognizer() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void ordinalParameter(int sourcePosition) {\n\t\t\t\t\t\tparameters.add( \"\" );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void namedParameter(String name, int sourcePosition) {\n\t\t\t\t\t\tparameters.add( name );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void jpaPositionalParameter(int label, int sourcePosition) {\n\t\t\t\t\t\tparameters.add( \"\" );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void other(char character) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\treturn new JdbcCall( callableName, resultParameter, parameters );\n\t}\n\n\tprivate static int skipWhitespace(String sqlString, int i) {\n\t\twhile ( i < sqlString.length() ) {\n\t\t\tif ( !Character.isWhitespace( sqlString.charAt( i ) ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn i;\n\t}\n\n\tprivate static AnnotationException illegalCallSyntax(org.hibernate.annotations.NamedNativeQuery queryAnn) {\n\t\treturn new AnnotationException( \"Callable 'NamedNativeQuery' named '\" + queryAnn.name()\n\t\t\t\t+ \"' does not use the JDBC call syntax\" );\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/boot/model/internal/QueryBinder.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html.\n */\npackage org.hibernate.boot.model.internal;\n\nimport java.lang.invoke.MethodHandles;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.function.Supplier;\n\nimport org.hibernate.AnnotationException;\nimport org.hibernate.CacheMode;\nimport org.hibernate.FlushMode;\nimport org.hibernate.LockOptions;\nimport org.hibernate.annotations.FlushModeType;\nimport org.hibernate.annotations.HQLSelect;\nimport org.hibernate.annotations.SQLSelect;\nimport org.hibernate.boot.internal.NamedHqlQueryDefinitionImpl;\nimport org.hibernate.boot.internal.NamedProcedureCallDefinitionImpl;\nimport org.hibernate.boot.models.JpaAnnotations;\nimport org.hibernate.boot.models.annotations.internal.NamedStoredProcedureQueryJpaAnnotation;\nimport org.hibernate.boot.models.annotations.internal.QueryHintJpaAnnotation;\nimport org.hibernate.boot.models.annotations.internal.StoredProcedureParameterJpaAnnotation;\nimport org.hibernate.boot.query.NamedHqlQueryDefinition;\nimport org.hibernate.boot.query.NamedNativeQueryDefinition;\nimport org.hibernate.boot.query.NamedProcedureCallDefinition;\nimport org.hibernate.boot.query.SqlResultSetMappingDescriptor;\nimport org.hibernate.boot.registry.classloading.spi.ClassLoaderService;\nimport org.hibernate.boot.spi.MetadataBuildingContext;\nimport org.hibernate.internal.CoreMessageLogger;\nimport org.hibernate.internal.log.DeprecationLogger;\nimport org.hibernate.jpa.HibernateHints;\nimport org.hibernate.models.internal.util.StringHelper;\nimport org.hibernate.models.spi.ClassDetails;\nimport org.hibernate.models.spi.SourceModelBuildingContext;\nimport org.hibernate.query.sql.internal.ParameterParser;\nimport org.hibernate.query.sql.spi.ParameterRecognizer;\nimport org.hibernate.type.BasicType;\n\nimport org.jboss.logging.Logger;\n\nimport jakarta.persistence.CacheRetrieveMode;\nimport jakarta.persistence.CacheStoreMode;\nimport jakarta.persistence.NamedNativeQuery;\nimport jakarta.persistence.NamedQuery;\nimport jakarta.persistence.NamedStoredProcedureQuery;\nimport jakarta.persistence.ParameterMode;\nimport jakarta.persistence.QueryHint;\nimport jakarta.persistence.SqlResultSetMapping;\nimport jakarta.persistence.StoredProcedureParameter;\n\nimport static java.lang.Boolean.TRUE;\nimport static org.hibernate.internal.util.StringHelper.nullIfEmpty;\nimport static org.hibernate.internal.util.collections.ArrayHelper.isEmpty;\nimport static org.hibernate.internal.util.collections.CollectionHelper.determineProperSizing;\nimport static org.hibernate.internal.util.collections.CollectionHelper.setOf;\n\n/**\n * Responsible for reading named queries defined in annotations and registering\n * {@link org.hibernate.boot.query.NamedQueryDefinition} objects.\n *\n * @implNote This class is stateless, unlike most of the other \"binders\".\n *\n * @author Emmanuel Bernard\n */\npublic abstract class QueryBinder {\n\tprivate static final CoreMessageLogger LOG = Logger.getMessageLogger( MethodHandles.lookup(), CoreMessageLogger.class, QueryBinder.class.getName() );\n\n\tpublic static void bindQuery(\n\t\t\tNamedQuery namedQuery,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\tif ( namedQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String queryName = namedQuery.name();\n\t\tfinal String queryString = namedQuery.query();\n\t\tfinal Class<?> resultClass = namedQuery.resultClass();\n\n\t\tif ( queryName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named query: %s => %s\", queryName, queryString );\n\t\t}\n\n\t\tfinal QueryHintDefinition hints = new QueryHintDefinition( queryName, namedQuery.hints() );\n\t\tfinal NamedHqlQueryDefinition<?> queryMapping =\n\t\t\t\tcreateNamedQueryDefinition( queryName, queryString, resultClass,\n\t\t\t\t\t\thints.determineLockOptions( namedQuery ), hints );\n\t\tif ( isDefault ) {\n\t\t\tcontext.getMetadataCollector().addDefaultQuery( queryMapping );\n\t\t}\n\t\telse {\n\t\t\tcontext.getMetadataCollector().addNamedQuery( queryMapping );\n\t\t}\n\t}\n\n\tprivate static <T> NamedHqlQueryDefinitionImpl<T> createNamedQueryDefinition(\n\t\t\tString queryName, String queryString, Class<T> resultClass, LockOptions lockOptions,\n\t\t\tQueryHintDefinition hints) {\n\t\treturn new NamedHqlQueryDefinitionImpl.Builder<T>(queryName)\n\t\t\t\t.setHqlString(queryString)\n\t\t\t\t.setResultClass(resultClass)\n\t\t\t\t.setCacheable(hints.getCacheability())\n\t\t\t\t.setCacheMode(hints.getCacheMode())\n\t\t\t\t.setCacheRegion(hints.getString(HibernateHints.HINT_CACHE_REGION))\n\t\t\t\t.setTimeout(hints.getTimeout())\n\t\t\t\t.setFetchSize(hints.getInteger(HibernateHints.HINT_FETCH_SIZE))\n\t\t\t\t.setFlushMode(hints.getFlushMode())\n\t\t\t\t.setReadOnly(hints.getBooleanWrapper(HibernateHints.HINT_READ_ONLY))\n\t\t\t\t.setLockOptions(lockOptions)\n\t\t\t\t.setComment(hints.getString(HibernateHints.HINT_COMMENT))\n\t\t\t\t.build();\n\t}\n\n\tpublic static void bindNativeQuery(\n\t\t\tNamedNativeQuery namedNativeQuery,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\tif ( namedNativeQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String registrationName = namedNativeQuery.name();\n\t\tfinal String queryString = namedNativeQuery.query();\n\n\t\tif ( registrationName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedNativeQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tfinal QueryHintDefinition hints = new QueryHintDefinition( registrationName, namedNativeQuery.hints() );\n\n\t\tfinal String resultSetMappingName = namedNativeQuery.resultSetMapping();\n\t\tfinal Class<?> resultClassDetails = namedNativeQuery.resultClass();\n\t\tfinal Class<?> resultClass = void.class == resultClassDetails ? null : resultClassDetails;\n\n\t\tfinal NamedNativeQueryDefinition<?> queryDefinition =\n\t\t\t\tcreateNamedQueryDefinition( registrationName, queryString, resultClass, resultSetMappingName, hints );\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named native query: %s => %s\",\n\t\t\t\t\tqueryDefinition.getRegistrationName(), queryDefinition.getSqlQueryString() );\n\t\t}\n\n\t\tif ( isDefault ) {\n\t\t\tcontext.getMetadataCollector().addDefaultNamedNativeQuery( queryDefinition );\n\t\t}\n\t\telse {\n\t\t\tcontext.getMetadataCollector().addNamedNativeQuery( queryDefinition );\n\t\t}\n\t}\n\n\tprivate static <T> NamedNativeQueryDefinition<T> createNamedQueryDefinition(\n\t\t\tString registrationName, String queryString,\n\t\t\tClass<T> resultClass, String resultSetMappingName,\n\t\t\tQueryHintDefinition hints) {\n\t\treturn new NamedNativeQueryDefinition.Builder<T>(registrationName)\n\t\t\t\t.setSqlString(queryString)\n\t\t\t\t.setResultClass(resultClass)\n\t\t\t\t.setResultSetMappingName(resultSetMappingName)\n\t\t\t\t.setQuerySpaces(null)\n\t\t\t\t.setCacheable(hints.getCacheability())\n\t\t\t\t.setCacheMode(hints.getCacheMode())\n\t\t\t\t.setCacheRegion(hints.getString(HibernateHints.HINT_CACHE_REGION))\n\t\t\t\t.setTimeout(hints.getTimeout())\n\t\t\t\t.setFetchSize(hints.getInteger(HibernateHints.HINT_FETCH_SIZE))\n\t\t\t\t.setFlushMode(hints.getFlushMode())\n\t\t\t\t.setReadOnly(hints.getBooleanWrapper(HibernateHints.HINT_READ_ONLY))\n\t\t\t\t.setComment(hints.getString(HibernateHints.HINT_COMMENT))\n\t\t\t\t.addHints(hints.getHintsMap())\n\t\t\t\t.build();\n\t}\n\n\tpublic static void bindNativeQuery(\n\t\t\tString name,\n\t\t\tSQLSelect sqlSelect,\n\t\t\tClassDetails annotatedClass,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal NamedNativeQueryDefinition.Builder<?> builder = new NamedNativeQueryDefinition.Builder<>( name )\n\t\t\t\t.setFlushMode( FlushMode.MANUAL )\n\t\t\t\t.setSqlString( sqlSelect.sql() )\n\t\t\t\t.setQuerySpaces( setOf( sqlSelect.querySpaces() ) );\n\n\t\tif ( annotatedClass != null ) {\n\t\t\tbuilder.setResultClass(\n\t\t\t\t\tcontext.getBootstrapContext().getServiceRegistry().requireService( ClassLoaderService.class )\n\t\t\t\t\t\t\t.classForName( annotatedClass.getClassName() )\n\t\t\t);\n\t\t}\n\n\t\tfinal SqlResultSetMapping resultSetMapping = sqlSelect.resultSetMapping();\n\t\tif ( !isEmpty( resultSetMapping.columns() )\n\t\t\t\t|| !isEmpty( resultSetMapping.entities() )\n\t\t\t\t|| !isEmpty( resultSetMapping.classes() ) ) {\n\t\t\tcontext.getMetadataCollector()\n\t\t\t\t\t.addResultSetMapping( SqlResultSetMappingDescriptor.from( resultSetMapping, name ) );\n\t\t\tbuilder.setResultSetMappingName( name );\n\t\t}\n\n\t\tcontext.getMetadataCollector().addNamedNativeQuery( builder.build() );\n\t}\n\n\tpublic static void bindNativeQuery(\n\t\t\torg.hibernate.annotations.NamedNativeQuery namedNativeQuery,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( namedNativeQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String registrationName = namedNativeQuery.name();\n\n\t\tif ( registrationName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedNativeQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tfinal String resultSetMappingName = namedNativeQuery.resultSetMapping();\n\t\tfinal Class<?> resultClassDetails = namedNativeQuery.resultClass();\n\t\tfinal Class<?> resultClass = resultClassDetails == void.class ? null : resultClassDetails;\n\n\t\tfinal String[] querySpacesList = namedNativeQuery.querySpaces();\n\t\tfinal HashSet<String> querySpaces = new HashSet<>( determineProperSizing( querySpacesList.length ) );\n\t\tCollections.addAll( querySpaces, querySpacesList );\n\n\t\tfinal NamedNativeQueryDefinition.Builder<?> builder =\n\t\t\t\tcreateQueryDefinition( namedNativeQuery, registrationName, resultSetMappingName, resultClass,\n\t\t\t\t\t\tnamedNativeQuery.timeout(), namedNativeQuery.fetchSize(), querySpaces );\n\n\t\tif ( TRUE == namedNativeQuery.callable() ) {\n\t\t\tfinal NamedProcedureCallDefinition definition =\n\t\t\t\t\tcreateStoredProcedure( builder, context, () -> illegalCallSyntax( namedNativeQuery ) );\n\t\t\tcontext.getMetadataCollector().addNamedProcedureCallDefinition( definition );\n\t\t\tDeprecationLogger.DEPRECATION_LOGGER.warn(\n\t\t\t\t\t\"Marking named native queries as callable is no longer supported; use '@jakarta.persistence.NamedStoredProcedureQuery' instead. Ignoring.\"\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tfinal NamedNativeQueryDefinition<?> queryDefinition = builder.build();\n\n\t\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\t\tLOG.debugf(\n\t\t\t\t\t\t\"Binding named native query: %s => %s\",\n\t\t\t\t\t\tqueryDefinition.getRegistrationName(),\n\t\t\t\t\t\tqueryDefinition.getSqlQueryString()\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tcontext.getMetadataCollector().addNamedNativeQuery( queryDefinition );\n\t\t}\n\t}\n\n\tprivate static <T> NamedNativeQueryDefinition.Builder<T> createQueryDefinition(\n\t\t\torg.hibernate.annotations.NamedNativeQuery namedNativeQuery,\n\t\t\tString registrationName, String resultSetMappingName,\n\t\t\tClass<T> resultClass,\n\t\t\tint timeout, int fetchSize,\n\t\t\tHashSet<String> querySpaces) {\n\t\treturn new NamedNativeQueryDefinition.Builder<T>(registrationName)\n\t\t\t\t.setSqlString(namedNativeQuery.query())\n\t\t\t\t.setResultSetMappingName(resultSetMappingName)\n\t\t\t\t.setResultClass(resultClass)\n\t\t\t\t.setCacheable(namedNativeQuery.cacheable())\n\t\t\t\t.setCacheRegion(nullIfEmpty(namedNativeQuery.cacheRegion()))\n\t\t\t\t.setCacheMode(getCacheMode(namedNativeQuery.cacheRetrieveMode(), namedNativeQuery.cacheStoreMode()))\n\t\t\t\t.setTimeout(timeout < 0 ? null : timeout)\n\t\t\t\t.setFetchSize(fetchSize < 0 ? null : fetchSize)\n\t\t\t\t.setFlushMode(getFlushMode(namedNativeQuery.flushMode()))\n\t\t\t\t.setReadOnly(namedNativeQuery.readOnly())\n\t\t\t\t.setQuerySpaces(querySpaces)\n\t\t\t\t.setComment(nullIfEmpty(namedNativeQuery.comment()));\n\t}\n\n\t/**\n\t * Handles legacy cases where a named native query was used to specify a procedure call\n\t *\n\t * @deprecated User should use {@linkplain NamedStoredProcedureQuery} instead\n\t */\n\t@Deprecated\n\tpublic static NamedProcedureCallDefinition createStoredProcedure(\n\t\t\tNamedNativeQueryDefinition.Builder<?> builder,\n\t\t\tMetadataBuildingContext context,\n\t\t\tSupplier<RuntimeException> exceptionProducer) {\n\t\tfinal String sqlString = builder.getSqlString().trim();\n\t\tif ( !sqlString.startsWith( \"{\" ) || !sqlString.endsWith( \"}\" ) ) {\n\t\t\tthrow exceptionProducer.get();\n\t\t}\n\t\tfinal JdbcCall jdbcCall = parseJdbcCall( sqlString, exceptionProducer );\n\n\t\tfinal SourceModelBuildingContext sourceModelBuildingContext = context.getMetadataCollector()\n\t\t\t\t.getSourceModelBuildingContext();\n\t\tfinal NamedStoredProcedureQueryJpaAnnotation nameStoredProcedureQueryAnn =\n\t\t\t\tJpaAnnotations.NAMED_STORED_PROCEDURE_QUERY.createUsage( sourceModelBuildingContext );\n\t\tnameStoredProcedureQueryAnn.name( builder.getName() );\n\t\tnameStoredProcedureQueryAnn.procedureName( jdbcCall.callableName );\n\n\t\tfinal StoredProcedureParameter[] parameters = new StoredProcedureParameter[jdbcCall.parameters.size()];\n\t\tnameStoredProcedureQueryAnn.parameters( parameters );\n\n\t\tfor ( int i = 0; i < jdbcCall.parameters.size(); i++ ) {\n\t\t\tfinal StoredProcedureParameterJpaAnnotation param =\n\t\t\t\t\tJpaAnnotations.STORED_PROCEDURE_PARAMETER.createUsage( sourceModelBuildingContext );\n\t\t\tparameters[i] = param;\n\n\t\t\tfinal String paramName = jdbcCall.parameters.get( i );\n\t\t\tparam.name( paramName );\n\t\t\tparam.mode( ParameterMode.IN );\n\n\t\t\tfinal String typeName = builder.getParameterTypes().get( paramName );\n\t\t\tfinal ClassDetails classDetails;\n\t\t\tif ( StringHelper.isEmpty( typeName ) ) {\n\t\t\t\tclassDetails = ClassDetails.VOID_CLASS_DETAILS;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfinal BasicType<Object> registeredType = context.getBootstrapContext()\n\t\t\t\t\t\t.getTypeConfiguration()\n\t\t\t\t\t\t.getBasicTypeRegistry()\n\t\t\t\t\t\t.getRegisteredType( typeName );\n\t\t\t\tclassDetails = context.getMetadataCollector().getClassDetailsRegistry()\n\t\t\t\t\t\t.getClassDetails( registeredType.getJavaType().getName() );\n\t\t\t}\n\t\t\tparam.type( classDetails.toJavaClass() );\n\t\t}\n\n\t\tif ( builder.getResultSetMappingName() != null ) {\n\t\t\tnameStoredProcedureQueryAnn.resultSetMappings( new String[] { builder.getResultSetMappingName() } );\n\t\t}\n\n\t\tfinal Class<?> resultClass = builder.getResultClass();\n\t\tif ( resultClass != null ) {\n\t\t\tnameStoredProcedureQueryAnn.resultClasses( new Class[]{ builder.getResultClass() } );\n\t\t}\n\n\t\tfinal List<QueryHintJpaAnnotation> hints = new ArrayList<>();\n\n\t\tif ( builder.getQuerySpaces() != null ) {\n\t\t\tfinal QueryHintJpaAnnotation hint =\n\t\t\t\t\tJpaAnnotations.QUERY_HINT.createUsage( sourceModelBuildingContext );\n\t\t\thint.name( HibernateHints.HINT_NATIVE_SPACES );\n\t\t\thint.value( String.join( \" \", builder.getQuerySpaces() ) );\n\t\t\thints.add( hint );\n\t\t}\n\n\t\tif ( jdbcCall.resultParameter ) {\n\t\t\t// Mark native queries that have a result parameter as callable functions\n\t\t\tfinal QueryHintJpaAnnotation hint =\n\t\t\t\t\tJpaAnnotations.QUERY_HINT.createUsage( sourceModelBuildingContext );\n\t\t\thint.name( HibernateHints.HINT_CALLABLE_FUNCTION );\n\t\t\thint.value( \"true\" );\n\t\t\thints.add( hint );\n\t\t}\n\n\t\tnameStoredProcedureQueryAnn.hints( hints.toArray(QueryHint[]::new) );\n\n\t\treturn new NamedProcedureCallDefinitionImpl( nameStoredProcedureQueryAnn );\n\t}\n\n\tpublic static void bindQuery(\n\t\t\tString name,\n\t\t\tHQLSelect hqlSelect,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal NamedHqlQueryDefinition<?> hqlQueryDefinition = new NamedHqlQueryDefinition.Builder<>( name )\n\t\t\t\t.setFlushMode( FlushMode.MANUAL )\n\t\t\t\t.setHqlString( hqlSelect.query() )\n\t\t\t\t.build();\n\n\t\tcontext.getMetadataCollector().addNamedQuery( hqlQueryDefinition );\n\t}\n\n\tpublic static void bindQuery(\n\t\t\torg.hibernate.annotations.NamedQuery namedQuery,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( namedQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String registrationName = namedQuery.name();\n\t\tfinal Class<?> resultClass = namedQuery.resultClass();\n\n\t\tif ( registrationName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tfinal NamedHqlQueryDefinition.Builder<?> builder =\n\t\t\t\tcreateQueryDefinition( namedQuery, registrationName, resultClass,\n\t\t\t\t\t\tnamedQuery.timeout(), namedQuery.fetchSize() ) ;\n\n\t\tfinal NamedHqlQueryDefinitionImpl<?> hqlQueryDefinition = builder.build();\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named query: %s => %s\",\n\t\t\t\t\thqlQueryDefinition.getRegistrationName(), hqlQueryDefinition.getHqlString() );\n\t\t}\n\n\t\tcontext.getMetadataCollector().addNamedQuery( hqlQueryDefinition );\n\t}\n\n\tprivate static <T> NamedHqlQueryDefinition.Builder<T> createQueryDefinition(\n\t\t\torg.hibernate.annotations.NamedQuery namedQuery,\n\t\t\tString registrationName, Class<T> resultClass, int timeout, int fetchSize) {\n\t\treturn new NamedHqlQueryDefinition.Builder<T>(registrationName)\n\t\t\t\t.setHqlString(namedQuery.query())\n\t\t\t\t.setResultClass(resultClass)\n\t\t\t\t.setCacheable(namedQuery.cacheable())\n\t\t\t\t.setCacheRegion(nullIfEmpty(namedQuery.cacheRegion()))\n\t\t\t\t.setCacheMode(getCacheMode(namedQuery.cacheRetrieveMode(), namedQuery.cacheStoreMode()))\n\t\t\t\t.setTimeout(timeout < 0 ? null : timeout)\n\t\t\t\t.setFetchSize(fetchSize < 0 ? null : fetchSize)\n\t\t\t\t.setFlushMode(getFlushMode(namedQuery.flushMode()))\n\t\t\t\t.setReadOnly(namedQuery.readOnly())\n\t\t\t\t.setComment(nullIfEmpty(namedQuery.comment()));\n\t}\n\n\tprivate static CacheMode getCacheMode(CacheRetrieveMode cacheRetrieveMode, CacheStoreMode cacheStoreMode) {\n\t\tfinal CacheMode cacheMode = CacheMode.fromJpaModes( cacheRetrieveMode, cacheStoreMode );\n\t\treturn cacheMode == null ? CacheMode.NORMAL : cacheMode;\n\t}\n\n\tprivate static FlushMode getFlushMode(FlushModeType flushModeType) {\n\t\treturn switch ( flushModeType ) {\n\t\t\tcase ALWAYS -> FlushMode.ALWAYS;\n\t\t\tcase AUTO -> FlushMode.AUTO;\n\t\t\tcase COMMIT -> FlushMode.COMMIT;\n\t\t\tcase MANUAL -> FlushMode.MANUAL;\n\t\t\tcase PERSISTENCE_CONTEXT -> null;\n\t\t};\n\t}\n\n\tpublic static void bindNamedStoredProcedureQuery(\n\t\t\tNamedStoredProcedureQuery namedStoredProcedureQuery,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\tif ( namedStoredProcedureQuery != null ) {\n\t\t\tif ( namedStoredProcedureQuery.name().isEmpty() ) {\n\t\t\t\tthrow new AnnotationException( \"Class or package level '@NamedStoredProcedureQuery' annotation must specify a 'name'\" );\n\t\t\t}\n\n\t\t\tfinal NamedProcedureCallDefinitionImpl definition =\n\t\t\t\t\tnew NamedProcedureCallDefinitionImpl( namedStoredProcedureQuery );\n\t\t\tif ( isDefault ) {\n\t\t\t\tcontext.getMetadataCollector().addDefaultNamedProcedureCall( definition );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcontext.getMetadataCollector().addNamedProcedureCallDefinition( definition );\n\t\t\t}\n\t\t\tLOG.debugf( \"Bound named stored procedure query : %s => %s\",\n\t\t\t\t\tdefinition.getRegistrationName(), definition.getProcedureName() );\n\t\t}\n\t}\n\n\tpublic static void bindSqlResultSetMapping(\n\t\t\tSqlResultSetMapping resultSetMappingAnn,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\t//no need to handle inSecondPass\n\t\tcontext.getMetadataCollector()\n\t\t\t\t.addSecondPass( new ResultSetMappingSecondPass( resultSetMappingAnn, context, isDefault ) );\n\t}\n\n\tprivate static class JdbcCall {\n\t\tprivate final String callableName;\n\t\tprivate final boolean resultParameter;\n\t\tprivate final ArrayList<String> parameters;\n\n\t\tpublic JdbcCall(String callableName, boolean resultParameter, ArrayList<String> parameters) {\n\t\t\tthis.callableName = callableName;\n\t\t\tthis.resultParameter = resultParameter;\n\t\t\tthis.parameters = parameters;\n\t\t}\n\t}\n\n\tprivate static JdbcCall parseJdbcCall(String sqlString, Supplier<RuntimeException> exceptionProducer) {\n\t\tString callableName = null;\n\t\tboolean resultParameter = false;\n\t\tint index = skipWhitespace( sqlString, 1 );\n\t\t// Parse the out param `?=` part\n\t\tif ( sqlString.charAt( index ) == '?' ) {\n\t\t\tresultParameter = true;\n\t\t\tindex++;\n\t\t\tindex = skipWhitespace( sqlString, index );\n\t\t\tif ( sqlString.charAt( index ) != '=' ) {\n\t\t\t\tthrow exceptionProducer.get();\n\t\t\t}\n\t\t\tindex++;\n\t\t\tindex = skipWhitespace( sqlString, index );\n\t\t}\n\t\t// Parse the call keyword\n\t\tif ( !sqlString.regionMatches( true, index, \"call\", 0, 4 ) ) {\n\t\t\tthrow exceptionProducer.get();\n\t\t}\n\t\tindex += 4;\n\t\tindex = skipWhitespace( sqlString, index );\n\n\t\t// Parse the procedure name\n\t\tfinal int procedureStart = index;\n\t\tfor ( ; index < sqlString.length(); index++ ) {\n\t\t\tfinal char c = sqlString.charAt( index );\n\t\t\tif ( c == '(' || Character.isWhitespace( c ) ) {\n\t\t\t\tcallableName = sqlString.substring( procedureStart, index );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tindex = skipWhitespace( sqlString, index );\n\t\tfinal ArrayList<String> parameters = new ArrayList<>();\n\t\tParameterParser.parse(\n\t\t\t\tsqlString.substring( index, sqlString.length() - 1 ),\n\t\t\t\tnew ParameterRecognizer() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void ordinalParameter(int sourcePosition) {\n\t\t\t\t\t\tparameters.add( \"\" );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void namedParameter(String name, int sourcePosition) {\n\t\t\t\t\t\tparameters.add( name );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void jpaPositionalParameter(int label, int sourcePosition) {\n\t\t\t\t\t\tparameters.add( \"\" );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void other(char character) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\treturn new JdbcCall( callableName, resultParameter, parameters );\n\t}\n\n\tprivate static int skipWhitespace(String sqlString, int i) {\n\t\twhile ( i < sqlString.length() ) {\n\t\t\tif ( !Character.isWhitespace( sqlString.charAt( i ) ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn i;\n\t}\n\n\tprivate static AnnotationException illegalCallSyntax(org.hibernate.annotations.NamedNativeQuery queryAnn) {\n\t\treturn new AnnotationException( \"Callable 'NamedNativeQuery' named '\" + queryAnn.name()\n\t\t\t\t+ \"' does not use the JDBC call syntax\" );\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private static <T> NamedNativeQueryDefinition.Builder<T> createQueryDefinition(\n\t\t\torg.hibernate.annotations.NamedNativeQuery namedNativeQuery,\n\t\t\tString registrationName, String resultSetMappingName,\n\t\t\tClass<T> resultClass,\n\t\t\tint timeout, int fetchSize,\n\t\t\tHashSet<String> querySpaces) {\n\t\treturn new NamedNativeQueryDefinition.Builder<T>(registrationName)\n\t\t\t\t.setSqlString(namedNativeQuery.query())\n\t\t\t\t.setResultSetMappingName(resultSetMappingName)\n\t\t\t\t.setResultClass(resultClass)\n\t\t\t\t.setCacheable(namedNativeQuery.cacheable())\n\t\t\t\t.setCacheRegion(nullIfEmpty(namedNativeQuery.cacheRegion()))\n\t\t\t\t.setCacheMode(getCacheMode(namedNativeQuery.cacheRetrieveMode(), namedNativeQuery.cacheStoreMode()))\n\t\t\t\t.setTimeout(timeout < 0 ? null : timeout)\n\t\t\t\t.setFetchSize(fetchSize < 0 ? null : fetchSize)\n\t\t\t\t.setFlushMode(getFlushMode(namedNativeQuery.flushMode()))\n\t\t\t\t.setReadOnly(namedNativeQuery.readOnly())\n\t\t\t\t.setQuerySpaces(querySpaces)\n\t\t\t\t.setComment(nullIfEmpty(namedNativeQuery.comment()));\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.boot.model.internal.QueryBinder#getCacheMode\n methodBody: private static CacheMode getCacheMode(CacheRetrieveMode cacheRetrieveMode, CacheStoreMode cacheStoreMode) {\nfinal CacheMode cacheMode=CacheMode.fromJpaModes(cacheRetrieveMode,cacheStoreMode);\nreturn cacheMode == null ? CacheMode.NORMAL : cacheMode;\n}",
            "methodSignature: org.hibernate.boot.model.internal.QueryBinder#illegalCallSyntax\n methodBody: private static AnnotationException illegalCallSyntax(org.hibernate.annotations.NamedNativeQuery queryAnn) {\nreturn new AnnotationException(\"Callable 'NamedNativeQuery' named '\" + queryAnn.name() + \"' does not use the JDBC call syntax\");\n}",
            "methodSignature: org.hibernate.boot.model.internal.QueryBinder#createStoredProcedure\n methodBody: public static NamedProcedureCallDefinition createStoredProcedure(\n\t\t\tNamedNativeQueryDefinition.Builder<?> builder,\n\t\t\tMetadataBuildingContext context,\n\t\t\tSupplier<RuntimeException> exceptionProducer) {\nfinal String sqlString=builder.getSqlString().trim();\nif(!sqlString.startsWith(\"{\") || !sqlString.endsWith(\"}\")){throw exceptionProducer.get();\n}final JdbcCall jdbcCall=parseJdbcCall(sqlString,exceptionProducer);\nfinal SourceModelBuildingContext sourceModelBuildingContext=context.getMetadataCollector().getSourceModelBuildingContext();\nfinal NamedStoredProcedureQueryJpaAnnotation nameStoredProcedureQueryAnn=JpaAnnotations.NAMED_STORED_PROCEDURE_QUERY.createUsage(sourceModelBuildingContext);\nnameStoredProcedureQueryAnn.name(builder.getName());\nnameStoredProcedureQueryAnn.procedureName(jdbcCall.callableName);\nfinal StoredProcedureParameter[] parameters=new StoredProcedureParameter[jdbcCall.parameters.size()];\nnameStoredProcedureQueryAnn.parameters(parameters);\nfor(int i=0; i < jdbcCall.parameters.size(); i++){final StoredProcedureParameterJpaAnnotation param=JpaAnnotations.STORED_PROCEDURE_PARAMETER.createUsage(sourceModelBuildingContext);\nparameters[i]=param;\nfinal String paramName=jdbcCall.parameters.get(i);\nparam.name(paramName);\nparam.mode(ParameterMode.IN);\nfinal String typeName=builder.getParameterTypes().get(paramName);\nfinal ClassDetails classDetails;\nif(StringHelper.isEmpty(typeName)){classDetails=ClassDetails.VOID_CLASS_DETAILS;\n}{final BasicType<Object> registeredType=context.getBootstrapContext().getTypeConfiguration().getBasicTypeRegistry().getRegisteredType(typeName);\nclassDetails=context.getMetadataCollector().getClassDetailsRegistry().getClassDetails(registeredType.getJavaType().getName());\n}param.type(classDetails.toJavaClass());\n}if(builder.getResultSetMappingName() != null){nameStoredProcedureQueryAnn.resultSetMappings(new String[]{builder.getResultSetMappingName()});\n}final Class<?> resultClass=builder.getResultClass();\nif(resultClass != null){nameStoredProcedureQueryAnn.resultClasses(new Class[]{builder.getResultClass()});\n}final List<QueryHintJpaAnnotation> hints=new ArrayList<>();\nif(builder.getQuerySpaces() != null){final QueryHintJpaAnnotation hint=JpaAnnotations.QUERY_HINT.createUsage(sourceModelBuildingContext);\nhint.name(HibernateHints.HINT_NATIVE_SPACES);\nhint.value(String.join(\" \",builder.getQuerySpaces()));\nhints.add(hint);\n}if(jdbcCall.resultParameter){final QueryHintJpaAnnotation hint=JpaAnnotations.QUERY_HINT.createUsage(sourceModelBuildingContext);\nhint.name(HibernateHints.HINT_CALLABLE_FUNCTION);\nhint.value(\"true\");\nhints.add(hint);\n}nameStoredProcedureQueryAnn.hints(hints.toArray(QueryHint[]::new));\nreturn new NamedProcedureCallDefinitionImpl(nameStoredProcedureQueryAnn);\n}",
            "methodSignature: org.hibernate.boot.model.internal.QueryBinder#getFlushMode\n methodBody: private static FlushMode getFlushMode(FlushModeType flushModeType) {\nreturn switch (flushModeType) {\ncase ALWAYS ->  yield FlushMode.ALWAYS;\ncase AUTO ->yield FlushMode.AUTO;\ncase COMMIT ->yield FlushMode.COMMIT;\ncase MANUAL ->yield FlushMode.MANUAL;\ncase PERSISTENCE_CONTEXT ->yield null;\n}\n;\n}"
        ],
        "sourceCodeAfterRefactoring": "public static void bindNativeQuery(\n\t\t\torg.hibernate.annotations.NamedNativeQuery namedNativeQuery,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( namedNativeQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String registrationName = namedNativeQuery.name();\n\n\t\tif ( registrationName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedNativeQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tfinal String resultSetMappingName = namedNativeQuery.resultSetMapping();\n\t\tfinal Class<?> resultClassDetails = namedNativeQuery.resultClass();\n\t\tfinal Class<?> resultClass = resultClassDetails == void.class ? null : resultClassDetails;\n\n\t\tfinal String[] querySpacesList = namedNativeQuery.querySpaces();\n\t\tfinal HashSet<String> querySpaces = new HashSet<>( determineProperSizing( querySpacesList.length ) );\n\t\tCollections.addAll( querySpaces, querySpacesList );\n\n\t\tfinal NamedNativeQueryDefinition.Builder<?> builder =\n\t\t\t\tcreateQueryDefinition( namedNativeQuery, registrationName, resultSetMappingName, resultClass,\n\t\t\t\t\t\tnamedNativeQuery.timeout(), namedNativeQuery.fetchSize(), querySpaces );\n\n\t\tif ( TRUE == namedNativeQuery.callable() ) {\n\t\t\tfinal NamedProcedureCallDefinition definition =\n\t\t\t\t\tcreateStoredProcedure( builder, context, () -> illegalCallSyntax( namedNativeQuery ) );\n\t\t\tcontext.getMetadataCollector().addNamedProcedureCallDefinition( definition );\n\t\t\tDeprecationLogger.DEPRECATION_LOGGER.warn(\n\t\t\t\t\t\"Marking named native queries as callable is no longer supported; use '@jakarta.persistence.NamedStoredProcedureQuery' instead. Ignoring.\"\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tfinal NamedNativeQueryDefinition<?> queryDefinition = builder.build();\n\n\t\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\t\tLOG.debugf(\n\t\t\t\t\t\t\"Binding named native query: %s => %s\",\n\t\t\t\t\t\tqueryDefinition.getRegistrationName(),\n\t\t\t\t\t\tqueryDefinition.getSqlQueryString()\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tcontext.getMetadataCollector().addNamedNativeQuery( queryDefinition );\n\t\t}\n\t}\nprivate static <T> NamedNativeQueryDefinition.Builder<T> createQueryDefinition(\n\t\t\torg.hibernate.annotations.NamedNativeQuery namedNativeQuery,\n\t\t\tString registrationName, String resultSetMappingName,\n\t\t\tClass<T> resultClass,\n\t\t\tint timeout, int fetchSize,\n\t\t\tHashSet<String> querySpaces) {\n\t\treturn new NamedNativeQueryDefinition.Builder<T>(registrationName)\n\t\t\t\t.setSqlString(namedNativeQuery.query())\n\t\t\t\t.setResultSetMappingName(resultSetMappingName)\n\t\t\t\t.setResultClass(resultClass)\n\t\t\t\t.setCacheable(namedNativeQuery.cacheable())\n\t\t\t\t.setCacheRegion(nullIfEmpty(namedNativeQuery.cacheRegion()))\n\t\t\t\t.setCacheMode(getCacheMode(namedNativeQuery.cacheRetrieveMode(), namedNativeQuery.cacheStoreMode()))\n\t\t\t\t.setTimeout(timeout < 0 ? null : timeout)\n\t\t\t\t.setFetchSize(fetchSize < 0 ? null : fetchSize)\n\t\t\t\t.setFlushMode(getFlushMode(namedNativeQuery.flushMode()))\n\t\t\t\t.setReadOnly(namedNativeQuery.readOnly())\n\t\t\t\t.setQuerySpaces(querySpaces)\n\t\t\t\t.setComment(nullIfEmpty(namedNativeQuery.comment()));\n\t}",
        "diffSourceCode": "-  205: \tpublic static void bindNativeQuery(\n-  206: \t\t\torg.hibernate.annotations.NamedNativeQuery namedNativeQuery,\n-  207: \t\t\tMetadataBuildingContext context) {\n-  208: \t\tif ( namedNativeQuery == null ) {\n-  209: \t\t\treturn;\n-  210: \t\t}\n-  211: \n-  212: \t\tfinal String registrationName = namedNativeQuery.name();\n-  213: \n-  214: \t\t//ResultSetMappingDefinition mappingDefinition = mappings.getJdbcValuesMappingProducer( queryAnn.resultSetMapping() );\n-  215: \t\tif ( registrationName.isEmpty() ) {\n-  216: \t\t\tthrow new AnnotationException( \"Class or package level '@NamedNativeQuery' annotation must specify a 'name'\" );\n-  217: \t\t}\n-  218: \n-  219: \t\tfinal String resultSetMappingName = namedNativeQuery.resultSetMapping();\n-  220: \t\tfinal Class<?> resultClassDetails = namedNativeQuery.resultClass();\n-  221: \t\tfinal Class<Object> resultClass = resultClassDetails == void.class\n-  222: \t\t\t\t? null\n-  223: \t\t\t\t: (Class<Object>) resultClassDetails;\n-  224: \n-  225: \t\tfinal Integer timeout = namedNativeQuery.timeout();\n-  226: \t\tfinal Integer fetchSize = namedNativeQuery.fetchSize();\n+  205: \t\t\tbuilder.setResultSetMappingName( name );\n+  206: \t\t}\n+  207: \n+  208: \t\tcontext.getMetadataCollector().addNamedNativeQuery( builder.build() );\n+  209: \t}\n+  210: \n+  211: \tpublic static void bindNativeQuery(\n+  212: \t\t\torg.hibernate.annotations.NamedNativeQuery namedNativeQuery,\n+  213: \t\t\tMetadataBuildingContext context) {\n+  214: \t\tif ( namedNativeQuery == null ) {\n+  215: \t\t\treturn;\n+  216: \t\t}\n+  217: \n+  218: \t\tfinal String registrationName = namedNativeQuery.name();\n+  219: \n+  220: \t\tif ( registrationName.isEmpty() ) {\n+  221: \t\t\tthrow new AnnotationException( \"Class or package level '@NamedNativeQuery' annotation must specify a 'name'\" );\n+  222: \t\t}\n+  223: \n+  224: \t\tfinal String resultSetMappingName = namedNativeQuery.resultSetMapping();\n+  225: \t\tfinal Class<?> resultClassDetails = namedNativeQuery.resultClass();\n+  226: \t\tfinal Class<?> resultClass = resultClassDetails == void.class ? null : resultClassDetails;\n   227: \n   228: \t\tfinal String[] querySpacesList = namedNativeQuery.querySpaces();\n   229: \t\tfinal HashSet<String> querySpaces = new HashSet<>( determineProperSizing( querySpacesList.length ) );\n   230: \t\tCollections.addAll( querySpaces, querySpacesList );\n   231: \n-  232: \t\tfinal NamedNativeQueryDefinition.Builder<?> builder = new NamedNativeQueryDefinition.Builder<>( registrationName )\n-  233: \t\t\t\t.setSqlString( namedNativeQuery.query() )\n-  234: \t\t\t\t.setResultSetMappingName( resultSetMappingName )\n-  235: \t\t\t\t.setResultClass( resultClass )\n-  236: \t\t\t\t.setCacheable( namedNativeQuery.cacheable() )\n-  237: \t\t\t\t.setCacheRegion( nullIfEmpty( namedNativeQuery.cacheRegion() ) )\n-  238: \t\t\t\t.setCacheMode( getCacheMode( namedNativeQuery.cacheRetrieveMode(), namedNativeQuery.cacheStoreMode() ) )\n-  239: \t\t\t\t.setTimeout( timeout < 0 ? null : timeout )\n-  240: \t\t\t\t.setFetchSize( fetchSize < 0 ? null : fetchSize )\n-  241: \t\t\t\t.setFlushMode( getFlushMode( namedNativeQuery.flushMode() ) )\n-  242: \t\t\t\t.setReadOnly( namedNativeQuery.readOnly() )\n-  243: \t\t\t\t.setQuerySpaces( querySpaces )\n-  244: \t\t\t\t.setComment( nullIfEmpty( namedNativeQuery.comment() ) );\n-  245: \n-  246: \t\tif ( TRUE == namedNativeQuery.callable() ) {\n-  247: \t\t\tfinal NamedProcedureCallDefinition definition =\n-  248: \t\t\t\t\tcreateStoredProcedure( builder, context, () -> illegalCallSyntax( namedNativeQuery ) );\n-  249: \t\t\tcontext.getMetadataCollector().addNamedProcedureCallDefinition( definition );\n-  250: \t\t\tDeprecationLogger.DEPRECATION_LOGGER.warn(\n-  251: \t\t\t\t\t\"Marking named native queries as callable is no longer supported; use '@jakarta.persistence.NamedStoredProcedureQuery' instead. Ignoring.\"\n-  252: \t\t\t);\n-  253: \t\t}\n-  254: \t\telse {\n-  255: \t\t\tfinal NamedNativeQueryDefinition<?> queryDefinition = builder.build();\n-  256: \n-  257: \t\t\tif ( LOG.isDebugEnabled() ) {\n-  258: \t\t\t\tLOG.debugf(\n-  259: \t\t\t\t\t\t\"Binding named native query: %s => %s\",\n-  260: \t\t\t\t\t\tqueryDefinition.getRegistrationName(),\n-  261: \t\t\t\t\t\tqueryDefinition.getSqlQueryString()\n-  262: \t\t\t\t);\n-  263: \t\t\t}\n-  264: \n-  265: \t\t\tcontext.getMetadataCollector().addNamedNativeQuery( queryDefinition );\n-  266: \t\t}\n-  267: \t}\n-  268: \n-  269: \t/**\n-  270: \t * Handles legacy cases where a named native query was used to specify a procedure call\n-  271: \t *\n-  272: \t * @deprecated User should use {@linkplain NamedStoredProcedureQuery} instead\n-  273: \t */\n-  274: \t@Deprecated\n-  275: \tpublic static NamedProcedureCallDefinition createStoredProcedure(\n-  276: \t\t\tNamedNativeQueryDefinition.Builder<?> builder,\n-  277: \t\t\tMetadataBuildingContext context,\n-  278: \t\t\tSupplier<RuntimeException> exceptionProducer) {\n+  232: \t\tfinal NamedNativeQueryDefinition.Builder<?> builder =\n+  233: \t\t\t\tcreateQueryDefinition( namedNativeQuery, registrationName, resultSetMappingName, resultClass,\n+  234: \t\t\t\t\t\tnamedNativeQuery.timeout(), namedNativeQuery.fetchSize(), querySpaces );\n+  235: \n+  236: \t\tif ( TRUE == namedNativeQuery.callable() ) {\n+  237: \t\t\tfinal NamedProcedureCallDefinition definition =\n+  238: \t\t\t\t\tcreateStoredProcedure( builder, context, () -> illegalCallSyntax( namedNativeQuery ) );\n+  239: \t\t\tcontext.getMetadataCollector().addNamedProcedureCallDefinition( definition );\n+  240: \t\t\tDeprecationLogger.DEPRECATION_LOGGER.warn(\n+  241: \t\t\t\t\t\"Marking named native queries as callable is no longer supported; use '@jakarta.persistence.NamedStoredProcedureQuery' instead. Ignoring.\"\n+  242: \t\t\t);\n+  243: \t\t}\n+  244: \t\telse {\n+  245: \t\t\tfinal NamedNativeQueryDefinition<?> queryDefinition = builder.build();\n+  246: \n+  247: \t\t\tif ( LOG.isDebugEnabled() ) {\n+  248: \t\t\t\tLOG.debugf(\n+  249: \t\t\t\t\t\t\"Binding named native query: %s => %s\",\n+  250: \t\t\t\t\t\tqueryDefinition.getRegistrationName(),\n+  251: \t\t\t\t\t\tqueryDefinition.getSqlQueryString()\n+  252: \t\t\t\t);\n+  253: \t\t\t}\n+  254: \n+  255: \t\t\tcontext.getMetadataCollector().addNamedNativeQuery( queryDefinition );\n+  256: \t\t}\n+  257: \t}\n+  258: \n+  259: \tprivate static <T> NamedNativeQueryDefinition.Builder<T> createQueryDefinition(\n+  260: \t\t\torg.hibernate.annotations.NamedNativeQuery namedNativeQuery,\n+  261: \t\t\tString registrationName, String resultSetMappingName,\n+  262: \t\t\tClass<T> resultClass,\n+  263: \t\t\tint timeout, int fetchSize,\n+  264: \t\t\tHashSet<String> querySpaces) {\n+  265: \t\treturn new NamedNativeQueryDefinition.Builder<T>(registrationName)\n+  266: \t\t\t\t.setSqlString(namedNativeQuery.query())\n+  267: \t\t\t\t.setResultSetMappingName(resultSetMappingName)\n+  268: \t\t\t\t.setResultClass(resultClass)\n+  269: \t\t\t\t.setCacheable(namedNativeQuery.cacheable())\n+  270: \t\t\t\t.setCacheRegion(nullIfEmpty(namedNativeQuery.cacheRegion()))\n+  271: \t\t\t\t.setCacheMode(getCacheMode(namedNativeQuery.cacheRetrieveMode(), namedNativeQuery.cacheStoreMode()))\n+  272: \t\t\t\t.setTimeout(timeout < 0 ? null : timeout)\n+  273: \t\t\t\t.setFetchSize(fetchSize < 0 ? null : fetchSize)\n+  274: \t\t\t\t.setFlushMode(getFlushMode(namedNativeQuery.flushMode()))\n+  275: \t\t\t\t.setReadOnly(namedNativeQuery.readOnly())\n+  276: \t\t\t\t.setQuerySpaces(querySpaces)\n+  277: \t\t\t\t.setComment(nullIfEmpty(namedNativeQuery.comment()));\n+  278: \t}\n",
        "uniqueId": "b53728f7278c40ef41e22326f917ca5c718ce6e7_205_267_259_278_211_257",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 27,
                "covered": 62
            },
            "BRANCH": {
                "missed": 4,
                "covered": 6
            },
            "LINE": {
                "missed": 10,
                "covered": 17
            },
            "COMPLEXITY": {
                "missed": 4,
                "covered": 2
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": true,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\npublic static void bindNativeQuery(\n        org.hibernate.annotations.NamedNativeQuery namedNativeQuery,\n        MetadataBuildingContext context) {\n    if (namedNativeQuery == null) {\n        return;\n    }\n\n    final String registrationName = namedNativeQuery.name();\n\n    if (registrationName.isEmpty()) {\n        throw new AnnotationException(\"Class or package level '@NamedNativeQuery' annotation must specify a 'name'\");\n    }\n\n    final String resultSetMappingName = namedNativeQuery.resultSetMapping();\n    final Class<?> resultClassDetails = namedNativeQuery.resultClass();\n    final Class<Object> resultClass = resultClassDetails == void.class\n            ? null\n            : (Class<Object>) resultClassDetails;\n\n    final Integer timeout = namedNativeQuery.timeout();\n    final Integer fetchSize = namedNativeQuery.fetchSize();\n\n    final String[] querySpacesList = namedNativeQuery.querySpaces();\n    final HashSet<String> querySpaces = new HashSet<>(determineProperSizing(querySpacesList.length));\n    Collections.addAll(querySpaces, querySpacesList);\n\n    NamedNativeQueryDefinition<?> queryDefinition = createNamedNativeQueryDefinition(namedNativeQuery, registrationName, resultSetMappingName, resultClass, timeout, fetchSize, querySpaces);\n\n    if (TRUE == namedNativeQuery.callable()) {\n        handleCallableNamedNativeQuery(queryDefinition, context, namedNativeQuery);\n    } else {\n        handleNonCallableNamedNativeQuery(queryDefinition, context);\n    }\n}\n\nprivate static NamedNativeQueryDefinition<?> createNamedNativeQueryDefinition(\n        org.hibernate.annotations.NamedNativeQuery namedNativeQuery,\n        String registrationName,\n        String resultSetMappingName,\n        Class<Object> resultClass,\n        Integer timeout,\n        Integer fetchSize,\n        HashSet<String> querySpaces) {\n    return new NamedNativeQueryDefinition.Builder<>(registrationName)\n            .setSqlString(namedNativeQuery.query())\n            .setResultSetMappingName(resultSetMappingName)\n            .setResultClass(resultClass)\n            .setCacheable(namedNativeQuery.cacheable())\n            .setCacheRegion(nullIfEmpty(namedNativeQuery.cacheRegion()))\n            .setCacheMode(getCacheMode(namedNativeQuery.cacheRetrieveMode(), namedNativeQuery.cacheStoreMode()))\n            .setTimeout(timeout < 0 ? null : timeout)\n            .setFetchSize(fetchSize < 0 ? null : fetchSize)\n            .setFlushMode(getFlushMode(namedNativeQuery.flushMode()))\n            .setReadOnly(namedNativeQuery.readOnly())\n            .setQuerySpaces(querySpaces)\n            .setComment(nullIfEmpty(namedNativeQuery.comment()))\n            .build();\n}\n\nprivate static void handleCallableNamedNativeQuery(NamedNativeQueryDefinition<?> queryDefinition, MetadataBuildingContext context, org.hibernate.annotations.NamedNativeQuery namedNativeQuery) {\n    final NamedProcedureCallDefinition definition = createStoredProcedure(queryDefinition, context, () -> illegalCallSyntax(namedNativeQuery));\n    context.getMetadataCollector().addNamedProcedureCallDefinition(definition);\n    DeprecationLogger.DEPRECATION_LOGGER.warn(\n            \"Marking named native queries as callable is no longer supported; use '@jakarta.persistence.NamedStoredProcedureQuery' instead. Ignoring.\"\n    );\n}\n\nprivate static void handleNonCallableNamedNativeQuery(NamedNativeQueryDefinition<?> queryDefinition, MetadataBuildingContext context) {\n    if (LOG.isDebugEnabled()) {\n        LOG.debugf(\n                \"Binding named native query: %s => %s\",\n                queryDefinition.getRegistrationName(),\n                queryDefinition.getSqlQueryString()\n        );\n    }\n\n    context.getMetadataCollector().addNamedNativeQuery(queryDefinition);\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\npublic static void bindNativeQuery(\n\t\t\torg.hibernate.annotations.NamedNativeQuery namedNativeQuery,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( namedNativeQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String registrationName = namedNativeQuery.name();\n\n\t\t//ResultSetMappingDefinition mappingDefinition = mappings.getJdbcValuesMappingProducer( queryAnn.resultSetMapping() );\n\t\tif ( registrationName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedNativeQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tfinal String resultSetMappingName = namedNativeQuery.resultSetMapping();\n\t\tfinal Class<?> resultClassDetails = namedNativeQuery.resultClass();\n\t\tfinal Class<Object> resultClass = resultClassDetails == void.class\n\t\t\t\t? null\n\t\t\t\t: (Class<Object>) resultClassDetails;\n\n\t\tfinal Integer timeout = namedNativeQuery.timeout();\n\t\tfinal Integer fetchSize = namedNativeQuery.fetchSize();\n\n\t\tfinal String[] querySpacesList = namedNativeQuery.querySpaces();\n\t\tfinal HashSet<String> querySpaces = new HashSet<>( determineProperSizing( querySpacesList.length ) );\n\t\tCollections.addAll( querySpaces, querySpacesList );\n\n\t\tfinal NamedNativeQueryDefinition.Builder<?> builder = new NamedNativeQueryDefinition.Builder<>( registrationName )\n\t\t\t\t.setSqlString( namedNativeQuery.query() )\n\t\t\t\t.setResultSetMappingName( resultSetMappingName )\n\t\t\t\t.setResultClass( resultClass )\n\t\t\t\t.setCacheable( namedNativeQuery.cacheable() )\n\t\t\t\t.setCacheRegion( nullIfEmpty( namedNativeQuery.cacheRegion() ) )\n\t\t\t\t.setCacheMode( getCacheMode( namedNativeQuery.cacheRetrieveMode(), namedNativeQuery.cacheStoreMode() ) )\n\t\t\t\t.setTimeout( timeout < 0 ? null : timeout )\n\t\t\t\t.setFetchSize( fetchSize < 0 ? null : fetchSize )\n\t\t\t\t.setFlushMode( getFlushMode( namedNativeQuery.flushMode() ) )\n\t\t\t\t.setReadOnly( namedNativeQuery.readOnly() )\n\t\t\t\t.setQuerySpaces( querySpaces )\n\t\t\t\t.setComment( nullIfEmpty( namedNativeQuery.comment() ) );\n\n\t\tif ( TRUE == namedNativeQuery.callable() ) {\n\t\t\tfinal NamedProcedureCallDefinition definition =\n\t\t\t\t\tcreateStoredProcedure( builder, context, () -> illegalCallSyntax( namedNativeQuery ) );\n\t\t\tcontext.getMetadataCollector().addNamedProcedureCallDefinition( definition );\n\t\t\tDeprecationLogger.DEPRECATION_LOGGER.warn(\n\t\t\t\t\t\"Marking named native queries as callable is no longer supported; use '@jakarta.persistence.NamedStoredProcedureQuery' instead. Ignoring.\"\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tfinal NamedNativeQueryDefinition<?> queryDefinition = builder.build();\n\n\t\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\t\tLOG.debugf(\n\t\t\t\t\t\t\"Binding named native query: %s => %s\",\n\t\t\t\t\t\tqueryDefinition.getRegistrationName(),\n\t\t\t\t\t\tqueryDefinition.getSqlQueryString()\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tcontext.getMetadataCollector().addNamedNativeQuery( queryDefinition );\n\t\t}\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html.\n */\npackage org.hibernate.boot.model.internal;\n\nimport java.lang.invoke.MethodHandles;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.function.Supplier;\n\nimport org.hibernate.AnnotationException;\nimport org.hibernate.CacheMode;\nimport org.hibernate.FlushMode;\nimport org.hibernate.annotations.FlushModeType;\nimport org.hibernate.annotations.HQLSelect;\nimport org.hibernate.annotations.SQLSelect;\nimport org.hibernate.boot.internal.NamedHqlQueryDefinitionImpl;\nimport org.hibernate.boot.internal.NamedProcedureCallDefinitionImpl;\nimport org.hibernate.boot.models.JpaAnnotations;\nimport org.hibernate.boot.models.annotations.internal.NamedStoredProcedureQueryJpaAnnotation;\nimport org.hibernate.boot.models.annotations.internal.QueryHintJpaAnnotation;\nimport org.hibernate.boot.models.annotations.internal.StoredProcedureParameterJpaAnnotation;\nimport org.hibernate.boot.query.NamedHqlQueryDefinition;\nimport org.hibernate.boot.query.NamedNativeQueryDefinition;\nimport org.hibernate.boot.query.NamedProcedureCallDefinition;\nimport org.hibernate.boot.query.SqlResultSetMappingDescriptor;\nimport org.hibernate.boot.registry.classloading.spi.ClassLoaderService;\nimport org.hibernate.boot.spi.MetadataBuildingContext;\nimport org.hibernate.internal.CoreMessageLogger;\nimport org.hibernate.internal.log.DeprecationLogger;\nimport org.hibernate.internal.util.collections.ArrayHelper;\nimport org.hibernate.jpa.HibernateHints;\nimport org.hibernate.models.internal.util.StringHelper;\nimport org.hibernate.models.spi.ClassDetails;\nimport org.hibernate.models.spi.SourceModelBuildingContext;\nimport org.hibernate.query.sql.internal.ParameterParser;\nimport org.hibernate.query.sql.spi.ParameterRecognizer;\nimport org.hibernate.type.BasicType;\n\nimport org.jboss.logging.Logger;\n\nimport jakarta.persistence.CacheRetrieveMode;\nimport jakarta.persistence.CacheStoreMode;\nimport jakarta.persistence.NamedNativeQuery;\nimport jakarta.persistence.NamedQuery;\nimport jakarta.persistence.NamedStoredProcedureQuery;\nimport jakarta.persistence.ParameterMode;\nimport jakarta.persistence.QueryHint;\nimport jakarta.persistence.SqlResultSetMapping;\nimport jakarta.persistence.StoredProcedureParameter;\n\nimport static java.lang.Boolean.TRUE;\nimport static org.hibernate.internal.util.StringHelper.nullIfEmpty;\nimport static org.hibernate.internal.util.collections.CollectionHelper.determineProperSizing;\nimport static org.hibernate.internal.util.collections.CollectionHelper.setOf;\n\n/**\n * Responsible for reading named queries defined in annotations and registering\n * {@link org.hibernate.boot.query.NamedQueryDefinition} objects.\n *\n * @implNote This class is stateless, unlike most of the other \"binders\".\n *\n * @author Emmanuel Bernard\n */\npublic abstract class QueryBinder {\n\tprivate static final CoreMessageLogger LOG = Logger.getMessageLogger( MethodHandles.lookup(), CoreMessageLogger.class, QueryBinder.class.getName() );\n\n\tpublic static void bindQuery(\n\t\t\tNamedQuery namedQuery,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\tif ( namedQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String queryName = namedQuery.name();\n\t\tfinal String queryString = namedQuery.query();\n\n\t\tif ( queryName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named query: %s => %s\", queryName, queryString );\n\t\t}\n\n\t\tfinal QueryHintDefinition hints = new QueryHintDefinition( queryName, namedQuery.hints() );\n\n\t\tfinal NamedHqlQueryDefinition<?> queryMapping = new NamedHqlQueryDefinitionImpl.Builder<>( queryName )\n\t\t\t\t.setHqlString( queryString )\n\t\t\t\t.setResultClass( (Class<Object>) namedQuery.resultClass() )\n\t\t\t\t.setCacheable( hints.getCacheability() )\n\t\t\t\t.setCacheMode( hints.getCacheMode() )\n\t\t\t\t.setCacheRegion( hints.getString( HibernateHints.HINT_CACHE_REGION ) )\n\t\t\t\t.setTimeout( hints.getTimeout() )\n\t\t\t\t.setFetchSize( hints.getInteger( HibernateHints.HINT_FETCH_SIZE ) )\n\t\t\t\t.setFlushMode( hints.getFlushMode() )\n\t\t\t\t.setReadOnly( hints.getBooleanWrapper( HibernateHints.HINT_READ_ONLY ) )\n\t\t\t\t.setLockOptions( hints.determineLockOptions( namedQuery ) )\n\t\t\t\t.setComment( hints.getString( HibernateHints.HINT_COMMENT ) )\n\t\t\t\t.build();\n\n\t\tif ( isDefault ) {\n\t\t\tcontext.getMetadataCollector().addDefaultQuery( queryMapping );\n\t\t}\n\t\telse {\n\t\t\tcontext.getMetadataCollector().addNamedQuery( queryMapping );\n\t\t}\n\t}\n\n\tprivate static Class<Object> loadClass(ClassDetails classDetails, MetadataBuildingContext context) {\n\t\treturn ClassDetails.VOID_CLASS_DETAILS == classDetails\n\t\t\t\t? null\n\t\t\t\t: context.getBootstrapContext()\n\t\t\t\t\t\t.getServiceRegistry()\n\t\t\t\t\t\t.requireService( ClassLoaderService.class )\n\t\t\t\t\t\t.classForName( classDetails.getName() );\n\t}\n\n\tpublic static void bindNativeQuery(\n\t\t\tNamedNativeQuery namedNativeQuery,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\tif ( namedNativeQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String registrationName = namedNativeQuery.name();\n\t\tfinal String queryString = namedNativeQuery.query();\n\n\t\tif ( registrationName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedNativeQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tfinal QueryHintDefinition hints = new QueryHintDefinition( registrationName, namedNativeQuery.hints() );\n\n\t\tfinal String resultSetMappingName = namedNativeQuery.resultSetMapping();\n\t\tfinal Class<?> resultClassDetails = namedNativeQuery.resultClass();\n\t\tfinal Class<Object> resultClass = void.class == resultClassDetails\n\t\t\t\t? null\n\t\t\t\t: (Class<Object>) resultClassDetails;\n\n\t\tfinal NamedNativeQueryDefinition.Builder<?> builder = new NamedNativeQueryDefinition.Builder<>( registrationName )\n\t\t\t\t.setSqlString( queryString )\n\t\t\t\t.setResultClass( resultClass )\n\t\t\t\t.setResultSetMappingName( resultSetMappingName )\n\t\t\t\t.setQuerySpaces( null )\n\t\t\t\t.setCacheable( hints.getCacheability() )\n\t\t\t\t.setCacheMode( hints.getCacheMode() )\n\t\t\t\t.setCacheRegion( hints.getString( HibernateHints.HINT_CACHE_REGION ) )\n\t\t\t\t.setTimeout( hints.getTimeout() )\n\t\t\t\t.setFetchSize( hints.getInteger( HibernateHints.HINT_FETCH_SIZE ) )\n\t\t\t\t.setFlushMode( hints.getFlushMode() )\n\t\t\t\t.setReadOnly( hints.getBooleanWrapper( HibernateHints.HINT_READ_ONLY ) )\n\t\t\t\t.setComment( hints.getString( HibernateHints.HINT_COMMENT ) )\n\t\t\t\t.addHints( hints.getHintsMap() );\n\n\t\tfinal NamedNativeQueryDefinition<?> queryDefinition = builder.build();\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named native query: %s => %s\", queryDefinition.getRegistrationName(), queryDefinition.getSqlQueryString() );\n\t\t}\n\n\t\tif ( isDefault ) {\n\t\t\tcontext.getMetadataCollector().addDefaultNamedNativeQuery( queryDefinition );\n\t\t}\n\t\telse {\n\t\t\tcontext.getMetadataCollector().addNamedNativeQuery( queryDefinition );\n\t\t}\n\t}\n\n\tpublic static void bindNativeQuery(\n\t\t\tString name,\n\t\t\tSQLSelect sqlSelect,\n\t\t\tClassDetails annotatedClass,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal NamedNativeQueryDefinition.Builder<?> builder = new NamedNativeQueryDefinition.Builder<>( name )\n\t\t\t\t.setFlushMode( FlushMode.MANUAL )\n\t\t\t\t.setSqlString( sqlSelect.sql() )\n\t\t\t\t.setQuerySpaces( setOf( sqlSelect.querySpaces() ) );\n\n\t\tif ( annotatedClass != null ) {\n\t\t\tbuilder.setResultClass(\n\t\t\t\t\tcontext.getBootstrapContext().getServiceRegistry().requireService( ClassLoaderService.class )\n\t\t\t\t\t\t\t.classForName( annotatedClass.getClassName() )\n\t\t\t);\n\t\t}\n\n\t\tfinal SqlResultSetMapping resultSetMapping = sqlSelect.resultSetMapping();\n\t\tif ( !ArrayHelper.isEmpty( resultSetMapping.columns() )\n\t\t\t\t|| !ArrayHelper.isEmpty( resultSetMapping.entities() )\n\t\t\t\t|| !ArrayHelper.isEmpty( resultSetMapping.classes() ) ) {\n\t\t\tcontext.getMetadataCollector().addResultSetMapping( SqlResultSetMappingDescriptor.from( resultSetMapping, name ) );\n\t\t\tbuilder.setResultSetMappingName( name );\n\t\t}\n\n\t\tcontext.getMetadataCollector().addNamedNativeQuery( builder.build() );\n\t}\n\n\tpublic static void bindNativeQuery(\n\t\t\torg.hibernate.annotations.NamedNativeQuery namedNativeQuery,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( namedNativeQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String registrationName = namedNativeQuery.name();\n\n\t\t//ResultSetMappingDefinition mappingDefinition = mappings.getJdbcValuesMappingProducer( queryAnn.resultSetMapping() );\n\t\tif ( registrationName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedNativeQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tfinal String resultSetMappingName = namedNativeQuery.resultSetMapping();\n\t\tfinal Class<?> resultClassDetails = namedNativeQuery.resultClass();\n\t\tfinal Class<Object> resultClass = resultClassDetails == void.class\n\t\t\t\t? null\n\t\t\t\t: (Class<Object>) resultClassDetails;\n\n\t\tfinal Integer timeout = namedNativeQuery.timeout();\n\t\tfinal Integer fetchSize = namedNativeQuery.fetchSize();\n\n\t\tfinal String[] querySpacesList = namedNativeQuery.querySpaces();\n\t\tfinal HashSet<String> querySpaces = new HashSet<>( determineProperSizing( querySpacesList.length ) );\n\t\tCollections.addAll( querySpaces, querySpacesList );\n\n\t\tfinal NamedNativeQueryDefinition.Builder<?> builder = new NamedNativeQueryDefinition.Builder<>( registrationName )\n\t\t\t\t.setSqlString( namedNativeQuery.query() )\n\t\t\t\t.setResultSetMappingName( resultSetMappingName )\n\t\t\t\t.setResultClass( resultClass )\n\t\t\t\t.setCacheable( namedNativeQuery.cacheable() )\n\t\t\t\t.setCacheRegion( nullIfEmpty( namedNativeQuery.cacheRegion() ) )\n\t\t\t\t.setCacheMode( getCacheMode( namedNativeQuery.cacheRetrieveMode(), namedNativeQuery.cacheStoreMode() ) )\n\t\t\t\t.setTimeout( timeout < 0 ? null : timeout )\n\t\t\t\t.setFetchSize( fetchSize < 0 ? null : fetchSize )\n\t\t\t\t.setFlushMode( getFlushMode( namedNativeQuery.flushMode() ) )\n\t\t\t\t.setReadOnly( namedNativeQuery.readOnly() )\n\t\t\t\t.setQuerySpaces( querySpaces )\n\t\t\t\t.setComment( nullIfEmpty( namedNativeQuery.comment() ) );\n\n\t\tif ( TRUE == namedNativeQuery.callable() ) {\n\t\t\tfinal NamedProcedureCallDefinition definition =\n\t\t\t\t\tcreateStoredProcedure( builder, context, () -> illegalCallSyntax( namedNativeQuery ) );\n\t\t\tcontext.getMetadataCollector().addNamedProcedureCallDefinition( definition );\n\t\t\tDeprecationLogger.DEPRECATION_LOGGER.warn(\n\t\t\t\t\t\"Marking named native queries as callable is no longer supported; use '@jakarta.persistence.NamedStoredProcedureQuery' instead. Ignoring.\"\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tfinal NamedNativeQueryDefinition<?> queryDefinition = builder.build();\n\n\t\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\t\tLOG.debugf(\n\t\t\t\t\t\t\"Binding named native query: %s => %s\",\n\t\t\t\t\t\tqueryDefinition.getRegistrationName(),\n\t\t\t\t\t\tqueryDefinition.getSqlQueryString()\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tcontext.getMetadataCollector().addNamedNativeQuery( queryDefinition );\n\t\t}\n\t}\n\n\t/**\n\t * Handles legacy cases where a named native query was used to specify a procedure call\n\t *\n\t * @deprecated User should use {@linkplain NamedStoredProcedureQuery} instead\n\t */\n\t@Deprecated\n\tpublic static NamedProcedureCallDefinition createStoredProcedure(\n\t\t\tNamedNativeQueryDefinition.Builder<?> builder,\n\t\t\tMetadataBuildingContext context,\n\t\t\tSupplier<RuntimeException> exceptionProducer) {\n\t\tfinal String sqlString = builder.getSqlString().trim();\n\t\tif ( !sqlString.startsWith( \"{\" ) || !sqlString.endsWith( \"}\" ) ) {\n\t\t\tthrow exceptionProducer.get();\n\t\t}\n\t\tfinal JdbcCall jdbcCall = parseJdbcCall( sqlString, exceptionProducer );\n\n\t\tfinal SourceModelBuildingContext sourceModelBuildingContext = context.getMetadataCollector()\n\t\t\t\t.getSourceModelBuildingContext();\n\t\tfinal NamedStoredProcedureQueryJpaAnnotation nameStoredProcedureQueryAnn = JpaAnnotations.NAMED_STORED_PROCEDURE_QUERY.createUsage( sourceModelBuildingContext );\n\t\tnameStoredProcedureQueryAnn.name( builder.getName() );\n\t\tnameStoredProcedureQueryAnn.procedureName( jdbcCall.callableName );\n\n\t\tfinal StoredProcedureParameter[] parameters = new StoredProcedureParameter[jdbcCall.parameters.size()];\n\t\tnameStoredProcedureQueryAnn.parameters( parameters );\n\n\t\tfor ( int i = 0; i < jdbcCall.parameters.size(); i++ ) {\n\t\t\tfinal StoredProcedureParameterJpaAnnotation param = JpaAnnotations.STORED_PROCEDURE_PARAMETER.createUsage( sourceModelBuildingContext );\n\t\t\tparameters[i] = param;\n\n\t\t\tfinal String paramName = jdbcCall.parameters.get( i );\n\t\t\tparam.name( paramName );\n\t\t\tparam.mode( ParameterMode.IN );\n\n\t\t\tfinal String typeName = builder.getParameterTypes().get( paramName );\n\t\t\tfinal ClassDetails classDetails;\n\t\t\tif ( StringHelper.isEmpty( typeName ) ) {\n\t\t\t\tclassDetails = ClassDetails.VOID_CLASS_DETAILS;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfinal BasicType<Object> registeredType = context.getBootstrapContext()\n\t\t\t\t\t\t.getTypeConfiguration()\n\t\t\t\t\t\t.getBasicTypeRegistry()\n\t\t\t\t\t\t.getRegisteredType( typeName );\n\t\t\t\tclassDetails = context.getMetadataCollector().getClassDetailsRegistry().getClassDetails( registeredType.getJavaType().getName() );\n\t\t\t}\n\t\t\tparam.type( classDetails.toJavaClass() );\n\t\t}\n\n\t\tif ( builder.getResultSetMappingName() != null ) {\n\t\t\tnameStoredProcedureQueryAnn.resultSetMappings( new String[] { builder.getResultSetMappingName() } );\n\t\t}\n\n\t\tfinal Class<?> resultClass = builder.getResultClass();\n\t\tif ( resultClass != null ) {\n\t\t\tnameStoredProcedureQueryAnn.resultClasses( new Class[]{ builder.getResultClass() } );\n\t\t}\n\n\t\tfinal List<QueryHintJpaAnnotation> hints = new ArrayList<>();\n\n\t\tif ( builder.getQuerySpaces() != null ) {\n\t\t\tfinal QueryHintJpaAnnotation hint = JpaAnnotations.QUERY_HINT.createUsage( sourceModelBuildingContext );\n\t\t\thint.name( HibernateHints.HINT_NATIVE_SPACES );\n\t\t\thint.value( String.join( \" \", builder.getQuerySpaces() ) );\n\t\t\thints.add( hint );\n\t\t}\n\n\t\tif ( jdbcCall.resultParameter ) {\n\t\t\t// Mark native queries that have a result parameter as callable functions\n\t\t\tfinal QueryHintJpaAnnotation hint = JpaAnnotations.QUERY_HINT.createUsage( sourceModelBuildingContext );\n\t\t\thint.name( HibernateHints.HINT_CALLABLE_FUNCTION );\n\t\t\thint.value( \"true\" );\n\t\t\thints.add( hint );\n\t\t}\n\n\t\tnameStoredProcedureQueryAnn.hints( hints.toArray(QueryHint[]::new) );\n\n\t\treturn new NamedProcedureCallDefinitionImpl( nameStoredProcedureQueryAnn );\n\t}\n\n\tpublic static void bindQuery(\n\t\t\tString name,\n\t\t\tHQLSelect hqlSelect,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal NamedHqlQueryDefinition<?> hqlQueryDefinition = new NamedHqlQueryDefinition.Builder<>( name )\n\t\t\t\t.setFlushMode( FlushMode.MANUAL )\n\t\t\t\t.setHqlString( hqlSelect.query() )\n\t\t\t\t.build();\n\n\t\tcontext.getMetadataCollector().addNamedQuery( hqlQueryDefinition );\n\t}\n\n\tpublic static void bindQuery(\n\t\t\torg.hibernate.annotations.NamedQuery namedQuery,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( namedQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String registrationName = namedQuery.name();\n\n\t\t//ResultSetMappingDefinition mappingDefinition = mappings.getJdbcValuesMappingProducer( namedQuery.resultSetMapping() );\n\t\tif ( registrationName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tfinal int timeout = namedQuery.timeout();\n\t\tfinal int fetchSize = namedQuery.fetchSize();\n\n\t\tfinal NamedHqlQueryDefinition.Builder<?> builder = new NamedHqlQueryDefinition.Builder<>( registrationName )\n\t\t\t\t.setHqlString( namedQuery.query() )\n\t\t\t\t.setResultClass( (Class<Object>) namedQuery.resultClass() )\n\t\t\t\t.setCacheable( namedQuery.cacheable() )\n\t\t\t\t.setCacheRegion( nullIfEmpty( namedQuery.cacheRegion() ) )\n\t\t\t\t.setCacheMode( getCacheMode( namedQuery.cacheRetrieveMode(), namedQuery.cacheStoreMode() ) )\n\t\t\t\t.setTimeout( timeout < 0 ? null : timeout )\n\t\t\t\t.setFetchSize( fetchSize < 0 ? null : fetchSize )\n\t\t\t\t.setFlushMode( getFlushMode( namedQuery.flushMode() ) )\n\t\t\t\t.setReadOnly( namedQuery.readOnly() )\n\t\t\t\t.setComment( nullIfEmpty( namedQuery.comment() ) );\n\n\t\tfinal NamedHqlQueryDefinitionImpl<?> hqlQueryDefinition = builder.build();\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named query: %s => %s\", hqlQueryDefinition.getRegistrationName(), hqlQueryDefinition.getHqlString() );\n\t\t}\n\n\t\tcontext.getMetadataCollector().addNamedQuery( hqlQueryDefinition );\n\t}\n\n\tprivate static CacheMode getCacheMode(CacheRetrieveMode cacheRetrieveMode, CacheStoreMode cacheStoreMode) {\n\t\tfinal CacheMode cacheMode = CacheMode.fromJpaModes( cacheRetrieveMode, cacheStoreMode );\n\t\treturn cacheMode == null ? CacheMode.NORMAL : cacheMode;\n\t}\n\n\tprivate static FlushMode getFlushMode(FlushModeType flushModeType) {\n\t\treturn switch ( flushModeType ) {\n\t\t\tcase ALWAYS -> FlushMode.ALWAYS;\n\t\t\tcase AUTO -> FlushMode.AUTO;\n\t\t\tcase COMMIT -> FlushMode.COMMIT;\n\t\t\tcase MANUAL -> FlushMode.MANUAL;\n\t\t\tcase PERSISTENCE_CONTEXT -> null;\n\t\t};\n\t}\n\n\tpublic static void bindNamedStoredProcedureQuery(\n\t\t\tNamedStoredProcedureQuery namedStoredProcedureQuery,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\tif ( namedStoredProcedureQuery != null ) {\n\t\t\tif ( namedStoredProcedureQuery.name().isEmpty() ) {\n\t\t\t\tthrow new AnnotationException( \"Class or package level '@NamedStoredProcedureQuery' annotation must specify a 'name'\" );\n\t\t\t}\n\n\t\t\tfinal NamedProcedureCallDefinitionImpl definition = new NamedProcedureCallDefinitionImpl( namedStoredProcedureQuery );\n\t\t\tif ( isDefault ) {\n\t\t\t\tcontext.getMetadataCollector().addDefaultNamedProcedureCall( definition );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcontext.getMetadataCollector().addNamedProcedureCallDefinition( definition );\n\t\t\t}\n\t\t\tLOG.debugf( \"Bound named stored procedure query : %s => %s\", definition.getRegistrationName(), definition.getProcedureName() );\n\t\t}\n\t}\n\n\tpublic static void bindSqlResultSetMapping(\n\t\t\tSqlResultSetMapping resultSetMappingAnn,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\t//no need to handle inSecondPass\n\t\tcontext.getMetadataCollector().addSecondPass( new ResultSetMappingSecondPass( resultSetMappingAnn, context, isDefault ) );\n\t}\n\n\tprivate static class JdbcCall {\n\t\tprivate final String callableName;\n\t\tprivate final boolean resultParameter;\n\t\tprivate final ArrayList<String> parameters;\n\n\t\tpublic JdbcCall(String callableName, boolean resultParameter, ArrayList<String> parameters) {\n\t\t\tthis.callableName = callableName;\n\t\t\tthis.resultParameter = resultParameter;\n\t\t\tthis.parameters = parameters;\n\t\t}\n\t}\n\n\tprivate static JdbcCall parseJdbcCall(String sqlString, Supplier<RuntimeException> exceptionProducer) {\n\t\tString callableName = null;\n\t\tboolean resultParameter = false;\n\t\tint index = skipWhitespace( sqlString, 1 );\n\t\t// Parse the out param `?=` part\n\t\tif ( sqlString.charAt( index ) == '?' ) {\n\t\t\tresultParameter = true;\n\t\t\tindex++;\n\t\t\tindex = skipWhitespace( sqlString, index );\n\t\t\tif ( sqlString.charAt( index ) != '=' ) {\n\t\t\t\tthrow exceptionProducer.get();\n\t\t\t}\n\t\t\tindex++;\n\t\t\tindex = skipWhitespace( sqlString, index );\n\t\t}\n\t\t// Parse the call keyword\n\t\tif ( !sqlString.regionMatches( true, index, \"call\", 0, 4 ) ) {\n\t\t\tthrow exceptionProducer.get();\n\t\t}\n\t\tindex += 4;\n\t\tindex = skipWhitespace( sqlString, index );\n\n\t\t// Parse the procedure name\n\t\tfinal int procedureStart = index;\n\t\tfor ( ; index < sqlString.length(); index++ ) {\n\t\t\tfinal char c = sqlString.charAt( index );\n\t\t\tif ( c == '(' || Character.isWhitespace( c ) ) {\n\t\t\t\tcallableName = sqlString.substring( procedureStart, index );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tindex = skipWhitespace( sqlString, index );\n\t\tfinal ArrayList<String> parameters = new ArrayList<>();\n\t\tParameterParser.parse(\n\t\t\t\tsqlString.substring( index, sqlString.length() - 1 ),\n\t\t\t\tnew ParameterRecognizer() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void ordinalParameter(int sourcePosition) {\n\t\t\t\t\t\tparameters.add( \"\" );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void namedParameter(String name, int sourcePosition) {\n\t\t\t\t\t\tparameters.add( name );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void jpaPositionalParameter(int label, int sourcePosition) {\n\t\t\t\t\t\tparameters.add( \"\" );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void other(char character) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\treturn new JdbcCall( callableName, resultParameter, parameters );\n\t}\n\n\tprivate static int skipWhitespace(String sqlString, int i) {\n\t\twhile ( i < sqlString.length() ) {\n\t\t\tif ( !Character.isWhitespace( sqlString.charAt( i ) ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn i;\n\t}\n\n\tprivate static AnnotationException illegalCallSyntax(org.hibernate.annotations.NamedNativeQuery queryAnn) {\n\t\treturn new AnnotationException( \"Callable 'NamedNativeQuery' named '\" + queryAnn.name()\n\t\t\t\t+ \"' does not use the JDBC call syntax\" );\n\t}\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate createNamedQueryDefinition(queryName String, queryString String, resultClass Class<T>, lockOptions LockOptions, hints QueryHintDefinition) : NamedHqlQueryDefinitionImpl<T> extracted from public bindQuery(namedQuery NamedQuery, context MetadataBuildingContext, isDefault boolean) : void in class org.hibernate.boot.model.internal.QueryBinder",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/boot/model/internal/QueryBinder.java",
                "startLine": 73,
                "endLine": 114,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/boot/model/internal/QueryBinder.java",
                "startLine": 74,
                "endLine": 104,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/boot/model/internal/QueryBinder.java",
                "startLine": 106,
                "endLine": 122,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public static void bindQuery(\n\t\t\tNamedQuery namedQuery,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\tif ( namedQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String queryName = namedQuery.name();\n\t\tfinal String queryString = namedQuery.query();\n\n\t\tif ( queryName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named query: %s => %s\", queryName, queryString );\n\t\t}\n\n\t\tfinal QueryHintDefinition hints = new QueryHintDefinition( queryName, namedQuery.hints() );\n\n\t\tfinal NamedHqlQueryDefinition<?> queryMapping = new NamedHqlQueryDefinitionImpl.Builder<>( queryName )\n\t\t\t\t.setHqlString( queryString )\n\t\t\t\t.setResultClass( (Class<Object>) namedQuery.resultClass() )\n\t\t\t\t.setCacheable( hints.getCacheability() )\n\t\t\t\t.setCacheMode( hints.getCacheMode() )\n\t\t\t\t.setCacheRegion( hints.getString( HibernateHints.HINT_CACHE_REGION ) )\n\t\t\t\t.setTimeout( hints.getTimeout() )\n\t\t\t\t.setFetchSize( hints.getInteger( HibernateHints.HINT_FETCH_SIZE ) )\n\t\t\t\t.setFlushMode( hints.getFlushMode() )\n\t\t\t\t.setReadOnly( hints.getBooleanWrapper( HibernateHints.HINT_READ_ONLY ) )\n\t\t\t\t.setLockOptions( hints.determineLockOptions( namedQuery ) )\n\t\t\t\t.setComment( hints.getString( HibernateHints.HINT_COMMENT ) )\n\t\t\t\t.build();\n\n\t\tif ( isDefault ) {\n\t\t\tcontext.getMetadataCollector().addDefaultQuery( queryMapping );\n\t\t}\n\t\telse {\n\t\t\tcontext.getMetadataCollector().addNamedQuery( queryMapping );\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/boot/model/internal/QueryBinder.java",
        "isPureRefactoring": true,
        "commitId": "b53728f7278c40ef41e22326f917ca5c718ce6e7",
        "packageNameBefore": "org.hibernate.boot.model.internal",
        "classNameBefore": "org.hibernate.boot.model.internal.QueryBinder",
        "methodNameBefore": "org.hibernate.boot.model.internal.QueryBinder#bindQuery",
        "invokedMethod": "methodSignature: org.hibernate.boot.model.internal.QueryBinder#getCacheMode\n methodBody: private static CacheMode getCacheMode(CacheRetrieveMode cacheRetrieveMode, CacheStoreMode cacheStoreMode) {\nfinal CacheMode cacheMode=CacheMode.fromJpaModes(cacheRetrieveMode,cacheStoreMode);\nreturn cacheMode == null ? CacheMode.NORMAL : cacheMode;\n}\nmethodSignature: org.hibernate.boot.model.internal.QueryBinder#getFlushMode\n methodBody: private static FlushMode getFlushMode(FlushModeType flushModeType) {\nreturn switch (flushModeType) {\ncase ALWAYS ->  yield FlushMode.ALWAYS;\ncase AUTO ->yield FlushMode.AUTO;\ncase COMMIT ->yield FlushMode.COMMIT;\ncase MANUAL ->yield FlushMode.MANUAL;\ncase PERSISTENCE_CONTEXT ->yield null;\n}\n;\n}",
        "classSignatureBefore": "public abstract class QueryBinder ",
        "methodNameBeforeSet": [
            "org.hibernate.boot.model.internal.QueryBinder#bindQuery"
        ],
        "classNameBeforeSet": [
            "org.hibernate.boot.model.internal.QueryBinder"
        ],
        "classSignatureBeforeSet": [
            "public abstract class QueryBinder "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html.\n */\npackage org.hibernate.boot.model.internal;\n\nimport java.lang.invoke.MethodHandles;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.function.Supplier;\n\nimport org.hibernate.AnnotationException;\nimport org.hibernate.CacheMode;\nimport org.hibernate.FlushMode;\nimport org.hibernate.annotations.FlushModeType;\nimport org.hibernate.annotations.HQLSelect;\nimport org.hibernate.annotations.SQLSelect;\nimport org.hibernate.boot.internal.NamedHqlQueryDefinitionImpl;\nimport org.hibernate.boot.internal.NamedProcedureCallDefinitionImpl;\nimport org.hibernate.boot.models.JpaAnnotations;\nimport org.hibernate.boot.models.annotations.internal.NamedStoredProcedureQueryJpaAnnotation;\nimport org.hibernate.boot.models.annotations.internal.QueryHintJpaAnnotation;\nimport org.hibernate.boot.models.annotations.internal.StoredProcedureParameterJpaAnnotation;\nimport org.hibernate.boot.query.NamedHqlQueryDefinition;\nimport org.hibernate.boot.query.NamedNativeQueryDefinition;\nimport org.hibernate.boot.query.NamedProcedureCallDefinition;\nimport org.hibernate.boot.query.SqlResultSetMappingDescriptor;\nimport org.hibernate.boot.registry.classloading.spi.ClassLoaderService;\nimport org.hibernate.boot.spi.MetadataBuildingContext;\nimport org.hibernate.internal.CoreMessageLogger;\nimport org.hibernate.internal.log.DeprecationLogger;\nimport org.hibernate.internal.util.collections.ArrayHelper;\nimport org.hibernate.jpa.HibernateHints;\nimport org.hibernate.models.internal.util.StringHelper;\nimport org.hibernate.models.spi.ClassDetails;\nimport org.hibernate.models.spi.SourceModelBuildingContext;\nimport org.hibernate.query.sql.internal.ParameterParser;\nimport org.hibernate.query.sql.spi.ParameterRecognizer;\nimport org.hibernate.type.BasicType;\n\nimport org.jboss.logging.Logger;\n\nimport jakarta.persistence.CacheRetrieveMode;\nimport jakarta.persistence.CacheStoreMode;\nimport jakarta.persistence.NamedNativeQuery;\nimport jakarta.persistence.NamedQuery;\nimport jakarta.persistence.NamedStoredProcedureQuery;\nimport jakarta.persistence.ParameterMode;\nimport jakarta.persistence.QueryHint;\nimport jakarta.persistence.SqlResultSetMapping;\nimport jakarta.persistence.StoredProcedureParameter;\n\nimport static java.lang.Boolean.TRUE;\nimport static org.hibernate.internal.util.StringHelper.nullIfEmpty;\nimport static org.hibernate.internal.util.collections.CollectionHelper.determineProperSizing;\nimport static org.hibernate.internal.util.collections.CollectionHelper.setOf;\n\n/**\n * Responsible for reading named queries defined in annotations and registering\n * {@link org.hibernate.boot.query.NamedQueryDefinition} objects.\n *\n * @implNote This class is stateless, unlike most of the other \"binders\".\n *\n * @author Emmanuel Bernard\n */\npublic abstract class QueryBinder {\n\tprivate static final CoreMessageLogger LOG = Logger.getMessageLogger( MethodHandles.lookup(), CoreMessageLogger.class, QueryBinder.class.getName() );\n\n\tpublic static void bindQuery(\n\t\t\tNamedQuery namedQuery,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\tif ( namedQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String queryName = namedQuery.name();\n\t\tfinal String queryString = namedQuery.query();\n\n\t\tif ( queryName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named query: %s => %s\", queryName, queryString );\n\t\t}\n\n\t\tfinal QueryHintDefinition hints = new QueryHintDefinition( queryName, namedQuery.hints() );\n\n\t\tfinal NamedHqlQueryDefinition<?> queryMapping = new NamedHqlQueryDefinitionImpl.Builder<>( queryName )\n\t\t\t\t.setHqlString( queryString )\n\t\t\t\t.setResultClass( (Class<Object>) namedQuery.resultClass() )\n\t\t\t\t.setCacheable( hints.getCacheability() )\n\t\t\t\t.setCacheMode( hints.getCacheMode() )\n\t\t\t\t.setCacheRegion( hints.getString( HibernateHints.HINT_CACHE_REGION ) )\n\t\t\t\t.setTimeout( hints.getTimeout() )\n\t\t\t\t.setFetchSize( hints.getInteger( HibernateHints.HINT_FETCH_SIZE ) )\n\t\t\t\t.setFlushMode( hints.getFlushMode() )\n\t\t\t\t.setReadOnly( hints.getBooleanWrapper( HibernateHints.HINT_READ_ONLY ) )\n\t\t\t\t.setLockOptions( hints.determineLockOptions( namedQuery ) )\n\t\t\t\t.setComment( hints.getString( HibernateHints.HINT_COMMENT ) )\n\t\t\t\t.build();\n\n\t\tif ( isDefault ) {\n\t\t\tcontext.getMetadataCollector().addDefaultQuery( queryMapping );\n\t\t}\n\t\telse {\n\t\t\tcontext.getMetadataCollector().addNamedQuery( queryMapping );\n\t\t}\n\t}\n\n\tprivate static Class<Object> loadClass(ClassDetails classDetails, MetadataBuildingContext context) {\n\t\treturn ClassDetails.VOID_CLASS_DETAILS == classDetails\n\t\t\t\t? null\n\t\t\t\t: context.getBootstrapContext()\n\t\t\t\t\t\t.getServiceRegistry()\n\t\t\t\t\t\t.requireService( ClassLoaderService.class )\n\t\t\t\t\t\t.classForName( classDetails.getName() );\n\t}\n\n\tpublic static void bindNativeQuery(\n\t\t\tNamedNativeQuery namedNativeQuery,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\tif ( namedNativeQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String registrationName = namedNativeQuery.name();\n\t\tfinal String queryString = namedNativeQuery.query();\n\n\t\tif ( registrationName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedNativeQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tfinal QueryHintDefinition hints = new QueryHintDefinition( registrationName, namedNativeQuery.hints() );\n\n\t\tfinal String resultSetMappingName = namedNativeQuery.resultSetMapping();\n\t\tfinal Class<?> resultClassDetails = namedNativeQuery.resultClass();\n\t\tfinal Class<Object> resultClass = void.class == resultClassDetails\n\t\t\t\t? null\n\t\t\t\t: (Class<Object>) resultClassDetails;\n\n\t\tfinal NamedNativeQueryDefinition.Builder<?> builder = new NamedNativeQueryDefinition.Builder<>( registrationName )\n\t\t\t\t.setSqlString( queryString )\n\t\t\t\t.setResultClass( resultClass )\n\t\t\t\t.setResultSetMappingName( resultSetMappingName )\n\t\t\t\t.setQuerySpaces( null )\n\t\t\t\t.setCacheable( hints.getCacheability() )\n\t\t\t\t.setCacheMode( hints.getCacheMode() )\n\t\t\t\t.setCacheRegion( hints.getString( HibernateHints.HINT_CACHE_REGION ) )\n\t\t\t\t.setTimeout( hints.getTimeout() )\n\t\t\t\t.setFetchSize( hints.getInteger( HibernateHints.HINT_FETCH_SIZE ) )\n\t\t\t\t.setFlushMode( hints.getFlushMode() )\n\t\t\t\t.setReadOnly( hints.getBooleanWrapper( HibernateHints.HINT_READ_ONLY ) )\n\t\t\t\t.setComment( hints.getString( HibernateHints.HINT_COMMENT ) )\n\t\t\t\t.addHints( hints.getHintsMap() );\n\n\t\tfinal NamedNativeQueryDefinition<?> queryDefinition = builder.build();\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named native query: %s => %s\", queryDefinition.getRegistrationName(), queryDefinition.getSqlQueryString() );\n\t\t}\n\n\t\tif ( isDefault ) {\n\t\t\tcontext.getMetadataCollector().addDefaultNamedNativeQuery( queryDefinition );\n\t\t}\n\t\telse {\n\t\t\tcontext.getMetadataCollector().addNamedNativeQuery( queryDefinition );\n\t\t}\n\t}\n\n\tpublic static void bindNativeQuery(\n\t\t\tString name,\n\t\t\tSQLSelect sqlSelect,\n\t\t\tClassDetails annotatedClass,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal NamedNativeQueryDefinition.Builder<?> builder = new NamedNativeQueryDefinition.Builder<>( name )\n\t\t\t\t.setFlushMode( FlushMode.MANUAL )\n\t\t\t\t.setSqlString( sqlSelect.sql() )\n\t\t\t\t.setQuerySpaces( setOf( sqlSelect.querySpaces() ) );\n\n\t\tif ( annotatedClass != null ) {\n\t\t\tbuilder.setResultClass(\n\t\t\t\t\tcontext.getBootstrapContext().getServiceRegistry().requireService( ClassLoaderService.class )\n\t\t\t\t\t\t\t.classForName( annotatedClass.getClassName() )\n\t\t\t);\n\t\t}\n\n\t\tfinal SqlResultSetMapping resultSetMapping = sqlSelect.resultSetMapping();\n\t\tif ( !ArrayHelper.isEmpty( resultSetMapping.columns() )\n\t\t\t\t|| !ArrayHelper.isEmpty( resultSetMapping.entities() )\n\t\t\t\t|| !ArrayHelper.isEmpty( resultSetMapping.classes() ) ) {\n\t\t\tcontext.getMetadataCollector().addResultSetMapping( SqlResultSetMappingDescriptor.from( resultSetMapping, name ) );\n\t\t\tbuilder.setResultSetMappingName( name );\n\t\t}\n\n\t\tcontext.getMetadataCollector().addNamedNativeQuery( builder.build() );\n\t}\n\n\tpublic static void bindNativeQuery(\n\t\t\torg.hibernate.annotations.NamedNativeQuery namedNativeQuery,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( namedNativeQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String registrationName = namedNativeQuery.name();\n\n\t\t//ResultSetMappingDefinition mappingDefinition = mappings.getJdbcValuesMappingProducer( queryAnn.resultSetMapping() );\n\t\tif ( registrationName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedNativeQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tfinal String resultSetMappingName = namedNativeQuery.resultSetMapping();\n\t\tfinal Class<?> resultClassDetails = namedNativeQuery.resultClass();\n\t\tfinal Class<Object> resultClass = resultClassDetails == void.class\n\t\t\t\t? null\n\t\t\t\t: (Class<Object>) resultClassDetails;\n\n\t\tfinal Integer timeout = namedNativeQuery.timeout();\n\t\tfinal Integer fetchSize = namedNativeQuery.fetchSize();\n\n\t\tfinal String[] querySpacesList = namedNativeQuery.querySpaces();\n\t\tfinal HashSet<String> querySpaces = new HashSet<>( determineProperSizing( querySpacesList.length ) );\n\t\tCollections.addAll( querySpaces, querySpacesList );\n\n\t\tfinal NamedNativeQueryDefinition.Builder<?> builder = new NamedNativeQueryDefinition.Builder<>( registrationName )\n\t\t\t\t.setSqlString( namedNativeQuery.query() )\n\t\t\t\t.setResultSetMappingName( resultSetMappingName )\n\t\t\t\t.setResultClass( resultClass )\n\t\t\t\t.setCacheable( namedNativeQuery.cacheable() )\n\t\t\t\t.setCacheRegion( nullIfEmpty( namedNativeQuery.cacheRegion() ) )\n\t\t\t\t.setCacheMode( getCacheMode( namedNativeQuery.cacheRetrieveMode(), namedNativeQuery.cacheStoreMode() ) )\n\t\t\t\t.setTimeout( timeout < 0 ? null : timeout )\n\t\t\t\t.setFetchSize( fetchSize < 0 ? null : fetchSize )\n\t\t\t\t.setFlushMode( getFlushMode( namedNativeQuery.flushMode() ) )\n\t\t\t\t.setReadOnly( namedNativeQuery.readOnly() )\n\t\t\t\t.setQuerySpaces( querySpaces )\n\t\t\t\t.setComment( nullIfEmpty( namedNativeQuery.comment() ) );\n\n\t\tif ( TRUE == namedNativeQuery.callable() ) {\n\t\t\tfinal NamedProcedureCallDefinition definition =\n\t\t\t\t\tcreateStoredProcedure( builder, context, () -> illegalCallSyntax( namedNativeQuery ) );\n\t\t\tcontext.getMetadataCollector().addNamedProcedureCallDefinition( definition );\n\t\t\tDeprecationLogger.DEPRECATION_LOGGER.warn(\n\t\t\t\t\t\"Marking named native queries as callable is no longer supported; use '@jakarta.persistence.NamedStoredProcedureQuery' instead. Ignoring.\"\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tfinal NamedNativeQueryDefinition<?> queryDefinition = builder.build();\n\n\t\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\t\tLOG.debugf(\n\t\t\t\t\t\t\"Binding named native query: %s => %s\",\n\t\t\t\t\t\tqueryDefinition.getRegistrationName(),\n\t\t\t\t\t\tqueryDefinition.getSqlQueryString()\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tcontext.getMetadataCollector().addNamedNativeQuery( queryDefinition );\n\t\t}\n\t}\n\n\t/**\n\t * Handles legacy cases where a named native query was used to specify a procedure call\n\t *\n\t * @deprecated User should use {@linkplain NamedStoredProcedureQuery} instead\n\t */\n\t@Deprecated\n\tpublic static NamedProcedureCallDefinition createStoredProcedure(\n\t\t\tNamedNativeQueryDefinition.Builder<?> builder,\n\t\t\tMetadataBuildingContext context,\n\t\t\tSupplier<RuntimeException> exceptionProducer) {\n\t\tfinal String sqlString = builder.getSqlString().trim();\n\t\tif ( !sqlString.startsWith( \"{\" ) || !sqlString.endsWith( \"}\" ) ) {\n\t\t\tthrow exceptionProducer.get();\n\t\t}\n\t\tfinal JdbcCall jdbcCall = parseJdbcCall( sqlString, exceptionProducer );\n\n\t\tfinal SourceModelBuildingContext sourceModelBuildingContext = context.getMetadataCollector()\n\t\t\t\t.getSourceModelBuildingContext();\n\t\tfinal NamedStoredProcedureQueryJpaAnnotation nameStoredProcedureQueryAnn = JpaAnnotations.NAMED_STORED_PROCEDURE_QUERY.createUsage( sourceModelBuildingContext );\n\t\tnameStoredProcedureQueryAnn.name( builder.getName() );\n\t\tnameStoredProcedureQueryAnn.procedureName( jdbcCall.callableName );\n\n\t\tfinal StoredProcedureParameter[] parameters = new StoredProcedureParameter[jdbcCall.parameters.size()];\n\t\tnameStoredProcedureQueryAnn.parameters( parameters );\n\n\t\tfor ( int i = 0; i < jdbcCall.parameters.size(); i++ ) {\n\t\t\tfinal StoredProcedureParameterJpaAnnotation param = JpaAnnotations.STORED_PROCEDURE_PARAMETER.createUsage( sourceModelBuildingContext );\n\t\t\tparameters[i] = param;\n\n\t\t\tfinal String paramName = jdbcCall.parameters.get( i );\n\t\t\tparam.name( paramName );\n\t\t\tparam.mode( ParameterMode.IN );\n\n\t\t\tfinal String typeName = builder.getParameterTypes().get( paramName );\n\t\t\tfinal ClassDetails classDetails;\n\t\t\tif ( StringHelper.isEmpty( typeName ) ) {\n\t\t\t\tclassDetails = ClassDetails.VOID_CLASS_DETAILS;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfinal BasicType<Object> registeredType = context.getBootstrapContext()\n\t\t\t\t\t\t.getTypeConfiguration()\n\t\t\t\t\t\t.getBasicTypeRegistry()\n\t\t\t\t\t\t.getRegisteredType( typeName );\n\t\t\t\tclassDetails = context.getMetadataCollector().getClassDetailsRegistry().getClassDetails( registeredType.getJavaType().getName() );\n\t\t\t}\n\t\t\tparam.type( classDetails.toJavaClass() );\n\t\t}\n\n\t\tif ( builder.getResultSetMappingName() != null ) {\n\t\t\tnameStoredProcedureQueryAnn.resultSetMappings( new String[] { builder.getResultSetMappingName() } );\n\t\t}\n\n\t\tfinal Class<?> resultClass = builder.getResultClass();\n\t\tif ( resultClass != null ) {\n\t\t\tnameStoredProcedureQueryAnn.resultClasses( new Class[]{ builder.getResultClass() } );\n\t\t}\n\n\t\tfinal List<QueryHintJpaAnnotation> hints = new ArrayList<>();\n\n\t\tif ( builder.getQuerySpaces() != null ) {\n\t\t\tfinal QueryHintJpaAnnotation hint = JpaAnnotations.QUERY_HINT.createUsage( sourceModelBuildingContext );\n\t\t\thint.name( HibernateHints.HINT_NATIVE_SPACES );\n\t\t\thint.value( String.join( \" \", builder.getQuerySpaces() ) );\n\t\t\thints.add( hint );\n\t\t}\n\n\t\tif ( jdbcCall.resultParameter ) {\n\t\t\t// Mark native queries that have a result parameter as callable functions\n\t\t\tfinal QueryHintJpaAnnotation hint = JpaAnnotations.QUERY_HINT.createUsage( sourceModelBuildingContext );\n\t\t\thint.name( HibernateHints.HINT_CALLABLE_FUNCTION );\n\t\t\thint.value( \"true\" );\n\t\t\thints.add( hint );\n\t\t}\n\n\t\tnameStoredProcedureQueryAnn.hints( hints.toArray(QueryHint[]::new) );\n\n\t\treturn new NamedProcedureCallDefinitionImpl( nameStoredProcedureQueryAnn );\n\t}\n\n\tpublic static void bindQuery(\n\t\t\tString name,\n\t\t\tHQLSelect hqlSelect,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal NamedHqlQueryDefinition<?> hqlQueryDefinition = new NamedHqlQueryDefinition.Builder<>( name )\n\t\t\t\t.setFlushMode( FlushMode.MANUAL )\n\t\t\t\t.setHqlString( hqlSelect.query() )\n\t\t\t\t.build();\n\n\t\tcontext.getMetadataCollector().addNamedQuery( hqlQueryDefinition );\n\t}\n\n\tpublic static void bindQuery(\n\t\t\torg.hibernate.annotations.NamedQuery namedQuery,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( namedQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String registrationName = namedQuery.name();\n\n\t\t//ResultSetMappingDefinition mappingDefinition = mappings.getJdbcValuesMappingProducer( namedQuery.resultSetMapping() );\n\t\tif ( registrationName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tfinal int timeout = namedQuery.timeout();\n\t\tfinal int fetchSize = namedQuery.fetchSize();\n\n\t\tfinal NamedHqlQueryDefinition.Builder<?> builder = new NamedHqlQueryDefinition.Builder<>( registrationName )\n\t\t\t\t.setHqlString( namedQuery.query() )\n\t\t\t\t.setResultClass( (Class<Object>) namedQuery.resultClass() )\n\t\t\t\t.setCacheable( namedQuery.cacheable() )\n\t\t\t\t.setCacheRegion( nullIfEmpty( namedQuery.cacheRegion() ) )\n\t\t\t\t.setCacheMode( getCacheMode( namedQuery.cacheRetrieveMode(), namedQuery.cacheStoreMode() ) )\n\t\t\t\t.setTimeout( timeout < 0 ? null : timeout )\n\t\t\t\t.setFetchSize( fetchSize < 0 ? null : fetchSize )\n\t\t\t\t.setFlushMode( getFlushMode( namedQuery.flushMode() ) )\n\t\t\t\t.setReadOnly( namedQuery.readOnly() )\n\t\t\t\t.setComment( nullIfEmpty( namedQuery.comment() ) );\n\n\t\tfinal NamedHqlQueryDefinitionImpl<?> hqlQueryDefinition = builder.build();\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named query: %s => %s\", hqlQueryDefinition.getRegistrationName(), hqlQueryDefinition.getHqlString() );\n\t\t}\n\n\t\tcontext.getMetadataCollector().addNamedQuery( hqlQueryDefinition );\n\t}\n\n\tprivate static CacheMode getCacheMode(CacheRetrieveMode cacheRetrieveMode, CacheStoreMode cacheStoreMode) {\n\t\tfinal CacheMode cacheMode = CacheMode.fromJpaModes( cacheRetrieveMode, cacheStoreMode );\n\t\treturn cacheMode == null ? CacheMode.NORMAL : cacheMode;\n\t}\n\n\tprivate static FlushMode getFlushMode(FlushModeType flushModeType) {\n\t\treturn switch ( flushModeType ) {\n\t\t\tcase ALWAYS -> FlushMode.ALWAYS;\n\t\t\tcase AUTO -> FlushMode.AUTO;\n\t\t\tcase COMMIT -> FlushMode.COMMIT;\n\t\t\tcase MANUAL -> FlushMode.MANUAL;\n\t\t\tcase PERSISTENCE_CONTEXT -> null;\n\t\t};\n\t}\n\n\tpublic static void bindNamedStoredProcedureQuery(\n\t\t\tNamedStoredProcedureQuery namedStoredProcedureQuery,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\tif ( namedStoredProcedureQuery != null ) {\n\t\t\tif ( namedStoredProcedureQuery.name().isEmpty() ) {\n\t\t\t\tthrow new AnnotationException( \"Class or package level '@NamedStoredProcedureQuery' annotation must specify a 'name'\" );\n\t\t\t}\n\n\t\t\tfinal NamedProcedureCallDefinitionImpl definition = new NamedProcedureCallDefinitionImpl( namedStoredProcedureQuery );\n\t\t\tif ( isDefault ) {\n\t\t\t\tcontext.getMetadataCollector().addDefaultNamedProcedureCall( definition );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcontext.getMetadataCollector().addNamedProcedureCallDefinition( definition );\n\t\t\t}\n\t\t\tLOG.debugf( \"Bound named stored procedure query : %s => %s\", definition.getRegistrationName(), definition.getProcedureName() );\n\t\t}\n\t}\n\n\tpublic static void bindSqlResultSetMapping(\n\t\t\tSqlResultSetMapping resultSetMappingAnn,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\t//no need to handle inSecondPass\n\t\tcontext.getMetadataCollector().addSecondPass( new ResultSetMappingSecondPass( resultSetMappingAnn, context, isDefault ) );\n\t}\n\n\tprivate static class JdbcCall {\n\t\tprivate final String callableName;\n\t\tprivate final boolean resultParameter;\n\t\tprivate final ArrayList<String> parameters;\n\n\t\tpublic JdbcCall(String callableName, boolean resultParameter, ArrayList<String> parameters) {\n\t\t\tthis.callableName = callableName;\n\t\t\tthis.resultParameter = resultParameter;\n\t\t\tthis.parameters = parameters;\n\t\t}\n\t}\n\n\tprivate static JdbcCall parseJdbcCall(String sqlString, Supplier<RuntimeException> exceptionProducer) {\n\t\tString callableName = null;\n\t\tboolean resultParameter = false;\n\t\tint index = skipWhitespace( sqlString, 1 );\n\t\t// Parse the out param `?=` part\n\t\tif ( sqlString.charAt( index ) == '?' ) {\n\t\t\tresultParameter = true;\n\t\t\tindex++;\n\t\t\tindex = skipWhitespace( sqlString, index );\n\t\t\tif ( sqlString.charAt( index ) != '=' ) {\n\t\t\t\tthrow exceptionProducer.get();\n\t\t\t}\n\t\t\tindex++;\n\t\t\tindex = skipWhitespace( sqlString, index );\n\t\t}\n\t\t// Parse the call keyword\n\t\tif ( !sqlString.regionMatches( true, index, \"call\", 0, 4 ) ) {\n\t\t\tthrow exceptionProducer.get();\n\t\t}\n\t\tindex += 4;\n\t\tindex = skipWhitespace( sqlString, index );\n\n\t\t// Parse the procedure name\n\t\tfinal int procedureStart = index;\n\t\tfor ( ; index < sqlString.length(); index++ ) {\n\t\t\tfinal char c = sqlString.charAt( index );\n\t\t\tif ( c == '(' || Character.isWhitespace( c ) ) {\n\t\t\t\tcallableName = sqlString.substring( procedureStart, index );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tindex = skipWhitespace( sqlString, index );\n\t\tfinal ArrayList<String> parameters = new ArrayList<>();\n\t\tParameterParser.parse(\n\t\t\t\tsqlString.substring( index, sqlString.length() - 1 ),\n\t\t\t\tnew ParameterRecognizer() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void ordinalParameter(int sourcePosition) {\n\t\t\t\t\t\tparameters.add( \"\" );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void namedParameter(String name, int sourcePosition) {\n\t\t\t\t\t\tparameters.add( name );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void jpaPositionalParameter(int label, int sourcePosition) {\n\t\t\t\t\t\tparameters.add( \"\" );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void other(char character) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\treturn new JdbcCall( callableName, resultParameter, parameters );\n\t}\n\n\tprivate static int skipWhitespace(String sqlString, int i) {\n\t\twhile ( i < sqlString.length() ) {\n\t\t\tif ( !Character.isWhitespace( sqlString.charAt( i ) ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn i;\n\t}\n\n\tprivate static AnnotationException illegalCallSyntax(org.hibernate.annotations.NamedNativeQuery queryAnn) {\n\t\treturn new AnnotationException( \"Callable 'NamedNativeQuery' named '\" + queryAnn.name()\n\t\t\t\t+ \"' does not use the JDBC call syntax\" );\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/boot/model/internal/QueryBinder.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html.\n */\npackage org.hibernate.boot.model.internal;\n\nimport java.lang.invoke.MethodHandles;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.function.Supplier;\n\nimport org.hibernate.AnnotationException;\nimport org.hibernate.CacheMode;\nimport org.hibernate.FlushMode;\nimport org.hibernate.LockOptions;\nimport org.hibernate.annotations.FlushModeType;\nimport org.hibernate.annotations.HQLSelect;\nimport org.hibernate.annotations.SQLSelect;\nimport org.hibernate.boot.internal.NamedHqlQueryDefinitionImpl;\nimport org.hibernate.boot.internal.NamedProcedureCallDefinitionImpl;\nimport org.hibernate.boot.models.JpaAnnotations;\nimport org.hibernate.boot.models.annotations.internal.NamedStoredProcedureQueryJpaAnnotation;\nimport org.hibernate.boot.models.annotations.internal.QueryHintJpaAnnotation;\nimport org.hibernate.boot.models.annotations.internal.StoredProcedureParameterJpaAnnotation;\nimport org.hibernate.boot.query.NamedHqlQueryDefinition;\nimport org.hibernate.boot.query.NamedNativeQueryDefinition;\nimport org.hibernate.boot.query.NamedProcedureCallDefinition;\nimport org.hibernate.boot.query.SqlResultSetMappingDescriptor;\nimport org.hibernate.boot.registry.classloading.spi.ClassLoaderService;\nimport org.hibernate.boot.spi.MetadataBuildingContext;\nimport org.hibernate.internal.CoreMessageLogger;\nimport org.hibernate.internal.log.DeprecationLogger;\nimport org.hibernate.jpa.HibernateHints;\nimport org.hibernate.models.internal.util.StringHelper;\nimport org.hibernate.models.spi.ClassDetails;\nimport org.hibernate.models.spi.SourceModelBuildingContext;\nimport org.hibernate.query.sql.internal.ParameterParser;\nimport org.hibernate.query.sql.spi.ParameterRecognizer;\nimport org.hibernate.type.BasicType;\n\nimport org.jboss.logging.Logger;\n\nimport jakarta.persistence.CacheRetrieveMode;\nimport jakarta.persistence.CacheStoreMode;\nimport jakarta.persistence.NamedNativeQuery;\nimport jakarta.persistence.NamedQuery;\nimport jakarta.persistence.NamedStoredProcedureQuery;\nimport jakarta.persistence.ParameterMode;\nimport jakarta.persistence.QueryHint;\nimport jakarta.persistence.SqlResultSetMapping;\nimport jakarta.persistence.StoredProcedureParameter;\n\nimport static java.lang.Boolean.TRUE;\nimport static org.hibernate.internal.util.StringHelper.nullIfEmpty;\nimport static org.hibernate.internal.util.collections.ArrayHelper.isEmpty;\nimport static org.hibernate.internal.util.collections.CollectionHelper.determineProperSizing;\nimport static org.hibernate.internal.util.collections.CollectionHelper.setOf;\n\n/**\n * Responsible for reading named queries defined in annotations and registering\n * {@link org.hibernate.boot.query.NamedQueryDefinition} objects.\n *\n * @implNote This class is stateless, unlike most of the other \"binders\".\n *\n * @author Emmanuel Bernard\n */\npublic abstract class QueryBinder {\n\tprivate static final CoreMessageLogger LOG = Logger.getMessageLogger( MethodHandles.lookup(), CoreMessageLogger.class, QueryBinder.class.getName() );\n\n\tpublic static void bindQuery(\n\t\t\tNamedQuery namedQuery,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\tif ( namedQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String queryName = namedQuery.name();\n\t\tfinal String queryString = namedQuery.query();\n\t\tfinal Class<?> resultClass = namedQuery.resultClass();\n\n\t\tif ( queryName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named query: %s => %s\", queryName, queryString );\n\t\t}\n\n\t\tfinal QueryHintDefinition hints = new QueryHintDefinition( queryName, namedQuery.hints() );\n\t\tfinal NamedHqlQueryDefinition<?> queryMapping =\n\t\t\t\tcreateNamedQueryDefinition( queryName, queryString, resultClass,\n\t\t\t\t\t\thints.determineLockOptions( namedQuery ), hints );\n\t\tif ( isDefault ) {\n\t\t\tcontext.getMetadataCollector().addDefaultQuery( queryMapping );\n\t\t}\n\t\telse {\n\t\t\tcontext.getMetadataCollector().addNamedQuery( queryMapping );\n\t\t}\n\t}\n\n\tprivate static <T> NamedHqlQueryDefinitionImpl<T> createNamedQueryDefinition(\n\t\t\tString queryName, String queryString, Class<T> resultClass, LockOptions lockOptions,\n\t\t\tQueryHintDefinition hints) {\n\t\treturn new NamedHqlQueryDefinitionImpl.Builder<T>(queryName)\n\t\t\t\t.setHqlString(queryString)\n\t\t\t\t.setResultClass(resultClass)\n\t\t\t\t.setCacheable(hints.getCacheability())\n\t\t\t\t.setCacheMode(hints.getCacheMode())\n\t\t\t\t.setCacheRegion(hints.getString(HibernateHints.HINT_CACHE_REGION))\n\t\t\t\t.setTimeout(hints.getTimeout())\n\t\t\t\t.setFetchSize(hints.getInteger(HibernateHints.HINT_FETCH_SIZE))\n\t\t\t\t.setFlushMode(hints.getFlushMode())\n\t\t\t\t.setReadOnly(hints.getBooleanWrapper(HibernateHints.HINT_READ_ONLY))\n\t\t\t\t.setLockOptions(lockOptions)\n\t\t\t\t.setComment(hints.getString(HibernateHints.HINT_COMMENT))\n\t\t\t\t.build();\n\t}\n\n\tpublic static void bindNativeQuery(\n\t\t\tNamedNativeQuery namedNativeQuery,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\tif ( namedNativeQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String registrationName = namedNativeQuery.name();\n\t\tfinal String queryString = namedNativeQuery.query();\n\n\t\tif ( registrationName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedNativeQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tfinal QueryHintDefinition hints = new QueryHintDefinition( registrationName, namedNativeQuery.hints() );\n\n\t\tfinal String resultSetMappingName = namedNativeQuery.resultSetMapping();\n\t\tfinal Class<?> resultClassDetails = namedNativeQuery.resultClass();\n\t\tfinal Class<?> resultClass = void.class == resultClassDetails ? null : resultClassDetails;\n\n\t\tfinal NamedNativeQueryDefinition<?> queryDefinition =\n\t\t\t\tcreateNamedQueryDefinition( registrationName, queryString, resultClass, resultSetMappingName, hints );\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named native query: %s => %s\",\n\t\t\t\t\tqueryDefinition.getRegistrationName(), queryDefinition.getSqlQueryString() );\n\t\t}\n\n\t\tif ( isDefault ) {\n\t\t\tcontext.getMetadataCollector().addDefaultNamedNativeQuery( queryDefinition );\n\t\t}\n\t\telse {\n\t\t\tcontext.getMetadataCollector().addNamedNativeQuery( queryDefinition );\n\t\t}\n\t}\n\n\tprivate static <T> NamedNativeQueryDefinition<T> createNamedQueryDefinition(\n\t\t\tString registrationName, String queryString,\n\t\t\tClass<T> resultClass, String resultSetMappingName,\n\t\t\tQueryHintDefinition hints) {\n\t\treturn new NamedNativeQueryDefinition.Builder<T>(registrationName)\n\t\t\t\t.setSqlString(queryString)\n\t\t\t\t.setResultClass(resultClass)\n\t\t\t\t.setResultSetMappingName(resultSetMappingName)\n\t\t\t\t.setQuerySpaces(null)\n\t\t\t\t.setCacheable(hints.getCacheability())\n\t\t\t\t.setCacheMode(hints.getCacheMode())\n\t\t\t\t.setCacheRegion(hints.getString(HibernateHints.HINT_CACHE_REGION))\n\t\t\t\t.setTimeout(hints.getTimeout())\n\t\t\t\t.setFetchSize(hints.getInteger(HibernateHints.HINT_FETCH_SIZE))\n\t\t\t\t.setFlushMode(hints.getFlushMode())\n\t\t\t\t.setReadOnly(hints.getBooleanWrapper(HibernateHints.HINT_READ_ONLY))\n\t\t\t\t.setComment(hints.getString(HibernateHints.HINT_COMMENT))\n\t\t\t\t.addHints(hints.getHintsMap())\n\t\t\t\t.build();\n\t}\n\n\tpublic static void bindNativeQuery(\n\t\t\tString name,\n\t\t\tSQLSelect sqlSelect,\n\t\t\tClassDetails annotatedClass,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal NamedNativeQueryDefinition.Builder<?> builder = new NamedNativeQueryDefinition.Builder<>( name )\n\t\t\t\t.setFlushMode( FlushMode.MANUAL )\n\t\t\t\t.setSqlString( sqlSelect.sql() )\n\t\t\t\t.setQuerySpaces( setOf( sqlSelect.querySpaces() ) );\n\n\t\tif ( annotatedClass != null ) {\n\t\t\tbuilder.setResultClass(\n\t\t\t\t\tcontext.getBootstrapContext().getServiceRegistry().requireService( ClassLoaderService.class )\n\t\t\t\t\t\t\t.classForName( annotatedClass.getClassName() )\n\t\t\t);\n\t\t}\n\n\t\tfinal SqlResultSetMapping resultSetMapping = sqlSelect.resultSetMapping();\n\t\tif ( !isEmpty( resultSetMapping.columns() )\n\t\t\t\t|| !isEmpty( resultSetMapping.entities() )\n\t\t\t\t|| !isEmpty( resultSetMapping.classes() ) ) {\n\t\t\tcontext.getMetadataCollector()\n\t\t\t\t\t.addResultSetMapping( SqlResultSetMappingDescriptor.from( resultSetMapping, name ) );\n\t\t\tbuilder.setResultSetMappingName( name );\n\t\t}\n\n\t\tcontext.getMetadataCollector().addNamedNativeQuery( builder.build() );\n\t}\n\n\tpublic static void bindNativeQuery(\n\t\t\torg.hibernate.annotations.NamedNativeQuery namedNativeQuery,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( namedNativeQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String registrationName = namedNativeQuery.name();\n\n\t\tif ( registrationName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedNativeQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tfinal String resultSetMappingName = namedNativeQuery.resultSetMapping();\n\t\tfinal Class<?> resultClassDetails = namedNativeQuery.resultClass();\n\t\tfinal Class<?> resultClass = resultClassDetails == void.class ? null : resultClassDetails;\n\n\t\tfinal String[] querySpacesList = namedNativeQuery.querySpaces();\n\t\tfinal HashSet<String> querySpaces = new HashSet<>( determineProperSizing( querySpacesList.length ) );\n\t\tCollections.addAll( querySpaces, querySpacesList );\n\n\t\tfinal NamedNativeQueryDefinition.Builder<?> builder =\n\t\t\t\tcreateQueryDefinition( namedNativeQuery, registrationName, resultSetMappingName, resultClass,\n\t\t\t\t\t\tnamedNativeQuery.timeout(), namedNativeQuery.fetchSize(), querySpaces );\n\n\t\tif ( TRUE == namedNativeQuery.callable() ) {\n\t\t\tfinal NamedProcedureCallDefinition definition =\n\t\t\t\t\tcreateStoredProcedure( builder, context, () -> illegalCallSyntax( namedNativeQuery ) );\n\t\t\tcontext.getMetadataCollector().addNamedProcedureCallDefinition( definition );\n\t\t\tDeprecationLogger.DEPRECATION_LOGGER.warn(\n\t\t\t\t\t\"Marking named native queries as callable is no longer supported; use '@jakarta.persistence.NamedStoredProcedureQuery' instead. Ignoring.\"\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tfinal NamedNativeQueryDefinition<?> queryDefinition = builder.build();\n\n\t\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\t\tLOG.debugf(\n\t\t\t\t\t\t\"Binding named native query: %s => %s\",\n\t\t\t\t\t\tqueryDefinition.getRegistrationName(),\n\t\t\t\t\t\tqueryDefinition.getSqlQueryString()\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tcontext.getMetadataCollector().addNamedNativeQuery( queryDefinition );\n\t\t}\n\t}\n\n\tprivate static <T> NamedNativeQueryDefinition.Builder<T> createQueryDefinition(\n\t\t\torg.hibernate.annotations.NamedNativeQuery namedNativeQuery,\n\t\t\tString registrationName, String resultSetMappingName,\n\t\t\tClass<T> resultClass,\n\t\t\tint timeout, int fetchSize,\n\t\t\tHashSet<String> querySpaces) {\n\t\treturn new NamedNativeQueryDefinition.Builder<T>(registrationName)\n\t\t\t\t.setSqlString(namedNativeQuery.query())\n\t\t\t\t.setResultSetMappingName(resultSetMappingName)\n\t\t\t\t.setResultClass(resultClass)\n\t\t\t\t.setCacheable(namedNativeQuery.cacheable())\n\t\t\t\t.setCacheRegion(nullIfEmpty(namedNativeQuery.cacheRegion()))\n\t\t\t\t.setCacheMode(getCacheMode(namedNativeQuery.cacheRetrieveMode(), namedNativeQuery.cacheStoreMode()))\n\t\t\t\t.setTimeout(timeout < 0 ? null : timeout)\n\t\t\t\t.setFetchSize(fetchSize < 0 ? null : fetchSize)\n\t\t\t\t.setFlushMode(getFlushMode(namedNativeQuery.flushMode()))\n\t\t\t\t.setReadOnly(namedNativeQuery.readOnly())\n\t\t\t\t.setQuerySpaces(querySpaces)\n\t\t\t\t.setComment(nullIfEmpty(namedNativeQuery.comment()));\n\t}\n\n\t/**\n\t * Handles legacy cases where a named native query was used to specify a procedure call\n\t *\n\t * @deprecated User should use {@linkplain NamedStoredProcedureQuery} instead\n\t */\n\t@Deprecated\n\tpublic static NamedProcedureCallDefinition createStoredProcedure(\n\t\t\tNamedNativeQueryDefinition.Builder<?> builder,\n\t\t\tMetadataBuildingContext context,\n\t\t\tSupplier<RuntimeException> exceptionProducer) {\n\t\tfinal String sqlString = builder.getSqlString().trim();\n\t\tif ( !sqlString.startsWith( \"{\" ) || !sqlString.endsWith( \"}\" ) ) {\n\t\t\tthrow exceptionProducer.get();\n\t\t}\n\t\tfinal JdbcCall jdbcCall = parseJdbcCall( sqlString, exceptionProducer );\n\n\t\tfinal SourceModelBuildingContext sourceModelBuildingContext = context.getMetadataCollector()\n\t\t\t\t.getSourceModelBuildingContext();\n\t\tfinal NamedStoredProcedureQueryJpaAnnotation nameStoredProcedureQueryAnn =\n\t\t\t\tJpaAnnotations.NAMED_STORED_PROCEDURE_QUERY.createUsage( sourceModelBuildingContext );\n\t\tnameStoredProcedureQueryAnn.name( builder.getName() );\n\t\tnameStoredProcedureQueryAnn.procedureName( jdbcCall.callableName );\n\n\t\tfinal StoredProcedureParameter[] parameters = new StoredProcedureParameter[jdbcCall.parameters.size()];\n\t\tnameStoredProcedureQueryAnn.parameters( parameters );\n\n\t\tfor ( int i = 0; i < jdbcCall.parameters.size(); i++ ) {\n\t\t\tfinal StoredProcedureParameterJpaAnnotation param =\n\t\t\t\t\tJpaAnnotations.STORED_PROCEDURE_PARAMETER.createUsage( sourceModelBuildingContext );\n\t\t\tparameters[i] = param;\n\n\t\t\tfinal String paramName = jdbcCall.parameters.get( i );\n\t\t\tparam.name( paramName );\n\t\t\tparam.mode( ParameterMode.IN );\n\n\t\t\tfinal String typeName = builder.getParameterTypes().get( paramName );\n\t\t\tfinal ClassDetails classDetails;\n\t\t\tif ( StringHelper.isEmpty( typeName ) ) {\n\t\t\t\tclassDetails = ClassDetails.VOID_CLASS_DETAILS;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfinal BasicType<Object> registeredType = context.getBootstrapContext()\n\t\t\t\t\t\t.getTypeConfiguration()\n\t\t\t\t\t\t.getBasicTypeRegistry()\n\t\t\t\t\t\t.getRegisteredType( typeName );\n\t\t\t\tclassDetails = context.getMetadataCollector().getClassDetailsRegistry()\n\t\t\t\t\t\t.getClassDetails( registeredType.getJavaType().getName() );\n\t\t\t}\n\t\t\tparam.type( classDetails.toJavaClass() );\n\t\t}\n\n\t\tif ( builder.getResultSetMappingName() != null ) {\n\t\t\tnameStoredProcedureQueryAnn.resultSetMappings( new String[] { builder.getResultSetMappingName() } );\n\t\t}\n\n\t\tfinal Class<?> resultClass = builder.getResultClass();\n\t\tif ( resultClass != null ) {\n\t\t\tnameStoredProcedureQueryAnn.resultClasses( new Class[]{ builder.getResultClass() } );\n\t\t}\n\n\t\tfinal List<QueryHintJpaAnnotation> hints = new ArrayList<>();\n\n\t\tif ( builder.getQuerySpaces() != null ) {\n\t\t\tfinal QueryHintJpaAnnotation hint =\n\t\t\t\t\tJpaAnnotations.QUERY_HINT.createUsage( sourceModelBuildingContext );\n\t\t\thint.name( HibernateHints.HINT_NATIVE_SPACES );\n\t\t\thint.value( String.join( \" \", builder.getQuerySpaces() ) );\n\t\t\thints.add( hint );\n\t\t}\n\n\t\tif ( jdbcCall.resultParameter ) {\n\t\t\t// Mark native queries that have a result parameter as callable functions\n\t\t\tfinal QueryHintJpaAnnotation hint =\n\t\t\t\t\tJpaAnnotations.QUERY_HINT.createUsage( sourceModelBuildingContext );\n\t\t\thint.name( HibernateHints.HINT_CALLABLE_FUNCTION );\n\t\t\thint.value( \"true\" );\n\t\t\thints.add( hint );\n\t\t}\n\n\t\tnameStoredProcedureQueryAnn.hints( hints.toArray(QueryHint[]::new) );\n\n\t\treturn new NamedProcedureCallDefinitionImpl( nameStoredProcedureQueryAnn );\n\t}\n\n\tpublic static void bindQuery(\n\t\t\tString name,\n\t\t\tHQLSelect hqlSelect,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal NamedHqlQueryDefinition<?> hqlQueryDefinition = new NamedHqlQueryDefinition.Builder<>( name )\n\t\t\t\t.setFlushMode( FlushMode.MANUAL )\n\t\t\t\t.setHqlString( hqlSelect.query() )\n\t\t\t\t.build();\n\n\t\tcontext.getMetadataCollector().addNamedQuery( hqlQueryDefinition );\n\t}\n\n\tpublic static void bindQuery(\n\t\t\torg.hibernate.annotations.NamedQuery namedQuery,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( namedQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String registrationName = namedQuery.name();\n\t\tfinal Class<?> resultClass = namedQuery.resultClass();\n\n\t\tif ( registrationName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tfinal NamedHqlQueryDefinition.Builder<?> builder =\n\t\t\t\tcreateQueryDefinition( namedQuery, registrationName, resultClass,\n\t\t\t\t\t\tnamedQuery.timeout(), namedQuery.fetchSize() ) ;\n\n\t\tfinal NamedHqlQueryDefinitionImpl<?> hqlQueryDefinition = builder.build();\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named query: %s => %s\",\n\t\t\t\t\thqlQueryDefinition.getRegistrationName(), hqlQueryDefinition.getHqlString() );\n\t\t}\n\n\t\tcontext.getMetadataCollector().addNamedQuery( hqlQueryDefinition );\n\t}\n\n\tprivate static <T> NamedHqlQueryDefinition.Builder<T> createQueryDefinition(\n\t\t\torg.hibernate.annotations.NamedQuery namedQuery,\n\t\t\tString registrationName, Class<T> resultClass, int timeout, int fetchSize) {\n\t\treturn new NamedHqlQueryDefinition.Builder<T>(registrationName)\n\t\t\t\t.setHqlString(namedQuery.query())\n\t\t\t\t.setResultClass(resultClass)\n\t\t\t\t.setCacheable(namedQuery.cacheable())\n\t\t\t\t.setCacheRegion(nullIfEmpty(namedQuery.cacheRegion()))\n\t\t\t\t.setCacheMode(getCacheMode(namedQuery.cacheRetrieveMode(), namedQuery.cacheStoreMode()))\n\t\t\t\t.setTimeout(timeout < 0 ? null : timeout)\n\t\t\t\t.setFetchSize(fetchSize < 0 ? null : fetchSize)\n\t\t\t\t.setFlushMode(getFlushMode(namedQuery.flushMode()))\n\t\t\t\t.setReadOnly(namedQuery.readOnly())\n\t\t\t\t.setComment(nullIfEmpty(namedQuery.comment()));\n\t}\n\n\tprivate static CacheMode getCacheMode(CacheRetrieveMode cacheRetrieveMode, CacheStoreMode cacheStoreMode) {\n\t\tfinal CacheMode cacheMode = CacheMode.fromJpaModes( cacheRetrieveMode, cacheStoreMode );\n\t\treturn cacheMode == null ? CacheMode.NORMAL : cacheMode;\n\t}\n\n\tprivate static FlushMode getFlushMode(FlushModeType flushModeType) {\n\t\treturn switch ( flushModeType ) {\n\t\t\tcase ALWAYS -> FlushMode.ALWAYS;\n\t\t\tcase AUTO -> FlushMode.AUTO;\n\t\t\tcase COMMIT -> FlushMode.COMMIT;\n\t\t\tcase MANUAL -> FlushMode.MANUAL;\n\t\t\tcase PERSISTENCE_CONTEXT -> null;\n\t\t};\n\t}\n\n\tpublic static void bindNamedStoredProcedureQuery(\n\t\t\tNamedStoredProcedureQuery namedStoredProcedureQuery,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\tif ( namedStoredProcedureQuery != null ) {\n\t\t\tif ( namedStoredProcedureQuery.name().isEmpty() ) {\n\t\t\t\tthrow new AnnotationException( \"Class or package level '@NamedStoredProcedureQuery' annotation must specify a 'name'\" );\n\t\t\t}\n\n\t\t\tfinal NamedProcedureCallDefinitionImpl definition =\n\t\t\t\t\tnew NamedProcedureCallDefinitionImpl( namedStoredProcedureQuery );\n\t\t\tif ( isDefault ) {\n\t\t\t\tcontext.getMetadataCollector().addDefaultNamedProcedureCall( definition );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcontext.getMetadataCollector().addNamedProcedureCallDefinition( definition );\n\t\t\t}\n\t\t\tLOG.debugf( \"Bound named stored procedure query : %s => %s\",\n\t\t\t\t\tdefinition.getRegistrationName(), definition.getProcedureName() );\n\t\t}\n\t}\n\n\tpublic static void bindSqlResultSetMapping(\n\t\t\tSqlResultSetMapping resultSetMappingAnn,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\t//no need to handle inSecondPass\n\t\tcontext.getMetadataCollector()\n\t\t\t\t.addSecondPass( new ResultSetMappingSecondPass( resultSetMappingAnn, context, isDefault ) );\n\t}\n\n\tprivate static class JdbcCall {\n\t\tprivate final String callableName;\n\t\tprivate final boolean resultParameter;\n\t\tprivate final ArrayList<String> parameters;\n\n\t\tpublic JdbcCall(String callableName, boolean resultParameter, ArrayList<String> parameters) {\n\t\t\tthis.callableName = callableName;\n\t\t\tthis.resultParameter = resultParameter;\n\t\t\tthis.parameters = parameters;\n\t\t}\n\t}\n\n\tprivate static JdbcCall parseJdbcCall(String sqlString, Supplier<RuntimeException> exceptionProducer) {\n\t\tString callableName = null;\n\t\tboolean resultParameter = false;\n\t\tint index = skipWhitespace( sqlString, 1 );\n\t\t// Parse the out param `?=` part\n\t\tif ( sqlString.charAt( index ) == '?' ) {\n\t\t\tresultParameter = true;\n\t\t\tindex++;\n\t\t\tindex = skipWhitespace( sqlString, index );\n\t\t\tif ( sqlString.charAt( index ) != '=' ) {\n\t\t\t\tthrow exceptionProducer.get();\n\t\t\t}\n\t\t\tindex++;\n\t\t\tindex = skipWhitespace( sqlString, index );\n\t\t}\n\t\t// Parse the call keyword\n\t\tif ( !sqlString.regionMatches( true, index, \"call\", 0, 4 ) ) {\n\t\t\tthrow exceptionProducer.get();\n\t\t}\n\t\tindex += 4;\n\t\tindex = skipWhitespace( sqlString, index );\n\n\t\t// Parse the procedure name\n\t\tfinal int procedureStart = index;\n\t\tfor ( ; index < sqlString.length(); index++ ) {\n\t\t\tfinal char c = sqlString.charAt( index );\n\t\t\tif ( c == '(' || Character.isWhitespace( c ) ) {\n\t\t\t\tcallableName = sqlString.substring( procedureStart, index );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tindex = skipWhitespace( sqlString, index );\n\t\tfinal ArrayList<String> parameters = new ArrayList<>();\n\t\tParameterParser.parse(\n\t\t\t\tsqlString.substring( index, sqlString.length() - 1 ),\n\t\t\t\tnew ParameterRecognizer() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void ordinalParameter(int sourcePosition) {\n\t\t\t\t\t\tparameters.add( \"\" );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void namedParameter(String name, int sourcePosition) {\n\t\t\t\t\t\tparameters.add( name );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void jpaPositionalParameter(int label, int sourcePosition) {\n\t\t\t\t\t\tparameters.add( \"\" );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void other(char character) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\treturn new JdbcCall( callableName, resultParameter, parameters );\n\t}\n\n\tprivate static int skipWhitespace(String sqlString, int i) {\n\t\twhile ( i < sqlString.length() ) {\n\t\t\tif ( !Character.isWhitespace( sqlString.charAt( i ) ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn i;\n\t}\n\n\tprivate static AnnotationException illegalCallSyntax(org.hibernate.annotations.NamedNativeQuery queryAnn) {\n\t\treturn new AnnotationException( \"Callable 'NamedNativeQuery' named '\" + queryAnn.name()\n\t\t\t\t+ \"' does not use the JDBC call syntax\" );\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private static <T> NamedHqlQueryDefinitionImpl<T> createNamedQueryDefinition(\n\t\t\tString queryName, String queryString, Class<T> resultClass, LockOptions lockOptions,\n\t\t\tQueryHintDefinition hints) {\n\t\treturn new NamedHqlQueryDefinitionImpl.Builder<T>(queryName)\n\t\t\t\t.setHqlString(queryString)\n\t\t\t\t.setResultClass(resultClass)\n\t\t\t\t.setCacheable(hints.getCacheability())\n\t\t\t\t.setCacheMode(hints.getCacheMode())\n\t\t\t\t.setCacheRegion(hints.getString(HibernateHints.HINT_CACHE_REGION))\n\t\t\t\t.setTimeout(hints.getTimeout())\n\t\t\t\t.setFetchSize(hints.getInteger(HibernateHints.HINT_FETCH_SIZE))\n\t\t\t\t.setFlushMode(hints.getFlushMode())\n\t\t\t\t.setReadOnly(hints.getBooleanWrapper(HibernateHints.HINT_READ_ONLY))\n\t\t\t\t.setLockOptions(lockOptions)\n\t\t\t\t.setComment(hints.getString(HibernateHints.HINT_COMMENT))\n\t\t\t\t.build();\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.boot.model.internal.QueryBinder#getCacheMode\n methodBody: private static CacheMode getCacheMode(CacheRetrieveMode cacheRetrieveMode, CacheStoreMode cacheStoreMode) {\nfinal CacheMode cacheMode=CacheMode.fromJpaModes(cacheRetrieveMode,cacheStoreMode);\nreturn cacheMode == null ? CacheMode.NORMAL : cacheMode;\n}",
            "methodSignature: org.hibernate.boot.model.internal.QueryBinder#getFlushMode\n methodBody: private static FlushMode getFlushMode(FlushModeType flushModeType) {\nreturn switch (flushModeType) {\ncase ALWAYS ->  yield FlushMode.ALWAYS;\ncase AUTO ->yield FlushMode.AUTO;\ncase COMMIT ->yield FlushMode.COMMIT;\ncase MANUAL ->yield FlushMode.MANUAL;\ncase PERSISTENCE_CONTEXT ->yield null;\n}\n;\n}"
        ],
        "sourceCodeAfterRefactoring": "public static void bindQuery(\n\t\t\tNamedQuery namedQuery,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\tif ( namedQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String queryName = namedQuery.name();\n\t\tfinal String queryString = namedQuery.query();\n\t\tfinal Class<?> resultClass = namedQuery.resultClass();\n\n\t\tif ( queryName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named query: %s => %s\", queryName, queryString );\n\t\t}\n\n\t\tfinal QueryHintDefinition hints = new QueryHintDefinition( queryName, namedQuery.hints() );\n\t\tfinal NamedHqlQueryDefinition<?> queryMapping =\n\t\t\t\tcreateNamedQueryDefinition( queryName, queryString, resultClass,\n\t\t\t\t\t\thints.determineLockOptions( namedQuery ), hints );\n\t\tif ( isDefault ) {\n\t\t\tcontext.getMetadataCollector().addDefaultQuery( queryMapping );\n\t\t}\n\t\telse {\n\t\t\tcontext.getMetadataCollector().addNamedQuery( queryMapping );\n\t\t}\n\t}\nprivate static <T> NamedHqlQueryDefinitionImpl<T> createNamedQueryDefinition(\n\t\t\tString queryName, String queryString, Class<T> resultClass, LockOptions lockOptions,\n\t\t\tQueryHintDefinition hints) {\n\t\treturn new NamedHqlQueryDefinitionImpl.Builder<T>(queryName)\n\t\t\t\t.setHqlString(queryString)\n\t\t\t\t.setResultClass(resultClass)\n\t\t\t\t.setCacheable(hints.getCacheability())\n\t\t\t\t.setCacheMode(hints.getCacheMode())\n\t\t\t\t.setCacheRegion(hints.getString(HibernateHints.HINT_CACHE_REGION))\n\t\t\t\t.setTimeout(hints.getTimeout())\n\t\t\t\t.setFetchSize(hints.getInteger(HibernateHints.HINT_FETCH_SIZE))\n\t\t\t\t.setFlushMode(hints.getFlushMode())\n\t\t\t\t.setReadOnly(hints.getBooleanWrapper(HibernateHints.HINT_READ_ONLY))\n\t\t\t\t.setLockOptions(lockOptions)\n\t\t\t\t.setComment(hints.getString(HibernateHints.HINT_COMMENT))\n\t\t\t\t.build();\n\t}",
        "diffSourceCode": "-   73: \tpublic static void bindQuery(\n-   74: \t\t\tNamedQuery namedQuery,\n-   75: \t\t\tMetadataBuildingContext context,\n-   76: \t\t\tboolean isDefault) {\n-   77: \t\tif ( namedQuery == null ) {\n-   78: \t\t\treturn;\n-   79: \t\t}\n-   80: \n-   81: \t\tfinal String queryName = namedQuery.name();\n-   82: \t\tfinal String queryString = namedQuery.query();\n-   83: \n-   84: \t\tif ( queryName.isEmpty() ) {\n-   85: \t\t\tthrow new AnnotationException( \"Class or package level '@NamedQuery' annotation must specify a 'name'\" );\n-   86: \t\t}\n-   87: \n-   88: \t\tif ( LOG.isDebugEnabled() ) {\n-   89: \t\t\tLOG.debugf( \"Binding named query: %s => %s\", queryName, queryString );\n-   90: \t\t}\n-   91: \n-   92: \t\tfinal QueryHintDefinition hints = new QueryHintDefinition( queryName, namedQuery.hints() );\n+   73: \n+   74: \tpublic static void bindQuery(\n+   75: \t\t\tNamedQuery namedQuery,\n+   76: \t\t\tMetadataBuildingContext context,\n+   77: \t\t\tboolean isDefault) {\n+   78: \t\tif ( namedQuery == null ) {\n+   79: \t\t\treturn;\n+   80: \t\t}\n+   81: \n+   82: \t\tfinal String queryName = namedQuery.name();\n+   83: \t\tfinal String queryString = namedQuery.query();\n+   84: \t\tfinal Class<?> resultClass = namedQuery.resultClass();\n+   85: \n+   86: \t\tif ( queryName.isEmpty() ) {\n+   87: \t\t\tthrow new AnnotationException( \"Class or package level '@NamedQuery' annotation must specify a 'name'\" );\n+   88: \t\t}\n+   89: \n+   90: \t\tif ( LOG.isDebugEnabled() ) {\n+   91: \t\t\tLOG.debugf( \"Binding named query: %s => %s\", queryName, queryString );\n+   92: \t\t}\n    93: \n-   94: \t\tfinal NamedHqlQueryDefinition<?> queryMapping = new NamedHqlQueryDefinitionImpl.Builder<>( queryName )\n-   95: \t\t\t\t.setHqlString( queryString )\n-   96: \t\t\t\t.setResultClass( (Class<Object>) namedQuery.resultClass() )\n-   97: \t\t\t\t.setCacheable( hints.getCacheability() )\n-   98: \t\t\t\t.setCacheMode( hints.getCacheMode() )\n-   99: \t\t\t\t.setCacheRegion( hints.getString( HibernateHints.HINT_CACHE_REGION ) )\n-  100: \t\t\t\t.setTimeout( hints.getTimeout() )\n-  101: \t\t\t\t.setFetchSize( hints.getInteger( HibernateHints.HINT_FETCH_SIZE ) )\n-  102: \t\t\t\t.setFlushMode( hints.getFlushMode() )\n-  103: \t\t\t\t.setReadOnly( hints.getBooleanWrapper( HibernateHints.HINT_READ_ONLY ) )\n-  104: \t\t\t\t.setLockOptions( hints.determineLockOptions( namedQuery ) )\n-  105: \t\t\t\t.setComment( hints.getString( HibernateHints.HINT_COMMENT ) )\n-  106: \t\t\t\t.build();\n-  107: \n-  108: \t\tif ( isDefault ) {\n-  109: \t\t\tcontext.getMetadataCollector().addDefaultQuery( queryMapping );\n-  110: \t\t}\n-  111: \t\telse {\n-  112: \t\t\tcontext.getMetadataCollector().addNamedQuery( queryMapping );\n-  113: \t\t}\n-  114: \t}\n-  115: \n-  116: \tprivate static Class<Object> loadClass(ClassDetails classDetails, MetadataBuildingContext context) {\n-  117: \t\treturn ClassDetails.VOID_CLASS_DETAILS == classDetails\n-  118: \t\t\t\t? null\n-  119: \t\t\t\t: context.getBootstrapContext()\n-  120: \t\t\t\t\t\t.getServiceRegistry()\n-  121: \t\t\t\t\t\t.requireService( ClassLoaderService.class )\n-  122: \t\t\t\t\t\t.classForName( classDetails.getName() );\n+   94: \t\tfinal QueryHintDefinition hints = new QueryHintDefinition( queryName, namedQuery.hints() );\n+   95: \t\tfinal NamedHqlQueryDefinition<?> queryMapping =\n+   96: \t\t\t\tcreateNamedQueryDefinition( queryName, queryString, resultClass,\n+   97: \t\t\t\t\t\thints.determineLockOptions( namedQuery ), hints );\n+   98: \t\tif ( isDefault ) {\n+   99: \t\t\tcontext.getMetadataCollector().addDefaultQuery( queryMapping );\n+  100: \t\t}\n+  101: \t\telse {\n+  102: \t\t\tcontext.getMetadataCollector().addNamedQuery( queryMapping );\n+  103: \t\t}\n+  104: \t}\n+  105: \n+  106: \tprivate static <T> NamedHqlQueryDefinitionImpl<T> createNamedQueryDefinition(\n+  107: \t\t\tString queryName, String queryString, Class<T> resultClass, LockOptions lockOptions,\n+  108: \t\t\tQueryHintDefinition hints) {\n+  109: \t\treturn new NamedHqlQueryDefinitionImpl.Builder<T>(queryName)\n+  110: \t\t\t\t.setHqlString(queryString)\n+  111: \t\t\t\t.setResultClass(resultClass)\n+  112: \t\t\t\t.setCacheable(hints.getCacheability())\n+  113: \t\t\t\t.setCacheMode(hints.getCacheMode())\n+  114: \t\t\t\t.setCacheRegion(hints.getString(HibernateHints.HINT_CACHE_REGION))\n+  115: \t\t\t\t.setTimeout(hints.getTimeout())\n+  116: \t\t\t\t.setFetchSize(hints.getInteger(HibernateHints.HINT_FETCH_SIZE))\n+  117: \t\t\t\t.setFlushMode(hints.getFlushMode())\n+  118: \t\t\t\t.setReadOnly(hints.getBooleanWrapper(HibernateHints.HINT_READ_ONLY))\n+  119: \t\t\t\t.setLockOptions(lockOptions)\n+  120: \t\t\t\t.setComment(hints.getString(HibernateHints.HINT_COMMENT))\n+  121: \t\t\t\t.build();\n+  122: \t}\n",
        "uniqueId": "b53728f7278c40ef41e22326f917ca5c718ce6e7_73_114_106_122_74_104",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 13,
                "covered": 31
            },
            "BRANCH": {
                "missed": 3,
                "covered": 3
            },
            "LINE": {
                "missed": 4,
                "covered": 11
            },
            "COMPLEXITY": {
                "missed": 3,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": true,
        "compileAndTestResult": true,
        "refactoredCode": "##########################\npublic static void bindQuery(\n        NamedQuery namedQuery,\n        MetadataBuildingContext context,\n        boolean isDefault) {\n    if (namedQuery == null) {\n        return;\n    }\n\n    final String queryName = namedQuery.name();\n    final String queryString = namedQuery.query();\n\n    if (queryName.isEmpty()) {\n        throw new AnnotationException(\"Class or package level '@NamedQuery' annotation must specify a 'name'\");\n    }\n\n    if (LOG.isDebugEnabled()) {\n        LOG.debugf(\"Binding named query: %s => %s\", queryName, queryString);\n    }\n\n    final QueryHintDefinition hints = new QueryHintDefinition(queryName, namedQuery.hints());\n\n    final NamedHqlQueryDefinition<?> queryMapping = createNamedHqlQueryDefinition(queryName, queryString, namedQuery, hints);\n\n    if (isDefault) {\n        context.getMetadataCollector().addDefaultQuery(queryMapping);\n    } else {\n        context.getMetadataCollector().addNamedQuery(queryMapping);\n    }\n}\n\nprivate static NamedHqlQueryDefinition<?> createNamedHqlQueryDefinition(String queryName, String queryString, NamedQuery namedQuery, QueryHintDefinition hints) {\n    return new NamedHqlQueryDefinitionImpl.Builder<>(queryName)\n            .setHqlString(queryString)\n            .setResultClass((Class<Object>) namedQuery.resultClass())\n            .setCacheable(hints.getCacheability())\n            .setCacheMode(hints.getCacheMode())\n            .setCacheRegion(hints.getString(HibernateHints.HINT_CACHE_REGION))\n            .setTimeout(hints.getTimeout())\n            .setFetchSize(hints.getInteger(HibernateHints.HINT_FETCH_SIZE))\n            .setFlushMode(hints.getFlushMode())\n            .setReadOnly(hints.getBooleanWrapper(HibernateHints.HINT_READ_ONLY))\n            .setLockOptions(hints.determineLockOptions(namedQuery))\n            .setComment(hints.getString(HibernateHints.HINT_COMMENT))\n            .build();\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\npublic static void bindQuery(\n\t\t\tNamedQuery namedQuery,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\tif ( namedQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String queryName = namedQuery.name();\n\t\tfinal String queryString = namedQuery.query();\n\n\t\tif ( queryName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named query: %s => %s\", queryName, queryString );\n\t\t}\n\n\t\tfinal QueryHintDefinition hints = new QueryHintDefinition( queryName, namedQuery.hints() );\n\n\t\tfinal NamedHqlQueryDefinition<?> queryMapping = new NamedHqlQueryDefinitionImpl.Builder<>( queryName )\n\t\t\t\t.setHqlString( queryString )\n\t\t\t\t.setResultClass( (Class<Object>) namedQuery.resultClass() )\n\t\t\t\t.setCacheable( hints.getCacheability() )\n\t\t\t\t.setCacheMode( hints.getCacheMode() )\n\t\t\t\t.setCacheRegion( hints.getString( HibernateHints.HINT_CACHE_REGION ) )\n\t\t\t\t.setTimeout( hints.getTimeout() )\n\t\t\t\t.setFetchSize( hints.getInteger( HibernateHints.HINT_FETCH_SIZE ) )\n\t\t\t\t.setFlushMode( hints.getFlushMode() )\n\t\t\t\t.setReadOnly( hints.getBooleanWrapper( HibernateHints.HINT_READ_ONLY ) )\n\t\t\t\t.setLockOptions( hints.determineLockOptions( namedQuery ) )\n\t\t\t\t.setComment( hints.getString( HibernateHints.HINT_COMMENT ) )\n\t\t\t\t.build();\n\n\t\tif ( isDefault ) {\n\t\t\tcontext.getMetadataCollector().addDefaultQuery( queryMapping );\n\t\t}\n\t\telse {\n\t\t\tcontext.getMetadataCollector().addNamedQuery( queryMapping );\n\t\t}\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html.\n */\npackage org.hibernate.boot.model.internal;\n\nimport java.lang.invoke.MethodHandles;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.function.Supplier;\n\nimport org.hibernate.AnnotationException;\nimport org.hibernate.CacheMode;\nimport org.hibernate.FlushMode;\nimport org.hibernate.annotations.FlushModeType;\nimport org.hibernate.annotations.HQLSelect;\nimport org.hibernate.annotations.SQLSelect;\nimport org.hibernate.boot.internal.NamedHqlQueryDefinitionImpl;\nimport org.hibernate.boot.internal.NamedProcedureCallDefinitionImpl;\nimport org.hibernate.boot.models.JpaAnnotations;\nimport org.hibernate.boot.models.annotations.internal.NamedStoredProcedureQueryJpaAnnotation;\nimport org.hibernate.boot.models.annotations.internal.QueryHintJpaAnnotation;\nimport org.hibernate.boot.models.annotations.internal.StoredProcedureParameterJpaAnnotation;\nimport org.hibernate.boot.query.NamedHqlQueryDefinition;\nimport org.hibernate.boot.query.NamedNativeQueryDefinition;\nimport org.hibernate.boot.query.NamedProcedureCallDefinition;\nimport org.hibernate.boot.query.SqlResultSetMappingDescriptor;\nimport org.hibernate.boot.registry.classloading.spi.ClassLoaderService;\nimport org.hibernate.boot.spi.MetadataBuildingContext;\nimport org.hibernate.internal.CoreMessageLogger;\nimport org.hibernate.internal.log.DeprecationLogger;\nimport org.hibernate.internal.util.collections.ArrayHelper;\nimport org.hibernate.jpa.HibernateHints;\nimport org.hibernate.models.internal.util.StringHelper;\nimport org.hibernate.models.spi.ClassDetails;\nimport org.hibernate.models.spi.SourceModelBuildingContext;\nimport org.hibernate.query.sql.internal.ParameterParser;\nimport org.hibernate.query.sql.spi.ParameterRecognizer;\nimport org.hibernate.type.BasicType;\n\nimport org.jboss.logging.Logger;\n\nimport jakarta.persistence.CacheRetrieveMode;\nimport jakarta.persistence.CacheStoreMode;\nimport jakarta.persistence.NamedNativeQuery;\nimport jakarta.persistence.NamedQuery;\nimport jakarta.persistence.NamedStoredProcedureQuery;\nimport jakarta.persistence.ParameterMode;\nimport jakarta.persistence.QueryHint;\nimport jakarta.persistence.SqlResultSetMapping;\nimport jakarta.persistence.StoredProcedureParameter;\n\nimport static java.lang.Boolean.TRUE;\nimport static org.hibernate.internal.util.StringHelper.nullIfEmpty;\nimport static org.hibernate.internal.util.collections.CollectionHelper.determineProperSizing;\nimport static org.hibernate.internal.util.collections.CollectionHelper.setOf;\n\n/**\n * Responsible for reading named queries defined in annotations and registering\n * {@link org.hibernate.boot.query.NamedQueryDefinition} objects.\n *\n * @implNote This class is stateless, unlike most of the other \"binders\".\n *\n * @author Emmanuel Bernard\n */\npublic abstract class QueryBinder {\n\tprivate static final CoreMessageLogger LOG = Logger.getMessageLogger( MethodHandles.lookup(), CoreMessageLogger.class, QueryBinder.class.getName() );\n\n\tpublic static void bindQuery(\n\t\t\tNamedQuery namedQuery,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\tif ( namedQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String queryName = namedQuery.name();\n\t\tfinal String queryString = namedQuery.query();\n\n\t\tif ( queryName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named query: %s => %s\", queryName, queryString );\n\t\t}\n\n\t\tfinal QueryHintDefinition hints = new QueryHintDefinition( queryName, namedQuery.hints() );\n\n\t\tfinal NamedHqlQueryDefinition<?> queryMapping = new NamedHqlQueryDefinitionImpl.Builder<>( queryName )\n\t\t\t\t.setHqlString( queryString )\n\t\t\t\t.setResultClass( (Class<Object>) namedQuery.resultClass() )\n\t\t\t\t.setCacheable( hints.getCacheability() )\n\t\t\t\t.setCacheMode( hints.getCacheMode() )\n\t\t\t\t.setCacheRegion( hints.getString( HibernateHints.HINT_CACHE_REGION ) )\n\t\t\t\t.setTimeout( hints.getTimeout() )\n\t\t\t\t.setFetchSize( hints.getInteger( HibernateHints.HINT_FETCH_SIZE ) )\n\t\t\t\t.setFlushMode( hints.getFlushMode() )\n\t\t\t\t.setReadOnly( hints.getBooleanWrapper( HibernateHints.HINT_READ_ONLY ) )\n\t\t\t\t.setLockOptions( hints.determineLockOptions( namedQuery ) )\n\t\t\t\t.setComment( hints.getString( HibernateHints.HINT_COMMENT ) )\n\t\t\t\t.build();\n\n\t\tif ( isDefault ) {\n\t\t\tcontext.getMetadataCollector().addDefaultQuery( queryMapping );\n\t\t}\n\t\telse {\n\t\t\tcontext.getMetadataCollector().addNamedQuery( queryMapping );\n\t\t}\n\t}\n\n\tprivate static Class<Object> loadClass(ClassDetails classDetails, MetadataBuildingContext context) {\n\t\treturn ClassDetails.VOID_CLASS_DETAILS == classDetails\n\t\t\t\t? null\n\t\t\t\t: context.getBootstrapContext()\n\t\t\t\t\t\t.getServiceRegistry()\n\t\t\t\t\t\t.requireService( ClassLoaderService.class )\n\t\t\t\t\t\t.classForName( classDetails.getName() );\n\t}\n\n\tpublic static void bindNativeQuery(\n\t\t\tNamedNativeQuery namedNativeQuery,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\tif ( namedNativeQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String registrationName = namedNativeQuery.name();\n\t\tfinal String queryString = namedNativeQuery.query();\n\n\t\tif ( registrationName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedNativeQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tfinal QueryHintDefinition hints = new QueryHintDefinition( registrationName, namedNativeQuery.hints() );\n\n\t\tfinal String resultSetMappingName = namedNativeQuery.resultSetMapping();\n\t\tfinal Class<?> resultClassDetails = namedNativeQuery.resultClass();\n\t\tfinal Class<Object> resultClass = void.class == resultClassDetails\n\t\t\t\t? null\n\t\t\t\t: (Class<Object>) resultClassDetails;\n\n\t\tfinal NamedNativeQueryDefinition.Builder<?> builder = new NamedNativeQueryDefinition.Builder<>( registrationName )\n\t\t\t\t.setSqlString( queryString )\n\t\t\t\t.setResultClass( resultClass )\n\t\t\t\t.setResultSetMappingName( resultSetMappingName )\n\t\t\t\t.setQuerySpaces( null )\n\t\t\t\t.setCacheable( hints.getCacheability() )\n\t\t\t\t.setCacheMode( hints.getCacheMode() )\n\t\t\t\t.setCacheRegion( hints.getString( HibernateHints.HINT_CACHE_REGION ) )\n\t\t\t\t.setTimeout( hints.getTimeout() )\n\t\t\t\t.setFetchSize( hints.getInteger( HibernateHints.HINT_FETCH_SIZE ) )\n\t\t\t\t.setFlushMode( hints.getFlushMode() )\n\t\t\t\t.setReadOnly( hints.getBooleanWrapper( HibernateHints.HINT_READ_ONLY ) )\n\t\t\t\t.setComment( hints.getString( HibernateHints.HINT_COMMENT ) )\n\t\t\t\t.addHints( hints.getHintsMap() );\n\n\t\tfinal NamedNativeQueryDefinition<?> queryDefinition = builder.build();\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named native query: %s => %s\", queryDefinition.getRegistrationName(), queryDefinition.getSqlQueryString() );\n\t\t}\n\n\t\tif ( isDefault ) {\n\t\t\tcontext.getMetadataCollector().addDefaultNamedNativeQuery( queryDefinition );\n\t\t}\n\t\telse {\n\t\t\tcontext.getMetadataCollector().addNamedNativeQuery( queryDefinition );\n\t\t}\n\t}\n\n\tpublic static void bindNativeQuery(\n\t\t\tString name,\n\t\t\tSQLSelect sqlSelect,\n\t\t\tClassDetails annotatedClass,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal NamedNativeQueryDefinition.Builder<?> builder = new NamedNativeQueryDefinition.Builder<>( name )\n\t\t\t\t.setFlushMode( FlushMode.MANUAL )\n\t\t\t\t.setSqlString( sqlSelect.sql() )\n\t\t\t\t.setQuerySpaces( setOf( sqlSelect.querySpaces() ) );\n\n\t\tif ( annotatedClass != null ) {\n\t\t\tbuilder.setResultClass(\n\t\t\t\t\tcontext.getBootstrapContext().getServiceRegistry().requireService( ClassLoaderService.class )\n\t\t\t\t\t\t\t.classForName( annotatedClass.getClassName() )\n\t\t\t);\n\t\t}\n\n\t\tfinal SqlResultSetMapping resultSetMapping = sqlSelect.resultSetMapping();\n\t\tif ( !ArrayHelper.isEmpty( resultSetMapping.columns() )\n\t\t\t\t|| !ArrayHelper.isEmpty( resultSetMapping.entities() )\n\t\t\t\t|| !ArrayHelper.isEmpty( resultSetMapping.classes() ) ) {\n\t\t\tcontext.getMetadataCollector().addResultSetMapping( SqlResultSetMappingDescriptor.from( resultSetMapping, name ) );\n\t\t\tbuilder.setResultSetMappingName( name );\n\t\t}\n\n\t\tcontext.getMetadataCollector().addNamedNativeQuery( builder.build() );\n\t}\n\n\tpublic static void bindNativeQuery(\n\t\t\torg.hibernate.annotations.NamedNativeQuery namedNativeQuery,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( namedNativeQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String registrationName = namedNativeQuery.name();\n\n\t\t//ResultSetMappingDefinition mappingDefinition = mappings.getJdbcValuesMappingProducer( queryAnn.resultSetMapping() );\n\t\tif ( registrationName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedNativeQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tfinal String resultSetMappingName = namedNativeQuery.resultSetMapping();\n\t\tfinal Class<?> resultClassDetails = namedNativeQuery.resultClass();\n\t\tfinal Class<Object> resultClass = resultClassDetails == void.class\n\t\t\t\t? null\n\t\t\t\t: (Class<Object>) resultClassDetails;\n\n\t\tfinal Integer timeout = namedNativeQuery.timeout();\n\t\tfinal Integer fetchSize = namedNativeQuery.fetchSize();\n\n\t\tfinal String[] querySpacesList = namedNativeQuery.querySpaces();\n\t\tfinal HashSet<String> querySpaces = new HashSet<>( determineProperSizing( querySpacesList.length ) );\n\t\tCollections.addAll( querySpaces, querySpacesList );\n\n\t\tfinal NamedNativeQueryDefinition.Builder<?> builder = new NamedNativeQueryDefinition.Builder<>( registrationName )\n\t\t\t\t.setSqlString( namedNativeQuery.query() )\n\t\t\t\t.setResultSetMappingName( resultSetMappingName )\n\t\t\t\t.setResultClass( resultClass )\n\t\t\t\t.setCacheable( namedNativeQuery.cacheable() )\n\t\t\t\t.setCacheRegion( nullIfEmpty( namedNativeQuery.cacheRegion() ) )\n\t\t\t\t.setCacheMode( getCacheMode( namedNativeQuery.cacheRetrieveMode(), namedNativeQuery.cacheStoreMode() ) )\n\t\t\t\t.setTimeout( timeout < 0 ? null : timeout )\n\t\t\t\t.setFetchSize( fetchSize < 0 ? null : fetchSize )\n\t\t\t\t.setFlushMode( getFlushMode( namedNativeQuery.flushMode() ) )\n\t\t\t\t.setReadOnly( namedNativeQuery.readOnly() )\n\t\t\t\t.setQuerySpaces( querySpaces )\n\t\t\t\t.setComment( nullIfEmpty( namedNativeQuery.comment() ) );\n\n\t\tif ( TRUE == namedNativeQuery.callable() ) {\n\t\t\tfinal NamedProcedureCallDefinition definition =\n\t\t\t\t\tcreateStoredProcedure( builder, context, () -> illegalCallSyntax( namedNativeQuery ) );\n\t\t\tcontext.getMetadataCollector().addNamedProcedureCallDefinition( definition );\n\t\t\tDeprecationLogger.DEPRECATION_LOGGER.warn(\n\t\t\t\t\t\"Marking named native queries as callable is no longer supported; use '@jakarta.persistence.NamedStoredProcedureQuery' instead. Ignoring.\"\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tfinal NamedNativeQueryDefinition<?> queryDefinition = builder.build();\n\n\t\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\t\tLOG.debugf(\n\t\t\t\t\t\t\"Binding named native query: %s => %s\",\n\t\t\t\t\t\tqueryDefinition.getRegistrationName(),\n\t\t\t\t\t\tqueryDefinition.getSqlQueryString()\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tcontext.getMetadataCollector().addNamedNativeQuery( queryDefinition );\n\t\t}\n\t}\n\n\t/**\n\t * Handles legacy cases where a named native query was used to specify a procedure call\n\t *\n\t * @deprecated User should use {@linkplain NamedStoredProcedureQuery} instead\n\t */\n\t@Deprecated\n\tpublic static NamedProcedureCallDefinition createStoredProcedure(\n\t\t\tNamedNativeQueryDefinition.Builder<?> builder,\n\t\t\tMetadataBuildingContext context,\n\t\t\tSupplier<RuntimeException> exceptionProducer) {\n\t\tfinal String sqlString = builder.getSqlString().trim();\n\t\tif ( !sqlString.startsWith( \"{\" ) || !sqlString.endsWith( \"}\" ) ) {\n\t\t\tthrow exceptionProducer.get();\n\t\t}\n\t\tfinal JdbcCall jdbcCall = parseJdbcCall( sqlString, exceptionProducer );\n\n\t\tfinal SourceModelBuildingContext sourceModelBuildingContext = context.getMetadataCollector()\n\t\t\t\t.getSourceModelBuildingContext();\n\t\tfinal NamedStoredProcedureQueryJpaAnnotation nameStoredProcedureQueryAnn = JpaAnnotations.NAMED_STORED_PROCEDURE_QUERY.createUsage( sourceModelBuildingContext );\n\t\tnameStoredProcedureQueryAnn.name( builder.getName() );\n\t\tnameStoredProcedureQueryAnn.procedureName( jdbcCall.callableName );\n\n\t\tfinal StoredProcedureParameter[] parameters = new StoredProcedureParameter[jdbcCall.parameters.size()];\n\t\tnameStoredProcedureQueryAnn.parameters( parameters );\n\n\t\tfor ( int i = 0; i < jdbcCall.parameters.size(); i++ ) {\n\t\t\tfinal StoredProcedureParameterJpaAnnotation param = JpaAnnotations.STORED_PROCEDURE_PARAMETER.createUsage( sourceModelBuildingContext );\n\t\t\tparameters[i] = param;\n\n\t\t\tfinal String paramName = jdbcCall.parameters.get( i );\n\t\t\tparam.name( paramName );\n\t\t\tparam.mode( ParameterMode.IN );\n\n\t\t\tfinal String typeName = builder.getParameterTypes().get( paramName );\n\t\t\tfinal ClassDetails classDetails;\n\t\t\tif ( StringHelper.isEmpty( typeName ) ) {\n\t\t\t\tclassDetails = ClassDetails.VOID_CLASS_DETAILS;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfinal BasicType<Object> registeredType = context.getBootstrapContext()\n\t\t\t\t\t\t.getTypeConfiguration()\n\t\t\t\t\t\t.getBasicTypeRegistry()\n\t\t\t\t\t\t.getRegisteredType( typeName );\n\t\t\t\tclassDetails = context.getMetadataCollector().getClassDetailsRegistry().getClassDetails( registeredType.getJavaType().getName() );\n\t\t\t}\n\t\t\tparam.type( classDetails.toJavaClass() );\n\t\t}\n\n\t\tif ( builder.getResultSetMappingName() != null ) {\n\t\t\tnameStoredProcedureQueryAnn.resultSetMappings( new String[] { builder.getResultSetMappingName() } );\n\t\t}\n\n\t\tfinal Class<?> resultClass = builder.getResultClass();\n\t\tif ( resultClass != null ) {\n\t\t\tnameStoredProcedureQueryAnn.resultClasses( new Class[]{ builder.getResultClass() } );\n\t\t}\n\n\t\tfinal List<QueryHintJpaAnnotation> hints = new ArrayList<>();\n\n\t\tif ( builder.getQuerySpaces() != null ) {\n\t\t\tfinal QueryHintJpaAnnotation hint = JpaAnnotations.QUERY_HINT.createUsage( sourceModelBuildingContext );\n\t\t\thint.name( HibernateHints.HINT_NATIVE_SPACES );\n\t\t\thint.value( String.join( \" \", builder.getQuerySpaces() ) );\n\t\t\thints.add( hint );\n\t\t}\n\n\t\tif ( jdbcCall.resultParameter ) {\n\t\t\t// Mark native queries that have a result parameter as callable functions\n\t\t\tfinal QueryHintJpaAnnotation hint = JpaAnnotations.QUERY_HINT.createUsage( sourceModelBuildingContext );\n\t\t\thint.name( HibernateHints.HINT_CALLABLE_FUNCTION );\n\t\t\thint.value( \"true\" );\n\t\t\thints.add( hint );\n\t\t}\n\n\t\tnameStoredProcedureQueryAnn.hints( hints.toArray(QueryHint[]::new) );\n\n\t\treturn new NamedProcedureCallDefinitionImpl( nameStoredProcedureQueryAnn );\n\t}\n\n\tpublic static void bindQuery(\n\t\t\tString name,\n\t\t\tHQLSelect hqlSelect,\n\t\t\tMetadataBuildingContext context) {\n\t\tfinal NamedHqlQueryDefinition<?> hqlQueryDefinition = new NamedHqlQueryDefinition.Builder<>( name )\n\t\t\t\t.setFlushMode( FlushMode.MANUAL )\n\t\t\t\t.setHqlString( hqlSelect.query() )\n\t\t\t\t.build();\n\n\t\tcontext.getMetadataCollector().addNamedQuery( hqlQueryDefinition );\n\t}\n\n\tpublic static void bindQuery(\n\t\t\torg.hibernate.annotations.NamedQuery namedQuery,\n\t\t\tMetadataBuildingContext context) {\n\t\tif ( namedQuery == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String registrationName = namedQuery.name();\n\n\t\t//ResultSetMappingDefinition mappingDefinition = mappings.getJdbcValuesMappingProducer( namedQuery.resultSetMapping() );\n\t\tif ( registrationName.isEmpty() ) {\n\t\t\tthrow new AnnotationException( \"Class or package level '@NamedQuery' annotation must specify a 'name'\" );\n\t\t}\n\n\t\tfinal int timeout = namedQuery.timeout();\n\t\tfinal int fetchSize = namedQuery.fetchSize();\n\n\t\tfinal NamedHqlQueryDefinition.Builder<?> builder = new NamedHqlQueryDefinition.Builder<>( registrationName )\n\t\t\t\t.setHqlString( namedQuery.query() )\n\t\t\t\t.setResultClass( (Class<Object>) namedQuery.resultClass() )\n\t\t\t\t.setCacheable( namedQuery.cacheable() )\n\t\t\t\t.setCacheRegion( nullIfEmpty( namedQuery.cacheRegion() ) )\n\t\t\t\t.setCacheMode( getCacheMode( namedQuery.cacheRetrieveMode(), namedQuery.cacheStoreMode() ) )\n\t\t\t\t.setTimeout( timeout < 0 ? null : timeout )\n\t\t\t\t.setFetchSize( fetchSize < 0 ? null : fetchSize )\n\t\t\t\t.setFlushMode( getFlushMode( namedQuery.flushMode() ) )\n\t\t\t\t.setReadOnly( namedQuery.readOnly() )\n\t\t\t\t.setComment( nullIfEmpty( namedQuery.comment() ) );\n\n\t\tfinal NamedHqlQueryDefinitionImpl<?> hqlQueryDefinition = builder.build();\n\n\t\tif ( LOG.isDebugEnabled() ) {\n\t\t\tLOG.debugf( \"Binding named query: %s => %s\", hqlQueryDefinition.getRegistrationName(), hqlQueryDefinition.getHqlString() );\n\t\t}\n\n\t\tcontext.getMetadataCollector().addNamedQuery( hqlQueryDefinition );\n\t}\n\n\tprivate static CacheMode getCacheMode(CacheRetrieveMode cacheRetrieveMode, CacheStoreMode cacheStoreMode) {\n\t\tfinal CacheMode cacheMode = CacheMode.fromJpaModes( cacheRetrieveMode, cacheStoreMode );\n\t\treturn cacheMode == null ? CacheMode.NORMAL : cacheMode;\n\t}\n\n\tprivate static FlushMode getFlushMode(FlushModeType flushModeType) {\n\t\treturn switch ( flushModeType ) {\n\t\t\tcase ALWAYS -> FlushMode.ALWAYS;\n\t\t\tcase AUTO -> FlushMode.AUTO;\n\t\t\tcase COMMIT -> FlushMode.COMMIT;\n\t\t\tcase MANUAL -> FlushMode.MANUAL;\n\t\t\tcase PERSISTENCE_CONTEXT -> null;\n\t\t};\n\t}\n\n\tpublic static void bindNamedStoredProcedureQuery(\n\t\t\tNamedStoredProcedureQuery namedStoredProcedureQuery,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\tif ( namedStoredProcedureQuery != null ) {\n\t\t\tif ( namedStoredProcedureQuery.name().isEmpty() ) {\n\t\t\t\tthrow new AnnotationException( \"Class or package level '@NamedStoredProcedureQuery' annotation must specify a 'name'\" );\n\t\t\t}\n\n\t\t\tfinal NamedProcedureCallDefinitionImpl definition = new NamedProcedureCallDefinitionImpl( namedStoredProcedureQuery );\n\t\t\tif ( isDefault ) {\n\t\t\t\tcontext.getMetadataCollector().addDefaultNamedProcedureCall( definition );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcontext.getMetadataCollector().addNamedProcedureCallDefinition( definition );\n\t\t\t}\n\t\t\tLOG.debugf( \"Bound named stored procedure query : %s => %s\", definition.getRegistrationName(), definition.getProcedureName() );\n\t\t}\n\t}\n\n\tpublic static void bindSqlResultSetMapping(\n\t\t\tSqlResultSetMapping resultSetMappingAnn,\n\t\t\tMetadataBuildingContext context,\n\t\t\tboolean isDefault) {\n\t\t//no need to handle inSecondPass\n\t\tcontext.getMetadataCollector().addSecondPass( new ResultSetMappingSecondPass( resultSetMappingAnn, context, isDefault ) );\n\t}\n\n\tprivate static class JdbcCall {\n\t\tprivate final String callableName;\n\t\tprivate final boolean resultParameter;\n\t\tprivate final ArrayList<String> parameters;\n\n\t\tpublic JdbcCall(String callableName, boolean resultParameter, ArrayList<String> parameters) {\n\t\t\tthis.callableName = callableName;\n\t\t\tthis.resultParameter = resultParameter;\n\t\t\tthis.parameters = parameters;\n\t\t}\n\t}\n\n\tprivate static JdbcCall parseJdbcCall(String sqlString, Supplier<RuntimeException> exceptionProducer) {\n\t\tString callableName = null;\n\t\tboolean resultParameter = false;\n\t\tint index = skipWhitespace( sqlString, 1 );\n\t\t// Parse the out param `?=` part\n\t\tif ( sqlString.charAt( index ) == '?' ) {\n\t\t\tresultParameter = true;\n\t\t\tindex++;\n\t\t\tindex = skipWhitespace( sqlString, index );\n\t\t\tif ( sqlString.charAt( index ) != '=' ) {\n\t\t\t\tthrow exceptionProducer.get();\n\t\t\t}\n\t\t\tindex++;\n\t\t\tindex = skipWhitespace( sqlString, index );\n\t\t}\n\t\t// Parse the call keyword\n\t\tif ( !sqlString.regionMatches( true, index, \"call\", 0, 4 ) ) {\n\t\t\tthrow exceptionProducer.get();\n\t\t}\n\t\tindex += 4;\n\t\tindex = skipWhitespace( sqlString, index );\n\n\t\t// Parse the procedure name\n\t\tfinal int procedureStart = index;\n\t\tfor ( ; index < sqlString.length(); index++ ) {\n\t\t\tfinal char c = sqlString.charAt( index );\n\t\t\tif ( c == '(' || Character.isWhitespace( c ) ) {\n\t\t\t\tcallableName = sqlString.substring( procedureStart, index );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tindex = skipWhitespace( sqlString, index );\n\t\tfinal ArrayList<String> parameters = new ArrayList<>();\n\t\tParameterParser.parse(\n\t\t\t\tsqlString.substring( index, sqlString.length() - 1 ),\n\t\t\t\tnew ParameterRecognizer() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void ordinalParameter(int sourcePosition) {\n\t\t\t\t\t\tparameters.add( \"\" );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void namedParameter(String name, int sourcePosition) {\n\t\t\t\t\t\tparameters.add( name );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void jpaPositionalParameter(int label, int sourcePosition) {\n\t\t\t\t\t\tparameters.add( \"\" );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void other(char character) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\treturn new JdbcCall( callableName, resultParameter, parameters );\n\t}\n\n\tprivate static int skipWhitespace(String sqlString, int i) {\n\t\twhile ( i < sqlString.length() ) {\n\t\t\tif ( !Character.isWhitespace( sqlString.charAt( i ) ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn i;\n\t}\n\n\tprivate static AnnotationException illegalCallSyntax(org.hibernate.annotations.NamedNativeQuery queryAnn) {\n\t\treturn new AnnotationException( \"Callable 'NamedNativeQuery' named '\" + queryAnn.name()\n\t\t\t\t+ \"' does not use the JDBC call syntax\" );\n\t}\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate getCompositeCascadeStyle(compositeType ComponentType, cascade String) : CascadeStyle extracted from private getCompositeCascadeStyle(compositeType CompositeType, cascade String) : CascadeStyle in class org.hibernate.mapping.Property",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/mapping/Property.java",
                "startLine": 151,
                "endLine": 162,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/mapping/Property.java",
                "startLine": 157,
                "endLine": 164,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/mapping/Property.java",
                "startLine": 166,
                "endLine": 174,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private static CascadeStyle getCompositeCascadeStyle(CompositeType compositeType, String cascade) {\n\t\tif ( compositeType.isAnyType() ) {\n\t\t\treturn getCascadeStyle( cascade );\n\t\t}\n\t\tfinal int length = compositeType.getSubtypes().length;\n\t\tfor ( int i=0; i<length; i++ ) {\n\t\t\tif ( compositeType.getCascadeStyle(i) != CascadeStyles.NONE ) {\n\t\t\t\treturn CascadeStyles.ALL;\n\t\t\t}\n\t\t}\n\t\treturn getCascadeStyle( cascade );\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/mapping/Property.java",
        "isPureRefactoring": true,
        "commitId": "94b444b4d8e0ac7ec5817642ca711f626ee327f3",
        "packageNameBefore": "org.hibernate.mapping",
        "classNameBefore": "org.hibernate.mapping.Property",
        "methodNameBefore": "org.hibernate.mapping.Property#getCompositeCascadeStyle",
        "invokedMethod": "methodSignature: org.hibernate.type.AbstractType#isAnyType\n methodBody: public boolean isAnyType() {\nreturn false;\n}\nmethodSignature: org.hibernate.mapping.Property#getCascadeStyle\n methodBody: private static CascadeStyle getCascadeStyle(String cascade) {\nif(cascade == null || cascade.equals(\"none\")){return CascadeStyles.NONE;\n}{final StringTokenizer tokens=new StringTokenizer(cascade,\", \");\nfinal CascadeStyle[] styles=new CascadeStyle[tokens.countTokens()];\nint i=0;\nwhile(tokens.hasMoreTokens()){styles[i++]=CascadeStyles.getCascadeStyle(tokens.nextToken());\n}return new CascadeStyles.MultipleCascadeStyle(styles);\n}}",
        "classSignatureBefore": "public class Property implements Serializable, MetaAttributable ",
        "methodNameBeforeSet": [
            "org.hibernate.mapping.Property#getCompositeCascadeStyle"
        ],
        "classNameBeforeSet": [
            "org.hibernate.mapping.Property"
        ],
        "classSignatureBeforeSet": [
            "public class Property implements Serializable, MetaAttributable "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.mapping;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.StringTokenizer;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.Internal;\nimport org.hibernate.MappingException;\nimport org.hibernate.boot.model.relational.Database;\nimport org.hibernate.bytecode.enhance.spi.interceptor.EnhancementHelper;\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.engine.spi.CascadeStyle;\nimport org.hibernate.engine.spi.CascadeStyles;\nimport org.hibernate.engine.spi.Mapping;\nimport org.hibernate.jpa.event.spi.CallbackDefinition;\nimport org.hibernate.metamodel.RepresentationMode;\nimport org.hibernate.metamodel.spi.RuntimeModelCreationContext;\nimport org.hibernate.property.access.spi.Getter;\nimport org.hibernate.property.access.spi.PropertyAccessStrategy;\nimport org.hibernate.property.access.spi.PropertyAccessStrategyResolver;\nimport org.hibernate.property.access.spi.Setter;\nimport org.hibernate.service.ServiceRegistry;\nimport org.hibernate.generator.Generator;\nimport org.hibernate.generator.GeneratorCreationContext;\nimport org.hibernate.type.CompositeType;\nimport org.hibernate.type.Type;\nimport org.hibernate.type.WrapperArrayHandling;\n\nimport static java.util.Collections.emptyList;\nimport static java.util.Collections.unmodifiableList;\n\n/**\n * A mapping model object representing a property or field of an {@linkplain PersistentClass entity}\n * or {@linkplain Component embeddable class}.\n *\n * @author Gavin King\n */\npublic class Property implements Serializable, MetaAttributable {\n\tprivate String name;\n\tprivate Value value;\n\tprivate String cascade;\n\tprivate boolean updateable = true;\n\tprivate boolean insertable = true;\n\tprivate boolean selectable = true;\n\tprivate boolean optimisticLocked = true;\n\tprivate GeneratorCreator generatorCreator;\n\tprivate String propertyAccessorName;\n\tprivate PropertyAccessStrategy propertyAccessStrategy;\n\tprivate boolean lazy;\n\tprivate String lazyGroup;\n\tprivate boolean optional;\n\tprivate java.util.Map<String,MetaAttribute> metaAttributes;\n\tprivate PersistentClass persistentClass;\n\tprivate boolean naturalIdentifier;\n\tprivate boolean isGeneric;\n\tprivate boolean lob;\n\tprivate java.util.List<CallbackDefinition> callbackDefinitions;\n\tprivate String returnedClassName;\n\n\tpublic boolean isBackRef() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Does this property represent a synthetic property?  A synthetic property is one we create during\n\t * metamodel binding to represent a collection of columns but which does not represent a property\n\t * physically available on the entity.\n\t *\n\t * @return True if synthetic; false otherwise.\n\t */\n\tpublic boolean isSynthetic() {\n\t\treturn false;\n\t}\n\n\tpublic Type getType() throws MappingException {\n\t\treturn value.getType();\n\t}\n\t\n\tpublic int getColumnSpan() {\n\t\treturn value.getColumnSpan();\n\t}\n\n\t/**\n\t * Delegates to {@link Value#getSelectables()}.\n\t */\n\tpublic java.util.List<Selectable> getSelectables() {\n\t\treturn value.getSelectables();\n\t}\n\n\t/**\n\t * Delegates to {@link Value#getColumns()}.\n\t *\n\t * @throws org.hibernate.AssertionFailure if the mapping involves formulas\n\t */\n\tpublic java.util.List<Column> getColumns() {\n\t\treturn value.getColumns();\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic boolean isComposite() {\n\t\treturn value instanceof Component;\n\t}\n\n\tpublic Value getValue() {\n\t\treturn value;\n\t}\n\n\tpublic void resetUpdateable(boolean updateable) {\n\t\tsetUpdateable( updateable );\n\t\tboolean[] columnUpdateability = getValue().getColumnUpdateability();\n\t\tfor (int i=0; i<getColumnSpan(); i++ ) {\n\t\t\tcolumnUpdateability[i] = updateable;\n\t\t}\n\t}\n\n\tpublic void resetOptional(boolean optional) {\n\t\tsetOptional( optional );\n\t\tfor ( Selectable selectable: getValue().getSelectables() ) {\n\t\t\tif (selectable instanceof Column) {\n\t\t\t\tfinal Column column = (Column) selectable;\n\t\t\t\tcolumn.setNullable( optional );\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic CascadeStyle getCascadeStyle() throws MappingException {\n\t\tfinal Type type = value.getType();\n\t\tif ( type.isComponentType() ) {\n\t\t\treturn getCompositeCascadeStyle( (CompositeType) type, cascade );\n\t\t}\n\t\telse if ( type.isCollectionType() ) {\n\t\t\tfinal Collection collection = (Collection) value;\n\t\t\treturn getCollectionCascadeStyle( collection.getElement().getType(), cascade );\n\t\t}\n\t\telse {\n\t\t\treturn getCascadeStyle( cascade );\t\t\t\n\t\t}\n\t}\n\n\tprivate static CascadeStyle getCompositeCascadeStyle(CompositeType compositeType, String cascade) {\n\t\tif ( compositeType.isAnyType() ) {\n\t\t\treturn getCascadeStyle( cascade );\n\t\t}\n\t\tfinal int length = compositeType.getSubtypes().length;\n\t\tfor ( int i=0; i<length; i++ ) {\n\t\t\tif ( compositeType.getCascadeStyle(i) != CascadeStyles.NONE ) {\n\t\t\t\treturn CascadeStyles.ALL;\n\t\t\t}\n\t\t}\n\t\treturn getCascadeStyle( cascade );\n\t}\n\n\tprivate static CascadeStyle getCollectionCascadeStyle(Type elementType, String cascade) {\n\t\treturn elementType.isComponentType()\n\t\t\t\t? getCompositeCascadeStyle( (CompositeType) elementType, cascade )\n\t\t\t\t: getCascadeStyle( cascade );\n\t}\n\t\n\tprivate static CascadeStyle getCascadeStyle(String cascade) {\n\t\tif ( cascade==null || cascade.equals(\"none\") ) {\n\t\t\treturn CascadeStyles.NONE;\n\t\t}\n\t\telse {\n\t\t\tfinal StringTokenizer tokens = new StringTokenizer(cascade, \", \");\n\t\t\tfinal CascadeStyle[] styles = new CascadeStyle[ tokens.countTokens() ] ;\n\t\t\tint i=0;\n\t\t\twhile ( tokens.hasMoreTokens() ) {\n\t\t\t\tstyles[i++] = CascadeStyles.getCascadeStyle( tokens.nextToken() );\n\t\t\t}\n\t\t\treturn new CascadeStyles.MultipleCascadeStyle(styles);\n\t\t}\t\t\n\t}\n\t\n\tpublic String getCascade() {\n\t\treturn cascade;\n\t}\n\n\tpublic void setCascade(String cascade) {\n\t\tthis.cascade = cascade;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name==null ? null : name.intern();\n\t}\n\n\tpublic void setValue(Value value) {\n\t\tthis.value = value;\n\t}\n\n\tpublic boolean isUpdateable() {\n\t\t// if the property mapping consists of all formulas,\n\t\t// make it non-updatable\n\t\treturn updateable && value.hasAnyUpdatableColumns();\n\t}\n\n\tpublic boolean isInsertable() {\n\t\t// if the property mapping consists of all formulas, \n\t\t// make it non-insertable\n\t\treturn insertable && value.hasAnyInsertableColumns();\n\t}\n\n\t@Internal\n\tpublic GeneratorCreator getValueGeneratorCreator() {\n\t\treturn generatorCreator;\n\t}\n\n\t@Internal\n\tpublic void setValueGeneratorCreator(GeneratorCreator generator) {\n\t\tthis.generatorCreator = generator;\n\t}\n\n\tpublic void setUpdateable(boolean mutable) {\n\t\tthis.updateable = mutable;\n\t}\n\n\tpublic void setInsertable(boolean insertable) {\n\t\tthis.insertable = insertable;\n\t}\n\n\tpublic String getPropertyAccessorName() {\n\t\treturn propertyAccessorName;\n\t}\n\n\tpublic void setPropertyAccessorName(String string) {\n\t\tpropertyAccessorName = string;\n\t}\n\n\tpublic PropertyAccessStrategy getPropertyAccessStrategy() {\n\t\treturn propertyAccessStrategy;\n\t}\n\n\tpublic void setPropertyAccessStrategy(PropertyAccessStrategy propertyAccessStrategy) {\n\t\tthis.propertyAccessStrategy = propertyAccessStrategy;\n\t}\n\n\tpublic boolean isBasicPropertyAccessor() {\n\t\treturn propertyAccessorName==null || \"property\".equals( propertyAccessorName );\n\t}\n\n\tpublic Map<String, MetaAttribute> getMetaAttributes() {\n\t\treturn metaAttributes;\n\t}\n\n\tpublic MetaAttribute getMetaAttribute(String attributeName) {\n\t\treturn metaAttributes==null ? null : metaAttributes.get(attributeName);\n\t}\n\n\tpublic void setMetaAttributes(Map<String, MetaAttribute> metas) {\n\t\tthis.metaAttributes = metas;\n\t}\n\n\tpublic boolean isValid(Mapping mapping) throws MappingException {\n\t\tfinal Value value = getValue();\n\t\tif ( value instanceof BasicValue && ( (BasicValue) value ).isDisallowedWrapperArray() ) {\n\t\t\tthrow new MappingException(\n\t\t\t\t\t\"The property \" + persistentClass.getEntityName() + \"#\" + name +\n\t\t\t\t\t\t\t\" uses a wrapper type Byte[]/Character[] which indicates an issue in your domain model. \" +\n\t\t\t\t\t\t\t\"These types have been treated like byte[]/char[] until Hibernate 6.2 which meant that \" +\n\t\t\t\t\t\t\t\"null elements were not allowed, but on JDBC were processed like VARBINARY or VARCHAR. \" +\n\t\t\t\t\t\t\t\"If you don't use nulls in your arrays, change the type of the property to byte[]/char[]. \" +\n\t\t\t\t\t\t\t\"To allow explicit uses of the wrapper types Byte[]/Character[] which allows null element \" +\n\t\t\t\t\t\t\t\"but has a different serialization format than before Hibernate 6.2, configure the \" +\n\t\t\t\t\t\t\t\"setting \" + AvailableSettings.WRAPPER_ARRAY_HANDLING + \" to the value \" + WrapperArrayHandling.ALLOW + \". \" +\n\t\t\t\t\t\t\t\"To revert to the legacy treatment of these types, configure the value to \" + WrapperArrayHandling.LEGACY + \". \" +\n\t\t\t\t\t\t\t\"For more information on this matter, consult the migration guide of Hibernate 6.2 \" +\n\t\t\t\t\t\t\t\"and the Javadoc of the org.hibernate.cfg.AvailableSettings.WRAPPER_ARRAY_HANDLING field.\"\n\t\t\t);\n\t\t}\n\t\treturn value.isValid( mapping );\n\t}\n\n\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + '(' + name + ')';\n\t}\n\t\n\tpublic void setLazy(boolean lazy) {\n\t\tthis.lazy=lazy;\n\t}\n\n\t/**\n\t * Is this property lazy in the \"bytecode\" sense?\n\t * <p>\n\t * Lazy here means whether we initialize this field of the entity\n\t * instance in its \"base fetch group\". It affects whether we list\n\t * this property's columns in the SQL select for the owning entity\n\t * when we load its \"base fetch group\". The actual value that is set\n\t * varies based on the nature (basic, etc) of the property.\n\t *\n\t * @apiNote This method reports whether the property is considered\n\t * part of the base fetch group based solely on the information in\n\t * the mapping but {@link EnhancementHelper#includeInBaseFetchGroup}\n\t * is also accounts for other details.\n\t */\n\tpublic boolean isLazy() {\n\t\tif ( value instanceof ToOne ) {\n\t\t\t// For a many-to-one, this is always false. Whether the\n\t\t\t// association is EAGER, PROXY or NO-PROXY we always want\n\t\t\t// to select the foreign key\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\treturn lazy;\n\t\t}\n\t}\n\n\tpublic String getLazyGroup() {\n\t\treturn lazyGroup;\n\t}\n\n\tpublic void setLazyGroup(String lazyGroup) {\n\t\tthis.lazyGroup = lazyGroup;\n\t}\n\n\tpublic boolean isOptimisticLocked() {\n\t\treturn optimisticLocked;\n\t}\n\n\tpublic void setOptimisticLocked(boolean optimisticLocked) {\n\t\tthis.optimisticLocked = optimisticLocked;\n\t}\n\t\n\tpublic boolean isOptional() {\n\t\treturn optional;\n\t}\n\t\n\tpublic void setOptional(boolean optional) {\n\t\tthis.optional = optional;\n\t}\n\n\tpublic PersistentClass getPersistentClass() {\n\t\treturn persistentClass;\n\t}\n\n\tpublic void setPersistentClass(PersistentClass persistentClass) {\n\t\tthis.persistentClass = persistentClass;\n\t}\n\n\tpublic boolean isSelectable() {\n\t\treturn selectable;\n\t}\n\t\n\tpublic void setSelectable(boolean selectable) {\n\t\tthis.selectable = selectable;\n\t}\n\n\t// todo : remove\n\t@Internal\n\tpublic Getter getGetter(Class clazz) throws MappingException {\n\t\treturn getPropertyAccessStrategy( clazz ).buildPropertyAccess( clazz, name, true ).getGetter();\n\t}\n\n\t// todo : remove\n\t@Internal\n\tpublic Setter getSetter(Class clazz) throws MappingException {\n\t\treturn getPropertyAccessStrategy( clazz ).buildPropertyAccess( clazz, name, true ).getSetter();\n\t}\n\n\t// todo : remove\n\t@Internal\n\tpublic PropertyAccessStrategy getPropertyAccessStrategy(Class clazz) throws MappingException {\n\t\tfinal PropertyAccessStrategy propertyAccessStrategy = getPropertyAccessStrategy();\n\t\tif ( propertyAccessStrategy != null ) {\n\t\t\treturn propertyAccessStrategy;\n\t\t}\n\t\tString accessName = getPropertyAccessorName();\n\t\tif ( accessName == null ) {\n\t\t\tif ( clazz == null || java.util.Map.class.equals( clazz ) ) {\n\t\t\t\taccessName = \"map\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\taccessName = \"property\";\n\t\t\t}\n\t\t}\n\n\t\tfinal RepresentationMode representationMode = clazz == null || java.util.Map.class.equals( clazz )\n\t\t\t\t? RepresentationMode.MAP\n\t\t\t\t: RepresentationMode.POJO;\n\n\t\treturn resolveServiceRegistry()\n\t\t\t\t.requireService( PropertyAccessStrategyResolver.class )\n\t\t\t\t.resolvePropertyAccessStrategy( clazz, accessName, representationMode );\n\t}\n\n\tServiceRegistry resolveServiceRegistry() {\n\t\tif ( getPersistentClass() != null ) {\n\t\t\treturn getPersistentClass().getServiceRegistry();\n\t\t}\n\t\tif ( getValue() != null ) {\n\t\t\treturn getValue().getServiceRegistry();\n\t\t}\n\t\tthrow new HibernateException( \"Could not resolve ServiceRegistry\" );\n\t}\n\n\tpublic boolean isNaturalIdentifier() {\n\t\treturn naturalIdentifier;\n\t}\n\n\tpublic void setNaturalIdentifier(boolean naturalIdentifier) {\n\t\tthis.naturalIdentifier = naturalIdentifier;\n\t}\n\n\tpublic boolean isGeneric() {\n\t\treturn isGeneric;\n\t}\n\n\tpublic void setGeneric(boolean generic) {\n\t\tthis.isGeneric = generic;\n\t}\n\n\tpublic boolean isLob() {\n\t\treturn lob;\n\t}\n\n\tpublic void setLob(boolean lob) {\n\t\tthis.lob = lob;\n\t}\n\n\tpublic void addCallbackDefinitions(java.util.List<CallbackDefinition> callbackDefinitions) {\n\t\tif ( callbackDefinitions != null && !callbackDefinitions.isEmpty() ) {\n\t\t\tif ( this.callbackDefinitions == null ) {\n\t\t\t\tthis.callbackDefinitions = new ArrayList<>();\n\t\t\t}\n\t\t\tthis.callbackDefinitions.addAll( callbackDefinitions );\n\t\t}\n\t}\n\n\tpublic java.util.List<CallbackDefinition> getCallbackDefinitions() {\n\t\treturn callbackDefinitions == null ? emptyList() : unmodifiableList( callbackDefinitions );\n\t}\n\n\tpublic String getReturnedClassName() {\n\t\treturn returnedClassName;\n\t}\n\n\tpublic void setReturnedClassName(String returnedClassName) {\n\t\tthis.returnedClassName = returnedClassName;\n\t}\n\n\tpublic Generator createGenerator(RuntimeModelCreationContext context) {\n\t\treturn generatorCreator == null ? null :\n\t\t\t\tgeneratorCreator.createGenerator( new PropertyGeneratorCreationContext( context ) );\n\t}\n\n\tpublic Property copy() {\n\t\tfinal Property property = new Property();\n\t\tproperty.setName( getName() );\n\t\tproperty.setValue( getValue() );\n\t\tproperty.setCascade( getCascade() );\n\t\tproperty.setUpdateable( isUpdateable() );\n\t\tproperty.setInsertable( isInsertable() );\n\t\tproperty.setSelectable( isSelectable() );\n\t\tproperty.setOptimisticLocked( isOptimisticLocked() );\n\t\tproperty.setValueGeneratorCreator( getValueGeneratorCreator() );\n\t\tproperty.setPropertyAccessorName( getPropertyAccessorName() );\n\t\tproperty.setPropertyAccessStrategy( getPropertyAccessStrategy() );\n\t\tproperty.setLazy( isLazy() );\n\t\tproperty.setLazyGroup( getLazyGroup() );\n\t\tproperty.setOptional( isOptional() );\n\t\tproperty.setMetaAttributes( getMetaAttributes() );\n\t\tproperty.setPersistentClass( getPersistentClass() );\n\t\tproperty.setNaturalIdentifier( isNaturalIdentifier() );\n\t\tproperty.setGeneric( isGeneric() );\n\t\tproperty.setLob( isLob() );\n\t\tproperty.addCallbackDefinitions( getCallbackDefinitions() );\n\t\tproperty.setReturnedClassName( getReturnedClassName() );\n\t\treturn property;\n\t}\n\n\tprivate class PropertyGeneratorCreationContext implements GeneratorCreationContext {\n\t\tprivate final RuntimeModelCreationContext context;\n\n\t\tpublic PropertyGeneratorCreationContext(RuntimeModelCreationContext context) {\n\t\t\tthis.context = context;\n\t\t}\n\n\t\t@Override\n\t\tpublic Database getDatabase() {\n\t\t\treturn context.getMetadata().getDatabase();\n\t\t}\n\n\t\t@Override\n\t\tpublic ServiceRegistry getServiceRegistry() {\n\t\t\treturn context.getBootstrapContext().getServiceRegistry();\n\t\t}\n\n\t\t@Override\n\t\tpublic String getDefaultCatalog() {\n\t\t\treturn context.getSessionFactoryOptions().getDefaultCatalog();\n\t\t}\n\n\t\t@Override\n\t\tpublic String getDefaultSchema() {\n\t\t\treturn context.getSessionFactoryOptions().getDefaultSchema();\n\t\t}\n\n\t\t@Override\n\t\tpublic PersistentClass getPersistentClass() {\n\t\t\treturn persistentClass;\n\t\t}\n\n\t\t@Override\n\t\tpublic RootClass getRootClass() {\n\t\t\treturn persistentClass.getRootClass();\n\t\t}\n\n\t\t@Override\n\t\tpublic Property getProperty() {\n\t\t\treturn Property.this;\n\t\t}\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/mapping/Property.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.mapping;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.StringTokenizer;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.Internal;\nimport org.hibernate.MappingException;\nimport org.hibernate.boot.model.relational.Database;\nimport org.hibernate.bytecode.enhance.spi.interceptor.EnhancementHelper;\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.engine.spi.CascadeStyle;\nimport org.hibernate.engine.spi.CascadeStyles;\nimport org.hibernate.engine.spi.Mapping;\nimport org.hibernate.jpa.event.spi.CallbackDefinition;\nimport org.hibernate.metamodel.RepresentationMode;\nimport org.hibernate.metamodel.spi.RuntimeModelCreationContext;\nimport org.hibernate.property.access.spi.Getter;\nimport org.hibernate.property.access.spi.PropertyAccessStrategy;\nimport org.hibernate.property.access.spi.PropertyAccessStrategyResolver;\nimport org.hibernate.property.access.spi.Setter;\nimport org.hibernate.service.ServiceRegistry;\nimport org.hibernate.generator.Generator;\nimport org.hibernate.generator.GeneratorCreationContext;\nimport org.hibernate.type.AnyType;\nimport org.hibernate.type.CollectionType;\nimport org.hibernate.type.ComponentType;\nimport org.hibernate.type.CompositeType;\nimport org.hibernate.type.Type;\nimport org.hibernate.type.WrapperArrayHandling;\n\nimport static java.util.Collections.emptyList;\nimport static java.util.Collections.unmodifiableList;\n\n/**\n * A mapping model object representing a property or field of an {@linkplain PersistentClass entity}\n * or {@linkplain Component embeddable class}.\n *\n * @author Gavin King\n */\npublic class Property implements Serializable, MetaAttributable {\n\tprivate String name;\n\tprivate Value value;\n\tprivate String cascade;\n\tprivate boolean updateable = true;\n\tprivate boolean insertable = true;\n\tprivate boolean selectable = true;\n\tprivate boolean optimisticLocked = true;\n\tprivate GeneratorCreator generatorCreator;\n\tprivate String propertyAccessorName;\n\tprivate PropertyAccessStrategy propertyAccessStrategy;\n\tprivate boolean lazy;\n\tprivate String lazyGroup;\n\tprivate boolean optional;\n\tprivate java.util.Map<String,MetaAttribute> metaAttributes;\n\tprivate PersistentClass persistentClass;\n\tprivate boolean naturalIdentifier;\n\tprivate boolean isGeneric;\n\tprivate boolean lob;\n\tprivate java.util.List<CallbackDefinition> callbackDefinitions;\n\tprivate String returnedClassName;\n\n\tpublic boolean isBackRef() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Does this property represent a synthetic property?  A synthetic property is one we create during\n\t * metamodel binding to represent a collection of columns but which does not represent a property\n\t * physically available on the entity.\n\t *\n\t * @return True if synthetic; false otherwise.\n\t */\n\tpublic boolean isSynthetic() {\n\t\treturn false;\n\t}\n\n\tpublic Type getType() throws MappingException {\n\t\treturn value.getType();\n\t}\n\t\n\tpublic int getColumnSpan() {\n\t\treturn value.getColumnSpan();\n\t}\n\n\t/**\n\t * Delegates to {@link Value#getSelectables()}.\n\t */\n\tpublic java.util.List<Selectable> getSelectables() {\n\t\treturn value.getSelectables();\n\t}\n\n\t/**\n\t * Delegates to {@link Value#getColumns()}.\n\t *\n\t * @throws org.hibernate.AssertionFailure if the mapping involves formulas\n\t */\n\tpublic java.util.List<Column> getColumns() {\n\t\treturn value.getColumns();\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic boolean isComposite() {\n\t\treturn value instanceof Component;\n\t}\n\n\tpublic Value getValue() {\n\t\treturn value;\n\t}\n\n\tpublic void resetUpdateable(boolean updateable) {\n\t\tsetUpdateable( updateable );\n\t\tboolean[] columnUpdateability = getValue().getColumnUpdateability();\n\t\tfor (int i=0; i<getColumnSpan(); i++ ) {\n\t\t\tcolumnUpdateability[i] = updateable;\n\t\t}\n\t}\n\n\tpublic void resetOptional(boolean optional) {\n\t\tsetOptional( optional );\n\t\tfor ( Selectable selectable: getValue().getSelectables() ) {\n\t\t\tif (selectable instanceof Column) {\n\t\t\t\tfinal Column column = (Column) selectable;\n\t\t\t\tcolumn.setNullable( optional );\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic CascadeStyle getCascadeStyle() throws MappingException {\n\t\tfinal Type type = value.getType();\n\t\tif ( type instanceof AnyType ) {\n\t\t\treturn getCascadeStyle( cascade );\n\t\t}\n\t\tif ( type instanceof ComponentType ) {\n\t\t\treturn getCompositeCascadeStyle( (ComponentType) type, cascade );\n\t\t}\n\t\telse if ( type instanceof CollectionType ) {\n\t\t\tfinal Collection collection = (Collection) value;\n\t\t\treturn getCollectionCascadeStyle( collection.getElement().getType(), cascade );\n\t\t}\n\t\telse {\n\t\t\treturn getCascadeStyle( cascade );\t\t\t\n\t\t}\n\t}\n\n\tprivate static CascadeStyle getCompositeCascadeStyle(CompositeType compositeType, String cascade) {\n\t\tif ( compositeType instanceof AnyType ) {\n\t\t\treturn getCascadeStyle( cascade );\n\t\t}\n\t\telse {\n\t\t\treturn getCompositeCascadeStyle( (ComponentType) compositeType, cascade );\n\t\t}\n\t}\n\n\tprivate static CascadeStyle getCompositeCascadeStyle(ComponentType compositeType, String cascade) {\n\t\tfinal int length = compositeType.getSubtypes().length;\n\t\tfor ( int i=0; i<length; i++ ) {\n\t\t\tif ( compositeType.getCascadeStyle(i) != CascadeStyles.NONE ) {\n\t\t\t\treturn CascadeStyles.ALL;\n\t\t\t}\n\t\t}\n\t\treturn getCascadeStyle( cascade );\n\t}\n\n\tprivate static CascadeStyle getCollectionCascadeStyle(Type elementType, String cascade) {\n\t\tif ( elementType instanceof AnyType ) {\n\t\t\treturn getCascadeStyle( cascade );\n\t\t}\n\t\telse if ( elementType instanceof ComponentType ) {\n\t\t\treturn getCompositeCascadeStyle( (ComponentType) elementType, cascade );\n\t\t}\n\t\telse {\n\t\t\treturn getCascadeStyle( cascade );\n\t\t}\n\t}\n\t\n\tprivate static CascadeStyle getCascadeStyle(String cascade) {\n\t\tif ( cascade==null || cascade.equals(\"none\") ) {\n\t\t\treturn CascadeStyles.NONE;\n\t\t}\n\t\telse {\n\t\t\tfinal StringTokenizer tokens = new StringTokenizer(cascade, \", \");\n\t\t\tfinal CascadeStyle[] styles = new CascadeStyle[ tokens.countTokens() ] ;\n\t\t\tint i=0;\n\t\t\twhile ( tokens.hasMoreTokens() ) {\n\t\t\t\tstyles[i++] = CascadeStyles.getCascadeStyle( tokens.nextToken() );\n\t\t\t}\n\t\t\treturn new CascadeStyles.MultipleCascadeStyle(styles);\n\t\t}\t\t\n\t}\n\t\n\tpublic String getCascade() {\n\t\treturn cascade;\n\t}\n\n\tpublic void setCascade(String cascade) {\n\t\tthis.cascade = cascade;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name==null ? null : name.intern();\n\t}\n\n\tpublic void setValue(Value value) {\n\t\tthis.value = value;\n\t}\n\n\tpublic boolean isUpdateable() {\n\t\t// if the property mapping consists of all formulas,\n\t\t// make it non-updatable\n\t\treturn updateable && value.hasAnyUpdatableColumns();\n\t}\n\n\tpublic boolean isInsertable() {\n\t\t// if the property mapping consists of all formulas, \n\t\t// make it non-insertable\n\t\treturn insertable && value.hasAnyInsertableColumns();\n\t}\n\n\t@Internal\n\tpublic GeneratorCreator getValueGeneratorCreator() {\n\t\treturn generatorCreator;\n\t}\n\n\t@Internal\n\tpublic void setValueGeneratorCreator(GeneratorCreator generator) {\n\t\tthis.generatorCreator = generator;\n\t}\n\n\tpublic void setUpdateable(boolean mutable) {\n\t\tthis.updateable = mutable;\n\t}\n\n\tpublic void setInsertable(boolean insertable) {\n\t\tthis.insertable = insertable;\n\t}\n\n\tpublic String getPropertyAccessorName() {\n\t\treturn propertyAccessorName;\n\t}\n\n\tpublic void setPropertyAccessorName(String string) {\n\t\tpropertyAccessorName = string;\n\t}\n\n\tpublic PropertyAccessStrategy getPropertyAccessStrategy() {\n\t\treturn propertyAccessStrategy;\n\t}\n\n\tpublic void setPropertyAccessStrategy(PropertyAccessStrategy propertyAccessStrategy) {\n\t\tthis.propertyAccessStrategy = propertyAccessStrategy;\n\t}\n\n\tpublic boolean isBasicPropertyAccessor() {\n\t\treturn propertyAccessorName==null || \"property\".equals( propertyAccessorName );\n\t}\n\n\tpublic Map<String, MetaAttribute> getMetaAttributes() {\n\t\treturn metaAttributes;\n\t}\n\n\tpublic MetaAttribute getMetaAttribute(String attributeName) {\n\t\treturn metaAttributes==null ? null : metaAttributes.get(attributeName);\n\t}\n\n\tpublic void setMetaAttributes(Map<String, MetaAttribute> metas) {\n\t\tthis.metaAttributes = metas;\n\t}\n\n\tpublic boolean isValid(Mapping mapping) throws MappingException {\n\t\tfinal Value value = getValue();\n\t\tif ( value instanceof BasicValue && ( (BasicValue) value ).isDisallowedWrapperArray() ) {\n\t\t\tthrow new MappingException(\n\t\t\t\t\t\"The property \" + persistentClass.getEntityName() + \"#\" + name +\n\t\t\t\t\t\t\t\" uses a wrapper type Byte[]/Character[] which indicates an issue in your domain model. \" +\n\t\t\t\t\t\t\t\"These types have been treated like byte[]/char[] until Hibernate 6.2 which meant that \" +\n\t\t\t\t\t\t\t\"null elements were not allowed, but on JDBC were processed like VARBINARY or VARCHAR. \" +\n\t\t\t\t\t\t\t\"If you don't use nulls in your arrays, change the type of the property to byte[]/char[]. \" +\n\t\t\t\t\t\t\t\"To allow explicit uses of the wrapper types Byte[]/Character[] which allows null element \" +\n\t\t\t\t\t\t\t\"but has a different serialization format than before Hibernate 6.2, configure the \" +\n\t\t\t\t\t\t\t\"setting \" + AvailableSettings.WRAPPER_ARRAY_HANDLING + \" to the value \" + WrapperArrayHandling.ALLOW + \". \" +\n\t\t\t\t\t\t\t\"To revert to the legacy treatment of these types, configure the value to \" + WrapperArrayHandling.LEGACY + \". \" +\n\t\t\t\t\t\t\t\"For more information on this matter, consult the migration guide of Hibernate 6.2 \" +\n\t\t\t\t\t\t\t\"and the Javadoc of the org.hibernate.cfg.AvailableSettings.WRAPPER_ARRAY_HANDLING field.\"\n\t\t\t);\n\t\t}\n\t\treturn value.isValid( mapping );\n\t}\n\n\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + '(' + name + ')';\n\t}\n\t\n\tpublic void setLazy(boolean lazy) {\n\t\tthis.lazy=lazy;\n\t}\n\n\t/**\n\t * Is this property lazy in the \"bytecode\" sense?\n\t * <p>\n\t * Lazy here means whether we initialize this field of the entity\n\t * instance in its \"base fetch group\". It affects whether we list\n\t * this property's columns in the SQL select for the owning entity\n\t * when we load its \"base fetch group\". The actual value that is set\n\t * varies based on the nature (basic, etc) of the property.\n\t *\n\t * @apiNote This method reports whether the property is considered\n\t * part of the base fetch group based solely on the information in\n\t * the mapping but {@link EnhancementHelper#includeInBaseFetchGroup}\n\t * is also accounts for other details.\n\t */\n\tpublic boolean isLazy() {\n\t\tif ( value instanceof ToOne ) {\n\t\t\t// For a many-to-one, this is always false. Whether the\n\t\t\t// association is EAGER, PROXY or NO-PROXY we always want\n\t\t\t// to select the foreign key\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\treturn lazy;\n\t\t}\n\t}\n\n\tpublic String getLazyGroup() {\n\t\treturn lazyGroup;\n\t}\n\n\tpublic void setLazyGroup(String lazyGroup) {\n\t\tthis.lazyGroup = lazyGroup;\n\t}\n\n\tpublic boolean isOptimisticLocked() {\n\t\treturn optimisticLocked;\n\t}\n\n\tpublic void setOptimisticLocked(boolean optimisticLocked) {\n\t\tthis.optimisticLocked = optimisticLocked;\n\t}\n\t\n\tpublic boolean isOptional() {\n\t\treturn optional;\n\t}\n\t\n\tpublic void setOptional(boolean optional) {\n\t\tthis.optional = optional;\n\t}\n\n\tpublic PersistentClass getPersistentClass() {\n\t\treturn persistentClass;\n\t}\n\n\tpublic void setPersistentClass(PersistentClass persistentClass) {\n\t\tthis.persistentClass = persistentClass;\n\t}\n\n\tpublic boolean isSelectable() {\n\t\treturn selectable;\n\t}\n\t\n\tpublic void setSelectable(boolean selectable) {\n\t\tthis.selectable = selectable;\n\t}\n\n\t// todo : remove\n\t@Internal\n\tpublic Getter getGetter(Class clazz) throws MappingException {\n\t\treturn getPropertyAccessStrategy( clazz ).buildPropertyAccess( clazz, name, true ).getGetter();\n\t}\n\n\t// todo : remove\n\t@Internal\n\tpublic Setter getSetter(Class clazz) throws MappingException {\n\t\treturn getPropertyAccessStrategy( clazz ).buildPropertyAccess( clazz, name, true ).getSetter();\n\t}\n\n\t// todo : remove\n\t@Internal\n\tpublic PropertyAccessStrategy getPropertyAccessStrategy(Class clazz) throws MappingException {\n\t\tfinal PropertyAccessStrategy propertyAccessStrategy = getPropertyAccessStrategy();\n\t\tif ( propertyAccessStrategy != null ) {\n\t\t\treturn propertyAccessStrategy;\n\t\t}\n\t\tString accessName = getPropertyAccessorName();\n\t\tif ( accessName == null ) {\n\t\t\tif ( clazz == null || java.util.Map.class.equals( clazz ) ) {\n\t\t\t\taccessName = \"map\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\taccessName = \"property\";\n\t\t\t}\n\t\t}\n\n\t\tfinal RepresentationMode representationMode = clazz == null || java.util.Map.class.equals( clazz )\n\t\t\t\t? RepresentationMode.MAP\n\t\t\t\t: RepresentationMode.POJO;\n\n\t\treturn resolveServiceRegistry()\n\t\t\t\t.requireService( PropertyAccessStrategyResolver.class )\n\t\t\t\t.resolvePropertyAccessStrategy( clazz, accessName, representationMode );\n\t}\n\n\tServiceRegistry resolveServiceRegistry() {\n\t\tif ( getPersistentClass() != null ) {\n\t\t\treturn getPersistentClass().getServiceRegistry();\n\t\t}\n\t\tif ( getValue() != null ) {\n\t\t\treturn getValue().getServiceRegistry();\n\t\t}\n\t\tthrow new HibernateException( \"Could not resolve ServiceRegistry\" );\n\t}\n\n\tpublic boolean isNaturalIdentifier() {\n\t\treturn naturalIdentifier;\n\t}\n\n\tpublic void setNaturalIdentifier(boolean naturalIdentifier) {\n\t\tthis.naturalIdentifier = naturalIdentifier;\n\t}\n\n\tpublic boolean isGeneric() {\n\t\treturn isGeneric;\n\t}\n\n\tpublic void setGeneric(boolean generic) {\n\t\tthis.isGeneric = generic;\n\t}\n\n\tpublic boolean isLob() {\n\t\treturn lob;\n\t}\n\n\tpublic void setLob(boolean lob) {\n\t\tthis.lob = lob;\n\t}\n\n\tpublic void addCallbackDefinitions(java.util.List<CallbackDefinition> callbackDefinitions) {\n\t\tif ( callbackDefinitions != null && !callbackDefinitions.isEmpty() ) {\n\t\t\tif ( this.callbackDefinitions == null ) {\n\t\t\t\tthis.callbackDefinitions = new ArrayList<>();\n\t\t\t}\n\t\t\tthis.callbackDefinitions.addAll( callbackDefinitions );\n\t\t}\n\t}\n\n\tpublic java.util.List<CallbackDefinition> getCallbackDefinitions() {\n\t\treturn callbackDefinitions == null ? emptyList() : unmodifiableList( callbackDefinitions );\n\t}\n\n\tpublic String getReturnedClassName() {\n\t\treturn returnedClassName;\n\t}\n\n\tpublic void setReturnedClassName(String returnedClassName) {\n\t\tthis.returnedClassName = returnedClassName;\n\t}\n\n\tpublic Generator createGenerator(RuntimeModelCreationContext context) {\n\t\treturn generatorCreator == null ? null :\n\t\t\t\tgeneratorCreator.createGenerator( new PropertyGeneratorCreationContext( context ) );\n\t}\n\n\tpublic Property copy() {\n\t\tfinal Property property = new Property();\n\t\tproperty.setName( getName() );\n\t\tproperty.setValue( getValue() );\n\t\tproperty.setCascade( getCascade() );\n\t\tproperty.setUpdateable( isUpdateable() );\n\t\tproperty.setInsertable( isInsertable() );\n\t\tproperty.setSelectable( isSelectable() );\n\t\tproperty.setOptimisticLocked( isOptimisticLocked() );\n\t\tproperty.setValueGeneratorCreator( getValueGeneratorCreator() );\n\t\tproperty.setPropertyAccessorName( getPropertyAccessorName() );\n\t\tproperty.setPropertyAccessStrategy( getPropertyAccessStrategy() );\n\t\tproperty.setLazy( isLazy() );\n\t\tproperty.setLazyGroup( getLazyGroup() );\n\t\tproperty.setOptional( isOptional() );\n\t\tproperty.setMetaAttributes( getMetaAttributes() );\n\t\tproperty.setPersistentClass( getPersistentClass() );\n\t\tproperty.setNaturalIdentifier( isNaturalIdentifier() );\n\t\tproperty.setGeneric( isGeneric() );\n\t\tproperty.setLob( isLob() );\n\t\tproperty.addCallbackDefinitions( getCallbackDefinitions() );\n\t\tproperty.setReturnedClassName( getReturnedClassName() );\n\t\treturn property;\n\t}\n\n\tprivate class PropertyGeneratorCreationContext implements GeneratorCreationContext {\n\t\tprivate final RuntimeModelCreationContext context;\n\n\t\tpublic PropertyGeneratorCreationContext(RuntimeModelCreationContext context) {\n\t\t\tthis.context = context;\n\t\t}\n\n\t\t@Override\n\t\tpublic Database getDatabase() {\n\t\t\treturn context.getMetadata().getDatabase();\n\t\t}\n\n\t\t@Override\n\t\tpublic ServiceRegistry getServiceRegistry() {\n\t\t\treturn context.getBootstrapContext().getServiceRegistry();\n\t\t}\n\n\t\t@Override\n\t\tpublic String getDefaultCatalog() {\n\t\t\treturn context.getSessionFactoryOptions().getDefaultCatalog();\n\t\t}\n\n\t\t@Override\n\t\tpublic String getDefaultSchema() {\n\t\t\treturn context.getSessionFactoryOptions().getDefaultSchema();\n\t\t}\n\n\t\t@Override\n\t\tpublic PersistentClass getPersistentClass() {\n\t\t\treturn persistentClass;\n\t\t}\n\n\t\t@Override\n\t\tpublic RootClass getRootClass() {\n\t\t\treturn persistentClass.getRootClass();\n\t\t}\n\n\t\t@Override\n\t\tpublic Property getProperty() {\n\t\t\treturn Property.this;\n\t\t}\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private static CascadeStyle getCompositeCascadeStyle(ComponentType compositeType, String cascade) {\n\t\tfinal int length = compositeType.getSubtypes().length;\n\t\tfor ( int i=0; i<length; i++ ) {\n\t\t\tif ( compositeType.getCascadeStyle(i) != CascadeStyles.NONE ) {\n\t\t\t\treturn CascadeStyles.ALL;\n\t\t\t}\n\t\t}\n\t\treturn getCascadeStyle( cascade );\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.type.AbstractType#isAnyType\n methodBody: public boolean isAnyType() {\nreturn false;\n}",
            "methodSignature: org.hibernate.mapping.Property#getCascadeStyle\n methodBody: private static CascadeStyle getCascadeStyle(String cascade) {\nif(cascade == null || cascade.equals(\"none\")){return CascadeStyles.NONE;\n}{final StringTokenizer tokens=new StringTokenizer(cascade,\", \");\nfinal CascadeStyle[] styles=new CascadeStyle[tokens.countTokens()];\nint i=0;\nwhile(tokens.hasMoreTokens()){styles[i++]=CascadeStyles.getCascadeStyle(tokens.nextToken());\n}return new CascadeStyles.MultipleCascadeStyle(styles);\n}}"
        ],
        "sourceCodeAfterRefactoring": "private static CascadeStyle getCompositeCascadeStyle(CompositeType compositeType, String cascade) {\n\t\tif ( compositeType instanceof AnyType ) {\n\t\t\treturn getCascadeStyle( cascade );\n\t\t}\n\t\telse {\n\t\t\treturn getCompositeCascadeStyle( (ComponentType) compositeType, cascade );\n\t\t}\n\t}\nprivate static CascadeStyle getCompositeCascadeStyle(ComponentType compositeType, String cascade) {\n\t\tfinal int length = compositeType.getSubtypes().length;\n\t\tfor ( int i=0; i<length; i++ ) {\n\t\t\tif ( compositeType.getCascadeStyle(i) != CascadeStyles.NONE ) {\n\t\t\t\treturn CascadeStyles.ALL;\n\t\t\t}\n\t\t}\n\t\treturn getCascadeStyle( cascade );\n\t}",
        "diffSourceCode": "-  151: \tprivate static CascadeStyle getCompositeCascadeStyle(CompositeType compositeType, String cascade) {\n-  152: \t\tif ( compositeType.isAnyType() ) {\n-  153: \t\t\treturn getCascadeStyle( cascade );\n+  151: \t\t}\n+  152: \t\telse {\n+  153: \t\t\treturn getCascadeStyle( cascade );\t\t\t\n   154: \t\t}\n-  155: \t\tfinal int length = compositeType.getSubtypes().length;\n-  156: \t\tfor ( int i=0; i<length; i++ ) {\n-  157: \t\t\tif ( compositeType.getCascadeStyle(i) != CascadeStyles.NONE ) {\n-  158: \t\t\t\treturn CascadeStyles.ALL;\n-  159: \t\t\t}\n+  155: \t}\n+  156: \n+  157: \tprivate static CascadeStyle getCompositeCascadeStyle(CompositeType compositeType, String cascade) {\n+  158: \t\tif ( compositeType instanceof AnyType ) {\n+  159: \t\t\treturn getCascadeStyle( cascade );\n   160: \t\t}\n-  161: \t\treturn getCascadeStyle( cascade );\n-  162: \t}\n-  163: \n-  164: \tprivate static CascadeStyle getCollectionCascadeStyle(Type elementType, String cascade) {\n-  166: \t\t\t\t? getCompositeCascadeStyle( (CompositeType) elementType, cascade )\n-  167: \t\t\t\t: getCascadeStyle( cascade );\n-  168: \t}\n-  169: \t\n-  170: \tprivate static CascadeStyle getCascadeStyle(String cascade) {\n-  171: \t\tif ( cascade==null || cascade.equals(\"none\") ) {\n-  172: \t\t\treturn CascadeStyles.NONE;\n-  173: \t\t}\n-  174: \t\telse {\n+  161: \t\telse {\n+  162: \t\t\treturn getCompositeCascadeStyle( (ComponentType) compositeType, cascade );\n+  163: \t\t}\n+  164: \t}\n+  166: \tprivate static CascadeStyle getCompositeCascadeStyle(ComponentType compositeType, String cascade) {\n+  167: \t\tfinal int length = compositeType.getSubtypes().length;\n+  168: \t\tfor ( int i=0; i<length; i++ ) {\n+  169: \t\t\tif ( compositeType.getCascadeStyle(i) != CascadeStyles.NONE ) {\n+  170: \t\t\t\treturn CascadeStyles.ALL;\n+  171: \t\t\t}\n+  172: \t\t}\n+  173: \t\treturn getCascadeStyle( cascade );\n+  174: \t}\n",
        "uniqueId": "94b444b4d8e0ac7ec5817642ca711f626ee327f3_151_162_166_174_157_164",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 27
            },
            "BRANCH": {
                "missed": 0,
                "covered": 6
            },
            "LINE": {
                "missed": 0,
                "covered": 7
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 4
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\nprivate static CascadeStyle getCollectionCascadeStyle(Type elementType, String cascade) {\n    return elementType.isComponentType()\n            ? getCompositeCascadeStyle((CompositeType) elementType, cascade)\n            : getCascadeStyle(cascade);\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprivate static CascadeStyle getCompositeCascadeStyle(CompositeType compositeType, String cascade) {\n\t\tif ( compositeType.isAnyType() ) {\n\t\t\treturn getCascadeStyle( cascade );\n\t\t}\n\t\tfinal int length = compositeType.getSubtypes().length;\n\t\tfor ( int i=0; i<length; i++ ) {\n\t\t\tif ( compositeType.getCascadeStyle(i) != CascadeStyles.NONE ) {\n\t\t\t\treturn CascadeStyles.ALL;\n\t\t\t}\n\t\t}\n\t\treturn getCascadeStyle( cascade );\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.mapping;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.StringTokenizer;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.Internal;\nimport org.hibernate.MappingException;\nimport org.hibernate.boot.model.relational.Database;\nimport org.hibernate.bytecode.enhance.spi.interceptor.EnhancementHelper;\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.engine.spi.CascadeStyle;\nimport org.hibernate.engine.spi.CascadeStyles;\nimport org.hibernate.engine.spi.Mapping;\nimport org.hibernate.jpa.event.spi.CallbackDefinition;\nimport org.hibernate.metamodel.RepresentationMode;\nimport org.hibernate.metamodel.spi.RuntimeModelCreationContext;\nimport org.hibernate.property.access.spi.Getter;\nimport org.hibernate.property.access.spi.PropertyAccessStrategy;\nimport org.hibernate.property.access.spi.PropertyAccessStrategyResolver;\nimport org.hibernate.property.access.spi.Setter;\nimport org.hibernate.service.ServiceRegistry;\nimport org.hibernate.generator.Generator;\nimport org.hibernate.generator.GeneratorCreationContext;\nimport org.hibernate.type.CompositeType;\nimport org.hibernate.type.Type;\nimport org.hibernate.type.WrapperArrayHandling;\n\nimport static java.util.Collections.emptyList;\nimport static java.util.Collections.unmodifiableList;\n\n/**\n * A mapping model object representing a property or field of an {@linkplain PersistentClass entity}\n * or {@linkplain Component embeddable class}.\n *\n * @author Gavin King\n */\npublic class Property implements Serializable, MetaAttributable {\n\tprivate String name;\n\tprivate Value value;\n\tprivate String cascade;\n\tprivate boolean updateable = true;\n\tprivate boolean insertable = true;\n\tprivate boolean selectable = true;\n\tprivate boolean optimisticLocked = true;\n\tprivate GeneratorCreator generatorCreator;\n\tprivate String propertyAccessorName;\n\tprivate PropertyAccessStrategy propertyAccessStrategy;\n\tprivate boolean lazy;\n\tprivate String lazyGroup;\n\tprivate boolean optional;\n\tprivate java.util.Map<String,MetaAttribute> metaAttributes;\n\tprivate PersistentClass persistentClass;\n\tprivate boolean naturalIdentifier;\n\tprivate boolean isGeneric;\n\tprivate boolean lob;\n\tprivate java.util.List<CallbackDefinition> callbackDefinitions;\n\tprivate String returnedClassName;\n\n\tpublic boolean isBackRef() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Does this property represent a synthetic property?  A synthetic property is one we create during\n\t * metamodel binding to represent a collection of columns but which does not represent a property\n\t * physically available on the entity.\n\t *\n\t * @return True if synthetic; false otherwise.\n\t */\n\tpublic boolean isSynthetic() {\n\t\treturn false;\n\t}\n\n\tpublic Type getType() throws MappingException {\n\t\treturn value.getType();\n\t}\n\t\n\tpublic int getColumnSpan() {\n\t\treturn value.getColumnSpan();\n\t}\n\n\t/**\n\t * Delegates to {@link Value#getSelectables()}.\n\t */\n\tpublic java.util.List<Selectable> getSelectables() {\n\t\treturn value.getSelectables();\n\t}\n\n\t/**\n\t * Delegates to {@link Value#getColumns()}.\n\t *\n\t * @throws org.hibernate.AssertionFailure if the mapping involves formulas\n\t */\n\tpublic java.util.List<Column> getColumns() {\n\t\treturn value.getColumns();\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic boolean isComposite() {\n\t\treturn value instanceof Component;\n\t}\n\n\tpublic Value getValue() {\n\t\treturn value;\n\t}\n\n\tpublic void resetUpdateable(boolean updateable) {\n\t\tsetUpdateable( updateable );\n\t\tboolean[] columnUpdateability = getValue().getColumnUpdateability();\n\t\tfor (int i=0; i<getColumnSpan(); i++ ) {\n\t\t\tcolumnUpdateability[i] = updateable;\n\t\t}\n\t}\n\n\tpublic void resetOptional(boolean optional) {\n\t\tsetOptional( optional );\n\t\tfor ( Selectable selectable: getValue().getSelectables() ) {\n\t\t\tif (selectable instanceof Column) {\n\t\t\t\tfinal Column column = (Column) selectable;\n\t\t\t\tcolumn.setNullable( optional );\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic CascadeStyle getCascadeStyle() throws MappingException {\n\t\tfinal Type type = value.getType();\n\t\tif ( type.isComponentType() ) {\n\t\t\treturn getCompositeCascadeStyle( (CompositeType) type, cascade );\n\t\t}\n\t\telse if ( type.isCollectionType() ) {\n\t\t\tfinal Collection collection = (Collection) value;\n\t\t\treturn getCollectionCascadeStyle( collection.getElement().getType(), cascade );\n\t\t}\n\t\telse {\n\t\t\treturn getCascadeStyle( cascade );\t\t\t\n\t\t}\n\t}\n\n\tprivate static CascadeStyle getCompositeCascadeStyle(CompositeType compositeType, String cascade) {\n\t\tif ( compositeType.isAnyType() ) {\n\t\t\treturn getCascadeStyle( cascade );\n\t\t}\n\t\tfinal int length = compositeType.getSubtypes().length;\n\t\tfor ( int i=0; i<length; i++ ) {\n\t\t\tif ( compositeType.getCascadeStyle(i) != CascadeStyles.NONE ) {\n\t\t\t\treturn CascadeStyles.ALL;\n\t\t\t}\n\t\t}\n\t\treturn getCascadeStyle( cascade );\n\t}\n\n\tprivate static CascadeStyle getCollectionCascadeStyle(Type elementType, String cascade) {\n\t\treturn elementType.isComponentType()\n\t\t\t\t? getCompositeCascadeStyle( (CompositeType) elementType, cascade )\n\t\t\t\t: getCascadeStyle( cascade );\n\t}\n\t\n\tprivate static CascadeStyle getCascadeStyle(String cascade) {\n\t\tif ( cascade==null || cascade.equals(\"none\") ) {\n\t\t\treturn CascadeStyles.NONE;\n\t\t}\n\t\telse {\n\t\t\tfinal StringTokenizer tokens = new StringTokenizer(cascade, \", \");\n\t\t\tfinal CascadeStyle[] styles = new CascadeStyle[ tokens.countTokens() ] ;\n\t\t\tint i=0;\n\t\t\twhile ( tokens.hasMoreTokens() ) {\n\t\t\t\tstyles[i++] = CascadeStyles.getCascadeStyle( tokens.nextToken() );\n\t\t\t}\n\t\t\treturn new CascadeStyles.MultipleCascadeStyle(styles);\n\t\t}\t\t\n\t}\n\t\n\tpublic String getCascade() {\n\t\treturn cascade;\n\t}\n\n\tpublic void setCascade(String cascade) {\n\t\tthis.cascade = cascade;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name==null ? null : name.intern();\n\t}\n\n\tpublic void setValue(Value value) {\n\t\tthis.value = value;\n\t}\n\n\tpublic boolean isUpdateable() {\n\t\t// if the property mapping consists of all formulas,\n\t\t// make it non-updatable\n\t\treturn updateable && value.hasAnyUpdatableColumns();\n\t}\n\n\tpublic boolean isInsertable() {\n\t\t// if the property mapping consists of all formulas, \n\t\t// make it non-insertable\n\t\treturn insertable && value.hasAnyInsertableColumns();\n\t}\n\n\t@Internal\n\tpublic GeneratorCreator getValueGeneratorCreator() {\n\t\treturn generatorCreator;\n\t}\n\n\t@Internal\n\tpublic void setValueGeneratorCreator(GeneratorCreator generator) {\n\t\tthis.generatorCreator = generator;\n\t}\n\n\tpublic void setUpdateable(boolean mutable) {\n\t\tthis.updateable = mutable;\n\t}\n\n\tpublic void setInsertable(boolean insertable) {\n\t\tthis.insertable = insertable;\n\t}\n\n\tpublic String getPropertyAccessorName() {\n\t\treturn propertyAccessorName;\n\t}\n\n\tpublic void setPropertyAccessorName(String string) {\n\t\tpropertyAccessorName = string;\n\t}\n\n\tpublic PropertyAccessStrategy getPropertyAccessStrategy() {\n\t\treturn propertyAccessStrategy;\n\t}\n\n\tpublic void setPropertyAccessStrategy(PropertyAccessStrategy propertyAccessStrategy) {\n\t\tthis.propertyAccessStrategy = propertyAccessStrategy;\n\t}\n\n\tpublic boolean isBasicPropertyAccessor() {\n\t\treturn propertyAccessorName==null || \"property\".equals( propertyAccessorName );\n\t}\n\n\tpublic Map<String, MetaAttribute> getMetaAttributes() {\n\t\treturn metaAttributes;\n\t}\n\n\tpublic MetaAttribute getMetaAttribute(String attributeName) {\n\t\treturn metaAttributes==null ? null : metaAttributes.get(attributeName);\n\t}\n\n\tpublic void setMetaAttributes(Map<String, MetaAttribute> metas) {\n\t\tthis.metaAttributes = metas;\n\t}\n\n\tpublic boolean isValid(Mapping mapping) throws MappingException {\n\t\tfinal Value value = getValue();\n\t\tif ( value instanceof BasicValue && ( (BasicValue) value ).isDisallowedWrapperArray() ) {\n\t\t\tthrow new MappingException(\n\t\t\t\t\t\"The property \" + persistentClass.getEntityName() + \"#\" + name +\n\t\t\t\t\t\t\t\" uses a wrapper type Byte[]/Character[] which indicates an issue in your domain model. \" +\n\t\t\t\t\t\t\t\"These types have been treated like byte[]/char[] until Hibernate 6.2 which meant that \" +\n\t\t\t\t\t\t\t\"null elements were not allowed, but on JDBC were processed like VARBINARY or VARCHAR. \" +\n\t\t\t\t\t\t\t\"If you don't use nulls in your arrays, change the type of the property to byte[]/char[]. \" +\n\t\t\t\t\t\t\t\"To allow explicit uses of the wrapper types Byte[]/Character[] which allows null element \" +\n\t\t\t\t\t\t\t\"but has a different serialization format than before Hibernate 6.2, configure the \" +\n\t\t\t\t\t\t\t\"setting \" + AvailableSettings.WRAPPER_ARRAY_HANDLING + \" to the value \" + WrapperArrayHandling.ALLOW + \". \" +\n\t\t\t\t\t\t\t\"To revert to the legacy treatment of these types, configure the value to \" + WrapperArrayHandling.LEGACY + \". \" +\n\t\t\t\t\t\t\t\"For more information on this matter, consult the migration guide of Hibernate 6.2 \" +\n\t\t\t\t\t\t\t\"and the Javadoc of the org.hibernate.cfg.AvailableSettings.WRAPPER_ARRAY_HANDLING field.\"\n\t\t\t);\n\t\t}\n\t\treturn value.isValid( mapping );\n\t}\n\n\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + '(' + name + ')';\n\t}\n\t\n\tpublic void setLazy(boolean lazy) {\n\t\tthis.lazy=lazy;\n\t}\n\n\t/**\n\t * Is this property lazy in the \"bytecode\" sense?\n\t * <p>\n\t * Lazy here means whether we initialize this field of the entity\n\t * instance in its \"base fetch group\". It affects whether we list\n\t * this property's columns in the SQL select for the owning entity\n\t * when we load its \"base fetch group\". The actual value that is set\n\t * varies based on the nature (basic, etc) of the property.\n\t *\n\t * @apiNote This method reports whether the property is considered\n\t * part of the base fetch group based solely on the information in\n\t * the mapping but {@link EnhancementHelper#includeInBaseFetchGroup}\n\t * is also accounts for other details.\n\t */\n\tpublic boolean isLazy() {\n\t\tif ( value instanceof ToOne ) {\n\t\t\t// For a many-to-one, this is always false. Whether the\n\t\t\t// association is EAGER, PROXY or NO-PROXY we always want\n\t\t\t// to select the foreign key\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\treturn lazy;\n\t\t}\n\t}\n\n\tpublic String getLazyGroup() {\n\t\treturn lazyGroup;\n\t}\n\n\tpublic void setLazyGroup(String lazyGroup) {\n\t\tthis.lazyGroup = lazyGroup;\n\t}\n\n\tpublic boolean isOptimisticLocked() {\n\t\treturn optimisticLocked;\n\t}\n\n\tpublic void setOptimisticLocked(boolean optimisticLocked) {\n\t\tthis.optimisticLocked = optimisticLocked;\n\t}\n\t\n\tpublic boolean isOptional() {\n\t\treturn optional;\n\t}\n\t\n\tpublic void setOptional(boolean optional) {\n\t\tthis.optional = optional;\n\t}\n\n\tpublic PersistentClass getPersistentClass() {\n\t\treturn persistentClass;\n\t}\n\n\tpublic void setPersistentClass(PersistentClass persistentClass) {\n\t\tthis.persistentClass = persistentClass;\n\t}\n\n\tpublic boolean isSelectable() {\n\t\treturn selectable;\n\t}\n\t\n\tpublic void setSelectable(boolean selectable) {\n\t\tthis.selectable = selectable;\n\t}\n\n\t// todo : remove\n\t@Internal\n\tpublic Getter getGetter(Class clazz) throws MappingException {\n\t\treturn getPropertyAccessStrategy( clazz ).buildPropertyAccess( clazz, name, true ).getGetter();\n\t}\n\n\t// todo : remove\n\t@Internal\n\tpublic Setter getSetter(Class clazz) throws MappingException {\n\t\treturn getPropertyAccessStrategy( clazz ).buildPropertyAccess( clazz, name, true ).getSetter();\n\t}\n\n\t// todo : remove\n\t@Internal\n\tpublic PropertyAccessStrategy getPropertyAccessStrategy(Class clazz) throws MappingException {\n\t\tfinal PropertyAccessStrategy propertyAccessStrategy = getPropertyAccessStrategy();\n\t\tif ( propertyAccessStrategy != null ) {\n\t\t\treturn propertyAccessStrategy;\n\t\t}\n\t\tString accessName = getPropertyAccessorName();\n\t\tif ( accessName == null ) {\n\t\t\tif ( clazz == null || java.util.Map.class.equals( clazz ) ) {\n\t\t\t\taccessName = \"map\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\taccessName = \"property\";\n\t\t\t}\n\t\t}\n\n\t\tfinal RepresentationMode representationMode = clazz == null || java.util.Map.class.equals( clazz )\n\t\t\t\t? RepresentationMode.MAP\n\t\t\t\t: RepresentationMode.POJO;\n\n\t\treturn resolveServiceRegistry()\n\t\t\t\t.requireService( PropertyAccessStrategyResolver.class )\n\t\t\t\t.resolvePropertyAccessStrategy( clazz, accessName, representationMode );\n\t}\n\n\tServiceRegistry resolveServiceRegistry() {\n\t\tif ( getPersistentClass() != null ) {\n\t\t\treturn getPersistentClass().getServiceRegistry();\n\t\t}\n\t\tif ( getValue() != null ) {\n\t\t\treturn getValue().getServiceRegistry();\n\t\t}\n\t\tthrow new HibernateException( \"Could not resolve ServiceRegistry\" );\n\t}\n\n\tpublic boolean isNaturalIdentifier() {\n\t\treturn naturalIdentifier;\n\t}\n\n\tpublic void setNaturalIdentifier(boolean naturalIdentifier) {\n\t\tthis.naturalIdentifier = naturalIdentifier;\n\t}\n\n\tpublic boolean isGeneric() {\n\t\treturn isGeneric;\n\t}\n\n\tpublic void setGeneric(boolean generic) {\n\t\tthis.isGeneric = generic;\n\t}\n\n\tpublic boolean isLob() {\n\t\treturn lob;\n\t}\n\n\tpublic void setLob(boolean lob) {\n\t\tthis.lob = lob;\n\t}\n\n\tpublic void addCallbackDefinitions(java.util.List<CallbackDefinition> callbackDefinitions) {\n\t\tif ( callbackDefinitions != null && !callbackDefinitions.isEmpty() ) {\n\t\t\tif ( this.callbackDefinitions == null ) {\n\t\t\t\tthis.callbackDefinitions = new ArrayList<>();\n\t\t\t}\n\t\t\tthis.callbackDefinitions.addAll( callbackDefinitions );\n\t\t}\n\t}\n\n\tpublic java.util.List<CallbackDefinition> getCallbackDefinitions() {\n\t\treturn callbackDefinitions == null ? emptyList() : unmodifiableList( callbackDefinitions );\n\t}\n\n\tpublic String getReturnedClassName() {\n\t\treturn returnedClassName;\n\t}\n\n\tpublic void setReturnedClassName(String returnedClassName) {\n\t\tthis.returnedClassName = returnedClassName;\n\t}\n\n\tpublic Generator createGenerator(RuntimeModelCreationContext context) {\n\t\treturn generatorCreator == null ? null :\n\t\t\t\tgeneratorCreator.createGenerator( new PropertyGeneratorCreationContext( context ) );\n\t}\n\n\tpublic Property copy() {\n\t\tfinal Property property = new Property();\n\t\tproperty.setName( getName() );\n\t\tproperty.setValue( getValue() );\n\t\tproperty.setCascade( getCascade() );\n\t\tproperty.setUpdateable( isUpdateable() );\n\t\tproperty.setInsertable( isInsertable() );\n\t\tproperty.setSelectable( isSelectable() );\n\t\tproperty.setOptimisticLocked( isOptimisticLocked() );\n\t\tproperty.setValueGeneratorCreator( getValueGeneratorCreator() );\n\t\tproperty.setPropertyAccessorName( getPropertyAccessorName() );\n\t\tproperty.setPropertyAccessStrategy( getPropertyAccessStrategy() );\n\t\tproperty.setLazy( isLazy() );\n\t\tproperty.setLazyGroup( getLazyGroup() );\n\t\tproperty.setOptional( isOptional() );\n\t\tproperty.setMetaAttributes( getMetaAttributes() );\n\t\tproperty.setPersistentClass( getPersistentClass() );\n\t\tproperty.setNaturalIdentifier( isNaturalIdentifier() );\n\t\tproperty.setGeneric( isGeneric() );\n\t\tproperty.setLob( isLob() );\n\t\tproperty.addCallbackDefinitions( getCallbackDefinitions() );\n\t\tproperty.setReturnedClassName( getReturnedClassName() );\n\t\treturn property;\n\t}\n\n\tprivate class PropertyGeneratorCreationContext implements GeneratorCreationContext {\n\t\tprivate final RuntimeModelCreationContext context;\n\n\t\tpublic PropertyGeneratorCreationContext(RuntimeModelCreationContext context) {\n\t\t\tthis.context = context;\n\t\t}\n\n\t\t@Override\n\t\tpublic Database getDatabase() {\n\t\t\treturn context.getMetadata().getDatabase();\n\t\t}\n\n\t\t@Override\n\t\tpublic ServiceRegistry getServiceRegistry() {\n\t\t\treturn context.getBootstrapContext().getServiceRegistry();\n\t\t}\n\n\t\t@Override\n\t\tpublic String getDefaultCatalog() {\n\t\t\treturn context.getSessionFactoryOptions().getDefaultCatalog();\n\t\t}\n\n\t\t@Override\n\t\tpublic String getDefaultSchema() {\n\t\t\treturn context.getSessionFactoryOptions().getDefaultSchema();\n\t\t}\n\n\t\t@Override\n\t\tpublic PersistentClass getPersistentClass() {\n\t\t\treturn persistentClass;\n\t\t}\n\n\t\t@Override\n\t\tpublic RootClass getRootClass() {\n\t\t\treturn persistentClass.getRootClass();\n\t\t}\n\n\t\t@Override\n\t\tpublic Property getProperty() {\n\t\t\treturn Property.this;\n\t\t}\n\t}\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Inline Method",
        "description": "Inline Method\tprotected createAssemblers(parent InitializerParent<?>, resultDescriptor EmbeddableResultGraphNode, creationState AssemblerCreationState, embeddableTypeDescriptor EmbeddableMappingType, fetchConverter Function<Fetch,Fetch>) : DomainResultAssembler<?>[] inlined to protected NonAggregatedIdentifierMappingInitializer(resultDescriptor EmbeddableResultGraphNode, parent InitializerParent<?>, creationState AssemblerCreationState, isResultInitializer boolean, fetchConverter Function<Fetch,Fetch>) in class org.hibernate.sql.results.graph.embeddable.internal.NonAggregatedIdentifierMappingInitializer",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/results/graph/embeddable/internal/NonAggregatedIdentifierMappingInitializer.java",
                "startLine": 109,
                "endLine": 160,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/results/graph/embeddable/internal/NonAggregatedIdentifierMappingInitializer.java",
                "startLine": 112,
                "endLine": 189,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/results/graph/embeddable/internal/NonAggregatedIdentifierMappingInitializer.java",
                "startLine": 162,
                "endLine": 181,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "protected static DomainResultAssembler<?>[] createAssemblers(\n\t\t\tInitializerParent<?> parent,\n\t\t\tEmbeddableResultGraphNode resultDescriptor,\n\t\t\tAssemblerCreationState creationState,\n\t\t\tEmbeddableMappingType embeddableTypeDescriptor,\n\t\t\tFunction<Fetch, Fetch> fetchConverter) {\n\t\tfinal int size = embeddableTypeDescriptor.getNumberOfFetchables();\n\t\tfinal DomainResultAssembler<?>[] assemblers = new DomainResultAssembler[size];\n\t\tfor ( int i = 0; i < size; i++ ) {\n\t\t\tfinal Fetchable stateArrayContributor = embeddableTypeDescriptor.getFetchable( i );\n\t\t\tfinal Fetch fetch = fetchConverter.apply( resultDescriptor.findFetch( stateArrayContributor ) );\n\n\t\t\tfinal DomainResultAssembler<?> stateAssembler = fetch == null\n\t\t\t\t\t? new NullValueAssembler<>( stateArrayContributor.getJavaType() )\n\t\t\t\t\t: fetch.createAssembler( parent, creationState );\n\n\t\t\tassemblers[i] = stateAssembler;\n\t\t}\n\t\treturn assemblers;\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/sql/results/graph/embeddable/internal/NonAggregatedIdentifierMappingInitializer.java",
        "isPureRefactoring": true,
        "commitId": "f8a6106ea20df36dc5c07827948a04b77243c1a6",
        "packageNameBefore": "org.hibernate.sql.results.graph.embeddable.internal",
        "classNameBefore": "org.hibernate.sql.results.graph.embeddable.internal.NonAggregatedIdentifierMappingInitializer",
        "methodNameBefore": "org.hibernate.sql.results.graph.embeddable.internal.NonAggregatedIdentifierMappingInitializer#createAssemblers",
        "invokedMethod": "methodSignature: org.hibernate.metamodel.mapping.internal.AbstractEmbeddableMapping#getFetchable\n methodBody: public Fetchable getFetchable(int position) {\nreturn getAttributeMappings().get(position);\n}\nmethodSignature: org.hibernate.metamodel.mapping.internal.AbstractEmbeddableMapping#getNumberOfFetchables\n methodBody: public int getNumberOfFetchables() {\nreturn getAttributeMappings().size();\n}",
        "classSignatureBefore": "public class NonAggregatedIdentifierMappingInitializer extends AbstractInitializer<NonAggregatedIdentifierMappingInitializer.NonAggregatedIdentifierMappingInitializerData>\n\t\timplements EmbeddableInitializer<NonAggregatedIdentifierMappingInitializer.NonAggregatedIdentifierMappingInitializerData> ",
        "methodNameBeforeSet": [
            "org.hibernate.sql.results.graph.embeddable.internal.NonAggregatedIdentifierMappingInitializer#createAssemblers"
        ],
        "classNameBeforeSet": [
            "org.hibernate.sql.results.graph.embeddable.internal.NonAggregatedIdentifierMappingInitializer"
        ],
        "classSignatureBeforeSet": [
            "public class NonAggregatedIdentifierMappingInitializer extends AbstractInitializer<NonAggregatedIdentifierMappingInitializer.NonAggregatedIdentifierMappingInitializerData>\n\t\timplements EmbeddableInitializer<NonAggregatedIdentifierMappingInitializer.NonAggregatedIdentifierMappingInitializerData> "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.sql.results.graph.embeddable.internal;\n\nimport java.util.function.BiConsumer;\nimport java.util.function.Function;\n\nimport org.hibernate.bytecode.enhance.spi.LazyPropertyInitializer;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.metamodel.mapping.AttributeMapping;\nimport org.hibernate.metamodel.mapping.EmbeddableMappingType;\nimport org.hibernate.metamodel.mapping.EmbeddableValuedModelPart;\nimport org.hibernate.metamodel.mapping.ForeignKeyDescriptor;\nimport org.hibernate.metamodel.mapping.NonAggregatedIdentifierMapping;\nimport org.hibernate.metamodel.mapping.internal.ToOneAttributeMapping;\nimport org.hibernate.metamodel.spi.EmbeddableInstantiator;\nimport org.hibernate.metamodel.spi.ValueAccess;\nimport org.hibernate.proxy.HibernateProxy;\nimport org.hibernate.proxy.LazyInitializer;\nimport org.hibernate.spi.EntityIdentifierNavigablePath;\nimport org.hibernate.spi.NavigablePath;\nimport org.hibernate.sql.results.graph.AssemblerCreationState;\nimport org.hibernate.sql.results.graph.DomainResultAssembler;\nimport org.hibernate.sql.results.graph.Fetch;\nimport org.hibernate.sql.results.graph.Fetchable;\nimport org.hibernate.sql.results.graph.Initializer;\nimport org.hibernate.sql.results.graph.InitializerData;\nimport org.hibernate.sql.results.graph.InitializerParent;\nimport org.hibernate.sql.results.graph.embeddable.EmbeddableInitializer;\nimport org.hibernate.sql.results.graph.embeddable.EmbeddableResultGraphNode;\nimport org.hibernate.sql.results.graph.internal.AbstractInitializer;\nimport org.hibernate.sql.results.internal.NullValueAssembler;\nimport org.hibernate.sql.results.jdbc.spi.RowProcessingState;\n\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport static org.hibernate.sql.results.graph.entity.internal.BatchEntityInsideEmbeddableSelectFetchInitializer.BATCH_PROPERTY;\n\n/**\n * @author Steve Ebersole\n */\npublic class NonAggregatedIdentifierMappingInitializer extends AbstractInitializer<NonAggregatedIdentifierMappingInitializer.NonAggregatedIdentifierMappingInitializerData>\n\t\timplements EmbeddableInitializer<NonAggregatedIdentifierMappingInitializer.NonAggregatedIdentifierMappingInitializerData> {\n\n\tprivate final NavigablePath navigablePath;\n\tprivate final NonAggregatedIdentifierMapping embedded;\n\tprivate final EmbeddableMappingType virtualIdEmbeddable;\n\tprivate final EmbeddableMappingType representationEmbeddable;\n\tprivate final EmbeddableInstantiator embeddableInstantiator;\n\tprivate final @Nullable InitializerParent<?> parent;\n\tprivate final SessionFactoryImplementor sessionFactory;\n\tprivate final boolean isResultInitializer;\n\n\tprivate final DomainResultAssembler<?>[] assemblers;\n\tprivate final @Nullable Initializer<InitializerData>[] initializers;\n\tprivate final @Nullable Initializer<InitializerData>[] subInitializersForResolveFromInitialized;\n\tprivate final boolean lazyCapable;\n\tprivate final boolean hasLazySubInitializer;\n\tprivate final boolean hasIdClass;\n\n\tpublic static class NonAggregatedIdentifierMappingInitializerData extends InitializerData implements ValueAccess {\n\t\tprotected final boolean isFindByIdLookup;\n\t\tprotected final InitializerData parentData;\n\t\tprotected final Object[] virtualIdState;\n\t\tprotected final Object[] idClassState;\n\n\t\tpublic NonAggregatedIdentifierMappingInitializerData(NonAggregatedIdentifierMappingInitializer initializer, RowProcessingState rowProcessingState) {\n\t\t\tsuper( rowProcessingState );\n\t\t\tthis.isFindByIdLookup = !initializer.hasIdClass && rowProcessingState.getEntityId() != null\n\t\t\t\t\t&& initializer.navigablePath.getParent().getParent() == null\n\t\t\t\t\t&& initializer.navigablePath instanceof EntityIdentifierNavigablePath;\n\t\t\tthis.parentData = initializer.parent == null ? null : initializer.parent.getData( rowProcessingState );\n\t\t\tfinal EmbeddableMappingType virtualIdEmbeddable = initializer.embedded.getEmbeddableTypeDescriptor();\n\t\t\tfinal int size = virtualIdEmbeddable.getNumberOfFetchables();\n\t\t\tthis.virtualIdState = new Object[ size ];\n\t\t\tthis.idClassState = new Object[ size ];\n\t\t}\n\n\t\t@Override\n\t\tpublic Object[] getValues() {\n\t\t\tassert getState() == State.RESOLVED;\n\t\t\treturn idClassState;\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T getValue(int i, Class<T> clazz) {\n\t\t\tassert getState() == State.RESOLVED;\n\t\t\treturn clazz.cast( idClassState[i] );\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getOwner() {\n\t\t\treturn parentData == null ? null : parentData.getInstance();\n\t\t}\n\t}\n\n\tpublic NonAggregatedIdentifierMappingInitializer(\n\t\t\tEmbeddableResultGraphNode resultDescriptor,\n\t\t\tInitializerParent<?> parent,\n\t\t\tAssemblerCreationState creationState,\n\t\t\tboolean isResultInitializer) {\n\t\tthis( resultDescriptor, parent, creationState, isResultInitializer, Function.identity() );\n\t}\n\n\tprotected NonAggregatedIdentifierMappingInitializer(\n\t\t\tEmbeddableResultGraphNode resultDescriptor,\n\t\t\tInitializerParent<?> parent,\n\t\t\tAssemblerCreationState creationState,\n\t\t\tboolean isResultInitializer,\n\t\t\tFunction<Fetch, Fetch> fetchConverter) {\n\t\tsuper( creationState );\n\t\tthis.navigablePath = resultDescriptor.getNavigablePath();\n\t\tthis.embedded = (NonAggregatedIdentifierMapping) resultDescriptor.getReferencedMappingContainer();\n\t\tthis.parent = parent;\n\t\tthis.isResultInitializer = isResultInitializer;\n\n\t\tthis.virtualIdEmbeddable = embedded.getEmbeddableTypeDescriptor();\n\t\tthis.representationEmbeddable = embedded.getMappedIdEmbeddableTypeDescriptor();\n\t\tthis.embeddableInstantiator = representationEmbeddable.getRepresentationStrategy().getInstantiator();\n\t\tthis.hasIdClass = embedded.hasContainingClass() && virtualIdEmbeddable != representationEmbeddable;\n\n\t\tthis.sessionFactory = creationState.getSqlAstCreationContext().getSessionFactory();\n\t\tthis.assemblers = createAssemblers( this, resultDescriptor, creationState, virtualIdEmbeddable, fetchConverter );\n\t\tfinal Initializer<?>[] initializers = new Initializer[assemblers.length];\n\t\tfinal Initializer<?>[] eagerSubInitializers = new Initializer[assemblers.length];\n\t\tboolean empty = true;\n\t\tboolean emptyEager = true;\n\t\tboolean lazyCapable = false;\n\t\tboolean hasLazySubInitializers = false;\n\t\tfor ( int i = 0; i < assemblers.length; i++ ) {\n\t\t\tfinal Initializer<?> initializer = assemblers[i].getInitializer();\n\t\t\tif ( initializer != null ) {\n\t\t\t\tif ( initializer.isEager() ) {\n\t\t\t\t\teagerSubInitializers[i] = initializer;\n\t\t\t\t\thasLazySubInitializers = hasLazySubInitializers || initializer.hasLazySubInitializers();\n\t\t\t\t\temptyEager = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\thasLazySubInitializers = true;\n\t\t\t\t}\n\t\t\t\tlazyCapable = lazyCapable || initializer.isLazyCapable();\n\t\t\t\tinitializers[i] = initializer;\n\t\t\t\tempty = false;\n\t\t\t}\n\t\t}\n\t\t//noinspection unchecked\n\t\tthis.initializers = (Initializer<InitializerData>[]) (\n\t\t\t\tempty ? Initializer.EMPTY_ARRAY : initializers\n\t\t);\n\t\t// No need to think about bytecode enhancement here, since ids can't contain lazy basic attributes\n\t\tthis.subInitializersForResolveFromInitialized = (Initializer<InitializerData>[]) (\n\t\t\t\temptyEager ? Initializer.EMPTY_ARRAY : initializers\n\t\t);\n\t\tthis.lazyCapable = lazyCapable;\n\t\tthis.hasLazySubInitializer = hasLazySubInitializers;\n\t}\n\n\tprotected static DomainResultAssembler<?>[] createAssemblers(\n\t\t\tInitializerParent<?> parent,\n\t\t\tEmbeddableResultGraphNode resultDescriptor,\n\t\t\tAssemblerCreationState creationState,\n\t\t\tEmbeddableMappingType embeddableTypeDescriptor,\n\t\t\tFunction<Fetch, Fetch> fetchConverter) {\n\t\tfinal int size = embeddableTypeDescriptor.getNumberOfFetchables();\n\t\tfinal DomainResultAssembler<?>[] assemblers = new DomainResultAssembler[size];\n\t\tfor ( int i = 0; i < size; i++ ) {\n\t\t\tfinal Fetchable stateArrayContributor = embeddableTypeDescriptor.getFetchable( i );\n\t\t\tfinal Fetch fetch = fetchConverter.apply( resultDescriptor.findFetch( stateArrayContributor ) );\n\n\t\t\tfinal DomainResultAssembler<?> stateAssembler = fetch == null\n\t\t\t\t\t? new NullValueAssembler<>( stateArrayContributor.getJavaType() )\n\t\t\t\t\t: fetch.createAssembler( parent, creationState );\n\n\t\t\tassemblers[i] = stateAssembler;\n\t\t}\n\t\treturn assemblers;\n\t}\n\n\t@Override\n\tpublic EmbeddableValuedModelPart getInitializedPart() {\n\t\treturn embedded;\n\t}\n\n\t@Override\n\tpublic @Nullable InitializerParent<?> getParent() {\n\t\treturn parent;\n\t}\n\n\t@Override\n\tpublic NavigablePath getNavigablePath() {\n\t\treturn navigablePath;\n\t}\n\n\t@Override\n\tpublic boolean isResultInitializer() {\n\t\treturn isResultInitializer;\n\t}\n\n\t@Override\n\tprotected InitializerData createInitializerData(RowProcessingState rowProcessingState) {\n\t\treturn new NonAggregatedIdentifierMappingInitializerData( this, rowProcessingState );\n\t}\n\n\t@Override\n\tpublic void resolveKey(NonAggregatedIdentifierMappingInitializerData data) {\n\t\tif ( data.getState() != State.UNINITIALIZED ) {\n\t\t\treturn;\n\t\t}\n\t\t// We need to possibly wrap the processing state if the embeddable is within an aggregate\n\t\tdata.setInstance( null );\n\t\tdata.setState( State.KEY_RESOLVED );\n\t\tif ( initializers.length == 0 ) {\n\t\t\t// Resolve the component early to know if the key is missing or not\n\t\t\tresolveInstance( data );\n\t\t}\n\t\telse {\n\t\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\t\tfor ( Initializer<InitializerData> initializer : initializers ) {\n\t\t\t\tif ( initializer != null ) {\n\t\t\t\t\tfinal InitializerData subData = initializer.getData( rowProcessingState );\n\t\t\t\t\tinitializer.resolveKey( subData );\n\t\t\t\t\tif ( subData.getState() == State.MISSING ) {\n\t\t\t\t\t\tdata.setState( State.MISSING );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void resolveInstance(NonAggregatedIdentifierMappingInitializerData data) {\n\t\tif ( data.getState() != State.KEY_RESOLVED ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If we don't have an id class and this is a find by id lookup, we just use that instance\n\t\tif ( data.isFindByIdLookup ) {\n\t\t\tdata.setInstance( data.getRowProcessingState().getEntityId() );\n\t\t\tdata.setState( State.INITIALIZED );\n\t\t\treturn;\n\t\t}\n\t\tdata.setState( State.RESOLVED );\n\t\t// We need to possibly wrap the processing state if the embeddable is within an aggregate\n\t\textractRowState( data );\n\t\tif ( data.getState() == State.MISSING ) {\n\t\t\tdata.setInstance( null );\n\t\t}\n\t\telse {\n\t\t\tdata.setInstance( embeddableInstantiator.instantiate( data, sessionFactory ) );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void resolveInstance(@Nullable Object instance, NonAggregatedIdentifierMappingInitializerData data) {\n\t\tif ( instance == null ) {\n\t\t\tdata.setState( State.MISSING );\n\t\t\tdata.setInstance( null );\n\t\t}\n\t\telse {\n\t\t\tdata.setState( State.INITIALIZED );\n\t\t\tdata.setInstance( instance );\n\t\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\t\tresolveInstanceSubInitializers( instance, rowProcessingState );\n\t\t\tif ( rowProcessingState.needsResolveState() ) {\n\t\t\t\tfor ( DomainResultAssembler<?> assembler : assemblers ) {\n\t\t\t\t\tassembler.resolveState( rowProcessingState );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void resolveInstanceSubInitializers(Object instance, RowProcessingState rowProcessingState) {\n\t\tfor ( int i = 0; i < subInitializersForResolveFromInitialized.length; i++ ) {\n\t\t\tfinal Initializer<InitializerData> initializer = subInitializersForResolveFromInitialized[i];\n\t\t\tif ( initializer != null ) {\n\t\t\t\tfinal Object subInstance = virtualIdEmbeddable.getValue( instance, i );\n\t\t\t\tif ( subInstance == LazyPropertyInitializer.UNFETCHED_PROPERTY ) {\n\t\t\t\t\t// Go through the normal initializer process\n\t\t\t\t\tinitializer.resolveKey( rowProcessingState );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tinitializer.resolveInstance( subInstance, rowProcessingState );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void initializeInstance(NonAggregatedIdentifierMappingInitializerData data) {\n\t\tif ( data.getState() != State.RESOLVED ) {\n\t\t\treturn;\n\t\t}\n\t\tdata.setState( State.INITIALIZED );\n\n\t\tif ( parent != null ) {\n\t\t\tassert parent.isEntityInitializer();\n\t\t\tfinal Object parentInstance = parent.getResolvedInstance( data.getRowProcessingState() );\n\t\t\tassert parentInstance != null;\n\t\t\tfinal LazyInitializer lazyInitializer = HibernateProxy.extractLazyInitializer( parentInstance );\n\t\t\t// If the composite instance has a lazy initializer attached, this means that the embeddable is actually virtual\n\t\t\t// and the compositeInstance == entity, so we have to inject the row state into the entity when it finishes resolution\n\t\t\tif ( lazyInitializer != null ) {\n\t\t\t\tvirtualIdEmbeddable.setValues( lazyInitializer.getImplementation(), data.virtualIdState );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvirtualIdEmbeddable.setValues( parentInstance, data.virtualIdState );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tprotected void forEachSubInitializer(BiConsumer<Initializer<?>, RowProcessingState> consumer, InitializerData data) {\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tfor ( Initializer<?> initializer : initializers ) {\n\t\t\tif ( initializer != null ) {\n\t\t\t\tconsumer.accept( initializer, rowProcessingState );\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void extractRowState(NonAggregatedIdentifierMappingInitializerData data) {\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tfor ( int i = 0; i < assemblers.length; i++ ) {\n\t\t\tfinal Object contributorValue = assemblers[i].assemble( rowProcessingState );\n\n\t\t\tif ( contributorValue == null ) {\n\t\t\t\t// This is a key and there is a null part, the whole thing has to be turned into null\n\t\t\t\tdata.setState( State.MISSING );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( contributorValue == BATCH_PROPERTY ) {\n\t\t\t\tdata.virtualIdState[i] = null;\n\t\t\t\tdata.idClassState[i] = null;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdata.virtualIdState[i] = contributorValue;\n\t\t\t\tdata.idClassState[i] = contributorValue;\n\t\t\t\tif ( hasIdClass ) {\n\t\t\t\t\tfinal AttributeMapping virtualIdAttribute = virtualIdEmbeddable.getAttributeMapping( i );\n\t\t\t\t\tfinal AttributeMapping mappedIdAttribute = representationEmbeddable.getAttributeMapping( i );\n\t\t\t\t\tif ( virtualIdAttribute instanceof ToOneAttributeMapping\n\t\t\t\t\t\t\t&& !( mappedIdAttribute instanceof ToOneAttributeMapping ) ) {\n\t\t\t\t\t\tfinal ToOneAttributeMapping toOneAttributeMapping = (ToOneAttributeMapping) virtualIdAttribute;\n\t\t\t\t\t\tfinal ForeignKeyDescriptor fkDescriptor = toOneAttributeMapping.getForeignKeyDescriptor();\n\t\t\t\t\t\tfinal Object associationKey = fkDescriptor.getAssociationKeyFromSide(\n\t\t\t\t\t\t\t\tdata.virtualIdState[i],\n\t\t\t\t\t\t\t\ttoOneAttributeMapping.getSideNature().inverse(),\n\t\t\t\t\t\t\t\trowProcessingState.getSession()\n\t\t\t\t\t\t);\n\t\t\t\t\t\tdata.idClassState[i] = associationKey;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void resolveState(NonAggregatedIdentifierMappingInitializerData data) {\n\t\tif ( !data.isFindByIdLookup ) {\n\t\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\t\tfor ( final DomainResultAssembler<?> assembler : assemblers ) {\n\t\t\t\tassembler.resolveState( rowProcessingState );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isPartOfKey() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean isEager() {\n\t\t// Embeddables are never lazy\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean isLazyCapable() {\n\t\treturn lazyCapable;\n\t}\n\n\t@Override\n\tpublic boolean hasLazySubInitializers() {\n\t\treturn hasLazySubInitializer;\n\t}\n\n\t/*\n\t * Used by Hibernate Reactive\n\t */\n\tprotected @Nullable Initializer<InitializerData>[] getInitializers() {\n\t\treturn initializers;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"NonAggregatedIdentifierMappingInitializer(\" + navigablePath + \") : `\" + getInitializedPart().getJavaType().getJavaTypeClass() + \"`\";\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/sql/results/graph/embeddable/internal/NonAggregatedIdentifierMappingInitializer.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.sql.results.graph.embeddable.internal;\n\nimport java.util.function.BiConsumer;\nimport java.util.function.Function;\n\nimport org.hibernate.bytecode.enhance.spi.LazyPropertyInitializer;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.metamodel.mapping.AttributeMapping;\nimport org.hibernate.metamodel.mapping.EmbeddableMappingType;\nimport org.hibernate.metamodel.mapping.EmbeddableValuedModelPart;\nimport org.hibernate.metamodel.mapping.ForeignKeyDescriptor;\nimport org.hibernate.metamodel.mapping.NonAggregatedIdentifierMapping;\nimport org.hibernate.metamodel.mapping.internal.ToOneAttributeMapping;\nimport org.hibernate.metamodel.spi.EmbeddableInstantiator;\nimport org.hibernate.metamodel.spi.ValueAccess;\nimport org.hibernate.proxy.HibernateProxy;\nimport org.hibernate.proxy.LazyInitializer;\nimport org.hibernate.spi.EntityIdentifierNavigablePath;\nimport org.hibernate.spi.NavigablePath;\nimport org.hibernate.sql.results.graph.AssemblerCreationState;\nimport org.hibernate.sql.results.graph.DomainResultAssembler;\nimport org.hibernate.sql.results.graph.Fetch;\nimport org.hibernate.sql.results.graph.FetchParent;\nimport org.hibernate.sql.results.graph.Fetchable;\nimport org.hibernate.sql.results.graph.Initializer;\nimport org.hibernate.sql.results.graph.InitializerData;\nimport org.hibernate.sql.results.graph.InitializerParent;\nimport org.hibernate.sql.results.graph.embeddable.EmbeddableInitializer;\nimport org.hibernate.sql.results.graph.embeddable.EmbeddableResultGraphNode;\nimport org.hibernate.sql.results.graph.entity.EntityInitializer;\nimport org.hibernate.sql.results.graph.internal.AbstractInitializer;\nimport org.hibernate.sql.results.internal.NullValueAssembler;\nimport org.hibernate.sql.results.jdbc.spi.RowProcessingState;\n\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport static org.hibernate.sql.results.graph.entity.internal.BatchEntityInsideEmbeddableSelectFetchInitializer.BATCH_PROPERTY;\n\n/**\n * @author Steve Ebersole\n */\npublic class NonAggregatedIdentifierMappingInitializer extends AbstractInitializer<NonAggregatedIdentifierMappingInitializer.NonAggregatedIdentifierMappingInitializerData>\n\t\timplements EmbeddableInitializer<NonAggregatedIdentifierMappingInitializer.NonAggregatedIdentifierMappingInitializerData> {\n\n\tprivate final NavigablePath navigablePath;\n\tprivate final NonAggregatedIdentifierMapping embedded;\n\tprivate final EmbeddableMappingType virtualIdEmbeddable;\n\tprivate final EmbeddableMappingType representationEmbeddable;\n\tprivate final EmbeddableInstantiator embeddableInstantiator;\n\tprivate final @Nullable InitializerParent<?> parent;\n\tprivate final SessionFactoryImplementor sessionFactory;\n\tprivate final boolean isResultInitializer;\n\n\tprivate final DomainResultAssembler<?>[] assemblers;\n\tprivate final @Nullable Initializer<InitializerData>[] initializers;\n\tprivate final @Nullable Initializer<InitializerData>[] subInitializersForResolveFromInitialized;\n\tprivate final @Nullable Initializer<InitializerData>[] collectionContainingSubInitializers;\n\tprivate final boolean lazyCapable;\n\tprivate final boolean hasLazySubInitializer;\n\tprivate final boolean hasIdClass;\n\n\tpublic static class NonAggregatedIdentifierMappingInitializerData extends InitializerData implements ValueAccess {\n\t\tprotected final boolean isFindByIdLookup;\n\t\tprotected final InitializerData parentData;\n\t\tprotected final Object[] virtualIdState;\n\t\tprotected final Object[] idClassState;\n\n\t\tpublic NonAggregatedIdentifierMappingInitializerData(NonAggregatedIdentifierMappingInitializer initializer, RowProcessingState rowProcessingState) {\n\t\t\tsuper( rowProcessingState );\n\t\t\tthis.isFindByIdLookup = !initializer.hasIdClass && rowProcessingState.getEntityId() != null\n\t\t\t\t\t&& initializer.navigablePath.getParent().getParent() == null\n\t\t\t\t\t&& initializer.navigablePath instanceof EntityIdentifierNavigablePath;\n\t\t\tthis.parentData = initializer.parent == null ? null : initializer.parent.getData( rowProcessingState );\n\t\t\tfinal EmbeddableMappingType virtualIdEmbeddable = initializer.embedded.getEmbeddableTypeDescriptor();\n\t\t\tfinal int size = virtualIdEmbeddable.getNumberOfFetchables();\n\t\t\tthis.virtualIdState = new Object[ size ];\n\t\t\tthis.idClassState = new Object[ size ];\n\t\t}\n\n\t\t@Override\n\t\tpublic Object[] getValues() {\n\t\t\tassert getState() == State.RESOLVED;\n\t\t\treturn idClassState;\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T getValue(int i, Class<T> clazz) {\n\t\t\tassert getState() == State.RESOLVED;\n\t\t\treturn clazz.cast( idClassState[i] );\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getOwner() {\n\t\t\treturn parentData == null ? null : parentData.getInstance();\n\t\t}\n\t}\n\n\tpublic NonAggregatedIdentifierMappingInitializer(\n\t\t\tEmbeddableResultGraphNode resultDescriptor,\n\t\t\tInitializerParent<?> parent,\n\t\t\tAssemblerCreationState creationState,\n\t\t\tboolean isResultInitializer) {\n\t\tthis( resultDescriptor, parent, creationState, isResultInitializer, Function.identity() );\n\t}\n\n\tprotected NonAggregatedIdentifierMappingInitializer(\n\t\t\tEmbeddableResultGraphNode resultDescriptor,\n\t\t\tInitializerParent<?> parent,\n\t\t\tAssemblerCreationState creationState,\n\t\t\tboolean isResultInitializer,\n\t\t\tFunction<Fetch, Fetch> fetchConverter) {\n\t\tsuper( creationState );\n\t\tthis.navigablePath = resultDescriptor.getNavigablePath();\n\t\tthis.embedded = (NonAggregatedIdentifierMapping) resultDescriptor.getReferencedMappingContainer();\n\t\tthis.parent = parent;\n\t\tthis.isResultInitializer = isResultInitializer;\n\n\t\tthis.virtualIdEmbeddable = embedded.getEmbeddableTypeDescriptor();\n\t\tthis.representationEmbeddable = embedded.getMappedIdEmbeddableTypeDescriptor();\n\t\tthis.embeddableInstantiator = representationEmbeddable.getRepresentationStrategy().getInstantiator();\n\t\tthis.hasIdClass = embedded.hasContainingClass() && virtualIdEmbeddable != representationEmbeddable;\n\n\t\tthis.sessionFactory = creationState.getSqlAstCreationContext().getSessionFactory();\n\n\t\tfinal int size = virtualIdEmbeddable.getNumberOfFetchables();\n\t\tfinal DomainResultAssembler<?>[] assemblers = new DomainResultAssembler[size];\n\t\tthis.assemblers = assemblers;\n\t\tfinal Initializer<?>[] initializers = new Initializer[assemblers.length];\n\t\tfinal Initializer<?>[] eagerSubInitializers = new Initializer[assemblers.length];\n\t\tfinal Initializer<?>[] collectionContainingSubInitializers = new Initializer[assemblers.length];\n\t\tboolean empty = true;\n\t\tboolean emptyEager = true;\n\t\tboolean emptyCollectionInitializers = true;\n\t\tboolean lazyCapable = false;\n\t\tboolean hasLazySubInitializers = false;\n\t\tfor ( int i = 0; i < size; i++ ) {\n\t\t\tfinal Fetchable stateArrayContributor = virtualIdEmbeddable.getFetchable( i );\n\t\t\tfinal Fetch fetch = fetchConverter.apply( resultDescriptor.findFetch( stateArrayContributor ) );\n\n\t\t\tfinal DomainResultAssembler<?> stateAssembler = fetch == null\n\t\t\t\t\t? new NullValueAssembler<>( stateArrayContributor.getJavaType() )\n\t\t\t\t\t: fetch.createAssembler( this, creationState );\n\n\t\t\tassemblers[i] = stateAssembler;\n\n\t\t\tfinal Initializer<?> initializer = stateAssembler.getInitializer();\n\t\t\tif ( initializer != null ) {\n\t\t\t\tif ( initializer.isEager() ) {\n\t\t\t\t\teagerSubInitializers[i] = initializer;\n\t\t\t\t\thasLazySubInitializers = hasLazySubInitializers || initializer.hasLazySubInitializers();\n\t\t\t\t\temptyEager = false;\n\t\t\t\t\tassert fetch != null;\n\t\t\t\t\tfinal FetchParent fetchParent;\n\t\t\t\t\tif ( ( fetchParent = fetch.asFetchParent() ) != null && fetchParent.containsCollectionFetches()\n\t\t\t\t\t\t\t|| initializer.isCollectionInitializer() ) {\n\t\t\t\t\t\tcollectionContainingSubInitializers[i] = initializer;\n\t\t\t\t\t\temptyCollectionInitializers = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\thasLazySubInitializers = true;\n\t\t\t\t}\n\t\t\t\tlazyCapable = lazyCapable || initializer.isLazyCapable();\n\t\t\t\tinitializers[i] = initializer;\n\t\t\t\tempty = false;\n\t\t\t}\n\t\t}\n\t\t//noinspection unchecked\n\t\tthis.initializers = (Initializer<InitializerData>[]) (\n\t\t\t\tempty ? Initializer.EMPTY_ARRAY : initializers\n\t\t);\n\t\t// No need to think about bytecode enhancement here, since ids can't contain lazy basic attributes\n\t\t//noinspection unchecked\n\t\tthis.subInitializersForResolveFromInitialized = (Initializer<InitializerData>[]) (\n\t\t\t\temptyEager ? Initializer.EMPTY_ARRAY : initializers\n\t\t);\n\t\t//noinspection unchecked\n\t\tthis.collectionContainingSubInitializers = (Initializer<InitializerData>[]) (\n\t\t\t\temptyCollectionInitializers ? Initializer.EMPTY_ARRAY : collectionContainingSubInitializers\n\t\t);\n\t\tthis.lazyCapable = lazyCapable;\n\t\tthis.hasLazySubInitializer = hasLazySubInitializers;\n\t}\n\n\t@Override\n\tpublic EmbeddableValuedModelPart getInitializedPart() {\n\t\treturn embedded;\n\t}\n\n\t@Override\n\tpublic @Nullable InitializerParent<?> getParent() {\n\t\treturn parent;\n\t}\n\n\t@Override\n\tpublic NavigablePath getNavigablePath() {\n\t\treturn navigablePath;\n\t}\n\n\t@Override\n\tpublic boolean isResultInitializer() {\n\t\treturn isResultInitializer;\n\t}\n\n\t@Override\n\tprotected InitializerData createInitializerData(RowProcessingState rowProcessingState) {\n\t\treturn new NonAggregatedIdentifierMappingInitializerData( this, rowProcessingState );\n\t}\n\n\t@Override\n\tpublic void resolveKey(NonAggregatedIdentifierMappingInitializerData data) {\n\t\tif ( data.getState() != State.UNINITIALIZED ) {\n\t\t\treturn;\n\t\t}\n\t\tdata.setInstance( null );\n\t\tdata.setState( State.KEY_RESOLVED );\n\t\tif ( initializers.length == 0 ) {\n\t\t\t// Resolve the component early to know if the key is missing or not\n\t\t\tresolveInstance( data );\n\t\t}\n\t\telse {\n\t\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\t\tfor ( Initializer<InitializerData> initializer : initializers ) {\n\t\t\t\tif ( initializer != null ) {\n\t\t\t\t\tfinal InitializerData subData = initializer.getData( rowProcessingState );\n\t\t\t\t\tinitializer.resolveKey( subData );\n\t\t\t\t\tif ( subData.getState() == State.MISSING ) {\n\t\t\t\t\t\tdata.setState( State.MISSING );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void resetResolvedEntityRegistrations(RowProcessingState rowProcessingState) {\n\t\tfinal NonAggregatedIdentifierMappingInitializerData data = getData( rowProcessingState );\n\t\tfor ( Initializer<InitializerData> initializer : initializers ) {\n\t\t\tif ( initializer != null ) {\n\t\t\t\tfinal EntityInitializer<?> entityInitializer = initializer.asEntityInitializer();\n\t\t\t\tfinal EmbeddableInitializer<?> embeddableInitializer;\n\t\t\t\tif ( entityInitializer != null ) {\n\t\t\t\t\tentityInitializer.resetResolvedEntityRegistrations( rowProcessingState );\n\t\t\t\t}\n\t\t\t\telse if ( ( embeddableInitializer = initializer.asEmbeddableInitializer() ) != null ) {\n\t\t\t\t\tembeddableInitializer.resetResolvedEntityRegistrations( rowProcessingState );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void resolveFromPreviousRow(NonAggregatedIdentifierMappingInitializerData data) {\n\t\tif ( data.getState() == State.UNINITIALIZED ) {\n\t\t\tif ( data.getInstance() == null ) {\n\t\t\t\tdata.setState( State.MISSING );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\t\t\t// When a previous row initialized this entity already, we only need to process collections\n\t\t\t\tfor ( Initializer<InitializerData> initializer : collectionContainingSubInitializers ) {\n\t\t\t\t\tif ( initializer != null ) {\n\t\t\t\t\t\tinitializer.resolveFromPreviousRow( rowProcessingState );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdata.setState( State.INITIALIZED );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void resolveInstance(NonAggregatedIdentifierMappingInitializerData data) {\n\t\tif ( data.getState() != State.KEY_RESOLVED ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If we don't have an id class and this is a find by id lookup, we just use that instance\n\t\tif ( data.isFindByIdLookup ) {\n\t\t\tdata.setInstance( data.getRowProcessingState().getEntityId() );\n\t\t\tdata.setState( State.INITIALIZED );\n\t\t\treturn;\n\t\t}\n\t\tdata.setState( State.RESOLVED );\n\t\t// We need to possibly wrap the processing state if the embeddable is within an aggregate\n\t\textractRowState( data );\n\t\tif ( data.getState() == State.MISSING ) {\n\t\t\tdata.setInstance( null );\n\t\t}\n\t\telse {\n\t\t\tdata.setInstance( embeddableInstantiator.instantiate( data, sessionFactory ) );\n\t\t}\n\t\tif ( parent == null ) {\n\t\t\tdata.setState( State.INITIALIZED );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void resolveInstance(@Nullable Object instance, NonAggregatedIdentifierMappingInitializerData data) {\n\t\tif ( instance == null ) {\n\t\t\tdata.setState( State.MISSING );\n\t\t\tdata.setInstance( null );\n\t\t}\n\t\telse {\n\t\t\tdata.setState( State.INITIALIZED );\n\t\t\tdata.setInstance( instance );\n\t\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\t\tresolveInstanceSubInitializers( instance, rowProcessingState );\n\t\t\tif ( rowProcessingState.needsResolveState() ) {\n\t\t\t\tfor ( DomainResultAssembler<?> assembler : assemblers ) {\n\t\t\t\t\tassembler.resolveState( rowProcessingState );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void resolveInstanceSubInitializers(Object instance, RowProcessingState rowProcessingState) {\n\t\tfor ( int i = 0; i < subInitializersForResolveFromInitialized.length; i++ ) {\n\t\t\tfinal Initializer<InitializerData> initializer = subInitializersForResolveFromInitialized[i];\n\t\t\tif ( initializer != null ) {\n\t\t\t\tfinal Object subInstance = virtualIdEmbeddable.getValue( instance, i );\n\t\t\t\tif ( subInstance == LazyPropertyInitializer.UNFETCHED_PROPERTY ) {\n\t\t\t\t\t// Go through the normal initializer process\n\t\t\t\t\tinitializer.resolveKey( rowProcessingState );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tinitializer.resolveInstance( subInstance, rowProcessingState );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void initializeInstance(NonAggregatedIdentifierMappingInitializerData data) {\n\t\tif ( data.getState() != State.RESOLVED ) {\n\t\t\treturn;\n\t\t}\n\t\tdata.setState( State.INITIALIZED );\n\n\t\tif ( parent != null ) {\n\t\t\tassert parent.isEntityInitializer();\n\t\t\tfinal Object parentInstance = parent.getResolvedInstance( data.getRowProcessingState() );\n\t\t\tassert parentInstance != null;\n\t\t\tfinal LazyInitializer lazyInitializer = HibernateProxy.extractLazyInitializer( parentInstance );\n\t\t\t// If the composite instance has a lazy initializer attached, this means that the embeddable is actually virtual\n\t\t\t// and the compositeInstance == entity, so we have to inject the row state into the entity when it finishes resolution\n\t\t\tif ( lazyInitializer != null ) {\n\t\t\t\tvirtualIdEmbeddable.setValues( lazyInitializer.getImplementation(), data.virtualIdState );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvirtualIdEmbeddable.setValues( parentInstance, data.virtualIdState );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tprotected void forEachSubInitializer(BiConsumer<Initializer<?>, RowProcessingState> consumer, InitializerData data) {\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tfor ( Initializer<?> initializer : initializers ) {\n\t\t\tif ( initializer != null ) {\n\t\t\t\tconsumer.accept( initializer, rowProcessingState );\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void extractRowState(NonAggregatedIdentifierMappingInitializerData data) {\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tfor ( int i = 0; i < assemblers.length; i++ ) {\n\t\t\tfinal Object contributorValue = assemblers[i].assemble( rowProcessingState );\n\n\t\t\tif ( contributorValue == null ) {\n\t\t\t\t// This is a key and there is a null part, the whole thing has to be turned into null\n\t\t\t\tdata.setState( State.MISSING );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( contributorValue == BATCH_PROPERTY ) {\n\t\t\t\tdata.virtualIdState[i] = null;\n\t\t\t\tdata.idClassState[i] = null;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdata.virtualIdState[i] = contributorValue;\n\t\t\t\tdata.idClassState[i] = contributorValue;\n\t\t\t\tif ( hasIdClass ) {\n\t\t\t\t\tfinal AttributeMapping virtualIdAttribute = virtualIdEmbeddable.getAttributeMapping( i );\n\t\t\t\t\tfinal AttributeMapping mappedIdAttribute = representationEmbeddable.getAttributeMapping( i );\n\t\t\t\t\tif ( virtualIdAttribute instanceof ToOneAttributeMapping\n\t\t\t\t\t\t\t&& !( mappedIdAttribute instanceof ToOneAttributeMapping ) ) {\n\t\t\t\t\t\tfinal ToOneAttributeMapping toOneAttributeMapping = (ToOneAttributeMapping) virtualIdAttribute;\n\t\t\t\t\t\tfinal ForeignKeyDescriptor fkDescriptor = toOneAttributeMapping.getForeignKeyDescriptor();\n\t\t\t\t\t\tfinal Object associationKey = fkDescriptor.getAssociationKeyFromSide(\n\t\t\t\t\t\t\t\tdata.virtualIdState[i],\n\t\t\t\t\t\t\t\ttoOneAttributeMapping.getSideNature().inverse(),\n\t\t\t\t\t\t\t\trowProcessingState.getSession()\n\t\t\t\t\t\t);\n\t\t\t\t\t\tdata.idClassState[i] = associationKey;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void resolveState(NonAggregatedIdentifierMappingInitializerData data) {\n\t\tif ( !data.isFindByIdLookup ) {\n\t\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\t\tfor ( final DomainResultAssembler<?> assembler : assemblers ) {\n\t\t\t\tassembler.resolveState( rowProcessingState );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isPartOfKey() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean isEager() {\n\t\t// Embeddables are never lazy\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean isLazyCapable() {\n\t\treturn lazyCapable;\n\t}\n\n\t@Override\n\tpublic boolean hasLazySubInitializers() {\n\t\treturn hasLazySubInitializer;\n\t}\n\n\t/*\n\t * Used by Hibernate Reactive\n\t */\n\tprotected @Nullable Initializer<InitializerData>[] getInitializers() {\n\t\treturn initializers;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"NonAggregatedIdentifierMappingInitializer(\" + navigablePath + \") : `\" + getInitializedPart().getJavaType().getJavaTypeClass() + \"`\";\n\t}\n}\n",
        "diffSourceCodeSet": [],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.metamodel.mapping.internal.AbstractEmbeddableMapping#getFetchable\n methodBody: public Fetchable getFetchable(int position) {\nreturn getAttributeMappings().get(position);\n}",
            "methodSignature: org.hibernate.metamodel.mapping.internal.AbstractEmbeddableMapping#getNumberOfFetchables\n methodBody: public int getNumberOfFetchables() {\nreturn getAttributeMappings().size();\n}"
        ],
        "sourceCodeAfterRefactoring": "protected NonAggregatedIdentifierMappingInitializer(\n\t\t\tEmbeddableResultGraphNode resultDescriptor,\n\t\t\tInitializerParent<?> parent,\n\t\t\tAssemblerCreationState creationState,\n\t\t\tboolean isResultInitializer,\n\t\t\tFunction<Fetch, Fetch> fetchConverter) {\n\t\tsuper( creationState );\n\t\tthis.navigablePath = resultDescriptor.getNavigablePath();\n\t\tthis.embedded = (NonAggregatedIdentifierMapping) resultDescriptor.getReferencedMappingContainer();\n\t\tthis.parent = parent;\n\t\tthis.isResultInitializer = isResultInitializer;\n\n\t\tthis.virtualIdEmbeddable = embedded.getEmbeddableTypeDescriptor();\n\t\tthis.representationEmbeddable = embedded.getMappedIdEmbeddableTypeDescriptor();\n\t\tthis.embeddableInstantiator = representationEmbeddable.getRepresentationStrategy().getInstantiator();\n\t\tthis.hasIdClass = embedded.hasContainingClass() && virtualIdEmbeddable != representationEmbeddable;\n\n\t\tthis.sessionFactory = creationState.getSqlAstCreationContext().getSessionFactory();\n\n\t\tfinal int size = virtualIdEmbeddable.getNumberOfFetchables();\n\t\tfinal DomainResultAssembler<?>[] assemblers = new DomainResultAssembler[size];\n\t\tthis.assemblers = assemblers;\n\t\tfinal Initializer<?>[] initializers = new Initializer[assemblers.length];\n\t\tfinal Initializer<?>[] eagerSubInitializers = new Initializer[assemblers.length];\n\t\tfinal Initializer<?>[] collectionContainingSubInitializers = new Initializer[assemblers.length];\n\t\tboolean empty = true;\n\t\tboolean emptyEager = true;\n\t\tboolean emptyCollectionInitializers = true;\n\t\tboolean lazyCapable = false;\n\t\tboolean hasLazySubInitializers = false;\n\t\tfor ( int i = 0; i < size; i++ ) {\n\t\t\tfinal Fetchable stateArrayContributor = virtualIdEmbeddable.getFetchable( i );\n\t\t\tfinal Fetch fetch = fetchConverter.apply( resultDescriptor.findFetch( stateArrayContributor ) );\n\n\t\t\tfinal DomainResultAssembler<?> stateAssembler = fetch == null\n\t\t\t\t\t? new NullValueAssembler<>( stateArrayContributor.getJavaType() )\n\t\t\t\t\t: fetch.createAssembler( this, creationState );\n\n\t\t\tassemblers[i] = stateAssembler;\n\n\t\t\tfinal Initializer<?> initializer = stateAssembler.getInitializer();\n\t\t\tif ( initializer != null ) {\n\t\t\t\tif ( initializer.isEager() ) {\n\t\t\t\t\teagerSubInitializers[i] = initializer;\n\t\t\t\t\thasLazySubInitializers = hasLazySubInitializers || initializer.hasLazySubInitializers();\n\t\t\t\t\temptyEager = false;\n\t\t\t\t\tassert fetch != null;\n\t\t\t\t\tfinal FetchParent fetchParent;\n\t\t\t\t\tif ( ( fetchParent = fetch.asFetchParent() ) != null && fetchParent.containsCollectionFetches()\n\t\t\t\t\t\t\t|| initializer.isCollectionInitializer() ) {\n\t\t\t\t\t\tcollectionContainingSubInitializers[i] = initializer;\n\t\t\t\t\t\temptyCollectionInitializers = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\thasLazySubInitializers = true;\n\t\t\t\t}\n\t\t\t\tlazyCapable = lazyCapable || initializer.isLazyCapable();\n\t\t\t\tinitializers[i] = initializer;\n\t\t\t\tempty = false;\n\t\t\t}\n\t\t}\n\t\t//noinspection unchecked\n\t\tthis.initializers = (Initializer<InitializerData>[]) (\n\t\t\t\tempty ? Initializer.EMPTY_ARRAY : initializers\n\t\t);\n\t\t// No need to think about bytecode enhancement here, since ids can't contain lazy basic attributes\n\t\t//noinspection unchecked\n\t\tthis.subInitializersForResolveFromInitialized = (Initializer<InitializerData>[]) (\n\t\t\t\temptyEager ? Initializer.EMPTY_ARRAY : initializers\n\t\t);\n\t\t//noinspection unchecked\n\t\tthis.collectionContainingSubInitializers = (Initializer<InitializerData>[]) (\n\t\t\t\temptyCollectionInitializers ? Initializer.EMPTY_ARRAY : collectionContainingSubInitializers\n\t\t);\n\t\tthis.lazyCapable = lazyCapable;\n\t\tthis.hasLazySubInitializer = hasLazySubInitializers;\n\t}",
        "diffSourceCode": "-  109: \tprotected NonAggregatedIdentifierMappingInitializer(\n-  110: \t\t\tEmbeddableResultGraphNode resultDescriptor,\n-  111: \t\t\tInitializerParent<?> parent,\n-  112: \t\t\tAssemblerCreationState creationState,\n-  113: \t\t\tboolean isResultInitializer,\n-  114: \t\t\tFunction<Fetch, Fetch> fetchConverter) {\n-  115: \t\tsuper( creationState );\n-  116: \t\tthis.navigablePath = resultDescriptor.getNavigablePath();\n-  117: \t\tthis.embedded = (NonAggregatedIdentifierMapping) resultDescriptor.getReferencedMappingContainer();\n-  118: \t\tthis.parent = parent;\n-  119: \t\tthis.isResultInitializer = isResultInitializer;\n-  120: \n-  121: \t\tthis.virtualIdEmbeddable = embedded.getEmbeddableTypeDescriptor();\n-  122: \t\tthis.representationEmbeddable = embedded.getMappedIdEmbeddableTypeDescriptor();\n-  123: \t\tthis.embeddableInstantiator = representationEmbeddable.getRepresentationStrategy().getInstantiator();\n-  124: \t\tthis.hasIdClass = embedded.hasContainingClass() && virtualIdEmbeddable != representationEmbeddable;\n-  125: \n-  126: \t\tthis.sessionFactory = creationState.getSqlAstCreationContext().getSessionFactory();\n-  127: \t\tthis.assemblers = createAssemblers( this, resultDescriptor, creationState, virtualIdEmbeddable, fetchConverter );\n-  128: \t\tfinal Initializer<?>[] initializers = new Initializer[assemblers.length];\n-  129: \t\tfinal Initializer<?>[] eagerSubInitializers = new Initializer[assemblers.length];\n-  130: \t\tboolean empty = true;\n-  131: \t\tboolean emptyEager = true;\n-  132: \t\tboolean lazyCapable = false;\n-  133: \t\tboolean hasLazySubInitializers = false;\n-  134: \t\tfor ( int i = 0; i < assemblers.length; i++ ) {\n-  135: \t\t\tfinal Initializer<?> initializer = assemblers[i].getInitializer();\n-  136: \t\t\tif ( initializer != null ) {\n-  137: \t\t\t\tif ( initializer.isEager() ) {\n-  138: \t\t\t\t\teagerSubInitializers[i] = initializer;\n-  139: \t\t\t\t\thasLazySubInitializers = hasLazySubInitializers || initializer.hasLazySubInitializers();\n-  140: \t\t\t\t\temptyEager = false;\n-  141: \t\t\t\t}\n-  142: \t\t\t\telse {\n-  143: \t\t\t\t\thasLazySubInitializers = true;\n-  144: \t\t\t\t}\n-  145: \t\t\t\tlazyCapable = lazyCapable || initializer.isLazyCapable();\n-  146: \t\t\t\tinitializers[i] = initializer;\n-  147: \t\t\t\tempty = false;\n-  148: \t\t\t}\n-  149: \t\t}\n-  150: \t\t//noinspection unchecked\n-  151: \t\tthis.initializers = (Initializer<InitializerData>[]) (\n-  152: \t\t\t\tempty ? Initializer.EMPTY_ARRAY : initializers\n-  153: \t\t);\n-  154: \t\t// No need to think about bytecode enhancement here, since ids can't contain lazy basic attributes\n-  155: \t\tthis.subInitializersForResolveFromInitialized = (Initializer<InitializerData>[]) (\n-  156: \t\t\t\temptyEager ? Initializer.EMPTY_ARRAY : initializers\n-  157: \t\t);\n-  158: \t\tthis.lazyCapable = lazyCapable;\n-  159: \t\tthis.hasLazySubInitializer = hasLazySubInitializers;\n-  160: \t}\n-  161: \n-  162: \tprotected static DomainResultAssembler<?>[] createAssemblers(\n-  163: \t\t\tInitializerParent<?> parent,\n-  164: \t\t\tEmbeddableResultGraphNode resultDescriptor,\n-  165: \t\t\tAssemblerCreationState creationState,\n-  166: \t\t\tEmbeddableMappingType embeddableTypeDescriptor,\n-  167: \t\t\tFunction<Fetch, Fetch> fetchConverter) {\n-  168: \t\tfinal int size = embeddableTypeDescriptor.getNumberOfFetchables();\n-  169: \t\tfinal DomainResultAssembler<?>[] assemblers = new DomainResultAssembler[size];\n-  170: \t\tfor ( int i = 0; i < size; i++ ) {\n-  171: \t\t\tfinal Fetchable stateArrayContributor = embeddableTypeDescriptor.getFetchable( i );\n-  172: \t\t\tfinal Fetch fetch = fetchConverter.apply( resultDescriptor.findFetch( stateArrayContributor ) );\n-  173: \n-  174: \t\t\tfinal DomainResultAssembler<?> stateAssembler = fetch == null\n-  175: \t\t\t\t\t? new NullValueAssembler<>( stateArrayContributor.getJavaType() )\n-  176: \t\t\t\t\t: fetch.createAssembler( parent, creationState );\n-  177: \n-  178: \t\t\tassemblers[i] = stateAssembler;\n-  179: \t\t}\n-  180: \t\treturn assemblers;\n-  181: \t}\n-  182: \n-  183: \t@Override\n-  184: \tpublic EmbeddableValuedModelPart getInitializedPart() {\n-  185: \t\treturn embedded;\n-  186: \t}\n-  187: \n-  188: \t@Override\n-  189: \tpublic @Nullable InitializerParent<?> getParent() {\n+  109: \t\tthis( resultDescriptor, parent, creationState, isResultInitializer, Function.identity() );\n+  110: \t}\n+  111: \n+  112: \tprotected NonAggregatedIdentifierMappingInitializer(\n+  113: \t\t\tEmbeddableResultGraphNode resultDescriptor,\n+  114: \t\t\tInitializerParent<?> parent,\n+  115: \t\t\tAssemblerCreationState creationState,\n+  116: \t\t\tboolean isResultInitializer,\n+  117: \t\t\tFunction<Fetch, Fetch> fetchConverter) {\n+  118: \t\tsuper( creationState );\n+  119: \t\tthis.navigablePath = resultDescriptor.getNavigablePath();\n+  120: \t\tthis.embedded = (NonAggregatedIdentifierMapping) resultDescriptor.getReferencedMappingContainer();\n+  121: \t\tthis.parent = parent;\n+  122: \t\tthis.isResultInitializer = isResultInitializer;\n+  123: \n+  124: \t\tthis.virtualIdEmbeddable = embedded.getEmbeddableTypeDescriptor();\n+  125: \t\tthis.representationEmbeddable = embedded.getMappedIdEmbeddableTypeDescriptor();\n+  126: \t\tthis.embeddableInstantiator = representationEmbeddable.getRepresentationStrategy().getInstantiator();\n+  127: \t\tthis.hasIdClass = embedded.hasContainingClass() && virtualIdEmbeddable != representationEmbeddable;\n+  128: \n+  129: \t\tthis.sessionFactory = creationState.getSqlAstCreationContext().getSessionFactory();\n+  130: \n+  131: \t\tfinal int size = virtualIdEmbeddable.getNumberOfFetchables();\n+  132: \t\tfinal DomainResultAssembler<?>[] assemblers = new DomainResultAssembler[size];\n+  133: \t\tthis.assemblers = assemblers;\n+  134: \t\tfinal Initializer<?>[] initializers = new Initializer[assemblers.length];\n+  135: \t\tfinal Initializer<?>[] eagerSubInitializers = new Initializer[assemblers.length];\n+  136: \t\tfinal Initializer<?>[] collectionContainingSubInitializers = new Initializer[assemblers.length];\n+  137: \t\tboolean empty = true;\n+  138: \t\tboolean emptyEager = true;\n+  139: \t\tboolean emptyCollectionInitializers = true;\n+  140: \t\tboolean lazyCapable = false;\n+  141: \t\tboolean hasLazySubInitializers = false;\n+  142: \t\tfor ( int i = 0; i < size; i++ ) {\n+  143: \t\t\tfinal Fetchable stateArrayContributor = virtualIdEmbeddable.getFetchable( i );\n+  144: \t\t\tfinal Fetch fetch = fetchConverter.apply( resultDescriptor.findFetch( stateArrayContributor ) );\n+  145: \n+  146: \t\t\tfinal DomainResultAssembler<?> stateAssembler = fetch == null\n+  147: \t\t\t\t\t? new NullValueAssembler<>( stateArrayContributor.getJavaType() )\n+  148: \t\t\t\t\t: fetch.createAssembler( this, creationState );\n+  149: \n+  150: \t\t\tassemblers[i] = stateAssembler;\n+  151: \n+  152: \t\t\tfinal Initializer<?> initializer = stateAssembler.getInitializer();\n+  153: \t\t\tif ( initializer != null ) {\n+  154: \t\t\t\tif ( initializer.isEager() ) {\n+  155: \t\t\t\t\teagerSubInitializers[i] = initializer;\n+  156: \t\t\t\t\thasLazySubInitializers = hasLazySubInitializers || initializer.hasLazySubInitializers();\n+  157: \t\t\t\t\temptyEager = false;\n+  158: \t\t\t\t\tassert fetch != null;\n+  159: \t\t\t\t\tfinal FetchParent fetchParent;\n+  160: \t\t\t\t\tif ( ( fetchParent = fetch.asFetchParent() ) != null && fetchParent.containsCollectionFetches()\n+  161: \t\t\t\t\t\t\t|| initializer.isCollectionInitializer() ) {\n+  162: \t\t\t\t\t\tcollectionContainingSubInitializers[i] = initializer;\n+  163: \t\t\t\t\t\temptyCollectionInitializers = false;\n+  164: \t\t\t\t\t}\n+  165: \t\t\t\t}\n+  166: \t\t\t\telse {\n+  167: \t\t\t\t\thasLazySubInitializers = true;\n+  168: \t\t\t\t}\n+  169: \t\t\t\tlazyCapable = lazyCapable || initializer.isLazyCapable();\n+  170: \t\t\t\tinitializers[i] = initializer;\n+  171: \t\t\t\tempty = false;\n+  172: \t\t\t}\n+  173: \t\t}\n+  174: \t\t//noinspection unchecked\n+  175: \t\tthis.initializers = (Initializer<InitializerData>[]) (\n+  176: \t\t\t\tempty ? Initializer.EMPTY_ARRAY : initializers\n+  177: \t\t);\n+  178: \t\t// No need to think about bytecode enhancement here, since ids can't contain lazy basic attributes\n+  179: \t\t//noinspection unchecked\n+  180: \t\tthis.subInitializersForResolveFromInitialized = (Initializer<InitializerData>[]) (\n+  181: \t\t\t\temptyEager ? Initializer.EMPTY_ARRAY : initializers\n+  182: \t\t);\n+  183: \t\t//noinspection unchecked\n+  184: \t\tthis.collectionContainingSubInitializers = (Initializer<InitializerData>[]) (\n+  185: \t\t\t\temptyCollectionInitializers ? Initializer.EMPTY_ARRAY : collectionContainingSubInitializers\n+  186: \t\t);\n+  187: \t\tthis.lazyCapable = lazyCapable;\n+  188: \t\tthis.hasLazySubInitializer = hasLazySubInitializers;\n+  189: \t}\n",
        "uniqueId": "f8a6106ea20df36dc5c07827948a04b77243c1a6_109_160__112_189_162_181",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 6,
                "covered": 37
            },
            "BRANCH": {
                "missed": 1,
                "covered": 3
            },
            "LINE": {
                "missed": 1,
                "covered": 9
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 2
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\nprotected static DomainResultAssembler<?>[] createAssemblers(\n\t\t\tInitializerParent<?> parent,\n\t\t\tEmbeddableResultGraphNode resultDescriptor,\n\t\t\tAssemblerCreationState creationState,\n\t\t\tEmbeddableMappingType embeddableTypeDescriptor,\n\t\t\tFunction<Fetch, Fetch> fetchConverter) {\n\t\tfinal int size = embeddableTypeDescriptor.getNumberOfFetchables();\n\t\tfinal DomainResultAssembler<?>[] assemblers = new DomainResultAssembler[size];\n\t\tfor ( int i = 0; i < size; i++ ) {\n\t\t\tfinal Fetchable stateArrayContributor = embeddableTypeDescriptor.getFetchable( i );\n\t\t\tfinal Fetch fetch = fetchConverter.apply( resultDescriptor.findFetch( stateArrayContributor ) );\n\n\t\t\tfinal DomainResultAssembler<?> stateAssembler = fetch == null\n\t\t\t\t\t? new NullValueAssembler<>( stateArrayContributor.getJavaType() )\n\t\t\t\t\t: fetch.createAssembler( parent, creationState );\n\n\t\t\tassemblers[i] = stateAssembler;\n\t\t}\n\t\treturn assemblers;\n\t}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprotected static DomainResultAssembler<?>[] createAssemblers(\n\t\t\tInitializerParent<?> parent,\n\t\t\tEmbeddableResultGraphNode resultDescriptor,\n\t\t\tAssemblerCreationState creationState,\n\t\t\tEmbeddableMappingType embeddableTypeDescriptor,\n\t\t\tFunction<Fetch, Fetch> fetchConverter) {\n\t\tfinal int size = embeddableTypeDescriptor.getNumberOfFetchables();\n\t\tfinal DomainResultAssembler<?>[] assemblers = new DomainResultAssembler[size];\n\t\tfor ( int i = 0; i < size; i++ ) {\n\t\t\tfinal Fetchable stateArrayContributor = embeddableTypeDescriptor.getFetchable( i );\n\t\t\tfinal Fetch fetch = fetchConverter.apply( resultDescriptor.findFetch( stateArrayContributor ) );\n\n\t\t\tfinal DomainResultAssembler<?> stateAssembler = fetch == null\n\t\t\t\t\t? new NullValueAssembler<>( stateArrayContributor.getJavaType() )\n\t\t\t\t\t: fetch.createAssembler( parent, creationState );\n\n\t\t\tassemblers[i] = stateAssembler;\n\t\t}\n\t\treturn assemblers;\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.sql.results.graph.embeddable.internal;\n\nimport java.util.function.BiConsumer;\nimport java.util.function.Function;\n\nimport org.hibernate.bytecode.enhance.spi.LazyPropertyInitializer;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.metamodel.mapping.AttributeMapping;\nimport org.hibernate.metamodel.mapping.EmbeddableMappingType;\nimport org.hibernate.metamodel.mapping.EmbeddableValuedModelPart;\nimport org.hibernate.metamodel.mapping.ForeignKeyDescriptor;\nimport org.hibernate.metamodel.mapping.NonAggregatedIdentifierMapping;\nimport org.hibernate.metamodel.mapping.internal.ToOneAttributeMapping;\nimport org.hibernate.metamodel.spi.EmbeddableInstantiator;\nimport org.hibernate.metamodel.spi.ValueAccess;\nimport org.hibernate.proxy.HibernateProxy;\nimport org.hibernate.proxy.LazyInitializer;\nimport org.hibernate.spi.EntityIdentifierNavigablePath;\nimport org.hibernate.spi.NavigablePath;\nimport org.hibernate.sql.results.graph.AssemblerCreationState;\nimport org.hibernate.sql.results.graph.DomainResultAssembler;\nimport org.hibernate.sql.results.graph.Fetch;\nimport org.hibernate.sql.results.graph.Fetchable;\nimport org.hibernate.sql.results.graph.Initializer;\nimport org.hibernate.sql.results.graph.InitializerData;\nimport org.hibernate.sql.results.graph.InitializerParent;\nimport org.hibernate.sql.results.graph.embeddable.EmbeddableInitializer;\nimport org.hibernate.sql.results.graph.embeddable.EmbeddableResultGraphNode;\nimport org.hibernate.sql.results.graph.internal.AbstractInitializer;\nimport org.hibernate.sql.results.internal.NullValueAssembler;\nimport org.hibernate.sql.results.jdbc.spi.RowProcessingState;\n\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\nimport static org.hibernate.sql.results.graph.entity.internal.BatchEntityInsideEmbeddableSelectFetchInitializer.BATCH_PROPERTY;\n\n/**\n * @author Steve Ebersole\n */\npublic class NonAggregatedIdentifierMappingInitializer extends AbstractInitializer<NonAggregatedIdentifierMappingInitializer.NonAggregatedIdentifierMappingInitializerData>\n\t\timplements EmbeddableInitializer<NonAggregatedIdentifierMappingInitializer.NonAggregatedIdentifierMappingInitializerData> {\n\n\tprivate final NavigablePath navigablePath;\n\tprivate final NonAggregatedIdentifierMapping embedded;\n\tprivate final EmbeddableMappingType virtualIdEmbeddable;\n\tprivate final EmbeddableMappingType representationEmbeddable;\n\tprivate final EmbeddableInstantiator embeddableInstantiator;\n\tprivate final @Nullable InitializerParent<?> parent;\n\tprivate final SessionFactoryImplementor sessionFactory;\n\tprivate final boolean isResultInitializer;\n\n\tprivate final DomainResultAssembler<?>[] assemblers;\n\tprivate final @Nullable Initializer<InitializerData>[] initializers;\n\tprivate final @Nullable Initializer<InitializerData>[] subInitializersForResolveFromInitialized;\n\tprivate final boolean lazyCapable;\n\tprivate final boolean hasLazySubInitializer;\n\tprivate final boolean hasIdClass;\n\n\tpublic static class NonAggregatedIdentifierMappingInitializerData extends InitializerData implements ValueAccess {\n\t\tprotected final boolean isFindByIdLookup;\n\t\tprotected final InitializerData parentData;\n\t\tprotected final Object[] virtualIdState;\n\t\tprotected final Object[] idClassState;\n\n\t\tpublic NonAggregatedIdentifierMappingInitializerData(NonAggregatedIdentifierMappingInitializer initializer, RowProcessingState rowProcessingState) {\n\t\t\tsuper( rowProcessingState );\n\t\t\tthis.isFindByIdLookup = !initializer.hasIdClass && rowProcessingState.getEntityId() != null\n\t\t\t\t\t&& initializer.navigablePath.getParent().getParent() == null\n\t\t\t\t\t&& initializer.navigablePath instanceof EntityIdentifierNavigablePath;\n\t\t\tthis.parentData = initializer.parent == null ? null : initializer.parent.getData( rowProcessingState );\n\t\t\tfinal EmbeddableMappingType virtualIdEmbeddable = initializer.embedded.getEmbeddableTypeDescriptor();\n\t\t\tfinal int size = virtualIdEmbeddable.getNumberOfFetchables();\n\t\t\tthis.virtualIdState = new Object[ size ];\n\t\t\tthis.idClassState = new Object[ size ];\n\t\t}\n\n\t\t@Override\n\t\tpublic Object[] getValues() {\n\t\t\tassert getState() == State.RESOLVED;\n\t\t\treturn idClassState;\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T getValue(int i, Class<T> clazz) {\n\t\t\tassert getState() == State.RESOLVED;\n\t\t\treturn clazz.cast( idClassState[i] );\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getOwner() {\n\t\t\treturn parentData == null ? null : parentData.getInstance();\n\t\t}\n\t}\n\n\tpublic NonAggregatedIdentifierMappingInitializer(\n\t\t\tEmbeddableResultGraphNode resultDescriptor,\n\t\t\tInitializerParent<?> parent,\n\t\t\tAssemblerCreationState creationState,\n\t\t\tboolean isResultInitializer) {\n\t\tthis( resultDescriptor, parent, creationState, isResultInitializer, Function.identity() );\n\t}\n\n\tprotected NonAggregatedIdentifierMappingInitializer(\n\t\t\tEmbeddableResultGraphNode resultDescriptor,\n\t\t\tInitializerParent<?> parent,\n\t\t\tAssemblerCreationState creationState,\n\t\t\tboolean isResultInitializer,\n\t\t\tFunction<Fetch, Fetch> fetchConverter) {\n\t\tsuper( creationState );\n\t\tthis.navigablePath = resultDescriptor.getNavigablePath();\n\t\tthis.embedded = (NonAggregatedIdentifierMapping) resultDescriptor.getReferencedMappingContainer();\n\t\tthis.parent = parent;\n\t\tthis.isResultInitializer = isResultInitializer;\n\n\t\tthis.virtualIdEmbeddable = embedded.getEmbeddableTypeDescriptor();\n\t\tthis.representationEmbeddable = embedded.getMappedIdEmbeddableTypeDescriptor();\n\t\tthis.embeddableInstantiator = representationEmbeddable.getRepresentationStrategy().getInstantiator();\n\t\tthis.hasIdClass = embedded.hasContainingClass() && virtualIdEmbeddable != representationEmbeddable;\n\n\t\tthis.sessionFactory = creationState.getSqlAstCreationContext().getSessionFactory();\n\t\tthis.assemblers = createAssemblers( this, resultDescriptor, creationState, virtualIdEmbeddable, fetchConverter );\n\t\tfinal Initializer<?>[] initializers = new Initializer[assemblers.length];\n\t\tfinal Initializer<?>[] eagerSubInitializers = new Initializer[assemblers.length];\n\t\tboolean empty = true;\n\t\tboolean emptyEager = true;\n\t\tboolean lazyCapable = false;\n\t\tboolean hasLazySubInitializers = false;\n\t\tfor ( int i = 0; i < assemblers.length; i++ ) {\n\t\t\tfinal Initializer<?> initializer = assemblers[i].getInitializer();\n\t\t\tif ( initializer != null ) {\n\t\t\t\tif ( initializer.isEager() ) {\n\t\t\t\t\teagerSubInitializers[i] = initializer;\n\t\t\t\t\thasLazySubInitializers = hasLazySubInitializers || initializer.hasLazySubInitializers();\n\t\t\t\t\temptyEager = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\thasLazySubInitializers = true;\n\t\t\t\t}\n\t\t\t\tlazyCapable = lazyCapable || initializer.isLazyCapable();\n\t\t\t\tinitializers[i] = initializer;\n\t\t\t\tempty = false;\n\t\t\t}\n\t\t}\n\t\t//noinspection unchecked\n\t\tthis.initializers = (Initializer<InitializerData>[]) (\n\t\t\t\tempty ? Initializer.EMPTY_ARRAY : initializers\n\t\t);\n\t\t// No need to think about bytecode enhancement here, since ids can't contain lazy basic attributes\n\t\tthis.subInitializersForResolveFromInitialized = (Initializer<InitializerData>[]) (\n\t\t\t\temptyEager ? Initializer.EMPTY_ARRAY : initializers\n\t\t);\n\t\tthis.lazyCapable = lazyCapable;\n\t\tthis.hasLazySubInitializer = hasLazySubInitializers;\n\t}\n\n\tprotected static DomainResultAssembler<?>[] createAssemblers(\n\t\t\tInitializerParent<?> parent,\n\t\t\tEmbeddableResultGraphNode resultDescriptor,\n\t\t\tAssemblerCreationState creationState,\n\t\t\tEmbeddableMappingType embeddableTypeDescriptor,\n\t\t\tFunction<Fetch, Fetch> fetchConverter) {\n\t\tfinal int size = embeddableTypeDescriptor.getNumberOfFetchables();\n\t\tfinal DomainResultAssembler<?>[] assemblers = new DomainResultAssembler[size];\n\t\tfor ( int i = 0; i < size; i++ ) {\n\t\t\tfinal Fetchable stateArrayContributor = embeddableTypeDescriptor.getFetchable( i );\n\t\t\tfinal Fetch fetch = fetchConverter.apply( resultDescriptor.findFetch( stateArrayContributor ) );\n\n\t\t\tfinal DomainResultAssembler<?> stateAssembler = fetch == null\n\t\t\t\t\t? new NullValueAssembler<>( stateArrayContributor.getJavaType() )\n\t\t\t\t\t: fetch.createAssembler( parent, creationState );\n\n\t\t\tassemblers[i] = stateAssembler;\n\t\t}\n\t\treturn assemblers;\n\t}\n\n\t@Override\n\tpublic EmbeddableValuedModelPart getInitializedPart() {\n\t\treturn embedded;\n\t}\n\n\t@Override\n\tpublic @Nullable InitializerParent<?> getParent() {\n\t\treturn parent;\n\t}\n\n\t@Override\n\tpublic NavigablePath getNavigablePath() {\n\t\treturn navigablePath;\n\t}\n\n\t@Override\n\tpublic boolean isResultInitializer() {\n\t\treturn isResultInitializer;\n\t}\n\n\t@Override\n\tprotected InitializerData createInitializerData(RowProcessingState rowProcessingState) {\n\t\treturn new NonAggregatedIdentifierMappingInitializerData( this, rowProcessingState );\n\t}\n\n\t@Override\n\tpublic void resolveKey(NonAggregatedIdentifierMappingInitializerData data) {\n\t\tif ( data.getState() != State.UNINITIALIZED ) {\n\t\t\treturn;\n\t\t}\n\t\t// We need to possibly wrap the processing state if the embeddable is within an aggregate\n\t\tdata.setInstance( null );\n\t\tdata.setState( State.KEY_RESOLVED );\n\t\tif ( initializers.length == 0 ) {\n\t\t\t// Resolve the component early to know if the key is missing or not\n\t\t\tresolveInstance( data );\n\t\t}\n\t\telse {\n\t\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\t\tfor ( Initializer<InitializerData> initializer : initializers ) {\n\t\t\t\tif ( initializer != null ) {\n\t\t\t\t\tfinal InitializerData subData = initializer.getData( rowProcessingState );\n\t\t\t\t\tinitializer.resolveKey( subData );\n\t\t\t\t\tif ( subData.getState() == State.MISSING ) {\n\t\t\t\t\t\tdata.setState( State.MISSING );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void resolveInstance(NonAggregatedIdentifierMappingInitializerData data) {\n\t\tif ( data.getState() != State.KEY_RESOLVED ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If we don't have an id class and this is a find by id lookup, we just use that instance\n\t\tif ( data.isFindByIdLookup ) {\n\t\t\tdata.setInstance( data.getRowProcessingState().getEntityId() );\n\t\t\tdata.setState( State.INITIALIZED );\n\t\t\treturn;\n\t\t}\n\t\tdata.setState( State.RESOLVED );\n\t\t// We need to possibly wrap the processing state if the embeddable is within an aggregate\n\t\textractRowState( data );\n\t\tif ( data.getState() == State.MISSING ) {\n\t\t\tdata.setInstance( null );\n\t\t}\n\t\telse {\n\t\t\tdata.setInstance( embeddableInstantiator.instantiate( data, sessionFactory ) );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void resolveInstance(@Nullable Object instance, NonAggregatedIdentifierMappingInitializerData data) {\n\t\tif ( instance == null ) {\n\t\t\tdata.setState( State.MISSING );\n\t\t\tdata.setInstance( null );\n\t\t}\n\t\telse {\n\t\t\tdata.setState( State.INITIALIZED );\n\t\t\tdata.setInstance( instance );\n\t\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\t\tresolveInstanceSubInitializers( instance, rowProcessingState );\n\t\t\tif ( rowProcessingState.needsResolveState() ) {\n\t\t\t\tfor ( DomainResultAssembler<?> assembler : assemblers ) {\n\t\t\t\t\tassembler.resolveState( rowProcessingState );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void resolveInstanceSubInitializers(Object instance, RowProcessingState rowProcessingState) {\n\t\tfor ( int i = 0; i < subInitializersForResolveFromInitialized.length; i++ ) {\n\t\t\tfinal Initializer<InitializerData> initializer = subInitializersForResolveFromInitialized[i];\n\t\t\tif ( initializer != null ) {\n\t\t\t\tfinal Object subInstance = virtualIdEmbeddable.getValue( instance, i );\n\t\t\t\tif ( subInstance == LazyPropertyInitializer.UNFETCHED_PROPERTY ) {\n\t\t\t\t\t// Go through the normal initializer process\n\t\t\t\t\tinitializer.resolveKey( rowProcessingState );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tinitializer.resolveInstance( subInstance, rowProcessingState );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void initializeInstance(NonAggregatedIdentifierMappingInitializerData data) {\n\t\tif ( data.getState() != State.RESOLVED ) {\n\t\t\treturn;\n\t\t}\n\t\tdata.setState( State.INITIALIZED );\n\n\t\tif ( parent != null ) {\n\t\t\tassert parent.isEntityInitializer();\n\t\t\tfinal Object parentInstance = parent.getResolvedInstance( data.getRowProcessingState() );\n\t\t\tassert parentInstance != null;\n\t\t\tfinal LazyInitializer lazyInitializer = HibernateProxy.extractLazyInitializer( parentInstance );\n\t\t\t// If the composite instance has a lazy initializer attached, this means that the embeddable is actually virtual\n\t\t\t// and the compositeInstance == entity, so we have to inject the row state into the entity when it finishes resolution\n\t\t\tif ( lazyInitializer != null ) {\n\t\t\t\tvirtualIdEmbeddable.setValues( lazyInitializer.getImplementation(), data.virtualIdState );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvirtualIdEmbeddable.setValues( parentInstance, data.virtualIdState );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tprotected void forEachSubInitializer(BiConsumer<Initializer<?>, RowProcessingState> consumer, InitializerData data) {\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tfor ( Initializer<?> initializer : initializers ) {\n\t\t\tif ( initializer != null ) {\n\t\t\t\tconsumer.accept( initializer, rowProcessingState );\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void extractRowState(NonAggregatedIdentifierMappingInitializerData data) {\n\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\tfor ( int i = 0; i < assemblers.length; i++ ) {\n\t\t\tfinal Object contributorValue = assemblers[i].assemble( rowProcessingState );\n\n\t\t\tif ( contributorValue == null ) {\n\t\t\t\t// This is a key and there is a null part, the whole thing has to be turned into null\n\t\t\t\tdata.setState( State.MISSING );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( contributorValue == BATCH_PROPERTY ) {\n\t\t\t\tdata.virtualIdState[i] = null;\n\t\t\t\tdata.idClassState[i] = null;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdata.virtualIdState[i] = contributorValue;\n\t\t\t\tdata.idClassState[i] = contributorValue;\n\t\t\t\tif ( hasIdClass ) {\n\t\t\t\t\tfinal AttributeMapping virtualIdAttribute = virtualIdEmbeddable.getAttributeMapping( i );\n\t\t\t\t\tfinal AttributeMapping mappedIdAttribute = representationEmbeddable.getAttributeMapping( i );\n\t\t\t\t\tif ( virtualIdAttribute instanceof ToOneAttributeMapping\n\t\t\t\t\t\t\t&& !( mappedIdAttribute instanceof ToOneAttributeMapping ) ) {\n\t\t\t\t\t\tfinal ToOneAttributeMapping toOneAttributeMapping = (ToOneAttributeMapping) virtualIdAttribute;\n\t\t\t\t\t\tfinal ForeignKeyDescriptor fkDescriptor = toOneAttributeMapping.getForeignKeyDescriptor();\n\t\t\t\t\t\tfinal Object associationKey = fkDescriptor.getAssociationKeyFromSide(\n\t\t\t\t\t\t\t\tdata.virtualIdState[i],\n\t\t\t\t\t\t\t\ttoOneAttributeMapping.getSideNature().inverse(),\n\t\t\t\t\t\t\t\trowProcessingState.getSession()\n\t\t\t\t\t\t);\n\t\t\t\t\t\tdata.idClassState[i] = associationKey;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void resolveState(NonAggregatedIdentifierMappingInitializerData data) {\n\t\tif ( !data.isFindByIdLookup ) {\n\t\t\tfinal RowProcessingState rowProcessingState = data.getRowProcessingState();\n\t\t\tfor ( final DomainResultAssembler<?> assembler : assemblers ) {\n\t\t\t\tassembler.resolveState( rowProcessingState );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isPartOfKey() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean isEager() {\n\t\t// Embeddables are never lazy\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean isLazyCapable() {\n\t\treturn lazyCapable;\n\t}\n\n\t@Override\n\tpublic boolean hasLazySubInitializers() {\n\t\treturn hasLazySubInitializer;\n\t}\n\n\t/*\n\t * Used by Hibernate Reactive\n\t */\n\tprotected @Nullable Initializer<InitializerData>[] getInitializers() {\n\t\treturn initializers;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"NonAggregatedIdentifierMappingInitializer(\" + navigablePath + \") : `\" + getInitializedPart().getJavaType().getJavaTypeClass() + \"`\";\n\t}\n}\n\nRefactoring Operation:\nInline Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored class code in the following format:\n##########################\nrefactored_class_code\n##########################\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tpublic needsResolve() : boolean extracted from public resolve(jdbcResultsMetadata JdbcValuesMetadata, sessionFactory SessionFactoryImplementor) : SqlSelection in class org.hibernate.sql.results.internal.SqlSelectionImpl",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/results/internal/SqlSelectionImpl.java",
                "startLine": 152,
                "endLine": 168,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/results/internal/SqlSelectionImpl.java",
                "startLine": 156,
                "endLine": 172,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/results/internal/SqlSelectionImpl.java",
                "startLine": 152,
                "endLine": 154,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic SqlSelection resolve(JdbcValuesMetadata jdbcResultsMetadata, SessionFactoryImplementor sessionFactory) {\n\t\tif ( sqlExpression.getExpressionType() instanceof JavaObjectType ) {\n\t\t\tfinal BasicType<Object> resolvedType = jdbcResultsMetadata.resolveType(\n\t\t\t\t\tjdbcPosition,\n\t\t\t\t\tnull,\n\t\t\t\t\tsessionFactory\n\t\t\t);\n\t\t\treturn new ResolvedSqlSelection(\n\t\t\t\t\tjdbcPosition,\n\t\t\t\t\tvaluesArrayPosition,\n\t\t\t\t\tsqlExpression,\n\t\t\t\t\tresolvedType\n\t\t\t);\n\t\t}\n\t\treturn this;\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/sql/results/internal/SqlSelectionImpl.java",
        "isPureRefactoring": true,
        "commitId": "e9513b1db5553cec8e8bfb3a095fc3d903a747b5",
        "packageNameBefore": "org.hibernate.sql.results.internal",
        "classNameBefore": "org.hibernate.sql.results.internal.SqlSelectionImpl",
        "methodNameBefore": "org.hibernate.sql.results.internal.SqlSelectionImpl#resolve",
        "invokedMethod": "methodSignature: org.hibernate.sql.exec.internal.JdbcSelectExecutorStandardImpl.CachedJdbcValuesMetadata#resolveType\n methodBody: public <J> BasicType<J> resolveType(\n\t\t\t\tint position,\n\t\t\t\tJavaType<J> explicitJavaType,\n\t\t\t\tTypeConfiguration typeConfiguration) {\nfinal BasicType<?> type=types[position - 1];\nif(type == null){throw new IllegalStateException(\"Unexpected resolving of unavailable column at position: \" + position);\n}if(explicitJavaType == null || type.getJavaTypeDescriptor() == explicitJavaType){return (BasicType<J>)type;\n}{return typeConfiguration.getBasicTypeRegistry().resolve(explicitJavaType,type.getJdbcType());\n}}\nmethodSignature: org.hibernate.sql.exec.internal.JdbcSelectExecutorStandardImpl.CapturingJdbcValuesMetadata#resolveType\n methodBody: public <J> BasicType<J> resolveType(\n\t\t\t\tint position,\n\t\t\t\tJavaType<J> explicitJavaType,\n\t\t\t\tTypeConfiguration typeConfiguration) {\nif(columnNames == null){initializeArrays();\n}final BasicType<J> basicType=resultSetAccess.resolveType(position,explicitJavaType,typeConfiguration);\ntypes[position - 1]=basicType;\nreturn basicType;\n}\nmethodSignature: org.hibernate.sql.results.internal.SqlSelectionImpl#getExpressionType\n methodBody: public JdbcMappingContainer getExpressionType() {\nreturn getExpression().getExpressionType();\n}",
        "classSignatureBefore": "public class SqlSelectionImpl implements SqlSelection, SqlExpressionAccess ",
        "methodNameBeforeSet": [
            "org.hibernate.sql.results.internal.SqlSelectionImpl#resolve"
        ],
        "classNameBeforeSet": [
            "org.hibernate.sql.results.internal.SqlSelectionImpl"
        ],
        "classSignatureBeforeSet": [
            "public class SqlSelectionImpl implements SqlSelection, SqlExpressionAccess "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.sql.results.internal;\n\nimport java.util.Objects;\n\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.metamodel.mapping.JdbcMapping;\nimport org.hibernate.metamodel.mapping.JdbcMappingContainer;\nimport org.hibernate.sql.ast.SqlAstWalker;\nimport org.hibernate.sql.ast.spi.SqlExpressionAccess;\nimport org.hibernate.sql.ast.spi.SqlSelection;\nimport org.hibernate.sql.ast.tree.expression.Expression;\nimport org.hibernate.sql.results.jdbc.spi.JdbcValuesMetadata;\nimport org.hibernate.type.BasicType;\nimport org.hibernate.type.JavaObjectType;\nimport org.hibernate.type.descriptor.ValueExtractor;\nimport org.hibernate.type.descriptor.java.JavaType;\n\n/**\n * @asciidoc\n *\n * ```\n * @Entity\n * class MyEntity {\n *     ...\n *     @Column ( name = \"the_column\", ... )\n *     public String getTheColumn() { ... }\n *\n *     @Convert ( ... )\n *     @Column ( name = \"the_column\", ... )\n *     ConvertedType getTheConvertedColumn() { ... }\n *\n * }\n * ```\n *\n * @author Steve Ebersole\n */\npublic class SqlSelectionImpl implements SqlSelection, SqlExpressionAccess {\n\tprivate final int jdbcPosition;\n\tprivate final int valuesArrayPosition;\n\tprivate final Expression sqlExpression;\n\tprivate final JavaType<?> jdbcJavaType;\n\tprivate final boolean virtual;\n\tprivate transient ValueExtractor valueExtractor;\n\n\tpublic SqlSelectionImpl(Expression sqlExpression) {\n\t\tthis( 0, -1, null, sqlExpression, false );\n\t}\n\n\tpublic SqlSelectionImpl(int valuesArrayPosition, Expression sqlExpression) {\n\t\tthis( valuesArrayPosition + 1, valuesArrayPosition, null, sqlExpression, false );\n\t}\n\n\tpublic SqlSelectionImpl(int jdbcPosition, int valuesArrayPosition, Expression sqlExpression, boolean virtual) {\n\t\tthis( jdbcPosition, valuesArrayPosition, null, sqlExpression, virtual );\n\t}\n\n\tpublic SqlSelectionImpl(\n\t\t\tint jdbcPosition,\n\t\t\tint valuesArrayPosition,\n\t\t\tJavaType<?> jdbcJavaType,\n\t\t\tExpression sqlExpression,\n\t\t\tboolean virtual) {\n\t\tthis(\n\t\t\t\tjdbcPosition,\n\t\t\t\tvaluesArrayPosition,\n\t\t\t\tsqlExpression,\n\t\t\t\tjdbcJavaType,\n\t\t\t\tvirtual,\n\t\t\t\tnull\n\t\t);\n\t}\n\n\tprotected SqlSelectionImpl(\n\t\t\tint jdbcPosition,\n\t\t\tint valuesArrayPosition,\n\t\t\tExpression sqlExpression,\n\t\t\tJavaType<?> jdbcJavaType,\n\t\t\tboolean virtual,\n\t\t\tValueExtractor valueExtractor) {\n\t\tthis.jdbcPosition = jdbcPosition;\n\t\tthis.valuesArrayPosition = valuesArrayPosition;\n\t\tthis.sqlExpression = sqlExpression;\n\t\tthis.jdbcJavaType = jdbcJavaType;\n\t\tthis.virtual = virtual;\n\t\tthis.valueExtractor = valueExtractor;\n\t}\n\n\tprivate static ValueExtractor determineValueExtractor(Expression sqlExpression, JavaType<?> jdbcJavaType) {\n\t\tfinal JdbcMappingContainer expressionType = sqlExpression.getExpressionType();\n\t\tfinal JdbcMapping jdbcMapping = expressionType == null\n\t\t\t\t? JavaObjectType.INSTANCE\n\t\t\t\t: expressionType.getSingleJdbcMapping();\n\t\tif ( jdbcJavaType == null || jdbcMapping.getMappedJavaType() == jdbcJavaType ) {\n\t\t\treturn jdbcMapping.getJdbcValueExtractor();\n\t\t}\n\t\telse {\n\t\t\treturn jdbcMapping.getJdbcType().getExtractor( jdbcJavaType );\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic Expression getExpression() {\n\t\treturn sqlExpression;\n\t}\n\n\t@Override\n\tpublic ValueExtractor getJdbcValueExtractor() {\n\t\tValueExtractor extractor = valueExtractor;\n\t\tif ( extractor == null ) {\n\t\t\tvalueExtractor = extractor = determineValueExtractor( sqlExpression, jdbcJavaType );\n\t\t}\n\t\treturn extractor;\n\t}\n\n\t@Override\n\tpublic int getJdbcResultSetIndex() {\n\t\treturn jdbcPosition;\n\t}\n\n\t@Override\n\tpublic int getValuesArrayPosition() {\n\t\treturn valuesArrayPosition;\n\t}\n\n\t@Override\n\tpublic JdbcMappingContainer getExpressionType() {\n\t\treturn getExpression().getExpressionType();\n\t}\n\n\t@Override\n\tpublic boolean isVirtual() {\n\t\treturn virtual;\n\t}\n\n\t@Override\n\tpublic Expression getSqlExpression() {\n\t\treturn sqlExpression;\n\t}\n\n\t@Override\n\tpublic void accept(SqlAstWalker interpreter) {\n\t\tsqlExpression.accept( interpreter );\n\t}\n\n\t@Override\n\tpublic SqlSelection resolve(JdbcValuesMetadata jdbcResultsMetadata, SessionFactoryImplementor sessionFactory) {\n\t\tif ( sqlExpression.getExpressionType() instanceof JavaObjectType ) {\n\t\t\tfinal BasicType<Object> resolvedType = jdbcResultsMetadata.resolveType(\n\t\t\t\t\tjdbcPosition,\n\t\t\t\t\tnull,\n\t\t\t\t\tsessionFactory\n\t\t\t);\n\t\t\treturn new ResolvedSqlSelection(\n\t\t\t\t\tjdbcPosition,\n\t\t\t\t\tvaluesArrayPosition,\n\t\t\t\t\tsqlExpression,\n\t\t\t\t\tresolvedType\n\t\t\t);\n\t\t}\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif ( this == o ) {\n\t\t\treturn true;\n\t\t}\n\t\tif ( o == null || getClass() != o.getClass() ) {\n\t\t\treturn false;\n\t\t}\n\t\tfinal SqlSelection that = (SqlSelection) o;\n\t\treturn jdbcPosition == that.getJdbcResultSetIndex() &&\n\t\t\t\tvaluesArrayPosition == that.getValuesArrayPosition() &&\n\t\t\t\tObjects.equals( sqlExpression, that.getExpression() ) &&\n\t\t\t\tvirtual == that.isVirtual();\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn Objects.hash( jdbcPosition, valuesArrayPosition, sqlExpression, virtual );\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/sql/results/internal/SqlSelectionImpl.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.sql.results.internal;\n\nimport java.util.Objects;\n\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.metamodel.mapping.JdbcMapping;\nimport org.hibernate.metamodel.mapping.JdbcMappingContainer;\nimport org.hibernate.sql.ast.SqlAstWalker;\nimport org.hibernate.sql.ast.spi.SqlExpressionAccess;\nimport org.hibernate.sql.ast.spi.SqlSelection;\nimport org.hibernate.sql.ast.tree.expression.Expression;\nimport org.hibernate.sql.results.jdbc.spi.JdbcValuesMetadata;\nimport org.hibernate.type.BasicType;\nimport org.hibernate.type.JavaObjectType;\nimport org.hibernate.type.descriptor.ValueExtractor;\nimport org.hibernate.type.descriptor.java.JavaType;\n\n/**\n * @asciidoc\n *\n * ```\n * @Entity\n * class MyEntity {\n *     ...\n *     @Column ( name = \"the_column\", ... )\n *     public String getTheColumn() { ... }\n *\n *     @Convert ( ... )\n *     @Column ( name = \"the_column\", ... )\n *     ConvertedType getTheConvertedColumn() { ... }\n *\n * }\n * ```\n *\n * @author Steve Ebersole\n */\npublic class SqlSelectionImpl implements SqlSelection, SqlExpressionAccess {\n\tprivate final int jdbcPosition;\n\tprivate final int valuesArrayPosition;\n\tprivate final Expression sqlExpression;\n\tprivate final JavaType<?> jdbcJavaType;\n\tprivate final boolean virtual;\n\tprivate transient ValueExtractor valueExtractor;\n\n\tpublic SqlSelectionImpl(Expression sqlExpression) {\n\t\tthis( 0, -1, null, sqlExpression, false );\n\t}\n\n\tpublic SqlSelectionImpl(int valuesArrayPosition, Expression sqlExpression) {\n\t\tthis( valuesArrayPosition + 1, valuesArrayPosition, null, sqlExpression, false );\n\t}\n\n\tpublic SqlSelectionImpl(int jdbcPosition, int valuesArrayPosition, Expression sqlExpression, boolean virtual) {\n\t\tthis( jdbcPosition, valuesArrayPosition, null, sqlExpression, virtual );\n\t}\n\n\tpublic SqlSelectionImpl(\n\t\t\tint jdbcPosition,\n\t\t\tint valuesArrayPosition,\n\t\t\tJavaType<?> jdbcJavaType,\n\t\t\tExpression sqlExpression,\n\t\t\tboolean virtual) {\n\t\tthis(\n\t\t\t\tjdbcPosition,\n\t\t\t\tvaluesArrayPosition,\n\t\t\t\tsqlExpression,\n\t\t\t\tjdbcJavaType,\n\t\t\t\tvirtual,\n\t\t\t\tnull\n\t\t);\n\t}\n\n\tprotected SqlSelectionImpl(\n\t\t\tint jdbcPosition,\n\t\t\tint valuesArrayPosition,\n\t\t\tExpression sqlExpression,\n\t\t\tJavaType<?> jdbcJavaType,\n\t\t\tboolean virtual,\n\t\t\tValueExtractor valueExtractor) {\n\t\tthis.jdbcPosition = jdbcPosition;\n\t\tthis.valuesArrayPosition = valuesArrayPosition;\n\t\tthis.sqlExpression = sqlExpression;\n\t\tthis.jdbcJavaType = jdbcJavaType;\n\t\tthis.virtual = virtual;\n\t\tthis.valueExtractor = valueExtractor;\n\t}\n\n\tprivate static ValueExtractor determineValueExtractor(Expression sqlExpression, JavaType<?> jdbcJavaType) {\n\t\tfinal JdbcMappingContainer expressionType = sqlExpression.getExpressionType();\n\t\tfinal JdbcMapping jdbcMapping = expressionType == null\n\t\t\t\t? JavaObjectType.INSTANCE\n\t\t\t\t: expressionType.getSingleJdbcMapping();\n\t\tif ( jdbcJavaType == null || jdbcMapping.getMappedJavaType() == jdbcJavaType ) {\n\t\t\treturn jdbcMapping.getJdbcValueExtractor();\n\t\t}\n\t\telse {\n\t\t\treturn jdbcMapping.getJdbcType().getExtractor( jdbcJavaType );\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic Expression getExpression() {\n\t\treturn sqlExpression;\n\t}\n\n\t@Override\n\tpublic ValueExtractor getJdbcValueExtractor() {\n\t\tValueExtractor extractor = valueExtractor;\n\t\tif ( extractor == null ) {\n\t\t\tvalueExtractor = extractor = determineValueExtractor( sqlExpression, jdbcJavaType );\n\t\t}\n\t\treturn extractor;\n\t}\n\n\t@Override\n\tpublic int getJdbcResultSetIndex() {\n\t\treturn jdbcPosition;\n\t}\n\n\t@Override\n\tpublic int getValuesArrayPosition() {\n\t\treturn valuesArrayPosition;\n\t}\n\n\t@Override\n\tpublic JdbcMappingContainer getExpressionType() {\n\t\treturn getExpression().getExpressionType();\n\t}\n\n\t@Override\n\tpublic boolean isVirtual() {\n\t\treturn virtual;\n\t}\n\n\t@Override\n\tpublic Expression getSqlExpression() {\n\t\treturn sqlExpression;\n\t}\n\n\t@Override\n\tpublic void accept(SqlAstWalker interpreter) {\n\t\tsqlExpression.accept( interpreter );\n\t}\n\n\tpublic boolean needsResolve() {\n\t\treturn sqlExpression.getExpressionType() instanceof JavaObjectType;\n\t}\n\n\t@Override\n\tpublic SqlSelection resolve(JdbcValuesMetadata jdbcResultsMetadata, SessionFactoryImplementor sessionFactory) {\n\t\tif ( needsResolve() ) {\n\t\t\tfinal BasicType<Object> resolvedType = jdbcResultsMetadata.resolveType(\n\t\t\t\t\tjdbcPosition,\n\t\t\t\t\tnull,\n\t\t\t\t\tsessionFactory\n\t\t\t);\n\t\t\treturn new ResolvedSqlSelection(\n\t\t\t\t\tjdbcPosition,\n\t\t\t\t\tvaluesArrayPosition,\n\t\t\t\t\tsqlExpression,\n\t\t\t\t\tresolvedType\n\t\t\t);\n\t\t}\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif ( this == o ) {\n\t\t\treturn true;\n\t\t}\n\t\tif ( o == null || getClass() != o.getClass() ) {\n\t\t\treturn false;\n\t\t}\n\t\tfinal SqlSelection that = (SqlSelection) o;\n\t\treturn jdbcPosition == that.getJdbcResultSetIndex() &&\n\t\t\t\tvaluesArrayPosition == that.getValuesArrayPosition() &&\n\t\t\t\tObjects.equals( sqlExpression, that.getExpression() ) &&\n\t\t\t\tvirtual == that.isVirtual();\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn Objects.hash( jdbcPosition, valuesArrayPosition, sqlExpression, virtual );\n\t}\n}\n",
        "diffSourceCodeSet": [
            "public boolean needsResolve() {\n\t\treturn sqlExpression.getExpressionType() instanceof JavaObjectType;\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.sql.exec.internal.JdbcSelectExecutorStandardImpl.CachedJdbcValuesMetadata#resolveType\n methodBody: public <J> BasicType<J> resolveType(\n\t\t\t\tint position,\n\t\t\t\tJavaType<J> explicitJavaType,\n\t\t\t\tTypeConfiguration typeConfiguration) {\nfinal BasicType<?> type=types[position - 1];\nif(type == null){throw new IllegalStateException(\"Unexpected resolving of unavailable column at position: \" + position);\n}if(explicitJavaType == null || type.getJavaTypeDescriptor() == explicitJavaType){return (BasicType<J>)type;\n}{return typeConfiguration.getBasicTypeRegistry().resolve(explicitJavaType,type.getJdbcType());\n}}",
            "methodSignature: org.hibernate.sql.exec.internal.JdbcSelectExecutorStandardImpl.CapturingJdbcValuesMetadata#resolveType\n methodBody: public <J> BasicType<J> resolveType(\n\t\t\t\tint position,\n\t\t\t\tJavaType<J> explicitJavaType,\n\t\t\t\tTypeConfiguration typeConfiguration) {\nif(columnNames == null){initializeArrays();\n}final BasicType<J> basicType=resultSetAccess.resolveType(position,explicitJavaType,typeConfiguration);\ntypes[position - 1]=basicType;\nreturn basicType;\n}",
            "methodSignature: org.hibernate.sql.results.internal.SqlSelectionImpl#getExpressionType\n methodBody: public JdbcMappingContainer getExpressionType() {\nreturn getExpression().getExpressionType();\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\tpublic SqlSelection resolve(JdbcValuesMetadata jdbcResultsMetadata, SessionFactoryImplementor sessionFactory) {\n\t\tif ( needsResolve() ) {\n\t\t\tfinal BasicType<Object> resolvedType = jdbcResultsMetadata.resolveType(\n\t\t\t\t\tjdbcPosition,\n\t\t\t\t\tnull,\n\t\t\t\t\tsessionFactory\n\t\t\t);\n\t\t\treturn new ResolvedSqlSelection(\n\t\t\t\t\tjdbcPosition,\n\t\t\t\t\tvaluesArrayPosition,\n\t\t\t\t\tsqlExpression,\n\t\t\t\t\tresolvedType\n\t\t\t);\n\t\t}\n\t\treturn this;\n\t}\npublic boolean needsResolve() {\n\t\treturn sqlExpression.getExpressionType() instanceof JavaObjectType;\n\t}",
        "diffSourceCode": "-  152: \t@Override\n-  153: \tpublic SqlSelection resolve(JdbcValuesMetadata jdbcResultsMetadata, SessionFactoryImplementor sessionFactory) {\n-  154: \t\tif ( sqlExpression.getExpressionType() instanceof JavaObjectType ) {\n-  155: \t\t\tfinal BasicType<Object> resolvedType = jdbcResultsMetadata.resolveType(\n-  156: \t\t\t\t\tjdbcPosition,\n-  157: \t\t\t\t\tnull,\n-  158: \t\t\t\t\tsessionFactory\n-  159: \t\t\t);\n-  160: \t\t\treturn new ResolvedSqlSelection(\n-  161: \t\t\t\t\tjdbcPosition,\n-  162: \t\t\t\t\tvaluesArrayPosition,\n-  163: \t\t\t\t\tsqlExpression,\n-  164: \t\t\t\t\tresolvedType\n-  165: \t\t\t);\n-  166: \t\t}\n-  167: \t\treturn this;\n-  168: \t}\n-  169: \n-  170: \t@Override\n-  171: \tpublic boolean equals(Object o) {\n-  172: \t\tif ( this == o ) {\n+  152: \tpublic boolean needsResolve() {\n+  153: \t\treturn sqlExpression.getExpressionType() instanceof JavaObjectType;\n+  154: \t}\n+  155: \n+  156: \t@Override\n+  157: \tpublic SqlSelection resolve(JdbcValuesMetadata jdbcResultsMetadata, SessionFactoryImplementor sessionFactory) {\n+  158: \t\tif ( needsResolve() ) {\n+  159: \t\t\tfinal BasicType<Object> resolvedType = jdbcResultsMetadata.resolveType(\n+  160: \t\t\t\t\tjdbcPosition,\n+  161: \t\t\t\t\tnull,\n+  162: \t\t\t\t\tsessionFactory\n+  163: \t\t\t);\n+  164: \t\t\treturn new ResolvedSqlSelection(\n+  165: \t\t\t\t\tjdbcPosition,\n+  166: \t\t\t\t\tvaluesArrayPosition,\n+  167: \t\t\t\t\tsqlExpression,\n+  168: \t\t\t\t\tresolvedType\n+  169: \t\t\t);\n+  170: \t\t}\n+  171: \t\treturn this;\n+  172: \t}\n",
        "uniqueId": "e9513b1db5553cec8e8bfb3a095fc3d903a747b5_152_168_152_154_156_172",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 25
            },
            "BRANCH": {
                "missed": 0,
                "covered": 2
            },
            "LINE": {
                "missed": 0,
                "covered": 4
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 2
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\nprivate SqlSelection createResolvedSqlSelection(JdbcValuesMetadata jdbcResultsMetadata, SessionFactoryImplementor sessionFactory, BasicType<Object> resolvedType) {\n    return new ResolvedSqlSelection(\n            jdbcPosition,\n            valuesArrayPosition,\n            sqlExpression,\n            resolvedType\n    );\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Override\n\tpublic SqlSelection resolve(JdbcValuesMetadata jdbcResultsMetadata, SessionFactoryImplementor sessionFactory) {\n\t\tif ( sqlExpression.getExpressionType() instanceof JavaObjectType ) {\n\t\t\tfinal BasicType<Object> resolvedType = jdbcResultsMetadata.resolveType(\n\t\t\t\t\tjdbcPosition,\n\t\t\t\t\tnull,\n\t\t\t\t\tsessionFactory\n\t\t\t);\n\t\t\treturn new ResolvedSqlSelection(\n\t\t\t\t\tjdbcPosition,\n\t\t\t\t\tvaluesArrayPosition,\n\t\t\t\t\tsqlExpression,\n\t\t\t\t\tresolvedType\n\t\t\t);\n\t\t}\n\t\treturn this;\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.sql.results.internal;\n\nimport java.util.Objects;\n\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.metamodel.mapping.JdbcMapping;\nimport org.hibernate.metamodel.mapping.JdbcMappingContainer;\nimport org.hibernate.sql.ast.SqlAstWalker;\nimport org.hibernate.sql.ast.spi.SqlExpressionAccess;\nimport org.hibernate.sql.ast.spi.SqlSelection;\nimport org.hibernate.sql.ast.tree.expression.Expression;\nimport org.hibernate.sql.results.jdbc.spi.JdbcValuesMetadata;\nimport org.hibernate.type.BasicType;\nimport org.hibernate.type.JavaObjectType;\nimport org.hibernate.type.descriptor.ValueExtractor;\nimport org.hibernate.type.descriptor.java.JavaType;\n\n/**\n * @asciidoc\n *\n * ```\n * @Entity\n * class MyEntity {\n *     ...\n *     @Column ( name = \"the_column\", ... )\n *     public String getTheColumn() { ... }\n *\n *     @Convert ( ... )\n *     @Column ( name = \"the_column\", ... )\n *     ConvertedType getTheConvertedColumn() { ... }\n *\n * }\n * ```\n *\n * @author Steve Ebersole\n */\npublic class SqlSelectionImpl implements SqlSelection, SqlExpressionAccess {\n\tprivate final int jdbcPosition;\n\tprivate final int valuesArrayPosition;\n\tprivate final Expression sqlExpression;\n\tprivate final JavaType<?> jdbcJavaType;\n\tprivate final boolean virtual;\n\tprivate transient ValueExtractor valueExtractor;\n\n\tpublic SqlSelectionImpl(Expression sqlExpression) {\n\t\tthis( 0, -1, null, sqlExpression, false );\n\t}\n\n\tpublic SqlSelectionImpl(int valuesArrayPosition, Expression sqlExpression) {\n\t\tthis( valuesArrayPosition + 1, valuesArrayPosition, null, sqlExpression, false );\n\t}\n\n\tpublic SqlSelectionImpl(int jdbcPosition, int valuesArrayPosition, Expression sqlExpression, boolean virtual) {\n\t\tthis( jdbcPosition, valuesArrayPosition, null, sqlExpression, virtual );\n\t}\n\n\tpublic SqlSelectionImpl(\n\t\t\tint jdbcPosition,\n\t\t\tint valuesArrayPosition,\n\t\t\tJavaType<?> jdbcJavaType,\n\t\t\tExpression sqlExpression,\n\t\t\tboolean virtual) {\n\t\tthis(\n\t\t\t\tjdbcPosition,\n\t\t\t\tvaluesArrayPosition,\n\t\t\t\tsqlExpression,\n\t\t\t\tjdbcJavaType,\n\t\t\t\tvirtual,\n\t\t\t\tnull\n\t\t);\n\t}\n\n\tprotected SqlSelectionImpl(\n\t\t\tint jdbcPosition,\n\t\t\tint valuesArrayPosition,\n\t\t\tExpression sqlExpression,\n\t\t\tJavaType<?> jdbcJavaType,\n\t\t\tboolean virtual,\n\t\t\tValueExtractor valueExtractor) {\n\t\tthis.jdbcPosition = jdbcPosition;\n\t\tthis.valuesArrayPosition = valuesArrayPosition;\n\t\tthis.sqlExpression = sqlExpression;\n\t\tthis.jdbcJavaType = jdbcJavaType;\n\t\tthis.virtual = virtual;\n\t\tthis.valueExtractor = valueExtractor;\n\t}\n\n\tprivate static ValueExtractor determineValueExtractor(Expression sqlExpression, JavaType<?> jdbcJavaType) {\n\t\tfinal JdbcMappingContainer expressionType = sqlExpression.getExpressionType();\n\t\tfinal JdbcMapping jdbcMapping = expressionType == null\n\t\t\t\t? JavaObjectType.INSTANCE\n\t\t\t\t: expressionType.getSingleJdbcMapping();\n\t\tif ( jdbcJavaType == null || jdbcMapping.getMappedJavaType() == jdbcJavaType ) {\n\t\t\treturn jdbcMapping.getJdbcValueExtractor();\n\t\t}\n\t\telse {\n\t\t\treturn jdbcMapping.getJdbcType().getExtractor( jdbcJavaType );\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic Expression getExpression() {\n\t\treturn sqlExpression;\n\t}\n\n\t@Override\n\tpublic ValueExtractor getJdbcValueExtractor() {\n\t\tValueExtractor extractor = valueExtractor;\n\t\tif ( extractor == null ) {\n\t\t\tvalueExtractor = extractor = determineValueExtractor( sqlExpression, jdbcJavaType );\n\t\t}\n\t\treturn extractor;\n\t}\n\n\t@Override\n\tpublic int getJdbcResultSetIndex() {\n\t\treturn jdbcPosition;\n\t}\n\n\t@Override\n\tpublic int getValuesArrayPosition() {\n\t\treturn valuesArrayPosition;\n\t}\n\n\t@Override\n\tpublic JdbcMappingContainer getExpressionType() {\n\t\treturn getExpression().getExpressionType();\n\t}\n\n\t@Override\n\tpublic boolean isVirtual() {\n\t\treturn virtual;\n\t}\n\n\t@Override\n\tpublic Expression getSqlExpression() {\n\t\treturn sqlExpression;\n\t}\n\n\t@Override\n\tpublic void accept(SqlAstWalker interpreter) {\n\t\tsqlExpression.accept( interpreter );\n\t}\n\n\t@Override\n\tpublic SqlSelection resolve(JdbcValuesMetadata jdbcResultsMetadata, SessionFactoryImplementor sessionFactory) {\n\t\tif ( sqlExpression.getExpressionType() instanceof JavaObjectType ) {\n\t\t\tfinal BasicType<Object> resolvedType = jdbcResultsMetadata.resolveType(\n\t\t\t\t\tjdbcPosition,\n\t\t\t\t\tnull,\n\t\t\t\t\tsessionFactory\n\t\t\t);\n\t\t\treturn new ResolvedSqlSelection(\n\t\t\t\t\tjdbcPosition,\n\t\t\t\t\tvaluesArrayPosition,\n\t\t\t\t\tsqlExpression,\n\t\t\t\t\tresolvedType\n\t\t\t);\n\t\t}\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif ( this == o ) {\n\t\t\treturn true;\n\t\t}\n\t\tif ( o == null || getClass() != o.getClass() ) {\n\t\t\treturn false;\n\t\t}\n\t\tfinal SqlSelection that = (SqlSelection) o;\n\t\treturn jdbcPosition == that.getJdbcResultSetIndex() &&\n\t\t\t\tvaluesArrayPosition == that.getValuesArrayPosition() &&\n\t\t\t\tObjects.equals( sqlExpression, that.getExpression() ) &&\n\t\t\t\tvirtual == that.isVirtual();\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn Objects.hash( jdbcPosition, valuesArrayPosition, sqlExpression, virtual );\n\t}\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate beginSlowQueryLogging() : long extracted from public execute(statement Statement, sql String) : ResultSet in class org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 149,
                "endLine": 180,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 152,
                "endLine": 181,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 229,
                "endLine": 231,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "isPureRefactoring": true,
        "commitId": "7b8c403df746e127f38d3f5f3efb45b941c36af2",
        "packageNameBefore": "org.hibernate.engine.jdbc.internal",
        "classNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "methodNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute",
        "invokedMethod": "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute\n methodBody: public ResultSet execute(Statement statement, String sql) {\nsqlStatementLogger.logStatement(sql);\nlong executeStartNanos=0;\nif(this.sqlStatementLogger.getLogSlowQuery() > 0){executeStartNanos=System.nanoTime();\n}tryfinal ResultSet rs;\nfinal EventManager eventManager=jdbcCoordinator.getJdbcSessionOwner().getEventManager();\nfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent=eventManager.beginJdbcPreparedStatementExecutionEvent();\ntryjdbcExecuteStatementStart();\nif(!statement.execute(sql)){while(!statement.getMoreResults() && statement.getUpdateCount() != -1){}}rs=statement.getResultSet();\nfinallyeventManager.completeJdbcPreparedStatementExecutionEvent(jdbcPreparedStatementExecutionEvent,sql);\njdbcExecuteStatementEnd();\nsqlStatementLogger.logSlowQuery(sql,executeStartNanos,context());\npostExtract(rs,statement);\nreturn rs;\ncatch(SQLException e)throw sqlExceptionHelper.convert(e,\"could not execute statement\",sql);\n}",
        "classSignatureBefore": "public class ResultSetReturnImpl implements ResultSetReturn ",
        "methodNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute"
        ],
        "classNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl"
        ],
        "classSignatureBeforeSet": [
            "public class ResultSetReturnImpl implements ResultSetReturn "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final Dialect dialect;\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.dialect = jdbcServices.getDialect();\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcEventHandler;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging(sql, executeStartNanos);\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate EventManager getEventManager() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t}\n\n\tprivate JdbcEventHandler getEventHandler() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler();\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tgetEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tgetEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\tprivate void endSlowQueryLogging(String sql, long executeStartNanos) {\n\t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n\t}\n\n\tprivate long beginSlowQueryLogging() {\n\t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "diffSourceCodeSet": [
            "private long beginSlowQueryLogging() {\n\t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute\n methodBody: public ResultSet execute(Statement statement, String sql) {\nsqlStatementLogger.logStatement(sql);\nlong executeStartNanos=0;\nif(this.sqlStatementLogger.getLogSlowQuery() > 0){executeStartNanos=System.nanoTime();\n}tryfinal ResultSet rs;\nfinal EventManager eventManager=jdbcCoordinator.getJdbcSessionOwner().getEventManager();\nfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent=eventManager.beginJdbcPreparedStatementExecutionEvent();\ntryjdbcExecuteStatementStart();\nif(!statement.execute(sql)){while(!statement.getMoreResults() && statement.getUpdateCount() != -1){}}rs=statement.getResultSet();\nfinallyeventManager.completeJdbcPreparedStatementExecutionEvent(jdbcPreparedStatementExecutionEvent,sql);\njdbcExecuteStatementEnd();\nsqlStatementLogger.logSlowQuery(sql,executeStartNanos,context());\npostExtract(rs,statement);\nreturn rs;\ncatch(SQLException e)throw sqlExceptionHelper.convert(e,\"could not execute statement\",sql);\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\nprivate long beginSlowQueryLogging() {\n\t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n\t}",
        "diffSourceCode": "-  149: \t@Override\n-  150: \tpublic ResultSet execute(Statement statement, String sql) {\n-  151: \t\tsqlStatementLogger.logStatement( sql );\n-  152: \t\tlong executeStartNanos = 0;\n-  153: \t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n-  154: \t\t\texecuteStartNanos = System.nanoTime();\n-  155: \t\t}\n+  149: \t\t}\n+  150: \t}\n+  151: \n+  152: \t@Override\n+  153: \tpublic ResultSet execute(Statement statement, String sql) {\n+  154: \t\tsqlStatementLogger.logStatement( sql );\n+  155: \t\tlong executeStartNanos = beginSlowQueryLogging();\n   156: \t\ttry {\n   157: \t\t\tfinal ResultSet rs;\n-  158: \t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n-  159: \t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n-  160: \t\t\ttry {\n-  161: \t\t\t\tjdbcExecuteStatementStart();\n-  162: \t\t\t\tif ( !statement.execute( sql ) ) {\n-  163: \t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n-  164: \t\t\t\t\t\t// do nothing until we hit the resultset\n-  165: \t\t\t\t\t}\n-  166: \t\t\t\t}\n-  167: \t\t\t\trs = statement.getResultSet();\n-  168: \t\t\t}\n-  169: \t\t\tfinally {\n-  170: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n-  171: \t\t\t\tjdbcExecuteStatementEnd();\n-  172: \t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n-  173: \t\t\t}\n-  174: \t\t\tpostExtract( rs, statement );\n-  175: \t\t\treturn rs;\n-  176: \t\t}\n-  177: \t\tcatch (SQLException e) {\n-  178: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n-  179: \t\t}\n-  180: \t}\n-  181: \n-  229: \tprivate void postExtract(ResultSet rs, Statement st) {\n-  230: \t\tif ( rs != null ) {\n-  231: \t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n+  158: \t\t\tfinal EventManager eventManager = getEventManager();\n+  159: \t\t\tfinal HibernateMonitoringEvent executionEvent =\n+  160: \t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n+  161: \t\t\ttry {\n+  162: \t\t\t\tjdbcExecuteStatementStart();\n+  163: \t\t\t\tif ( !statement.execute( sql ) ) {\n+  164: \t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n+  165: \t\t\t\t\t\t// do nothing until we hit the resultset\n+  166: \t\t\t\t\t}\n+  167: \t\t\t\t}\n+  168: \t\t\t\trs = statement.getResultSet();\n+  169: \t\t\t}\n+  170: \t\t\tfinally {\n+  171: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n+  172: \t\t\t\tjdbcExecuteStatementEnd();\n+  173: \t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n+  174: \t\t\t}\n+  175: \t\t\tpostExtract( rs, statement );\n+  176: \t\t\treturn rs;\n+  177: \t\t}\n+  178: \t\tcatch (SQLException e) {\n+  179: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n+  180: \t\t}\n+  181: \t}\n+  229: \tprivate long beginSlowQueryLogging() {\n+  230: \t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n+  231: \t}\n",
        "uniqueId": "7b8c403df746e127f38d3f5f3efb45b941c36af2_149_180_229_231_152_181",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 9,
                "covered": 45
            },
            "BRANCH": {
                "missed": 3,
                "covered": 3
            },
            "LINE": {
                "missed": 2,
                "covered": 14
            },
            "COMPLEXITY": {
                "missed": 3,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\nprivate void logSlowQuery(String sql, long executeStartNanos) {\n    if (this.sqlStatementLogger.getLogSlowQuery() > 0) {\n        sqlStatementLogger.logSlowQuery(sql, executeStartNanos, context());\n    }\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final Dialect dialect;\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.dialect = jdbcServices.getDialect();\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate endSlowQueryLogging(sql String, executeStartNanos long) : void extracted from public execute(statement Statement, sql String) : ResultSet in class org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 149,
                "endLine": 180,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 152,
                "endLine": 181,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 225,
                "endLine": 227,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "isPureRefactoring": true,
        "commitId": "7b8c403df746e127f38d3f5f3efb45b941c36af2",
        "packageNameBefore": "org.hibernate.engine.jdbc.internal",
        "classNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "methodNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute",
        "invokedMethod": "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute\n methodBody: public ResultSet execute(Statement statement, String sql) {\nsqlStatementLogger.logStatement(sql);\nlong executeStartNanos=0;\nif(this.sqlStatementLogger.getLogSlowQuery() > 0){executeStartNanos=System.nanoTime();\n}tryfinal ResultSet rs;\nfinal EventManager eventManager=jdbcCoordinator.getJdbcSessionOwner().getEventManager();\nfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent=eventManager.beginJdbcPreparedStatementExecutionEvent();\ntryjdbcExecuteStatementStart();\nif(!statement.execute(sql)){while(!statement.getMoreResults() && statement.getUpdateCount() != -1){}}rs=statement.getResultSet();\nfinallyeventManager.completeJdbcPreparedStatementExecutionEvent(jdbcPreparedStatementExecutionEvent,sql);\njdbcExecuteStatementEnd();\nsqlStatementLogger.logSlowQuery(sql,executeStartNanos,context());\npostExtract(rs,statement);\nreturn rs;\ncatch(SQLException e)throw sqlExceptionHelper.convert(e,\"could not execute statement\",sql);\n}",
        "classSignatureBefore": "public class ResultSetReturnImpl implements ResultSetReturn ",
        "methodNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute"
        ],
        "classNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl"
        ],
        "classSignatureBeforeSet": [
            "public class ResultSetReturnImpl implements ResultSetReturn "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final Dialect dialect;\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.dialect = jdbcServices.getDialect();\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcEventHandler;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging(sql, executeStartNanos);\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate EventManager getEventManager() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t}\n\n\tprivate JdbcEventHandler getEventHandler() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler();\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tgetEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tgetEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\tprivate void endSlowQueryLogging(String sql, long executeStartNanos) {\n\t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n\t}\n\n\tprivate long beginSlowQueryLogging() {\n\t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "diffSourceCodeSet": [
            "private void endSlowQueryLogging(String sql, long executeStartNanos) {\n\t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute\n methodBody: public ResultSet execute(Statement statement, String sql) {\nsqlStatementLogger.logStatement(sql);\nlong executeStartNanos=0;\nif(this.sqlStatementLogger.getLogSlowQuery() > 0){executeStartNanos=System.nanoTime();\n}tryfinal ResultSet rs;\nfinal EventManager eventManager=jdbcCoordinator.getJdbcSessionOwner().getEventManager();\nfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent=eventManager.beginJdbcPreparedStatementExecutionEvent();\ntryjdbcExecuteStatementStart();\nif(!statement.execute(sql)){while(!statement.getMoreResults() && statement.getUpdateCount() != -1){}}rs=statement.getResultSet();\nfinallyeventManager.completeJdbcPreparedStatementExecutionEvent(jdbcPreparedStatementExecutionEvent,sql);\njdbcExecuteStatementEnd();\nsqlStatementLogger.logSlowQuery(sql,executeStartNanos,context());\npostExtract(rs,statement);\nreturn rs;\ncatch(SQLException e)throw sqlExceptionHelper.convert(e,\"could not execute statement\",sql);\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\nprivate void endSlowQueryLogging(String sql, long executeStartNanos) {\n\t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n\t}",
        "diffSourceCode": "-  149: \t@Override\n-  150: \tpublic ResultSet execute(Statement statement, String sql) {\n-  151: \t\tsqlStatementLogger.logStatement( sql );\n-  152: \t\tlong executeStartNanos = 0;\n-  153: \t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n-  154: \t\t\texecuteStartNanos = System.nanoTime();\n-  155: \t\t}\n+  149: \t\t}\n+  150: \t}\n+  151: \n+  152: \t@Override\n+  153: \tpublic ResultSet execute(Statement statement, String sql) {\n+  154: \t\tsqlStatementLogger.logStatement( sql );\n+  155: \t\tlong executeStartNanos = beginSlowQueryLogging();\n   156: \t\ttry {\n   157: \t\t\tfinal ResultSet rs;\n-  158: \t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n-  159: \t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n-  160: \t\t\ttry {\n-  161: \t\t\t\tjdbcExecuteStatementStart();\n-  162: \t\t\t\tif ( !statement.execute( sql ) ) {\n-  163: \t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n-  164: \t\t\t\t\t\t// do nothing until we hit the resultset\n-  165: \t\t\t\t\t}\n-  166: \t\t\t\t}\n-  167: \t\t\t\trs = statement.getResultSet();\n-  168: \t\t\t}\n-  169: \t\t\tfinally {\n-  170: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n-  171: \t\t\t\tjdbcExecuteStatementEnd();\n-  172: \t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n-  173: \t\t\t}\n-  174: \t\t\tpostExtract( rs, statement );\n-  175: \t\t\treturn rs;\n-  176: \t\t}\n-  177: \t\tcatch (SQLException e) {\n-  178: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n-  179: \t\t}\n-  180: \t}\n-  181: \n-  225: \t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n-  226: \t\t}\n+  158: \t\t\tfinal EventManager eventManager = getEventManager();\n+  159: \t\t\tfinal HibernateMonitoringEvent executionEvent =\n+  160: \t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n+  161: \t\t\ttry {\n+  162: \t\t\t\tjdbcExecuteStatementStart();\n+  163: \t\t\t\tif ( !statement.execute( sql ) ) {\n+  164: \t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n+  165: \t\t\t\t\t\t// do nothing until we hit the resultset\n+  166: \t\t\t\t\t}\n+  167: \t\t\t\t}\n+  168: \t\t\t\trs = statement.getResultSet();\n+  169: \t\t\t}\n+  170: \t\t\tfinally {\n+  171: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n+  172: \t\t\t\tjdbcExecuteStatementEnd();\n+  173: \t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n+  174: \t\t\t}\n+  175: \t\t\tpostExtract( rs, statement );\n+  176: \t\t\treturn rs;\n+  177: \t\t}\n+  178: \t\tcatch (SQLException e) {\n+  179: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n+  180: \t\t}\n+  181: \t}\n+  225: \tprivate void endSlowQueryLogging(String sql, long executeStartNanos) {\n+  226: \t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n   227: \t}\n",
        "uniqueId": "7b8c403df746e127f38d3f5f3efb45b941c36af2_149_180_225_227_152_181",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 9,
                "covered": 45
            },
            "BRANCH": {
                "missed": 3,
                "covered": 3
            },
            "LINE": {
                "missed": 2,
                "covered": 14
            },
            "COMPLEXITY": {
                "missed": 3,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\nprivate void logSlowQuery(String sql, long executeStartNanos) {\n    if (this.sqlStatementLogger.getLogSlowQuery() > 0) {\n        sqlStatementLogger.logSlowQuery(sql, executeStartNanos, context());\n    }\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final Dialect dialect;\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.dialect = jdbcServices.getDialect();\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate getEventManager() : EventManager extracted from public execute(statement Statement, sql String) : ResultSet in class org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 149,
                "endLine": 180,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 152,
                "endLine": 181,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 75,
                "endLine": 77,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "isPureRefactoring": true,
        "commitId": "7b8c403df746e127f38d3f5f3efb45b941c36af2",
        "packageNameBefore": "org.hibernate.engine.jdbc.internal",
        "classNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "methodNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute",
        "invokedMethod": "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute\n methodBody: public ResultSet execute(Statement statement, String sql) {\nsqlStatementLogger.logStatement(sql);\nlong executeStartNanos=0;\nif(this.sqlStatementLogger.getLogSlowQuery() > 0){executeStartNanos=System.nanoTime();\n}tryfinal ResultSet rs;\nfinal EventManager eventManager=jdbcCoordinator.getJdbcSessionOwner().getEventManager();\nfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent=eventManager.beginJdbcPreparedStatementExecutionEvent();\ntryjdbcExecuteStatementStart();\nif(!statement.execute(sql)){while(!statement.getMoreResults() && statement.getUpdateCount() != -1){}}rs=statement.getResultSet();\nfinallyeventManager.completeJdbcPreparedStatementExecutionEvent(jdbcPreparedStatementExecutionEvent,sql);\njdbcExecuteStatementEnd();\nsqlStatementLogger.logSlowQuery(sql,executeStartNanos,context());\npostExtract(rs,statement);\nreturn rs;\ncatch(SQLException e)throw sqlExceptionHelper.convert(e,\"could not execute statement\",sql);\n}",
        "classSignatureBefore": "public class ResultSetReturnImpl implements ResultSetReturn ",
        "methodNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute"
        ],
        "classNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl"
        ],
        "classSignatureBeforeSet": [
            "public class ResultSetReturnImpl implements ResultSetReturn "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final Dialect dialect;\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.dialect = jdbcServices.getDialect();\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcEventHandler;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging(sql, executeStartNanos);\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate EventManager getEventManager() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t}\n\n\tprivate JdbcEventHandler getEventHandler() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler();\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tgetEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tgetEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\tprivate void endSlowQueryLogging(String sql, long executeStartNanos) {\n\t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n\t}\n\n\tprivate long beginSlowQueryLogging() {\n\t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "diffSourceCodeSet": [
            "private EventManager getEventManager() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute\n methodBody: public ResultSet execute(Statement statement, String sql) {\nsqlStatementLogger.logStatement(sql);\nlong executeStartNanos=0;\nif(this.sqlStatementLogger.getLogSlowQuery() > 0){executeStartNanos=System.nanoTime();\n}tryfinal ResultSet rs;\nfinal EventManager eventManager=jdbcCoordinator.getJdbcSessionOwner().getEventManager();\nfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent=eventManager.beginJdbcPreparedStatementExecutionEvent();\ntryjdbcExecuteStatementStart();\nif(!statement.execute(sql)){while(!statement.getMoreResults() && statement.getUpdateCount() != -1){}}rs=statement.getResultSet();\nfinallyeventManager.completeJdbcPreparedStatementExecutionEvent(jdbcPreparedStatementExecutionEvent,sql);\njdbcExecuteStatementEnd();\nsqlStatementLogger.logSlowQuery(sql,executeStartNanos,context());\npostExtract(rs,statement);\nreturn rs;\ncatch(SQLException e)throw sqlExceptionHelper.convert(e,\"could not execute statement\",sql);\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\nprivate EventManager getEventManager() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t}",
        "diffSourceCode": "-   75: \n-   76: \tprivate JdbcSessionContext context() {\n-   77: \t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n-  149: \t@Override\n-  150: \tpublic ResultSet execute(Statement statement, String sql) {\n-  151: \t\tsqlStatementLogger.logStatement( sql );\n-  152: \t\tlong executeStartNanos = 0;\n-  153: \t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n-  154: \t\t\texecuteStartNanos = System.nanoTime();\n-  155: \t\t}\n+   75: \tprivate EventManager getEventManager() {\n+   76: \t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n+   77: \t}\n+  149: \t\t}\n+  150: \t}\n+  151: \n+  152: \t@Override\n+  153: \tpublic ResultSet execute(Statement statement, String sql) {\n+  154: \t\tsqlStatementLogger.logStatement( sql );\n+  155: \t\tlong executeStartNanos = beginSlowQueryLogging();\n   156: \t\ttry {\n   157: \t\t\tfinal ResultSet rs;\n-  158: \t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n-  159: \t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n-  160: \t\t\ttry {\n-  161: \t\t\t\tjdbcExecuteStatementStart();\n-  162: \t\t\t\tif ( !statement.execute( sql ) ) {\n-  163: \t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n-  164: \t\t\t\t\t\t// do nothing until we hit the resultset\n-  165: \t\t\t\t\t}\n-  166: \t\t\t\t}\n-  167: \t\t\t\trs = statement.getResultSet();\n-  168: \t\t\t}\n-  169: \t\t\tfinally {\n-  170: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n-  171: \t\t\t\tjdbcExecuteStatementEnd();\n-  172: \t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n-  173: \t\t\t}\n-  174: \t\t\tpostExtract( rs, statement );\n-  175: \t\t\treturn rs;\n-  176: \t\t}\n-  177: \t\tcatch (SQLException e) {\n-  178: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n-  179: \t\t}\n-  180: \t}\n-  181: \n+  158: \t\t\tfinal EventManager eventManager = getEventManager();\n+  159: \t\t\tfinal HibernateMonitoringEvent executionEvent =\n+  160: \t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n+  161: \t\t\ttry {\n+  162: \t\t\t\tjdbcExecuteStatementStart();\n+  163: \t\t\t\tif ( !statement.execute( sql ) ) {\n+  164: \t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n+  165: \t\t\t\t\t\t// do nothing until we hit the resultset\n+  166: \t\t\t\t\t}\n+  167: \t\t\t\t}\n+  168: \t\t\t\trs = statement.getResultSet();\n+  169: \t\t\t}\n+  170: \t\t\tfinally {\n+  171: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n+  172: \t\t\t\tjdbcExecuteStatementEnd();\n+  173: \t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n+  174: \t\t\t}\n+  175: \t\t\tpostExtract( rs, statement );\n+  176: \t\t\treturn rs;\n+  177: \t\t}\n+  178: \t\tcatch (SQLException e) {\n+  179: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n+  180: \t\t}\n+  181: \t}\n",
        "uniqueId": "7b8c403df746e127f38d3f5f3efb45b941c36af2_149_180_75_77_152_181",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 9,
                "covered": 45
            },
            "BRANCH": {
                "missed": 3,
                "covered": 3
            },
            "LINE": {
                "missed": 2,
                "covered": 14
            },
            "COMPLEXITY": {
                "missed": 3,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\nprivate void logSlowQuery(String sql, long executeStartNanos) {\n    if (this.sqlStatementLogger.getLogSlowQuery() > 0) {\n        sqlStatementLogger.logSlowQuery(sql, executeStartNanos, context());\n    }\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final Dialect dialect;\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.dialect = jdbcServices.getDialect();\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate beginSlowQueryLogging() : long extracted from public execute(statement PreparedStatement, sql String) : ResultSet in class org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 116,
                "endLine": 147,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 121,
                "endLine": 150,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 229,
                "endLine": 231,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "isPureRefactoring": true,
        "commitId": "7b8c403df746e127f38d3f5f3efb45b941c36af2",
        "packageNameBefore": "org.hibernate.engine.jdbc.internal",
        "classNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "methodNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute",
        "invokedMethod": "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute\n methodBody: public ResultSet execute(Statement statement, String sql) {\nsqlStatementLogger.logStatement(sql);\nlong executeStartNanos=0;\nif(this.sqlStatementLogger.getLogSlowQuery() > 0){executeStartNanos=System.nanoTime();\n}tryfinal ResultSet rs;\nfinal EventManager eventManager=jdbcCoordinator.getJdbcSessionOwner().getEventManager();\nfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent=eventManager.beginJdbcPreparedStatementExecutionEvent();\ntryjdbcExecuteStatementStart();\nif(!statement.execute(sql)){while(!statement.getMoreResults() && statement.getUpdateCount() != -1){}}rs=statement.getResultSet();\nfinallyeventManager.completeJdbcPreparedStatementExecutionEvent(jdbcPreparedStatementExecutionEvent,sql);\njdbcExecuteStatementEnd();\nsqlStatementLogger.logSlowQuery(sql,executeStartNanos,context());\npostExtract(rs,statement);\nreturn rs;\ncatch(SQLException e)throw sqlExceptionHelper.convert(e,\"could not execute statement\",sql);\n}",
        "classSignatureBefore": "public class ResultSetReturnImpl implements ResultSetReturn ",
        "methodNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute"
        ],
        "classNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl"
        ],
        "classSignatureBeforeSet": [
            "public class ResultSetReturnImpl implements ResultSetReturn "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final Dialect dialect;\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.dialect = jdbcServices.getDialect();\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcEventHandler;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging(sql, executeStartNanos);\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate EventManager getEventManager() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t}\n\n\tprivate JdbcEventHandler getEventHandler() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler();\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tgetEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tgetEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\tprivate void endSlowQueryLogging(String sql, long executeStartNanos) {\n\t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n\t}\n\n\tprivate long beginSlowQueryLogging() {\n\t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "diffSourceCodeSet": [
            "private long beginSlowQueryLogging() {\n\t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute\n methodBody: public ResultSet execute(Statement statement, String sql) {\nsqlStatementLogger.logStatement(sql);\nlong executeStartNanos=0;\nif(this.sqlStatementLogger.getLogSlowQuery() > 0){executeStartNanos=System.nanoTime();\n}tryfinal ResultSet rs;\nfinal EventManager eventManager=jdbcCoordinator.getJdbcSessionOwner().getEventManager();\nfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent=eventManager.beginJdbcPreparedStatementExecutionEvent();\ntryjdbcExecuteStatementStart();\nif(!statement.execute(sql)){while(!statement.getMoreResults() && statement.getUpdateCount() != -1){}}rs=statement.getResultSet();\nfinallyeventManager.completeJdbcPreparedStatementExecutionEvent(jdbcPreparedStatementExecutionEvent,sql);\njdbcExecuteStatementEnd();\nsqlStatementLogger.logSlowQuery(sql,executeStartNanos,context());\npostExtract(rs,statement);\nreturn rs;\ncatch(SQLException e)throw sqlExceptionHelper.convert(e,\"could not execute statement\",sql);\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\nprivate long beginSlowQueryLogging() {\n\t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n\t}",
        "diffSourceCode": "-  116: \t@Override\n-  117: \tpublic ResultSet execute(PreparedStatement statement, String sql) {\n-  118: \t\t// sql logged by StatementPreparerImpl\n-  119: \t\tlong executeStartNanos = 0;\n-  120: \t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n-  121: \t\t\texecuteStartNanos = System.nanoTime();\n-  122: \t\t}\n-  123: \t\ttry {\n-  124: \t\t\tfinal ResultSet rs;\n-  125: \t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n-  126: \t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n-  127: \t\t\ttry {\n-  128: \t\t\t\tjdbcExecuteStatementStart();\n-  129: \t\t\t\tif ( !statement.execute() ) {\n-  130: \t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n-  131: \t\t\t\t\t\t// do nothing until we hit the resultset\n-  132: \t\t\t\t\t}\n-  133: \t\t\t\t}\n-  134: \t\t\t\trs = statement.getResultSet();\n-  135: \t\t\t}\n-  136: \t\t\tfinally {\n-  137: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n-  138: \t\t\t\tjdbcExecuteStatementEnd();\n-  139: \t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n-  140: \t\t\t}\n-  141: \t\t\tpostExtract( rs, statement );\n-  142: \t\t\treturn rs;\n-  143: \t\t}\n-  144: \t\tcatch (SQLException e) {\n-  145: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n+  116: \t\tcatch (SQLException e) {\n+  117: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n+  118: \t\t}\n+  119: \t}\n+  120: \n+  121: \t@Override\n+  122: \tpublic ResultSet execute(PreparedStatement statement, String sql) {\n+  123: \t\t// sql logged by StatementPreparerImpl\n+  124: \t\tlong executeStartNanos = beginSlowQueryLogging();\n+  125: \t\ttry {\n+  126: \t\t\tfinal ResultSet rs;\n+  127: \t\t\tfinal EventManager eventManager = getEventManager();\n+  128: \t\t\tfinal HibernateMonitoringEvent executionEvent =\n+  129: \t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n+  130: \t\t\ttry {\n+  131: \t\t\t\tjdbcExecuteStatementStart();\n+  132: \t\t\t\tif ( !statement.execute() ) {\n+  133: \t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n+  134: \t\t\t\t\t\t// do nothing until we hit the resultset\n+  135: \t\t\t\t\t}\n+  136: \t\t\t\t}\n+  137: \t\t\t\trs = statement.getResultSet();\n+  138: \t\t\t}\n+  139: \t\t\tfinally {\n+  140: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n+  141: \t\t\t\tjdbcExecuteStatementEnd();\n+  142: \t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n+  143: \t\t\t}\n+  144: \t\t\tpostExtract( rs, statement );\n+  145: \t\t\treturn rs;\n   146: \t\t}\n-  147: \t}\n-  148: \n-  149: \t@Override\n-  150: \tpublic ResultSet execute(Statement statement, String sql) {\n-  229: \tprivate void postExtract(ResultSet rs, Statement st) {\n-  230: \t\tif ( rs != null ) {\n-  231: \t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n+  147: \t\tcatch (SQLException e) {\n+  148: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n+  149: \t\t}\n+  150: \t}\n+  229: \tprivate long beginSlowQueryLogging() {\n+  230: \t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n+  231: \t}\n",
        "uniqueId": "7b8c403df746e127f38d3f5f3efb45b941c36af2_116_147_229_231_121_150",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 9,
                "covered": 45
            },
            "BRANCH": {
                "missed": 3,
                "covered": 3
            },
            "LINE": {
                "missed": 2,
                "covered": 14
            },
            "COMPLEXITY": {
                "missed": 3,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\nprivate void logSlowQuery(String sql, long executeStartNanos) {\n    if (this.sqlStatementLogger.getLogSlowQuery() > 0) {\n        sqlStatementLogger.logSlowQuery(sql, executeStartNanos, context());\n    }\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final Dialect dialect;\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.dialect = jdbcServices.getDialect();\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate endSlowQueryLogging(sql String, executeStartNanos long) : void extracted from public execute(statement PreparedStatement, sql String) : ResultSet in class org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 116,
                "endLine": 147,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 121,
                "endLine": 150,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 225,
                "endLine": 227,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "isPureRefactoring": true,
        "commitId": "7b8c403df746e127f38d3f5f3efb45b941c36af2",
        "packageNameBefore": "org.hibernate.engine.jdbc.internal",
        "classNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "methodNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute",
        "invokedMethod": "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute\n methodBody: public ResultSet execute(Statement statement, String sql) {\nsqlStatementLogger.logStatement(sql);\nlong executeStartNanos=0;\nif(this.sqlStatementLogger.getLogSlowQuery() > 0){executeStartNanos=System.nanoTime();\n}tryfinal ResultSet rs;\nfinal EventManager eventManager=jdbcCoordinator.getJdbcSessionOwner().getEventManager();\nfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent=eventManager.beginJdbcPreparedStatementExecutionEvent();\ntryjdbcExecuteStatementStart();\nif(!statement.execute(sql)){while(!statement.getMoreResults() && statement.getUpdateCount() != -1){}}rs=statement.getResultSet();\nfinallyeventManager.completeJdbcPreparedStatementExecutionEvent(jdbcPreparedStatementExecutionEvent,sql);\njdbcExecuteStatementEnd();\nsqlStatementLogger.logSlowQuery(sql,executeStartNanos,context());\npostExtract(rs,statement);\nreturn rs;\ncatch(SQLException e)throw sqlExceptionHelper.convert(e,\"could not execute statement\",sql);\n}",
        "classSignatureBefore": "public class ResultSetReturnImpl implements ResultSetReturn ",
        "methodNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute"
        ],
        "classNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl"
        ],
        "classSignatureBeforeSet": [
            "public class ResultSetReturnImpl implements ResultSetReturn "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final Dialect dialect;\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.dialect = jdbcServices.getDialect();\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcEventHandler;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging(sql, executeStartNanos);\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate EventManager getEventManager() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t}\n\n\tprivate JdbcEventHandler getEventHandler() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler();\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tgetEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tgetEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\tprivate void endSlowQueryLogging(String sql, long executeStartNanos) {\n\t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n\t}\n\n\tprivate long beginSlowQueryLogging() {\n\t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "diffSourceCodeSet": [
            "private void endSlowQueryLogging(String sql, long executeStartNanos) {\n\t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute\n methodBody: public ResultSet execute(Statement statement, String sql) {\nsqlStatementLogger.logStatement(sql);\nlong executeStartNanos=0;\nif(this.sqlStatementLogger.getLogSlowQuery() > 0){executeStartNanos=System.nanoTime();\n}tryfinal ResultSet rs;\nfinal EventManager eventManager=jdbcCoordinator.getJdbcSessionOwner().getEventManager();\nfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent=eventManager.beginJdbcPreparedStatementExecutionEvent();\ntryjdbcExecuteStatementStart();\nif(!statement.execute(sql)){while(!statement.getMoreResults() && statement.getUpdateCount() != -1){}}rs=statement.getResultSet();\nfinallyeventManager.completeJdbcPreparedStatementExecutionEvent(jdbcPreparedStatementExecutionEvent,sql);\njdbcExecuteStatementEnd();\nsqlStatementLogger.logSlowQuery(sql,executeStartNanos,context());\npostExtract(rs,statement);\nreturn rs;\ncatch(SQLException e)throw sqlExceptionHelper.convert(e,\"could not execute statement\",sql);\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\nprivate void endSlowQueryLogging(String sql, long executeStartNanos) {\n\t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n\t}",
        "diffSourceCode": "-  116: \t@Override\n-  117: \tpublic ResultSet execute(PreparedStatement statement, String sql) {\n-  118: \t\t// sql logged by StatementPreparerImpl\n-  119: \t\tlong executeStartNanos = 0;\n-  120: \t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n-  121: \t\t\texecuteStartNanos = System.nanoTime();\n-  122: \t\t}\n-  123: \t\ttry {\n-  124: \t\t\tfinal ResultSet rs;\n-  125: \t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n-  126: \t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n-  127: \t\t\ttry {\n-  128: \t\t\t\tjdbcExecuteStatementStart();\n-  129: \t\t\t\tif ( !statement.execute() ) {\n-  130: \t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n-  131: \t\t\t\t\t\t// do nothing until we hit the resultset\n-  132: \t\t\t\t\t}\n-  133: \t\t\t\t}\n-  134: \t\t\t\trs = statement.getResultSet();\n-  135: \t\t\t}\n-  136: \t\t\tfinally {\n-  137: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n-  138: \t\t\t\tjdbcExecuteStatementEnd();\n-  139: \t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n-  140: \t\t\t}\n-  141: \t\t\tpostExtract( rs, statement );\n-  142: \t\t\treturn rs;\n-  143: \t\t}\n-  144: \t\tcatch (SQLException e) {\n-  145: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n+  116: \t\tcatch (SQLException e) {\n+  117: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n+  118: \t\t}\n+  119: \t}\n+  120: \n+  121: \t@Override\n+  122: \tpublic ResultSet execute(PreparedStatement statement, String sql) {\n+  123: \t\t// sql logged by StatementPreparerImpl\n+  124: \t\tlong executeStartNanos = beginSlowQueryLogging();\n+  125: \t\ttry {\n+  126: \t\t\tfinal ResultSet rs;\n+  127: \t\t\tfinal EventManager eventManager = getEventManager();\n+  128: \t\t\tfinal HibernateMonitoringEvent executionEvent =\n+  129: \t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n+  130: \t\t\ttry {\n+  131: \t\t\t\tjdbcExecuteStatementStart();\n+  132: \t\t\t\tif ( !statement.execute() ) {\n+  133: \t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n+  134: \t\t\t\t\t\t// do nothing until we hit the resultset\n+  135: \t\t\t\t\t}\n+  136: \t\t\t\t}\n+  137: \t\t\t\trs = statement.getResultSet();\n+  138: \t\t\t}\n+  139: \t\t\tfinally {\n+  140: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n+  141: \t\t\t\tjdbcExecuteStatementEnd();\n+  142: \t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n+  143: \t\t\t}\n+  144: \t\t\tpostExtract( rs, statement );\n+  145: \t\t\treturn rs;\n   146: \t\t}\n-  147: \t}\n-  148: \n-  149: \t@Override\n-  150: \tpublic ResultSet execute(Statement statement, String sql) {\n-  225: \t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n-  226: \t\t}\n+  147: \t\tcatch (SQLException e) {\n+  148: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n+  149: \t\t}\n+  150: \t}\n+  225: \tprivate void endSlowQueryLogging(String sql, long executeStartNanos) {\n+  226: \t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n   227: \t}\n",
        "uniqueId": "7b8c403df746e127f38d3f5f3efb45b941c36af2_116_147_225_227_121_150",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 9,
                "covered": 45
            },
            "BRANCH": {
                "missed": 3,
                "covered": 3
            },
            "LINE": {
                "missed": 2,
                "covered": 14
            },
            "COMPLEXITY": {
                "missed": 3,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\nprivate void logSlowQuery(String sql, long executeStartNanos) {\n    if (this.sqlStatementLogger.getLogSlowQuery() > 0) {\n        sqlStatementLogger.logSlowQuery(sql, executeStartNanos, context());\n    }\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final Dialect dialect;\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.dialect = jdbcServices.getDialect();\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate getEventManager() : EventManager extracted from public execute(statement PreparedStatement, sql String) : ResultSet in class org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 116,
                "endLine": 147,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 121,
                "endLine": 150,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 75,
                "endLine": 77,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "isPureRefactoring": true,
        "commitId": "7b8c403df746e127f38d3f5f3efb45b941c36af2",
        "packageNameBefore": "org.hibernate.engine.jdbc.internal",
        "classNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "methodNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute",
        "invokedMethod": "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute\n methodBody: public ResultSet execute(Statement statement, String sql) {\nsqlStatementLogger.logStatement(sql);\nlong executeStartNanos=0;\nif(this.sqlStatementLogger.getLogSlowQuery() > 0){executeStartNanos=System.nanoTime();\n}tryfinal ResultSet rs;\nfinal EventManager eventManager=jdbcCoordinator.getJdbcSessionOwner().getEventManager();\nfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent=eventManager.beginJdbcPreparedStatementExecutionEvent();\ntryjdbcExecuteStatementStart();\nif(!statement.execute(sql)){while(!statement.getMoreResults() && statement.getUpdateCount() != -1){}}rs=statement.getResultSet();\nfinallyeventManager.completeJdbcPreparedStatementExecutionEvent(jdbcPreparedStatementExecutionEvent,sql);\njdbcExecuteStatementEnd();\nsqlStatementLogger.logSlowQuery(sql,executeStartNanos,context());\npostExtract(rs,statement);\nreturn rs;\ncatch(SQLException e)throw sqlExceptionHelper.convert(e,\"could not execute statement\",sql);\n}",
        "classSignatureBefore": "public class ResultSetReturnImpl implements ResultSetReturn ",
        "methodNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute"
        ],
        "classNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl"
        ],
        "classSignatureBeforeSet": [
            "public class ResultSetReturnImpl implements ResultSetReturn "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final Dialect dialect;\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.dialect = jdbcServices.getDialect();\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcEventHandler;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging(sql, executeStartNanos);\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate EventManager getEventManager() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t}\n\n\tprivate JdbcEventHandler getEventHandler() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler();\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tgetEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tgetEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\tprivate void endSlowQueryLogging(String sql, long executeStartNanos) {\n\t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n\t}\n\n\tprivate long beginSlowQueryLogging() {\n\t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "diffSourceCodeSet": [
            "private EventManager getEventManager() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#execute\n methodBody: public ResultSet execute(Statement statement, String sql) {\nsqlStatementLogger.logStatement(sql);\nlong executeStartNanos=0;\nif(this.sqlStatementLogger.getLogSlowQuery() > 0){executeStartNanos=System.nanoTime();\n}tryfinal ResultSet rs;\nfinal EventManager eventManager=jdbcCoordinator.getJdbcSessionOwner().getEventManager();\nfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent=eventManager.beginJdbcPreparedStatementExecutionEvent();\ntryjdbcExecuteStatementStart();\nif(!statement.execute(sql)){while(!statement.getMoreResults() && statement.getUpdateCount() != -1){}}rs=statement.getResultSet();\nfinallyeventManager.completeJdbcPreparedStatementExecutionEvent(jdbcPreparedStatementExecutionEvent,sql);\njdbcExecuteStatementEnd();\nsqlStatementLogger.logSlowQuery(sql,executeStartNanos,context());\npostExtract(rs,statement);\nreturn rs;\ncatch(SQLException e)throw sqlExceptionHelper.convert(e,\"could not execute statement\",sql);\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\nprivate EventManager getEventManager() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t}",
        "diffSourceCode": "-   75: \n-   76: \tprivate JdbcSessionContext context() {\n-   77: \t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n-  116: \t@Override\n-  117: \tpublic ResultSet execute(PreparedStatement statement, String sql) {\n-  118: \t\t// sql logged by StatementPreparerImpl\n-  119: \t\tlong executeStartNanos = 0;\n-  120: \t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n-  121: \t\t\texecuteStartNanos = System.nanoTime();\n-  122: \t\t}\n-  123: \t\ttry {\n-  124: \t\t\tfinal ResultSet rs;\n-  125: \t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n-  126: \t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n-  127: \t\t\ttry {\n-  128: \t\t\t\tjdbcExecuteStatementStart();\n-  129: \t\t\t\tif ( !statement.execute() ) {\n-  130: \t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n-  131: \t\t\t\t\t\t// do nothing until we hit the resultset\n-  132: \t\t\t\t\t}\n-  133: \t\t\t\t}\n-  134: \t\t\t\trs = statement.getResultSet();\n-  135: \t\t\t}\n-  136: \t\t\tfinally {\n-  137: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n-  138: \t\t\t\tjdbcExecuteStatementEnd();\n-  139: \t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n-  140: \t\t\t}\n-  141: \t\t\tpostExtract( rs, statement );\n-  142: \t\t\treturn rs;\n-  143: \t\t}\n-  144: \t\tcatch (SQLException e) {\n-  145: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n+   75: \tprivate EventManager getEventManager() {\n+   76: \t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n+   77: \t}\n+  116: \t\tcatch (SQLException e) {\n+  117: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n+  118: \t\t}\n+  119: \t}\n+  120: \n+  121: \t@Override\n+  122: \tpublic ResultSet execute(PreparedStatement statement, String sql) {\n+  123: \t\t// sql logged by StatementPreparerImpl\n+  124: \t\tlong executeStartNanos = beginSlowQueryLogging();\n+  125: \t\ttry {\n+  126: \t\t\tfinal ResultSet rs;\n+  127: \t\t\tfinal EventManager eventManager = getEventManager();\n+  128: \t\t\tfinal HibernateMonitoringEvent executionEvent =\n+  129: \t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n+  130: \t\t\ttry {\n+  131: \t\t\t\tjdbcExecuteStatementStart();\n+  132: \t\t\t\tif ( !statement.execute() ) {\n+  133: \t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n+  134: \t\t\t\t\t\t// do nothing until we hit the resultset\n+  135: \t\t\t\t\t}\n+  136: \t\t\t\t}\n+  137: \t\t\t\trs = statement.getResultSet();\n+  138: \t\t\t}\n+  139: \t\t\tfinally {\n+  140: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n+  141: \t\t\t\tjdbcExecuteStatementEnd();\n+  142: \t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n+  143: \t\t\t}\n+  144: \t\t\tpostExtract( rs, statement );\n+  145: \t\t\treturn rs;\n   146: \t\t}\n-  147: \t}\n-  148: \n-  149: \t@Override\n-  150: \tpublic ResultSet execute(Statement statement, String sql) {\n+  147: \t\tcatch (SQLException e) {\n+  148: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n+  149: \t\t}\n+  150: \t}\n",
        "uniqueId": "7b8c403df746e127f38d3f5f3efb45b941c36af2_116_147_75_77_121_150",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 9,
                "covered": 45
            },
            "BRANCH": {
                "missed": 3,
                "covered": 3
            },
            "LINE": {
                "missed": 2,
                "covered": 14
            },
            "COMPLEXITY": {
                "missed": 3,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\nprivate void logSlowQuery(String sql, long executeStartNanos) {\n    if (this.sqlStatementLogger.getLogSlowQuery() > 0) {\n        sqlStatementLogger.logSlowQuery(sql, executeStartNanos, context());\n    }\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final Dialect dialect;\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.dialect = jdbcServices.getDialect();\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate beginSlowQueryLogging() : long extracted from public extract(statement Statement, sql String) : ResultSet in class org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 88,
                "endLine": 114,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 95,
                "endLine": 119,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
                "startLine": 229,
                "endLine": 231,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "isPureRefactoring": true,
        "commitId": "7b8c403df746e127f38d3f5f3efb45b941c36af2",
        "packageNameBefore": "org.hibernate.engine.jdbc.internal",
        "classNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl",
        "methodNameBefore": "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#extract",
        "invokedMethod": "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}",
        "classSignatureBefore": "public class ResultSetReturnImpl implements ResultSetReturn ",
        "methodNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#extract"
        ],
        "classNameBeforeSet": [
            "org.hibernate.engine.jdbc.internal.ResultSetReturnImpl"
        ],
        "classSignatureBeforeSet": [
            "public class ResultSetReturnImpl implements ResultSetReturn "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Tolerable changes in the body\n",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final Dialect dialect;\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.dialect = jdbcServices.getDialect();\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcEventHandler;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging(sql, executeStartNanos);\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate EventManager getEventManager() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t}\n\n\tprivate JdbcEventHandler getEventHandler() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler();\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tgetEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tgetEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\tfinal EventManager eventManager = getEventManager();\n\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t}\n\t}\n\n\tprivate void endSlowQueryLogging(String sql, long executeStartNanos) {\n\t\tsqlStatementLogger.logSlowQuery(sql, executeStartNanos, context() );\n\t}\n\n\tprivate long beginSlowQueryLogging() {\n\t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n",
        "diffSourceCodeSet": [
            "private long beginSlowQueryLogging() {\n\t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementStart\n methodBody: private void jdbcExecuteStatementStart() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#context\n methodBody: private JdbcSessionContext context() {\nreturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#jdbcExecuteStatementEnd\n methodBody: private void jdbcExecuteStatementEnd() {\njdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.ResultSetReturnImpl#postExtract\n methodBody: private void postExtract(ResultSet rs, Statement st) {\nif(rs != null){jdbcCoordinator.getLogicalConnection().getResourceRegistry().register(rs,st);\n}}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = beginSlowQueryLogging();\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = getEventManager();\n\t\t\tfinal HibernateMonitoringEvent executionEvent =\n\t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\nprivate long beginSlowQueryLogging() {\n\t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n\t}",
        "diffSourceCode": "-   88: \t@Override\n-   89: \tpublic ResultSet extract(Statement statement, String sql) {\n-   90: \t\tsqlStatementLogger.logStatement( sql );\n-   91: \t\tlong executeStartNanos = 0;\n-   92: \t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n-   93: \t\t\texecuteStartNanos = System.nanoTime();\n-   94: \t\t}\n-   95: \t\ttry {\n-   96: \t\t\tfinal ResultSet rs;\n-   97: \t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n-   98: \t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n-   99: \t\t\ttry {\n-  100: \t\t\t\tjdbcExecuteStatementStart();\n-  101: \t\t\t\trs = statement.executeQuery( sql );\n-  102: \t\t\t}\n-  103: \t\t\tfinally {\n-  104: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n-  105: \t\t\t\tjdbcExecuteStatementEnd();\n-  106: \t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n+   88: \t\tgetEventHandler().jdbcExecuteStatementEnd();\n+   89: \t}\n+   90: \n+   91: \tprivate void jdbcExecuteStatementStart() {\n+   92: \t\tgetEventHandler().jdbcExecuteStatementStart();\n+   93: \t}\n+   94: \n+   95: \t@Override\n+   96: \tpublic ResultSet extract(Statement statement, String sql) {\n+   97: \t\tsqlStatementLogger.logStatement( sql );\n+   98: \t\tlong executeStartNanos = beginSlowQueryLogging();\n+   99: \t\ttry {\n+  100: \t\t\tfinal ResultSet rs;\n+  101: \t\t\tfinal EventManager eventManager = getEventManager();\n+  102: \t\t\tfinal HibernateMonitoringEvent executionEvent =\n+  103: \t\t\t\t\teventManager.beginJdbcPreparedStatementExecutionEvent();\n+  104: \t\t\ttry {\n+  105: \t\t\t\tjdbcExecuteStatementStart();\n+  106: \t\t\t\trs = statement.executeQuery( sql );\n   107: \t\t\t}\n-  108: \t\t\tpostExtract( rs, statement );\n-  109: \t\t\treturn rs;\n-  110: \t\t}\n-  111: \t\tcatch (SQLException e) {\n-  112: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n-  113: \t\t}\n-  114: \t}\n-  115: \n-  116: \t@Override\n-  117: \tpublic ResultSet execute(PreparedStatement statement, String sql) {\n-  118: \t\t// sql logged by StatementPreparerImpl\n-  119: \t\tlong executeStartNanos = 0;\n-  229: \tprivate void postExtract(ResultSet rs, Statement st) {\n-  230: \t\tif ( rs != null ) {\n-  231: \t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n+  108: \t\t\tfinally {\n+  109: \t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( executionEvent, sql );\n+  110: \t\t\t\tjdbcExecuteStatementEnd();\n+  111: \t\t\t\tendSlowQueryLogging( sql, executeStartNanos );\n+  112: \t\t\t}\n+  113: \t\t\tpostExtract( rs, statement );\n+  114: \t\t\treturn rs;\n+  115: \t\t}\n+  116: \t\tcatch (SQLException e) {\n+  117: \t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n+  118: \t\t}\n+  119: \t}\n+  229: \tprivate long beginSlowQueryLogging() {\n+  230: \t\treturn sqlStatementLogger.getLogSlowQuery() > 0 ? System.nanoTime() : 0;\n+  231: \t}\n",
        "uniqueId": "7b8c403df746e127f38d3f5f3efb45b941c36af2_88_114_229_231_95_119",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 43
            },
            "LINE": {
                "missed": 0,
                "covered": 14
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\nprivate void logSlowQuery(String sql, long executeStartNanos) {\n    if (this.sqlStatementLogger.getLogSlowQuery() > 0) {\n        sqlStatementLogger.logSlowQuery(sql, executeStartNanos, context());\n    }\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.engine.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.jdbc.spi.JdbcServices;\nimport org.hibernate.engine.jdbc.spi.ResultSetReturn;\nimport org.hibernate.engine.jdbc.spi.SqlExceptionHelper;\nimport org.hibernate.engine.jdbc.spi.SqlStatementLogger;\nimport org.hibernate.event.spi.EventManager;\nimport org.hibernate.event.spi.HibernateMonitoringEvent;\nimport org.hibernate.resource.jdbc.spi.JdbcSessionContext;\n\n/**\n * Standard implementation of the ResultSetReturn contract\n *\n * @author Brett Meyer\n */\npublic class ResultSetReturnImpl implements ResultSetReturn {\n\tprivate final JdbcCoordinator jdbcCoordinator;\n\n\tprivate final Dialect dialect;\n\tprivate final SqlStatementLogger sqlStatementLogger;\n\tprivate final SqlExceptionHelper sqlExceptionHelper;\n\n\t/**\n\t * Constructs a ResultSetReturnImpl\n\t *\n\t * @param jdbcCoordinator The JdbcCoordinator\n\t */\n\tpublic ResultSetReturnImpl(JdbcCoordinator jdbcCoordinator, JdbcServices jdbcServices) {\n\t\tthis.jdbcCoordinator = jdbcCoordinator;\n\t\tthis.dialect = jdbcServices.getDialect();\n\t\tthis.sqlStatementLogger = jdbcServices.getSqlStatementLogger();\n\t\tthis.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(PreparedStatement statement, String sql) {\n\t\t// IMPL NOTE : SQL logged by caller\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\tprivate JdbcSessionContext context() {\n\t\treturn jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext();\n\t}\n\n\tprivate void jdbcExecuteStatementEnd() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementEnd();\n\t}\n\n\tprivate void jdbcExecuteStatementStart() {\n\t\tjdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getEventHandler().jdbcExecuteStatementStart();\n\t}\n\n\t@Override\n\tpublic ResultSet extract(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\trs = statement.executeQuery( sql );\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not extract ResultSet\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(PreparedStatement statement, String sql) {\n\t\t// sql logged by StatementPreparerImpl\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute() ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic ResultSet execute(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\ttry {\n\t\t\tfinal ResultSet rs;\n\t\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\t\ttry {\n\t\t\t\tjdbcExecuteStatementStart();\n\t\t\t\tif ( !statement.execute( sql ) ) {\n\t\t\t\t\twhile ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {\n\t\t\t\t\t\t// do nothing until we hit the resultset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trs = statement.getResultSet();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\t\tjdbcExecuteStatementEnd();\n\t\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t\t}\n\t\t\tpostExtract( rs, statement );\n\t\t\treturn rs;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(PreparedStatement statement, String sql) {\n\t\tassert statement != null;\n\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int executeUpdate(Statement statement, String sql) {\n\t\tsqlStatementLogger.logStatement( sql );\n\t\tlong executeStartNanos = 0;\n\t\tif ( this.sqlStatementLogger.getLogSlowQuery() > 0 ) {\n\t\t\texecuteStartNanos = System.nanoTime();\n\t\t}\n\t\tfinal EventManager eventManager = jdbcCoordinator.getJdbcSessionOwner().getEventManager();\n\t\tfinal HibernateMonitoringEvent jdbcPreparedStatementExecutionEvent = eventManager.beginJdbcPreparedStatementExecutionEvent();\n\t\ttry {\n\t\t\tjdbcExecuteStatementStart();\n\t\t\treturn statement.executeUpdate( sql );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow sqlExceptionHelper.convert( e, \"could not execute statement\", sql );\n\t\t}\n\t\tfinally {\n\t\t\teventManager.completeJdbcPreparedStatementExecutionEvent( jdbcPreparedStatementExecutionEvent, sql );\n\t\t\tjdbcExecuteStatementEnd();\n\t\t\tsqlStatementLogger.logSlowQuery( sql, executeStartNanos, context() );\n\t\t}\n\t}\n\n\tprivate void postExtract(ResultSet rs, Statement st) {\n\t\tif ( rs != null ) {\n\t\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().register( rs, st );\n\t\t}\n\t}\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate getJdbcParamName(procedureCall ProcedureCallImplementor<?>, isNamed boolean, typeToUse OutputableType<T>, databaseMetaData ExtractedDatabaseMetaData) : String extracted from public toJdbcParameterRegistration(startIndex int, procedureCall ProcedureCallImplementor<?>) : JdbcCallParameterRegistration in class org.hibernate.procedure.internal.ProcedureParameterImpl",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/procedure/internal/ProcedureParameterImpl.java",
                "startLine": 121,
                "endLine": 185,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/procedure/internal/ProcedureParameterImpl.java",
                "startLine": 122,
                "endLine": 188,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/procedure/internal/ProcedureParameterImpl.java",
                "startLine": 190,
                "endLine": 196,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic JdbcCallParameterRegistration toJdbcParameterRegistration(\n\t\t\tint startIndex,\n\t\t\tProcedureCallImplementor<?> procedureCall) {\n\t\tfinal QueryParameterBinding<T> binding = procedureCall.getParameterBindings().getBinding( this );\n\t\tfinal boolean isNamed = procedureCall.getParameterStrategy() == ParameterStrategy.NAMED && this.name != null;\n\n\t\tfinal BindableType<T> bindableType;\n\t\tif ( getHibernateType() != null ) {\n\t\t\tbindableType = getHibernateType();\n\t\t}\n\t\telse if ( binding != null ) {\n\t\t\t//noinspection unchecked\n\t\t\tbindableType = (BindableType<T>) binding.getBindType();\n\t\t}\n\t\telse {\n\t\t\tbindableType = null;\n\t\t}\n\n\t\tfinal OutputableType<T> typeToUse = (OutputableType<T>) BindingTypeHelper.INSTANCE.resolveTemporalPrecision(\n\t\t\t\tbinding == null ? null : binding.getExplicitTemporalPrecision(),\n\t\t\t\tbindableType,\n\t\t\t\tprocedureCall.getSession().getFactory()\n\t\t);\n\n\t\tfinal String jdbcParamName;\n\t\tif ( isNamed && canDoNameParameterBinding( typeToUse, procedureCall ) ) {\n\t\t\tjdbcParamName = this.name;\n\t\t}\n\t\telse {\n\t\t\tjdbcParamName = null;\n\t\t}\n\n\t\tfinal JdbcParameterBinder parameterBinder;\n\t\tfinal JdbcCallRefCursorExtractorImpl refCursorExtractor;\n\t\tfinal JdbcCallParameterExtractorImpl<T> parameterExtractor;\n\n\t\tswitch ( mode ) {\n\t\t\tcase REF_CURSOR:\n\t\t\t\trefCursorExtractor = new JdbcCallRefCursorExtractorImpl( jdbcParamName, startIndex );\n\t\t\t\tparameterBinder = null;\n\t\t\t\tparameterExtractor = null;\n\t\t\t\tbreak;\n\t\t\tcase IN:\n\t\t\t\tvalidateBindableType( typeToUse, startIndex );\n\t\t\t\tparameterBinder = getParameterBinder( typeToUse, jdbcParamName );\n\t\t\t\tparameterExtractor = null;\n\t\t\t\trefCursorExtractor = null;\n\t\t\t\tbreak;\n\t\t\tcase INOUT:\n\t\t\t\tvalidateBindableType( typeToUse, startIndex );\n\t\t\t\tparameterBinder = getParameterBinder( typeToUse, jdbcParamName );\n\t\t\t\tparameterExtractor = new JdbcCallParameterExtractorImpl<>( procedureCall.getProcedureName(), jdbcParamName, startIndex, typeToUse );\n\t\t\t\trefCursorExtractor = null;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tvalidateBindableType( typeToUse, startIndex );\n\t\t\t\tparameterBinder = null;\n\t\t\t\tparameterExtractor = new JdbcCallParameterExtractorImpl<>( procedureCall.getProcedureName(), jdbcParamName, startIndex, typeToUse );\n\t\t\t\trefCursorExtractor = null;\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn new JdbcCallParameterRegistrationImpl( jdbcParamName, startIndex, mode, typeToUse, parameterBinder, parameterExtractor, refCursorExtractor );\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/procedure/internal/ProcedureParameterImpl.java",
        "isPureRefactoring": true,
        "commitId": "8766a8e012cd08616847f26f3ccb3e0bd7441698",
        "packageNameBefore": "org.hibernate.procedure.internal",
        "classNameBefore": "org.hibernate.procedure.internal.ProcedureParameterImpl",
        "methodNameBefore": "org.hibernate.procedure.internal.ProcedureParameterImpl#toJdbcParameterRegistration",
        "invokedMethod": "methodSignature: org.hibernate.procedure.internal.ProcedureParameterImpl#canDoNameParameterBinding\n methodBody: private boolean canDoNameParameterBinding(\n\t\t\tBindableType<?> hibernateType,\n\t\t\tProcedureCallImplementor<?> procedureCall) {\nfinal ExtractedDatabaseMetaData databaseMetaData=procedureCall.getSession().getFactory().getJdbcServices().getJdbcEnvironment().getExtractedDatabaseMetaData();\nreturn procedureCall.getFunctionReturn() == null && databaseMetaData.supportsNamedParameters() && hibernateType instanceof ProcedureParameterNamedBinder && ((ProcedureParameterNamedBinder<?>)hibernateType).canDoSetting();\n}\nmethodSignature: org.hibernate.procedure.internal.ProcedureParameterImpl#getParameterBinder\n methodBody: private JdbcParameterBinder getParameterBinder(BindableType<T> typeToUse, String name) {\nif(typeToUse == null){throw new ParameterTypeException(String.format(Locale.ROOT,\"Cannot determine the bindable type for procedure parameter %s (%s)\",this.name != null ? this.name : this.position,name));\n}if(typeToUse instanceof BasicType<?>){if(name == null){return new JdbcParameterImpl((BasicType<T>)typeToUse);\n}{return new JdbcParameterImpl((BasicType<T>)typeToUse){\n  @Override protected void bindParameterValue(  JdbcMapping jdbcMapping,  PreparedStatement statement,  Object bindValue,  int startPosition,  ExecutionContext executionContext) throws SQLException {\n    jdbcMapping.getJdbcValueBinder().bind((CallableStatement)statement,bindValue,name,executionContext.getSession());\n  }\n  @Override public String toString(){\n    return \"JdbcParameter(\" + name + \")\";\n  }\n}\n;\n}}throw new UnsupportedOperationException();\n}\nmethodSignature: org.hibernate.procedure.internal.ProcedureParameterImpl#validateBindableType\n methodBody: private void validateBindableType(BindableType<T> bindableType, int startIndex) {\nif(bindableType == null){throw new ParameterTypeException(String.format(Locale.ROOT,\"Could not determine ProcedureCall parameter bind type - %s (%s)\",this.name != null ? this.name : this.position,startIndex));\n}}",
        "classSignatureBefore": "public class ProcedureParameterImpl<T> extends AbstractQueryParameter<T> implements ProcedureParameterImplementor<T> ",
        "methodNameBeforeSet": [
            "org.hibernate.procedure.internal.ProcedureParameterImpl#toJdbcParameterRegistration"
        ],
        "classNameBeforeSet": [
            "org.hibernate.procedure.internal.ProcedureParameterImpl"
        ],
        "classSignatureBeforeSet": [
            "public class ProcedureParameterImpl<T> extends AbstractQueryParameter<T> implements ProcedureParameterImplementor<T> "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics",
                "description": "All the mappings are matched! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.procedure.internal;\n\nimport java.sql.CallableStatement;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.util.Locale;\nimport java.util.Objects;\n\nimport org.hibernate.engine.jdbc.env.spi.ExtractedDatabaseMetaData;\nimport org.hibernate.metamodel.mapping.JdbcMapping;\nimport org.hibernate.procedure.ParameterTypeException;\nimport org.hibernate.procedure.spi.NamedCallableQueryMemento;\nimport org.hibernate.procedure.spi.ParameterStrategy;\nimport org.hibernate.procedure.spi.ProcedureCallImplementor;\nimport org.hibernate.procedure.spi.ProcedureParameterImplementor;\nimport org.hibernate.query.BindableType;\nimport org.hibernate.query.OutputableType;\nimport org.hibernate.query.internal.BindingTypeHelper;\nimport org.hibernate.query.spi.AbstractQueryParameter;\nimport org.hibernate.query.spi.QueryParameterBinding;\nimport org.hibernate.sql.exec.internal.JdbcCallParameterExtractorImpl;\nimport org.hibernate.sql.exec.internal.JdbcCallParameterRegistrationImpl;\nimport org.hibernate.sql.exec.internal.JdbcCallRefCursorExtractorImpl;\nimport org.hibernate.sql.exec.internal.JdbcParameterImpl;\nimport org.hibernate.sql.exec.spi.ExecutionContext;\nimport org.hibernate.sql.exec.spi.JdbcCallParameterRegistration;\nimport org.hibernate.sql.exec.spi.JdbcParameterBinder;\nimport org.hibernate.type.BasicType;\nimport org.hibernate.type.ProcedureParameterNamedBinder;\n\nimport jakarta.persistence.ParameterMode;\n\n/**\n * @author Steve Ebersole\n */\npublic class ProcedureParameterImpl<T> extends AbstractQueryParameter<T> implements ProcedureParameterImplementor<T> {\n\n\tprivate final String name;\n\tprivate final Integer position;\n\tprivate final ParameterMode mode;\n\tprivate final Class<T> javaType;\n\n\t/**\n\t * Used for named Query parameters\n\t */\n\tpublic ProcedureParameterImpl(\n\t\t\tString name,\n\t\t\tParameterMode mode,\n\t\t\tClass<T> javaType,\n\t\t\tBindableType<T> hibernateType) {\n\t\tsuper( false, hibernateType );\n\t\tthis.name = name;\n\t\tthis.position = null;\n\t\tthis.mode = mode;\n\t\tthis.javaType = javaType;\n\t}\n\n\t/**\n\t * Used for ordinal Query parameters\n\t */\n\tpublic ProcedureParameterImpl(\n\t\t\tInteger position,\n\t\t\tParameterMode mode,\n\t\t\tClass<T> javaType,\n\t\t\tBindableType<T> hibernateType) {\n\t\tsuper( false, hibernateType );\n\t\tthis.name = null;\n\t\tthis.position = position;\n\t\tthis.mode = mode;\n\t\tthis.javaType = javaType;\n\t}\n\n\t@Override\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\t@Override\n\tpublic Integer getPosition() {\n\t\treturn position;\n\t}\n\n\t@Override\n\tpublic ParameterMode getMode() {\n\t\treturn mode;\n\t}\n\n\t@Override\n\tpublic Class<T> getParameterType() {\n\t\treturn javaType;\n\t}\n\n\t@Override\n\tpublic NamedCallableQueryMemento.ParameterMemento toMemento() {\n\t\treturn session -> {\n\t\t\tif ( getName() != null ) {\n\t\t\t\treturn new ProcedureParameterImpl<>(\n\t\t\t\t\t\tgetName(),\n\t\t\t\t\t\tgetMode(),\n\t\t\t\t\t\tjavaType,\n\t\t\t\t\t\tgetHibernateType()\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new ProcedureParameterImpl<>(\n\t\t\t\t\t\tgetPosition(),\n\t\t\t\t\t\tgetMode(),\n\t\t\t\t\t\tjavaType,\n\t\t\t\t\t\tgetHibernateType()\n\t\t\t\t);\n\t\t\t}\n\t\t};\n\t}\n\n\t@Override\n\tpublic JdbcCallParameterRegistration toJdbcParameterRegistration(\n\t\t\tint startIndex,\n\t\t\tProcedureCallImplementor<?> procedureCall) {\n\t\tfinal QueryParameterBinding<T> binding = procedureCall.getParameterBindings().getBinding( this );\n\t\tfinal boolean isNamed = procedureCall.getParameterStrategy() == ParameterStrategy.NAMED && this.name != null;\n\n\t\tfinal BindableType<T> bindableType;\n\t\tif ( getHibernateType() != null ) {\n\t\t\tbindableType = getHibernateType();\n\t\t}\n\t\telse if ( binding != null ) {\n\t\t\t//noinspection unchecked\n\t\t\tbindableType = (BindableType<T>) binding.getBindType();\n\t\t}\n\t\telse {\n\t\t\tbindableType = null;\n\t\t}\n\n\t\tfinal OutputableType<T> typeToUse = (OutputableType<T>) BindingTypeHelper.INSTANCE.resolveTemporalPrecision(\n\t\t\t\tbinding == null ? null : binding.getExplicitTemporalPrecision(),\n\t\t\t\tbindableType,\n\t\t\t\tprocedureCall.getSession().getFactory()\n\t\t);\n\n\t\tfinal String jdbcParamName;\n\t\tif ( isNamed && canDoNameParameterBinding( typeToUse, procedureCall ) ) {\n\t\t\tjdbcParamName = this.name;\n\t\t}\n\t\telse {\n\t\t\tjdbcParamName = null;\n\t\t}\n\n\t\tfinal JdbcParameterBinder parameterBinder;\n\t\tfinal JdbcCallRefCursorExtractorImpl refCursorExtractor;\n\t\tfinal JdbcCallParameterExtractorImpl<T> parameterExtractor;\n\n\t\tswitch ( mode ) {\n\t\t\tcase REF_CURSOR:\n\t\t\t\trefCursorExtractor = new JdbcCallRefCursorExtractorImpl( jdbcParamName, startIndex );\n\t\t\t\tparameterBinder = null;\n\t\t\t\tparameterExtractor = null;\n\t\t\t\tbreak;\n\t\t\tcase IN:\n\t\t\t\tvalidateBindableType( typeToUse, startIndex );\n\t\t\t\tparameterBinder = getParameterBinder( typeToUse, jdbcParamName );\n\t\t\t\tparameterExtractor = null;\n\t\t\t\trefCursorExtractor = null;\n\t\t\t\tbreak;\n\t\t\tcase INOUT:\n\t\t\t\tvalidateBindableType( typeToUse, startIndex );\n\t\t\t\tparameterBinder = getParameterBinder( typeToUse, jdbcParamName );\n\t\t\t\tparameterExtractor = new JdbcCallParameterExtractorImpl<>( procedureCall.getProcedureName(), jdbcParamName, startIndex, typeToUse );\n\t\t\t\trefCursorExtractor = null;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tvalidateBindableType( typeToUse, startIndex );\n\t\t\t\tparameterBinder = null;\n\t\t\t\tparameterExtractor = new JdbcCallParameterExtractorImpl<>( procedureCall.getProcedureName(), jdbcParamName, startIndex, typeToUse );\n\t\t\t\trefCursorExtractor = null;\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn new JdbcCallParameterRegistrationImpl( jdbcParamName, startIndex, mode, typeToUse, parameterBinder, parameterExtractor, refCursorExtractor );\n\t}\n\n\tprivate void validateBindableType(BindableType<T> bindableType, int startIndex) {\n\t\tif ( bindableType == null ) {\n\t\t\tthrow new ParameterTypeException(\n\t\t\t\t\tString.format(\n\t\t\t\t\t\t\tLocale.ROOT,\n\t\t\t\t\t\t\t\"Could not determine ProcedureCall parameter bind type - %s (%s)\",\n\t\t\t\t\t\t\tthis.name != null ? this.name : this.position,\n\t\t\t\t\t\t\tstartIndex\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate JdbcParameterBinder getParameterBinder(BindableType<T> typeToUse, String name) {\n\t\tif ( typeToUse == null ) {\n\t\t\tthrow new ParameterTypeException(\n\t\t\t\t\tString.format(\n\t\t\t\t\t\t\tLocale.ROOT,\n\t\t\t\t\t\t\t\"Cannot determine the bindable type for procedure parameter %s (%s)\",\n\t\t\t\t\t\t\tthis.name != null ? this.name : this.position,\n\t\t\t\t\t\t\tname\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tif ( typeToUse instanceof BasicType<?> ) {\n\t\t\tif ( name == null ) {\n\t\t\t\treturn new JdbcParameterImpl( (BasicType<T>) typeToUse );\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new JdbcParameterImpl( (BasicType<T>) typeToUse ) {\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected void bindParameterValue(\n\t\t\t\t\t\t\tJdbcMapping jdbcMapping,\n\t\t\t\t\t\t\tPreparedStatement statement,\n\t\t\t\t\t\t\tObject bindValue,\n\t\t\t\t\t\t\tint startPosition,\n\t\t\t\t\t\t\tExecutionContext executionContext) throws SQLException {\n\t\t\t\t\t\tjdbcMapping.getJdbcValueBinder().bind(\n\t\t\t\t\t\t\t\t(CallableStatement) statement,\n\t\t\t\t\t\t\t\tbindValue,\n\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\texecutionContext.getSession()\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\treturn \"JdbcParameter(\" + name + \")\";\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\tprivate boolean canDoNameParameterBinding(\n\t\t\tBindableType<?> hibernateType,\n\t\t\tProcedureCallImplementor<?> procedureCall) {\n\t\tfinal ExtractedDatabaseMetaData databaseMetaData = procedureCall.getSession()\n\t\t\t\t.getFactory()\n\t\t\t\t.getJdbcServices()\n\t\t\t\t.getJdbcEnvironment()\n\t\t\t\t.getExtractedDatabaseMetaData();\n\t\treturn procedureCall.getFunctionReturn() == null\n\t\t\t\t&& databaseMetaData.supportsNamedParameters()\n\t\t\t\t&& hibernateType instanceof ProcedureParameterNamedBinder\n\t\t\t\t&& ( (ProcedureParameterNamedBinder<?>) hibernateType ).canDoSetting();\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn Objects.hash( name, position, mode );\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif ( this == o ) {\n\t\t\treturn true;\n\t\t}\n\t\tif ( o == null || getClass() != o.getClass() ) {\n\t\t\treturn false;\n\t\t}\n\t\tProcedureParameterImpl<?> that = (ProcedureParameterImpl<?>) o;\n\t\treturn Objects.equals( name, that.name ) &&\n\t\t\t\tObjects.equals( position, that.position ) &&\n\t\t\t\tmode == that.mode;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tif ( position == null ) {\n\t\t\treturn name;\n\t\t}\n\t\telse {\n\t\t\treturn position.toString();\n\t\t}\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/procedure/internal/ProcedureParameterImpl.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.procedure.internal;\n\nimport java.sql.CallableStatement;\nimport java.sql.DatabaseMetaData;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.util.Locale;\nimport java.util.Objects;\n\nimport org.hibernate.engine.jdbc.env.spi.ExtractedDatabaseMetaData;\nimport org.hibernate.metamodel.mapping.JdbcMapping;\nimport org.hibernate.procedure.ParameterTypeException;\nimport org.hibernate.procedure.spi.NamedCallableQueryMemento;\nimport org.hibernate.procedure.spi.ParameterStrategy;\nimport org.hibernate.procedure.spi.ProcedureCallImplementor;\nimport org.hibernate.procedure.spi.ProcedureParameterImplementor;\nimport org.hibernate.query.BindableType;\nimport org.hibernate.query.OutputableType;\nimport org.hibernate.query.internal.BindingTypeHelper;\nimport org.hibernate.query.spi.AbstractQueryParameter;\nimport org.hibernate.query.spi.QueryParameterBinding;\nimport org.hibernate.sql.exec.internal.JdbcCallParameterExtractorImpl;\nimport org.hibernate.sql.exec.internal.JdbcCallParameterRegistrationImpl;\nimport org.hibernate.sql.exec.internal.JdbcCallRefCursorExtractorImpl;\nimport org.hibernate.sql.exec.internal.JdbcParameterImpl;\nimport org.hibernate.sql.exec.spi.ExecutionContext;\nimport org.hibernate.sql.exec.spi.JdbcCallParameterRegistration;\nimport org.hibernate.sql.exec.spi.JdbcParameterBinder;\nimport org.hibernate.type.BasicType;\nimport org.hibernate.type.ProcedureParameterNamedBinder;\n\nimport jakarta.persistence.ParameterMode;\n\n/**\n * @author Steve Ebersole\n */\npublic class ProcedureParameterImpl<T> extends AbstractQueryParameter<T> implements ProcedureParameterImplementor<T> {\n\n\tprivate final String name;\n\tprivate final Integer position;\n\tprivate final ParameterMode mode;\n\tprivate final Class<T> javaType;\n\n\t/**\n\t * Used for named Query parameters\n\t */\n\tpublic ProcedureParameterImpl(\n\t\t\tString name,\n\t\t\tParameterMode mode,\n\t\t\tClass<T> javaType,\n\t\t\tBindableType<T> hibernateType) {\n\t\tsuper( false, hibernateType );\n\t\tthis.name = name;\n\t\tthis.position = null;\n\t\tthis.mode = mode;\n\t\tthis.javaType = javaType;\n\t}\n\n\t/**\n\t * Used for ordinal Query parameters\n\t */\n\tpublic ProcedureParameterImpl(\n\t\t\tInteger position,\n\t\t\tParameterMode mode,\n\t\t\tClass<T> javaType,\n\t\t\tBindableType<T> hibernateType) {\n\t\tsuper( false, hibernateType );\n\t\tthis.name = null;\n\t\tthis.position = position;\n\t\tthis.mode = mode;\n\t\tthis.javaType = javaType;\n\t}\n\n\t@Override\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\t@Override\n\tpublic Integer getPosition() {\n\t\treturn position;\n\t}\n\n\t@Override\n\tpublic ParameterMode getMode() {\n\t\treturn mode;\n\t}\n\n\t@Override\n\tpublic Class<T> getParameterType() {\n\t\treturn javaType;\n\t}\n\n\t@Override\n\tpublic NamedCallableQueryMemento.ParameterMemento toMemento() {\n\t\treturn session -> {\n\t\t\tif ( getName() != null ) {\n\t\t\t\treturn new ProcedureParameterImpl<>(\n\t\t\t\t\t\tgetName(),\n\t\t\t\t\t\tgetMode(),\n\t\t\t\t\t\tjavaType,\n\t\t\t\t\t\tgetHibernateType()\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new ProcedureParameterImpl<>(\n\t\t\t\t\t\tgetPosition(),\n\t\t\t\t\t\tgetMode(),\n\t\t\t\t\t\tjavaType,\n\t\t\t\t\t\tgetHibernateType()\n\t\t\t\t);\n\t\t\t}\n\t\t};\n\t}\n\n\t@Override\n\tpublic JdbcCallParameterRegistration toJdbcParameterRegistration(\n\t\t\tint startIndex,\n\t\t\tProcedureCallImplementor<?> procedureCall) {\n\t\tfinal QueryParameterBinding<T> binding = procedureCall.getParameterBindings().getBinding( this );\n\t\tfinal boolean isNamed = procedureCall.getParameterStrategy() == ParameterStrategy.NAMED && this.name != null;\n\n\t\tfinal BindableType<T> bindableType;\n\t\tif ( getHibernateType() != null ) {\n\t\t\tbindableType = getHibernateType();\n\t\t}\n\t\telse if ( binding != null ) {\n\t\t\t//noinspection unchecked\n\t\t\tbindableType = (BindableType<T>) binding.getBindType();\n\t\t}\n\t\telse {\n\t\t\tbindableType = null;\n\t\t}\n\n\t\tfinal OutputableType<T> typeToUse = (OutputableType<T>) BindingTypeHelper.INSTANCE.resolveTemporalPrecision(\n\t\t\t\tbinding == null ? null : binding.getExplicitTemporalPrecision(),\n\t\t\t\tbindableType,\n\t\t\t\tprocedureCall.getSession().getFactory()\n\t\t);\n\n\t\tfinal String jdbcParamName;\n\t\tfinal JdbcParameterBinder parameterBinder;\n\t\tfinal JdbcCallRefCursorExtractorImpl refCursorExtractor;\n\t\tfinal JdbcCallParameterExtractorImpl<T> parameterExtractor;\n\t\tfinal ExtractedDatabaseMetaData databaseMetaData = procedureCall.getSession()\n\t\t\t\t.getFactory()\n\t\t\t\t.getJdbcServices()\n\t\t\t\t.getJdbcEnvironment()\n\t\t\t\t.getExtractedDatabaseMetaData();\n\n\t\tswitch ( mode ) {\n\t\t\tcase REF_CURSOR:\n\t\t\t\tjdbcParamName = this.name != null && databaseMetaData.supportsNamedParameters() ? this.name : null;\n\t\t\t\trefCursorExtractor = new JdbcCallRefCursorExtractorImpl( jdbcParamName, startIndex );\n\t\t\t\tparameterBinder = null;\n\t\t\t\tparameterExtractor = null;\n\t\t\t\tbreak;\n\t\t\tcase IN:\n\t\t\t\tjdbcParamName = getJdbcParamName( procedureCall, isNamed, typeToUse, databaseMetaData );\n\t\t\t\tvalidateBindableType( typeToUse, startIndex );\n\t\t\t\tparameterBinder = getParameterBinder( typeToUse, jdbcParamName );\n\t\t\t\tparameterExtractor = null;\n\t\t\t\trefCursorExtractor = null;\n\t\t\t\tbreak;\n\t\t\tcase INOUT:\n\t\t\t\tjdbcParamName = getJdbcParamName( procedureCall, isNamed, typeToUse, databaseMetaData );\n\t\t\t\tvalidateBindableType( typeToUse, startIndex );\n\t\t\t\tparameterBinder = getParameterBinder( typeToUse, jdbcParamName );\n\t\t\t\tparameterExtractor = new JdbcCallParameterExtractorImpl<>( procedureCall.getProcedureName(), jdbcParamName, startIndex, typeToUse );\n\t\t\t\trefCursorExtractor = null;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tjdbcParamName = getJdbcParamName( procedureCall, isNamed, typeToUse, databaseMetaData );\n\t\t\t\tvalidateBindableType( typeToUse, startIndex );\n\t\t\t\tparameterBinder = null;\n\t\t\t\tparameterExtractor = new JdbcCallParameterExtractorImpl<>( procedureCall.getProcedureName(), jdbcParamName, startIndex, typeToUse );\n\t\t\t\trefCursorExtractor = null;\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn new JdbcCallParameterRegistrationImpl( jdbcParamName, startIndex, mode, typeToUse, parameterBinder, parameterExtractor, refCursorExtractor );\n\t}\n\n\tprivate String getJdbcParamName(\n\t\t\tProcedureCallImplementor<?> procedureCall,\n\t\t\tboolean isNamed,\n\t\t\tOutputableType<T> typeToUse,\n\t\t\tExtractedDatabaseMetaData databaseMetaData) {\n\t\treturn isNamed && canDoNameParameterBinding( typeToUse, procedureCall, databaseMetaData ) ? this.name : null;\n\t}\n\n\tprivate void validateBindableType(BindableType<T> bindableType, int startIndex) {\n\t\tif ( bindableType == null ) {\n\t\t\tthrow new ParameterTypeException(\n\t\t\t\t\tString.format(\n\t\t\t\t\t\t\tLocale.ROOT,\n\t\t\t\t\t\t\t\"Could not determine ProcedureCall parameter bind type - %s (%s)\",\n\t\t\t\t\t\t\tthis.name != null ? this.name : this.position,\n\t\t\t\t\t\t\tstartIndex\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate JdbcParameterBinder getParameterBinder(BindableType<T> typeToUse, String name) {\n\t\tif ( typeToUse == null ) {\n\t\t\tthrow new ParameterTypeException(\n\t\t\t\t\tString.format(\n\t\t\t\t\t\t\tLocale.ROOT,\n\t\t\t\t\t\t\t\"Cannot determine the bindable type for procedure parameter %s (%s)\",\n\t\t\t\t\t\t\tthis.name != null ? this.name : this.position,\n\t\t\t\t\t\t\tname\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tif ( typeToUse instanceof BasicType<?> ) {\n\t\t\tif ( name == null  ) {\n\t\t\t\treturn new JdbcParameterImpl( (BasicType<T>) typeToUse );\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new JdbcParameterImpl( (BasicType<T>) typeToUse ) {\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected void bindParameterValue(\n\t\t\t\t\t\t\tJdbcMapping jdbcMapping,\n\t\t\t\t\t\t\tPreparedStatement statement,\n\t\t\t\t\t\t\tObject bindValue,\n\t\t\t\t\t\t\tint startPosition,\n\t\t\t\t\t\t\tExecutionContext executionContext) throws SQLException {\n\t\t\t\t\t\tjdbcMapping.getJdbcValueBinder().bind(\n\t\t\t\t\t\t\t\t(CallableStatement) statement,\n\t\t\t\t\t\t\t\tbindValue,\n\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\texecutionContext.getSession()\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\treturn \"JdbcParameter(\" + name + \")\";\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\tprivate boolean canDoNameParameterBinding(\n\t\t\tBindableType<?> hibernateType,\n\t\t\tProcedureCallImplementor<?> procedureCall,\n\t\t\tExtractedDatabaseMetaData databaseMetaData) {\n\t\treturn procedureCall.getFunctionReturn() == null\n\t\t\t\t&& databaseMetaData.supportsNamedParameters()\n\t\t\t\t&& hibernateType instanceof ProcedureParameterNamedBinder\n\t\t\t\t&& ( (ProcedureParameterNamedBinder<?>) hibernateType ).canDoSetting();\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn Objects.hash( name, position, mode );\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif ( this == o ) {\n\t\t\treturn true;\n\t\t}\n\t\tif ( o == null || getClass() != o.getClass() ) {\n\t\t\treturn false;\n\t\t}\n\t\tProcedureParameterImpl<?> that = (ProcedureParameterImpl<?>) o;\n\t\treturn Objects.equals( name, that.name ) &&\n\t\t\t\tObjects.equals( position, that.position ) &&\n\t\t\t\tmode == that.mode;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tif ( position == null ) {\n\t\t\treturn name;\n\t\t}\n\t\telse {\n\t\t\treturn position.toString();\n\t\t}\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private String getJdbcParamName(\n\t\t\tProcedureCallImplementor<?> procedureCall,\n\t\t\tboolean isNamed,\n\t\t\tOutputableType<T> typeToUse,\n\t\t\tExtractedDatabaseMetaData databaseMetaData) {\n\t\treturn isNamed && canDoNameParameterBinding( typeToUse, procedureCall, databaseMetaData ) ? this.name : null;\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.procedure.internal.ProcedureParameterImpl#canDoNameParameterBinding\n methodBody: private boolean canDoNameParameterBinding(\n\t\t\tBindableType<?> hibernateType,\n\t\t\tProcedureCallImplementor<?> procedureCall) {\nfinal ExtractedDatabaseMetaData databaseMetaData=procedureCall.getSession().getFactory().getJdbcServices().getJdbcEnvironment().getExtractedDatabaseMetaData();\nreturn procedureCall.getFunctionReturn() == null && databaseMetaData.supportsNamedParameters() && hibernateType instanceof ProcedureParameterNamedBinder && ((ProcedureParameterNamedBinder<?>)hibernateType).canDoSetting();\n}",
            "methodSignature: org.hibernate.procedure.internal.ProcedureParameterImpl#getParameterBinder\n methodBody: private JdbcParameterBinder getParameterBinder(BindableType<T> typeToUse, String name) {\nif(typeToUse == null){throw new ParameterTypeException(String.format(Locale.ROOT,\"Cannot determine the bindable type for procedure parameter %s (%s)\",this.name != null ? this.name : this.position,name));\n}if(typeToUse instanceof BasicType<?>){if(name == null){return new JdbcParameterImpl((BasicType<T>)typeToUse);\n}{return new JdbcParameterImpl((BasicType<T>)typeToUse){\n  @Override protected void bindParameterValue(  JdbcMapping jdbcMapping,  PreparedStatement statement,  Object bindValue,  int startPosition,  ExecutionContext executionContext) throws SQLException {\n    jdbcMapping.getJdbcValueBinder().bind((CallableStatement)statement,bindValue,name,executionContext.getSession());\n  }\n  @Override public String toString(){\n    return \"JdbcParameter(\" + name + \")\";\n  }\n}\n;\n}}throw new UnsupportedOperationException();\n}",
            "methodSignature: org.hibernate.procedure.internal.ProcedureParameterImpl#validateBindableType\n methodBody: private void validateBindableType(BindableType<T> bindableType, int startIndex) {\nif(bindableType == null){throw new ParameterTypeException(String.format(Locale.ROOT,\"Could not determine ProcedureCall parameter bind type - %s (%s)\",this.name != null ? this.name : this.position,startIndex));\n}}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\tpublic JdbcCallParameterRegistration toJdbcParameterRegistration(\n\t\t\tint startIndex,\n\t\t\tProcedureCallImplementor<?> procedureCall) {\n\t\tfinal QueryParameterBinding<T> binding = procedureCall.getParameterBindings().getBinding( this );\n\t\tfinal boolean isNamed = procedureCall.getParameterStrategy() == ParameterStrategy.NAMED && this.name != null;\n\n\t\tfinal BindableType<T> bindableType;\n\t\tif ( getHibernateType() != null ) {\n\t\t\tbindableType = getHibernateType();\n\t\t}\n\t\telse if ( binding != null ) {\n\t\t\t//noinspection unchecked\n\t\t\tbindableType = (BindableType<T>) binding.getBindType();\n\t\t}\n\t\telse {\n\t\t\tbindableType = null;\n\t\t}\n\n\t\tfinal OutputableType<T> typeToUse = (OutputableType<T>) BindingTypeHelper.INSTANCE.resolveTemporalPrecision(\n\t\t\t\tbinding == null ? null : binding.getExplicitTemporalPrecision(),\n\t\t\t\tbindableType,\n\t\t\t\tprocedureCall.getSession().getFactory()\n\t\t);\n\n\t\tfinal String jdbcParamName;\n\t\tfinal JdbcParameterBinder parameterBinder;\n\t\tfinal JdbcCallRefCursorExtractorImpl refCursorExtractor;\n\t\tfinal JdbcCallParameterExtractorImpl<T> parameterExtractor;\n\t\tfinal ExtractedDatabaseMetaData databaseMetaData = procedureCall.getSession()\n\t\t\t\t.getFactory()\n\t\t\t\t.getJdbcServices()\n\t\t\t\t.getJdbcEnvironment()\n\t\t\t\t.getExtractedDatabaseMetaData();\n\n\t\tswitch ( mode ) {\n\t\t\tcase REF_CURSOR:\n\t\t\t\tjdbcParamName = this.name != null && databaseMetaData.supportsNamedParameters() ? this.name : null;\n\t\t\t\trefCursorExtractor = new JdbcCallRefCursorExtractorImpl( jdbcParamName, startIndex );\n\t\t\t\tparameterBinder = null;\n\t\t\t\tparameterExtractor = null;\n\t\t\t\tbreak;\n\t\t\tcase IN:\n\t\t\t\tjdbcParamName = getJdbcParamName( procedureCall, isNamed, typeToUse, databaseMetaData );\n\t\t\t\tvalidateBindableType( typeToUse, startIndex );\n\t\t\t\tparameterBinder = getParameterBinder( typeToUse, jdbcParamName );\n\t\t\t\tparameterExtractor = null;\n\t\t\t\trefCursorExtractor = null;\n\t\t\t\tbreak;\n\t\t\tcase INOUT:\n\t\t\t\tjdbcParamName = getJdbcParamName( procedureCall, isNamed, typeToUse, databaseMetaData );\n\t\t\t\tvalidateBindableType( typeToUse, startIndex );\n\t\t\t\tparameterBinder = getParameterBinder( typeToUse, jdbcParamName );\n\t\t\t\tparameterExtractor = new JdbcCallParameterExtractorImpl<>( procedureCall.getProcedureName(), jdbcParamName, startIndex, typeToUse );\n\t\t\t\trefCursorExtractor = null;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tjdbcParamName = getJdbcParamName( procedureCall, isNamed, typeToUse, databaseMetaData );\n\t\t\t\tvalidateBindableType( typeToUse, startIndex );\n\t\t\t\tparameterBinder = null;\n\t\t\t\tparameterExtractor = new JdbcCallParameterExtractorImpl<>( procedureCall.getProcedureName(), jdbcParamName, startIndex, typeToUse );\n\t\t\t\trefCursorExtractor = null;\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn new JdbcCallParameterRegistrationImpl( jdbcParamName, startIndex, mode, typeToUse, parameterBinder, parameterExtractor, refCursorExtractor );\n\t}\nprivate String getJdbcParamName(\n\t\t\tProcedureCallImplementor<?> procedureCall,\n\t\t\tboolean isNamed,\n\t\t\tOutputableType<T> typeToUse,\n\t\t\tExtractedDatabaseMetaData databaseMetaData) {\n\t\treturn isNamed && canDoNameParameterBinding( typeToUse, procedureCall, databaseMetaData ) ? this.name : null;\n\t}",
        "diffSourceCode": "-  121: \t@Override\n-  122: \tpublic JdbcCallParameterRegistration toJdbcParameterRegistration(\n-  123: \t\t\tint startIndex,\n-  124: \t\t\tProcedureCallImplementor<?> procedureCall) {\n-  125: \t\tfinal QueryParameterBinding<T> binding = procedureCall.getParameterBindings().getBinding( this );\n-  126: \t\tfinal boolean isNamed = procedureCall.getParameterStrategy() == ParameterStrategy.NAMED && this.name != null;\n-  127: \n-  128: \t\tfinal BindableType<T> bindableType;\n-  129: \t\tif ( getHibernateType() != null ) {\n-  130: \t\t\tbindableType = getHibernateType();\n-  131: \t\t}\n-  132: \t\telse if ( binding != null ) {\n-  133: \t\t\t//noinspection unchecked\n-  134: \t\t\tbindableType = (BindableType<T>) binding.getBindType();\n-  135: \t\t}\n-  136: \t\telse {\n-  137: \t\t\tbindableType = null;\n-  138: \t\t}\n-  139: \n-  140: \t\tfinal OutputableType<T> typeToUse = (OutputableType<T>) BindingTypeHelper.INSTANCE.resolveTemporalPrecision(\n-  141: \t\t\t\tbinding == null ? null : binding.getExplicitTemporalPrecision(),\n-  142: \t\t\t\tbindableType,\n-  143: \t\t\t\tprocedureCall.getSession().getFactory()\n-  144: \t\t);\n-  145: \n-  146: \t\tfinal String jdbcParamName;\n-  147: \t\tif ( isNamed && canDoNameParameterBinding( typeToUse, procedureCall ) ) {\n-  148: \t\t\tjdbcParamName = this.name;\n-  149: \t\t}\n-  150: \t\telse {\n-  151: \t\t\tjdbcParamName = null;\n-  152: \t\t}\n-  153: \n-  154: \t\tfinal JdbcParameterBinder parameterBinder;\n-  155: \t\tfinal JdbcCallRefCursorExtractorImpl refCursorExtractor;\n-  156: \t\tfinal JdbcCallParameterExtractorImpl<T> parameterExtractor;\n-  157: \n-  158: \t\tswitch ( mode ) {\n-  159: \t\t\tcase REF_CURSOR:\n+  121: \n+  122: \t@Override\n+  123: \tpublic JdbcCallParameterRegistration toJdbcParameterRegistration(\n+  124: \t\t\tint startIndex,\n+  125: \t\t\tProcedureCallImplementor<?> procedureCall) {\n+  126: \t\tfinal QueryParameterBinding<T> binding = procedureCall.getParameterBindings().getBinding( this );\n+  127: \t\tfinal boolean isNamed = procedureCall.getParameterStrategy() == ParameterStrategy.NAMED && this.name != null;\n+  128: \n+  129: \t\tfinal BindableType<T> bindableType;\n+  130: \t\tif ( getHibernateType() != null ) {\n+  131: \t\t\tbindableType = getHibernateType();\n+  132: \t\t}\n+  133: \t\telse if ( binding != null ) {\n+  134: \t\t\t//noinspection unchecked\n+  135: \t\t\tbindableType = (BindableType<T>) binding.getBindType();\n+  136: \t\t}\n+  137: \t\telse {\n+  138: \t\t\tbindableType = null;\n+  139: \t\t}\n+  140: \n+  141: \t\tfinal OutputableType<T> typeToUse = (OutputableType<T>) BindingTypeHelper.INSTANCE.resolveTemporalPrecision(\n+  142: \t\t\t\tbinding == null ? null : binding.getExplicitTemporalPrecision(),\n+  143: \t\t\t\tbindableType,\n+  144: \t\t\t\tprocedureCall.getSession().getFactory()\n+  145: \t\t);\n+  146: \n+  147: \t\tfinal String jdbcParamName;\n+  148: \t\tfinal JdbcParameterBinder parameterBinder;\n+  149: \t\tfinal JdbcCallRefCursorExtractorImpl refCursorExtractor;\n+  150: \t\tfinal JdbcCallParameterExtractorImpl<T> parameterExtractor;\n+  151: \t\tfinal ExtractedDatabaseMetaData databaseMetaData = procedureCall.getSession()\n+  152: \t\t\t\t.getFactory()\n+  153: \t\t\t\t.getJdbcServices()\n+  154: \t\t\t\t.getJdbcEnvironment()\n+  155: \t\t\t\t.getExtractedDatabaseMetaData();\n+  156: \n+  157: \t\tswitch ( mode ) {\n+  158: \t\t\tcase REF_CURSOR:\n+  159: \t\t\t\tjdbcParamName = this.name != null && databaseMetaData.supportsNamedParameters() ? this.name : null;\n   160: \t\t\t\trefCursorExtractor = new JdbcCallRefCursorExtractorImpl( jdbcParamName, startIndex );\n   161: \t\t\t\tparameterBinder = null;\n   162: \t\t\t\tparameterExtractor = null;\n   163: \t\t\t\tbreak;\n   164: \t\t\tcase IN:\n-  165: \t\t\t\tvalidateBindableType( typeToUse, startIndex );\n-  166: \t\t\t\tparameterBinder = getParameterBinder( typeToUse, jdbcParamName );\n-  167: \t\t\t\tparameterExtractor = null;\n-  168: \t\t\t\trefCursorExtractor = null;\n-  169: \t\t\t\tbreak;\n-  170: \t\t\tcase INOUT:\n-  171: \t\t\t\tvalidateBindableType( typeToUse, startIndex );\n-  172: \t\t\t\tparameterBinder = getParameterBinder( typeToUse, jdbcParamName );\n-  173: \t\t\t\tparameterExtractor = new JdbcCallParameterExtractorImpl<>( procedureCall.getProcedureName(), jdbcParamName, startIndex, typeToUse );\n-  174: \t\t\t\trefCursorExtractor = null;\n-  175: \t\t\t\tbreak;\n-  176: \t\t\tdefault:\n-  177: \t\t\t\tvalidateBindableType( typeToUse, startIndex );\n-  178: \t\t\t\tparameterBinder = null;\n-  179: \t\t\t\tparameterExtractor = new JdbcCallParameterExtractorImpl<>( procedureCall.getProcedureName(), jdbcParamName, startIndex, typeToUse );\n-  180: \t\t\t\trefCursorExtractor = null;\n-  181: \t\t\t\tbreak;\n-  182: \t\t}\n-  183: \n-  184: \t\treturn new JdbcCallParameterRegistrationImpl( jdbcParamName, startIndex, mode, typeToUse, parameterBinder, parameterExtractor, refCursorExtractor );\n-  185: \t}\n+  165: \t\t\t\tjdbcParamName = getJdbcParamName( procedureCall, isNamed, typeToUse, databaseMetaData );\n+  166: \t\t\t\tvalidateBindableType( typeToUse, startIndex );\n+  167: \t\t\t\tparameterBinder = getParameterBinder( typeToUse, jdbcParamName );\n+  168: \t\t\t\tparameterExtractor = null;\n+  169: \t\t\t\trefCursorExtractor = null;\n+  170: \t\t\t\tbreak;\n+  171: \t\t\tcase INOUT:\n+  172: \t\t\t\tjdbcParamName = getJdbcParamName( procedureCall, isNamed, typeToUse, databaseMetaData );\n+  173: \t\t\t\tvalidateBindableType( typeToUse, startIndex );\n+  174: \t\t\t\tparameterBinder = getParameterBinder( typeToUse, jdbcParamName );\n+  175: \t\t\t\tparameterExtractor = new JdbcCallParameterExtractorImpl<>( procedureCall.getProcedureName(), jdbcParamName, startIndex, typeToUse );\n+  176: \t\t\t\trefCursorExtractor = null;\n+  177: \t\t\t\tbreak;\n+  178: \t\t\tdefault:\n+  179: \t\t\t\tjdbcParamName = getJdbcParamName( procedureCall, isNamed, typeToUse, databaseMetaData );\n+  180: \t\t\t\tvalidateBindableType( typeToUse, startIndex );\n+  181: \t\t\t\tparameterBinder = null;\n+  182: \t\t\t\tparameterExtractor = new JdbcCallParameterExtractorImpl<>( procedureCall.getProcedureName(), jdbcParamName, startIndex, typeToUse );\n+  183: \t\t\t\trefCursorExtractor = null;\n+  184: \t\t\t\tbreak;\n+  185: \t\t}\n   186: \n-  187: \tprivate void validateBindableType(BindableType<T> bindableType, int startIndex) {\n-  188: \t\tif ( bindableType == null ) {\n-  190: \t\t\t\t\tString.format(\n-  191: \t\t\t\t\t\t\tLocale.ROOT,\n-  192: \t\t\t\t\t\t\t\"Could not determine ProcedureCall parameter bind type - %s (%s)\",\n-  193: \t\t\t\t\t\t\tthis.name != null ? this.name : this.position,\n-  194: \t\t\t\t\t\t\tstartIndex\n-  195: \t\t\t\t\t)\n-  196: \t\t\t);\n+  187: \t\treturn new JdbcCallParameterRegistrationImpl( jdbcParamName, startIndex, mode, typeToUse, parameterBinder, parameterExtractor, refCursorExtractor );\n+  188: \t}\n+  190: \tprivate String getJdbcParamName(\n+  191: \t\t\tProcedureCallImplementor<?> procedureCall,\n+  192: \t\t\tboolean isNamed,\n+  193: \t\t\tOutputableType<T> typeToUse,\n+  194: \t\t\tExtractedDatabaseMetaData databaseMetaData) {\n+  195: \t\treturn isNamed && canDoNameParameterBinding( typeToUse, procedureCall, databaseMetaData ) ? this.name : null;\n+  196: \t}\n",
        "uniqueId": "8766a8e012cd08616847f26f3ccb3e0bd7441698_121_185_190_196_122_188",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 73,
                "covered": 66
            },
            "BRANCH": {
                "missed": 13,
                "covered": 5
            },
            "LINE": {
                "missed": 17,
                "covered": 16
            },
            "COMPLEXITY": {
                "missed": 10,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\nprivate BindableType<T> determineBindableType(QueryParameterBinding<T> binding) {\n    if (getHibernateType() != null) {\n        return getHibernateType();\n    } else if (binding != null) {\n        //noinspection unchecked\n        return (BindableType<T>) binding.getBindType();\n    } else {\n        return null;\n    }\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Override\n\tpublic JdbcCallParameterRegistration toJdbcParameterRegistration(\n\t\t\tint startIndex,\n\t\t\tProcedureCallImplementor<?> procedureCall) {\n\t\tfinal QueryParameterBinding<T> binding = procedureCall.getParameterBindings().getBinding( this );\n\t\tfinal boolean isNamed = procedureCall.getParameterStrategy() == ParameterStrategy.NAMED && this.name != null;\n\n\t\tfinal BindableType<T> bindableType;\n\t\tif ( getHibernateType() != null ) {\n\t\t\tbindableType = getHibernateType();\n\t\t}\n\t\telse if ( binding != null ) {\n\t\t\t//noinspection unchecked\n\t\t\tbindableType = (BindableType<T>) binding.getBindType();\n\t\t}\n\t\telse {\n\t\t\tbindableType = null;\n\t\t}\n\n\t\tfinal OutputableType<T> typeToUse = (OutputableType<T>) BindingTypeHelper.INSTANCE.resolveTemporalPrecision(\n\t\t\t\tbinding == null ? null : binding.getExplicitTemporalPrecision(),\n\t\t\t\tbindableType,\n\t\t\t\tprocedureCall.getSession().getFactory()\n\t\t);\n\n\t\tfinal String jdbcParamName;\n\t\tif ( isNamed && canDoNameParameterBinding( typeToUse, procedureCall ) ) {\n\t\t\tjdbcParamName = this.name;\n\t\t}\n\t\telse {\n\t\t\tjdbcParamName = null;\n\t\t}\n\n\t\tfinal JdbcParameterBinder parameterBinder;\n\t\tfinal JdbcCallRefCursorExtractorImpl refCursorExtractor;\n\t\tfinal JdbcCallParameterExtractorImpl<T> parameterExtractor;\n\n\t\tswitch ( mode ) {\n\t\t\tcase REF_CURSOR:\n\t\t\t\trefCursorExtractor = new JdbcCallRefCursorExtractorImpl( jdbcParamName, startIndex );\n\t\t\t\tparameterBinder = null;\n\t\t\t\tparameterExtractor = null;\n\t\t\t\tbreak;\n\t\t\tcase IN:\n\t\t\t\tvalidateBindableType( typeToUse, startIndex );\n\t\t\t\tparameterBinder = getParameterBinder( typeToUse, jdbcParamName );\n\t\t\t\tparameterExtractor = null;\n\t\t\t\trefCursorExtractor = null;\n\t\t\t\tbreak;\n\t\t\tcase INOUT:\n\t\t\t\tvalidateBindableType( typeToUse, startIndex );\n\t\t\t\tparameterBinder = getParameterBinder( typeToUse, jdbcParamName );\n\t\t\t\tparameterExtractor = new JdbcCallParameterExtractorImpl<>( procedureCall.getProcedureName(), jdbcParamName, startIndex, typeToUse );\n\t\t\t\trefCursorExtractor = null;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tvalidateBindableType( typeToUse, startIndex );\n\t\t\t\tparameterBinder = null;\n\t\t\t\tparameterExtractor = new JdbcCallParameterExtractorImpl<>( procedureCall.getProcedureName(), jdbcParamName, startIndex, typeToUse );\n\t\t\t\trefCursorExtractor = null;\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn new JdbcCallParameterRegistrationImpl( jdbcParamName, startIndex, mode, typeToUse, parameterBinder, parameterExtractor, refCursorExtractor );\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.procedure.internal;\n\nimport java.sql.CallableStatement;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.util.Locale;\nimport java.util.Objects;\n\nimport org.hibernate.engine.jdbc.env.spi.ExtractedDatabaseMetaData;\nimport org.hibernate.metamodel.mapping.JdbcMapping;\nimport org.hibernate.procedure.ParameterTypeException;\nimport org.hibernate.procedure.spi.NamedCallableQueryMemento;\nimport org.hibernate.procedure.spi.ParameterStrategy;\nimport org.hibernate.procedure.spi.ProcedureCallImplementor;\nimport org.hibernate.procedure.spi.ProcedureParameterImplementor;\nimport org.hibernate.query.BindableType;\nimport org.hibernate.query.OutputableType;\nimport org.hibernate.query.internal.BindingTypeHelper;\nimport org.hibernate.query.spi.AbstractQueryParameter;\nimport org.hibernate.query.spi.QueryParameterBinding;\nimport org.hibernate.sql.exec.internal.JdbcCallParameterExtractorImpl;\nimport org.hibernate.sql.exec.internal.JdbcCallParameterRegistrationImpl;\nimport org.hibernate.sql.exec.internal.JdbcCallRefCursorExtractorImpl;\nimport org.hibernate.sql.exec.internal.JdbcParameterImpl;\nimport org.hibernate.sql.exec.spi.ExecutionContext;\nimport org.hibernate.sql.exec.spi.JdbcCallParameterRegistration;\nimport org.hibernate.sql.exec.spi.JdbcParameterBinder;\nimport org.hibernate.type.BasicType;\nimport org.hibernate.type.ProcedureParameterNamedBinder;\n\nimport jakarta.persistence.ParameterMode;\n\n/**\n * @author Steve Ebersole\n */\npublic class ProcedureParameterImpl<T> extends AbstractQueryParameter<T> implements ProcedureParameterImplementor<T> {\n\n\tprivate final String name;\n\tprivate final Integer position;\n\tprivate final ParameterMode mode;\n\tprivate final Class<T> javaType;\n\n\t/**\n\t * Used for named Query parameters\n\t */\n\tpublic ProcedureParameterImpl(\n\t\t\tString name,\n\t\t\tParameterMode mode,\n\t\t\tClass<T> javaType,\n\t\t\tBindableType<T> hibernateType) {\n\t\tsuper( false, hibernateType );\n\t\tthis.name = name;\n\t\tthis.position = null;\n\t\tthis.mode = mode;\n\t\tthis.javaType = javaType;\n\t}\n\n\t/**\n\t * Used for ordinal Query parameters\n\t */\n\tpublic ProcedureParameterImpl(\n\t\t\tInteger position,\n\t\t\tParameterMode mode,\n\t\t\tClass<T> javaType,\n\t\t\tBindableType<T> hibernateType) {\n\t\tsuper( false, hibernateType );\n\t\tthis.name = null;\n\t\tthis.position = position;\n\t\tthis.mode = mode;\n\t\tthis.javaType = javaType;\n\t}\n\n\t@Override\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\t@Override\n\tpublic Integer getPosition() {\n\t\treturn position;\n\t}\n\n\t@Override\n\tpublic ParameterMode getMode() {\n\t\treturn mode;\n\t}\n\n\t@Override\n\tpublic Class<T> getParameterType() {\n\t\treturn javaType;\n\t}\n\n\t@Override\n\tpublic NamedCallableQueryMemento.ParameterMemento toMemento() {\n\t\treturn session -> {\n\t\t\tif ( getName() != null ) {\n\t\t\t\treturn new ProcedureParameterImpl<>(\n\t\t\t\t\t\tgetName(),\n\t\t\t\t\t\tgetMode(),\n\t\t\t\t\t\tjavaType,\n\t\t\t\t\t\tgetHibernateType()\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new ProcedureParameterImpl<>(\n\t\t\t\t\t\tgetPosition(),\n\t\t\t\t\t\tgetMode(),\n\t\t\t\t\t\tjavaType,\n\t\t\t\t\t\tgetHibernateType()\n\t\t\t\t);\n\t\t\t}\n\t\t};\n\t}\n\n\t@Override\n\tpublic JdbcCallParameterRegistration toJdbcParameterRegistration(\n\t\t\tint startIndex,\n\t\t\tProcedureCallImplementor<?> procedureCall) {\n\t\tfinal QueryParameterBinding<T> binding = procedureCall.getParameterBindings().getBinding( this );\n\t\tfinal boolean isNamed = procedureCall.getParameterStrategy() == ParameterStrategy.NAMED && this.name != null;\n\n\t\tfinal BindableType<T> bindableType;\n\t\tif ( getHibernateType() != null ) {\n\t\t\tbindableType = getHibernateType();\n\t\t}\n\t\telse if ( binding != null ) {\n\t\t\t//noinspection unchecked\n\t\t\tbindableType = (BindableType<T>) binding.getBindType();\n\t\t}\n\t\telse {\n\t\t\tbindableType = null;\n\t\t}\n\n\t\tfinal OutputableType<T> typeToUse = (OutputableType<T>) BindingTypeHelper.INSTANCE.resolveTemporalPrecision(\n\t\t\t\tbinding == null ? null : binding.getExplicitTemporalPrecision(),\n\t\t\t\tbindableType,\n\t\t\t\tprocedureCall.getSession().getFactory()\n\t\t);\n\n\t\tfinal String jdbcParamName;\n\t\tif ( isNamed && canDoNameParameterBinding( typeToUse, procedureCall ) ) {\n\t\t\tjdbcParamName = this.name;\n\t\t}\n\t\telse {\n\t\t\tjdbcParamName = null;\n\t\t}\n\n\t\tfinal JdbcParameterBinder parameterBinder;\n\t\tfinal JdbcCallRefCursorExtractorImpl refCursorExtractor;\n\t\tfinal JdbcCallParameterExtractorImpl<T> parameterExtractor;\n\n\t\tswitch ( mode ) {\n\t\t\tcase REF_CURSOR:\n\t\t\t\trefCursorExtractor = new JdbcCallRefCursorExtractorImpl( jdbcParamName, startIndex );\n\t\t\t\tparameterBinder = null;\n\t\t\t\tparameterExtractor = null;\n\t\t\t\tbreak;\n\t\t\tcase IN:\n\t\t\t\tvalidateBindableType( typeToUse, startIndex );\n\t\t\t\tparameterBinder = getParameterBinder( typeToUse, jdbcParamName );\n\t\t\t\tparameterExtractor = null;\n\t\t\t\trefCursorExtractor = null;\n\t\t\t\tbreak;\n\t\t\tcase INOUT:\n\t\t\t\tvalidateBindableType( typeToUse, startIndex );\n\t\t\t\tparameterBinder = getParameterBinder( typeToUse, jdbcParamName );\n\t\t\t\tparameterExtractor = new JdbcCallParameterExtractorImpl<>( procedureCall.getProcedureName(), jdbcParamName, startIndex, typeToUse );\n\t\t\t\trefCursorExtractor = null;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tvalidateBindableType( typeToUse, startIndex );\n\t\t\t\tparameterBinder = null;\n\t\t\t\tparameterExtractor = new JdbcCallParameterExtractorImpl<>( procedureCall.getProcedureName(), jdbcParamName, startIndex, typeToUse );\n\t\t\t\trefCursorExtractor = null;\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn new JdbcCallParameterRegistrationImpl( jdbcParamName, startIndex, mode, typeToUse, parameterBinder, parameterExtractor, refCursorExtractor );\n\t}\n\n\tprivate void validateBindableType(BindableType<T> bindableType, int startIndex) {\n\t\tif ( bindableType == null ) {\n\t\t\tthrow new ParameterTypeException(\n\t\t\t\t\tString.format(\n\t\t\t\t\t\t\tLocale.ROOT,\n\t\t\t\t\t\t\t\"Could not determine ProcedureCall parameter bind type - %s (%s)\",\n\t\t\t\t\t\t\tthis.name != null ? this.name : this.position,\n\t\t\t\t\t\t\tstartIndex\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate JdbcParameterBinder getParameterBinder(BindableType<T> typeToUse, String name) {\n\t\tif ( typeToUse == null ) {\n\t\t\tthrow new ParameterTypeException(\n\t\t\t\t\tString.format(\n\t\t\t\t\t\t\tLocale.ROOT,\n\t\t\t\t\t\t\t\"Cannot determine the bindable type for procedure parameter %s (%s)\",\n\t\t\t\t\t\t\tthis.name != null ? this.name : this.position,\n\t\t\t\t\t\t\tname\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tif ( typeToUse instanceof BasicType<?> ) {\n\t\t\tif ( name == null ) {\n\t\t\t\treturn new JdbcParameterImpl( (BasicType<T>) typeToUse );\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new JdbcParameterImpl( (BasicType<T>) typeToUse ) {\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected void bindParameterValue(\n\t\t\t\t\t\t\tJdbcMapping jdbcMapping,\n\t\t\t\t\t\t\tPreparedStatement statement,\n\t\t\t\t\t\t\tObject bindValue,\n\t\t\t\t\t\t\tint startPosition,\n\t\t\t\t\t\t\tExecutionContext executionContext) throws SQLException {\n\t\t\t\t\t\tjdbcMapping.getJdbcValueBinder().bind(\n\t\t\t\t\t\t\t\t(CallableStatement) statement,\n\t\t\t\t\t\t\t\tbindValue,\n\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\texecutionContext.getSession()\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String toString() {\n\t\t\t\t\t\treturn \"JdbcParameter(\" + name + \")\";\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\tprivate boolean canDoNameParameterBinding(\n\t\t\tBindableType<?> hibernateType,\n\t\t\tProcedureCallImplementor<?> procedureCall) {\n\t\tfinal ExtractedDatabaseMetaData databaseMetaData = procedureCall.getSession()\n\t\t\t\t.getFactory()\n\t\t\t\t.getJdbcServices()\n\t\t\t\t.getJdbcEnvironment()\n\t\t\t\t.getExtractedDatabaseMetaData();\n\t\treturn procedureCall.getFunctionReturn() == null\n\t\t\t\t&& databaseMetaData.supportsNamedParameters()\n\t\t\t\t&& hibernateType instanceof ProcedureParameterNamedBinder\n\t\t\t\t&& ( (ProcedureParameterNamedBinder<?>) hibernateType ).canDoSetting();\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn Objects.hash( name, position, mode );\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif ( this == o ) {\n\t\t\treturn true;\n\t\t}\n\t\tif ( o == null || getClass() != o.getClass() ) {\n\t\t\treturn false;\n\t\t}\n\t\tProcedureParameterImpl<?> that = (ProcedureParameterImpl<?>) o;\n\t\treturn Objects.equals( name, that.name ) &&\n\t\t\t\tObjects.equals( position, that.position ) &&\n\t\t\t\tmode == that.mode;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tif ( position == null ) {\n\t\t\treturn name;\n\t\t}\n\t\telse {\n\t\t\treturn position.toString();\n\t\t}\n\t}\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate extractIsolationAsString(properties Map<String,Object>) : String extracted from private resolveIsolationSetting(properties Map<String,Object>, cf AgroalConnectionFactoryConfigurationSupplier) : void in class org.hibernate.agroal.internal.AgroalConnectionProvider",
        "diffLocations": [
            {
                "filePath": "hibernate-agroal/src/main/java/org/hibernate/agroal/internal/AgroalConnectionProvider.java",
                "startLine": 64,
                "endLine": 71,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-agroal/src/main/java/org/hibernate/agroal/internal/AgroalConnectionProvider.java",
                "startLine": 80,
                "endLine": 85,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-agroal/src/main/java/org/hibernate/agroal/internal/AgroalConnectionProvider.java",
                "startLine": 71,
                "endLine": 78,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private static void resolveIsolationSetting(Map<String, Object> properties, AgroalConnectionFactoryConfigurationSupplier cf) {\n\t\tInteger isolation = ConnectionProviderInitiator.extractIsolation( properties );\n\t\tif ( isolation != null ) {\n\t\t\t// Agroal resolves transaction isolation from the 'nice' name\n\t\t\tString isolationString = ConnectionProviderInitiator.toIsolationNiceName( isolation );\n\t\t\tcf.jdbcTransactionIsolation( AgroalConnectionFactoryConfiguration.TransactionIsolation.valueOf( isolationString ) );\n\t\t}\n\t}",
        "filePathBefore": "hibernate-agroal/src/main/java/org/hibernate/agroal/internal/AgroalConnectionProvider.java",
        "isPureRefactoring": true,
        "commitId": "f556ba9e909d6258f4ab041bd61fb6fa8e1a57e0",
        "packageNameBefore": "org.hibernate.agroal.internal",
        "classNameBefore": "org.hibernate.agroal.internal.AgroalConnectionProvider",
        "methodNameBefore": "org.hibernate.agroal.internal.AgroalConnectionProvider#resolveIsolationSetting",
        "classSignatureBefore": "public class AgroalConnectionProvider implements ConnectionProvider, Configurable, Stoppable ",
        "methodNameBeforeSet": [
            "org.hibernate.agroal.internal.AgroalConnectionProvider#resolveIsolationSetting"
        ],
        "classNameBeforeSet": [
            "org.hibernate.agroal.internal.AgroalConnectionProvider"
        ],
        "classSignatureBeforeSet": [
            "public class AgroalConnectionProvider implements ConnectionProvider, Configurable, Stoppable "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics Severe changes",
                "description": "Return expression has been added within the Extract Method mechanics - with non-mapped leaves",
                "mappingState": 2
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\n\npackage org.hibernate.agroal.internal;\n\nimport io.agroal.api.AgroalDataSource;\nimport io.agroal.api.configuration.AgroalConnectionFactoryConfiguration;\nimport io.agroal.api.configuration.supplier.AgroalConnectionFactoryConfigurationSupplier;\nimport io.agroal.api.configuration.supplier.AgroalPropertiesReader;\nimport io.agroal.api.security.NamePrincipal;\nimport io.agroal.api.security.SimplePassword;\nimport org.hibernate.HibernateException;\nimport org.hibernate.cfg.AgroalSettings;\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.engine.jdbc.connections.internal.ConnectionProviderInitiator;\nimport org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;\nimport org.hibernate.service.UnknownUnwrapTypeException;\nimport org.hibernate.service.spi.Configurable;\nimport org.hibernate.service.spi.Stoppable;\nimport org.jboss.logging.Logger;\n\nimport javax.sql.DataSource;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Map;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\n\n/**\n * ConnectionProvider based on Agroal connection pool\n * To use this ConnectionProvider set: <pre> hibernate.connection.provider_class AgroalConnectionProvider </pre>\n *\n * Usual hibernate properties are supported:\n * <pre>\n *     hibernate.connection.driver_class\n *     hibernate.connection.url\n *     hibernate.connection.username\n *     hibernate.connection.password\n *     hibernate.connection.autocommit\n *     hibernate.connection.isolation\n * </pre>\n *\n * Other configuration options are available, using the {@code hibernate.agroal} prefix\n *\n * @see AgroalSettings\n * @see AgroalPropertiesReader\n * @see AvailableSettings#CONNECTION_PROVIDER\n *\n * @author Luis Barreiro\n */\npublic class AgroalConnectionProvider implements ConnectionProvider, Configurable, Stoppable {\n\n\tpublic static final String CONFIG_PREFIX = AgroalSettings.AGROAL_CONFIG_PREFIX + \".\";\n\tprivate static final long serialVersionUID = 1L;\n\tprivate static final Logger LOGGER = Logger.getLogger( AgroalConnectionProvider.class );\n\tprivate AgroalDataSource agroalDataSource = null;\n\n\t// --- Configurable\n\n\tprivate static void resolveIsolationSetting(Map<String, Object> properties, AgroalConnectionFactoryConfigurationSupplier cf) {\n\t\tInteger isolation = ConnectionProviderInitiator.extractIsolation( properties );\n\t\tif ( isolation != null ) {\n\t\t\t// Agroal resolves transaction isolation from the 'nice' name\n\t\t\tString isolationString = ConnectionProviderInitiator.toIsolationNiceName( isolation );\n\t\t\tcf.jdbcTransactionIsolation( AgroalConnectionFactoryConfiguration.TransactionIsolation.valueOf( isolationString ) );\n\t\t}\n\t}\n\n\tprivate static <T> void copyProperty(Map<String, Object> properties, String key, Consumer<T> consumer, Function<String, T> converter) {\n\t\tObject value = properties.get( key );\n\t\tif ( value instanceof String ) {\n\t\t\tconsumer.accept( converter.apply( (String) value ) );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void configure(Map<String, Object> props) throws HibernateException {\n\t\tLOGGER.debug( \"Configuring Agroal\" );\n\t\ttry {\n\t\t\tAgroalPropertiesReader agroalProperties = new AgroalPropertiesReader( CONFIG_PREFIX )\n\t\t\t\t\t.readProperties( (Map) props ); //TODO: this is a garbage cast\n\t\t\tagroalProperties.modify().connectionPoolConfiguration( cp -> cp.connectionFactoryConfiguration( cf -> {\n\t\t\t\tcopyProperty( props, AvailableSettings.DRIVER, cf::connectionProviderClassName, Function.identity() );\n\t\t\t\tcopyProperty( props, AvailableSettings.URL, cf::jdbcUrl, Function.identity() );\n\t\t\t\tcopyProperty( props, AvailableSettings.USER, cf::principal, NamePrincipal::new );\n\t\t\t\tcopyProperty( props, AvailableSettings.PASS, cf::credential, SimplePassword::new );\n\t\t\t\tcopyProperty( props, AvailableSettings.AUTOCOMMIT, cf::autoCommit, Boolean::valueOf );\n\t\t\t\tresolveIsolationSetting( props, cf );\n\t\t\t\treturn cf;\n\t\t\t} ) );\n\n\t\t\tagroalDataSource = AgroalDataSource.from( agroalProperties );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\tthrow new HibernateException( e );\n\t\t}\n\t\tLOGGER.debug( \"Agroal Configured\" );\n\t}\n\n\t// --- ConnectionProvider\n\n\t@Override\n\tpublic Connection getConnection() throws SQLException {\n\t\treturn agroalDataSource == null ? null : agroalDataSource.getConnection();\n\t}\n\n\t@Override\n\tpublic void closeConnection(Connection connection) throws SQLException {\n\t\tconnection.close();\n\t}\n\n\t@Override\n\tpublic boolean supportsAggressiveRelease() {\n\t\t// Agroal supports integration with Narayana as the JTA provider, that would enable aggressive release\n\t\t// That logic is similar with what Hibernate does (however with better performance since it's integrated in the pool)\n\t\t// and therefore that integration is not leveraged right now.\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isUnwrappableAs(Class<?> unwrapType) {\n\t\treturn ConnectionProvider.class.equals( unwrapType )\n\t\t\t|| AgroalConnectionProvider.class.isAssignableFrom( unwrapType )\n\t\t\t|| DataSource.class.isAssignableFrom( unwrapType );\n\t}\n\n\t@Override\n\t@SuppressWarnings( \"unchecked\" )\n\tpublic <T> T unwrap(Class<T> unwrapType) {\n\t\tif ( ConnectionProvider.class.equals( unwrapType )\n\t\t\t\t|| AgroalConnectionProvider.class.isAssignableFrom( unwrapType ) ) {\n\t\t\treturn (T) this;\n\t\t}\n\t\tif ( DataSource.class.isAssignableFrom( unwrapType ) ) {\n\t\t\treturn (T) agroalDataSource;\n\t\t}\n\t\tthrow new UnknownUnwrapTypeException( unwrapType );\n\t}\n\n\t// --- Stoppable\n\n\t@Override\n\tpublic void stop() {\n\t\tif ( agroalDataSource != null ) {\n\t\t\tagroalDataSource.close();\n\t\t}\n\t}\n}\n",
        "filePathAfter": "hibernate-agroal/src/main/java/org/hibernate/agroal/internal/AgroalConnectionProvider.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\n\npackage org.hibernate.agroal.internal;\n\nimport io.agroal.api.AgroalDataSource;\nimport io.agroal.api.configuration.AgroalConnectionFactoryConfiguration;\nimport io.agroal.api.configuration.AgroalConnectionPoolConfiguration;\nimport io.agroal.api.configuration.supplier.AgroalConnectionFactoryConfigurationSupplier;\nimport io.agroal.api.configuration.supplier.AgroalPropertiesReader;\nimport io.agroal.api.security.NamePrincipal;\nimport io.agroal.api.security.SimplePassword;\nimport org.hibernate.HibernateException;\nimport org.hibernate.cfg.AgroalSettings;\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.engine.jdbc.connections.internal.ConnectionProviderInitiator;\nimport org.hibernate.engine.jdbc.connections.internal.DatabaseConnectionInfoImpl;\nimport org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;\nimport org.hibernate.engine.jdbc.connections.spi.DatabaseConnectionInfo;\nimport org.hibernate.service.UnknownUnwrapTypeException;\nimport org.hibernate.service.spi.Configurable;\nimport org.hibernate.service.spi.Stoppable;\n\nimport javax.sql.DataSource;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Map;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\n\nimport org.jboss.logging.Logger;\n\nimport static org.hibernate.cfg.AgroalSettings.AGROAL_CONFIG_PREFIX;\n\n/**\n * ConnectionProvider based on Agroal connection pool\n * To use this ConnectionProvider set: <pre> hibernate.connection.provider_class AgroalConnectionProvider </pre>\n *\n * Usual hibernate properties are supported:\n * <pre>\n *     hibernate.connection.driver_class\n *     hibernate.connection.url\n *     hibernate.connection.username\n *     hibernate.connection.password\n *     hibernate.connection.autocommit\n *     hibernate.connection.isolation\n * </pre>\n *\n * Other configuration options are available, using the {@code hibernate.agroal} prefix\n *\n * @see AgroalSettings\n * @see AgroalPropertiesReader\n * @see AvailableSettings#CONNECTION_PROVIDER\n *\n * @author Luis Barreiro\n */\npublic class AgroalConnectionProvider implements ConnectionProvider, Configurable, Stoppable {\n\n\tpublic static final String CONFIG_PREFIX = AGROAL_CONFIG_PREFIX + \".\";\n\tprivate static final long serialVersionUID = 1L;\n\tprivate static final Logger LOGGER = Logger.getLogger( AgroalConnectionProvider.class );\n\tprivate AgroalDataSource agroalDataSource = null;\n\tprivate DatabaseConnectionInfo dbInfo;\n\n\t// --- Configurable\n\n\tprivate static String extractIsolationAsString(Map<String, Object> properties) {\n\t\tInteger isolation = ConnectionProviderInitiator.extractIsolation( properties );\n\t\tif ( isolation != null ) {\n\t\t\t// Agroal resolves transaction isolation from the 'nice' name\n\t\t\treturn ConnectionProviderInitiator.toIsolationNiceName( isolation );\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate static void resolveIsolationSetting(Map<String, Object> properties, AgroalConnectionFactoryConfigurationSupplier cf) {\n\t\tString isolationString = extractIsolationAsString( properties );\n\t\tif ( isolationString != null ) {\n\t\t\tcf.jdbcTransactionIsolation( AgroalConnectionFactoryConfiguration.TransactionIsolation.valueOf( isolationString ) );\n\t\t}\n\t}\n\n\tprivate static <T> void copyProperty(Map<String, Object> properties, String key, Consumer<T> consumer, Function<String, T> converter) {\n\t\tObject value = properties.get( key );\n\t\tif ( value instanceof String ) {\n\t\t\tconsumer.accept( converter.apply( (String) value ) );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void configure(Map<String, Object> props) throws HibernateException {\n\t\tLOGGER.debug( \"Configuring Agroal\" );\n\t\ttry {\n\t\t\tAgroalPropertiesReader agroalProperties = new AgroalPropertiesReader( CONFIG_PREFIX )\n\t\t\t\t\t.readProperties( (Map) props ); //TODO: this is a garbage cast\n\t\t\tagroalProperties.modify().connectionPoolConfiguration( cp -> cp.connectionFactoryConfiguration( cf -> {\n\t\t\t\tcopyProperty( props, AvailableSettings.DRIVER, cf::connectionProviderClassName, Function.identity() );\n\t\t\t\tcopyProperty( props, AvailableSettings.URL, cf::jdbcUrl, Function.identity() );\n\t\t\t\tcopyProperty( props, AvailableSettings.USER, cf::principal, NamePrincipal::new );\n\t\t\t\tcopyProperty( props, AvailableSettings.PASS, cf::credential, SimplePassword::new );\n\t\t\t\tcopyProperty( props, AvailableSettings.AUTOCOMMIT, cf::autoCommit, Boolean::valueOf );\n\t\t\t\tresolveIsolationSetting( props, cf );\n\t\t\t\treturn cf;\n\t\t\t} ) );\n\n\t\t\tagroalDataSource = AgroalDataSource.from( agroalProperties );\n\n\t\t\t// For logging purposes\n\t\t\tAgroalConnectionPoolConfiguration acpc = agroalDataSource.getConfiguration().connectionPoolConfiguration();\n\t\t\tAgroalConnectionFactoryConfiguration acfc = acpc.connectionFactoryConfiguration();\n\t\t\tdbInfo = new DatabaseConnectionInfoImpl()\n\t\t\t\t\t.setDBUrl( acfc.jdbcUrl() )\n\t\t\t\t\t.setDBDriverName( acfc.connectionProviderClass().toString() )\n\t\t\t\t\t.setDBAutoCommitMode( Boolean.toString(acfc.autoCommit()) )\n\t\t\t\t\t.setDBIsolationLevel( acfc.jdbcTransactionIsolation() != null ?\n\t\t\t\t\t\t\tConnectionProviderInitiator.toIsolationNiceName( acfc.jdbcTransactionIsolation().level() ) : null )\n\t\t\t\t\t.setDBMinPoolSize( String.valueOf(acpc.minSize()) )\n\t\t\t\t\t.setDBMaxPoolSize( String.valueOf(acpc.maxSize()) );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\tthrow new HibernateException( e );\n\t\t}\n\t\tLOGGER.debug( \"Agroal Configured\" );\n\t}\n\n\t// --- ConnectionProvider\n\n\t@Override\n\tpublic Connection getConnection() throws SQLException {\n\t\treturn agroalDataSource == null ? null : agroalDataSource.getConnection();\n\t}\n\n\t@Override\n\tpublic void closeConnection(Connection connection) throws SQLException {\n\t\tconnection.close();\n\t}\n\n\t@Override\n\tpublic boolean supportsAggressiveRelease() {\n\t\t// Agroal supports integration with Narayana as the JTA provider, that would enable aggressive release\n\t\t// That logic is similar with what Hibernate does (however with better performance since it's integrated in the pool)\n\t\t// and therefore that integration is not leveraged right now.\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic DatabaseConnectionInfo getDatabaseConnectionInfo() {\n\t\treturn dbInfo;\n\t}\n\n\t@Override\n\tpublic boolean isUnwrappableAs(Class<?> unwrapType) {\n\t\treturn ConnectionProvider.class.equals( unwrapType )\n\t\t\t|| AgroalConnectionProvider.class.isAssignableFrom( unwrapType )\n\t\t\t|| DataSource.class.isAssignableFrom( unwrapType );\n\t}\n\n\t@Override\n\t@SuppressWarnings( \"unchecked\" )\n\tpublic <T> T unwrap(Class<T> unwrapType) {\n\t\tif ( ConnectionProvider.class.equals( unwrapType )\n\t\t\t\t|| AgroalConnectionProvider.class.isAssignableFrom( unwrapType ) ) {\n\t\t\treturn (T) this;\n\t\t}\n\t\tif ( DataSource.class.isAssignableFrom( unwrapType ) ) {\n\t\t\treturn (T) agroalDataSource;\n\t\t}\n\t\tthrow new UnknownUnwrapTypeException( unwrapType );\n\t}\n\n\t// --- Stoppable\n\n\t@Override\n\tpublic void stop() {\n\t\tif ( agroalDataSource != null ) {\n\t\t\tagroalDataSource.close();\n\t\t}\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private static String extractIsolationAsString(Map<String, Object> properties) {\n\t\tInteger isolation = ConnectionProviderInitiator.extractIsolation( properties );\n\t\tif ( isolation != null ) {\n\t\t\t// Agroal resolves transaction isolation from the 'nice' name\n\t\t\treturn ConnectionProviderInitiator.toIsolationNiceName( isolation );\n\t\t}\n\t\treturn null;\n\t}"
        ],
        "invokedMethodSet": [],
        "sourceCodeAfterRefactoring": "private static void resolveIsolationSetting(Map<String, Object> properties, AgroalConnectionFactoryConfigurationSupplier cf) {\n\t\tString isolationString = extractIsolationAsString( properties );\n\t\tif ( isolationString != null ) {\n\t\t\tcf.jdbcTransactionIsolation( AgroalConnectionFactoryConfiguration.TransactionIsolation.valueOf( isolationString ) );\n\t\t}\n\t}\nprivate static String extractIsolationAsString(Map<String, Object> properties) {\n\t\tInteger isolation = ConnectionProviderInitiator.extractIsolation( properties );\n\t\tif ( isolation != null ) {\n\t\t\t// Agroal resolves transaction isolation from the 'nice' name\n\t\t\treturn ConnectionProviderInitiator.toIsolationNiceName( isolation );\n\t\t}\n\t\treturn null;\n\t}",
        "diffSourceCode": "-   64: \tprivate static void resolveIsolationSetting(Map<String, Object> properties, AgroalConnectionFactoryConfigurationSupplier cf) {\n-   65: \t\tInteger isolation = ConnectionProviderInitiator.extractIsolation( properties );\n-   66: \t\tif ( isolation != null ) {\n-   67: \t\t\t// Agroal resolves transaction isolation from the 'nice' name\n-   68: \t\t\tString isolationString = ConnectionProviderInitiator.toIsolationNiceName( isolation );\n-   69: \t\t\tcf.jdbcTransactionIsolation( AgroalConnectionFactoryConfiguration.TransactionIsolation.valueOf( isolationString ) );\n-   70: \t\t}\n-   71: \t}\n-   72: \n-   73: \tprivate static <T> void copyProperty(Map<String, Object> properties, String key, Consumer<T> consumer, Function<String, T> converter) {\n-   74: \t\tObject value = properties.get( key );\n-   75: \t\tif ( value instanceof String ) {\n-   76: \t\t\tconsumer.accept( converter.apply( (String) value ) );\n-   77: \t\t}\n+   64: \tprivate static final long serialVersionUID = 1L;\n+   65: \tprivate static final Logger LOGGER = Logger.getLogger( AgroalConnectionProvider.class );\n+   66: \tprivate AgroalDataSource agroalDataSource = null;\n+   67: \tprivate DatabaseConnectionInfo dbInfo;\n+   68: \n+   69: \t// --- Configurable\n+   70: \n+   71: \tprivate static String extractIsolationAsString(Map<String, Object> properties) {\n+   72: \t\tInteger isolation = ConnectionProviderInitiator.extractIsolation( properties );\n+   73: \t\tif ( isolation != null ) {\n+   74: \t\t\t// Agroal resolves transaction isolation from the 'nice' name\n+   75: \t\t\treturn ConnectionProviderInitiator.toIsolationNiceName( isolation );\n+   76: \t\t}\n+   77: \t\treturn null;\n    78: \t}\n-   80: \t@Override\n-   81: \tpublic void configure(Map<String, Object> props) throws HibernateException {\n-   82: \t\tLOGGER.debug( \"Configuring Agroal\" );\n-   83: \t\ttry {\n-   84: \t\t\tAgroalPropertiesReader agroalProperties = new AgroalPropertiesReader( CONFIG_PREFIX )\n-   85: \t\t\t\t\t.readProperties( (Map) props ); //TODO: this is a garbage cast\n+   80: \tprivate static void resolveIsolationSetting(Map<String, Object> properties, AgroalConnectionFactoryConfigurationSupplier cf) {\n+   81: \t\tString isolationString = extractIsolationAsString( properties );\n+   82: \t\tif ( isolationString != null ) {\n+   83: \t\t\tcf.jdbcTransactionIsolation( AgroalConnectionFactoryConfiguration.TransactionIsolation.valueOf( isolationString ) );\n+   84: \t\t}\n+   85: \t}\n",
        "uniqueId": "f556ba9e909d6258f4ab041bd61fb6fa8e1a57e0_64_71_71_78_80_85",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 14
            },
            "BRANCH": {
                "missed": 0,
                "covered": 2
            },
            "LINE": {
                "missed": 0,
                "covered": 5
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 2
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\nprivate static <T> void copyProperty(Map<String, Object> properties, String key, Consumer<T> consumer, Function<String, T> converter) {\n    Object value = properties.get(key);\n    if (value instanceof String) {\n        consumer.accept(converter.apply((String) value));\n    }\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprivate static void resolveIsolationSetting(Map<String, Object> properties, AgroalConnectionFactoryConfigurationSupplier cf) {\n\t\tInteger isolation = ConnectionProviderInitiator.extractIsolation( properties );\n\t\tif ( isolation != null ) {\n\t\t\t// Agroal resolves transaction isolation from the 'nice' name\n\t\t\tString isolationString = ConnectionProviderInitiator.toIsolationNiceName( isolation );\n\t\t\tcf.jdbcTransactionIsolation( AgroalConnectionFactoryConfiguration.TransactionIsolation.valueOf( isolationString ) );\n\t\t}\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\n\npackage org.hibernate.agroal.internal;\n\nimport io.agroal.api.AgroalDataSource;\nimport io.agroal.api.configuration.AgroalConnectionFactoryConfiguration;\nimport io.agroal.api.configuration.supplier.AgroalConnectionFactoryConfigurationSupplier;\nimport io.agroal.api.configuration.supplier.AgroalPropertiesReader;\nimport io.agroal.api.security.NamePrincipal;\nimport io.agroal.api.security.SimplePassword;\nimport org.hibernate.HibernateException;\nimport org.hibernate.cfg.AgroalSettings;\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.engine.jdbc.connections.internal.ConnectionProviderInitiator;\nimport org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;\nimport org.hibernate.service.UnknownUnwrapTypeException;\nimport org.hibernate.service.spi.Configurable;\nimport org.hibernate.service.spi.Stoppable;\nimport org.jboss.logging.Logger;\n\nimport javax.sql.DataSource;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Map;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\n\n/**\n * ConnectionProvider based on Agroal connection pool\n * To use this ConnectionProvider set: <pre> hibernate.connection.provider_class AgroalConnectionProvider </pre>\n *\n * Usual hibernate properties are supported:\n * <pre>\n *     hibernate.connection.driver_class\n *     hibernate.connection.url\n *     hibernate.connection.username\n *     hibernate.connection.password\n *     hibernate.connection.autocommit\n *     hibernate.connection.isolation\n * </pre>\n *\n * Other configuration options are available, using the {@code hibernate.agroal} prefix\n *\n * @see AgroalSettings\n * @see AgroalPropertiesReader\n * @see AvailableSettings#CONNECTION_PROVIDER\n *\n * @author Luis Barreiro\n */\npublic class AgroalConnectionProvider implements ConnectionProvider, Configurable, Stoppable {\n\n\tpublic static final String CONFIG_PREFIX = AgroalSettings.AGROAL_CONFIG_PREFIX + \".\";\n\tprivate static final long serialVersionUID = 1L;\n\tprivate static final Logger LOGGER = Logger.getLogger( AgroalConnectionProvider.class );\n\tprivate AgroalDataSource agroalDataSource = null;\n\n\t// --- Configurable\n\n\tprivate static void resolveIsolationSetting(Map<String, Object> properties, AgroalConnectionFactoryConfigurationSupplier cf) {\n\t\tInteger isolation = ConnectionProviderInitiator.extractIsolation( properties );\n\t\tif ( isolation != null ) {\n\t\t\t// Agroal resolves transaction isolation from the 'nice' name\n\t\t\tString isolationString = ConnectionProviderInitiator.toIsolationNiceName( isolation );\n\t\t\tcf.jdbcTransactionIsolation( AgroalConnectionFactoryConfiguration.TransactionIsolation.valueOf( isolationString ) );\n\t\t}\n\t}\n\n\tprivate static <T> void copyProperty(Map<String, Object> properties, String key, Consumer<T> consumer, Function<String, T> converter) {\n\t\tObject value = properties.get( key );\n\t\tif ( value instanceof String ) {\n\t\t\tconsumer.accept( converter.apply( (String) value ) );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void configure(Map<String, Object> props) throws HibernateException {\n\t\tLOGGER.debug( \"Configuring Agroal\" );\n\t\ttry {\n\t\t\tAgroalPropertiesReader agroalProperties = new AgroalPropertiesReader( CONFIG_PREFIX )\n\t\t\t\t\t.readProperties( (Map) props ); //TODO: this is a garbage cast\n\t\t\tagroalProperties.modify().connectionPoolConfiguration( cp -> cp.connectionFactoryConfiguration( cf -> {\n\t\t\t\tcopyProperty( props, AvailableSettings.DRIVER, cf::connectionProviderClassName, Function.identity() );\n\t\t\t\tcopyProperty( props, AvailableSettings.URL, cf::jdbcUrl, Function.identity() );\n\t\t\t\tcopyProperty( props, AvailableSettings.USER, cf::principal, NamePrincipal::new );\n\t\t\t\tcopyProperty( props, AvailableSettings.PASS, cf::credential, SimplePassword::new );\n\t\t\t\tcopyProperty( props, AvailableSettings.AUTOCOMMIT, cf::autoCommit, Boolean::valueOf );\n\t\t\t\tresolveIsolationSetting( props, cf );\n\t\t\t\treturn cf;\n\t\t\t} ) );\n\n\t\t\tagroalDataSource = AgroalDataSource.from( agroalProperties );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\tthrow new HibernateException( e );\n\t\t}\n\t\tLOGGER.debug( \"Agroal Configured\" );\n\t}\n\n\t// --- ConnectionProvider\n\n\t@Override\n\tpublic Connection getConnection() throws SQLException {\n\t\treturn agroalDataSource == null ? null : agroalDataSource.getConnection();\n\t}\n\n\t@Override\n\tpublic void closeConnection(Connection connection) throws SQLException {\n\t\tconnection.close();\n\t}\n\n\t@Override\n\tpublic boolean supportsAggressiveRelease() {\n\t\t// Agroal supports integration with Narayana as the JTA provider, that would enable aggressive release\n\t\t// That logic is similar with what Hibernate does (however with better performance since it's integrated in the pool)\n\t\t// and therefore that integration is not leveraged right now.\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isUnwrappableAs(Class<?> unwrapType) {\n\t\treturn ConnectionProvider.class.equals( unwrapType )\n\t\t\t|| AgroalConnectionProvider.class.isAssignableFrom( unwrapType )\n\t\t\t|| DataSource.class.isAssignableFrom( unwrapType );\n\t}\n\n\t@Override\n\t@SuppressWarnings( \"unchecked\" )\n\tpublic <T> T unwrap(Class<T> unwrapType) {\n\t\tif ( ConnectionProvider.class.equals( unwrapType )\n\t\t\t\t|| AgroalConnectionProvider.class.isAssignableFrom( unwrapType ) ) {\n\t\t\treturn (T) this;\n\t\t}\n\t\tif ( DataSource.class.isAssignableFrom( unwrapType ) ) {\n\t\t\treturn (T) agroalDataSource;\n\t\t}\n\t\tthrow new UnknownUnwrapTypeException( unwrapType );\n\t}\n\n\t// --- Stoppable\n\n\t@Override\n\tpublic void stop() {\n\t\tif ( agroalDataSource != null ) {\n\t\t\tagroalDataSource.close();\n\t\t}\n\t}\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate advanceToLast() : boolean extracted from public last(rowProcessingState RowProcessingState) : boolean in class org.hibernate.sql.results.jdbc.internal.JdbcValuesResultSetImpl",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/results/jdbc/internal/JdbcValuesResultSetImpl.java",
                "startLine": 249,
                "endLine": 266,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/results/jdbc/internal/JdbcValuesResultSetImpl.java",
                "startLine": 198,
                "endLine": 201,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/sql/results/jdbc/internal/JdbcValuesResultSetImpl.java",
                "startLine": 212,
                "endLine": 219,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic boolean last(RowProcessingState rowProcessingState) {\n\t\treturn advance(\n\t\t\t\t() -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t//noinspection RedundantIfStatement\n\t\t\t\t\t\tif ( ! resultSetAccess.getResultSet().last() ) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (SQLException e) {\n\t\t\t\t\t\tthrow makeExecutionException( \"Error advancing (last) ResultSet position\", e );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/sql/results/jdbc/internal/JdbcValuesResultSetImpl.java",
        "isPureRefactoring": true,
        "commitId": "c7bd022b075647bee8fd4695595a29334e036d78",
        "packageNameBefore": "org.hibernate.sql.results.jdbc.internal",
        "classNameBefore": "org.hibernate.sql.results.jdbc.internal.JdbcValuesResultSetImpl",
        "methodNameBefore": "org.hibernate.sql.results.jdbc.internal.JdbcValuesResultSetImpl#last",
        "invokedMethod": "methodSignature: org.hibernate.sql.results.jdbc.internal.JdbcValuesResultSetImpl.Advancer#advance\n methodBody: boolean advance();\nmethodSignature: org.hibernate.sql.results.jdbc.internal.JdbcValuesResultSetImpl#last\n methodBody: public boolean last(RowProcessingState rowProcessingState) {\nreturn advance(() -> {\n  try {\n    if (!resultSetAccess.getResultSet().last()) {\n      return false;\n    }\n    return true;\n  }\n catch (  SQLException e) {\n    throw makeExecutionException(\"Error advancing (last) ResultSet position\",e);\n  }\n}\n);\n}\nmethodSignature: org.hibernate.sql.results.jdbc.internal.JdbcValuesResultSetImpl#advance\n methodBody: private boolean advance(Advancer advancer) {\nfinal boolean hasResult=advancer.advance();\nif(!hasResult){return false;\n}readCurrentRowValues();\nreturn true;\n}\nmethodSignature: org.hibernate.sql.results.jdbc.internal.JdbcValuesResultSetImpl#makeExecutionException\n methodBody: private ExecutionException makeExecutionException(String message, SQLException cause) {\nreturn new ExecutionException(message,executionContext.getSession().getJdbcServices().getSqlExceptionHelper().convert(cause,message));\n}",
        "classSignatureBefore": "public class JdbcValuesResultSetImpl extends AbstractJdbcValues ",
        "methodNameBeforeSet": [
            "org.hibernate.sql.results.jdbc.internal.JdbcValuesResultSetImpl#last"
        ],
        "classNameBeforeSet": [
            "org.hibernate.sql.results.jdbc.internal.JdbcValuesResultSetImpl"
        ],
        "classSignatureBeforeSet": [
            "public class JdbcValuesResultSetImpl extends AbstractJdbcValues "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics Severe changes",
                "description": "Return expression has been added within the Extract Method mechanics - with non-mapped leaves",
                "mappingState": 2
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.sql.results.jdbc.internal;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Arrays;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.cache.spi.QueryKey;\nimport org.hibernate.cache.spi.QueryResultsCache;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.engine.spi.SharedSessionContractImplementor;\nimport org.hibernate.query.spi.QueryOptions;\nimport org.hibernate.sql.ast.spi.SqlSelection;\nimport org.hibernate.sql.exec.ExecutionException;\nimport org.hibernate.sql.exec.spi.ExecutionContext;\nimport org.hibernate.sql.results.caching.QueryCachePutManager;\nimport org.hibernate.sql.results.caching.internal.QueryCachePutManagerDisabledImpl;\nimport org.hibernate.sql.results.caching.internal.QueryCachePutManagerEnabledImpl;\nimport org.hibernate.sql.results.jdbc.spi.JdbcValuesMapping;\nimport org.hibernate.sql.results.jdbc.spi.JdbcValuesMetadata;\nimport org.hibernate.sql.results.jdbc.spi.RowProcessingState;\n\n/**\n * JdbcValuesSource implementation for a JDBC ResultSet as the source\n *\n * @author Steve Ebersole\n */\npublic class JdbcValuesResultSetImpl extends AbstractJdbcValues {\n\n\tprivate final ResultSetAccess resultSetAccess;\n\tprivate final JdbcValuesMapping valuesMapping;\n\tprivate final ExecutionContext executionContext;\n\n\tprivate final SqlSelection[] sqlSelections;\n\tprivate final Object[] currentRowJdbcValues;\n\n\tpublic JdbcValuesResultSetImpl(\n\t\t\tResultSetAccess resultSetAccess,\n\t\t\tQueryKey queryCacheKey,\n\t\t\tString queryIdentifier,\n\t\t\tQueryOptions queryOptions,\n\t\t\tJdbcValuesMapping valuesMapping,\n\t\t\tJdbcValuesMetadata metadataForCache,\n\t\t\tExecutionContext executionContext) {\n\t\tsuper( resolveQueryCachePutManager( executionContext, queryOptions, queryCacheKey, queryIdentifier, metadataForCache ) );\n\t\tthis.resultSetAccess = resultSetAccess;\n\t\tthis.valuesMapping = valuesMapping;\n\t\tthis.executionContext = executionContext;\n\n\t\tthis.sqlSelections = valuesMapping.getSqlSelections().toArray( new SqlSelection[0] );\n\t\tthis.currentRowJdbcValues = new Object[ valuesMapping.getRowSize() ];\n\t}\n\n\tprivate static QueryCachePutManager resolveQueryCachePutManager(\n\t\t\tExecutionContext executionContext,\n\t\t\tQueryOptions queryOptions,\n\t\t\tQueryKey queryCacheKey,\n\t\t\tString queryIdentifier,\n\t\t\tJdbcValuesMetadata metadataForCache) {\n\t\tif ( queryCacheKey != null ) {\n\t\t\tfinal SessionFactoryImplementor factory = executionContext.getSession().getFactory();\n\t\t\tfinal QueryResultsCache queryCache = factory.getCache()\n\t\t\t\t\t.getQueryResultsCache( queryOptions.getResultCacheRegionName() );\n\t\t\treturn new QueryCachePutManagerEnabledImpl(\n\t\t\t\t\tqueryCache,\n\t\t\t\t\tfactory.getStatistics(),\n\t\t\t\t\tqueryCacheKey,\n\t\t\t\t\tqueryIdentifier,\n\t\t\t\t\tmetadataForCache\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn QueryCachePutManagerDisabledImpl.INSTANCE;\n\t\t}\n\t}\n\n\t@Override\n\tprotected final boolean processNext(RowProcessingState rowProcessingState) {\n\t\treturn advance(\n\t\t\t\t() -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t//noinspection RedundantIfStatement\n\t\t\t\t\t\tif ( ! resultSetAccess.getResultSet().next() ) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (SQLException e) {\n\t\t\t\t\t\tthrow makeExecutionException( \"Error advancing (next) ResultSet position\", e );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@Override\n\tprotected boolean processPrevious(RowProcessingState rowProcessingState) {\n\t\treturn advance(\n\t\t\t\t() -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t//noinspection RedundantIfStatement\n\t\t\t\t\t\tif ( ! resultSetAccess.getResultSet().previous() ) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (SQLException e) {\n\t\t\t\t\t\tthrow makeExecutionException( \"Error advancing (previous) ResultSet position\", e );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@Override\n\tprotected boolean processScroll(int numberOfRows, RowProcessingState rowProcessingState) {\n\t\treturn advance(\n\t\t\t\t() -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t//noinspection RedundantIfStatement\n\t\t\t\t\t\tif ( ! resultSetAccess.getResultSet().relative( numberOfRows ) ) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (SQLException e) {\n\t\t\t\t\t\tthrow makeExecutionException( \"Error advancing (scroll) ResultSet position\", e );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@Override\n\tpublic int getPosition() {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().getRow() - 1;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#getRow\", e );\n\t\t}\n\t}\n\n\t@Override\n\tprotected boolean processPosition(int position, RowProcessingState rowProcessingState) {\n\t\treturn advance(\n\t\t\t\t() -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t//noinspection RedundantIfStatement\n\t\t\t\t\t\tif ( ! resultSetAccess.getResultSet().absolute( position ) ) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (SQLException e) {\n\t\t\t\t\t\tthrow makeExecutionException( \"Error advancing (scroll) ResultSet position\", e );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@Override\n\tpublic boolean isBeforeFirst(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().isBeforeFirst();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#isBeforeFirst()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void beforeFirst(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\tresultSetAccess.getResultSet().beforeFirst();\n\t\t\tArrays.fill( currentRowJdbcValues, null );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#beforeFirst()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isFirst(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().isFirst();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#isFirst()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean first(RowProcessingState rowProcessingState) {\n\t\treturn advance(\n\t\t\t\t() -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t//noinspection RedundantIfStatement\n\t\t\t\t\t\tif ( ! resultSetAccess.getResultSet().first() ) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (SQLException e) {\n\t\t\t\t\t\tthrow makeExecutionException( \"Error advancing (first) ResultSet position\", e );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@Override\n\tpublic boolean isAfterLast(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().isAfterLast();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#isAfterLast()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void afterLast(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\tresultSetAccess.getResultSet().afterLast();\n\t\t\tArrays.fill( currentRowJdbcValues, null );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#afterLast()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isLast(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().isLast();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#isLast()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean last(RowProcessingState rowProcessingState) {\n\t\treturn advance(\n\t\t\t\t() -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t//noinspection RedundantIfStatement\n\t\t\t\t\t\tif ( ! resultSetAccess.getResultSet().last() ) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (SQLException e) {\n\t\t\t\t\t\tthrow makeExecutionException( \"Error advancing (last) ResultSet position\", e );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@FunctionalInterface\n\tprivate interface Advancer {\n\t\tboolean advance();\n\t}\n\n\tprivate boolean advance(Advancer advancer) {\n\t\tfinal boolean hasResult = advancer.advance();\n\t\tif ( ! hasResult ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treadCurrentRowValues();\n\t\treturn true;\n\t}\n\n\tprivate ExecutionException makeExecutionException(String message, SQLException cause) {\n\t\treturn new ExecutionException(\n\t\t\t\tmessage,\n\t\t\t\texecutionContext.getSession().getJdbcServices().getSqlExceptionHelper().convert(\n\t\t\t\t\t\tcause,\n\t\t\t\t\t\tmessage\n\t\t\t\t)\n\t\t);\n\t}\n\n\tprivate void readCurrentRowValues() {\n\t\tfinal ResultSet resultSet = resultSetAccess.getResultSet();\n\t\tfinal SharedSessionContractImplementor session = executionContext.getSession();\n\t\tfor ( final SqlSelection sqlSelection : sqlSelections ) {\n\t\t\ttry {\n\t\t\t\tcurrentRowJdbcValues[ sqlSelection.getValuesArrayPosition() ] = sqlSelection.getJdbcValueExtractor().extract(\n\t\t\t\t\t\tresultSet,\n\t\t\t\t\t\tsqlSelection.getJdbcResultSetIndex(),\n\t\t\t\t\t\tsession\n\t\t\t\t);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new HibernateException(\n\t\t\t\t\t\t\"Unable to extract JDBC value for position `\" + sqlSelection.getJdbcResultSetIndex() + \"`\",\n\t\t\t\t\t\te\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tprotected void release() {\n\t\tresultSetAccess.release();\n\t}\n\n\t@Override\n\tpublic JdbcValuesMapping getValuesMapping() {\n\t\treturn valuesMapping;\n\t}\n\n\t@Override\n\tpublic Object[] getCurrentRowValuesArray() {\n\t\treturn currentRowJdbcValues;\n\t}\n\n\t@Override\n\tpublic void setFetchSize(int fetchSize) {\n\t\ttry {\n\t\t\tresultSetAccess.getResultSet().setFetchSize(fetchSize);\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet.setFetchSize()\", e );\n\t\t}\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/sql/results/jdbc/internal/JdbcValuesResultSetImpl.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.sql.results.jdbc.internal;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Arrays;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.cache.spi.QueryKey;\nimport org.hibernate.cache.spi.QueryResultsCache;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.engine.spi.SharedSessionContractImplementor;\nimport org.hibernate.query.spi.QueryOptions;\nimport org.hibernate.sql.ast.spi.SqlSelection;\nimport org.hibernate.sql.exec.ExecutionException;\nimport org.hibernate.sql.exec.spi.ExecutionContext;\nimport org.hibernate.sql.results.caching.QueryCachePutManager;\nimport org.hibernate.sql.results.caching.internal.QueryCachePutManagerDisabledImpl;\nimport org.hibernate.sql.results.caching.internal.QueryCachePutManagerEnabledImpl;\nimport org.hibernate.sql.results.jdbc.spi.JdbcValuesMapping;\nimport org.hibernate.sql.results.jdbc.spi.JdbcValuesMetadata;\nimport org.hibernate.sql.results.jdbc.spi.RowProcessingState;\n\n/**\n * JdbcValuesSource implementation for a JDBC ResultSet as the source\n *\n * @author Steve Ebersole\n */\npublic class JdbcValuesResultSetImpl extends AbstractJdbcValues {\n\n\tprivate final ResultSetAccess resultSetAccess;\n\tprivate final JdbcValuesMapping valuesMapping;\n\tprivate final ExecutionContext executionContext;\n\n\tprivate final SqlSelection[] sqlSelections;\n\tprivate final Object[] currentRowJdbcValues;\n\n\tpublic JdbcValuesResultSetImpl(\n\t\t\tResultSetAccess resultSetAccess,\n\t\t\tQueryKey queryCacheKey,\n\t\t\tString queryIdentifier,\n\t\t\tQueryOptions queryOptions,\n\t\t\tJdbcValuesMapping valuesMapping,\n\t\t\tJdbcValuesMetadata metadataForCache,\n\t\t\tExecutionContext executionContext) {\n\t\tsuper( resolveQueryCachePutManager( executionContext, queryOptions, queryCacheKey, queryIdentifier, metadataForCache ) );\n\t\tthis.resultSetAccess = resultSetAccess;\n\t\tthis.valuesMapping = valuesMapping;\n\t\tthis.executionContext = executionContext;\n\n\t\tthis.sqlSelections = valuesMapping.getSqlSelections().toArray( new SqlSelection[0] );\n\t\tthis.currentRowJdbcValues = new Object[ valuesMapping.getRowSize() ];\n\t}\n\n\tprivate static QueryCachePutManager resolveQueryCachePutManager(\n\t\t\tExecutionContext executionContext,\n\t\t\tQueryOptions queryOptions,\n\t\t\tQueryKey queryCacheKey,\n\t\t\tString queryIdentifier,\n\t\t\tJdbcValuesMetadata metadataForCache) {\n\t\tif ( queryCacheKey != null ) {\n\t\t\tfinal SessionFactoryImplementor factory = executionContext.getSession().getFactory();\n\t\t\tfinal QueryResultsCache queryCache = factory.getCache()\n\t\t\t\t\t.getQueryResultsCache( queryOptions.getResultCacheRegionName() );\n\t\t\treturn new QueryCachePutManagerEnabledImpl(\n\t\t\t\t\tqueryCache,\n\t\t\t\t\tfactory.getStatistics(),\n\t\t\t\t\tqueryCacheKey,\n\t\t\t\t\tqueryIdentifier,\n\t\t\t\t\tmetadataForCache\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn QueryCachePutManagerDisabledImpl.INSTANCE;\n\t\t}\n\t}\n\n\t@Override\n\tprotected final boolean processNext(RowProcessingState rowProcessingState) {\n\t\treturn advance( advanceNext() );\n\t}\n\n\t@Override\n\tprotected boolean processPrevious(RowProcessingState rowProcessingState) {\n\t\treturn advance( advancePrevious() );\n\t}\n\n\t@Override\n\tprotected boolean processScroll(int numberOfRows, RowProcessingState rowProcessingState) {\n\t\treturn advance( scrollRows( numberOfRows ) );\n\t}\n\n\tprivate boolean scrollRows(final int numberOfRows) {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().relative( numberOfRows );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error advancing (scroll) ResultSet position\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getPosition() {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().getRow() - 1;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#getRow\", e );\n\t\t}\n\t}\n\n\t@Override\n\tprotected boolean processPosition(int position, RowProcessingState rowProcessingState) {\n\t\treturn advance( advanceToPosition( position ) );\n\t}\n\n\tprivate boolean advanceToPosition(final int position) {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().absolute( position );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error advancing (scroll) ResultSet position\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isBeforeFirst(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().isBeforeFirst();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#isBeforeFirst()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void beforeFirst(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\tresultSetAccess.getResultSet().beforeFirst();\n\t\t\tArrays.fill( currentRowJdbcValues, null );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#beforeFirst()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isFirst(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().isFirst();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#isFirst()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean first(RowProcessingState rowProcessingState) {\n\t\treturn advance( advanceToFirst() );\n\t}\n\n\t@Override\n\tpublic boolean isAfterLast(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().isAfterLast();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#isAfterLast()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void afterLast(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\tresultSetAccess.getResultSet().afterLast();\n\t\t\tArrays.fill( currentRowJdbcValues, null );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#afterLast()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isLast(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().isLast();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#isLast()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean last(RowProcessingState rowProcessingState) {\n\t\treturn advance( advanceToLast() );\n\t}\n\n\tprivate boolean advanceNext() {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().next();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error advancing (next) ResultSet position\", e );\n\t\t}\n\t}\n\n\tprivate boolean advanceToLast() {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().last();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error advancing (last) ResultSet position\", e );\n\t\t}\n\t}\n\n\tprivate boolean advanceToFirst() {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().first();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error advancing (first) ResultSet position\", e );\n\t\t}\n\t}\n\n\tprivate boolean advancePrevious() {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().previous();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error advancing (previous) ResultSet position\", e );\n\t\t}\n\t}\n\n\tprivate boolean advance(final boolean hasResult) {\n\t\tif ( ! hasResult ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treadCurrentRowValues();\n\t\treturn true;\n\t}\n\n\tprivate ExecutionException makeExecutionException(String message, SQLException cause) {\n\t\treturn new ExecutionException(\n\t\t\t\tmessage,\n\t\t\t\texecutionContext.getSession().getJdbcServices().getSqlExceptionHelper().convert(\n\t\t\t\t\t\tcause,\n\t\t\t\t\t\tmessage\n\t\t\t\t)\n\t\t);\n\t}\n\n\tprivate void readCurrentRowValues() {\n\t\tfinal ResultSet resultSet = resultSetAccess.getResultSet();\n\t\tfinal SharedSessionContractImplementor session = executionContext.getSession();\n\t\tfor ( final SqlSelection sqlSelection : sqlSelections ) {\n\t\t\ttry {\n\t\t\t\tcurrentRowJdbcValues[ sqlSelection.getValuesArrayPosition() ] = sqlSelection.getJdbcValueExtractor().extract(\n\t\t\t\t\t\tresultSet,\n\t\t\t\t\t\tsqlSelection.getJdbcResultSetIndex(),\n\t\t\t\t\t\tsession\n\t\t\t\t);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new HibernateException(\n\t\t\t\t\t\t\"Unable to extract JDBC value for position `\" + sqlSelection.getJdbcResultSetIndex() + \"`\",\n\t\t\t\t\t\te\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tprotected void release() {\n\t\tresultSetAccess.release();\n\t}\n\n\t@Override\n\tpublic JdbcValuesMapping getValuesMapping() {\n\t\treturn valuesMapping;\n\t}\n\n\t@Override\n\tpublic Object[] getCurrentRowValuesArray() {\n\t\treturn currentRowJdbcValues;\n\t}\n\n\t@Override\n\tpublic void setFetchSize(int fetchSize) {\n\t\ttry {\n\t\t\tresultSetAccess.getResultSet().setFetchSize(fetchSize);\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet.setFetchSize()\", e );\n\t\t}\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private boolean advanceToLast() {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().last();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error advancing (last) ResultSet position\", e );\n\t\t}\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.sql.results.jdbc.internal.JdbcValuesResultSetImpl.Advancer#advance\n methodBody: boolean advance();",
            "methodSignature: org.hibernate.sql.results.jdbc.internal.JdbcValuesResultSetImpl#last\n methodBody: public boolean last(RowProcessingState rowProcessingState) {\nreturn advance(() -> {\n  try {\n    if (!resultSetAccess.getResultSet().last()) {\n      return false;\n    }\n    return true;\n  }\n catch (  SQLException e) {\n    throw makeExecutionException(\"Error advancing (last) ResultSet position\",e);\n  }\n}\n);\n}",
            "methodSignature: org.hibernate.sql.results.jdbc.internal.JdbcValuesResultSetImpl#advance\n methodBody: private boolean advance(Advancer advancer) {\nfinal boolean hasResult=advancer.advance();\nif(!hasResult){return false;\n}readCurrentRowValues();\nreturn true;\n}",
            "methodSignature: org.hibernate.sql.results.jdbc.internal.JdbcValuesResultSetImpl#makeExecutionException\n methodBody: private ExecutionException makeExecutionException(String message, SQLException cause) {\nreturn new ExecutionException(message,executionContext.getSession().getJdbcServices().getSqlExceptionHelper().convert(cause,message));\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\tpublic boolean last(RowProcessingState rowProcessingState) {\n\t\treturn advance( advanceToLast() );\n\t}\nprivate boolean advanceToLast() {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().last();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error advancing (last) ResultSet position\", e );\n\t\t}\n\t}",
        "diffSourceCode": "-  198: \n-  199: \t@Override\n-  200: \tpublic boolean first(RowProcessingState rowProcessingState) {\n-  201: \t\treturn advance(\n-  212: \t\t\t\t\t\tthrow makeExecutionException( \"Error advancing (first) ResultSet position\", e );\n-  213: \t\t\t\t\t}\n-  214: \t\t\t\t}\n-  215: \t\t);\n-  216: \t}\n-  217: \n-  218: \t@Override\n-  219: \tpublic boolean isAfterLast(RowProcessingState rowProcessingState) {\n-  249: \t@Override\n-  250: \tpublic boolean last(RowProcessingState rowProcessingState) {\n-  251: \t\treturn advance(\n-  252: \t\t\t\t() -> {\n-  253: \t\t\t\t\ttry {\n-  254: \t\t\t\t\t\t//noinspection RedundantIfStatement\n-  255: \t\t\t\t\t\tif ( ! resultSetAccess.getResultSet().last() ) {\n-  256: \t\t\t\t\t\t\treturn false;\n-  257: \t\t\t\t\t\t}\n-  258: \n-  259: \t\t\t\t\t\treturn true;\n-  260: \t\t\t\t\t}\n-  261: \t\t\t\t\tcatch (SQLException e) {\n-  262: \t\t\t\t\t\tthrow makeExecutionException( \"Error advancing (last) ResultSet position\", e );\n-  263: \t\t\t\t\t}\n-  264: \t\t\t\t}\n-  265: \t\t);\n-  266: \t}\n+  198: \t@Override\n+  199: \tpublic boolean last(RowProcessingState rowProcessingState) {\n+  200: \t\treturn advance( advanceToLast() );\n+  201: \t}\n+  212: \tprivate boolean advanceToLast() {\n+  213: \t\ttry {\n+  214: \t\t\treturn resultSetAccess.getResultSet().last();\n+  215: \t\t}\n+  216: \t\tcatch (SQLException e) {\n+  217: \t\t\tthrow makeExecutionException( \"Error advancing (last) ResultSet position\", e );\n+  218: \t\t}\n+  219: \t}\n+  249: \t\treturn new ExecutionException(\n+  250: \t\t\t\tmessage,\n+  251: \t\t\t\texecutionContext.getSession().getJdbcServices().getSqlExceptionHelper().convert(\n+  252: \t\t\t\t\t\tcause,\n+  253: \t\t\t\t\t\tmessage\n+  254: \t\t\t\t)\n+  255: \t\t);\n+  256: \t}\n+  257: \n+  258: \tprivate void readCurrentRowValues() {\n+  259: \t\tfinal ResultSet resultSet = resultSetAccess.getResultSet();\n+  260: \t\tfinal SharedSessionContractImplementor session = executionContext.getSession();\n+  261: \t\tfor ( final SqlSelection sqlSelection : sqlSelections ) {\n+  262: \t\t\ttry {\n+  263: \t\t\t\tcurrentRowJdbcValues[ sqlSelection.getValuesArrayPosition() ] = sqlSelection.getJdbcValueExtractor().extract(\n+  264: \t\t\t\t\t\tresultSet,\n+  265: \t\t\t\t\t\tsqlSelection.getJdbcResultSetIndex(),\n+  266: \t\t\t\t\t\tsession\n",
        "uniqueId": "c7bd022b075647bee8fd4695595a29334e036d78_249_266_212_219_198_201",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 5
            },
            "LINE": {
                "missed": 0,
                "covered": 1
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\nprivate boolean checkResultSetPosition(ResultSet resultSet, Advancer advancer, String errorMessage) {\n    try {\n        //noinspection RedundantIfStatement\n        if (!advancer.advance()) {\n            return false;\n        }\n        return true;\n    } catch (SQLException e) {\n        throw makeExecutionException(errorMessage, e);\n    }\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Override\n\tpublic boolean last(RowProcessingState rowProcessingState) {\n\t\treturn advance(\n\t\t\t\t() -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t//noinspection RedundantIfStatement\n\t\t\t\t\t\tif ( ! resultSetAccess.getResultSet().last() ) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (SQLException e) {\n\t\t\t\t\t\tthrow makeExecutionException( \"Error advancing (last) ResultSet position\", e );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.sql.results.jdbc.internal;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Arrays;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.cache.spi.QueryKey;\nimport org.hibernate.cache.spi.QueryResultsCache;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.engine.spi.SharedSessionContractImplementor;\nimport org.hibernate.query.spi.QueryOptions;\nimport org.hibernate.sql.ast.spi.SqlSelection;\nimport org.hibernate.sql.exec.ExecutionException;\nimport org.hibernate.sql.exec.spi.ExecutionContext;\nimport org.hibernate.sql.results.caching.QueryCachePutManager;\nimport org.hibernate.sql.results.caching.internal.QueryCachePutManagerDisabledImpl;\nimport org.hibernate.sql.results.caching.internal.QueryCachePutManagerEnabledImpl;\nimport org.hibernate.sql.results.jdbc.spi.JdbcValuesMapping;\nimport org.hibernate.sql.results.jdbc.spi.JdbcValuesMetadata;\nimport org.hibernate.sql.results.jdbc.spi.RowProcessingState;\n\n/**\n * JdbcValuesSource implementation for a JDBC ResultSet as the source\n *\n * @author Steve Ebersole\n */\npublic class JdbcValuesResultSetImpl extends AbstractJdbcValues {\n\n\tprivate final ResultSetAccess resultSetAccess;\n\tprivate final JdbcValuesMapping valuesMapping;\n\tprivate final ExecutionContext executionContext;\n\n\tprivate final SqlSelection[] sqlSelections;\n\tprivate final Object[] currentRowJdbcValues;\n\n\tpublic JdbcValuesResultSetImpl(\n\t\t\tResultSetAccess resultSetAccess,\n\t\t\tQueryKey queryCacheKey,\n\t\t\tString queryIdentifier,\n\t\t\tQueryOptions queryOptions,\n\t\t\tJdbcValuesMapping valuesMapping,\n\t\t\tJdbcValuesMetadata metadataForCache,\n\t\t\tExecutionContext executionContext) {\n\t\tsuper( resolveQueryCachePutManager( executionContext, queryOptions, queryCacheKey, queryIdentifier, metadataForCache ) );\n\t\tthis.resultSetAccess = resultSetAccess;\n\t\tthis.valuesMapping = valuesMapping;\n\t\tthis.executionContext = executionContext;\n\n\t\tthis.sqlSelections = valuesMapping.getSqlSelections().toArray( new SqlSelection[0] );\n\t\tthis.currentRowJdbcValues = new Object[ valuesMapping.getRowSize() ];\n\t}\n\n\tprivate static QueryCachePutManager resolveQueryCachePutManager(\n\t\t\tExecutionContext executionContext,\n\t\t\tQueryOptions queryOptions,\n\t\t\tQueryKey queryCacheKey,\n\t\t\tString queryIdentifier,\n\t\t\tJdbcValuesMetadata metadataForCache) {\n\t\tif ( queryCacheKey != null ) {\n\t\t\tfinal SessionFactoryImplementor factory = executionContext.getSession().getFactory();\n\t\t\tfinal QueryResultsCache queryCache = factory.getCache()\n\t\t\t\t\t.getQueryResultsCache( queryOptions.getResultCacheRegionName() );\n\t\t\treturn new QueryCachePutManagerEnabledImpl(\n\t\t\t\t\tqueryCache,\n\t\t\t\t\tfactory.getStatistics(),\n\t\t\t\t\tqueryCacheKey,\n\t\t\t\t\tqueryIdentifier,\n\t\t\t\t\tmetadataForCache\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn QueryCachePutManagerDisabledImpl.INSTANCE;\n\t\t}\n\t}\n\n\t@Override\n\tprotected final boolean processNext(RowProcessingState rowProcessingState) {\n\t\treturn advance(\n\t\t\t\t() -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t//noinspection RedundantIfStatement\n\t\t\t\t\t\tif ( ! resultSetAccess.getResultSet().next() ) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (SQLException e) {\n\t\t\t\t\t\tthrow makeExecutionException( \"Error advancing (next) ResultSet position\", e );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@Override\n\tprotected boolean processPrevious(RowProcessingState rowProcessingState) {\n\t\treturn advance(\n\t\t\t\t() -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t//noinspection RedundantIfStatement\n\t\t\t\t\t\tif ( ! resultSetAccess.getResultSet().previous() ) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (SQLException e) {\n\t\t\t\t\t\tthrow makeExecutionException( \"Error advancing (previous) ResultSet position\", e );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@Override\n\tprotected boolean processScroll(int numberOfRows, RowProcessingState rowProcessingState) {\n\t\treturn advance(\n\t\t\t\t() -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t//noinspection RedundantIfStatement\n\t\t\t\t\t\tif ( ! resultSetAccess.getResultSet().relative( numberOfRows ) ) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (SQLException e) {\n\t\t\t\t\t\tthrow makeExecutionException( \"Error advancing (scroll) ResultSet position\", e );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@Override\n\tpublic int getPosition() {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().getRow() - 1;\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#getRow\", e );\n\t\t}\n\t}\n\n\t@Override\n\tprotected boolean processPosition(int position, RowProcessingState rowProcessingState) {\n\t\treturn advance(\n\t\t\t\t() -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t//noinspection RedundantIfStatement\n\t\t\t\t\t\tif ( ! resultSetAccess.getResultSet().absolute( position ) ) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (SQLException e) {\n\t\t\t\t\t\tthrow makeExecutionException( \"Error advancing (scroll) ResultSet position\", e );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@Override\n\tpublic boolean isBeforeFirst(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().isBeforeFirst();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#isBeforeFirst()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void beforeFirst(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\tresultSetAccess.getResultSet().beforeFirst();\n\t\t\tArrays.fill( currentRowJdbcValues, null );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#beforeFirst()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isFirst(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().isFirst();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#isFirst()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean first(RowProcessingState rowProcessingState) {\n\t\treturn advance(\n\t\t\t\t() -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t//noinspection RedundantIfStatement\n\t\t\t\t\t\tif ( ! resultSetAccess.getResultSet().first() ) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (SQLException e) {\n\t\t\t\t\t\tthrow makeExecutionException( \"Error advancing (first) ResultSet position\", e );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@Override\n\tpublic boolean isAfterLast(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().isAfterLast();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#isAfterLast()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void afterLast(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\tresultSetAccess.getResultSet().afterLast();\n\t\t\tArrays.fill( currentRowJdbcValues, null );\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#afterLast()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isLast(RowProcessingState rowProcessingState) {\n\t\ttry {\n\t\t\treturn resultSetAccess.getResultSet().isLast();\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet#isLast()\", e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean last(RowProcessingState rowProcessingState) {\n\t\treturn advance(\n\t\t\t\t() -> {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t//noinspection RedundantIfStatement\n\t\t\t\t\t\tif ( ! resultSetAccess.getResultSet().last() ) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (SQLException e) {\n\t\t\t\t\t\tthrow makeExecutionException( \"Error advancing (last) ResultSet position\", e );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@FunctionalInterface\n\tprivate interface Advancer {\n\t\tboolean advance();\n\t}\n\n\tprivate boolean advance(Advancer advancer) {\n\t\tfinal boolean hasResult = advancer.advance();\n\t\tif ( ! hasResult ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treadCurrentRowValues();\n\t\treturn true;\n\t}\n\n\tprivate ExecutionException makeExecutionException(String message, SQLException cause) {\n\t\treturn new ExecutionException(\n\t\t\t\tmessage,\n\t\t\t\texecutionContext.getSession().getJdbcServices().getSqlExceptionHelper().convert(\n\t\t\t\t\t\tcause,\n\t\t\t\t\t\tmessage\n\t\t\t\t)\n\t\t);\n\t}\n\n\tprivate void readCurrentRowValues() {\n\t\tfinal ResultSet resultSet = resultSetAccess.getResultSet();\n\t\tfinal SharedSessionContractImplementor session = executionContext.getSession();\n\t\tfor ( final SqlSelection sqlSelection : sqlSelections ) {\n\t\t\ttry {\n\t\t\t\tcurrentRowJdbcValues[ sqlSelection.getValuesArrayPosition() ] = sqlSelection.getJdbcValueExtractor().extract(\n\t\t\t\t\t\tresultSet,\n\t\t\t\t\t\tsqlSelection.getJdbcResultSetIndex(),\n\t\t\t\t\t\tsession\n\t\t\t\t);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new HibernateException(\n\t\t\t\t\t\t\"Unable to extract JDBC value for position `\" + sqlSelection.getJdbcResultSetIndex() + \"`\",\n\t\t\t\t\t\te\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tprotected void release() {\n\t\tresultSetAccess.release();\n\t}\n\n\t@Override\n\tpublic JdbcValuesMapping getValuesMapping() {\n\t\treturn valuesMapping;\n\t}\n\n\t@Override\n\tpublic Object[] getCurrentRowValuesArray() {\n\t\treturn currentRowJdbcValues;\n\t}\n\n\t@Override\n\tpublic void setFetchSize(int fetchSize) {\n\t\ttry {\n\t\t\tresultSetAccess.getResultSet().setFetchSize(fetchSize);\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\tthrow makeExecutionException( \"Error calling ResultSet.setFetchSize()\", e );\n\t\t}\n\t}\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate link(author Author) : void extracted from public addAuthor(author Author) : void in class org.hibernate.orm.test.mapping.manytomany.ManyToManyListBidirectionalTest.Book",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/mapping/manytomany/ManyToManyListBidirectionalTest.java",
                "startLine": 97,
                "endLine": 100,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/mapping/manytomany/ManyToManyListBidirectionalTest.java",
                "startLine": 116,
                "endLine": 118,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/mapping/manytomany/ManyToManyListBidirectionalTest.java",
                "startLine": 100,
                "endLine": 103,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public void addAuthor(Author author) {\n\t\t\tauthors.add( author );\n\t\t\tauthor.books.add( this );\n\t\t}",
        "filePathBefore": "hibernate-core/src/test/java/org/hibernate/orm/test/mapping/manytomany/ManyToManyListBidirectionalTest.java",
        "isPureRefactoring": true,
        "commitId": "a9ac98b364ccf52bb9cb2be5324c9c983e8bd8b3",
        "packageNameBefore": "org.hibernate.orm.test.mapping.manytomany.ManyToManyListBidirectionalTest",
        "classNameBefore": "org.hibernate.orm.test.mapping.manytomany.ManyToManyListBidirectionalTest.Book",
        "methodNameBefore": "org.hibernate.orm.test.mapping.manytomany.ManyToManyListBidirectionalTest.Book#addAuthor",
        "invokedMethod": "methodSignature: org.hibernate.id.IdentifierGeneratorHelper.BasicHolder#add\n methodBody: public IntegralDataTypeHolder add(long addend) {\ncheckInitialized();\nvalue+=addend;\nreturn this;\n}\nmethodSignature: org.hibernate.id.IdentifierGeneratorHelper.BigIntegerHolder#add\n methodBody: public IntegralDataTypeHolder add(long increment) {\ncheckInitialized();\nvalue=value.add(BigInteger.valueOf(increment));\nreturn this;\n}\nmethodSignature: org.hibernate.internal.util.StringHelper#add\n methodBody: public static String[] add(String[] x, String sep, String[] y) {\nfinal String[] result=new String[x.length];\nfor(int i=0; i < x.length; i++){result[i]=x[i] + sep + y[i];\n}return result;\n}\nmethodSignature: org.hibernate.id.IdentifierGeneratorHelper.BigDecimalHolder#add\n methodBody: public IntegralDataTypeHolder add(long increment) {\ncheckInitialized();\nvalue=value.add(BigDecimal.valueOf(increment));\nreturn this;\n}",
        "classSignatureBefore": "public static class Book ",
        "methodNameBeforeSet": [
            "org.hibernate.orm.test.mapping.manytomany.ManyToManyListBidirectionalTest.Book#addAuthor"
        ],
        "classNameBeforeSet": [
            "org.hibernate.orm.test.mapping.manytomany.ManyToManyListBidirectionalTest.Book"
        ],
        "classSignatureBeforeSet": [
            "public static class Book "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.orm.test.mapping.manytomany;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.hibernate.testing.orm.junit.DomainModel;\nimport org.hibernate.testing.orm.junit.ServiceRegistry;\nimport org.hibernate.testing.orm.junit.SessionFactory;\nimport org.hibernate.testing.orm.junit.SessionFactoryScope;\nimport org.junit.jupiter.api.Test;\n\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.Id;\nimport jakarta.persistence.JoinColumn;\nimport jakarta.persistence.JoinTable;\nimport jakarta.persistence.ManyToMany;\n\n@DomainModel(\n\t\tannotatedClasses = {\n\t\t\t\tManyToManyListBidirectionalTest.Book.class,\n\t\t\t\tManyToManyListBidirectionalTest.Author.class\n\t\t}\n)\n@SessionFactory\n@ServiceRegistry\n@SuppressWarnings( \"unused\" )\npublic class ManyToManyListBidirectionalTest {\n\n\t@Test\n\tpublic void test(SessionFactoryScope scope) {\n\t\tscope.inTransaction( session -> {\n\t\t\tfinal Author author1 = new Author( 1 );\n\t\t\tfinal Author author2 = new Author( 2 );\n\n\t\t\tfinal Book bookByAuthor1 = new Book( 1 );\n\t\t\tbookByAuthor1.addAuthor( author1 );\n\n\t\t\tfinal Book bookByAuthor2 = new Book( 2 );\n\t\t\tbookByAuthor2.addAuthor( author2 );\n\n\t\t\tfinal Book bookByAuthor1AndAuthor2 = new Book( 3 );\n\t\t\tbookByAuthor1AndAuthor2.addAuthor( author1 );\n\t\t\tbookByAuthor1AndAuthor2.addAuthor( author2 );\n\n\t\t\tsession.persist( author1 );\n\t\t\tsession.persist( author2 );\n\t\t\tsession.persist( bookByAuthor1 );\n\t\t\tsession.persist( bookByAuthor2 );\n\t\t\tsession.persist( bookByAuthor1AndAuthor2 );\n\t\t} );\n\n\t\tscope.inTransaction( session -> {\n\t\t\tassertThat( session.createQuery( \"from Book b\", Book.class ).list() )\n\t\t\t\t\t.hasSize( 3 )\n\t\t\t\t\t.allSatisfy( book -> assertThat( book.authors )\n\t\t\t\t\t\t\t.allSatisfy( author -> assertThat( author.books ).contains( book ) ) );\n\t\t} );\n\n\t\tscope.inTransaction( session -> {\n\t\t\tsession.createMutationQuery( \"delete from Book\" ).executeUpdate();\n\t\t\tsession.createMutationQuery( \"delete from Author\" ).executeUpdate();\n\t\t} );\n\n\t\tscope.inTransaction( session -> {\n\t\t\tassertThat( session.createQuery( \"from Book\", Book.class ).list() ).isEmpty();\n\t\t\tassertThat( session.createQuery( \"from Author\", Author.class ).list() ).isEmpty();\n\t\t} );\n\t}\n\n\t@Entity(name = \"Book\")\n\tpublic static class Book {\n\n\t\t@Id\n\t\tprivate int id;\n\n\t\tpublic Book() {\n\t\t}\n\n\t\tpublic Book(int id) {\n\t\t\tthis.id = id;\n\t\t}\n\n\t\t@ManyToMany\n\t\t@JoinTable(name = \"book_author\",\n\t\t\t\tjoinColumns = { @JoinColumn(name = \"fk_book\") },\n\t\t\t\tinverseJoinColumns = { @JoinColumn(name = \"fk_author\") })\n\t\tprivate List<Author> authors = new ArrayList<>();\n\n\t\tpublic void addAuthor(Author author) {\n\t\t\tauthors.add( author );\n\t\t\tauthor.books.add( this );\n\t\t}\n\t}\n\n\t@Entity(name = \"Author\")\n\tpublic static class Author {\n\n\t\t@Id\n\t\tprivate int id;\n\n\t\tpublic Author() {\n\t\t}\n\n\t\tpublic Author(int id) {\n\t\t\tthis.id = id;\n\t\t}\n\n\t\t@ManyToMany(mappedBy = \"authors\")\n\t\tprivate List<Book> books = new ArrayList<>();\n\n\t\tpublic void addBook(Book book) {\n\t\t\tbooks.add( book );\n\t\t\tbook.authors.add( this );\n\t\t}\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/test/java/org/hibernate/orm/test/mapping/manytomany/ManyToManyListBidirectionalTest.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.orm.test.mapping.manytomany;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.hibernate.internal.util.collections.ArrayHelper;\n\nimport org.hibernate.testing.orm.junit.DomainModel;\nimport org.hibernate.testing.orm.junit.ServiceRegistry;\nimport org.hibernate.testing.orm.junit.SessionFactory;\nimport org.hibernate.testing.orm.junit.SessionFactoryScope;\nimport org.junit.jupiter.api.Test;\n\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.Id;\nimport jakarta.persistence.JoinColumn;\nimport jakarta.persistence.JoinTable;\nimport jakarta.persistence.ManyToMany;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n@DomainModel(\n\t\tannotatedClasses = {\n\t\t\t\tManyToManyListBidirectionalTest.Book.class,\n\t\t\t\tManyToManyListBidirectionalTest.Author.class\n\t\t}\n)\n@SessionFactory\n@ServiceRegistry\n@SuppressWarnings( \"unused\" )\npublic class ManyToManyListBidirectionalTest {\n\n\t@Test\n\tpublic void test(SessionFactoryScope scope) {\n\t\tscope.inTransaction( session -> {\n\t\t\tfinal Author author1 = new Author( 1 );\n\t\t\tfinal Author author2 = new Author( 2 );\n\t\t\tsession.persist( author1 );\n\t\t\tsession.persist( author2 );\n\n\t\t\tfinal Book bookByAuthor1 = new Book( 1, author1 );\n\t\t\tfinal Book bookByAuthor2 = new Book( 2, author2 );\n\t\t\tfinal Book bookByAuthors1And2 = new Book( 3, author1, author2 );\n\t\t\tsession.persist( bookByAuthor1 );\n\t\t\tsession.persist( bookByAuthor2 );\n\t\t\tsession.persist( bookByAuthors1And2 );\n\t\t} );\n\n\t\tscope.inTransaction( session -> {\n\t\t\tfinal List<Book> books = session.createQuery( \"from Book b\", Book.class ).list();\n\n\t\t\tassertThat( books ).hasSize( 3 );\n\t\t\tbooks.forEach( (book) -> {\n\t\t\t\tbook.authors.forEach( (author) -> {\n\t\t\t\t\tassertThat( author.books ).contains( book );\n\t\t\t\t} );\n\t\t\t} );\n\n//\t\t\tassertThat( books )\n//\t\t\t\t\t.hasSize( 3 )\n//\t\t\t\t\t.allSatisfy( book -> assertThat( book.authors )\n//\t\t\t\t\t\t\t.allSatisfy( author -> assertThat( author.books ).contains( book ) ) );\n\t\t} );\n\n\t\tscope.inTransaction( session -> {\n\t\t\tsession.createMutationQuery( \"delete from Book\" ).executeUpdate();\n\t\t\tsession.createMutationQuery( \"delete from Author\" ).executeUpdate();\n\t\t} );\n\n\t\tscope.inTransaction( session -> {\n\t\t\tassertThat( session.createQuery( \"from Book\", Book.class ).list() ).isEmpty();\n\t\t\tassertThat( session.createQuery( \"from Author\", Author.class ).list() ).isEmpty();\n\t\t} );\n\t}\n\n\t@Entity(name = \"Book\")\n\tpublic static class Book {\n\n\t\t@Id\n\t\tprivate int id;\n\n\t\tpublic Book() {\n\t\t}\n\n\t\tpublic Book(int id) {\n\t\t\tthis.id = id;\n\t\t}\n\n\t\tpublic Book(int id, Author author) {\n\t\t\tthis.id = id;\n\t\t\tlink( author );\n\t\t}\n\n\t\tprivate void link(Author author) {\n\t\t\tauthors.add( author );\n\t\t\tauthor.books.add( this );\n\t\t}\n\n\t\tpublic Book(int id, Author... authors) {\n\t\t\tthis.id = id;\n\t\t\tArrayHelper.forEach( authors, this::link );\n\t\t}\n\n\t\t@ManyToMany\n\t\t@JoinTable(name = \"book_author\",\n\t\t\t\tjoinColumns = { @JoinColumn(name = \"fk_book\") },\n\t\t\t\tinverseJoinColumns = { @JoinColumn(name = \"fk_author\") })\n\t\tprivate List<Author> authors = new ArrayList<>();\n\n\t\tpublic void addAuthor(Author author) {\n\t\t\tlink( author );\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Book(\" + id + \")@\" + Integer.toHexString( hashCode() );\n\t\t}\n\t}\n\n\t@Entity(name = \"Author\")\n\tpublic static class Author {\n\n\t\t@Id\n\t\tprivate int id;\n\n\t\tpublic Author() {\n\t\t}\n\n\t\tpublic Author(int id) {\n\t\t\tthis.id = id;\n\t\t}\n\n\t\t@ManyToMany(mappedBy = \"authors\")\n\t\tprivate List<Book> books = new ArrayList<>();\n\n\t\tpublic void addBook(Book book) {\n\t\t\tbooks.add( book );\n\t\t\tbook.authors.add( this );\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Author(\" + id + \")@\" + Integer.toHexString( hashCode() );\n\t\t}\n\t}\n\n}\n",
        "diffSourceCodeSet": [
            "private void link(Author author) {\n\t\t\tauthors.add( author );\n\t\t\tauthor.books.add( this );\n\t\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.id.IdentifierGeneratorHelper.BasicHolder#add\n methodBody: public IntegralDataTypeHolder add(long addend) {\ncheckInitialized();\nvalue+=addend;\nreturn this;\n}",
            "methodSignature: org.hibernate.id.IdentifierGeneratorHelper.BigIntegerHolder#add\n methodBody: public IntegralDataTypeHolder add(long increment) {\ncheckInitialized();\nvalue=value.add(BigInteger.valueOf(increment));\nreturn this;\n}",
            "methodSignature: org.hibernate.internal.util.StringHelper#add\n methodBody: public static String[] add(String[] x, String sep, String[] y) {\nfinal String[] result=new String[x.length];\nfor(int i=0; i < x.length; i++){result[i]=x[i] + sep + y[i];\n}return result;\n}",
            "methodSignature: org.hibernate.id.IdentifierGeneratorHelper.BigDecimalHolder#add\n methodBody: public IntegralDataTypeHolder add(long increment) {\ncheckInitialized();\nvalue=value.add(BigDecimal.valueOf(increment));\nreturn this;\n}"
        ],
        "sourceCodeAfterRefactoring": "public void addAuthor(Author author) {\n\t\t\tlink( author );\n\t\t}\nprivate void link(Author author) {\n\t\t\tauthors.add( author );\n\t\t\tauthor.books.add( this );\n\t\t}",
        "diffSourceCode": "-   97: \t\tpublic void addAuthor(Author author) {\n-   98: \t\t\tauthors.add( author );\n-   99: \t\t\tauthor.books.add( this );\n-  100: \t\t}\n-  101: \t}\n-  102: \n-  103: \t@Entity(name = \"Author\")\n-  116: \t\t@ManyToMany(mappedBy = \"authors\")\n-  117: \t\tprivate List<Book> books = new ArrayList<>();\n-  118: \n+   97: \t\t\tlink( author );\n+   98: \t\t}\n+   99: \n+  100: \t\tprivate void link(Author author) {\n+  101: \t\t\tauthors.add( author );\n+  102: \t\t\tauthor.books.add( this );\n+  103: \t\t}\n+  116: \t\tpublic void addAuthor(Author author) {\n+  117: \t\t\tlink( author );\n+  118: \t\t}\n",
        "uniqueId": "a9ac98b364ccf52bb9cb2be5324c9c983e8bd8b3_97_100_100_103_116_118",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": true,
        "refactoredCode": "##########################\npublic void addAuthor(Author author) {\n    authors.add(author);\n    author.addBook(this);\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\npublic void addAuthor(Author author) {\n\t\t\tauthors.add( author );\n\t\t\tauthor.books.add( this );\n\t\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.orm.test.mapping.manytomany;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.hibernate.testing.orm.junit.DomainModel;\nimport org.hibernate.testing.orm.junit.ServiceRegistry;\nimport org.hibernate.testing.orm.junit.SessionFactory;\nimport org.hibernate.testing.orm.junit.SessionFactoryScope;\nimport org.junit.jupiter.api.Test;\n\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.Id;\nimport jakarta.persistence.JoinColumn;\nimport jakarta.persistence.JoinTable;\nimport jakarta.persistence.ManyToMany;\n\n@DomainModel(\n\t\tannotatedClasses = {\n\t\t\t\tManyToManyListBidirectionalTest.Book.class,\n\t\t\t\tManyToManyListBidirectionalTest.Author.class\n\t\t}\n)\n@SessionFactory\n@ServiceRegistry\n@SuppressWarnings( \"unused\" )\npublic class ManyToManyListBidirectionalTest {\n\n\t@Test\n\tpublic void test(SessionFactoryScope scope) {\n\t\tscope.inTransaction( session -> {\n\t\t\tfinal Author author1 = new Author( 1 );\n\t\t\tfinal Author author2 = new Author( 2 );\n\n\t\t\tfinal Book bookByAuthor1 = new Book( 1 );\n\t\t\tbookByAuthor1.addAuthor( author1 );\n\n\t\t\tfinal Book bookByAuthor2 = new Book( 2 );\n\t\t\tbookByAuthor2.addAuthor( author2 );\n\n\t\t\tfinal Book bookByAuthor1AndAuthor2 = new Book( 3 );\n\t\t\tbookByAuthor1AndAuthor2.addAuthor( author1 );\n\t\t\tbookByAuthor1AndAuthor2.addAuthor( author2 );\n\n\t\t\tsession.persist( author1 );\n\t\t\tsession.persist( author2 );\n\t\t\tsession.persist( bookByAuthor1 );\n\t\t\tsession.persist( bookByAuthor2 );\n\t\t\tsession.persist( bookByAuthor1AndAuthor2 );\n\t\t} );\n\n\t\tscope.inTransaction( session -> {\n\t\t\tassertThat( session.createQuery( \"from Book b\", Book.class ).list() )\n\t\t\t\t\t.hasSize( 3 )\n\t\t\t\t\t.allSatisfy( book -> assertThat( book.authors )\n\t\t\t\t\t\t\t.allSatisfy( author -> assertThat( author.books ).contains( book ) ) );\n\t\t} );\n\n\t\tscope.inTransaction( session -> {\n\t\t\tsession.createMutationQuery( \"delete from Book\" ).executeUpdate();\n\t\t\tsession.createMutationQuery( \"delete from Author\" ).executeUpdate();\n\t\t} );\n\n\t\tscope.inTransaction( session -> {\n\t\t\tassertThat( session.createQuery( \"from Book\", Book.class ).list() ).isEmpty();\n\t\t\tassertThat( session.createQuery( \"from Author\", Author.class ).list() ).isEmpty();\n\t\t} );\n\t}\n\n\t@Entity(name = \"Book\")\n\tpublic static class Book {\n\n\t\t@Id\n\t\tprivate int id;\n\n\t\tpublic Book() {\n\t\t}\n\n\t\tpublic Book(int id) {\n\t\t\tthis.id = id;\n\t\t}\n\n\t\t@ManyToMany\n\t\t@JoinTable(name = \"book_author\",\n\t\t\t\tjoinColumns = { @JoinColumn(name = \"fk_book\") },\n\t\t\t\tinverseJoinColumns = { @JoinColumn(name = \"fk_author\") })\n\t\tprivate List<Author> authors = new ArrayList<>();\n\n\t\tpublic void addAuthor(Author author) {\n\t\t\tauthors.add( author );\n\t\t\tauthor.books.add( this );\n\t\t}\n\t}\n\n\t@Entity(name = \"Author\")\n\tpublic static class Author {\n\n\t\t@Id\n\t\tprivate int id;\n\n\t\tpublic Author() {\n\t\t}\n\n\t\tpublic Author(int id) {\n\t\t\tthis.id = id;\n\t\t}\n\n\t\t@ManyToMany(mappedBy = \"authors\")\n\t\tprivate List<Book> books = new ArrayList<>();\n\n\t\tpublic void addBook(Book book) {\n\t\t\tbooks.add( book );\n\t\t\tbook.authors.add( this );\n\t\t}\n\t}\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate exportSandboxSchema(sessionImpl SessionImplementor) : void extracted from public testSessionBatchingUsage() : void in class org.hibernate.orm.test.jdbc.internal.BatchingTest",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/jdbc/internal/BatchingTest.java",
                "startLine": 180,
                "endLine": 261,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/jdbc/internal/BatchingTest.java",
                "startLine": 229,
                "endLine": 302,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/jdbc/internal/BatchingTest.java",
                "startLine": 304,
                "endLine": 323,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n\tpublic void testSessionBatchingUsage() throws Exception {\n\t\tSession session = openSession();\n\t\tsession.setJdbcBatchSize( 3 );\n\t\tSessionImplementor sessionImpl = (SessionImplementor) session;\n\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n\n\t\t// set up some tables to use\n\t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n\t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n\t\ttry {\n\t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n\t\t}\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n        jdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n\n\t\t// ok, now we can get down to it...\n\t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n\t\ttxn.begin();\n\n\t\tfinal BatchBuilder batchBuilder = new BatchBuilderImpl( 2 );\n\t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\", Expectations.BASIC );\n\t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, jdbcCoordinator );\n\t\tassertTrue( \"unexpected Batch impl\", BatchingBatch.class.isInstance( insertBatch ) );\n\n\t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n\t\tinsertBatch.addObserver( batchObserver );\n\n\t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n\n\t\tPreparedStatement insert = insertBatch.getBatchStatement( insertSql, false );\n\t\tinsert.setLong( 1, 1 );\n\t\tinsert.setString( 2, \"name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tPreparedStatement insert2 = insertBatch.getBatchStatement( insertSql, false );\n\t\tassertSame( insert, insert2 );\n\t\tinsert = insert2;\n\t\tinsert.setLong( 1, 2 );\n\t\tinsert.setString( 2, \"another name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tPreparedStatement insert3 = insertBatch.getBatchStatement( insertSql, false );\n\t\tassertSame( insert, insert3 );\n\t\tinsert = insert3;\n\t\tinsert.setLong( 1, 3 );\n\t\tinsert.setString( 2, \"yet another name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.execute();\n\t\tassertEquals( 1, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.release();\n\n\t\ttxn.commit();\n\t\tsession.close();\n\t}",
        "filePathBefore": "hibernate-core/src/test/java/org/hibernate/orm/test/jdbc/internal/BatchingTest.java",
        "isPureRefactoring": true,
        "commitId": "a9ac98b364ccf52bb9cb2be5324c9c983e8bd8b3",
        "packageNameBefore": "org.hibernate.orm.test.jdbc.internal",
        "classNameBefore": "org.hibernate.orm.test.jdbc.internal.BatchingTest",
        "methodNameBefore": "org.hibernate.orm.test.jdbc.internal.BatchingTest#testSessionBatchingUsage",
        "invokedMethod": "methodSignature: org.hibernate.action.internal.BulkOperationCleanupAction.NaturalIdCleanup#release\n methodBody: private void release() {\nnaturalIdCacheAccessStrategy.unlockRegion(cacheLock);\n}\nmethodSignature: org.hibernate.orm.test.insertordering.InsertOrderingTest.StatsBatch#addToBatch\n methodBody: public void addToBatch() {\nCounter counter=(Counter)batchSizes.get(currentBatch);\ncounter.count++;\nsuper.addToBatch();\n}\nmethodSignature: org.hibernate.engine.jdbc.spi.JdbcCoordinator#getStatementPreparer\n methodBody: StatementPreparer getStatementPreparer();\nmethodSignature: org.hibernate.engine.jdbc.spi.JdbcServices#getDialect\n methodBody: Dialect getDialect();\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\nif(sql == null){throw new IllegalArgumentException(\"sql must be non-null.\");\n}PreparedStatement statement=statements.get(sql);\nif(statement == null){statement=buildBatchStatement(sql,callable);\nstatements.put(sql,statement);\n}{LOG.debug(\"Reusing batch statement\");\nsqlStatementLogger().logStatement(sql);\n}return statement;\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#execute\n methodBody: void execute();\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.SharedBatchBuildingCode#buildBatch\n methodBody: static Batch buildBatch(final int defaultJdbcBatchSize, final BatchKey key, final JdbcCoordinator jdbcCoordinator) {\nfinal Integer sessionJdbcBatchSize=jdbcCoordinator.getJdbcSessionOwner().getJdbcBatchSize();\nfinal int jdbcBatchSizeToUse=sessionJdbcBatchSize == null ? defaultJdbcBatchSize : sessionJdbcBatchSize;\nreturn jdbcBatchSizeToUse > 1 ? new BatchingBatch(key,jdbcCoordinator,jdbcBatchSizeToUse) : new NonBatchingBatch(key,jdbcCoordinator);\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#getLogicalConnection\n methodBody: public LogicalConnectionImplementor getLogicalConnection() {\nreturn logicalConnection;\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#close\n methodBody: protected void close(ResultSet resultSet) {\nLOG.tracev(\"Closing result set [{0}]\",resultSet);\nif(resultSet instanceof InvalidatableWrapper){@SuppressWarnings(\"unchecked\") final InvalidatableWrapper<ResultSet> wrapper=(InvalidatableWrapper<ResultSet>)resultSet;\nclose(wrapper.getWrappedObject());\nwrapper.invalidate();\nreturn;\n}tryresultSet.close();\ncatch(Exception e)LOG.debugf(\"Unable to release JDBC result set [%s]\",e.getMessage());\n}\nmethodSignature: org.hibernate.query.sqm.mutation.internal.inline.InlineUpdateHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal List<Object> ids=MatchingIdSelectionHelper.selectMatchingIds(sqmUpdate,domainParameterXref,executionContext);\nif(ids == null || ids.isEmpty()){return 0;\n}domainParameterXref.clearExpansions();\nfinal MappingMetamodel domainModel=sessionFactory.getRuntimeMetamodels().getMappingMetamodel();\nfinal String mutatingEntityName=sqmUpdate.getTarget().getModel().getHibernateEntityName();\nfinal EntityPersister entityDescriptor=domainModel.getEntityDescriptor(mutatingEntityName);\nfinal String rootEntityName=entityDescriptor.getEntityPersister().getRootEntityName();\nfinal EntityPersister rootEntityDescriptor=domainModel.getEntityDescriptor(rootEntityName);\nfinal String hierarchyRootTableName=((Joinable)rootEntityDescriptor).getTableName();\nfinal List<Expression> inListExpressions=new ArrayList<>(ids.size());\nfinal EntityIdentifierMapping identifierMapping=entityDescriptor.getIdentifierMapping();\nif(identifierMapping instanceof BasicValuedModelPart){final BasicValuedModelPart basicValuedModelPart=(BasicValuedModelPart)identifierMapping;\nfor(int i=0; i < ids.size(); i++){inListExpressions.add(new QueryLiteral<>(ids.get(i),basicValuedModelPart));\n}}{final int jdbcTypeCount=identifierMapping.getJdbcTypeCount();\nfor(int i=0; i < ids.size(); i++){final Object[] id=(Object[])ids.get(i);\nfinal List<Expression> tupleElements=new ArrayList<>(jdbcTypeCount);\ninListExpressions.add(new SqlTuple(tupleElements,identifierMapping));\nidentifierMapping.forEachJdbcType((index,jdbcMapping) -> {\n  tupleElements.add(new QueryLiteral<>(id[index],(BasicValuedMapping)jdbcMapping));\n}\n);\n}}final MultiTableSqmMutationConverter converterDelegate=new MultiTableSqmMutationConverter(entityDescriptor,sqmUpdate,sqmUpdate.getTarget(),domainParameterXref,executionContext.getQueryOptions(),executionContext.getSession().getLoadQueryInfluencers(),executionContext.getQueryParameterBindings(),sessionFactory);\nfinal TableGroup updatingTableGroup=converterDelegate.getMutatingTableGroup();\nfinal TableReference hierarchyRootTableReference=updatingTableGroup.resolveTableReference(updatingTableGroup.getNavigablePath(),hierarchyRootTableName);\nassert hierarchyRootTableReference != null;\nfinal Map<SqmParameter<?>,List<List<JdbcParameter>>> parameterResolutions;\nif(domainParameterXref.getSqmParameterCount() == 0){parameterResolutions=Collections.emptyMap();\n}{parameterResolutions=new IdentityHashMap<>();\n}final List<Assignment> assignments=new ArrayList<>();\nfinal Map<SqmParameter<?>,MappingModelExpressible<?>> paramTypeResolutions=new LinkedHashMap<>();\nconverterDelegate.visitSetClause(sqmUpdate.getSetClause(),assignments::add,(sqmParameter,mappingType,jdbcParameters) -> {\n  parameterResolutions.computeIfAbsent(sqmParameter,k -> new ArrayList<>(1)).add(jdbcParameters);\n  paramTypeResolutions.put(sqmParameter,mappingType);\n}\n);\nconverterDelegate.addVersionedAssignment(assignments::add,sqmUpdate);\nfinal Predicate providedPredicate;\nfinal SqmWhereClause whereClause=sqmUpdate.getWhereClause();\nif(whereClause == null || whereClause.getPredicate() == null){providedPredicate=null;\n}{providedPredicate=converterDelegate.visitWhereClause(whereClause,columnReference -> {\n}\n,(sqmParameter,mappingType,jdbcParameters) -> {\n  parameterResolutions.computeIfAbsent(sqmParameter,k -> new ArrayList<>(1)).add(jdbcParameters);\n  paramTypeResolutions.put(sqmParameter,mappingType);\n}\n);\nassert providedPredicate != null;\n}final PredicateCollector predicateCollector=new PredicateCollector(providedPredicate);\nentityDescriptor.applyBaseRestrictions(predicateCollector::applyPredicate,updatingTableGroup,true,executionContext.getSession().getLoadQueryInfluencers().getEnabledFilters(),null,converterDelegate);\nconverterDelegate.pruneTableGroupJoins();\nfinal Map<String,TableReference> tableReferenceByAlias=CollectionHelper.mapOfSize(updatingTableGroup.getTableReferenceJoins().size() + 1);\ncollectTableReference(updatingTableGroup.getPrimaryTableReference(),tableReferenceByAlias::put);\nfor(int i=0; i < updatingTableGroup.getTableReferenceJoins().size(); i++){collectTableReference(updatingTableGroup.getTableReferenceJoins().get(i),tableReferenceByAlias::put);\n}final JdbcParameterBindings jdbcParameterBindings=SqmUtil.createJdbcParameterBindings(executionContext.getQueryParameterBindings(),domainParameterXref,SqmUtil.generateJdbcParamsXref(domainParameterXref,() -> parameterResolutions),sessionFactory.getRuntimeMetamodels().getMappingMetamodel(),navigablePath -> updatingTableGroup,new SqmParameterMappingModelResolutionAccess(){\n  @Override @SuppressWarnings(\"unchecked\") public <T>MappingModelExpressible<T> getResolvedMappingModelType(  SqmParameter<T> parameter){\n    return (MappingModelExpressible<T>)paramTypeResolutions.get(parameter);\n  }\n}\n,executionContext.getSession());\nfinal Map<TableReference,List<Assignment>> assignmentsByTable=new HashMap<>();\nfor(int i=0; i < assignments.size(); i++){final Assignment assignment=assignments.get(i);\nfinal List<ColumnReference> assignmentColumnRefs=assignment.getAssignable().getColumnReferences();\nTableReference assignmentTableReference=null;\nfor(int c=0; c < assignmentColumnRefs.size(); c++){final ColumnReference columnReference=assignmentColumnRefs.get(c);\nfinal TableReference tableReference=resolveTableReference(columnReference,tableReferenceByAlias);\nif(assignmentTableReference != null && assignmentTableReference != tableReference){throw new SemanticException(\"Assignment referred to columns from multiple tables: \" + assignment.getAssignable());\n}assignmentTableReference=tableReference;\n}List<Assignment> assignmentsForTable=assignmentsByTable.get(assignmentTableReference);\nif(assignmentsForTable == null){assignmentsForTable=new ArrayList<>();\nassignmentsByTable.put(assignmentTableReference,assignmentsForTable);\n}assignmentsForTable.add(assignment);\n}final int rows=ids.size();\nfinal SqmJdbcExecutionContextAdapter executionContextAdapter=SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext);\nentityDescriptor.visitConstraintOrderedTables((tableExpression,tableKeyColumnVisitationSupplier) -> updateTable(tableExpression,tableKeyColumnVisitationSupplier,entityDescriptor,updatingTableGroup,assignmentsByTable,inListExpressions,rows,jdbcParameterBindings,executionContextAdapter));\nreturn rows;\n}\nmethodSignature: org.hibernate.dialect.AbstractHANADialect.CloseSuppressingInputStream#close\n methodBody: public void close() {\n}\nmethodSignature: org.hibernate.query.sqm.mutation.internal.inline.InlineDeleteHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal List<Object> idsAndFks=MatchingIdSelectionHelper.selectMatchingIds(sqmDeleteStatement,domainParameterXref,executionContext);\nif(idsAndFks == null || idsAndFks.isEmpty()){return 0;\n}final SessionFactoryImplementor factory=executionContext.getSession().getFactory();\nfinal String mutatingEntityName=sqmDeleteStatement.getTarget().getModel().getHibernateEntityName();\nfinal EntityMappingType entityDescriptor=factory.getRuntimeMetamodels().getEntityMappingType(mutatingEntityName);\nfinal JdbcParameterBindings jdbcParameterBindings=new JdbcParameterBindingsImpl(domainParameterXref.getQueryParameterCount());\nfinal MutableInteger valueIndexCounter=new MutableInteger();\nSqmMutationStrategyHelper.visitCollectionTables(entityDescriptor,pluralAttribute -> {\n  if (pluralAttribute.getSeparateCollectionTable() != null) {\n    final ModelPart fkTargetPart=pluralAttribute.getKeyDescriptor().getTargetPart();\n    final int valueIndex;\n    if (fkTargetPart instanceof EntityIdentifierMapping) {\n      valueIndex=0;\n    }\n else {\n      if (valueIndexCounter.get() == 0) {\n        valueIndexCounter.set(entityDescriptor.getIdentifierMapping().getJdbcTypeCount());\n      }\n      valueIndex=valueIndexCounter.get();\n      valueIndexCounter.plus(fkTargetPart.getJdbcTypeCount());\n    }\n    executeDelete(pluralAttribute.getSeparateCollectionTable(),entityDescriptor,() -> fkTargetPart::forEachSelectable,idsAndFks,valueIndex,fkTargetPart,jdbcParameterBindings,executionContext);\n  }\n}\n);\nentityDescriptor.visitConstraintOrderedTables((tableExpression,tableKeyColumnsVisitationSupplier) -> {\n  executeDelete(tableExpression,entityDescriptor,tableKeyColumnsVisitationSupplier,idsAndFks,0,null,jdbcParameterBindings,executionContext);\n}\n);\nreturn idsAndFks.size();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#hasRegisteredResources\n methodBody: private boolean hasRegisteredResources() {\nreturn getLogicalConnection().getResourceRegistry().hasRegisteredResources();\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#release\n methodBody: void release();\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.UnmodifiableBatchBuilderImpl#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn SharedBatchBuildingCode.buildBatch(jdbcBatchSize,key,jdbcCoordinator);\n}\nmethodSignature: org.hibernate.persister.entity.AbstractEntityPersister#isInstance\n methodBody: public boolean isInstance(Object object) {\nreturn getRepresentationStrategy().getInstantiator().isInstance(object,getFactory());\n}\nmethodSignature: org.hibernate.orm.test.jpa.transaction.batch.JtaWithFailingBatchTest.TestBatch#addToBatch\n methodBody: public void addToBatch() {\nthrow sqlExceptionHelper().convert(new SQLException(\"fake SQLException\"),\"could not perform addBatch\",currentStatementSql);\n}\nmethodSignature: org.hibernate.action.internal.BulkOperationCleanupAction#execute\n methodBody: public void execute() throws HibernateException {\n}\nmethodSignature: org.hibernate.orm.test.jpa.transaction.batch.JtaWithFailingBatchTest.TestBatch#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\ncurrentStatementSql=sql;\nPreparedStatement batchStatement=super.getBatchStatement(sql,callable);\ncreatedStatements.add(batchStatement);\nreturn batchStatement;\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.spi.BatchBuilder#buildBatch\n methodBody: Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator);\nmethodSignature: org.hibernate.procedure.internal.ProcedureCallImpl#execute\n methodBody: public boolean execute() {\ntryreturn outputs().getCurrent() instanceof ResultSetOutput;\ncatch(NoMoreOutputsException e)return false;\ncatch(HibernateException he)throw getSession().getExceptionConverter().convert(he);\ncatch(RuntimeException e)getSession().markForRollbackOnly();\nthrow e;\n}\nmethodSignature: org.hibernate.query.sqm.mutation.internal.cte.CteInsertHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal SqmInsertStatement<?> sqmInsertStatement=getSqmStatement();\nfinal SessionFactoryImplementor factory=executionContext.getSession().getFactory();\nfinal EntityPersister entityDescriptor=getEntityDescriptor().getEntityPersister();\nfinal String explicitDmlTargetAlias;\nif(sqmInsertStatement.getTarget().getExplicitAlias() == null){explicitDmlTargetAlias=\"dml_target\";\n}{explicitDmlTargetAlias=sqmInsertStatement.getTarget().getExplicitAlias();\n}final MultiTableSqmMutationConverter sqmConverter=new MultiTableSqmMutationConverter(entityDescriptor,sqmInsertStatement,sqmInsertStatement.getTarget(),explicitDmlTargetAlias,domainParameterXref,executionContext.getQueryOptions(),executionContext.getSession().getLoadQueryInfluencers(),executionContext.getQueryParameterBindings(),factory);\nfinal TableGroup insertingTableGroup=sqmConverter.getMutatingTableGroup();\nfinal Map<SqmParameter<?>,List<List<JdbcParameter>>> parameterResolutions;\nif(domainParameterXref.getSqmParameterCount() == 0){parameterResolutions=Collections.emptyMap();\n}{parameterResolutions=new IdentityHashMap<>();\n}final int size=sqmStatement.getInsertionTargetPaths().size();\nfinal List<Map.Entry<List<CteColumn>,Assignment>> targetPathColumns=new ArrayList<>(size);\nfinal List<CteColumn> targetPathCteColumns=new ArrayList<>(size);\nfinal Map<SqmParameter<?>,MappingModelExpressible<?>> paramTypeResolutions=new LinkedHashMap<>();\nfinal NamedTableReference entityTableReference=new NamedTableReference(cteTable.getTableExpression(),TemporaryTable.DEFAULT_ALIAS,true,sessionFactory);\nfinal InsertStatement insertStatement=new InsertStatement(entityTableReference);\nfinal BaseSqmToSqlAstConverter.AdditionalInsertValues additionalInsertValues=sqmConverter.visitInsertionTargetPaths((assignable,columnReferences) -> {\n  final SqmPathInterpretation<?> pathInterpretation=(SqmPathInterpretation<?>)assignable;\n  final int offset=CteTable.determineModelPartStartIndex(entityDescriptor,pathInterpretation.getExpressionType());\n  if (offset == -1) {\n    throw new IllegalStateException(\"Couldn't find matching cte column for: \" + ((Expression)assignable).getExpressionType());\n  }\n  final int end=offset + pathInterpretation.getExpressionType().getJdbcTypeCount();\n  final List<CteColumn> columns=cteTable.getCteColumns().subList(offset,end);\n  insertStatement.addTargetColumnReferences(columnReferences);\n  targetPathCteColumns.addAll(columns);\n  targetPathColumns.add(new AbstractMap.SimpleEntry<>(columns,new Assignment(assignable,(Expression)assignable)));\n}\n,sqmInsertStatement,entityDescriptor,insertingTableGroup,(sqmParameter,mappingType,jdbcParameters) -> {\n  parameterResolutions.computeIfAbsent(sqmParameter,k -> new ArrayList<>(1)).add(jdbcParameters);\n  paramTypeResolutions.put(sqmParameter,mappingType);\n}\n);\nfinal boolean assignsId=targetPathCteColumns.contains(cteTable.getCteColumns().get(0));\nfinal Stack<SqlAstProcessingState> processingStateStack=sqmConverter.getProcessingStateStack();\nfinal SqlAstProcessingState oldState=processingStateStack.pop();\nfinal Statement queryStatement;\nif(sqmInsertStatement instanceof SqmInsertSelectStatement){final QueryPart queryPart=sqmConverter.visitQueryPart(((SqmInsertSelectStatement<?>)sqmInsertStatement).getSelectQueryPart());\nqueryPart.visitQuerySpecs(querySpec -> {\n  if (additionalInsertValues.applySelections(querySpec,sessionFactory)) {\n    final CteColumn rowNumberColumn=cteTable.getCteColumns().get(cteTable.getCteColumns().size() - 1);\n    final ColumnReference columnReference=new ColumnReference((String)null,rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping());\n    insertStatement.getTargetColumnReferences().set(insertStatement.getTargetColumnReferences().size() - 1,columnReference);\n    targetPathCteColumns.set(targetPathCteColumns.size() - 1,rowNumberColumn);\n  }\n  if (!assignsId && entityDescriptor.getIdentifierGenerator() instanceof PostInsertIdentifierGenerator) {\n    querySpec.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,SqmInsertStrategyHelper.createRowNumberingExpression(querySpec,sessionFactory)));\n  }\n}\n);\nqueryStatement=new SelectStatement(queryPart);\n}{final List<SqmValues> sqmValuesList=((SqmInsertValuesStatement<?>)sqmInsertStatement).getValuesList();\nfinal List<Values> valuesList=new ArrayList<>(sqmValuesList.size());\nfor(SqmValues sqmValues: sqmValuesList){final Values values=sqmConverter.visitValues(sqmValues);\nadditionalInsertValues.applyValues(values);\nvaluesList.add(values);\n}final QuerySpec querySpec=new QuerySpec(true);\nfinal NavigablePath navigablePath=new NavigablePath(entityDescriptor.getRootPathName());\nfinal List<String> columnNames=new ArrayList<>(targetPathColumns.size());\nfinal String valuesAlias=insertingTableGroup.getPrimaryTableReference().getIdentificationVariable();\nfor(Map.Entry<List<CteColumn>,Assignment> entry: targetPathColumns){for(ColumnReference columnReference: entry.getValue().getAssignable().getColumnReferences()){columnNames.add(columnReference.getColumnExpression());\nquerySpec.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,columnReference.getQualifier().equals(valuesAlias) ? columnReference : new ColumnReference(valuesAlias,columnReference.getColumnExpression(),false,null,null,columnReference.getJdbcMapping())));\n}}final ValuesTableGroup valuesTableGroup=new ValuesTableGroup(navigablePath,entityDescriptor.getEntityPersister(),valuesList,insertingTableGroup.getPrimaryTableReference().getIdentificationVariable(),columnNames,true,factory);\nquerySpec.getFromClause().addRoot(valuesTableGroup);\nqueryStatement=new SelectStatement(querySpec);\n}processingStateStack.push(oldState);\nsqmConverter.pruneTableGroupJoins();\nif(!assignsId && entityDescriptor.getIdentifierGenerator() instanceof PostInsertIdentifierGenerator){final CteColumn rowNumberColumn=cteTable.getCteColumns().get(cteTable.getCteColumns().size() - 1);\nfinal ColumnReference columnReference=new ColumnReference((String)null,rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping());\ninsertStatement.getTargetColumnReferences().add(columnReference);\ntargetPathCteColumns.add(rowNumberColumn);\n}final CteTable entityCteTable=createCteTable(getCteTable(),targetPathCteColumns,factory);\nfinal QuerySpec querySpec=new QuerySpec(true,1);\nfinal List<DomainResult<?>> domainResults=new ArrayList<>(1);\nfinal SelectStatement statement=new SelectStatement(querySpec,domainResults);\nfinal CteStatement entityCte;\nif(additionalInsertValues.requiresRowNumberIntermediate()){final CteTable fullEntityCteTable=getCteTable();\nfinal String baseTableName=\"base_\" + entityCteTable.getTableExpression();\nfinal CteStatement baseEntityCte=new CteStatement(entityCteTable.withName(baseTableName),queryStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(baseEntityCte);\nfinal CteColumn rowNumberColumn=fullEntityCteTable.getCteColumns().get(fullEntityCteTable.getCteColumns().size() - 1);\nfinal ColumnReference rowNumberColumnReference=new ColumnReference(\"e\",rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping());\nfinal CteColumn idColumn=fullEntityCteTable.getCteColumns().get(0);\nfinal BasicValuedMapping idType=(BasicValuedMapping)idColumn.getJdbcMapping();\nfinal Optimizer optimizer=((OptimizableGenerator)entityDescriptor.getIdentifierGenerator()).getOptimizer();\nfinal BasicValuedMapping integerType=(BasicValuedMapping)rowNumberColumn.getJdbcMapping();\nfinal Expression rowNumberMinusOneModuloIncrement=new BinaryArithmeticExpression(new BinaryArithmeticExpression(rowNumberColumnReference,BinaryArithmeticOperator.SUBTRACT,new QueryLiteral<>(1,(BasicValuedMapping)rowNumberColumn.getJdbcMapping()),integerType),BinaryArithmeticOperator.MODULO,new QueryLiteral<>(optimizer.getIncrementSize(),integerType),integerType);\n{final QuerySpec rowsWithSequenceQuery=new QuerySpec(true);\nrowsWithSequenceQuery.getFromClause().addRoot(new CteTableGroup(new NamedTableReference(baseTableName,\"e\",false,factory)));\nrowsWithSequenceQuery.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,rowNumberColumnReference));\nfinal String fragment=((BulkInsertionCapableIdentifierGenerator)entityDescriptor.getIdentifierGenerator()).determineBulkInsertionIdentifierGenerationSelectFragment(sessionFactory.getSqlStringGenerationContext());\nrowsWithSequenceQuery.getSelectClause().addSqlSelection(new SqlSelectionImpl(2,1,new SelfRenderingSqlFragmentExpression(fragment)));\nrowsWithSequenceQuery.applyPredicate(new ComparisonPredicate(rowNumberMinusOneModuloIncrement,ComparisonOperator.EQUAL,new QueryLiteral<>(0,integerType)));\nfinal CteTable rowsWithSequenceCteTable=new CteTable(ROW_NUMBERS_WITH_SEQUENCE_VALUE,List.of(rowNumberColumn,idColumn));\nfinal SelectStatement rowsWithSequenceStatement=new SelectStatement(rowsWithSequenceQuery);\nfinal CteStatement rowsWithSequenceCte=new CteStatement(rowsWithSequenceCteTable,rowsWithSequenceStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(rowsWithSequenceCte);\n}{final QuerySpec entityQuery=new QuerySpec(true);\nfinal NavigablePath navigablePath=new NavigablePath(baseTableName);\nfinal TableGroup baseTableGroup=new TableGroupImpl(navigablePath,null,new NamedTableReference(baseTableName,\"e\",false,factory),null);\nfinal TableGroup rowsWithSequenceTableGroup=new CteTableGroup(new NamedTableReference(ROW_NUMBERS_WITH_SEQUENCE_VALUE,\"t\",false,factory));\nbaseTableGroup.addTableGroupJoin(new TableGroupJoin(rowsWithSequenceTableGroup.getNavigablePath(),SqlAstJoinType.LEFT,rowsWithSequenceTableGroup,new ComparisonPredicate(new BinaryArithmeticExpression(rowNumberColumnReference,BinaryArithmeticOperator.SUBTRACT,rowNumberMinusOneModuloIncrement,integerType),ComparisonOperator.EQUAL,new ColumnReference(\"t\",rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping()))));\nentityQuery.getFromClause().addRoot(baseTableGroup);\nentityQuery.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,new BinaryArithmeticExpression(new ColumnReference(\"t\",idColumn.getColumnExpression(),false,null,null,idColumn.getJdbcMapping()),BinaryArithmeticOperator.ADD,new BinaryArithmeticExpression(rowNumberColumnReference,BinaryArithmeticOperator.SUBTRACT,new ColumnReference(\"t\",rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping()),integerType),idType)));\nfinal CteTable finalEntityCteTable;\nif(targetPathCteColumns.contains(getCteTable().getCteColumns().get(0))){finalEntityCteTable=entityCteTable;\n}{targetPathCteColumns.add(0,getCteTable().getCteColumns().get(0));\nfinalEntityCteTable=createCteTable(getCteTable(),targetPathCteColumns,factory);\n}final List<CteColumn> cteColumns=finalEntityCteTable.getCteColumns();\nfor(int i=1; i < cteColumns.size(); i++){final CteColumn cteColumn=cteColumns.get(i);\nentityQuery.getSelectClause().addSqlSelection(new SqlSelectionImpl(i + 1,i,new ColumnReference(\"e\",cteColumn.getColumnExpression(),false,null,null,cteColumn.getJdbcMapping())));\n}final SelectStatement entityStatement=new SelectStatement(entityQuery);\nentityCte=new CteStatement(finalEntityCteTable,entityStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(entityCte);\n}}if(!assignsId && entityDescriptor.getIdentifierGenerator() instanceof PostInsertIdentifierGenerator){final String baseTableName=\"base_\" + entityCteTable.getTableExpression();\nfinal CteStatement baseEntityCte=new CteStatement(entityCteTable.withName(baseTableName),queryStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(baseEntityCte);\ntargetPathCteColumns.add(0,cteTable.getCteColumns().get(0));\nfinal CteTable finalEntityCteTable=createCteTable(getCteTable(),targetPathCteColumns,factory);\nfinal QuerySpec finalQuerySpec=new QuerySpec(true);\nfinal SelectStatement finalQueryStatement=new SelectStatement(finalQuerySpec);\nentityCte=new CteStatement(finalEntityCteTable,finalQueryStatement,CteMaterialization.MATERIALIZED);\n}{entityCte=new CteStatement(entityCteTable,queryStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(entityCte);\n}final String baseInsertCte=addDmlCtes(statement,entityCte,targetPathColumns,assignsId,sqmConverter,parameterResolutions,factory);\nfinal Expression count=createCountStar(factory,sqmConverter);\ndomainResults.add(new BasicResult<>(0,null,((SqlExpressible)count).getJdbcMapping()));\nquerySpec.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,count));\nquerySpec.getFromClause().addRoot(new CteTableGroup(new NamedTableReference(baseInsertCte,CTE_TABLE_IDENTIFIER,false,factory)));\nfinal JdbcServices jdbcServices=factory.getJdbcServices();\nfinal SqlAstTranslator<JdbcSelect> translator=jdbcServices.getJdbcEnvironment().getSqlAstTranslatorFactory().buildSelectTranslator(factory,statement);\nfinal JdbcParameterBindings jdbcParameterBindings=SqmUtil.createJdbcParameterBindings(executionContext.getQueryParameterBindings(),domainParameterXref,SqmUtil.generateJdbcParamsXref(domainParameterXref,sqmConverter),factory.getRuntimeMetamodels().getMappingMetamodel(),navigablePath -> sqmConverter.getMutatingTableGroup(),new SqmParameterMappingModelResolutionAccess(){\n  @Override @SuppressWarnings(\"unchecked\") public <T>MappingModelExpressible<T> getResolvedMappingModelType(  SqmParameter<T> parameter){\n    return (MappingModelExpressible<T>)paramTypeResolutions.get(parameter);\n  }\n}\n,executionContext.getSession());\nfinal JdbcSelect select=translator.translate(jdbcParameterBindings,executionContext.getQueryOptions());\nexecutionContext.getSession().autoFlushIfRequired(select.getAffectedTableNames());\nList<Object> list=jdbcServices.getJdbcSelectExecutor().list(select,jdbcParameterBindings,SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext),row -> row[0],ListResultsConsumer.UniqueSemantic.NONE);\nreturn ((Number)list.get(0)).intValue();\n}\nmethodSignature: org.hibernate.query.sqm.mutation.internal.temptable.InsertExecutionDelegate#execute\n methodBody: public int execute(ExecutionContext executionContext) {\nExecuteWithTemporaryTableHelper.performBeforeTemporaryTableUseActions(entityTable,executionContext);\ntryif(sessionUidParameter != null){jdbcParameterBindings.addBinding(sessionUidParameter,new JdbcParameterBindingImpl(entityTable.getSessionUidColumn().getJdbcMapping(),UUID.fromString(sessionUidAccess.apply(executionContext.getSession()))));\n}final int rows=ExecuteWithTemporaryTableHelper.saveIntoTemporaryTable(insertStatement,jdbcParameterBindings,executionContext);\nif(rows != 0){final AbstractEntityPersister persister=(AbstractEntityPersister)entityDescriptor.getEntityPersister();\nfinal int tableSpan=persister.getTableSpan();\ninsertRootTable(persister.getTableName(0),rows,persister.getKeyColumns(0),executionContext);\nif(persister.hasDuplicateTables()){final String[] insertedTables=new String[tableSpan];\ninsertedTables[0]=persister.getTableName(0);\nfor(int i=1; i < tableSpan; i++){if(persister.isInverseTable(i)){continue;\n}final String tableName=persister.getTableName(i);\ninsertedTables[i]=tableName;\nif(ArrayHelper.indexOf(insertedTables,i,tableName) != -1){continue;\n}insertTable(tableName,persister.getKeyColumns(i),persister.isNullableTable(i),executionContext);\n}}{for(int i=1; i < tableSpan; i++){insertTable(persister.getTableName(i),persister.getKeyColumns(i),persister.isNullableTable(i),executionContext);\n}}}return rows;\nfinallyExecuteWithTemporaryTableHelper.performAfterTemporaryTableUseActions(entityTable,sessionUidAccess,afterUseAction,executionContext);\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#getResultSetReturn\n methodBody: public ResultSetReturn getResultSetReturn() {\nif(resultSetExtractor == null){resultSetExtractor=new ResultSetReturnImpl(this,jdbcServices);\n}return resultSetExtractor;\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#addObserver\n methodBody: void addObserver(BatchObserver observer);\nmethodSignature: org.hibernate.query.sqm.mutation.internal.temptable.UpdateExecutionDelegate#execute\n methodBody: public int execute(ExecutionContext executionContext) {\nExecuteWithTemporaryTableHelper.performBeforeTemporaryTableUseActions(idTable,executionContext);\ntryfinal int rows=ExecuteWithTemporaryTableHelper.saveMatchingIdsIntoIdTable(sqmConverter,suppliedPredicate,idTable,sessionUidAccess,jdbcParameterBindings,executionContext);\nfinal QuerySpec idTableSubQuery=ExecuteWithTemporaryTableHelper.createIdTableSelectQuerySpec(idTable,sessionUidAccess,entityDescriptor,executionContext);\nentityDescriptor.visitConstraintOrderedTables((tableExpression,tableKeyColumnVisitationSupplier) -> updateTable(tableExpression,tableKeyColumnVisitationSupplier,rows,idTableSubQuery,executionContext));\nreturn rows;\nfinallyExecuteWithTemporaryTableHelper.performAfterTemporaryTableUseActions(idTable,sessionUidAccess,afterUseAction,executionContext);\n}\nmethodSignature: org.hibernate.metamodel.mapping.internal.MappingModelCreationProcess#execute\n methodBody: private void execute() {\nfor(EntityPersister entityPersister: entityPersisterMap.values()){if(entityPersister instanceof InFlightEntityMappingType){((InFlightEntityMappingType)entityPersister).linkWithSuperType(this);\n}}for(EntityPersister entityPersister: entityPersisterMap.values()){currentlyProcessingRole=entityPersister.getEntityName();\nif(entityPersister instanceof InFlightEntityMappingType){((InFlightEntityMappingType)entityPersister).prepareMappingModel(this);\n}}executePostInitCallbacks();\n}\nmethodSignature: org.hibernate.orm.test.insertordering.InsertOrderingTest.StatsBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn new StatsBatch(key,jdbcCoordinator,getJdbcBatchSize());\n}\nmethodSignature: org.hibernate.query.sqm.mutation.internal.cte.AbstractCteMutationHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal SqmDeleteOrUpdateStatement sqmMutationStatement=getSqmDeleteOrUpdateStatement();\nfinal SessionFactoryImplementor factory=executionContext.getSession().getFactory();\nfinal EntityMappingType entityDescriptor=getEntityDescriptor();\nfinal String explicitDmlTargetAlias;\nif(sqmMutationStatement.getTarget().getExplicitAlias() == null){explicitDmlTargetAlias=\"dml_target\";\n}{explicitDmlTargetAlias=sqmMutationStatement.getTarget().getExplicitAlias();\n}final MultiTableSqmMutationConverter sqmConverter=new MultiTableSqmMutationConverter(entityDescriptor,sqmMutationStatement,sqmMutationStatement.getTarget(),explicitDmlTargetAlias,domainParameterXref,executionContext.getQueryOptions(),executionContext.getSession().getLoadQueryInfluencers(),executionContext.getQueryParameterBindings(),factory);\nfinal Map<SqmParameter<?>,List<JdbcParameter>> parameterResolutions;\nif(domainParameterXref.getSqmParameterCount() == 0){parameterResolutions=Collections.emptyMap();\n}{parameterResolutions=new IdentityHashMap<>();\n}final Map<SqmParameter,MappingModelExpressible> paramTypeResolutions=new LinkedHashMap<>();\nfinal Predicate restriction=sqmConverter.visitWhereClause(sqmMutationStatement.getWhereClause(),columnReference -> {\n}\n,(sqmParam,mappingType,jdbcParameters) -> paramTypeResolutions.put(sqmParam,mappingType));\nsqmConverter.pruneTableGroupJoins();\nfinal CteStatement idSelectCte=new CteStatement(getCteTable(),MatchingIdSelectionHelper.generateMatchingIdSelectStatement(entityDescriptor,sqmMutationStatement,true,restriction,sqmConverter,executionContext,factory),CteMaterialization.MATERIALIZED);\nfinal QuerySpec querySpec=new QuerySpec(true,1);\nfinal List<DomainResult<?>> domainResults=new ArrayList<>(1);\nfinal SelectStatement statement=new SelectStatement(querySpec,domainResults);\nfinal JdbcServices jdbcServices=factory.getJdbcServices();\nfinal SqlAstTranslator<JdbcSelect> translator=jdbcServices.getJdbcEnvironment().getSqlAstTranslatorFactory().buildSelectTranslator(factory,statement);\nfinal Expression count=createCountStar(factory,sqmConverter);\ndomainResults.add(new BasicResult<>(0,null,((SqlExpressible)count).getJdbcMapping()));\nquerySpec.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,count));\nquerySpec.getFromClause().addRoot(new CteTableGroup(new NamedTableReference(idSelectCte.getCteTable().getTableExpression(),CTE_TABLE_IDENTIFIER,false,factory)));\nstatement.addCteStatement(idSelectCte);\naddDmlCtes(statement,idSelectCte,sqmConverter,parameterResolutions,factory);\nfinal JdbcParameterBindings jdbcParameterBindings=SqmUtil.createJdbcParameterBindings(executionContext.getQueryParameterBindings(),domainParameterXref,SqmUtil.generateJdbcParamsXref(domainParameterXref,sqmConverter),factory.getRuntimeMetamodels().getMappingMetamodel(),navigablePath -> sqmConverter.getMutatingTableGroup(),paramTypeResolutions::get,executionContext.getSession());\nfinal LockOptions lockOptions=executionContext.getQueryOptions().getLockOptions();\nfinal LockMode lockMode=lockOptions.getAliasSpecificLockMode(explicitDmlTargetAlias);\nlockOptions.setAliasSpecificLockMode(explicitDmlTargetAlias,LockMode.WRITE);\nfinal JdbcSelect select=translator.translate(jdbcParameterBindings,executionContext.getQueryOptions());\nlockOptions.setAliasSpecificLockMode(explicitDmlTargetAlias,lockMode);\nexecutionContext.getSession().autoFlushIfRequired(select.getAffectedTableNames());\nList<Object> list=jdbcServices.getJdbcSelectExecutor().list(select,jdbcParameterBindings,SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext),row -> row[0],ListResultsConsumer.UniqueSemantic.NONE);\nreturn ((Number)list.get(0)).intValue();\n}\nmethodSignature: org.hibernate.mapping.Component.ValueGenerationPlan#execute\n methodBody: public void execute(SharedSessionContractImplementor session, Object incomingObject, Object injectionContext) {\nfinal Object generatedValue=subGenerator.generate(session,incomingObject);\ninjector.set(injectionContext,generatedValue);\n}\nmethodSignature: org.hibernate.query.sqm.mutation.internal.temptable.TableBasedInsertHandler.ExecutionDelegate#execute\n methodBody: int execute(ExecutionContext executionContext);\nmethodSignature: org.hibernate.dialect.AbstractHANADialect.MaterializedNClob#setString\n methodBody: public int setString(long pos, String str) throws SQLException {\nthis.data=this.data.substring(0,(int)(pos - 1)) + str + this.data.substring((int)(pos - 1 + str.length()));\nreturn str.length();\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch#addToBatch\n methodBody: public void addToBatch() {\nnotifyObserversImplicitExecution();\nfor(Map.Entry<String,PreparedStatement> entry: getStatements().entrySet()){final String statementSQL=entry.getKey();\ntryfinal PreparedStatement statement=entry.getValue();\nfinal int rowCount=jdbcCoordinator.getResultSetReturn().executeUpdate(statement);\ngetKey().getExpectation().verifyOutcome(rowCount,statement,0,statementSQL);\njdbcCoordinator.getLogicalConnection().getResourceRegistry().release(statement);\njdbcCoordinator.afterStatementExecution();\ncatch(SQLException e)abortBatch(e);\nthrow sqlExceptionHelper().convert(e,\"could not execute non-batched batch statement\",statementSQL);\ncatch(RuntimeException e)abortBatch(e);\nthrow e;\n}getStatements().clear();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#getStatementPreparer\n methodBody: public StatementPreparer getStatementPreparer() {\nif(statementPreparer == null){statementPreparer=new StatementPreparerImpl(this,jdbcServices);\n}return statementPreparer;\n}\nmethodSignature: org.hibernate.sql.Insert#getDialect\n methodBody: protected Dialect getDialect() {\nreturn dialect;\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#release\n methodBody: public void release() {\nif(getStatements() != null && !getStatements().isEmpty()){LOG.batchContainedStatementsOnRelease();\n}releaseStatements();\nobservers.clear();\n}\nmethodSignature: org.hibernate.sql.exec.internal.StandardJdbcMutationExecutor#execute\n methodBody: public int execute(\n\t\t\tJdbcMutation jdbcMutation,\n\t\t\tJdbcParameterBindings jdbcParameterBindings,\n\t\t\tFunction<String, PreparedStatement> statementCreator,\n\t\t\tBiConsumer<Integer, PreparedStatement> expectationCheck,\n\t\t\tExecutionContext executionContext) {\nfinal SharedSessionContractImplementor session=executionContext.getSession();\nsession.autoFlushIfRequired(jdbcMutation.getAffectedTableNames());\nfinal LogicalConnectionImplementor logicalConnection=session.getJdbcCoordinator().getLogicalConnection();\nfinal JdbcServices jdbcServices=session.getJdbcServices();\nfinal QueryOptions queryOptions=executionContext.getQueryOptions();\nfinal String finalSql;\nif(queryOptions == null){finalSql=jdbcMutation.getSql();\n}{finalSql=jdbcServices.getDialect().addSqlHintOrComment(jdbcMutation.getSql(),queryOptions,executionContext.getSession().getFactory().getSessionFactoryOptions().isCommentsEnabled());\n}tryfinal PreparedStatement preparedStatement=statementCreator.apply(finalSql);\ntryif(executionContext.getQueryOptions().getTimeout() != null){preparedStatement.setQueryTimeout(executionContext.getQueryOptions().getTimeout());\n}int paramBindingPosition=1;\nfor(JdbcParameterBinder parameterBinder: jdbcMutation.getParameterBinders()){parameterBinder.bindParameterValue(preparedStatement,paramBindingPosition++,jdbcParameterBindings,executionContext);\n}session.getEventListenerManager().jdbcExecuteStatementStart();\ntryint rows=preparedStatement.executeUpdate();\nexpectationCheck.accept(rows,preparedStatement);\nreturn rows;\nfinallysession.getEventListenerManager().jdbcExecuteStatementEnd();\nfinallylogicalConnection.getResourceRegistry().release(preparedStatement);\ncatch(SQLException e)throw jdbcServices.getSqlExceptionHelper().convert(e,\"JDBC exception executing SQL [\" + finalSql + \"]\");\nfinallyexecutionContext.afterStatement(logicalConnection);\n}\nmethodSignature: org.hibernate.sql.exec.spi.JdbcMutationExecutor#execute\n methodBody: int execute(\n\t\t\tJdbcMutation jdbcMutation,\n\t\t\tJdbcParameterBindings jdbcParameterBindings,\n\t\t\tFunction<String, PreparedStatement> statementCreator,\n\t\t\tBiConsumer<Integer, PreparedStatement> expectationCheck,\n\t\t\tExecutionContext executionContext);\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#addObserver\n methodBody: public void addObserver(BatchObserver observer) {\nobservers.add(observer);\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.BatchBuilderImpl#setJdbcBatchSize\n methodBody: public void setJdbcBatchSize(int jdbcBatchSize) {\nthis.jdbcBatchSize=jdbcBatchSize;\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.BatchingBatch#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\ncurrentStatementSql=sql;\nint previousBatchSize=getStatements().size();\ncurrentStatement=super.getBatchStatement(sql,callable);\nint currentBatchSize=getStatements().size();\nif(currentBatchSize > previousBatchSize){this.batchSize=this.configuredBatchSize * currentBatchSize;\n}return currentStatement;\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#getBatchStatement\n methodBody: PreparedStatement getBatchStatement(String sql, boolean callable);\nmethodSignature: org.hibernate.engine.jdbc.spi.JdbcCoordinator#close\n methodBody: Connection close();\nmethodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#addToBatch\n methodBody: void addToBatch();\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.BatchingBatch#addToBatch\n methodBody: public void addToBatch() {\ntrycurrentStatement.addBatch();\ncatch(SQLException e)abortBatch(e);\nLOG.debug(\"SQLException escaped proxy\",e);\nthrow sqlExceptionHelper().convert(e,\"could not perform addBatch\",currentStatementSql);\ncatch(RuntimeException e)abortBatch(e);\nthrow e;\nstatementPosition++;\nif(statementPosition >= getKey().getBatchedStatementCount()){batchPosition++;\nif(batchPosition == batchSize){notifyObserversImplicitExecution();\nperformExecution();\nbatchPosition=0;\nbatchExecuted=true;\n}statementPosition=0;\n}}\nmethodSignature: org.hibernate.action.internal.BulkOperationCleanupAction.CollectionCleanup#release\n methodBody: private void release() {\ncacheAccess.unlockRegion(cacheLock);\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#execute\n methodBody: public final void execute() {\nnotifyObserversExplicitExecution();\nif(getStatements().isEmpty()){return;\n}trydoExecuteBatch();\nfinallyreleaseStatements();\n}\nmethodSignature: org.hibernate.action.internal.BulkOperationCleanupAction.EntityCleanup#release\n methodBody: private void release() {\ncacheAccess.unlockRegion(cacheLock);\n}\nmethodSignature: org.hibernate.sql.results.jdbc.internal.DeferredResultSetAccess#release\n methodBody: public void release() {\nif(resultSet != null){getPersistenceContext().getJdbcCoordinator().getLogicalConnection().getResourceRegistry().release(resultSet,preparedStatement);\nresultSet=null;\n}if(preparedStatement != null){getPersistenceContext().getJdbcCoordinator().getLogicalConnection().getResourceRegistry().release(preparedStatement);\npreparedStatement=null;\n}}\nmethodSignature: org.hibernate.query.sqm.mutation.internal.temptable.RestrictedDeleteExecutionDelegate#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal EntityPersister entityDescriptor=sessionFactory.getRuntimeMetamodels().getMappingMetamodel().getEntityDescriptor(sqmDelete.getTarget().getEntityName());\nfinal String hierarchyRootTableName=((Joinable)entityDescriptor).getTableName();\nfinal TableGroup deletingTableGroup=converter.getMutatingTableGroup();\nfinal TableReference hierarchyRootTableReference=deletingTableGroup.resolveTableReference(deletingTableGroup.getNavigablePath(),hierarchyRootTableName);\nassert hierarchyRootTableReference != null;\nfinal Map<SqmParameter<?>,List<List<JdbcParameter>>> parameterResolutions;\nfinal Map<SqmParameter<?>,MappingModelExpressible<?>> paramTypeResolutions;\nif(domainParameterXref.getSqmParameterCount() == 0){parameterResolutions=Collections.emptyMap();\nparamTypeResolutions=Collections.emptyMap();\n}{parameterResolutions=new IdentityHashMap<>();\nparamTypeResolutions=new LinkedHashMap<>();\n}final MutableBoolean needsIdTableWrapper=new MutableBoolean(false);\nfinal Predicate specifiedRestriction=converter.visitWhereClause(sqmDelete.getWhereClause(),columnReference -> {\n  if (!hierarchyRootTableReference.getIdentificationVariable().equals(columnReference.getQualifier())) {\n    needsIdTableWrapper.setValue(true);\n  }\n}\n,(sqmParameter,mappingType,jdbcParameters) -> {\n  parameterResolutions.computeIfAbsent(sqmParameter,k -> new ArrayList<>(1)).add(jdbcParameters);\n  paramTypeResolutions.put(sqmParameter,mappingType);\n}\n);\nfinal PredicateCollector predicateCollector=new PredicateCollector(specifiedRestriction);\nentityDescriptor.applyBaseRestrictions((filterPredicate) -> {\n  needsIdTableWrapper.setValue(true);\n  predicateCollector.applyPredicate(filterPredicate);\n}\n,deletingTableGroup,true,executionContext.getSession().getLoadQueryInfluencers().getEnabledFilters(),null,converter);\nconverter.pruneTableGroupJoins();\nfinal boolean needsIdTable=needsIdTableWrapper.getValue() || entityDescriptor != entityDescriptor.getRootEntityDescriptor();\nfinal SqmJdbcExecutionContextAdapter executionContextAdapter=SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext);\nif(needsIdTable){return executeWithIdTable(predicateCollector.getPredicate(),deletingTableGroup,parameterResolutions,paramTypeResolutions,executionContextAdapter);\n}{return executeWithoutIdTable(predicateCollector.getPredicate(),deletingTableGroup,parameterResolutions,paramTypeResolutions,converter.getSqlExpressionResolver(),executionContextAdapter);\n}}\nmethodSignature: org.hibernate.orm.test.jpa.transaction.batch.JtaWithFailingBatchTest.TestBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn buildBatchTest(key,jdbcCoordinator,getJdbcBatchSize());\n}\nmethodSignature: org.hibernate.orm.test.jpa.transaction.batch.FailingAddToBatchTest.TestBatch#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\nPreparedStatement batchStatement=super.getBatchStatement(sql,callable);\ncreatedStatements.add(batchStatement);\nreturn batchStatement;\n}\nmethodSignature: org.hibernate.orm.test.jpa.transaction.batch.JtaWithStatementsBatchTest.TestBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn buildBatchTest(key,jdbcCoordinator,getJdbcBatchSize());\n}\nmethodSignature: org.hibernate.orm.test.manytomany.batchload.TestingBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn new TestingBatch(key,jdbcCoordinator);\n}\nmethodSignature: org.hibernate.persister.collection.AbstractCollectionPersister#getDialect\n methodBody: protected Dialect getDialect() {\nreturn dialect;\n}\nmethodSignature: org.hibernate.engine.jdbc.spi.JdbcCoordinator#getLogicalConnection\n methodBody: LogicalConnectionImplementor getLogicalConnection();\nmethodSignature: org.hibernate.query.sqm.mutation.internal.temptable.TableBasedInsertHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nif(log.isTraceEnabled()){log.tracef(\"Starting multi-table insert execution - %s\",getSqmInsertStatement().getTarget().getModel().getName());\n}final SqmJdbcExecutionContextAdapter executionContextAdapter=SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext);\nreturn resolveDelegate(executionContext).execute(executionContextAdapter);\n}\nmethodSignature: org.hibernate.orm.test.insertordering.InsertOrderingTest.StatsBatch#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\nif(batchSQL == null || !batchSQL.equals(sql)){currentBatch++;\nbatchSQL=sql;\nbatchSizes.add(currentBatch,new Counter());\n}return super.getBatchStatement(sql,callable);\n}\nmethodSignature: org.hibernate.engine.jdbc.spi.JdbcCoordinator#getResultSetReturn\n methodBody: ResultSetReturn getResultSetReturn();\nmethodSignature: org.hibernate.sql.ast.spi.AbstractSqlAstTranslator#getDialect\n methodBody: public Dialect getDialect() {\nreturn dialect;\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.BatchBuilderImpl#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn SharedBatchBuildingCode.buildBatch(jdbcBatchSize,key,jdbcCoordinator);\n}\nmethodSignature: org.hibernate.orm.test.jpa.transaction.batch.FailingAddToBatchTest.TestBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn buildBatchTest(key,jdbcCoordinator,getJdbcBatchSize());\n}\nmethodSignature: org.hibernate.orm.test.jpa.transaction.batch.FailingAddToBatchTest.TestBatch#addToBatch\n methodBody: public void addToBatch() {\nRuntimeException failure=nextAddToBatchFailure.getAndSet(null);\nif(failure != null){throw failure;\n}super.addToBatch();\n}\nmethodSignature: org.hibernate.dialect.Dialect#getDropTableString\n methodBody: public String getDropTableString(String tableName) {\nfinal StringBuilder buf=new StringBuilder(\"drop table \");\nif(supportsIfExistsBeforeTableName()){buf.append(\"if exists \");\n}buf.append(tableName).append(getCascadeConstraintsString());\nif(supportsIfExistsAfterTableName()){buf.append(\" if exists\");\n}return buf.toString();\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#getJdbcCoordinator\n methodBody: protected JdbcCoordinator getJdbcCoordinator(){\nreturn this.jdbcCoordinator;\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#sessionFactory\n methodBody: protected SessionFactoryImplementor sessionFactory() {\nreturn this.owner.getJdbcSessionContext().getSessionFactory();\n}\nmethodSignature: org.hibernate.dialect.AbstractHANADialect.CloseSuppressingReader#close\n methodBody: public void close() {\n}\nmethodSignature: org.hibernate.sql.ast.spi.AbstractSqlAstTranslator#getJdbcServices\n methodBody: protected JdbcServices getJdbcServices() {\nreturn getSessionFactory().getJdbcServices();\n}",
        "classSignatureBefore": "public class BatchingTest extends BaseCoreFunctionalTestCase implements BatchKey ",
        "methodNameBeforeSet": [
            "org.hibernate.orm.test.jdbc.internal.BatchingTest#testSessionBatchingUsage"
        ],
        "classNameBeforeSet": [
            "org.hibernate.orm.test.jdbc.internal.BatchingTest"
        ],
        "classSignatureBeforeSet": [
            "public class BatchingTest extends BaseCoreFunctionalTestCase implements BatchKey "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.orm.test.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.Statement;\n\nimport org.hibernate.Session;\nimport org.hibernate.Transaction;\nimport org.hibernate.engine.jdbc.batch.internal.BasicBatchKey;\nimport org.hibernate.engine.jdbc.batch.internal.BatchBuilderImpl;\nimport org.hibernate.engine.jdbc.batch.internal.BatchingBatch;\nimport org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch;\nimport org.hibernate.engine.jdbc.batch.spi.Batch;\nimport org.hibernate.engine.jdbc.batch.spi.BatchBuilder;\nimport org.hibernate.engine.jdbc.batch.spi.BatchKey;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.spi.SessionImplementor;\nimport org.hibernate.jdbc.Expectation;\nimport org.hibernate.jdbc.Expectations;\nimport org.hibernate.resource.jdbc.spi.LogicalConnectionImplementor;\n\nimport org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;\nimport org.hibernate.orm.test.common.JournalingBatchObserver;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertSame;\nimport static org.junit.Assert.assertTrue;\n\n/**\n * @author Steve Ebersole\n * @author Brett Meyer\n */\npublic class BatchingTest extends BaseCoreFunctionalTestCase implements BatchKey {\n\t@Override\n\tpublic int getBatchedStatementCount() {\n\t\treturn 1;\n\t}\n\n\t@Override\n\tpublic Expectation getExpectation() {\n\t\treturn Expectations.BASIC;\n\t}\n\n\t@Test\n\tpublic void testNonBatchingUsage() throws Exception {\n\t\tSession session = openSession();\n\t\tSessionImplementor sessionImpl = (SessionImplementor) session;\n\t\t\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n\n\t\t// set up some tables to use\n\t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n\t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n\t\ttry {\n\t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n\t\t}\n\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n        jdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n\n\t\t// ok, now we can get down to it...\n\t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n\t\ttxn.begin();\n\n\t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n\n\t\tfinal BatchBuilder batchBuilder = new BatchBuilderImpl( -1 );\n\t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\", Expectations.BASIC );\n\t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, jdbcCoordinator );\n\n\t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n\t\tinsertBatch.addObserver( batchObserver );\n\n\t\tassertTrue( \"unexpected Batch impl\", NonBatchingBatch.class.isInstance( insertBatch ) );\n\t\tPreparedStatement insert = insertBatch.getBatchStatement( insertSql, false );\n\t\tinsert.setLong( 1, 1 );\n\t\tinsert.setString( 2, \"name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.execute();\n\t\tassertEquals( 1, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.release();\n\n\t\ttxn.commit();\n\t\tsession.close();\n\t}\n\n\t@Test\n\tpublic void testBatchingUsage() throws Exception {\n\t\tSession session = openSession();\n\t\tSessionImplementor sessionImpl = (SessionImplementor) session;\n\t\t\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n\n\t\t// set up some tables to use\n\t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n\t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n\t\ttry {\n\t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n\t\t}\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n        jdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n\n\t\t// ok, now we can get down to it...\n\t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n\t\ttxn.begin();\n\n\t\tfinal BatchBuilder batchBuilder = new BatchBuilderImpl( 2 );\n\t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\", Expectations.BASIC );\n\t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, jdbcCoordinator );\n\t\tassertTrue( \"unexpected Batch impl\", BatchingBatch.class.isInstance( insertBatch ) );\n\n\t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n\t\tinsertBatch.addObserver( batchObserver );\n\n\t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n\n\t\tPreparedStatement insert = insertBatch.getBatchStatement( insertSql, false );\n\t\tinsert.setLong( 1, 1 );\n\t\tinsert.setString( 2, \"name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tPreparedStatement insert2 = insertBatch.getBatchStatement( insertSql, false );\n\t\tassertSame( insert, insert2 );\n\t\tinsert = insert2;\n\t\tinsert.setLong( 1, 2 );\n\t\tinsert.setString( 2, \"another name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.execute();\n\t\tassertEquals( 1, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.release();\n\n\t\ttxn.commit();\n\t\tsession.close();\n\t}\n\n\t@Test\n\tpublic void testSessionBatchingUsage() throws Exception {\n\t\tSession session = openSession();\n\t\tsession.setJdbcBatchSize( 3 );\n\t\tSessionImplementor sessionImpl = (SessionImplementor) session;\n\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n\n\t\t// set up some tables to use\n\t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n\t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n\t\ttry {\n\t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n\t\t}\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n        jdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n\n\t\t// ok, now we can get down to it...\n\t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n\t\ttxn.begin();\n\n\t\tfinal BatchBuilder batchBuilder = new BatchBuilderImpl( 2 );\n\t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\", Expectations.BASIC );\n\t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, jdbcCoordinator );\n\t\tassertTrue( \"unexpected Batch impl\", BatchingBatch.class.isInstance( insertBatch ) );\n\n\t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n\t\tinsertBatch.addObserver( batchObserver );\n\n\t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n\n\t\tPreparedStatement insert = insertBatch.getBatchStatement( insertSql, false );\n\t\tinsert.setLong( 1, 1 );\n\t\tinsert.setString( 2, \"name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tPreparedStatement insert2 = insertBatch.getBatchStatement( insertSql, false );\n\t\tassertSame( insert, insert2 );\n\t\tinsert = insert2;\n\t\tinsert.setLong( 1, 2 );\n\t\tinsert.setString( 2, \"another name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tPreparedStatement insert3 = insertBatch.getBatchStatement( insertSql, false );\n\t\tassertSame( insert, insert3 );\n\t\tinsert = insert3;\n\t\tinsert.setLong( 1, 3 );\n\t\tinsert.setString( 2, \"yet another name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.execute();\n\t\tassertEquals( 1, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.release();\n\n\t\ttxn.commit();\n\t\tsession.close();\n\t}\n\n\t@Override\n\tprotected void cleanupTest() throws Exception {\n\t\ttry (Session session = openSession()) {\n\t\t\tsession.doWork( connection -> {\n\t\t\t\tfinal Statement stmnt = connection.createStatement();\n\n\t\t\t\tstmnt.execute( sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" ) );\n\t\t\t} );\n\t\t}\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/test/java/org/hibernate/orm/test/jdbc/internal/BatchingTest.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.orm.test.jdbc.internal;\n\nimport java.sql.Statement;\n\nimport org.hibernate.Session;\nimport org.hibernate.Transaction;\nimport org.hibernate.engine.jdbc.batch.internal.BasicBatchKey;\nimport org.hibernate.engine.jdbc.batch.internal.BatchBuilderImpl;\nimport org.hibernate.engine.jdbc.batch.spi.Batch;\nimport org.hibernate.engine.jdbc.batch.spi.BatchKey;\nimport org.hibernate.engine.jdbc.mutation.ParameterUsage;\nimport org.hibernate.engine.jdbc.mutation.internal.JdbcValueBindingsImpl;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.spi.SessionImplementor;\nimport org.hibernate.jdbc.Expectation;\nimport org.hibernate.jdbc.Expectations;\nimport org.hibernate.metamodel.mapping.JdbcMapping;\nimport org.hibernate.orm.test.common.JournalingBatchObserver;\nimport org.hibernate.resource.jdbc.spi.LogicalConnectionImplementor;\nimport org.hibernate.sql.model.MutationType;\nimport org.hibernate.sql.model.TableMapping;\nimport org.hibernate.sql.model.jdbc.JdbcValueDescriptor;\nimport org.hibernate.type.StandardBasicTypes;\n\nimport org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;\nimport org.junit.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.hibernate.jdbc.Expectations.NONE;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n\n/**\n * @author Steve Ebersole\n * @author Brett Meyer\n */\npublic class BatchingTest extends BaseCoreFunctionalTestCase implements BatchKey {\n\tprivate final String SANDBOX_TBL = \"SANDBOX_JDBC_TST\";\n\tprivate final TableMapping SANDBOX_TBL_MAPPING = new TableMapping() {\n\t\t@Override\n\t\tpublic String getTableName() {\n\t\t\treturn SANDBOX_TBL;\n\t\t}\n\n\t\t@Override\n\t\tpublic int getRelativePosition() {\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isOptional() {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isInverse() {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isIdentifierTable() {\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic MutationDetails getInsertDetails() {\n\t\t\treturn new MutationDetails( MutationType.INSERT, NONE, null, false );\n\t\t}\n\n\t\t@Override\n\t\tpublic MutationDetails getUpdateDetails() {\n\t\t\treturn new MutationDetails( MutationType.UPDATE, NONE, null, false );\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isCascadeDeleteEnabled() {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic MutationDetails getDeleteDetails() {\n\t\t\treturn new MutationDetails( MutationType.DELETE, NONE, null, false );\n\t\t}\n\t};\n\n\t@Override\n\tpublic int getBatchedStatementCount() {\n\t\treturn 1;\n\t}\n\n\t@Override\n\tpublic Expectation getExpectation() {\n\t\treturn Expectations.BASIC;\n\t}\n\n\t@Test\n\tpublic void testBatchingUsage() throws Exception {\n\t\tfinal Session session = openSession();\n\t\tfinal SessionImplementor sessionImpl = (SessionImplementor) session;\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\n\t\texportSandboxSchema( sessionImpl );\n\n\t\t// ok, now we can get down to it...\n\t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n\t\ttxn.begin();\n\n\t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n\n\t\tfinal BatchBuilderImpl batchBuilder = new BatchBuilderImpl( 2 );\n\t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\" );\n\t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, null, SANDBOX_TBL, sessionImpl, insertSql );\n\t\tassertThat( insertBatch ).isNotNull();\n\n\t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n\t\tinsertBatch.addObserver( batchObserver );\n\n\t\tfinal JdbcValueBindingsImpl jdbcValueBindings = sandboxInsertValueBindings( sessionImpl );\n\n\t\t// bind values for #1 - should do nothing at the JDBC level\n\t\tjdbcValueBindings.bindValue( 1, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n\t\tjdbcValueBindings.bindValue( \"name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isFalse();\n\n\t\t// add #1 to the batch - will acquire prepared statement to bind values\n\t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n        assertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\t// bind values for #2 - again, nothing at JDBC level (we have statement from earlier)\n\t\tjdbcValueBindings.bindValue( 2, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n\t\tjdbcValueBindings.bindValue( \"another name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\n\t\t// add #2 to the batch -\n\t\t// \t\t- uses the previous prepared statement to bind values\n\t\t//\t\t- batch size has been exceeded, trigger an implicit execution\n\t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 1 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\t// execute the batch - effectively only increments the explicit-execution counter\n\t\tinsertBatch.execute();\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 1 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 1 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isFalse();\n\n\t\tinsertBatch.release();\n\n\t\ttxn.commit();\n\t\tsession.close();\n\t}\n\n\tprivate JdbcValueBindingsImpl sandboxInsertValueBindings(SessionImplementor session) {\n\t\treturn new JdbcValueBindingsImpl(\n\t\t\t\tMutationType.INSERT,\n\t\t\t\tnull,\n\t\t\t\t(tableName, columnName, usage) -> {\n\t\t\t\t\tassert tableName.equals( SANDBOX_TBL );\n\n\t\t\t\t\tif ( columnName.equals( \"ID\" ) ) {\n\t\t\t\t\t\treturn new JdbcValueDescriptor() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic String getColumnName() {\n\t\t\t\t\t\t\t\treturn \"ID\";\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic ParameterUsage getUsage() {\n\t\t\t\t\t\t\t\treturn ParameterUsage.SET;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic int getJdbcPosition() {\n\t\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic JdbcMapping getJdbcMapping() {\n\t\t\t\t\t\t\t\treturn session.getTypeConfiguration()\n\t\t\t\t\t\t\t\t\t\t.getBasicTypeRegistry()\n\t\t\t\t\t\t\t\t\t\t.resolve( StandardBasicTypes.INTEGER );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( columnName.equals( \"NAME\" ) ) {\n\t\t\t\t\t\treturn new JdbcValueDescriptor() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic String getColumnName() {\n\t\t\t\t\t\t\t\treturn \"NAME\";\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic ParameterUsage getUsage() {\n\t\t\t\t\t\t\t\treturn ParameterUsage.SET;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic int getJdbcPosition() {\n\t\t\t\t\t\t\t\treturn 2;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic JdbcMapping getJdbcMapping() {\n\t\t\t\t\t\t\t\treturn session.getTypeConfiguration()\n\t\t\t\t\t\t\t\t\t\t.getBasicTypeRegistry()\n\t\t\t\t\t\t\t\t\t\t.resolve( StandardBasicTypes.STRING );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new IllegalArgumentException( \"Unknown column : \" + columnName );\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@Test\n\tpublic void testSessionBatchingUsage() throws Exception {\n\t\tSession session = openSession();\n\t\tsession.setJdbcBatchSize( 3 );\n\t\tSessionImplementor sessionImpl = (SessionImplementor) session;\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\n\t\texportSandboxSchema( sessionImpl );\n\n\t\t// ok, now we can get down to it...\n\t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n\t\ttxn.begin();\n\n\n\t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n\n\t\tfinal BatchBuilderImpl batchBuilder = new BatchBuilderImpl( 2 );\n\t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\" );\n\t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, 3, SANDBOX_TBL, sessionImpl, insertSql );\n\t\tassertThat( insertBatch ).isNotNull();\n\n\t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n\t\tinsertBatch.addObserver( batchObserver );\n\n\t\tfinal JdbcValueBindingsImpl jdbcValueBindings = sandboxInsertValueBindings( sessionImpl );\n\n\t\t// bind values for #1 - this does nothing at the JDBC level\n\t\tjdbcValueBindings.bindValue( 1, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n\t\tjdbcValueBindings.bindValue( \"name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isFalse();\n\n\t\t// add the values to the batch - this creates the prepared statement and binds the values\n\t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\t// bind values for #2 - this does nothing at the JDBC level : we do still have the statement defining the batch\n\t\tjdbcValueBindings.bindValue( 2, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n\t\tjdbcValueBindings.bindValue( \"another name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\t// add #2 to batch - we have not exceeded batch size, so we should not get an implicit execution\n\t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\t// bind values for #3 - this does nothing at the JDBC level : we do still have the statement defining the batch\n\t\tjdbcValueBindings.bindValue( 3, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n\t\tjdbcValueBindings.bindValue( \"yet another name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 1 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\tinsertBatch.execute();\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 1 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 1 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isFalse();\n\n\t\tinsertBatch.release();\n\n\t\ttxn.commit();\n\t\tsession.close();\n\t}\n\n\tprivate void exportSandboxSchema(SessionImplementor sessionImpl) {\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n\n\t\t// set up some tables to use\n\t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n\t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n\t\ttry {\n\t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n\t\t}\n\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n\t\tassertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n\t\tassertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n\t}\n\n\t@Override\n\tprotected void cleanupTest() throws Exception {\n\t\ttry (Session session = openSession()) {\n\t\t\tsession.doWork( connection -> {\n\t\t\t\tfinal Statement stmnt = connection.createStatement();\n\n\t\t\t\tstmnt.execute( sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" ) );\n\t\t\t} );\n\t\t}\n\t}\n\n}\n",
        "diffSourceCodeSet": [
            "private void exportSandboxSchema(SessionImplementor sessionImpl) {\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n\n\t\t// set up some tables to use\n\t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n\t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n\t\ttry {\n\t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n\t\t}\n\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n\t\tassertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n\t\tassertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.action.internal.BulkOperationCleanupAction.NaturalIdCleanup#release\n methodBody: private void release() {\nnaturalIdCacheAccessStrategy.unlockRegion(cacheLock);\n}",
            "methodSignature: org.hibernate.orm.test.insertordering.InsertOrderingTest.StatsBatch#addToBatch\n methodBody: public void addToBatch() {\nCounter counter=(Counter)batchSizes.get(currentBatch);\ncounter.count++;\nsuper.addToBatch();\n}",
            "methodSignature: org.hibernate.engine.jdbc.spi.JdbcCoordinator#getStatementPreparer\n methodBody: StatementPreparer getStatementPreparer();",
            "methodSignature: org.hibernate.engine.jdbc.spi.JdbcServices#getDialect\n methodBody: Dialect getDialect();",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\nif(sql == null){throw new IllegalArgumentException(\"sql must be non-null.\");\n}PreparedStatement statement=statements.get(sql);\nif(statement == null){statement=buildBatchStatement(sql,callable);\nstatements.put(sql,statement);\n}{LOG.debug(\"Reusing batch statement\");\nsqlStatementLogger().logStatement(sql);\n}return statement;\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#execute\n methodBody: void execute();",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.SharedBatchBuildingCode#buildBatch\n methodBody: static Batch buildBatch(final int defaultJdbcBatchSize, final BatchKey key, final JdbcCoordinator jdbcCoordinator) {\nfinal Integer sessionJdbcBatchSize=jdbcCoordinator.getJdbcSessionOwner().getJdbcBatchSize();\nfinal int jdbcBatchSizeToUse=sessionJdbcBatchSize == null ? defaultJdbcBatchSize : sessionJdbcBatchSize;\nreturn jdbcBatchSizeToUse > 1 ? new BatchingBatch(key,jdbcCoordinator,jdbcBatchSizeToUse) : new NonBatchingBatch(key,jdbcCoordinator);\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#getLogicalConnection\n methodBody: public LogicalConnectionImplementor getLogicalConnection() {\nreturn logicalConnection;\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#close\n methodBody: protected void close(ResultSet resultSet) {\nLOG.tracev(\"Closing result set [{0}]\",resultSet);\nif(resultSet instanceof InvalidatableWrapper){@SuppressWarnings(\"unchecked\") final InvalidatableWrapper<ResultSet> wrapper=(InvalidatableWrapper<ResultSet>)resultSet;\nclose(wrapper.getWrappedObject());\nwrapper.invalidate();\nreturn;\n}tryresultSet.close();\ncatch(Exception e)LOG.debugf(\"Unable to release JDBC result set [%s]\",e.getMessage());\n}",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.inline.InlineUpdateHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal List<Object> ids=MatchingIdSelectionHelper.selectMatchingIds(sqmUpdate,domainParameterXref,executionContext);\nif(ids == null || ids.isEmpty()){return 0;\n}domainParameterXref.clearExpansions();\nfinal MappingMetamodel domainModel=sessionFactory.getRuntimeMetamodels().getMappingMetamodel();\nfinal String mutatingEntityName=sqmUpdate.getTarget().getModel().getHibernateEntityName();\nfinal EntityPersister entityDescriptor=domainModel.getEntityDescriptor(mutatingEntityName);\nfinal String rootEntityName=entityDescriptor.getEntityPersister().getRootEntityName();\nfinal EntityPersister rootEntityDescriptor=domainModel.getEntityDescriptor(rootEntityName);\nfinal String hierarchyRootTableName=((Joinable)rootEntityDescriptor).getTableName();\nfinal List<Expression> inListExpressions=new ArrayList<>(ids.size());\nfinal EntityIdentifierMapping identifierMapping=entityDescriptor.getIdentifierMapping();\nif(identifierMapping instanceof BasicValuedModelPart){final BasicValuedModelPart basicValuedModelPart=(BasicValuedModelPart)identifierMapping;\nfor(int i=0; i < ids.size(); i++){inListExpressions.add(new QueryLiteral<>(ids.get(i),basicValuedModelPart));\n}}{final int jdbcTypeCount=identifierMapping.getJdbcTypeCount();\nfor(int i=0; i < ids.size(); i++){final Object[] id=(Object[])ids.get(i);\nfinal List<Expression> tupleElements=new ArrayList<>(jdbcTypeCount);\ninListExpressions.add(new SqlTuple(tupleElements,identifierMapping));\nidentifierMapping.forEachJdbcType((index,jdbcMapping) -> {\n  tupleElements.add(new QueryLiteral<>(id[index],(BasicValuedMapping)jdbcMapping));\n}\n);\n}}final MultiTableSqmMutationConverter converterDelegate=new MultiTableSqmMutationConverter(entityDescriptor,sqmUpdate,sqmUpdate.getTarget(),domainParameterXref,executionContext.getQueryOptions(),executionContext.getSession().getLoadQueryInfluencers(),executionContext.getQueryParameterBindings(),sessionFactory);\nfinal TableGroup updatingTableGroup=converterDelegate.getMutatingTableGroup();\nfinal TableReference hierarchyRootTableReference=updatingTableGroup.resolveTableReference(updatingTableGroup.getNavigablePath(),hierarchyRootTableName);\nassert hierarchyRootTableReference != null;\nfinal Map<SqmParameter<?>,List<List<JdbcParameter>>> parameterResolutions;\nif(domainParameterXref.getSqmParameterCount() == 0){parameterResolutions=Collections.emptyMap();\n}{parameterResolutions=new IdentityHashMap<>();\n}final List<Assignment> assignments=new ArrayList<>();\nfinal Map<SqmParameter<?>,MappingModelExpressible<?>> paramTypeResolutions=new LinkedHashMap<>();\nconverterDelegate.visitSetClause(sqmUpdate.getSetClause(),assignments::add,(sqmParameter,mappingType,jdbcParameters) -> {\n  parameterResolutions.computeIfAbsent(sqmParameter,k -> new ArrayList<>(1)).add(jdbcParameters);\n  paramTypeResolutions.put(sqmParameter,mappingType);\n}\n);\nconverterDelegate.addVersionedAssignment(assignments::add,sqmUpdate);\nfinal Predicate providedPredicate;\nfinal SqmWhereClause whereClause=sqmUpdate.getWhereClause();\nif(whereClause == null || whereClause.getPredicate() == null){providedPredicate=null;\n}{providedPredicate=converterDelegate.visitWhereClause(whereClause,columnReference -> {\n}\n,(sqmParameter,mappingType,jdbcParameters) -> {\n  parameterResolutions.computeIfAbsent(sqmParameter,k -> new ArrayList<>(1)).add(jdbcParameters);\n  paramTypeResolutions.put(sqmParameter,mappingType);\n}\n);\nassert providedPredicate != null;\n}final PredicateCollector predicateCollector=new PredicateCollector(providedPredicate);\nentityDescriptor.applyBaseRestrictions(predicateCollector::applyPredicate,updatingTableGroup,true,executionContext.getSession().getLoadQueryInfluencers().getEnabledFilters(),null,converterDelegate);\nconverterDelegate.pruneTableGroupJoins();\nfinal Map<String,TableReference> tableReferenceByAlias=CollectionHelper.mapOfSize(updatingTableGroup.getTableReferenceJoins().size() + 1);\ncollectTableReference(updatingTableGroup.getPrimaryTableReference(),tableReferenceByAlias::put);\nfor(int i=0; i < updatingTableGroup.getTableReferenceJoins().size(); i++){collectTableReference(updatingTableGroup.getTableReferenceJoins().get(i),tableReferenceByAlias::put);\n}final JdbcParameterBindings jdbcParameterBindings=SqmUtil.createJdbcParameterBindings(executionContext.getQueryParameterBindings(),domainParameterXref,SqmUtil.generateJdbcParamsXref(domainParameterXref,() -> parameterResolutions),sessionFactory.getRuntimeMetamodels().getMappingMetamodel(),navigablePath -> updatingTableGroup,new SqmParameterMappingModelResolutionAccess(){\n  @Override @SuppressWarnings(\"unchecked\") public <T>MappingModelExpressible<T> getResolvedMappingModelType(  SqmParameter<T> parameter){\n    return (MappingModelExpressible<T>)paramTypeResolutions.get(parameter);\n  }\n}\n,executionContext.getSession());\nfinal Map<TableReference,List<Assignment>> assignmentsByTable=new HashMap<>();\nfor(int i=0; i < assignments.size(); i++){final Assignment assignment=assignments.get(i);\nfinal List<ColumnReference> assignmentColumnRefs=assignment.getAssignable().getColumnReferences();\nTableReference assignmentTableReference=null;\nfor(int c=0; c < assignmentColumnRefs.size(); c++){final ColumnReference columnReference=assignmentColumnRefs.get(c);\nfinal TableReference tableReference=resolveTableReference(columnReference,tableReferenceByAlias);\nif(assignmentTableReference != null && assignmentTableReference != tableReference){throw new SemanticException(\"Assignment referred to columns from multiple tables: \" + assignment.getAssignable());\n}assignmentTableReference=tableReference;\n}List<Assignment> assignmentsForTable=assignmentsByTable.get(assignmentTableReference);\nif(assignmentsForTable == null){assignmentsForTable=new ArrayList<>();\nassignmentsByTable.put(assignmentTableReference,assignmentsForTable);\n}assignmentsForTable.add(assignment);\n}final int rows=ids.size();\nfinal SqmJdbcExecutionContextAdapter executionContextAdapter=SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext);\nentityDescriptor.visitConstraintOrderedTables((tableExpression,tableKeyColumnVisitationSupplier) -> updateTable(tableExpression,tableKeyColumnVisitationSupplier,entityDescriptor,updatingTableGroup,assignmentsByTable,inListExpressions,rows,jdbcParameterBindings,executionContextAdapter));\nreturn rows;\n}",
            "methodSignature: org.hibernate.dialect.AbstractHANADialect.CloseSuppressingInputStream#close\n methodBody: public void close() {\n}",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.inline.InlineDeleteHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal List<Object> idsAndFks=MatchingIdSelectionHelper.selectMatchingIds(sqmDeleteStatement,domainParameterXref,executionContext);\nif(idsAndFks == null || idsAndFks.isEmpty()){return 0;\n}final SessionFactoryImplementor factory=executionContext.getSession().getFactory();\nfinal String mutatingEntityName=sqmDeleteStatement.getTarget().getModel().getHibernateEntityName();\nfinal EntityMappingType entityDescriptor=factory.getRuntimeMetamodels().getEntityMappingType(mutatingEntityName);\nfinal JdbcParameterBindings jdbcParameterBindings=new JdbcParameterBindingsImpl(domainParameterXref.getQueryParameterCount());\nfinal MutableInteger valueIndexCounter=new MutableInteger();\nSqmMutationStrategyHelper.visitCollectionTables(entityDescriptor,pluralAttribute -> {\n  if (pluralAttribute.getSeparateCollectionTable() != null) {\n    final ModelPart fkTargetPart=pluralAttribute.getKeyDescriptor().getTargetPart();\n    final int valueIndex;\n    if (fkTargetPart instanceof EntityIdentifierMapping) {\n      valueIndex=0;\n    }\n else {\n      if (valueIndexCounter.get() == 0) {\n        valueIndexCounter.set(entityDescriptor.getIdentifierMapping().getJdbcTypeCount());\n      }\n      valueIndex=valueIndexCounter.get();\n      valueIndexCounter.plus(fkTargetPart.getJdbcTypeCount());\n    }\n    executeDelete(pluralAttribute.getSeparateCollectionTable(),entityDescriptor,() -> fkTargetPart::forEachSelectable,idsAndFks,valueIndex,fkTargetPart,jdbcParameterBindings,executionContext);\n  }\n}\n);\nentityDescriptor.visitConstraintOrderedTables((tableExpression,tableKeyColumnsVisitationSupplier) -> {\n  executeDelete(tableExpression,entityDescriptor,tableKeyColumnsVisitationSupplier,idsAndFks,0,null,jdbcParameterBindings,executionContext);\n}\n);\nreturn idsAndFks.size();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#hasRegisteredResources\n methodBody: private boolean hasRegisteredResources() {\nreturn getLogicalConnection().getResourceRegistry().hasRegisteredResources();\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#release\n methodBody: void release();",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.UnmodifiableBatchBuilderImpl#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn SharedBatchBuildingCode.buildBatch(jdbcBatchSize,key,jdbcCoordinator);\n}",
            "methodSignature: org.hibernate.persister.entity.AbstractEntityPersister#isInstance\n methodBody: public boolean isInstance(Object object) {\nreturn getRepresentationStrategy().getInstantiator().isInstance(object,getFactory());\n}",
            "methodSignature: org.hibernate.orm.test.jpa.transaction.batch.JtaWithFailingBatchTest.TestBatch#addToBatch\n methodBody: public void addToBatch() {\nthrow sqlExceptionHelper().convert(new SQLException(\"fake SQLException\"),\"could not perform addBatch\",currentStatementSql);\n}",
            "methodSignature: org.hibernate.action.internal.BulkOperationCleanupAction#execute\n methodBody: public void execute() throws HibernateException {\n}",
            "methodSignature: org.hibernate.orm.test.jpa.transaction.batch.JtaWithFailingBatchTest.TestBatch#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\ncurrentStatementSql=sql;\nPreparedStatement batchStatement=super.getBatchStatement(sql,callable);\ncreatedStatements.add(batchStatement);\nreturn batchStatement;\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.spi.BatchBuilder#buildBatch\n methodBody: Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator);",
            "methodSignature: org.hibernate.procedure.internal.ProcedureCallImpl#execute\n methodBody: public boolean execute() {\ntryreturn outputs().getCurrent() instanceof ResultSetOutput;\ncatch(NoMoreOutputsException e)return false;\ncatch(HibernateException he)throw getSession().getExceptionConverter().convert(he);\ncatch(RuntimeException e)getSession().markForRollbackOnly();\nthrow e;\n}",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.cte.CteInsertHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal SqmInsertStatement<?> sqmInsertStatement=getSqmStatement();\nfinal SessionFactoryImplementor factory=executionContext.getSession().getFactory();\nfinal EntityPersister entityDescriptor=getEntityDescriptor().getEntityPersister();\nfinal String explicitDmlTargetAlias;\nif(sqmInsertStatement.getTarget().getExplicitAlias() == null){explicitDmlTargetAlias=\"dml_target\";\n}{explicitDmlTargetAlias=sqmInsertStatement.getTarget().getExplicitAlias();\n}final MultiTableSqmMutationConverter sqmConverter=new MultiTableSqmMutationConverter(entityDescriptor,sqmInsertStatement,sqmInsertStatement.getTarget(),explicitDmlTargetAlias,domainParameterXref,executionContext.getQueryOptions(),executionContext.getSession().getLoadQueryInfluencers(),executionContext.getQueryParameterBindings(),factory);\nfinal TableGroup insertingTableGroup=sqmConverter.getMutatingTableGroup();\nfinal Map<SqmParameter<?>,List<List<JdbcParameter>>> parameterResolutions;\nif(domainParameterXref.getSqmParameterCount() == 0){parameterResolutions=Collections.emptyMap();\n}{parameterResolutions=new IdentityHashMap<>();\n}final int size=sqmStatement.getInsertionTargetPaths().size();\nfinal List<Map.Entry<List<CteColumn>,Assignment>> targetPathColumns=new ArrayList<>(size);\nfinal List<CteColumn> targetPathCteColumns=new ArrayList<>(size);\nfinal Map<SqmParameter<?>,MappingModelExpressible<?>> paramTypeResolutions=new LinkedHashMap<>();\nfinal NamedTableReference entityTableReference=new NamedTableReference(cteTable.getTableExpression(),TemporaryTable.DEFAULT_ALIAS,true,sessionFactory);\nfinal InsertStatement insertStatement=new InsertStatement(entityTableReference);\nfinal BaseSqmToSqlAstConverter.AdditionalInsertValues additionalInsertValues=sqmConverter.visitInsertionTargetPaths((assignable,columnReferences) -> {\n  final SqmPathInterpretation<?> pathInterpretation=(SqmPathInterpretation<?>)assignable;\n  final int offset=CteTable.determineModelPartStartIndex(entityDescriptor,pathInterpretation.getExpressionType());\n  if (offset == -1) {\n    throw new IllegalStateException(\"Couldn't find matching cte column for: \" + ((Expression)assignable).getExpressionType());\n  }\n  final int end=offset + pathInterpretation.getExpressionType().getJdbcTypeCount();\n  final List<CteColumn> columns=cteTable.getCteColumns().subList(offset,end);\n  insertStatement.addTargetColumnReferences(columnReferences);\n  targetPathCteColumns.addAll(columns);\n  targetPathColumns.add(new AbstractMap.SimpleEntry<>(columns,new Assignment(assignable,(Expression)assignable)));\n}\n,sqmInsertStatement,entityDescriptor,insertingTableGroup,(sqmParameter,mappingType,jdbcParameters) -> {\n  parameterResolutions.computeIfAbsent(sqmParameter,k -> new ArrayList<>(1)).add(jdbcParameters);\n  paramTypeResolutions.put(sqmParameter,mappingType);\n}\n);\nfinal boolean assignsId=targetPathCteColumns.contains(cteTable.getCteColumns().get(0));\nfinal Stack<SqlAstProcessingState> processingStateStack=sqmConverter.getProcessingStateStack();\nfinal SqlAstProcessingState oldState=processingStateStack.pop();\nfinal Statement queryStatement;\nif(sqmInsertStatement instanceof SqmInsertSelectStatement){final QueryPart queryPart=sqmConverter.visitQueryPart(((SqmInsertSelectStatement<?>)sqmInsertStatement).getSelectQueryPart());\nqueryPart.visitQuerySpecs(querySpec -> {\n  if (additionalInsertValues.applySelections(querySpec,sessionFactory)) {\n    final CteColumn rowNumberColumn=cteTable.getCteColumns().get(cteTable.getCteColumns().size() - 1);\n    final ColumnReference columnReference=new ColumnReference((String)null,rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping());\n    insertStatement.getTargetColumnReferences().set(insertStatement.getTargetColumnReferences().size() - 1,columnReference);\n    targetPathCteColumns.set(targetPathCteColumns.size() - 1,rowNumberColumn);\n  }\n  if (!assignsId && entityDescriptor.getIdentifierGenerator() instanceof PostInsertIdentifierGenerator) {\n    querySpec.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,SqmInsertStrategyHelper.createRowNumberingExpression(querySpec,sessionFactory)));\n  }\n}\n);\nqueryStatement=new SelectStatement(queryPart);\n}{final List<SqmValues> sqmValuesList=((SqmInsertValuesStatement<?>)sqmInsertStatement).getValuesList();\nfinal List<Values> valuesList=new ArrayList<>(sqmValuesList.size());\nfor(SqmValues sqmValues: sqmValuesList){final Values values=sqmConverter.visitValues(sqmValues);\nadditionalInsertValues.applyValues(values);\nvaluesList.add(values);\n}final QuerySpec querySpec=new QuerySpec(true);\nfinal NavigablePath navigablePath=new NavigablePath(entityDescriptor.getRootPathName());\nfinal List<String> columnNames=new ArrayList<>(targetPathColumns.size());\nfinal String valuesAlias=insertingTableGroup.getPrimaryTableReference().getIdentificationVariable();\nfor(Map.Entry<List<CteColumn>,Assignment> entry: targetPathColumns){for(ColumnReference columnReference: entry.getValue().getAssignable().getColumnReferences()){columnNames.add(columnReference.getColumnExpression());\nquerySpec.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,columnReference.getQualifier().equals(valuesAlias) ? columnReference : new ColumnReference(valuesAlias,columnReference.getColumnExpression(),false,null,null,columnReference.getJdbcMapping())));\n}}final ValuesTableGroup valuesTableGroup=new ValuesTableGroup(navigablePath,entityDescriptor.getEntityPersister(),valuesList,insertingTableGroup.getPrimaryTableReference().getIdentificationVariable(),columnNames,true,factory);\nquerySpec.getFromClause().addRoot(valuesTableGroup);\nqueryStatement=new SelectStatement(querySpec);\n}processingStateStack.push(oldState);\nsqmConverter.pruneTableGroupJoins();\nif(!assignsId && entityDescriptor.getIdentifierGenerator() instanceof PostInsertIdentifierGenerator){final CteColumn rowNumberColumn=cteTable.getCteColumns().get(cteTable.getCteColumns().size() - 1);\nfinal ColumnReference columnReference=new ColumnReference((String)null,rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping());\ninsertStatement.getTargetColumnReferences().add(columnReference);\ntargetPathCteColumns.add(rowNumberColumn);\n}final CteTable entityCteTable=createCteTable(getCteTable(),targetPathCteColumns,factory);\nfinal QuerySpec querySpec=new QuerySpec(true,1);\nfinal List<DomainResult<?>> domainResults=new ArrayList<>(1);\nfinal SelectStatement statement=new SelectStatement(querySpec,domainResults);\nfinal CteStatement entityCte;\nif(additionalInsertValues.requiresRowNumberIntermediate()){final CteTable fullEntityCteTable=getCteTable();\nfinal String baseTableName=\"base_\" + entityCteTable.getTableExpression();\nfinal CteStatement baseEntityCte=new CteStatement(entityCteTable.withName(baseTableName),queryStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(baseEntityCte);\nfinal CteColumn rowNumberColumn=fullEntityCteTable.getCteColumns().get(fullEntityCteTable.getCteColumns().size() - 1);\nfinal ColumnReference rowNumberColumnReference=new ColumnReference(\"e\",rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping());\nfinal CteColumn idColumn=fullEntityCteTable.getCteColumns().get(0);\nfinal BasicValuedMapping idType=(BasicValuedMapping)idColumn.getJdbcMapping();\nfinal Optimizer optimizer=((OptimizableGenerator)entityDescriptor.getIdentifierGenerator()).getOptimizer();\nfinal BasicValuedMapping integerType=(BasicValuedMapping)rowNumberColumn.getJdbcMapping();\nfinal Expression rowNumberMinusOneModuloIncrement=new BinaryArithmeticExpression(new BinaryArithmeticExpression(rowNumberColumnReference,BinaryArithmeticOperator.SUBTRACT,new QueryLiteral<>(1,(BasicValuedMapping)rowNumberColumn.getJdbcMapping()),integerType),BinaryArithmeticOperator.MODULO,new QueryLiteral<>(optimizer.getIncrementSize(),integerType),integerType);\n{final QuerySpec rowsWithSequenceQuery=new QuerySpec(true);\nrowsWithSequenceQuery.getFromClause().addRoot(new CteTableGroup(new NamedTableReference(baseTableName,\"e\",false,factory)));\nrowsWithSequenceQuery.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,rowNumberColumnReference));\nfinal String fragment=((BulkInsertionCapableIdentifierGenerator)entityDescriptor.getIdentifierGenerator()).determineBulkInsertionIdentifierGenerationSelectFragment(sessionFactory.getSqlStringGenerationContext());\nrowsWithSequenceQuery.getSelectClause().addSqlSelection(new SqlSelectionImpl(2,1,new SelfRenderingSqlFragmentExpression(fragment)));\nrowsWithSequenceQuery.applyPredicate(new ComparisonPredicate(rowNumberMinusOneModuloIncrement,ComparisonOperator.EQUAL,new QueryLiteral<>(0,integerType)));\nfinal CteTable rowsWithSequenceCteTable=new CteTable(ROW_NUMBERS_WITH_SEQUENCE_VALUE,List.of(rowNumberColumn,idColumn));\nfinal SelectStatement rowsWithSequenceStatement=new SelectStatement(rowsWithSequenceQuery);\nfinal CteStatement rowsWithSequenceCte=new CteStatement(rowsWithSequenceCteTable,rowsWithSequenceStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(rowsWithSequenceCte);\n}{final QuerySpec entityQuery=new QuerySpec(true);\nfinal NavigablePath navigablePath=new NavigablePath(baseTableName);\nfinal TableGroup baseTableGroup=new TableGroupImpl(navigablePath,null,new NamedTableReference(baseTableName,\"e\",false,factory),null);\nfinal TableGroup rowsWithSequenceTableGroup=new CteTableGroup(new NamedTableReference(ROW_NUMBERS_WITH_SEQUENCE_VALUE,\"t\",false,factory));\nbaseTableGroup.addTableGroupJoin(new TableGroupJoin(rowsWithSequenceTableGroup.getNavigablePath(),SqlAstJoinType.LEFT,rowsWithSequenceTableGroup,new ComparisonPredicate(new BinaryArithmeticExpression(rowNumberColumnReference,BinaryArithmeticOperator.SUBTRACT,rowNumberMinusOneModuloIncrement,integerType),ComparisonOperator.EQUAL,new ColumnReference(\"t\",rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping()))));\nentityQuery.getFromClause().addRoot(baseTableGroup);\nentityQuery.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,new BinaryArithmeticExpression(new ColumnReference(\"t\",idColumn.getColumnExpression(),false,null,null,idColumn.getJdbcMapping()),BinaryArithmeticOperator.ADD,new BinaryArithmeticExpression(rowNumberColumnReference,BinaryArithmeticOperator.SUBTRACT,new ColumnReference(\"t\",rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping()),integerType),idType)));\nfinal CteTable finalEntityCteTable;\nif(targetPathCteColumns.contains(getCteTable().getCteColumns().get(0))){finalEntityCteTable=entityCteTable;\n}{targetPathCteColumns.add(0,getCteTable().getCteColumns().get(0));\nfinalEntityCteTable=createCteTable(getCteTable(),targetPathCteColumns,factory);\n}final List<CteColumn> cteColumns=finalEntityCteTable.getCteColumns();\nfor(int i=1; i < cteColumns.size(); i++){final CteColumn cteColumn=cteColumns.get(i);\nentityQuery.getSelectClause().addSqlSelection(new SqlSelectionImpl(i + 1,i,new ColumnReference(\"e\",cteColumn.getColumnExpression(),false,null,null,cteColumn.getJdbcMapping())));\n}final SelectStatement entityStatement=new SelectStatement(entityQuery);\nentityCte=new CteStatement(finalEntityCteTable,entityStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(entityCte);\n}}if(!assignsId && entityDescriptor.getIdentifierGenerator() instanceof PostInsertIdentifierGenerator){final String baseTableName=\"base_\" + entityCteTable.getTableExpression();\nfinal CteStatement baseEntityCte=new CteStatement(entityCteTable.withName(baseTableName),queryStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(baseEntityCte);\ntargetPathCteColumns.add(0,cteTable.getCteColumns().get(0));\nfinal CteTable finalEntityCteTable=createCteTable(getCteTable(),targetPathCteColumns,factory);\nfinal QuerySpec finalQuerySpec=new QuerySpec(true);\nfinal SelectStatement finalQueryStatement=new SelectStatement(finalQuerySpec);\nentityCte=new CteStatement(finalEntityCteTable,finalQueryStatement,CteMaterialization.MATERIALIZED);\n}{entityCte=new CteStatement(entityCteTable,queryStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(entityCte);\n}final String baseInsertCte=addDmlCtes(statement,entityCte,targetPathColumns,assignsId,sqmConverter,parameterResolutions,factory);\nfinal Expression count=createCountStar(factory,sqmConverter);\ndomainResults.add(new BasicResult<>(0,null,((SqlExpressible)count).getJdbcMapping()));\nquerySpec.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,count));\nquerySpec.getFromClause().addRoot(new CteTableGroup(new NamedTableReference(baseInsertCte,CTE_TABLE_IDENTIFIER,false,factory)));\nfinal JdbcServices jdbcServices=factory.getJdbcServices();\nfinal SqlAstTranslator<JdbcSelect> translator=jdbcServices.getJdbcEnvironment().getSqlAstTranslatorFactory().buildSelectTranslator(factory,statement);\nfinal JdbcParameterBindings jdbcParameterBindings=SqmUtil.createJdbcParameterBindings(executionContext.getQueryParameterBindings(),domainParameterXref,SqmUtil.generateJdbcParamsXref(domainParameterXref,sqmConverter),factory.getRuntimeMetamodels().getMappingMetamodel(),navigablePath -> sqmConverter.getMutatingTableGroup(),new SqmParameterMappingModelResolutionAccess(){\n  @Override @SuppressWarnings(\"unchecked\") public <T>MappingModelExpressible<T> getResolvedMappingModelType(  SqmParameter<T> parameter){\n    return (MappingModelExpressible<T>)paramTypeResolutions.get(parameter);\n  }\n}\n,executionContext.getSession());\nfinal JdbcSelect select=translator.translate(jdbcParameterBindings,executionContext.getQueryOptions());\nexecutionContext.getSession().autoFlushIfRequired(select.getAffectedTableNames());\nList<Object> list=jdbcServices.getJdbcSelectExecutor().list(select,jdbcParameterBindings,SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext),row -> row[0],ListResultsConsumer.UniqueSemantic.NONE);\nreturn ((Number)list.get(0)).intValue();\n}",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.temptable.InsertExecutionDelegate#execute\n methodBody: public int execute(ExecutionContext executionContext) {\nExecuteWithTemporaryTableHelper.performBeforeTemporaryTableUseActions(entityTable,executionContext);\ntryif(sessionUidParameter != null){jdbcParameterBindings.addBinding(sessionUidParameter,new JdbcParameterBindingImpl(entityTable.getSessionUidColumn().getJdbcMapping(),UUID.fromString(sessionUidAccess.apply(executionContext.getSession()))));\n}final int rows=ExecuteWithTemporaryTableHelper.saveIntoTemporaryTable(insertStatement,jdbcParameterBindings,executionContext);\nif(rows != 0){final AbstractEntityPersister persister=(AbstractEntityPersister)entityDescriptor.getEntityPersister();\nfinal int tableSpan=persister.getTableSpan();\ninsertRootTable(persister.getTableName(0),rows,persister.getKeyColumns(0),executionContext);\nif(persister.hasDuplicateTables()){final String[] insertedTables=new String[tableSpan];\ninsertedTables[0]=persister.getTableName(0);\nfor(int i=1; i < tableSpan; i++){if(persister.isInverseTable(i)){continue;\n}final String tableName=persister.getTableName(i);\ninsertedTables[i]=tableName;\nif(ArrayHelper.indexOf(insertedTables,i,tableName) != -1){continue;\n}insertTable(tableName,persister.getKeyColumns(i),persister.isNullableTable(i),executionContext);\n}}{for(int i=1; i < tableSpan; i++){insertTable(persister.getTableName(i),persister.getKeyColumns(i),persister.isNullableTable(i),executionContext);\n}}}return rows;\nfinallyExecuteWithTemporaryTableHelper.performAfterTemporaryTableUseActions(entityTable,sessionUidAccess,afterUseAction,executionContext);\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#getResultSetReturn\n methodBody: public ResultSetReturn getResultSetReturn() {\nif(resultSetExtractor == null){resultSetExtractor=new ResultSetReturnImpl(this,jdbcServices);\n}return resultSetExtractor;\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#addObserver\n methodBody: void addObserver(BatchObserver observer);",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.temptable.UpdateExecutionDelegate#execute\n methodBody: public int execute(ExecutionContext executionContext) {\nExecuteWithTemporaryTableHelper.performBeforeTemporaryTableUseActions(idTable,executionContext);\ntryfinal int rows=ExecuteWithTemporaryTableHelper.saveMatchingIdsIntoIdTable(sqmConverter,suppliedPredicate,idTable,sessionUidAccess,jdbcParameterBindings,executionContext);\nfinal QuerySpec idTableSubQuery=ExecuteWithTemporaryTableHelper.createIdTableSelectQuerySpec(idTable,sessionUidAccess,entityDescriptor,executionContext);\nentityDescriptor.visitConstraintOrderedTables((tableExpression,tableKeyColumnVisitationSupplier) -> updateTable(tableExpression,tableKeyColumnVisitationSupplier,rows,idTableSubQuery,executionContext));\nreturn rows;\nfinallyExecuteWithTemporaryTableHelper.performAfterTemporaryTableUseActions(idTable,sessionUidAccess,afterUseAction,executionContext);\n}",
            "methodSignature: org.hibernate.metamodel.mapping.internal.MappingModelCreationProcess#execute\n methodBody: private void execute() {\nfor(EntityPersister entityPersister: entityPersisterMap.values()){if(entityPersister instanceof InFlightEntityMappingType){((InFlightEntityMappingType)entityPersister).linkWithSuperType(this);\n}}for(EntityPersister entityPersister: entityPersisterMap.values()){currentlyProcessingRole=entityPersister.getEntityName();\nif(entityPersister instanceof InFlightEntityMappingType){((InFlightEntityMappingType)entityPersister).prepareMappingModel(this);\n}}executePostInitCallbacks();\n}",
            "methodSignature: org.hibernate.orm.test.insertordering.InsertOrderingTest.StatsBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn new StatsBatch(key,jdbcCoordinator,getJdbcBatchSize());\n}",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.cte.AbstractCteMutationHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal SqmDeleteOrUpdateStatement sqmMutationStatement=getSqmDeleteOrUpdateStatement();\nfinal SessionFactoryImplementor factory=executionContext.getSession().getFactory();\nfinal EntityMappingType entityDescriptor=getEntityDescriptor();\nfinal String explicitDmlTargetAlias;\nif(sqmMutationStatement.getTarget().getExplicitAlias() == null){explicitDmlTargetAlias=\"dml_target\";\n}{explicitDmlTargetAlias=sqmMutationStatement.getTarget().getExplicitAlias();\n}final MultiTableSqmMutationConverter sqmConverter=new MultiTableSqmMutationConverter(entityDescriptor,sqmMutationStatement,sqmMutationStatement.getTarget(),explicitDmlTargetAlias,domainParameterXref,executionContext.getQueryOptions(),executionContext.getSession().getLoadQueryInfluencers(),executionContext.getQueryParameterBindings(),factory);\nfinal Map<SqmParameter<?>,List<JdbcParameter>> parameterResolutions;\nif(domainParameterXref.getSqmParameterCount() == 0){parameterResolutions=Collections.emptyMap();\n}{parameterResolutions=new IdentityHashMap<>();\n}final Map<SqmParameter,MappingModelExpressible> paramTypeResolutions=new LinkedHashMap<>();\nfinal Predicate restriction=sqmConverter.visitWhereClause(sqmMutationStatement.getWhereClause(),columnReference -> {\n}\n,(sqmParam,mappingType,jdbcParameters) -> paramTypeResolutions.put(sqmParam,mappingType));\nsqmConverter.pruneTableGroupJoins();\nfinal CteStatement idSelectCte=new CteStatement(getCteTable(),MatchingIdSelectionHelper.generateMatchingIdSelectStatement(entityDescriptor,sqmMutationStatement,true,restriction,sqmConverter,executionContext,factory),CteMaterialization.MATERIALIZED);\nfinal QuerySpec querySpec=new QuerySpec(true,1);\nfinal List<DomainResult<?>> domainResults=new ArrayList<>(1);\nfinal SelectStatement statement=new SelectStatement(querySpec,domainResults);\nfinal JdbcServices jdbcServices=factory.getJdbcServices();\nfinal SqlAstTranslator<JdbcSelect> translator=jdbcServices.getJdbcEnvironment().getSqlAstTranslatorFactory().buildSelectTranslator(factory,statement);\nfinal Expression count=createCountStar(factory,sqmConverter);\ndomainResults.add(new BasicResult<>(0,null,((SqlExpressible)count).getJdbcMapping()));\nquerySpec.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,count));\nquerySpec.getFromClause().addRoot(new CteTableGroup(new NamedTableReference(idSelectCte.getCteTable().getTableExpression(),CTE_TABLE_IDENTIFIER,false,factory)));\nstatement.addCteStatement(idSelectCte);\naddDmlCtes(statement,idSelectCte,sqmConverter,parameterResolutions,factory);\nfinal JdbcParameterBindings jdbcParameterBindings=SqmUtil.createJdbcParameterBindings(executionContext.getQueryParameterBindings(),domainParameterXref,SqmUtil.generateJdbcParamsXref(domainParameterXref,sqmConverter),factory.getRuntimeMetamodels().getMappingMetamodel(),navigablePath -> sqmConverter.getMutatingTableGroup(),paramTypeResolutions::get,executionContext.getSession());\nfinal LockOptions lockOptions=executionContext.getQueryOptions().getLockOptions();\nfinal LockMode lockMode=lockOptions.getAliasSpecificLockMode(explicitDmlTargetAlias);\nlockOptions.setAliasSpecificLockMode(explicitDmlTargetAlias,LockMode.WRITE);\nfinal JdbcSelect select=translator.translate(jdbcParameterBindings,executionContext.getQueryOptions());\nlockOptions.setAliasSpecificLockMode(explicitDmlTargetAlias,lockMode);\nexecutionContext.getSession().autoFlushIfRequired(select.getAffectedTableNames());\nList<Object> list=jdbcServices.getJdbcSelectExecutor().list(select,jdbcParameterBindings,SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext),row -> row[0],ListResultsConsumer.UniqueSemantic.NONE);\nreturn ((Number)list.get(0)).intValue();\n}",
            "methodSignature: org.hibernate.mapping.Component.ValueGenerationPlan#execute\n methodBody: public void execute(SharedSessionContractImplementor session, Object incomingObject, Object injectionContext) {\nfinal Object generatedValue=subGenerator.generate(session,incomingObject);\ninjector.set(injectionContext,generatedValue);\n}",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.temptable.TableBasedInsertHandler.ExecutionDelegate#execute\n methodBody: int execute(ExecutionContext executionContext);",
            "methodSignature: org.hibernate.dialect.AbstractHANADialect.MaterializedNClob#setString\n methodBody: public int setString(long pos, String str) throws SQLException {\nthis.data=this.data.substring(0,(int)(pos - 1)) + str + this.data.substring((int)(pos - 1 + str.length()));\nreturn str.length();\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch#addToBatch\n methodBody: public void addToBatch() {\nnotifyObserversImplicitExecution();\nfor(Map.Entry<String,PreparedStatement> entry: getStatements().entrySet()){final String statementSQL=entry.getKey();\ntryfinal PreparedStatement statement=entry.getValue();\nfinal int rowCount=jdbcCoordinator.getResultSetReturn().executeUpdate(statement);\ngetKey().getExpectation().verifyOutcome(rowCount,statement,0,statementSQL);\njdbcCoordinator.getLogicalConnection().getResourceRegistry().release(statement);\njdbcCoordinator.afterStatementExecution();\ncatch(SQLException e)abortBatch(e);\nthrow sqlExceptionHelper().convert(e,\"could not execute non-batched batch statement\",statementSQL);\ncatch(RuntimeException e)abortBatch(e);\nthrow e;\n}getStatements().clear();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#getStatementPreparer\n methodBody: public StatementPreparer getStatementPreparer() {\nif(statementPreparer == null){statementPreparer=new StatementPreparerImpl(this,jdbcServices);\n}return statementPreparer;\n}",
            "methodSignature: org.hibernate.sql.Insert#getDialect\n methodBody: protected Dialect getDialect() {\nreturn dialect;\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#release\n methodBody: public void release() {\nif(getStatements() != null && !getStatements().isEmpty()){LOG.batchContainedStatementsOnRelease();\n}releaseStatements();\nobservers.clear();\n}",
            "methodSignature: org.hibernate.sql.exec.internal.StandardJdbcMutationExecutor#execute\n methodBody: public int execute(\n\t\t\tJdbcMutation jdbcMutation,\n\t\t\tJdbcParameterBindings jdbcParameterBindings,\n\t\t\tFunction<String, PreparedStatement> statementCreator,\n\t\t\tBiConsumer<Integer, PreparedStatement> expectationCheck,\n\t\t\tExecutionContext executionContext) {\nfinal SharedSessionContractImplementor session=executionContext.getSession();\nsession.autoFlushIfRequired(jdbcMutation.getAffectedTableNames());\nfinal LogicalConnectionImplementor logicalConnection=session.getJdbcCoordinator().getLogicalConnection();\nfinal JdbcServices jdbcServices=session.getJdbcServices();\nfinal QueryOptions queryOptions=executionContext.getQueryOptions();\nfinal String finalSql;\nif(queryOptions == null){finalSql=jdbcMutation.getSql();\n}{finalSql=jdbcServices.getDialect().addSqlHintOrComment(jdbcMutation.getSql(),queryOptions,executionContext.getSession().getFactory().getSessionFactoryOptions().isCommentsEnabled());\n}tryfinal PreparedStatement preparedStatement=statementCreator.apply(finalSql);\ntryif(executionContext.getQueryOptions().getTimeout() != null){preparedStatement.setQueryTimeout(executionContext.getQueryOptions().getTimeout());\n}int paramBindingPosition=1;\nfor(JdbcParameterBinder parameterBinder: jdbcMutation.getParameterBinders()){parameterBinder.bindParameterValue(preparedStatement,paramBindingPosition++,jdbcParameterBindings,executionContext);\n}session.getEventListenerManager().jdbcExecuteStatementStart();\ntryint rows=preparedStatement.executeUpdate();\nexpectationCheck.accept(rows,preparedStatement);\nreturn rows;\nfinallysession.getEventListenerManager().jdbcExecuteStatementEnd();\nfinallylogicalConnection.getResourceRegistry().release(preparedStatement);\ncatch(SQLException e)throw jdbcServices.getSqlExceptionHelper().convert(e,\"JDBC exception executing SQL [\" + finalSql + \"]\");\nfinallyexecutionContext.afterStatement(logicalConnection);\n}",
            "methodSignature: org.hibernate.sql.exec.spi.JdbcMutationExecutor#execute\n methodBody: int execute(\n\t\t\tJdbcMutation jdbcMutation,\n\t\t\tJdbcParameterBindings jdbcParameterBindings,\n\t\t\tFunction<String, PreparedStatement> statementCreator,\n\t\t\tBiConsumer<Integer, PreparedStatement> expectationCheck,\n\t\t\tExecutionContext executionContext);",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#addObserver\n methodBody: public void addObserver(BatchObserver observer) {\nobservers.add(observer);\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.BatchBuilderImpl#setJdbcBatchSize\n methodBody: public void setJdbcBatchSize(int jdbcBatchSize) {\nthis.jdbcBatchSize=jdbcBatchSize;\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.BatchingBatch#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\ncurrentStatementSql=sql;\nint previousBatchSize=getStatements().size();\ncurrentStatement=super.getBatchStatement(sql,callable);\nint currentBatchSize=getStatements().size();\nif(currentBatchSize > previousBatchSize){this.batchSize=this.configuredBatchSize * currentBatchSize;\n}return currentStatement;\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#getBatchStatement\n methodBody: PreparedStatement getBatchStatement(String sql, boolean callable);",
            "methodSignature: org.hibernate.engine.jdbc.spi.JdbcCoordinator#close\n methodBody: Connection close();",
            "methodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#addToBatch\n methodBody: void addToBatch();",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.BatchingBatch#addToBatch\n methodBody: public void addToBatch() {\ntrycurrentStatement.addBatch();\ncatch(SQLException e)abortBatch(e);\nLOG.debug(\"SQLException escaped proxy\",e);\nthrow sqlExceptionHelper().convert(e,\"could not perform addBatch\",currentStatementSql);\ncatch(RuntimeException e)abortBatch(e);\nthrow e;\nstatementPosition++;\nif(statementPosition >= getKey().getBatchedStatementCount()){batchPosition++;\nif(batchPosition == batchSize){notifyObserversImplicitExecution();\nperformExecution();\nbatchPosition=0;\nbatchExecuted=true;\n}statementPosition=0;\n}}",
            "methodSignature: org.hibernate.action.internal.BulkOperationCleanupAction.CollectionCleanup#release\n methodBody: private void release() {\ncacheAccess.unlockRegion(cacheLock);\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#execute\n methodBody: public final void execute() {\nnotifyObserversExplicitExecution();\nif(getStatements().isEmpty()){return;\n}trydoExecuteBatch();\nfinallyreleaseStatements();\n}",
            "methodSignature: org.hibernate.action.internal.BulkOperationCleanupAction.EntityCleanup#release\n methodBody: private void release() {\ncacheAccess.unlockRegion(cacheLock);\n}",
            "methodSignature: org.hibernate.sql.results.jdbc.internal.DeferredResultSetAccess#release\n methodBody: public void release() {\nif(resultSet != null){getPersistenceContext().getJdbcCoordinator().getLogicalConnection().getResourceRegistry().release(resultSet,preparedStatement);\nresultSet=null;\n}if(preparedStatement != null){getPersistenceContext().getJdbcCoordinator().getLogicalConnection().getResourceRegistry().release(preparedStatement);\npreparedStatement=null;\n}}",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.temptable.RestrictedDeleteExecutionDelegate#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal EntityPersister entityDescriptor=sessionFactory.getRuntimeMetamodels().getMappingMetamodel().getEntityDescriptor(sqmDelete.getTarget().getEntityName());\nfinal String hierarchyRootTableName=((Joinable)entityDescriptor).getTableName();\nfinal TableGroup deletingTableGroup=converter.getMutatingTableGroup();\nfinal TableReference hierarchyRootTableReference=deletingTableGroup.resolveTableReference(deletingTableGroup.getNavigablePath(),hierarchyRootTableName);\nassert hierarchyRootTableReference != null;\nfinal Map<SqmParameter<?>,List<List<JdbcParameter>>> parameterResolutions;\nfinal Map<SqmParameter<?>,MappingModelExpressible<?>> paramTypeResolutions;\nif(domainParameterXref.getSqmParameterCount() == 0){parameterResolutions=Collections.emptyMap();\nparamTypeResolutions=Collections.emptyMap();\n}{parameterResolutions=new IdentityHashMap<>();\nparamTypeResolutions=new LinkedHashMap<>();\n}final MutableBoolean needsIdTableWrapper=new MutableBoolean(false);\nfinal Predicate specifiedRestriction=converter.visitWhereClause(sqmDelete.getWhereClause(),columnReference -> {\n  if (!hierarchyRootTableReference.getIdentificationVariable().equals(columnReference.getQualifier())) {\n    needsIdTableWrapper.setValue(true);\n  }\n}\n,(sqmParameter,mappingType,jdbcParameters) -> {\n  parameterResolutions.computeIfAbsent(sqmParameter,k -> new ArrayList<>(1)).add(jdbcParameters);\n  paramTypeResolutions.put(sqmParameter,mappingType);\n}\n);\nfinal PredicateCollector predicateCollector=new PredicateCollector(specifiedRestriction);\nentityDescriptor.applyBaseRestrictions((filterPredicate) -> {\n  needsIdTableWrapper.setValue(true);\n  predicateCollector.applyPredicate(filterPredicate);\n}\n,deletingTableGroup,true,executionContext.getSession().getLoadQueryInfluencers().getEnabledFilters(),null,converter);\nconverter.pruneTableGroupJoins();\nfinal boolean needsIdTable=needsIdTableWrapper.getValue() || entityDescriptor != entityDescriptor.getRootEntityDescriptor();\nfinal SqmJdbcExecutionContextAdapter executionContextAdapter=SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext);\nif(needsIdTable){return executeWithIdTable(predicateCollector.getPredicate(),deletingTableGroup,parameterResolutions,paramTypeResolutions,executionContextAdapter);\n}{return executeWithoutIdTable(predicateCollector.getPredicate(),deletingTableGroup,parameterResolutions,paramTypeResolutions,converter.getSqlExpressionResolver(),executionContextAdapter);\n}}",
            "methodSignature: org.hibernate.orm.test.jpa.transaction.batch.JtaWithFailingBatchTest.TestBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn buildBatchTest(key,jdbcCoordinator,getJdbcBatchSize());\n}",
            "methodSignature: org.hibernate.orm.test.jpa.transaction.batch.FailingAddToBatchTest.TestBatch#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\nPreparedStatement batchStatement=super.getBatchStatement(sql,callable);\ncreatedStatements.add(batchStatement);\nreturn batchStatement;\n}",
            "methodSignature: org.hibernate.orm.test.jpa.transaction.batch.JtaWithStatementsBatchTest.TestBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn buildBatchTest(key,jdbcCoordinator,getJdbcBatchSize());\n}",
            "methodSignature: org.hibernate.orm.test.manytomany.batchload.TestingBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn new TestingBatch(key,jdbcCoordinator);\n}",
            "methodSignature: org.hibernate.persister.collection.AbstractCollectionPersister#getDialect\n methodBody: protected Dialect getDialect() {\nreturn dialect;\n}",
            "methodSignature: org.hibernate.engine.jdbc.spi.JdbcCoordinator#getLogicalConnection\n methodBody: LogicalConnectionImplementor getLogicalConnection();",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.temptable.TableBasedInsertHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nif(log.isTraceEnabled()){log.tracef(\"Starting multi-table insert execution - %s\",getSqmInsertStatement().getTarget().getModel().getName());\n}final SqmJdbcExecutionContextAdapter executionContextAdapter=SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext);\nreturn resolveDelegate(executionContext).execute(executionContextAdapter);\n}",
            "methodSignature: org.hibernate.orm.test.insertordering.InsertOrderingTest.StatsBatch#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\nif(batchSQL == null || !batchSQL.equals(sql)){currentBatch++;\nbatchSQL=sql;\nbatchSizes.add(currentBatch,new Counter());\n}return super.getBatchStatement(sql,callable);\n}",
            "methodSignature: org.hibernate.engine.jdbc.spi.JdbcCoordinator#getResultSetReturn\n methodBody: ResultSetReturn getResultSetReturn();",
            "methodSignature: org.hibernate.sql.ast.spi.AbstractSqlAstTranslator#getDialect\n methodBody: public Dialect getDialect() {\nreturn dialect;\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.BatchBuilderImpl#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn SharedBatchBuildingCode.buildBatch(jdbcBatchSize,key,jdbcCoordinator);\n}",
            "methodSignature: org.hibernate.orm.test.jpa.transaction.batch.FailingAddToBatchTest.TestBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn buildBatchTest(key,jdbcCoordinator,getJdbcBatchSize());\n}",
            "methodSignature: org.hibernate.orm.test.jpa.transaction.batch.FailingAddToBatchTest.TestBatch#addToBatch\n methodBody: public void addToBatch() {\nRuntimeException failure=nextAddToBatchFailure.getAndSet(null);\nif(failure != null){throw failure;\n}super.addToBatch();\n}",
            "methodSignature: org.hibernate.dialect.Dialect#getDropTableString\n methodBody: public String getDropTableString(String tableName) {\nfinal StringBuilder buf=new StringBuilder(\"drop table \");\nif(supportsIfExistsBeforeTableName()){buf.append(\"if exists \");\n}buf.append(tableName).append(getCascadeConstraintsString());\nif(supportsIfExistsAfterTableName()){buf.append(\" if exists\");\n}return buf.toString();\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#getJdbcCoordinator\n methodBody: protected JdbcCoordinator getJdbcCoordinator(){\nreturn this.jdbcCoordinator;\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#sessionFactory\n methodBody: protected SessionFactoryImplementor sessionFactory() {\nreturn this.owner.getJdbcSessionContext().getSessionFactory();\n}",
            "methodSignature: org.hibernate.dialect.AbstractHANADialect.CloseSuppressingReader#close\n methodBody: public void close() {\n}",
            "methodSignature: org.hibernate.sql.ast.spi.AbstractSqlAstTranslator#getJdbcServices\n methodBody: protected JdbcServices getJdbcServices() {\nreturn getSessionFactory().getJdbcServices();\n}"
        ],
        "sourceCodeAfterRefactoring": "@Test\n\tpublic void testSessionBatchingUsage() throws Exception {\n\t\tSession session = openSession();\n\t\tsession.setJdbcBatchSize( 3 );\n\t\tSessionImplementor sessionImpl = (SessionImplementor) session;\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\n\t\texportSandboxSchema( sessionImpl );\n\n\t\t// ok, now we can get down to it...\n\t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n\t\ttxn.begin();\n\n\n\t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n\n\t\tfinal BatchBuilderImpl batchBuilder = new BatchBuilderImpl( 2 );\n\t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\" );\n\t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, 3, SANDBOX_TBL, sessionImpl, insertSql );\n\t\tassertThat( insertBatch ).isNotNull();\n\n\t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n\t\tinsertBatch.addObserver( batchObserver );\n\n\t\tfinal JdbcValueBindingsImpl jdbcValueBindings = sandboxInsertValueBindings( sessionImpl );\n\n\t\t// bind values for #1 - this does nothing at the JDBC level\n\t\tjdbcValueBindings.bindValue( 1, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n\t\tjdbcValueBindings.bindValue( \"name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isFalse();\n\n\t\t// add the values to the batch - this creates the prepared statement and binds the values\n\t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\t// bind values for #2 - this does nothing at the JDBC level : we do still have the statement defining the batch\n\t\tjdbcValueBindings.bindValue( 2, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n\t\tjdbcValueBindings.bindValue( \"another name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\t// add #2 to batch - we have not exceeded batch size, so we should not get an implicit execution\n\t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\t// bind values for #3 - this does nothing at the JDBC level : we do still have the statement defining the batch\n\t\tjdbcValueBindings.bindValue( 3, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n\t\tjdbcValueBindings.bindValue( \"yet another name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 1 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\tinsertBatch.execute();\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 1 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 1 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isFalse();\n\n\t\tinsertBatch.release();\n\n\t\ttxn.commit();\n\t\tsession.close();\n\t}\nprivate void exportSandboxSchema(SessionImplementor sessionImpl) {\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n\n\t\t// set up some tables to use\n\t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n\t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n\t\ttry {\n\t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n\t\t}\n\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n\t\tassertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n\t\tassertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n\t}",
        "diffSourceCode": "-  180: \t@Test\n-  181: \tpublic void testSessionBatchingUsage() throws Exception {\n-  182: \t\tSession session = openSession();\n-  183: \t\tsession.setJdbcBatchSize( 3 );\n-  184: \t\tSessionImplementor sessionImpl = (SessionImplementor) session;\n-  185: \n-  186: \t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n-  187: \t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n+  180: \t\t\t\t\t\t\tpublic ParameterUsage getUsage() {\n+  181: \t\t\t\t\t\t\t\treturn ParameterUsage.SET;\n+  182: \t\t\t\t\t\t\t}\n+  183: \n+  184: \t\t\t\t\t\t\t@Override\n+  185: \t\t\t\t\t\t\tpublic int getJdbcPosition() {\n+  186: \t\t\t\t\t\t\t\treturn 1;\n+  187: \t\t\t\t\t\t\t}\n   188: \n-  189: \t\t// set up some tables to use\n-  190: \t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n-  191: \t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n-  192: \t\ttry {\n-  193: \t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n-  194: \t\t}\n-  195: \t\tcatch ( Exception e ) {\n-  196: \t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n-  197: \t\t}\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n-  198:         assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n-  199: \t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n-  200:         jdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n-  201:         assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n-  202: \t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n-  203: \n-  204: \t\t// ok, now we can get down to it...\n-  205: \t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n-  206: \t\ttxn.begin();\n-  207: \n-  208: \t\tfinal BatchBuilder batchBuilder = new BatchBuilderImpl( 2 );\n-  209: \t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\", Expectations.BASIC );\n-  210: \t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, jdbcCoordinator );\n-  211: \t\tassertTrue( \"unexpected Batch impl\", BatchingBatch.class.isInstance( insertBatch ) );\n-  212: \n-  213: \t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n-  214: \t\tinsertBatch.addObserver( batchObserver );\n-  215: \n-  216: \t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n-  217: \n-  218: \t\tPreparedStatement insert = insertBatch.getBatchStatement( insertSql, false );\n-  219: \t\tinsert.setLong( 1, 1 );\n-  220: \t\tinsert.setString( 2, \"name\" );\n-  221: \t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n-  222: \t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n-  223: \t\tinsertBatch.addToBatch();\n-  224: \t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n-  225: \t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n-  226:         assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n-  227: \n-  228: \t\tPreparedStatement insert2 = insertBatch.getBatchStatement( insertSql, false );\n-  229: \t\tassertSame( insert, insert2 );\n-  230: \t\tinsert = insert2;\n-  231: \t\tinsert.setLong( 1, 2 );\n-  232: \t\tinsert.setString( 2, \"another name\" );\n-  233: \t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n-  234: \t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n-  235: \t\tinsertBatch.addToBatch();\n-  236: \t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n-  237: \t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n-  238:         assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n-  239: \n-  240: \t\tPreparedStatement insert3 = insertBatch.getBatchStatement( insertSql, false );\n-  241: \t\tassertSame( insert, insert3 );\n-  242: \t\tinsert = insert3;\n-  243: \t\tinsert.setLong( 1, 3 );\n-  244: \t\tinsert.setString( 2, \"yet another name\" );\n-  245: \t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n-  246: \t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n-  247: \t\tinsertBatch.addToBatch();\n-  248: \t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n-  249: \t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n-  250:         assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n-  251: \n-  252: \t\tinsertBatch.execute();\n-  253: \t\tassertEquals( 1, batchObserver.getExplicitExecutionCount() );\n-  254: \t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n-  255:         assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n-  256: \n-  257: \t\tinsertBatch.release();\n-  258: \n-  259: \t\ttxn.commit();\n-  260: \t\tsession.close();\n-  261: \t}\n-  262: \n-  263: \t@Override\n-  264: \tprotected void cleanupTest() throws Exception {\n-  265: \t\ttry (Session session = openSession()) {\n-  266: \t\t\tsession.doWork( connection -> {\n-  267: \t\t\t\tfinal Statement stmnt = connection.createStatement();\n-  268: \n-  269: \t\t\t\tstmnt.execute( sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" ) );\n-  270: \t\t\t} );\n-  271: \t\t}\n-  272: \t}\n-  273: \n-  274: }\n+  189: \t\t\t\t\t\t\t@Override\n+  190: \t\t\t\t\t\t\tpublic JdbcMapping getJdbcMapping() {\n+  191: \t\t\t\t\t\t\t\treturn session.getTypeConfiguration()\n+  192: \t\t\t\t\t\t\t\t\t\t.getBasicTypeRegistry()\n+  193: \t\t\t\t\t\t\t\t\t\t.resolve( StandardBasicTypes.INTEGER );\n+  194: \t\t\t\t\t\t\t}\n+  195: \t\t\t\t\t\t};\n+  196: \t\t\t\t\t}\n+  197: \n+  198: \t\t\t\t\tif ( columnName.equals( \"NAME\" ) ) {\n+  199: \t\t\t\t\t\treturn new JdbcValueDescriptor() {\n+  200: \t\t\t\t\t\t\t@Override\n+  201: \t\t\t\t\t\t\tpublic String getColumnName() {\n+  202: \t\t\t\t\t\t\t\treturn \"NAME\";\n+  203: \t\t\t\t\t\t\t}\n+  204: \n+  205: \t\t\t\t\t\t\t@Override\n+  206: \t\t\t\t\t\t\tpublic ParameterUsage getUsage() {\n+  207: \t\t\t\t\t\t\t\treturn ParameterUsage.SET;\n+  208: \t\t\t\t\t\t\t}\n+  209: \n+  210: \t\t\t\t\t\t\t@Override\n+  211: \t\t\t\t\t\t\tpublic int getJdbcPosition() {\n+  212: \t\t\t\t\t\t\t\treturn 2;\n+  213: \t\t\t\t\t\t\t}\n+  214: \n+  215: \t\t\t\t\t\t\t@Override\n+  216: \t\t\t\t\t\t\tpublic JdbcMapping getJdbcMapping() {\n+  217: \t\t\t\t\t\t\t\treturn session.getTypeConfiguration()\n+  218: \t\t\t\t\t\t\t\t\t\t.getBasicTypeRegistry()\n+  219: \t\t\t\t\t\t\t\t\t\t.resolve( StandardBasicTypes.STRING );\n+  220: \t\t\t\t\t\t\t}\n+  221: \t\t\t\t\t\t};\n+  222: \t\t\t\t\t}\n+  223: \n+  224: \t\t\t\t\tthrow new IllegalArgumentException( \"Unknown column : \" + columnName );\n+  225: \t\t\t\t}\n+  226: \t\t);\n+  227: \t}\n+  228: \n+  229: \t@Test\n+  230: \tpublic void testSessionBatchingUsage() throws Exception {\n+  231: \t\tSession session = openSession();\n+  232: \t\tsession.setJdbcBatchSize( 3 );\n+  233: \t\tSessionImplementor sessionImpl = (SessionImplementor) session;\n+  234: \t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n+  235: \n+  236: \t\texportSandboxSchema( sessionImpl );\n+  237: \n+  238: \t\t// ok, now we can get down to it...\n+  239: \t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n+  240: \t\ttxn.begin();\n+  241: \n+  242: \n+  243: \t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n+  244: \n+  245: \t\tfinal BatchBuilderImpl batchBuilder = new BatchBuilderImpl( 2 );\n+  246: \t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\" );\n+  247: \t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, 3, SANDBOX_TBL, sessionImpl, insertSql );\n+  248: \t\tassertThat( insertBatch ).isNotNull();\n+  249: \n+  250: \t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n+  251: \t\tinsertBatch.addObserver( batchObserver );\n+  252: \n+  253: \t\tfinal JdbcValueBindingsImpl jdbcValueBindings = sandboxInsertValueBindings( sessionImpl );\n+  254: \n+  255: \t\t// bind values for #1 - this does nothing at the JDBC level\n+  256: \t\tjdbcValueBindings.bindValue( 1, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n+  257: \t\tjdbcValueBindings.bindValue( \"name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n+  258: \t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n+  259: \t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n+  260: \t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isFalse();\n+  261: \n+  262: \t\t// add the values to the batch - this creates the prepared statement and binds the values\n+  263: \t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n+  264: \t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n+  265: \t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n+  266: \t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n+  267: \n+  268: \t\t// bind values for #2 - this does nothing at the JDBC level : we do still have the statement defining the batch\n+  269: \t\tjdbcValueBindings.bindValue( 2, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n+  270: \t\tjdbcValueBindings.bindValue( \"another name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n+  271: \t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n+  272: \t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n+  273: \t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n+  274: \n+  275: \t\t// add #2 to batch - we have not exceeded batch size, so we should not get an implicit execution\n+  276: \t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n+  277: \t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n+  278: \t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n+  279: \t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n+  280: \n+  281: \t\t// bind values for #3 - this does nothing at the JDBC level : we do still have the statement defining the batch\n+  282: \t\tjdbcValueBindings.bindValue( 3, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n+  283: \t\tjdbcValueBindings.bindValue( \"yet another name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n+  284: \t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n+  285: \t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n+  286: \t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n+  287: \n+  288: \t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n+  289: \t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n+  290: \t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 1 );\n+  291: \t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n+  292: \n+  293: \t\tinsertBatch.execute();\n+  294: \t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 1 );\n+  295: \t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 1 );\n+  296: \t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isFalse();\n+  297: \n+  298: \t\tinsertBatch.release();\n+  299: \n+  300: \t\ttxn.commit();\n+  301: \t\tsession.close();\n+  302: \t}\n+  304: \tprivate void exportSandboxSchema(SessionImplementor sessionImpl) {\n+  305: \t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n+  306: \t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n+  307: \n+  308: \t\t// set up some tables to use\n+  309: \t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n+  310: \t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n+  311: \t\ttry {\n+  312: \t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n+  313: \t\t}\n+  314: \t\tcatch ( Exception e ) {\n+  315: \t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n+  316: \t\t}\n+  317: \t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n+  318: \t\tassertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n+  319: \t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n+  320: \t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n+  321: \t\tassertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n+  322: \t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n+  323: \t}\n",
        "uniqueId": "a9ac98b364ccf52bb9cb2be5324c9c983e8bd8b3_180_261_304_323_229_302",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": true,
        "refactoredCode": "##########################\nprivate void setupTables(JdbcCoordinator jdbcCoordinator, LogicalConnectionImplementor logicalConnection) {\n    Statement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n    String dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString(\"SANDBOX_JDBC_TST\");\n    try {\n        jdbcCoordinator.getResultSetReturn().execute(statement, dropSql);\n    } catch (Exception e) {\n        // ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n    }\n    jdbcCoordinator.getResultSetReturn().execute(statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\");\n    assertTrue(jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources());\n    assertTrue(logicalConnection.isPhysicallyConnected());\n    jdbcCoordinator.getLogicalConnection().getResourceRegistry().release(statement);\n    assertFalse(jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources());\n    assertTrue(logicalConnection.isPhysicallyConnected()); // after_transaction specified\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Test\n\tpublic void testSessionBatchingUsage() throws Exception {\n\t\tSession session = openSession();\n\t\tsession.setJdbcBatchSize( 3 );\n\t\tSessionImplementor sessionImpl = (SessionImplementor) session;\n\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n\n\t\t// set up some tables to use\n\t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n\t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n\t\ttry {\n\t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n\t\t}\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n        jdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n\n\t\t// ok, now we can get down to it...\n\t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n\t\ttxn.begin();\n\n\t\tfinal BatchBuilder batchBuilder = new BatchBuilderImpl( 2 );\n\t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\", Expectations.BASIC );\n\t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, jdbcCoordinator );\n\t\tassertTrue( \"unexpected Batch impl\", BatchingBatch.class.isInstance( insertBatch ) );\n\n\t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n\t\tinsertBatch.addObserver( batchObserver );\n\n\t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n\n\t\tPreparedStatement insert = insertBatch.getBatchStatement( insertSql, false );\n\t\tinsert.setLong( 1, 1 );\n\t\tinsert.setString( 2, \"name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tPreparedStatement insert2 = insertBatch.getBatchStatement( insertSql, false );\n\t\tassertSame( insert, insert2 );\n\t\tinsert = insert2;\n\t\tinsert.setLong( 1, 2 );\n\t\tinsert.setString( 2, \"another name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tPreparedStatement insert3 = insertBatch.getBatchStatement( insertSql, false );\n\t\tassertSame( insert, insert3 );\n\t\tinsert = insert3;\n\t\tinsert.setLong( 1, 3 );\n\t\tinsert.setString( 2, \"yet another name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.execute();\n\t\tassertEquals( 1, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.release();\n\n\t\ttxn.commit();\n\t\tsession.close();\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.orm.test.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.Statement;\n\nimport org.hibernate.Session;\nimport org.hibernate.Transaction;\nimport org.hibernate.engine.jdbc.batch.internal.BasicBatchKey;\nimport org.hibernate.engine.jdbc.batch.internal.BatchBuilderImpl;\nimport org.hibernate.engine.jdbc.batch.internal.BatchingBatch;\nimport org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch;\nimport org.hibernate.engine.jdbc.batch.spi.Batch;\nimport org.hibernate.engine.jdbc.batch.spi.BatchBuilder;\nimport org.hibernate.engine.jdbc.batch.spi.BatchKey;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.spi.SessionImplementor;\nimport org.hibernate.jdbc.Expectation;\nimport org.hibernate.jdbc.Expectations;\nimport org.hibernate.resource.jdbc.spi.LogicalConnectionImplementor;\n\nimport org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;\nimport org.hibernate.orm.test.common.JournalingBatchObserver;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertSame;\nimport static org.junit.Assert.assertTrue;\n\n/**\n * @author Steve Ebersole\n * @author Brett Meyer\n */\npublic class BatchingTest extends BaseCoreFunctionalTestCase implements BatchKey {\n\t@Override\n\tpublic int getBatchedStatementCount() {\n\t\treturn 1;\n\t}\n\n\t@Override\n\tpublic Expectation getExpectation() {\n\t\treturn Expectations.BASIC;\n\t}\n\n\t@Test\n\tpublic void testNonBatchingUsage() throws Exception {\n\t\tSession session = openSession();\n\t\tSessionImplementor sessionImpl = (SessionImplementor) session;\n\t\t\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n\n\t\t// set up some tables to use\n\t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n\t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n\t\ttry {\n\t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n\t\t}\n\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n        jdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n\n\t\t// ok, now we can get down to it...\n\t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n\t\ttxn.begin();\n\n\t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n\n\t\tfinal BatchBuilder batchBuilder = new BatchBuilderImpl( -1 );\n\t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\", Expectations.BASIC );\n\t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, jdbcCoordinator );\n\n\t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n\t\tinsertBatch.addObserver( batchObserver );\n\n\t\tassertTrue( \"unexpected Batch impl\", NonBatchingBatch.class.isInstance( insertBatch ) );\n\t\tPreparedStatement insert = insertBatch.getBatchStatement( insertSql, false );\n\t\tinsert.setLong( 1, 1 );\n\t\tinsert.setString( 2, \"name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.execute();\n\t\tassertEquals( 1, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.release();\n\n\t\ttxn.commit();\n\t\tsession.close();\n\t}\n\n\t@Test\n\tpublic void testBatchingUsage() throws Exception {\n\t\tSession session = openSession();\n\t\tSessionImplementor sessionImpl = (SessionImplementor) session;\n\t\t\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n\n\t\t// set up some tables to use\n\t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n\t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n\t\ttry {\n\t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n\t\t}\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n        jdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n\n\t\t// ok, now we can get down to it...\n\t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n\t\ttxn.begin();\n\n\t\tfinal BatchBuilder batchBuilder = new BatchBuilderImpl( 2 );\n\t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\", Expectations.BASIC );\n\t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, jdbcCoordinator );\n\t\tassertTrue( \"unexpected Batch impl\", BatchingBatch.class.isInstance( insertBatch ) );\n\n\t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n\t\tinsertBatch.addObserver( batchObserver );\n\n\t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n\n\t\tPreparedStatement insert = insertBatch.getBatchStatement( insertSql, false );\n\t\tinsert.setLong( 1, 1 );\n\t\tinsert.setString( 2, \"name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tPreparedStatement insert2 = insertBatch.getBatchStatement( insertSql, false );\n\t\tassertSame( insert, insert2 );\n\t\tinsert = insert2;\n\t\tinsert.setLong( 1, 2 );\n\t\tinsert.setString( 2, \"another name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.execute();\n\t\tassertEquals( 1, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.release();\n\n\t\ttxn.commit();\n\t\tsession.close();\n\t}\n\n\t@Test\n\tpublic void testSessionBatchingUsage() throws Exception {\n\t\tSession session = openSession();\n\t\tsession.setJdbcBatchSize( 3 );\n\t\tSessionImplementor sessionImpl = (SessionImplementor) session;\n\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n\n\t\t// set up some tables to use\n\t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n\t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n\t\ttry {\n\t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n\t\t}\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n        jdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n\n\t\t// ok, now we can get down to it...\n\t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n\t\ttxn.begin();\n\n\t\tfinal BatchBuilder batchBuilder = new BatchBuilderImpl( 2 );\n\t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\", Expectations.BASIC );\n\t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, jdbcCoordinator );\n\t\tassertTrue( \"unexpected Batch impl\", BatchingBatch.class.isInstance( insertBatch ) );\n\n\t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n\t\tinsertBatch.addObserver( batchObserver );\n\n\t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n\n\t\tPreparedStatement insert = insertBatch.getBatchStatement( insertSql, false );\n\t\tinsert.setLong( 1, 1 );\n\t\tinsert.setString( 2, \"name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tPreparedStatement insert2 = insertBatch.getBatchStatement( insertSql, false );\n\t\tassertSame( insert, insert2 );\n\t\tinsert = insert2;\n\t\tinsert.setLong( 1, 2 );\n\t\tinsert.setString( 2, \"another name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tPreparedStatement insert3 = insertBatch.getBatchStatement( insertSql, false );\n\t\tassertSame( insert, insert3 );\n\t\tinsert = insert3;\n\t\tinsert.setLong( 1, 3 );\n\t\tinsert.setString( 2, \"yet another name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.execute();\n\t\tassertEquals( 1, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.release();\n\n\t\ttxn.commit();\n\t\tsession.close();\n\t}\n\n\t@Override\n\tprotected void cleanupTest() throws Exception {\n\t\ttry (Session session = openSession()) {\n\t\t\tsession.doWork( connection -> {\n\t\t\t\tfinal Statement stmnt = connection.createStatement();\n\n\t\t\t\tstmnt.execute( sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" ) );\n\t\t\t} );\n\t\t}\n\t}\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate exportSandboxSchema(sessionImpl SessionImplementor) : void extracted from public testBatchingUsage() : void in class org.hibernate.orm.test.jdbc.internal.BatchingTest",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/jdbc/internal/BatchingTest.java",
                "startLine": 110,
                "endLine": 178,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/jdbc/internal/BatchingTest.java",
                "startLine": 102,
                "endLine": 163,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/jdbc/internal/BatchingTest.java",
                "startLine": 304,
                "endLine": 323,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Test\n\tpublic void testBatchingUsage() throws Exception {\n\t\tSession session = openSession();\n\t\tSessionImplementor sessionImpl = (SessionImplementor) session;\n\t\t\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n\n\t\t// set up some tables to use\n\t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n\t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n\t\ttry {\n\t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n\t\t}\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n        jdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n\n\t\t// ok, now we can get down to it...\n\t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n\t\ttxn.begin();\n\n\t\tfinal BatchBuilder batchBuilder = new BatchBuilderImpl( 2 );\n\t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\", Expectations.BASIC );\n\t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, jdbcCoordinator );\n\t\tassertTrue( \"unexpected Batch impl\", BatchingBatch.class.isInstance( insertBatch ) );\n\n\t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n\t\tinsertBatch.addObserver( batchObserver );\n\n\t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n\n\t\tPreparedStatement insert = insertBatch.getBatchStatement( insertSql, false );\n\t\tinsert.setLong( 1, 1 );\n\t\tinsert.setString( 2, \"name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tPreparedStatement insert2 = insertBatch.getBatchStatement( insertSql, false );\n\t\tassertSame( insert, insert2 );\n\t\tinsert = insert2;\n\t\tinsert.setLong( 1, 2 );\n\t\tinsert.setString( 2, \"another name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.execute();\n\t\tassertEquals( 1, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.release();\n\n\t\ttxn.commit();\n\t\tsession.close();\n\t}",
        "filePathBefore": "hibernate-core/src/test/java/org/hibernate/orm/test/jdbc/internal/BatchingTest.java",
        "isPureRefactoring": true,
        "commitId": "a9ac98b364ccf52bb9cb2be5324c9c983e8bd8b3",
        "packageNameBefore": "org.hibernate.orm.test.jdbc.internal",
        "classNameBefore": "org.hibernate.orm.test.jdbc.internal.BatchingTest",
        "methodNameBefore": "org.hibernate.orm.test.jdbc.internal.BatchingTest#testBatchingUsage",
        "invokedMethod": "methodSignature: org.hibernate.action.internal.BulkOperationCleanupAction.NaturalIdCleanup#release\n methodBody: private void release() {\nnaturalIdCacheAccessStrategy.unlockRegion(cacheLock);\n}\nmethodSignature: org.hibernate.orm.test.insertordering.InsertOrderingTest.StatsBatch#addToBatch\n methodBody: public void addToBatch() {\nCounter counter=(Counter)batchSizes.get(currentBatch);\ncounter.count++;\nsuper.addToBatch();\n}\nmethodSignature: org.hibernate.engine.jdbc.spi.JdbcCoordinator#getStatementPreparer\n methodBody: StatementPreparer getStatementPreparer();\nmethodSignature: org.hibernate.engine.jdbc.spi.JdbcServices#getDialect\n methodBody: Dialect getDialect();\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\nif(sql == null){throw new IllegalArgumentException(\"sql must be non-null.\");\n}PreparedStatement statement=statements.get(sql);\nif(statement == null){statement=buildBatchStatement(sql,callable);\nstatements.put(sql,statement);\n}{LOG.debug(\"Reusing batch statement\");\nsqlStatementLogger().logStatement(sql);\n}return statement;\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#execute\n methodBody: void execute();\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.SharedBatchBuildingCode#buildBatch\n methodBody: static Batch buildBatch(final int defaultJdbcBatchSize, final BatchKey key, final JdbcCoordinator jdbcCoordinator) {\nfinal Integer sessionJdbcBatchSize=jdbcCoordinator.getJdbcSessionOwner().getJdbcBatchSize();\nfinal int jdbcBatchSizeToUse=sessionJdbcBatchSize == null ? defaultJdbcBatchSize : sessionJdbcBatchSize;\nreturn jdbcBatchSizeToUse > 1 ? new BatchingBatch(key,jdbcCoordinator,jdbcBatchSizeToUse) : new NonBatchingBatch(key,jdbcCoordinator);\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#getLogicalConnection\n methodBody: public LogicalConnectionImplementor getLogicalConnection() {\nreturn logicalConnection;\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#close\n methodBody: protected void close(ResultSet resultSet) {\nLOG.tracev(\"Closing result set [{0}]\",resultSet);\nif(resultSet instanceof InvalidatableWrapper){@SuppressWarnings(\"unchecked\") final InvalidatableWrapper<ResultSet> wrapper=(InvalidatableWrapper<ResultSet>)resultSet;\nclose(wrapper.getWrappedObject());\nwrapper.invalidate();\nreturn;\n}tryresultSet.close();\ncatch(Exception e)LOG.debugf(\"Unable to release JDBC result set [%s]\",e.getMessage());\n}\nmethodSignature: org.hibernate.query.sqm.mutation.internal.inline.InlineUpdateHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal List<Object> ids=MatchingIdSelectionHelper.selectMatchingIds(sqmUpdate,domainParameterXref,executionContext);\nif(ids == null || ids.isEmpty()){return 0;\n}domainParameterXref.clearExpansions();\nfinal MappingMetamodel domainModel=sessionFactory.getRuntimeMetamodels().getMappingMetamodel();\nfinal String mutatingEntityName=sqmUpdate.getTarget().getModel().getHibernateEntityName();\nfinal EntityPersister entityDescriptor=domainModel.getEntityDescriptor(mutatingEntityName);\nfinal String rootEntityName=entityDescriptor.getEntityPersister().getRootEntityName();\nfinal EntityPersister rootEntityDescriptor=domainModel.getEntityDescriptor(rootEntityName);\nfinal String hierarchyRootTableName=((Joinable)rootEntityDescriptor).getTableName();\nfinal List<Expression> inListExpressions=new ArrayList<>(ids.size());\nfinal EntityIdentifierMapping identifierMapping=entityDescriptor.getIdentifierMapping();\nif(identifierMapping instanceof BasicValuedModelPart){final BasicValuedModelPart basicValuedModelPart=(BasicValuedModelPart)identifierMapping;\nfor(int i=0; i < ids.size(); i++){inListExpressions.add(new QueryLiteral<>(ids.get(i),basicValuedModelPart));\n}}{final int jdbcTypeCount=identifierMapping.getJdbcTypeCount();\nfor(int i=0; i < ids.size(); i++){final Object[] id=(Object[])ids.get(i);\nfinal List<Expression> tupleElements=new ArrayList<>(jdbcTypeCount);\ninListExpressions.add(new SqlTuple(tupleElements,identifierMapping));\nidentifierMapping.forEachJdbcType((index,jdbcMapping) -> {\n  tupleElements.add(new QueryLiteral<>(id[index],(BasicValuedMapping)jdbcMapping));\n}\n);\n}}final MultiTableSqmMutationConverter converterDelegate=new MultiTableSqmMutationConverter(entityDescriptor,sqmUpdate,sqmUpdate.getTarget(),domainParameterXref,executionContext.getQueryOptions(),executionContext.getSession().getLoadQueryInfluencers(),executionContext.getQueryParameterBindings(),sessionFactory);\nfinal TableGroup updatingTableGroup=converterDelegate.getMutatingTableGroup();\nfinal TableReference hierarchyRootTableReference=updatingTableGroup.resolveTableReference(updatingTableGroup.getNavigablePath(),hierarchyRootTableName);\nassert hierarchyRootTableReference != null;\nfinal Map<SqmParameter<?>,List<List<JdbcParameter>>> parameterResolutions;\nif(domainParameterXref.getSqmParameterCount() == 0){parameterResolutions=Collections.emptyMap();\n}{parameterResolutions=new IdentityHashMap<>();\n}final List<Assignment> assignments=new ArrayList<>();\nfinal Map<SqmParameter<?>,MappingModelExpressible<?>> paramTypeResolutions=new LinkedHashMap<>();\nconverterDelegate.visitSetClause(sqmUpdate.getSetClause(),assignments::add,(sqmParameter,mappingType,jdbcParameters) -> {\n  parameterResolutions.computeIfAbsent(sqmParameter,k -> new ArrayList<>(1)).add(jdbcParameters);\n  paramTypeResolutions.put(sqmParameter,mappingType);\n}\n);\nconverterDelegate.addVersionedAssignment(assignments::add,sqmUpdate);\nfinal Predicate providedPredicate;\nfinal SqmWhereClause whereClause=sqmUpdate.getWhereClause();\nif(whereClause == null || whereClause.getPredicate() == null){providedPredicate=null;\n}{providedPredicate=converterDelegate.visitWhereClause(whereClause,columnReference -> {\n}\n,(sqmParameter,mappingType,jdbcParameters) -> {\n  parameterResolutions.computeIfAbsent(sqmParameter,k -> new ArrayList<>(1)).add(jdbcParameters);\n  paramTypeResolutions.put(sqmParameter,mappingType);\n}\n);\nassert providedPredicate != null;\n}final PredicateCollector predicateCollector=new PredicateCollector(providedPredicate);\nentityDescriptor.applyBaseRestrictions(predicateCollector::applyPredicate,updatingTableGroup,true,executionContext.getSession().getLoadQueryInfluencers().getEnabledFilters(),null,converterDelegate);\nconverterDelegate.pruneTableGroupJoins();\nfinal Map<String,TableReference> tableReferenceByAlias=CollectionHelper.mapOfSize(updatingTableGroup.getTableReferenceJoins().size() + 1);\ncollectTableReference(updatingTableGroup.getPrimaryTableReference(),tableReferenceByAlias::put);\nfor(int i=0; i < updatingTableGroup.getTableReferenceJoins().size(); i++){collectTableReference(updatingTableGroup.getTableReferenceJoins().get(i),tableReferenceByAlias::put);\n}final JdbcParameterBindings jdbcParameterBindings=SqmUtil.createJdbcParameterBindings(executionContext.getQueryParameterBindings(),domainParameterXref,SqmUtil.generateJdbcParamsXref(domainParameterXref,() -> parameterResolutions),sessionFactory.getRuntimeMetamodels().getMappingMetamodel(),navigablePath -> updatingTableGroup,new SqmParameterMappingModelResolutionAccess(){\n  @Override @SuppressWarnings(\"unchecked\") public <T>MappingModelExpressible<T> getResolvedMappingModelType(  SqmParameter<T> parameter){\n    return (MappingModelExpressible<T>)paramTypeResolutions.get(parameter);\n  }\n}\n,executionContext.getSession());\nfinal Map<TableReference,List<Assignment>> assignmentsByTable=new HashMap<>();\nfor(int i=0; i < assignments.size(); i++){final Assignment assignment=assignments.get(i);\nfinal List<ColumnReference> assignmentColumnRefs=assignment.getAssignable().getColumnReferences();\nTableReference assignmentTableReference=null;\nfor(int c=0; c < assignmentColumnRefs.size(); c++){final ColumnReference columnReference=assignmentColumnRefs.get(c);\nfinal TableReference tableReference=resolveTableReference(columnReference,tableReferenceByAlias);\nif(assignmentTableReference != null && assignmentTableReference != tableReference){throw new SemanticException(\"Assignment referred to columns from multiple tables: \" + assignment.getAssignable());\n}assignmentTableReference=tableReference;\n}List<Assignment> assignmentsForTable=assignmentsByTable.get(assignmentTableReference);\nif(assignmentsForTable == null){assignmentsForTable=new ArrayList<>();\nassignmentsByTable.put(assignmentTableReference,assignmentsForTable);\n}assignmentsForTable.add(assignment);\n}final int rows=ids.size();\nfinal SqmJdbcExecutionContextAdapter executionContextAdapter=SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext);\nentityDescriptor.visitConstraintOrderedTables((tableExpression,tableKeyColumnVisitationSupplier) -> updateTable(tableExpression,tableKeyColumnVisitationSupplier,entityDescriptor,updatingTableGroup,assignmentsByTable,inListExpressions,rows,jdbcParameterBindings,executionContextAdapter));\nreturn rows;\n}\nmethodSignature: org.hibernate.dialect.AbstractHANADialect.CloseSuppressingInputStream#close\n methodBody: public void close() {\n}\nmethodSignature: org.hibernate.query.sqm.mutation.internal.inline.InlineDeleteHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal List<Object> idsAndFks=MatchingIdSelectionHelper.selectMatchingIds(sqmDeleteStatement,domainParameterXref,executionContext);\nif(idsAndFks == null || idsAndFks.isEmpty()){return 0;\n}final SessionFactoryImplementor factory=executionContext.getSession().getFactory();\nfinal String mutatingEntityName=sqmDeleteStatement.getTarget().getModel().getHibernateEntityName();\nfinal EntityMappingType entityDescriptor=factory.getRuntimeMetamodels().getEntityMappingType(mutatingEntityName);\nfinal JdbcParameterBindings jdbcParameterBindings=new JdbcParameterBindingsImpl(domainParameterXref.getQueryParameterCount());\nfinal MutableInteger valueIndexCounter=new MutableInteger();\nSqmMutationStrategyHelper.visitCollectionTables(entityDescriptor,pluralAttribute -> {\n  if (pluralAttribute.getSeparateCollectionTable() != null) {\n    final ModelPart fkTargetPart=pluralAttribute.getKeyDescriptor().getTargetPart();\n    final int valueIndex;\n    if (fkTargetPart instanceof EntityIdentifierMapping) {\n      valueIndex=0;\n    }\n else {\n      if (valueIndexCounter.get() == 0) {\n        valueIndexCounter.set(entityDescriptor.getIdentifierMapping().getJdbcTypeCount());\n      }\n      valueIndex=valueIndexCounter.get();\n      valueIndexCounter.plus(fkTargetPart.getJdbcTypeCount());\n    }\n    executeDelete(pluralAttribute.getSeparateCollectionTable(),entityDescriptor,() -> fkTargetPart::forEachSelectable,idsAndFks,valueIndex,fkTargetPart,jdbcParameterBindings,executionContext);\n  }\n}\n);\nentityDescriptor.visitConstraintOrderedTables((tableExpression,tableKeyColumnsVisitationSupplier) -> {\n  executeDelete(tableExpression,entityDescriptor,tableKeyColumnsVisitationSupplier,idsAndFks,0,null,jdbcParameterBindings,executionContext);\n}\n);\nreturn idsAndFks.size();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#hasRegisteredResources\n methodBody: private boolean hasRegisteredResources() {\nreturn getLogicalConnection().getResourceRegistry().hasRegisteredResources();\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#release\n methodBody: void release();\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.UnmodifiableBatchBuilderImpl#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn SharedBatchBuildingCode.buildBatch(jdbcBatchSize,key,jdbcCoordinator);\n}\nmethodSignature: org.hibernate.persister.entity.AbstractEntityPersister#isInstance\n methodBody: public boolean isInstance(Object object) {\nreturn getRepresentationStrategy().getInstantiator().isInstance(object,getFactory());\n}\nmethodSignature: org.hibernate.orm.test.jpa.transaction.batch.JtaWithFailingBatchTest.TestBatch#addToBatch\n methodBody: public void addToBatch() {\nthrow sqlExceptionHelper().convert(new SQLException(\"fake SQLException\"),\"could not perform addBatch\",currentStatementSql);\n}\nmethodSignature: org.hibernate.action.internal.BulkOperationCleanupAction#execute\n methodBody: public void execute() throws HibernateException {\n}\nmethodSignature: org.hibernate.orm.test.jpa.transaction.batch.JtaWithFailingBatchTest.TestBatch#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\ncurrentStatementSql=sql;\nPreparedStatement batchStatement=super.getBatchStatement(sql,callable);\ncreatedStatements.add(batchStatement);\nreturn batchStatement;\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.spi.BatchBuilder#buildBatch\n methodBody: Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator);\nmethodSignature: org.hibernate.procedure.internal.ProcedureCallImpl#execute\n methodBody: public boolean execute() {\ntryreturn outputs().getCurrent() instanceof ResultSetOutput;\ncatch(NoMoreOutputsException e)return false;\ncatch(HibernateException he)throw getSession().getExceptionConverter().convert(he);\ncatch(RuntimeException e)getSession().markForRollbackOnly();\nthrow e;\n}\nmethodSignature: org.hibernate.query.sqm.mutation.internal.cte.CteInsertHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal SqmInsertStatement<?> sqmInsertStatement=getSqmStatement();\nfinal SessionFactoryImplementor factory=executionContext.getSession().getFactory();\nfinal EntityPersister entityDescriptor=getEntityDescriptor().getEntityPersister();\nfinal String explicitDmlTargetAlias;\nif(sqmInsertStatement.getTarget().getExplicitAlias() == null){explicitDmlTargetAlias=\"dml_target\";\n}{explicitDmlTargetAlias=sqmInsertStatement.getTarget().getExplicitAlias();\n}final MultiTableSqmMutationConverter sqmConverter=new MultiTableSqmMutationConverter(entityDescriptor,sqmInsertStatement,sqmInsertStatement.getTarget(),explicitDmlTargetAlias,domainParameterXref,executionContext.getQueryOptions(),executionContext.getSession().getLoadQueryInfluencers(),executionContext.getQueryParameterBindings(),factory);\nfinal TableGroup insertingTableGroup=sqmConverter.getMutatingTableGroup();\nfinal Map<SqmParameter<?>,List<List<JdbcParameter>>> parameterResolutions;\nif(domainParameterXref.getSqmParameterCount() == 0){parameterResolutions=Collections.emptyMap();\n}{parameterResolutions=new IdentityHashMap<>();\n}final int size=sqmStatement.getInsertionTargetPaths().size();\nfinal List<Map.Entry<List<CteColumn>,Assignment>> targetPathColumns=new ArrayList<>(size);\nfinal List<CteColumn> targetPathCteColumns=new ArrayList<>(size);\nfinal Map<SqmParameter<?>,MappingModelExpressible<?>> paramTypeResolutions=new LinkedHashMap<>();\nfinal NamedTableReference entityTableReference=new NamedTableReference(cteTable.getTableExpression(),TemporaryTable.DEFAULT_ALIAS,true,sessionFactory);\nfinal InsertStatement insertStatement=new InsertStatement(entityTableReference);\nfinal BaseSqmToSqlAstConverter.AdditionalInsertValues additionalInsertValues=sqmConverter.visitInsertionTargetPaths((assignable,columnReferences) -> {\n  final SqmPathInterpretation<?> pathInterpretation=(SqmPathInterpretation<?>)assignable;\n  final int offset=CteTable.determineModelPartStartIndex(entityDescriptor,pathInterpretation.getExpressionType());\n  if (offset == -1) {\n    throw new IllegalStateException(\"Couldn't find matching cte column for: \" + ((Expression)assignable).getExpressionType());\n  }\n  final int end=offset + pathInterpretation.getExpressionType().getJdbcTypeCount();\n  final List<CteColumn> columns=cteTable.getCteColumns().subList(offset,end);\n  insertStatement.addTargetColumnReferences(columnReferences);\n  targetPathCteColumns.addAll(columns);\n  targetPathColumns.add(new AbstractMap.SimpleEntry<>(columns,new Assignment(assignable,(Expression)assignable)));\n}\n,sqmInsertStatement,entityDescriptor,insertingTableGroup,(sqmParameter,mappingType,jdbcParameters) -> {\n  parameterResolutions.computeIfAbsent(sqmParameter,k -> new ArrayList<>(1)).add(jdbcParameters);\n  paramTypeResolutions.put(sqmParameter,mappingType);\n}\n);\nfinal boolean assignsId=targetPathCteColumns.contains(cteTable.getCteColumns().get(0));\nfinal Stack<SqlAstProcessingState> processingStateStack=sqmConverter.getProcessingStateStack();\nfinal SqlAstProcessingState oldState=processingStateStack.pop();\nfinal Statement queryStatement;\nif(sqmInsertStatement instanceof SqmInsertSelectStatement){final QueryPart queryPart=sqmConverter.visitQueryPart(((SqmInsertSelectStatement<?>)sqmInsertStatement).getSelectQueryPart());\nqueryPart.visitQuerySpecs(querySpec -> {\n  if (additionalInsertValues.applySelections(querySpec,sessionFactory)) {\n    final CteColumn rowNumberColumn=cteTable.getCteColumns().get(cteTable.getCteColumns().size() - 1);\n    final ColumnReference columnReference=new ColumnReference((String)null,rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping());\n    insertStatement.getTargetColumnReferences().set(insertStatement.getTargetColumnReferences().size() - 1,columnReference);\n    targetPathCteColumns.set(targetPathCteColumns.size() - 1,rowNumberColumn);\n  }\n  if (!assignsId && entityDescriptor.getIdentifierGenerator() instanceof PostInsertIdentifierGenerator) {\n    querySpec.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,SqmInsertStrategyHelper.createRowNumberingExpression(querySpec,sessionFactory)));\n  }\n}\n);\nqueryStatement=new SelectStatement(queryPart);\n}{final List<SqmValues> sqmValuesList=((SqmInsertValuesStatement<?>)sqmInsertStatement).getValuesList();\nfinal List<Values> valuesList=new ArrayList<>(sqmValuesList.size());\nfor(SqmValues sqmValues: sqmValuesList){final Values values=sqmConverter.visitValues(sqmValues);\nadditionalInsertValues.applyValues(values);\nvaluesList.add(values);\n}final QuerySpec querySpec=new QuerySpec(true);\nfinal NavigablePath navigablePath=new NavigablePath(entityDescriptor.getRootPathName());\nfinal List<String> columnNames=new ArrayList<>(targetPathColumns.size());\nfinal String valuesAlias=insertingTableGroup.getPrimaryTableReference().getIdentificationVariable();\nfor(Map.Entry<List<CteColumn>,Assignment> entry: targetPathColumns){for(ColumnReference columnReference: entry.getValue().getAssignable().getColumnReferences()){columnNames.add(columnReference.getColumnExpression());\nquerySpec.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,columnReference.getQualifier().equals(valuesAlias) ? columnReference : new ColumnReference(valuesAlias,columnReference.getColumnExpression(),false,null,null,columnReference.getJdbcMapping())));\n}}final ValuesTableGroup valuesTableGroup=new ValuesTableGroup(navigablePath,entityDescriptor.getEntityPersister(),valuesList,insertingTableGroup.getPrimaryTableReference().getIdentificationVariable(),columnNames,true,factory);\nquerySpec.getFromClause().addRoot(valuesTableGroup);\nqueryStatement=new SelectStatement(querySpec);\n}processingStateStack.push(oldState);\nsqmConverter.pruneTableGroupJoins();\nif(!assignsId && entityDescriptor.getIdentifierGenerator() instanceof PostInsertIdentifierGenerator){final CteColumn rowNumberColumn=cteTable.getCteColumns().get(cteTable.getCteColumns().size() - 1);\nfinal ColumnReference columnReference=new ColumnReference((String)null,rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping());\ninsertStatement.getTargetColumnReferences().add(columnReference);\ntargetPathCteColumns.add(rowNumberColumn);\n}final CteTable entityCteTable=createCteTable(getCteTable(),targetPathCteColumns,factory);\nfinal QuerySpec querySpec=new QuerySpec(true,1);\nfinal List<DomainResult<?>> domainResults=new ArrayList<>(1);\nfinal SelectStatement statement=new SelectStatement(querySpec,domainResults);\nfinal CteStatement entityCte;\nif(additionalInsertValues.requiresRowNumberIntermediate()){final CteTable fullEntityCteTable=getCteTable();\nfinal String baseTableName=\"base_\" + entityCteTable.getTableExpression();\nfinal CteStatement baseEntityCte=new CteStatement(entityCteTable.withName(baseTableName),queryStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(baseEntityCte);\nfinal CteColumn rowNumberColumn=fullEntityCteTable.getCteColumns().get(fullEntityCteTable.getCteColumns().size() - 1);\nfinal ColumnReference rowNumberColumnReference=new ColumnReference(\"e\",rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping());\nfinal CteColumn idColumn=fullEntityCteTable.getCteColumns().get(0);\nfinal BasicValuedMapping idType=(BasicValuedMapping)idColumn.getJdbcMapping();\nfinal Optimizer optimizer=((OptimizableGenerator)entityDescriptor.getIdentifierGenerator()).getOptimizer();\nfinal BasicValuedMapping integerType=(BasicValuedMapping)rowNumberColumn.getJdbcMapping();\nfinal Expression rowNumberMinusOneModuloIncrement=new BinaryArithmeticExpression(new BinaryArithmeticExpression(rowNumberColumnReference,BinaryArithmeticOperator.SUBTRACT,new QueryLiteral<>(1,(BasicValuedMapping)rowNumberColumn.getJdbcMapping()),integerType),BinaryArithmeticOperator.MODULO,new QueryLiteral<>(optimizer.getIncrementSize(),integerType),integerType);\n{final QuerySpec rowsWithSequenceQuery=new QuerySpec(true);\nrowsWithSequenceQuery.getFromClause().addRoot(new CteTableGroup(new NamedTableReference(baseTableName,\"e\",false,factory)));\nrowsWithSequenceQuery.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,rowNumberColumnReference));\nfinal String fragment=((BulkInsertionCapableIdentifierGenerator)entityDescriptor.getIdentifierGenerator()).determineBulkInsertionIdentifierGenerationSelectFragment(sessionFactory.getSqlStringGenerationContext());\nrowsWithSequenceQuery.getSelectClause().addSqlSelection(new SqlSelectionImpl(2,1,new SelfRenderingSqlFragmentExpression(fragment)));\nrowsWithSequenceQuery.applyPredicate(new ComparisonPredicate(rowNumberMinusOneModuloIncrement,ComparisonOperator.EQUAL,new QueryLiteral<>(0,integerType)));\nfinal CteTable rowsWithSequenceCteTable=new CteTable(ROW_NUMBERS_WITH_SEQUENCE_VALUE,List.of(rowNumberColumn,idColumn));\nfinal SelectStatement rowsWithSequenceStatement=new SelectStatement(rowsWithSequenceQuery);\nfinal CteStatement rowsWithSequenceCte=new CteStatement(rowsWithSequenceCteTable,rowsWithSequenceStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(rowsWithSequenceCte);\n}{final QuerySpec entityQuery=new QuerySpec(true);\nfinal NavigablePath navigablePath=new NavigablePath(baseTableName);\nfinal TableGroup baseTableGroup=new TableGroupImpl(navigablePath,null,new NamedTableReference(baseTableName,\"e\",false,factory),null);\nfinal TableGroup rowsWithSequenceTableGroup=new CteTableGroup(new NamedTableReference(ROW_NUMBERS_WITH_SEQUENCE_VALUE,\"t\",false,factory));\nbaseTableGroup.addTableGroupJoin(new TableGroupJoin(rowsWithSequenceTableGroup.getNavigablePath(),SqlAstJoinType.LEFT,rowsWithSequenceTableGroup,new ComparisonPredicate(new BinaryArithmeticExpression(rowNumberColumnReference,BinaryArithmeticOperator.SUBTRACT,rowNumberMinusOneModuloIncrement,integerType),ComparisonOperator.EQUAL,new ColumnReference(\"t\",rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping()))));\nentityQuery.getFromClause().addRoot(baseTableGroup);\nentityQuery.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,new BinaryArithmeticExpression(new ColumnReference(\"t\",idColumn.getColumnExpression(),false,null,null,idColumn.getJdbcMapping()),BinaryArithmeticOperator.ADD,new BinaryArithmeticExpression(rowNumberColumnReference,BinaryArithmeticOperator.SUBTRACT,new ColumnReference(\"t\",rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping()),integerType),idType)));\nfinal CteTable finalEntityCteTable;\nif(targetPathCteColumns.contains(getCteTable().getCteColumns().get(0))){finalEntityCteTable=entityCteTable;\n}{targetPathCteColumns.add(0,getCteTable().getCteColumns().get(0));\nfinalEntityCteTable=createCteTable(getCteTable(),targetPathCteColumns,factory);\n}final List<CteColumn> cteColumns=finalEntityCteTable.getCteColumns();\nfor(int i=1; i < cteColumns.size(); i++){final CteColumn cteColumn=cteColumns.get(i);\nentityQuery.getSelectClause().addSqlSelection(new SqlSelectionImpl(i + 1,i,new ColumnReference(\"e\",cteColumn.getColumnExpression(),false,null,null,cteColumn.getJdbcMapping())));\n}final SelectStatement entityStatement=new SelectStatement(entityQuery);\nentityCte=new CteStatement(finalEntityCteTable,entityStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(entityCte);\n}}if(!assignsId && entityDescriptor.getIdentifierGenerator() instanceof PostInsertIdentifierGenerator){final String baseTableName=\"base_\" + entityCteTable.getTableExpression();\nfinal CteStatement baseEntityCte=new CteStatement(entityCteTable.withName(baseTableName),queryStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(baseEntityCte);\ntargetPathCteColumns.add(0,cteTable.getCteColumns().get(0));\nfinal CteTable finalEntityCteTable=createCteTable(getCteTable(),targetPathCteColumns,factory);\nfinal QuerySpec finalQuerySpec=new QuerySpec(true);\nfinal SelectStatement finalQueryStatement=new SelectStatement(finalQuerySpec);\nentityCte=new CteStatement(finalEntityCteTable,finalQueryStatement,CteMaterialization.MATERIALIZED);\n}{entityCte=new CteStatement(entityCteTable,queryStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(entityCte);\n}final String baseInsertCte=addDmlCtes(statement,entityCte,targetPathColumns,assignsId,sqmConverter,parameterResolutions,factory);\nfinal Expression count=createCountStar(factory,sqmConverter);\ndomainResults.add(new BasicResult<>(0,null,((SqlExpressible)count).getJdbcMapping()));\nquerySpec.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,count));\nquerySpec.getFromClause().addRoot(new CteTableGroup(new NamedTableReference(baseInsertCte,CTE_TABLE_IDENTIFIER,false,factory)));\nfinal JdbcServices jdbcServices=factory.getJdbcServices();\nfinal SqlAstTranslator<JdbcSelect> translator=jdbcServices.getJdbcEnvironment().getSqlAstTranslatorFactory().buildSelectTranslator(factory,statement);\nfinal JdbcParameterBindings jdbcParameterBindings=SqmUtil.createJdbcParameterBindings(executionContext.getQueryParameterBindings(),domainParameterXref,SqmUtil.generateJdbcParamsXref(domainParameterXref,sqmConverter),factory.getRuntimeMetamodels().getMappingMetamodel(),navigablePath -> sqmConverter.getMutatingTableGroup(),new SqmParameterMappingModelResolutionAccess(){\n  @Override @SuppressWarnings(\"unchecked\") public <T>MappingModelExpressible<T> getResolvedMappingModelType(  SqmParameter<T> parameter){\n    return (MappingModelExpressible<T>)paramTypeResolutions.get(parameter);\n  }\n}\n,executionContext.getSession());\nfinal JdbcSelect select=translator.translate(jdbcParameterBindings,executionContext.getQueryOptions());\nexecutionContext.getSession().autoFlushIfRequired(select.getAffectedTableNames());\nList<Object> list=jdbcServices.getJdbcSelectExecutor().list(select,jdbcParameterBindings,SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext),row -> row[0],ListResultsConsumer.UniqueSemantic.NONE);\nreturn ((Number)list.get(0)).intValue();\n}\nmethodSignature: org.hibernate.query.sqm.mutation.internal.temptable.InsertExecutionDelegate#execute\n methodBody: public int execute(ExecutionContext executionContext) {\nExecuteWithTemporaryTableHelper.performBeforeTemporaryTableUseActions(entityTable,executionContext);\ntryif(sessionUidParameter != null){jdbcParameterBindings.addBinding(sessionUidParameter,new JdbcParameterBindingImpl(entityTable.getSessionUidColumn().getJdbcMapping(),UUID.fromString(sessionUidAccess.apply(executionContext.getSession()))));\n}final int rows=ExecuteWithTemporaryTableHelper.saveIntoTemporaryTable(insertStatement,jdbcParameterBindings,executionContext);\nif(rows != 0){final AbstractEntityPersister persister=(AbstractEntityPersister)entityDescriptor.getEntityPersister();\nfinal int tableSpan=persister.getTableSpan();\ninsertRootTable(persister.getTableName(0),rows,persister.getKeyColumns(0),executionContext);\nif(persister.hasDuplicateTables()){final String[] insertedTables=new String[tableSpan];\ninsertedTables[0]=persister.getTableName(0);\nfor(int i=1; i < tableSpan; i++){if(persister.isInverseTable(i)){continue;\n}final String tableName=persister.getTableName(i);\ninsertedTables[i]=tableName;\nif(ArrayHelper.indexOf(insertedTables,i,tableName) != -1){continue;\n}insertTable(tableName,persister.getKeyColumns(i),persister.isNullableTable(i),executionContext);\n}}{for(int i=1; i < tableSpan; i++){insertTable(persister.getTableName(i),persister.getKeyColumns(i),persister.isNullableTable(i),executionContext);\n}}}return rows;\nfinallyExecuteWithTemporaryTableHelper.performAfterTemporaryTableUseActions(entityTable,sessionUidAccess,afterUseAction,executionContext);\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#getResultSetReturn\n methodBody: public ResultSetReturn getResultSetReturn() {\nif(resultSetExtractor == null){resultSetExtractor=new ResultSetReturnImpl(this,jdbcServices);\n}return resultSetExtractor;\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#addObserver\n methodBody: void addObserver(BatchObserver observer);\nmethodSignature: org.hibernate.query.sqm.mutation.internal.temptable.UpdateExecutionDelegate#execute\n methodBody: public int execute(ExecutionContext executionContext) {\nExecuteWithTemporaryTableHelper.performBeforeTemporaryTableUseActions(idTable,executionContext);\ntryfinal int rows=ExecuteWithTemporaryTableHelper.saveMatchingIdsIntoIdTable(sqmConverter,suppliedPredicate,idTable,sessionUidAccess,jdbcParameterBindings,executionContext);\nfinal QuerySpec idTableSubQuery=ExecuteWithTemporaryTableHelper.createIdTableSelectQuerySpec(idTable,sessionUidAccess,entityDescriptor,executionContext);\nentityDescriptor.visitConstraintOrderedTables((tableExpression,tableKeyColumnVisitationSupplier) -> updateTable(tableExpression,tableKeyColumnVisitationSupplier,rows,idTableSubQuery,executionContext));\nreturn rows;\nfinallyExecuteWithTemporaryTableHelper.performAfterTemporaryTableUseActions(idTable,sessionUidAccess,afterUseAction,executionContext);\n}\nmethodSignature: org.hibernate.metamodel.mapping.internal.MappingModelCreationProcess#execute\n methodBody: private void execute() {\nfor(EntityPersister entityPersister: entityPersisterMap.values()){if(entityPersister instanceof InFlightEntityMappingType){((InFlightEntityMappingType)entityPersister).linkWithSuperType(this);\n}}for(EntityPersister entityPersister: entityPersisterMap.values()){currentlyProcessingRole=entityPersister.getEntityName();\nif(entityPersister instanceof InFlightEntityMappingType){((InFlightEntityMappingType)entityPersister).prepareMappingModel(this);\n}}executePostInitCallbacks();\n}\nmethodSignature: org.hibernate.orm.test.insertordering.InsertOrderingTest.StatsBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn new StatsBatch(key,jdbcCoordinator,getJdbcBatchSize());\n}\nmethodSignature: org.hibernate.query.sqm.mutation.internal.cte.AbstractCteMutationHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal SqmDeleteOrUpdateStatement sqmMutationStatement=getSqmDeleteOrUpdateStatement();\nfinal SessionFactoryImplementor factory=executionContext.getSession().getFactory();\nfinal EntityMappingType entityDescriptor=getEntityDescriptor();\nfinal String explicitDmlTargetAlias;\nif(sqmMutationStatement.getTarget().getExplicitAlias() == null){explicitDmlTargetAlias=\"dml_target\";\n}{explicitDmlTargetAlias=sqmMutationStatement.getTarget().getExplicitAlias();\n}final MultiTableSqmMutationConverter sqmConverter=new MultiTableSqmMutationConverter(entityDescriptor,sqmMutationStatement,sqmMutationStatement.getTarget(),explicitDmlTargetAlias,domainParameterXref,executionContext.getQueryOptions(),executionContext.getSession().getLoadQueryInfluencers(),executionContext.getQueryParameterBindings(),factory);\nfinal Map<SqmParameter<?>,List<JdbcParameter>> parameterResolutions;\nif(domainParameterXref.getSqmParameterCount() == 0){parameterResolutions=Collections.emptyMap();\n}{parameterResolutions=new IdentityHashMap<>();\n}final Map<SqmParameter,MappingModelExpressible> paramTypeResolutions=new LinkedHashMap<>();\nfinal Predicate restriction=sqmConverter.visitWhereClause(sqmMutationStatement.getWhereClause(),columnReference -> {\n}\n,(sqmParam,mappingType,jdbcParameters) -> paramTypeResolutions.put(sqmParam,mappingType));\nsqmConverter.pruneTableGroupJoins();\nfinal CteStatement idSelectCte=new CteStatement(getCteTable(),MatchingIdSelectionHelper.generateMatchingIdSelectStatement(entityDescriptor,sqmMutationStatement,true,restriction,sqmConverter,executionContext,factory),CteMaterialization.MATERIALIZED);\nfinal QuerySpec querySpec=new QuerySpec(true,1);\nfinal List<DomainResult<?>> domainResults=new ArrayList<>(1);\nfinal SelectStatement statement=new SelectStatement(querySpec,domainResults);\nfinal JdbcServices jdbcServices=factory.getJdbcServices();\nfinal SqlAstTranslator<JdbcSelect> translator=jdbcServices.getJdbcEnvironment().getSqlAstTranslatorFactory().buildSelectTranslator(factory,statement);\nfinal Expression count=createCountStar(factory,sqmConverter);\ndomainResults.add(new BasicResult<>(0,null,((SqlExpressible)count).getJdbcMapping()));\nquerySpec.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,count));\nquerySpec.getFromClause().addRoot(new CteTableGroup(new NamedTableReference(idSelectCte.getCteTable().getTableExpression(),CTE_TABLE_IDENTIFIER,false,factory)));\nstatement.addCteStatement(idSelectCte);\naddDmlCtes(statement,idSelectCte,sqmConverter,parameterResolutions,factory);\nfinal JdbcParameterBindings jdbcParameterBindings=SqmUtil.createJdbcParameterBindings(executionContext.getQueryParameterBindings(),domainParameterXref,SqmUtil.generateJdbcParamsXref(domainParameterXref,sqmConverter),factory.getRuntimeMetamodels().getMappingMetamodel(),navigablePath -> sqmConverter.getMutatingTableGroup(),paramTypeResolutions::get,executionContext.getSession());\nfinal LockOptions lockOptions=executionContext.getQueryOptions().getLockOptions();\nfinal LockMode lockMode=lockOptions.getAliasSpecificLockMode(explicitDmlTargetAlias);\nlockOptions.setAliasSpecificLockMode(explicitDmlTargetAlias,LockMode.WRITE);\nfinal JdbcSelect select=translator.translate(jdbcParameterBindings,executionContext.getQueryOptions());\nlockOptions.setAliasSpecificLockMode(explicitDmlTargetAlias,lockMode);\nexecutionContext.getSession().autoFlushIfRequired(select.getAffectedTableNames());\nList<Object> list=jdbcServices.getJdbcSelectExecutor().list(select,jdbcParameterBindings,SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext),row -> row[0],ListResultsConsumer.UniqueSemantic.NONE);\nreturn ((Number)list.get(0)).intValue();\n}\nmethodSignature: org.hibernate.mapping.Component.ValueGenerationPlan#execute\n methodBody: public void execute(SharedSessionContractImplementor session, Object incomingObject, Object injectionContext) {\nfinal Object generatedValue=subGenerator.generate(session,incomingObject);\ninjector.set(injectionContext,generatedValue);\n}\nmethodSignature: org.hibernate.query.sqm.mutation.internal.temptable.TableBasedInsertHandler.ExecutionDelegate#execute\n methodBody: int execute(ExecutionContext executionContext);\nmethodSignature: org.hibernate.dialect.AbstractHANADialect.MaterializedNClob#setString\n methodBody: public int setString(long pos, String str) throws SQLException {\nthis.data=this.data.substring(0,(int)(pos - 1)) + str + this.data.substring((int)(pos - 1 + str.length()));\nreturn str.length();\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch#addToBatch\n methodBody: public void addToBatch() {\nnotifyObserversImplicitExecution();\nfor(Map.Entry<String,PreparedStatement> entry: getStatements().entrySet()){final String statementSQL=entry.getKey();\ntryfinal PreparedStatement statement=entry.getValue();\nfinal int rowCount=jdbcCoordinator.getResultSetReturn().executeUpdate(statement);\ngetKey().getExpectation().verifyOutcome(rowCount,statement,0,statementSQL);\njdbcCoordinator.getLogicalConnection().getResourceRegistry().release(statement);\njdbcCoordinator.afterStatementExecution();\ncatch(SQLException e)abortBatch(e);\nthrow sqlExceptionHelper().convert(e,\"could not execute non-batched batch statement\",statementSQL);\ncatch(RuntimeException e)abortBatch(e);\nthrow e;\n}getStatements().clear();\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#getStatementPreparer\n methodBody: public StatementPreparer getStatementPreparer() {\nif(statementPreparer == null){statementPreparer=new StatementPreparerImpl(this,jdbcServices);\n}return statementPreparer;\n}\nmethodSignature: org.hibernate.sql.Insert#getDialect\n methodBody: protected Dialect getDialect() {\nreturn dialect;\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#release\n methodBody: public void release() {\nif(getStatements() != null && !getStatements().isEmpty()){LOG.batchContainedStatementsOnRelease();\n}releaseStatements();\nobservers.clear();\n}\nmethodSignature: org.hibernate.sql.exec.internal.StandardJdbcMutationExecutor#execute\n methodBody: public int execute(\n\t\t\tJdbcMutation jdbcMutation,\n\t\t\tJdbcParameterBindings jdbcParameterBindings,\n\t\t\tFunction<String, PreparedStatement> statementCreator,\n\t\t\tBiConsumer<Integer, PreparedStatement> expectationCheck,\n\t\t\tExecutionContext executionContext) {\nfinal SharedSessionContractImplementor session=executionContext.getSession();\nsession.autoFlushIfRequired(jdbcMutation.getAffectedTableNames());\nfinal LogicalConnectionImplementor logicalConnection=session.getJdbcCoordinator().getLogicalConnection();\nfinal JdbcServices jdbcServices=session.getJdbcServices();\nfinal QueryOptions queryOptions=executionContext.getQueryOptions();\nfinal String finalSql;\nif(queryOptions == null){finalSql=jdbcMutation.getSql();\n}{finalSql=jdbcServices.getDialect().addSqlHintOrComment(jdbcMutation.getSql(),queryOptions,executionContext.getSession().getFactory().getSessionFactoryOptions().isCommentsEnabled());\n}tryfinal PreparedStatement preparedStatement=statementCreator.apply(finalSql);\ntryif(executionContext.getQueryOptions().getTimeout() != null){preparedStatement.setQueryTimeout(executionContext.getQueryOptions().getTimeout());\n}int paramBindingPosition=1;\nfor(JdbcParameterBinder parameterBinder: jdbcMutation.getParameterBinders()){parameterBinder.bindParameterValue(preparedStatement,paramBindingPosition++,jdbcParameterBindings,executionContext);\n}session.getEventListenerManager().jdbcExecuteStatementStart();\ntryint rows=preparedStatement.executeUpdate();\nexpectationCheck.accept(rows,preparedStatement);\nreturn rows;\nfinallysession.getEventListenerManager().jdbcExecuteStatementEnd();\nfinallylogicalConnection.getResourceRegistry().release(preparedStatement);\ncatch(SQLException e)throw jdbcServices.getSqlExceptionHelper().convert(e,\"JDBC exception executing SQL [\" + finalSql + \"]\");\nfinallyexecutionContext.afterStatement(logicalConnection);\n}\nmethodSignature: org.hibernate.sql.exec.spi.JdbcMutationExecutor#execute\n methodBody: int execute(\n\t\t\tJdbcMutation jdbcMutation,\n\t\t\tJdbcParameterBindings jdbcParameterBindings,\n\t\t\tFunction<String, PreparedStatement> statementCreator,\n\t\t\tBiConsumer<Integer, PreparedStatement> expectationCheck,\n\t\t\tExecutionContext executionContext);\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#addObserver\n methodBody: public void addObserver(BatchObserver observer) {\nobservers.add(observer);\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.BatchingBatch#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\ncurrentStatementSql=sql;\nint previousBatchSize=getStatements().size();\ncurrentStatement=super.getBatchStatement(sql,callable);\nint currentBatchSize=getStatements().size();\nif(currentBatchSize > previousBatchSize){this.batchSize=this.configuredBatchSize * currentBatchSize;\n}return currentStatement;\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#getBatchStatement\n methodBody: PreparedStatement getBatchStatement(String sql, boolean callable);\nmethodSignature: org.hibernate.engine.jdbc.spi.JdbcCoordinator#close\n methodBody: Connection close();\nmethodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#addToBatch\n methodBody: void addToBatch();\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.BatchingBatch#addToBatch\n methodBody: public void addToBatch() {\ntrycurrentStatement.addBatch();\ncatch(SQLException e)abortBatch(e);\nLOG.debug(\"SQLException escaped proxy\",e);\nthrow sqlExceptionHelper().convert(e,\"could not perform addBatch\",currentStatementSql);\ncatch(RuntimeException e)abortBatch(e);\nthrow e;\nstatementPosition++;\nif(statementPosition >= getKey().getBatchedStatementCount()){batchPosition++;\nif(batchPosition == batchSize){notifyObserversImplicitExecution();\nperformExecution();\nbatchPosition=0;\nbatchExecuted=true;\n}statementPosition=0;\n}}\nmethodSignature: org.hibernate.action.internal.BulkOperationCleanupAction.CollectionCleanup#release\n methodBody: private void release() {\ncacheAccess.unlockRegion(cacheLock);\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#execute\n methodBody: public final void execute() {\nnotifyObserversExplicitExecution();\nif(getStatements().isEmpty()){return;\n}trydoExecuteBatch();\nfinallyreleaseStatements();\n}\nmethodSignature: org.hibernate.action.internal.BulkOperationCleanupAction.EntityCleanup#release\n methodBody: private void release() {\ncacheAccess.unlockRegion(cacheLock);\n}\nmethodSignature: org.hibernate.sql.results.jdbc.internal.DeferredResultSetAccess#release\n methodBody: public void release() {\nif(resultSet != null){getPersistenceContext().getJdbcCoordinator().getLogicalConnection().getResourceRegistry().release(resultSet,preparedStatement);\nresultSet=null;\n}if(preparedStatement != null){getPersistenceContext().getJdbcCoordinator().getLogicalConnection().getResourceRegistry().release(preparedStatement);\npreparedStatement=null;\n}}\nmethodSignature: org.hibernate.query.sqm.mutation.internal.temptable.RestrictedDeleteExecutionDelegate#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal EntityPersister entityDescriptor=sessionFactory.getRuntimeMetamodels().getMappingMetamodel().getEntityDescriptor(sqmDelete.getTarget().getEntityName());\nfinal String hierarchyRootTableName=((Joinable)entityDescriptor).getTableName();\nfinal TableGroup deletingTableGroup=converter.getMutatingTableGroup();\nfinal TableReference hierarchyRootTableReference=deletingTableGroup.resolveTableReference(deletingTableGroup.getNavigablePath(),hierarchyRootTableName);\nassert hierarchyRootTableReference != null;\nfinal Map<SqmParameter<?>,List<List<JdbcParameter>>> parameterResolutions;\nfinal Map<SqmParameter<?>,MappingModelExpressible<?>> paramTypeResolutions;\nif(domainParameterXref.getSqmParameterCount() == 0){parameterResolutions=Collections.emptyMap();\nparamTypeResolutions=Collections.emptyMap();\n}{parameterResolutions=new IdentityHashMap<>();\nparamTypeResolutions=new LinkedHashMap<>();\n}final MutableBoolean needsIdTableWrapper=new MutableBoolean(false);\nfinal Predicate specifiedRestriction=converter.visitWhereClause(sqmDelete.getWhereClause(),columnReference -> {\n  if (!hierarchyRootTableReference.getIdentificationVariable().equals(columnReference.getQualifier())) {\n    needsIdTableWrapper.setValue(true);\n  }\n}\n,(sqmParameter,mappingType,jdbcParameters) -> {\n  parameterResolutions.computeIfAbsent(sqmParameter,k -> new ArrayList<>(1)).add(jdbcParameters);\n  paramTypeResolutions.put(sqmParameter,mappingType);\n}\n);\nfinal PredicateCollector predicateCollector=new PredicateCollector(specifiedRestriction);\nentityDescriptor.applyBaseRestrictions((filterPredicate) -> {\n  needsIdTableWrapper.setValue(true);\n  predicateCollector.applyPredicate(filterPredicate);\n}\n,deletingTableGroup,true,executionContext.getSession().getLoadQueryInfluencers().getEnabledFilters(),null,converter);\nconverter.pruneTableGroupJoins();\nfinal boolean needsIdTable=needsIdTableWrapper.getValue() || entityDescriptor != entityDescriptor.getRootEntityDescriptor();\nfinal SqmJdbcExecutionContextAdapter executionContextAdapter=SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext);\nif(needsIdTable){return executeWithIdTable(predicateCollector.getPredicate(),deletingTableGroup,parameterResolutions,paramTypeResolutions,executionContextAdapter);\n}{return executeWithoutIdTable(predicateCollector.getPredicate(),deletingTableGroup,parameterResolutions,paramTypeResolutions,converter.getSqlExpressionResolver(),executionContextAdapter);\n}}\nmethodSignature: org.hibernate.orm.test.jpa.transaction.batch.JtaWithFailingBatchTest.TestBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn buildBatchTest(key,jdbcCoordinator,getJdbcBatchSize());\n}\nmethodSignature: org.hibernate.orm.test.jpa.transaction.batch.FailingAddToBatchTest.TestBatch#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\nPreparedStatement batchStatement=super.getBatchStatement(sql,callable);\ncreatedStatements.add(batchStatement);\nreturn batchStatement;\n}\nmethodSignature: org.hibernate.orm.test.jpa.transaction.batch.JtaWithStatementsBatchTest.TestBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn buildBatchTest(key,jdbcCoordinator,getJdbcBatchSize());\n}\nmethodSignature: org.hibernate.orm.test.manytomany.batchload.TestingBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn new TestingBatch(key,jdbcCoordinator);\n}\nmethodSignature: org.hibernate.persister.collection.AbstractCollectionPersister#getDialect\n methodBody: protected Dialect getDialect() {\nreturn dialect;\n}\nmethodSignature: org.hibernate.engine.jdbc.spi.JdbcCoordinator#getLogicalConnection\n methodBody: LogicalConnectionImplementor getLogicalConnection();\nmethodSignature: org.hibernate.query.sqm.mutation.internal.temptable.TableBasedInsertHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nif(log.isTraceEnabled()){log.tracef(\"Starting multi-table insert execution - %s\",getSqmInsertStatement().getTarget().getModel().getName());\n}final SqmJdbcExecutionContextAdapter executionContextAdapter=SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext);\nreturn resolveDelegate(executionContext).execute(executionContextAdapter);\n}\nmethodSignature: org.hibernate.orm.test.insertordering.InsertOrderingTest.StatsBatch#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\nif(batchSQL == null || !batchSQL.equals(sql)){currentBatch++;\nbatchSQL=sql;\nbatchSizes.add(currentBatch,new Counter());\n}return super.getBatchStatement(sql,callable);\n}\nmethodSignature: org.hibernate.engine.jdbc.spi.JdbcCoordinator#getResultSetReturn\n methodBody: ResultSetReturn getResultSetReturn();\nmethodSignature: org.hibernate.sql.ast.spi.AbstractSqlAstTranslator#getDialect\n methodBody: public Dialect getDialect() {\nreturn dialect;\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.BatchBuilderImpl#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn SharedBatchBuildingCode.buildBatch(jdbcBatchSize,key,jdbcCoordinator);\n}\nmethodSignature: org.hibernate.orm.test.jpa.transaction.batch.FailingAddToBatchTest.TestBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn buildBatchTest(key,jdbcCoordinator,getJdbcBatchSize());\n}\nmethodSignature: org.hibernate.orm.test.jpa.transaction.batch.FailingAddToBatchTest.TestBatch#addToBatch\n methodBody: public void addToBatch() {\nRuntimeException failure=nextAddToBatchFailure.getAndSet(null);\nif(failure != null){throw failure;\n}super.addToBatch();\n}\nmethodSignature: org.hibernate.dialect.Dialect#getDropTableString\n methodBody: public String getDropTableString(String tableName) {\nfinal StringBuilder buf=new StringBuilder(\"drop table \");\nif(supportsIfExistsBeforeTableName()){buf.append(\"if exists \");\n}buf.append(tableName).append(getCascadeConstraintsString());\nif(supportsIfExistsAfterTableName()){buf.append(\" if exists\");\n}return buf.toString();\n}\nmethodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#getJdbcCoordinator\n methodBody: protected JdbcCoordinator getJdbcCoordinator(){\nreturn this.jdbcCoordinator;\n}\nmethodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#sessionFactory\n methodBody: protected SessionFactoryImplementor sessionFactory() {\nreturn this.owner.getJdbcSessionContext().getSessionFactory();\n}\nmethodSignature: org.hibernate.dialect.AbstractHANADialect.CloseSuppressingReader#close\n methodBody: public void close() {\n}\nmethodSignature: org.hibernate.sql.ast.spi.AbstractSqlAstTranslator#getJdbcServices\n methodBody: protected JdbcServices getJdbcServices() {\nreturn getSessionFactory().getJdbcServices();\n}",
        "classSignatureBefore": "public class BatchingTest extends BaseCoreFunctionalTestCase implements BatchKey ",
        "methodNameBeforeSet": [
            "org.hibernate.orm.test.jdbc.internal.BatchingTest#testBatchingUsage"
        ],
        "classNameBeforeSet": [
            "org.hibernate.orm.test.jdbc.internal.BatchingTest"
        ],
        "classSignatureBeforeSet": [
            "public class BatchingTest extends BaseCoreFunctionalTestCase implements BatchKey "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.orm.test.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.Statement;\n\nimport org.hibernate.Session;\nimport org.hibernate.Transaction;\nimport org.hibernate.engine.jdbc.batch.internal.BasicBatchKey;\nimport org.hibernate.engine.jdbc.batch.internal.BatchBuilderImpl;\nimport org.hibernate.engine.jdbc.batch.internal.BatchingBatch;\nimport org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch;\nimport org.hibernate.engine.jdbc.batch.spi.Batch;\nimport org.hibernate.engine.jdbc.batch.spi.BatchBuilder;\nimport org.hibernate.engine.jdbc.batch.spi.BatchKey;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.spi.SessionImplementor;\nimport org.hibernate.jdbc.Expectation;\nimport org.hibernate.jdbc.Expectations;\nimport org.hibernate.resource.jdbc.spi.LogicalConnectionImplementor;\n\nimport org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;\nimport org.hibernate.orm.test.common.JournalingBatchObserver;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertSame;\nimport static org.junit.Assert.assertTrue;\n\n/**\n * @author Steve Ebersole\n * @author Brett Meyer\n */\npublic class BatchingTest extends BaseCoreFunctionalTestCase implements BatchKey {\n\t@Override\n\tpublic int getBatchedStatementCount() {\n\t\treturn 1;\n\t}\n\n\t@Override\n\tpublic Expectation getExpectation() {\n\t\treturn Expectations.BASIC;\n\t}\n\n\t@Test\n\tpublic void testNonBatchingUsage() throws Exception {\n\t\tSession session = openSession();\n\t\tSessionImplementor sessionImpl = (SessionImplementor) session;\n\t\t\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n\n\t\t// set up some tables to use\n\t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n\t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n\t\ttry {\n\t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n\t\t}\n\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n        jdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n\n\t\t// ok, now we can get down to it...\n\t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n\t\ttxn.begin();\n\n\t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n\n\t\tfinal BatchBuilder batchBuilder = new BatchBuilderImpl( -1 );\n\t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\", Expectations.BASIC );\n\t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, jdbcCoordinator );\n\n\t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n\t\tinsertBatch.addObserver( batchObserver );\n\n\t\tassertTrue( \"unexpected Batch impl\", NonBatchingBatch.class.isInstance( insertBatch ) );\n\t\tPreparedStatement insert = insertBatch.getBatchStatement( insertSql, false );\n\t\tinsert.setLong( 1, 1 );\n\t\tinsert.setString( 2, \"name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.execute();\n\t\tassertEquals( 1, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.release();\n\n\t\ttxn.commit();\n\t\tsession.close();\n\t}\n\n\t@Test\n\tpublic void testBatchingUsage() throws Exception {\n\t\tSession session = openSession();\n\t\tSessionImplementor sessionImpl = (SessionImplementor) session;\n\t\t\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n\n\t\t// set up some tables to use\n\t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n\t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n\t\ttry {\n\t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n\t\t}\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n        jdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n\n\t\t// ok, now we can get down to it...\n\t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n\t\ttxn.begin();\n\n\t\tfinal BatchBuilder batchBuilder = new BatchBuilderImpl( 2 );\n\t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\", Expectations.BASIC );\n\t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, jdbcCoordinator );\n\t\tassertTrue( \"unexpected Batch impl\", BatchingBatch.class.isInstance( insertBatch ) );\n\n\t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n\t\tinsertBatch.addObserver( batchObserver );\n\n\t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n\n\t\tPreparedStatement insert = insertBatch.getBatchStatement( insertSql, false );\n\t\tinsert.setLong( 1, 1 );\n\t\tinsert.setString( 2, \"name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tPreparedStatement insert2 = insertBatch.getBatchStatement( insertSql, false );\n\t\tassertSame( insert, insert2 );\n\t\tinsert = insert2;\n\t\tinsert.setLong( 1, 2 );\n\t\tinsert.setString( 2, \"another name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.execute();\n\t\tassertEquals( 1, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.release();\n\n\t\ttxn.commit();\n\t\tsession.close();\n\t}\n\n\t@Test\n\tpublic void testSessionBatchingUsage() throws Exception {\n\t\tSession session = openSession();\n\t\tsession.setJdbcBatchSize( 3 );\n\t\tSessionImplementor sessionImpl = (SessionImplementor) session;\n\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n\n\t\t// set up some tables to use\n\t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n\t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n\t\ttry {\n\t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n\t\t}\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n        jdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n\n\t\t// ok, now we can get down to it...\n\t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n\t\ttxn.begin();\n\n\t\tfinal BatchBuilder batchBuilder = new BatchBuilderImpl( 2 );\n\t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\", Expectations.BASIC );\n\t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, jdbcCoordinator );\n\t\tassertTrue( \"unexpected Batch impl\", BatchingBatch.class.isInstance( insertBatch ) );\n\n\t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n\t\tinsertBatch.addObserver( batchObserver );\n\n\t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n\n\t\tPreparedStatement insert = insertBatch.getBatchStatement( insertSql, false );\n\t\tinsert.setLong( 1, 1 );\n\t\tinsert.setString( 2, \"name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tPreparedStatement insert2 = insertBatch.getBatchStatement( insertSql, false );\n\t\tassertSame( insert, insert2 );\n\t\tinsert = insert2;\n\t\tinsert.setLong( 1, 2 );\n\t\tinsert.setString( 2, \"another name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tPreparedStatement insert3 = insertBatch.getBatchStatement( insertSql, false );\n\t\tassertSame( insert, insert3 );\n\t\tinsert = insert3;\n\t\tinsert.setLong( 1, 3 );\n\t\tinsert.setString( 2, \"yet another name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.execute();\n\t\tassertEquals( 1, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.release();\n\n\t\ttxn.commit();\n\t\tsession.close();\n\t}\n\n\t@Override\n\tprotected void cleanupTest() throws Exception {\n\t\ttry (Session session = openSession()) {\n\t\t\tsession.doWork( connection -> {\n\t\t\t\tfinal Statement stmnt = connection.createStatement();\n\n\t\t\t\tstmnt.execute( sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" ) );\n\t\t\t} );\n\t\t}\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/test/java/org/hibernate/orm/test/jdbc/internal/BatchingTest.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.orm.test.jdbc.internal;\n\nimport java.sql.Statement;\n\nimport org.hibernate.Session;\nimport org.hibernate.Transaction;\nimport org.hibernate.engine.jdbc.batch.internal.BasicBatchKey;\nimport org.hibernate.engine.jdbc.batch.internal.BatchBuilderImpl;\nimport org.hibernate.engine.jdbc.batch.spi.Batch;\nimport org.hibernate.engine.jdbc.batch.spi.BatchKey;\nimport org.hibernate.engine.jdbc.mutation.ParameterUsage;\nimport org.hibernate.engine.jdbc.mutation.internal.JdbcValueBindingsImpl;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.spi.SessionImplementor;\nimport org.hibernate.jdbc.Expectation;\nimport org.hibernate.jdbc.Expectations;\nimport org.hibernate.metamodel.mapping.JdbcMapping;\nimport org.hibernate.orm.test.common.JournalingBatchObserver;\nimport org.hibernate.resource.jdbc.spi.LogicalConnectionImplementor;\nimport org.hibernate.sql.model.MutationType;\nimport org.hibernate.sql.model.TableMapping;\nimport org.hibernate.sql.model.jdbc.JdbcValueDescriptor;\nimport org.hibernate.type.StandardBasicTypes;\n\nimport org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;\nimport org.junit.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.hibernate.jdbc.Expectations.NONE;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n\n/**\n * @author Steve Ebersole\n * @author Brett Meyer\n */\npublic class BatchingTest extends BaseCoreFunctionalTestCase implements BatchKey {\n\tprivate final String SANDBOX_TBL = \"SANDBOX_JDBC_TST\";\n\tprivate final TableMapping SANDBOX_TBL_MAPPING = new TableMapping() {\n\t\t@Override\n\t\tpublic String getTableName() {\n\t\t\treturn SANDBOX_TBL;\n\t\t}\n\n\t\t@Override\n\t\tpublic int getRelativePosition() {\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isOptional() {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isInverse() {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isIdentifierTable() {\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic MutationDetails getInsertDetails() {\n\t\t\treturn new MutationDetails( MutationType.INSERT, NONE, null, false );\n\t\t}\n\n\t\t@Override\n\t\tpublic MutationDetails getUpdateDetails() {\n\t\t\treturn new MutationDetails( MutationType.UPDATE, NONE, null, false );\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isCascadeDeleteEnabled() {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic MutationDetails getDeleteDetails() {\n\t\t\treturn new MutationDetails( MutationType.DELETE, NONE, null, false );\n\t\t}\n\t};\n\n\t@Override\n\tpublic int getBatchedStatementCount() {\n\t\treturn 1;\n\t}\n\n\t@Override\n\tpublic Expectation getExpectation() {\n\t\treturn Expectations.BASIC;\n\t}\n\n\t@Test\n\tpublic void testBatchingUsage() throws Exception {\n\t\tfinal Session session = openSession();\n\t\tfinal SessionImplementor sessionImpl = (SessionImplementor) session;\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\n\t\texportSandboxSchema( sessionImpl );\n\n\t\t// ok, now we can get down to it...\n\t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n\t\ttxn.begin();\n\n\t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n\n\t\tfinal BatchBuilderImpl batchBuilder = new BatchBuilderImpl( 2 );\n\t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\" );\n\t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, null, SANDBOX_TBL, sessionImpl, insertSql );\n\t\tassertThat( insertBatch ).isNotNull();\n\n\t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n\t\tinsertBatch.addObserver( batchObserver );\n\n\t\tfinal JdbcValueBindingsImpl jdbcValueBindings = sandboxInsertValueBindings( sessionImpl );\n\n\t\t// bind values for #1 - should do nothing at the JDBC level\n\t\tjdbcValueBindings.bindValue( 1, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n\t\tjdbcValueBindings.bindValue( \"name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isFalse();\n\n\t\t// add #1 to the batch - will acquire prepared statement to bind values\n\t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n        assertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\t// bind values for #2 - again, nothing at JDBC level (we have statement from earlier)\n\t\tjdbcValueBindings.bindValue( 2, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n\t\tjdbcValueBindings.bindValue( \"another name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\n\t\t// add #2 to the batch -\n\t\t// \t\t- uses the previous prepared statement to bind values\n\t\t//\t\t- batch size has been exceeded, trigger an implicit execution\n\t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 1 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\t// execute the batch - effectively only increments the explicit-execution counter\n\t\tinsertBatch.execute();\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 1 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 1 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isFalse();\n\n\t\tinsertBatch.release();\n\n\t\ttxn.commit();\n\t\tsession.close();\n\t}\n\n\tprivate JdbcValueBindingsImpl sandboxInsertValueBindings(SessionImplementor session) {\n\t\treturn new JdbcValueBindingsImpl(\n\t\t\t\tMutationType.INSERT,\n\t\t\t\tnull,\n\t\t\t\t(tableName, columnName, usage) -> {\n\t\t\t\t\tassert tableName.equals( SANDBOX_TBL );\n\n\t\t\t\t\tif ( columnName.equals( \"ID\" ) ) {\n\t\t\t\t\t\treturn new JdbcValueDescriptor() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic String getColumnName() {\n\t\t\t\t\t\t\t\treturn \"ID\";\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic ParameterUsage getUsage() {\n\t\t\t\t\t\t\t\treturn ParameterUsage.SET;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic int getJdbcPosition() {\n\t\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic JdbcMapping getJdbcMapping() {\n\t\t\t\t\t\t\t\treturn session.getTypeConfiguration()\n\t\t\t\t\t\t\t\t\t\t.getBasicTypeRegistry()\n\t\t\t\t\t\t\t\t\t\t.resolve( StandardBasicTypes.INTEGER );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( columnName.equals( \"NAME\" ) ) {\n\t\t\t\t\t\treturn new JdbcValueDescriptor() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic String getColumnName() {\n\t\t\t\t\t\t\t\treturn \"NAME\";\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic ParameterUsage getUsage() {\n\t\t\t\t\t\t\t\treturn ParameterUsage.SET;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic int getJdbcPosition() {\n\t\t\t\t\t\t\t\treturn 2;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic JdbcMapping getJdbcMapping() {\n\t\t\t\t\t\t\t\treturn session.getTypeConfiguration()\n\t\t\t\t\t\t\t\t\t\t.getBasicTypeRegistry()\n\t\t\t\t\t\t\t\t\t\t.resolve( StandardBasicTypes.STRING );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new IllegalArgumentException( \"Unknown column : \" + columnName );\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@Test\n\tpublic void testSessionBatchingUsage() throws Exception {\n\t\tSession session = openSession();\n\t\tsession.setJdbcBatchSize( 3 );\n\t\tSessionImplementor sessionImpl = (SessionImplementor) session;\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\n\t\texportSandboxSchema( sessionImpl );\n\n\t\t// ok, now we can get down to it...\n\t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n\t\ttxn.begin();\n\n\n\t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n\n\t\tfinal BatchBuilderImpl batchBuilder = new BatchBuilderImpl( 2 );\n\t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\" );\n\t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, 3, SANDBOX_TBL, sessionImpl, insertSql );\n\t\tassertThat( insertBatch ).isNotNull();\n\n\t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n\t\tinsertBatch.addObserver( batchObserver );\n\n\t\tfinal JdbcValueBindingsImpl jdbcValueBindings = sandboxInsertValueBindings( sessionImpl );\n\n\t\t// bind values for #1 - this does nothing at the JDBC level\n\t\tjdbcValueBindings.bindValue( 1, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n\t\tjdbcValueBindings.bindValue( \"name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isFalse();\n\n\t\t// add the values to the batch - this creates the prepared statement and binds the values\n\t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\t// bind values for #2 - this does nothing at the JDBC level : we do still have the statement defining the batch\n\t\tjdbcValueBindings.bindValue( 2, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n\t\tjdbcValueBindings.bindValue( \"another name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\t// add #2 to batch - we have not exceeded batch size, so we should not get an implicit execution\n\t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\t// bind values for #3 - this does nothing at the JDBC level : we do still have the statement defining the batch\n\t\tjdbcValueBindings.bindValue( 3, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n\t\tjdbcValueBindings.bindValue( \"yet another name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 1 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\tinsertBatch.execute();\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 1 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 1 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isFalse();\n\n\t\tinsertBatch.release();\n\n\t\ttxn.commit();\n\t\tsession.close();\n\t}\n\n\tprivate void exportSandboxSchema(SessionImplementor sessionImpl) {\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n\n\t\t// set up some tables to use\n\t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n\t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n\t\ttry {\n\t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n\t\t}\n\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n\t\tassertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n\t\tassertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n\t}\n\n\t@Override\n\tprotected void cleanupTest() throws Exception {\n\t\ttry (Session session = openSession()) {\n\t\t\tsession.doWork( connection -> {\n\t\t\t\tfinal Statement stmnt = connection.createStatement();\n\n\t\t\t\tstmnt.execute( sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" ) );\n\t\t\t} );\n\t\t}\n\t}\n\n}\n",
        "diffSourceCodeSet": [
            "private void exportSandboxSchema(SessionImplementor sessionImpl) {\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n\n\t\t// set up some tables to use\n\t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n\t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n\t\ttry {\n\t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n\t\t}\n\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n\t\tassertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n\t\tassertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.action.internal.BulkOperationCleanupAction.NaturalIdCleanup#release\n methodBody: private void release() {\nnaturalIdCacheAccessStrategy.unlockRegion(cacheLock);\n}",
            "methodSignature: org.hibernate.orm.test.insertordering.InsertOrderingTest.StatsBatch#addToBatch\n methodBody: public void addToBatch() {\nCounter counter=(Counter)batchSizes.get(currentBatch);\ncounter.count++;\nsuper.addToBatch();\n}",
            "methodSignature: org.hibernate.engine.jdbc.spi.JdbcCoordinator#getStatementPreparer\n methodBody: StatementPreparer getStatementPreparer();",
            "methodSignature: org.hibernate.engine.jdbc.spi.JdbcServices#getDialect\n methodBody: Dialect getDialect();",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\nif(sql == null){throw new IllegalArgumentException(\"sql must be non-null.\");\n}PreparedStatement statement=statements.get(sql);\nif(statement == null){statement=buildBatchStatement(sql,callable);\nstatements.put(sql,statement);\n}{LOG.debug(\"Reusing batch statement\");\nsqlStatementLogger().logStatement(sql);\n}return statement;\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#execute\n methodBody: void execute();",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.SharedBatchBuildingCode#buildBatch\n methodBody: static Batch buildBatch(final int defaultJdbcBatchSize, final BatchKey key, final JdbcCoordinator jdbcCoordinator) {\nfinal Integer sessionJdbcBatchSize=jdbcCoordinator.getJdbcSessionOwner().getJdbcBatchSize();\nfinal int jdbcBatchSizeToUse=sessionJdbcBatchSize == null ? defaultJdbcBatchSize : sessionJdbcBatchSize;\nreturn jdbcBatchSizeToUse > 1 ? new BatchingBatch(key,jdbcCoordinator,jdbcBatchSizeToUse) : new NonBatchingBatch(key,jdbcCoordinator);\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#getLogicalConnection\n methodBody: public LogicalConnectionImplementor getLogicalConnection() {\nreturn logicalConnection;\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#close\n methodBody: protected void close(ResultSet resultSet) {\nLOG.tracev(\"Closing result set [{0}]\",resultSet);\nif(resultSet instanceof InvalidatableWrapper){@SuppressWarnings(\"unchecked\") final InvalidatableWrapper<ResultSet> wrapper=(InvalidatableWrapper<ResultSet>)resultSet;\nclose(wrapper.getWrappedObject());\nwrapper.invalidate();\nreturn;\n}tryresultSet.close();\ncatch(Exception e)LOG.debugf(\"Unable to release JDBC result set [%s]\",e.getMessage());\n}",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.inline.InlineUpdateHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal List<Object> ids=MatchingIdSelectionHelper.selectMatchingIds(sqmUpdate,domainParameterXref,executionContext);\nif(ids == null || ids.isEmpty()){return 0;\n}domainParameterXref.clearExpansions();\nfinal MappingMetamodel domainModel=sessionFactory.getRuntimeMetamodels().getMappingMetamodel();\nfinal String mutatingEntityName=sqmUpdate.getTarget().getModel().getHibernateEntityName();\nfinal EntityPersister entityDescriptor=domainModel.getEntityDescriptor(mutatingEntityName);\nfinal String rootEntityName=entityDescriptor.getEntityPersister().getRootEntityName();\nfinal EntityPersister rootEntityDescriptor=domainModel.getEntityDescriptor(rootEntityName);\nfinal String hierarchyRootTableName=((Joinable)rootEntityDescriptor).getTableName();\nfinal List<Expression> inListExpressions=new ArrayList<>(ids.size());\nfinal EntityIdentifierMapping identifierMapping=entityDescriptor.getIdentifierMapping();\nif(identifierMapping instanceof BasicValuedModelPart){final BasicValuedModelPart basicValuedModelPart=(BasicValuedModelPart)identifierMapping;\nfor(int i=0; i < ids.size(); i++){inListExpressions.add(new QueryLiteral<>(ids.get(i),basicValuedModelPart));\n}}{final int jdbcTypeCount=identifierMapping.getJdbcTypeCount();\nfor(int i=0; i < ids.size(); i++){final Object[] id=(Object[])ids.get(i);\nfinal List<Expression> tupleElements=new ArrayList<>(jdbcTypeCount);\ninListExpressions.add(new SqlTuple(tupleElements,identifierMapping));\nidentifierMapping.forEachJdbcType((index,jdbcMapping) -> {\n  tupleElements.add(new QueryLiteral<>(id[index],(BasicValuedMapping)jdbcMapping));\n}\n);\n}}final MultiTableSqmMutationConverter converterDelegate=new MultiTableSqmMutationConverter(entityDescriptor,sqmUpdate,sqmUpdate.getTarget(),domainParameterXref,executionContext.getQueryOptions(),executionContext.getSession().getLoadQueryInfluencers(),executionContext.getQueryParameterBindings(),sessionFactory);\nfinal TableGroup updatingTableGroup=converterDelegate.getMutatingTableGroup();\nfinal TableReference hierarchyRootTableReference=updatingTableGroup.resolveTableReference(updatingTableGroup.getNavigablePath(),hierarchyRootTableName);\nassert hierarchyRootTableReference != null;\nfinal Map<SqmParameter<?>,List<List<JdbcParameter>>> parameterResolutions;\nif(domainParameterXref.getSqmParameterCount() == 0){parameterResolutions=Collections.emptyMap();\n}{parameterResolutions=new IdentityHashMap<>();\n}final List<Assignment> assignments=new ArrayList<>();\nfinal Map<SqmParameter<?>,MappingModelExpressible<?>> paramTypeResolutions=new LinkedHashMap<>();\nconverterDelegate.visitSetClause(sqmUpdate.getSetClause(),assignments::add,(sqmParameter,mappingType,jdbcParameters) -> {\n  parameterResolutions.computeIfAbsent(sqmParameter,k -> new ArrayList<>(1)).add(jdbcParameters);\n  paramTypeResolutions.put(sqmParameter,mappingType);\n}\n);\nconverterDelegate.addVersionedAssignment(assignments::add,sqmUpdate);\nfinal Predicate providedPredicate;\nfinal SqmWhereClause whereClause=sqmUpdate.getWhereClause();\nif(whereClause == null || whereClause.getPredicate() == null){providedPredicate=null;\n}{providedPredicate=converterDelegate.visitWhereClause(whereClause,columnReference -> {\n}\n,(sqmParameter,mappingType,jdbcParameters) -> {\n  parameterResolutions.computeIfAbsent(sqmParameter,k -> new ArrayList<>(1)).add(jdbcParameters);\n  paramTypeResolutions.put(sqmParameter,mappingType);\n}\n);\nassert providedPredicate != null;\n}final PredicateCollector predicateCollector=new PredicateCollector(providedPredicate);\nentityDescriptor.applyBaseRestrictions(predicateCollector::applyPredicate,updatingTableGroup,true,executionContext.getSession().getLoadQueryInfluencers().getEnabledFilters(),null,converterDelegate);\nconverterDelegate.pruneTableGroupJoins();\nfinal Map<String,TableReference> tableReferenceByAlias=CollectionHelper.mapOfSize(updatingTableGroup.getTableReferenceJoins().size() + 1);\ncollectTableReference(updatingTableGroup.getPrimaryTableReference(),tableReferenceByAlias::put);\nfor(int i=0; i < updatingTableGroup.getTableReferenceJoins().size(); i++){collectTableReference(updatingTableGroup.getTableReferenceJoins().get(i),tableReferenceByAlias::put);\n}final JdbcParameterBindings jdbcParameterBindings=SqmUtil.createJdbcParameterBindings(executionContext.getQueryParameterBindings(),domainParameterXref,SqmUtil.generateJdbcParamsXref(domainParameterXref,() -> parameterResolutions),sessionFactory.getRuntimeMetamodels().getMappingMetamodel(),navigablePath -> updatingTableGroup,new SqmParameterMappingModelResolutionAccess(){\n  @Override @SuppressWarnings(\"unchecked\") public <T>MappingModelExpressible<T> getResolvedMappingModelType(  SqmParameter<T> parameter){\n    return (MappingModelExpressible<T>)paramTypeResolutions.get(parameter);\n  }\n}\n,executionContext.getSession());\nfinal Map<TableReference,List<Assignment>> assignmentsByTable=new HashMap<>();\nfor(int i=0; i < assignments.size(); i++){final Assignment assignment=assignments.get(i);\nfinal List<ColumnReference> assignmentColumnRefs=assignment.getAssignable().getColumnReferences();\nTableReference assignmentTableReference=null;\nfor(int c=0; c < assignmentColumnRefs.size(); c++){final ColumnReference columnReference=assignmentColumnRefs.get(c);\nfinal TableReference tableReference=resolveTableReference(columnReference,tableReferenceByAlias);\nif(assignmentTableReference != null && assignmentTableReference != tableReference){throw new SemanticException(\"Assignment referred to columns from multiple tables: \" + assignment.getAssignable());\n}assignmentTableReference=tableReference;\n}List<Assignment> assignmentsForTable=assignmentsByTable.get(assignmentTableReference);\nif(assignmentsForTable == null){assignmentsForTable=new ArrayList<>();\nassignmentsByTable.put(assignmentTableReference,assignmentsForTable);\n}assignmentsForTable.add(assignment);\n}final int rows=ids.size();\nfinal SqmJdbcExecutionContextAdapter executionContextAdapter=SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext);\nentityDescriptor.visitConstraintOrderedTables((tableExpression,tableKeyColumnVisitationSupplier) -> updateTable(tableExpression,tableKeyColumnVisitationSupplier,entityDescriptor,updatingTableGroup,assignmentsByTable,inListExpressions,rows,jdbcParameterBindings,executionContextAdapter));\nreturn rows;\n}",
            "methodSignature: org.hibernate.dialect.AbstractHANADialect.CloseSuppressingInputStream#close\n methodBody: public void close() {\n}",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.inline.InlineDeleteHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal List<Object> idsAndFks=MatchingIdSelectionHelper.selectMatchingIds(sqmDeleteStatement,domainParameterXref,executionContext);\nif(idsAndFks == null || idsAndFks.isEmpty()){return 0;\n}final SessionFactoryImplementor factory=executionContext.getSession().getFactory();\nfinal String mutatingEntityName=sqmDeleteStatement.getTarget().getModel().getHibernateEntityName();\nfinal EntityMappingType entityDescriptor=factory.getRuntimeMetamodels().getEntityMappingType(mutatingEntityName);\nfinal JdbcParameterBindings jdbcParameterBindings=new JdbcParameterBindingsImpl(domainParameterXref.getQueryParameterCount());\nfinal MutableInteger valueIndexCounter=new MutableInteger();\nSqmMutationStrategyHelper.visitCollectionTables(entityDescriptor,pluralAttribute -> {\n  if (pluralAttribute.getSeparateCollectionTable() != null) {\n    final ModelPart fkTargetPart=pluralAttribute.getKeyDescriptor().getTargetPart();\n    final int valueIndex;\n    if (fkTargetPart instanceof EntityIdentifierMapping) {\n      valueIndex=0;\n    }\n else {\n      if (valueIndexCounter.get() == 0) {\n        valueIndexCounter.set(entityDescriptor.getIdentifierMapping().getJdbcTypeCount());\n      }\n      valueIndex=valueIndexCounter.get();\n      valueIndexCounter.plus(fkTargetPart.getJdbcTypeCount());\n    }\n    executeDelete(pluralAttribute.getSeparateCollectionTable(),entityDescriptor,() -> fkTargetPart::forEachSelectable,idsAndFks,valueIndex,fkTargetPart,jdbcParameterBindings,executionContext);\n  }\n}\n);\nentityDescriptor.visitConstraintOrderedTables((tableExpression,tableKeyColumnsVisitationSupplier) -> {\n  executeDelete(tableExpression,entityDescriptor,tableKeyColumnsVisitationSupplier,idsAndFks,0,null,jdbcParameterBindings,executionContext);\n}\n);\nreturn idsAndFks.size();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#hasRegisteredResources\n methodBody: private boolean hasRegisteredResources() {\nreturn getLogicalConnection().getResourceRegistry().hasRegisteredResources();\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#release\n methodBody: void release();",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.UnmodifiableBatchBuilderImpl#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn SharedBatchBuildingCode.buildBatch(jdbcBatchSize,key,jdbcCoordinator);\n}",
            "methodSignature: org.hibernate.persister.entity.AbstractEntityPersister#isInstance\n methodBody: public boolean isInstance(Object object) {\nreturn getRepresentationStrategy().getInstantiator().isInstance(object,getFactory());\n}",
            "methodSignature: org.hibernate.orm.test.jpa.transaction.batch.JtaWithFailingBatchTest.TestBatch#addToBatch\n methodBody: public void addToBatch() {\nthrow sqlExceptionHelper().convert(new SQLException(\"fake SQLException\"),\"could not perform addBatch\",currentStatementSql);\n}",
            "methodSignature: org.hibernate.action.internal.BulkOperationCleanupAction#execute\n methodBody: public void execute() throws HibernateException {\n}",
            "methodSignature: org.hibernate.orm.test.jpa.transaction.batch.JtaWithFailingBatchTest.TestBatch#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\ncurrentStatementSql=sql;\nPreparedStatement batchStatement=super.getBatchStatement(sql,callable);\ncreatedStatements.add(batchStatement);\nreturn batchStatement;\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.spi.BatchBuilder#buildBatch\n methodBody: Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator);",
            "methodSignature: org.hibernate.procedure.internal.ProcedureCallImpl#execute\n methodBody: public boolean execute() {\ntryreturn outputs().getCurrent() instanceof ResultSetOutput;\ncatch(NoMoreOutputsException e)return false;\ncatch(HibernateException he)throw getSession().getExceptionConverter().convert(he);\ncatch(RuntimeException e)getSession().markForRollbackOnly();\nthrow e;\n}",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.cte.CteInsertHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal SqmInsertStatement<?> sqmInsertStatement=getSqmStatement();\nfinal SessionFactoryImplementor factory=executionContext.getSession().getFactory();\nfinal EntityPersister entityDescriptor=getEntityDescriptor().getEntityPersister();\nfinal String explicitDmlTargetAlias;\nif(sqmInsertStatement.getTarget().getExplicitAlias() == null){explicitDmlTargetAlias=\"dml_target\";\n}{explicitDmlTargetAlias=sqmInsertStatement.getTarget().getExplicitAlias();\n}final MultiTableSqmMutationConverter sqmConverter=new MultiTableSqmMutationConverter(entityDescriptor,sqmInsertStatement,sqmInsertStatement.getTarget(),explicitDmlTargetAlias,domainParameterXref,executionContext.getQueryOptions(),executionContext.getSession().getLoadQueryInfluencers(),executionContext.getQueryParameterBindings(),factory);\nfinal TableGroup insertingTableGroup=sqmConverter.getMutatingTableGroup();\nfinal Map<SqmParameter<?>,List<List<JdbcParameter>>> parameterResolutions;\nif(domainParameterXref.getSqmParameterCount() == 0){parameterResolutions=Collections.emptyMap();\n}{parameterResolutions=new IdentityHashMap<>();\n}final int size=sqmStatement.getInsertionTargetPaths().size();\nfinal List<Map.Entry<List<CteColumn>,Assignment>> targetPathColumns=new ArrayList<>(size);\nfinal List<CteColumn> targetPathCteColumns=new ArrayList<>(size);\nfinal Map<SqmParameter<?>,MappingModelExpressible<?>> paramTypeResolutions=new LinkedHashMap<>();\nfinal NamedTableReference entityTableReference=new NamedTableReference(cteTable.getTableExpression(),TemporaryTable.DEFAULT_ALIAS,true,sessionFactory);\nfinal InsertStatement insertStatement=new InsertStatement(entityTableReference);\nfinal BaseSqmToSqlAstConverter.AdditionalInsertValues additionalInsertValues=sqmConverter.visitInsertionTargetPaths((assignable,columnReferences) -> {\n  final SqmPathInterpretation<?> pathInterpretation=(SqmPathInterpretation<?>)assignable;\n  final int offset=CteTable.determineModelPartStartIndex(entityDescriptor,pathInterpretation.getExpressionType());\n  if (offset == -1) {\n    throw new IllegalStateException(\"Couldn't find matching cte column for: \" + ((Expression)assignable).getExpressionType());\n  }\n  final int end=offset + pathInterpretation.getExpressionType().getJdbcTypeCount();\n  final List<CteColumn> columns=cteTable.getCteColumns().subList(offset,end);\n  insertStatement.addTargetColumnReferences(columnReferences);\n  targetPathCteColumns.addAll(columns);\n  targetPathColumns.add(new AbstractMap.SimpleEntry<>(columns,new Assignment(assignable,(Expression)assignable)));\n}\n,sqmInsertStatement,entityDescriptor,insertingTableGroup,(sqmParameter,mappingType,jdbcParameters) -> {\n  parameterResolutions.computeIfAbsent(sqmParameter,k -> new ArrayList<>(1)).add(jdbcParameters);\n  paramTypeResolutions.put(sqmParameter,mappingType);\n}\n);\nfinal boolean assignsId=targetPathCteColumns.contains(cteTable.getCteColumns().get(0));\nfinal Stack<SqlAstProcessingState> processingStateStack=sqmConverter.getProcessingStateStack();\nfinal SqlAstProcessingState oldState=processingStateStack.pop();\nfinal Statement queryStatement;\nif(sqmInsertStatement instanceof SqmInsertSelectStatement){final QueryPart queryPart=sqmConverter.visitQueryPart(((SqmInsertSelectStatement<?>)sqmInsertStatement).getSelectQueryPart());\nqueryPart.visitQuerySpecs(querySpec -> {\n  if (additionalInsertValues.applySelections(querySpec,sessionFactory)) {\n    final CteColumn rowNumberColumn=cteTable.getCteColumns().get(cteTable.getCteColumns().size() - 1);\n    final ColumnReference columnReference=new ColumnReference((String)null,rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping());\n    insertStatement.getTargetColumnReferences().set(insertStatement.getTargetColumnReferences().size() - 1,columnReference);\n    targetPathCteColumns.set(targetPathCteColumns.size() - 1,rowNumberColumn);\n  }\n  if (!assignsId && entityDescriptor.getIdentifierGenerator() instanceof PostInsertIdentifierGenerator) {\n    querySpec.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,SqmInsertStrategyHelper.createRowNumberingExpression(querySpec,sessionFactory)));\n  }\n}\n);\nqueryStatement=new SelectStatement(queryPart);\n}{final List<SqmValues> sqmValuesList=((SqmInsertValuesStatement<?>)sqmInsertStatement).getValuesList();\nfinal List<Values> valuesList=new ArrayList<>(sqmValuesList.size());\nfor(SqmValues sqmValues: sqmValuesList){final Values values=sqmConverter.visitValues(sqmValues);\nadditionalInsertValues.applyValues(values);\nvaluesList.add(values);\n}final QuerySpec querySpec=new QuerySpec(true);\nfinal NavigablePath navigablePath=new NavigablePath(entityDescriptor.getRootPathName());\nfinal List<String> columnNames=new ArrayList<>(targetPathColumns.size());\nfinal String valuesAlias=insertingTableGroup.getPrimaryTableReference().getIdentificationVariable();\nfor(Map.Entry<List<CteColumn>,Assignment> entry: targetPathColumns){for(ColumnReference columnReference: entry.getValue().getAssignable().getColumnReferences()){columnNames.add(columnReference.getColumnExpression());\nquerySpec.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,columnReference.getQualifier().equals(valuesAlias) ? columnReference : new ColumnReference(valuesAlias,columnReference.getColumnExpression(),false,null,null,columnReference.getJdbcMapping())));\n}}final ValuesTableGroup valuesTableGroup=new ValuesTableGroup(navigablePath,entityDescriptor.getEntityPersister(),valuesList,insertingTableGroup.getPrimaryTableReference().getIdentificationVariable(),columnNames,true,factory);\nquerySpec.getFromClause().addRoot(valuesTableGroup);\nqueryStatement=new SelectStatement(querySpec);\n}processingStateStack.push(oldState);\nsqmConverter.pruneTableGroupJoins();\nif(!assignsId && entityDescriptor.getIdentifierGenerator() instanceof PostInsertIdentifierGenerator){final CteColumn rowNumberColumn=cteTable.getCteColumns().get(cteTable.getCteColumns().size() - 1);\nfinal ColumnReference columnReference=new ColumnReference((String)null,rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping());\ninsertStatement.getTargetColumnReferences().add(columnReference);\ntargetPathCteColumns.add(rowNumberColumn);\n}final CteTable entityCteTable=createCteTable(getCteTable(),targetPathCteColumns,factory);\nfinal QuerySpec querySpec=new QuerySpec(true,1);\nfinal List<DomainResult<?>> domainResults=new ArrayList<>(1);\nfinal SelectStatement statement=new SelectStatement(querySpec,domainResults);\nfinal CteStatement entityCte;\nif(additionalInsertValues.requiresRowNumberIntermediate()){final CteTable fullEntityCteTable=getCteTable();\nfinal String baseTableName=\"base_\" + entityCteTable.getTableExpression();\nfinal CteStatement baseEntityCte=new CteStatement(entityCteTable.withName(baseTableName),queryStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(baseEntityCte);\nfinal CteColumn rowNumberColumn=fullEntityCteTable.getCteColumns().get(fullEntityCteTable.getCteColumns().size() - 1);\nfinal ColumnReference rowNumberColumnReference=new ColumnReference(\"e\",rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping());\nfinal CteColumn idColumn=fullEntityCteTable.getCteColumns().get(0);\nfinal BasicValuedMapping idType=(BasicValuedMapping)idColumn.getJdbcMapping();\nfinal Optimizer optimizer=((OptimizableGenerator)entityDescriptor.getIdentifierGenerator()).getOptimizer();\nfinal BasicValuedMapping integerType=(BasicValuedMapping)rowNumberColumn.getJdbcMapping();\nfinal Expression rowNumberMinusOneModuloIncrement=new BinaryArithmeticExpression(new BinaryArithmeticExpression(rowNumberColumnReference,BinaryArithmeticOperator.SUBTRACT,new QueryLiteral<>(1,(BasicValuedMapping)rowNumberColumn.getJdbcMapping()),integerType),BinaryArithmeticOperator.MODULO,new QueryLiteral<>(optimizer.getIncrementSize(),integerType),integerType);\n{final QuerySpec rowsWithSequenceQuery=new QuerySpec(true);\nrowsWithSequenceQuery.getFromClause().addRoot(new CteTableGroup(new NamedTableReference(baseTableName,\"e\",false,factory)));\nrowsWithSequenceQuery.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,rowNumberColumnReference));\nfinal String fragment=((BulkInsertionCapableIdentifierGenerator)entityDescriptor.getIdentifierGenerator()).determineBulkInsertionIdentifierGenerationSelectFragment(sessionFactory.getSqlStringGenerationContext());\nrowsWithSequenceQuery.getSelectClause().addSqlSelection(new SqlSelectionImpl(2,1,new SelfRenderingSqlFragmentExpression(fragment)));\nrowsWithSequenceQuery.applyPredicate(new ComparisonPredicate(rowNumberMinusOneModuloIncrement,ComparisonOperator.EQUAL,new QueryLiteral<>(0,integerType)));\nfinal CteTable rowsWithSequenceCteTable=new CteTable(ROW_NUMBERS_WITH_SEQUENCE_VALUE,List.of(rowNumberColumn,idColumn));\nfinal SelectStatement rowsWithSequenceStatement=new SelectStatement(rowsWithSequenceQuery);\nfinal CteStatement rowsWithSequenceCte=new CteStatement(rowsWithSequenceCteTable,rowsWithSequenceStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(rowsWithSequenceCte);\n}{final QuerySpec entityQuery=new QuerySpec(true);\nfinal NavigablePath navigablePath=new NavigablePath(baseTableName);\nfinal TableGroup baseTableGroup=new TableGroupImpl(navigablePath,null,new NamedTableReference(baseTableName,\"e\",false,factory),null);\nfinal TableGroup rowsWithSequenceTableGroup=new CteTableGroup(new NamedTableReference(ROW_NUMBERS_WITH_SEQUENCE_VALUE,\"t\",false,factory));\nbaseTableGroup.addTableGroupJoin(new TableGroupJoin(rowsWithSequenceTableGroup.getNavigablePath(),SqlAstJoinType.LEFT,rowsWithSequenceTableGroup,new ComparisonPredicate(new BinaryArithmeticExpression(rowNumberColumnReference,BinaryArithmeticOperator.SUBTRACT,rowNumberMinusOneModuloIncrement,integerType),ComparisonOperator.EQUAL,new ColumnReference(\"t\",rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping()))));\nentityQuery.getFromClause().addRoot(baseTableGroup);\nentityQuery.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,new BinaryArithmeticExpression(new ColumnReference(\"t\",idColumn.getColumnExpression(),false,null,null,idColumn.getJdbcMapping()),BinaryArithmeticOperator.ADD,new BinaryArithmeticExpression(rowNumberColumnReference,BinaryArithmeticOperator.SUBTRACT,new ColumnReference(\"t\",rowNumberColumn.getColumnExpression(),false,null,null,rowNumberColumn.getJdbcMapping()),integerType),idType)));\nfinal CteTable finalEntityCteTable;\nif(targetPathCteColumns.contains(getCteTable().getCteColumns().get(0))){finalEntityCteTable=entityCteTable;\n}{targetPathCteColumns.add(0,getCteTable().getCteColumns().get(0));\nfinalEntityCteTable=createCteTable(getCteTable(),targetPathCteColumns,factory);\n}final List<CteColumn> cteColumns=finalEntityCteTable.getCteColumns();\nfor(int i=1; i < cteColumns.size(); i++){final CteColumn cteColumn=cteColumns.get(i);\nentityQuery.getSelectClause().addSqlSelection(new SqlSelectionImpl(i + 1,i,new ColumnReference(\"e\",cteColumn.getColumnExpression(),false,null,null,cteColumn.getJdbcMapping())));\n}final SelectStatement entityStatement=new SelectStatement(entityQuery);\nentityCte=new CteStatement(finalEntityCteTable,entityStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(entityCte);\n}}if(!assignsId && entityDescriptor.getIdentifierGenerator() instanceof PostInsertIdentifierGenerator){final String baseTableName=\"base_\" + entityCteTable.getTableExpression();\nfinal CteStatement baseEntityCte=new CteStatement(entityCteTable.withName(baseTableName),queryStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(baseEntityCte);\ntargetPathCteColumns.add(0,cteTable.getCteColumns().get(0));\nfinal CteTable finalEntityCteTable=createCteTable(getCteTable(),targetPathCteColumns,factory);\nfinal QuerySpec finalQuerySpec=new QuerySpec(true);\nfinal SelectStatement finalQueryStatement=new SelectStatement(finalQuerySpec);\nentityCte=new CteStatement(finalEntityCteTable,finalQueryStatement,CteMaterialization.MATERIALIZED);\n}{entityCte=new CteStatement(entityCteTable,queryStatement,CteMaterialization.MATERIALIZED);\nstatement.addCteStatement(entityCte);\n}final String baseInsertCte=addDmlCtes(statement,entityCte,targetPathColumns,assignsId,sqmConverter,parameterResolutions,factory);\nfinal Expression count=createCountStar(factory,sqmConverter);\ndomainResults.add(new BasicResult<>(0,null,((SqlExpressible)count).getJdbcMapping()));\nquerySpec.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,count));\nquerySpec.getFromClause().addRoot(new CteTableGroup(new NamedTableReference(baseInsertCte,CTE_TABLE_IDENTIFIER,false,factory)));\nfinal JdbcServices jdbcServices=factory.getJdbcServices();\nfinal SqlAstTranslator<JdbcSelect> translator=jdbcServices.getJdbcEnvironment().getSqlAstTranslatorFactory().buildSelectTranslator(factory,statement);\nfinal JdbcParameterBindings jdbcParameterBindings=SqmUtil.createJdbcParameterBindings(executionContext.getQueryParameterBindings(),domainParameterXref,SqmUtil.generateJdbcParamsXref(domainParameterXref,sqmConverter),factory.getRuntimeMetamodels().getMappingMetamodel(),navigablePath -> sqmConverter.getMutatingTableGroup(),new SqmParameterMappingModelResolutionAccess(){\n  @Override @SuppressWarnings(\"unchecked\") public <T>MappingModelExpressible<T> getResolvedMappingModelType(  SqmParameter<T> parameter){\n    return (MappingModelExpressible<T>)paramTypeResolutions.get(parameter);\n  }\n}\n,executionContext.getSession());\nfinal JdbcSelect select=translator.translate(jdbcParameterBindings,executionContext.getQueryOptions());\nexecutionContext.getSession().autoFlushIfRequired(select.getAffectedTableNames());\nList<Object> list=jdbcServices.getJdbcSelectExecutor().list(select,jdbcParameterBindings,SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext),row -> row[0],ListResultsConsumer.UniqueSemantic.NONE);\nreturn ((Number)list.get(0)).intValue();\n}",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.temptable.InsertExecutionDelegate#execute\n methodBody: public int execute(ExecutionContext executionContext) {\nExecuteWithTemporaryTableHelper.performBeforeTemporaryTableUseActions(entityTable,executionContext);\ntryif(sessionUidParameter != null){jdbcParameterBindings.addBinding(sessionUidParameter,new JdbcParameterBindingImpl(entityTable.getSessionUidColumn().getJdbcMapping(),UUID.fromString(sessionUidAccess.apply(executionContext.getSession()))));\n}final int rows=ExecuteWithTemporaryTableHelper.saveIntoTemporaryTable(insertStatement,jdbcParameterBindings,executionContext);\nif(rows != 0){final AbstractEntityPersister persister=(AbstractEntityPersister)entityDescriptor.getEntityPersister();\nfinal int tableSpan=persister.getTableSpan();\ninsertRootTable(persister.getTableName(0),rows,persister.getKeyColumns(0),executionContext);\nif(persister.hasDuplicateTables()){final String[] insertedTables=new String[tableSpan];\ninsertedTables[0]=persister.getTableName(0);\nfor(int i=1; i < tableSpan; i++){if(persister.isInverseTable(i)){continue;\n}final String tableName=persister.getTableName(i);\ninsertedTables[i]=tableName;\nif(ArrayHelper.indexOf(insertedTables,i,tableName) != -1){continue;\n}insertTable(tableName,persister.getKeyColumns(i),persister.isNullableTable(i),executionContext);\n}}{for(int i=1; i < tableSpan; i++){insertTable(persister.getTableName(i),persister.getKeyColumns(i),persister.isNullableTable(i),executionContext);\n}}}return rows;\nfinallyExecuteWithTemporaryTableHelper.performAfterTemporaryTableUseActions(entityTable,sessionUidAccess,afterUseAction,executionContext);\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#getResultSetReturn\n methodBody: public ResultSetReturn getResultSetReturn() {\nif(resultSetExtractor == null){resultSetExtractor=new ResultSetReturnImpl(this,jdbcServices);\n}return resultSetExtractor;\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#addObserver\n methodBody: void addObserver(BatchObserver observer);",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.temptable.UpdateExecutionDelegate#execute\n methodBody: public int execute(ExecutionContext executionContext) {\nExecuteWithTemporaryTableHelper.performBeforeTemporaryTableUseActions(idTable,executionContext);\ntryfinal int rows=ExecuteWithTemporaryTableHelper.saveMatchingIdsIntoIdTable(sqmConverter,suppliedPredicate,idTable,sessionUidAccess,jdbcParameterBindings,executionContext);\nfinal QuerySpec idTableSubQuery=ExecuteWithTemporaryTableHelper.createIdTableSelectQuerySpec(idTable,sessionUidAccess,entityDescriptor,executionContext);\nentityDescriptor.visitConstraintOrderedTables((tableExpression,tableKeyColumnVisitationSupplier) -> updateTable(tableExpression,tableKeyColumnVisitationSupplier,rows,idTableSubQuery,executionContext));\nreturn rows;\nfinallyExecuteWithTemporaryTableHelper.performAfterTemporaryTableUseActions(idTable,sessionUidAccess,afterUseAction,executionContext);\n}",
            "methodSignature: org.hibernate.metamodel.mapping.internal.MappingModelCreationProcess#execute\n methodBody: private void execute() {\nfor(EntityPersister entityPersister: entityPersisterMap.values()){if(entityPersister instanceof InFlightEntityMappingType){((InFlightEntityMappingType)entityPersister).linkWithSuperType(this);\n}}for(EntityPersister entityPersister: entityPersisterMap.values()){currentlyProcessingRole=entityPersister.getEntityName();\nif(entityPersister instanceof InFlightEntityMappingType){((InFlightEntityMappingType)entityPersister).prepareMappingModel(this);\n}}executePostInitCallbacks();\n}",
            "methodSignature: org.hibernate.orm.test.insertordering.InsertOrderingTest.StatsBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn new StatsBatch(key,jdbcCoordinator,getJdbcBatchSize());\n}",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.cte.AbstractCteMutationHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal SqmDeleteOrUpdateStatement sqmMutationStatement=getSqmDeleteOrUpdateStatement();\nfinal SessionFactoryImplementor factory=executionContext.getSession().getFactory();\nfinal EntityMappingType entityDescriptor=getEntityDescriptor();\nfinal String explicitDmlTargetAlias;\nif(sqmMutationStatement.getTarget().getExplicitAlias() == null){explicitDmlTargetAlias=\"dml_target\";\n}{explicitDmlTargetAlias=sqmMutationStatement.getTarget().getExplicitAlias();\n}final MultiTableSqmMutationConverter sqmConverter=new MultiTableSqmMutationConverter(entityDescriptor,sqmMutationStatement,sqmMutationStatement.getTarget(),explicitDmlTargetAlias,domainParameterXref,executionContext.getQueryOptions(),executionContext.getSession().getLoadQueryInfluencers(),executionContext.getQueryParameterBindings(),factory);\nfinal Map<SqmParameter<?>,List<JdbcParameter>> parameterResolutions;\nif(domainParameterXref.getSqmParameterCount() == 0){parameterResolutions=Collections.emptyMap();\n}{parameterResolutions=new IdentityHashMap<>();\n}final Map<SqmParameter,MappingModelExpressible> paramTypeResolutions=new LinkedHashMap<>();\nfinal Predicate restriction=sqmConverter.visitWhereClause(sqmMutationStatement.getWhereClause(),columnReference -> {\n}\n,(sqmParam,mappingType,jdbcParameters) -> paramTypeResolutions.put(sqmParam,mappingType));\nsqmConverter.pruneTableGroupJoins();\nfinal CteStatement idSelectCte=new CteStatement(getCteTable(),MatchingIdSelectionHelper.generateMatchingIdSelectStatement(entityDescriptor,sqmMutationStatement,true,restriction,sqmConverter,executionContext,factory),CteMaterialization.MATERIALIZED);\nfinal QuerySpec querySpec=new QuerySpec(true,1);\nfinal List<DomainResult<?>> domainResults=new ArrayList<>(1);\nfinal SelectStatement statement=new SelectStatement(querySpec,domainResults);\nfinal JdbcServices jdbcServices=factory.getJdbcServices();\nfinal SqlAstTranslator<JdbcSelect> translator=jdbcServices.getJdbcEnvironment().getSqlAstTranslatorFactory().buildSelectTranslator(factory,statement);\nfinal Expression count=createCountStar(factory,sqmConverter);\ndomainResults.add(new BasicResult<>(0,null,((SqlExpressible)count).getJdbcMapping()));\nquerySpec.getSelectClause().addSqlSelection(new SqlSelectionImpl(1,0,count));\nquerySpec.getFromClause().addRoot(new CteTableGroup(new NamedTableReference(idSelectCte.getCteTable().getTableExpression(),CTE_TABLE_IDENTIFIER,false,factory)));\nstatement.addCteStatement(idSelectCte);\naddDmlCtes(statement,idSelectCte,sqmConverter,parameterResolutions,factory);\nfinal JdbcParameterBindings jdbcParameterBindings=SqmUtil.createJdbcParameterBindings(executionContext.getQueryParameterBindings(),domainParameterXref,SqmUtil.generateJdbcParamsXref(domainParameterXref,sqmConverter),factory.getRuntimeMetamodels().getMappingMetamodel(),navigablePath -> sqmConverter.getMutatingTableGroup(),paramTypeResolutions::get,executionContext.getSession());\nfinal LockOptions lockOptions=executionContext.getQueryOptions().getLockOptions();\nfinal LockMode lockMode=lockOptions.getAliasSpecificLockMode(explicitDmlTargetAlias);\nlockOptions.setAliasSpecificLockMode(explicitDmlTargetAlias,LockMode.WRITE);\nfinal JdbcSelect select=translator.translate(jdbcParameterBindings,executionContext.getQueryOptions());\nlockOptions.setAliasSpecificLockMode(explicitDmlTargetAlias,lockMode);\nexecutionContext.getSession().autoFlushIfRequired(select.getAffectedTableNames());\nList<Object> list=jdbcServices.getJdbcSelectExecutor().list(select,jdbcParameterBindings,SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext),row -> row[0],ListResultsConsumer.UniqueSemantic.NONE);\nreturn ((Number)list.get(0)).intValue();\n}",
            "methodSignature: org.hibernate.mapping.Component.ValueGenerationPlan#execute\n methodBody: public void execute(SharedSessionContractImplementor session, Object incomingObject, Object injectionContext) {\nfinal Object generatedValue=subGenerator.generate(session,incomingObject);\ninjector.set(injectionContext,generatedValue);\n}",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.temptable.TableBasedInsertHandler.ExecutionDelegate#execute\n methodBody: int execute(ExecutionContext executionContext);",
            "methodSignature: org.hibernate.dialect.AbstractHANADialect.MaterializedNClob#setString\n methodBody: public int setString(long pos, String str) throws SQLException {\nthis.data=this.data.substring(0,(int)(pos - 1)) + str + this.data.substring((int)(pos - 1 + str.length()));\nreturn str.length();\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch#addToBatch\n methodBody: public void addToBatch() {\nnotifyObserversImplicitExecution();\nfor(Map.Entry<String,PreparedStatement> entry: getStatements().entrySet()){final String statementSQL=entry.getKey();\ntryfinal PreparedStatement statement=entry.getValue();\nfinal int rowCount=jdbcCoordinator.getResultSetReturn().executeUpdate(statement);\ngetKey().getExpectation().verifyOutcome(rowCount,statement,0,statementSQL);\njdbcCoordinator.getLogicalConnection().getResourceRegistry().release(statement);\njdbcCoordinator.afterStatementExecution();\ncatch(SQLException e)abortBatch(e);\nthrow sqlExceptionHelper().convert(e,\"could not execute non-batched batch statement\",statementSQL);\ncatch(RuntimeException e)abortBatch(e);\nthrow e;\n}getStatements().clear();\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#getStatementPreparer\n methodBody: public StatementPreparer getStatementPreparer() {\nif(statementPreparer == null){statementPreparer=new StatementPreparerImpl(this,jdbcServices);\n}return statementPreparer;\n}",
            "methodSignature: org.hibernate.sql.Insert#getDialect\n methodBody: protected Dialect getDialect() {\nreturn dialect;\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#release\n methodBody: public void release() {\nif(getStatements() != null && !getStatements().isEmpty()){LOG.batchContainedStatementsOnRelease();\n}releaseStatements();\nobservers.clear();\n}",
            "methodSignature: org.hibernate.sql.exec.internal.StandardJdbcMutationExecutor#execute\n methodBody: public int execute(\n\t\t\tJdbcMutation jdbcMutation,\n\t\t\tJdbcParameterBindings jdbcParameterBindings,\n\t\t\tFunction<String, PreparedStatement> statementCreator,\n\t\t\tBiConsumer<Integer, PreparedStatement> expectationCheck,\n\t\t\tExecutionContext executionContext) {\nfinal SharedSessionContractImplementor session=executionContext.getSession();\nsession.autoFlushIfRequired(jdbcMutation.getAffectedTableNames());\nfinal LogicalConnectionImplementor logicalConnection=session.getJdbcCoordinator().getLogicalConnection();\nfinal JdbcServices jdbcServices=session.getJdbcServices();\nfinal QueryOptions queryOptions=executionContext.getQueryOptions();\nfinal String finalSql;\nif(queryOptions == null){finalSql=jdbcMutation.getSql();\n}{finalSql=jdbcServices.getDialect().addSqlHintOrComment(jdbcMutation.getSql(),queryOptions,executionContext.getSession().getFactory().getSessionFactoryOptions().isCommentsEnabled());\n}tryfinal PreparedStatement preparedStatement=statementCreator.apply(finalSql);\ntryif(executionContext.getQueryOptions().getTimeout() != null){preparedStatement.setQueryTimeout(executionContext.getQueryOptions().getTimeout());\n}int paramBindingPosition=1;\nfor(JdbcParameterBinder parameterBinder: jdbcMutation.getParameterBinders()){parameterBinder.bindParameterValue(preparedStatement,paramBindingPosition++,jdbcParameterBindings,executionContext);\n}session.getEventListenerManager().jdbcExecuteStatementStart();\ntryint rows=preparedStatement.executeUpdate();\nexpectationCheck.accept(rows,preparedStatement);\nreturn rows;\nfinallysession.getEventListenerManager().jdbcExecuteStatementEnd();\nfinallylogicalConnection.getResourceRegistry().release(preparedStatement);\ncatch(SQLException e)throw jdbcServices.getSqlExceptionHelper().convert(e,\"JDBC exception executing SQL [\" + finalSql + \"]\");\nfinallyexecutionContext.afterStatement(logicalConnection);\n}",
            "methodSignature: org.hibernate.sql.exec.spi.JdbcMutationExecutor#execute\n methodBody: int execute(\n\t\t\tJdbcMutation jdbcMutation,\n\t\t\tJdbcParameterBindings jdbcParameterBindings,\n\t\t\tFunction<String, PreparedStatement> statementCreator,\n\t\t\tBiConsumer<Integer, PreparedStatement> expectationCheck,\n\t\t\tExecutionContext executionContext);",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#addObserver\n methodBody: public void addObserver(BatchObserver observer) {\nobservers.add(observer);\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.BatchingBatch#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\ncurrentStatementSql=sql;\nint previousBatchSize=getStatements().size();\ncurrentStatement=super.getBatchStatement(sql,callable);\nint currentBatchSize=getStatements().size();\nif(currentBatchSize > previousBatchSize){this.batchSize=this.configuredBatchSize * currentBatchSize;\n}return currentStatement;\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#getBatchStatement\n methodBody: PreparedStatement getBatchStatement(String sql, boolean callable);",
            "methodSignature: org.hibernate.engine.jdbc.spi.JdbcCoordinator#close\n methodBody: Connection close();",
            "methodSignature: org.hibernate.engine.jdbc.batch.spi.Batch#addToBatch\n methodBody: void addToBatch();",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.BatchingBatch#addToBatch\n methodBody: public void addToBatch() {\ntrycurrentStatement.addBatch();\ncatch(SQLException e)abortBatch(e);\nLOG.debug(\"SQLException escaped proxy\",e);\nthrow sqlExceptionHelper().convert(e,\"could not perform addBatch\",currentStatementSql);\ncatch(RuntimeException e)abortBatch(e);\nthrow e;\nstatementPosition++;\nif(statementPosition >= getKey().getBatchedStatementCount()){batchPosition++;\nif(batchPosition == batchSize){notifyObserversImplicitExecution();\nperformExecution();\nbatchPosition=0;\nbatchExecuted=true;\n}statementPosition=0;\n}}",
            "methodSignature: org.hibernate.action.internal.BulkOperationCleanupAction.CollectionCleanup#release\n methodBody: private void release() {\ncacheAccess.unlockRegion(cacheLock);\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#execute\n methodBody: public final void execute() {\nnotifyObserversExplicitExecution();\nif(getStatements().isEmpty()){return;\n}trydoExecuteBatch();\nfinallyreleaseStatements();\n}",
            "methodSignature: org.hibernate.action.internal.BulkOperationCleanupAction.EntityCleanup#release\n methodBody: private void release() {\ncacheAccess.unlockRegion(cacheLock);\n}",
            "methodSignature: org.hibernate.sql.results.jdbc.internal.DeferredResultSetAccess#release\n methodBody: public void release() {\nif(resultSet != null){getPersistenceContext().getJdbcCoordinator().getLogicalConnection().getResourceRegistry().release(resultSet,preparedStatement);\nresultSet=null;\n}if(preparedStatement != null){getPersistenceContext().getJdbcCoordinator().getLogicalConnection().getResourceRegistry().release(preparedStatement);\npreparedStatement=null;\n}}",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.temptable.RestrictedDeleteExecutionDelegate#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nfinal EntityPersister entityDescriptor=sessionFactory.getRuntimeMetamodels().getMappingMetamodel().getEntityDescriptor(sqmDelete.getTarget().getEntityName());\nfinal String hierarchyRootTableName=((Joinable)entityDescriptor).getTableName();\nfinal TableGroup deletingTableGroup=converter.getMutatingTableGroup();\nfinal TableReference hierarchyRootTableReference=deletingTableGroup.resolveTableReference(deletingTableGroup.getNavigablePath(),hierarchyRootTableName);\nassert hierarchyRootTableReference != null;\nfinal Map<SqmParameter<?>,List<List<JdbcParameter>>> parameterResolutions;\nfinal Map<SqmParameter<?>,MappingModelExpressible<?>> paramTypeResolutions;\nif(domainParameterXref.getSqmParameterCount() == 0){parameterResolutions=Collections.emptyMap();\nparamTypeResolutions=Collections.emptyMap();\n}{parameterResolutions=new IdentityHashMap<>();\nparamTypeResolutions=new LinkedHashMap<>();\n}final MutableBoolean needsIdTableWrapper=new MutableBoolean(false);\nfinal Predicate specifiedRestriction=converter.visitWhereClause(sqmDelete.getWhereClause(),columnReference -> {\n  if (!hierarchyRootTableReference.getIdentificationVariable().equals(columnReference.getQualifier())) {\n    needsIdTableWrapper.setValue(true);\n  }\n}\n,(sqmParameter,mappingType,jdbcParameters) -> {\n  parameterResolutions.computeIfAbsent(sqmParameter,k -> new ArrayList<>(1)).add(jdbcParameters);\n  paramTypeResolutions.put(sqmParameter,mappingType);\n}\n);\nfinal PredicateCollector predicateCollector=new PredicateCollector(specifiedRestriction);\nentityDescriptor.applyBaseRestrictions((filterPredicate) -> {\n  needsIdTableWrapper.setValue(true);\n  predicateCollector.applyPredicate(filterPredicate);\n}\n,deletingTableGroup,true,executionContext.getSession().getLoadQueryInfluencers().getEnabledFilters(),null,converter);\nconverter.pruneTableGroupJoins();\nfinal boolean needsIdTable=needsIdTableWrapper.getValue() || entityDescriptor != entityDescriptor.getRootEntityDescriptor();\nfinal SqmJdbcExecutionContextAdapter executionContextAdapter=SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext);\nif(needsIdTable){return executeWithIdTable(predicateCollector.getPredicate(),deletingTableGroup,parameterResolutions,paramTypeResolutions,executionContextAdapter);\n}{return executeWithoutIdTable(predicateCollector.getPredicate(),deletingTableGroup,parameterResolutions,paramTypeResolutions,converter.getSqlExpressionResolver(),executionContextAdapter);\n}}",
            "methodSignature: org.hibernate.orm.test.jpa.transaction.batch.JtaWithFailingBatchTest.TestBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn buildBatchTest(key,jdbcCoordinator,getJdbcBatchSize());\n}",
            "methodSignature: org.hibernate.orm.test.jpa.transaction.batch.FailingAddToBatchTest.TestBatch#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\nPreparedStatement batchStatement=super.getBatchStatement(sql,callable);\ncreatedStatements.add(batchStatement);\nreturn batchStatement;\n}",
            "methodSignature: org.hibernate.orm.test.jpa.transaction.batch.JtaWithStatementsBatchTest.TestBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn buildBatchTest(key,jdbcCoordinator,getJdbcBatchSize());\n}",
            "methodSignature: org.hibernate.orm.test.manytomany.batchload.TestingBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn new TestingBatch(key,jdbcCoordinator);\n}",
            "methodSignature: org.hibernate.persister.collection.AbstractCollectionPersister#getDialect\n methodBody: protected Dialect getDialect() {\nreturn dialect;\n}",
            "methodSignature: org.hibernate.engine.jdbc.spi.JdbcCoordinator#getLogicalConnection\n methodBody: LogicalConnectionImplementor getLogicalConnection();",
            "methodSignature: org.hibernate.query.sqm.mutation.internal.temptable.TableBasedInsertHandler#execute\n methodBody: public int execute(DomainQueryExecutionContext executionContext) {\nif(log.isTraceEnabled()){log.tracef(\"Starting multi-table insert execution - %s\",getSqmInsertStatement().getTarget().getModel().getName());\n}final SqmJdbcExecutionContextAdapter executionContextAdapter=SqmJdbcExecutionContextAdapter.omittingLockingAndPaging(executionContext);\nreturn resolveDelegate(executionContext).execute(executionContextAdapter);\n}",
            "methodSignature: org.hibernate.orm.test.insertordering.InsertOrderingTest.StatsBatch#getBatchStatement\n methodBody: public PreparedStatement getBatchStatement(String sql, boolean callable) {\nif(batchSQL == null || !batchSQL.equals(sql)){currentBatch++;\nbatchSQL=sql;\nbatchSizes.add(currentBatch,new Counter());\n}return super.getBatchStatement(sql,callable);\n}",
            "methodSignature: org.hibernate.engine.jdbc.spi.JdbcCoordinator#getResultSetReturn\n methodBody: ResultSetReturn getResultSetReturn();",
            "methodSignature: org.hibernate.sql.ast.spi.AbstractSqlAstTranslator#getDialect\n methodBody: public Dialect getDialect() {\nreturn dialect;\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.BatchBuilderImpl#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn SharedBatchBuildingCode.buildBatch(jdbcBatchSize,key,jdbcCoordinator);\n}",
            "methodSignature: org.hibernate.orm.test.jpa.transaction.batch.FailingAddToBatchTest.TestBatchBuilder#buildBatch\n methodBody: public Batch buildBatch(BatchKey key, JdbcCoordinator jdbcCoordinator) {\nreturn buildBatchTest(key,jdbcCoordinator,getJdbcBatchSize());\n}",
            "methodSignature: org.hibernate.orm.test.jpa.transaction.batch.FailingAddToBatchTest.TestBatch#addToBatch\n methodBody: public void addToBatch() {\nRuntimeException failure=nextAddToBatchFailure.getAndSet(null);\nif(failure != null){throw failure;\n}super.addToBatch();\n}",
            "methodSignature: org.hibernate.dialect.Dialect#getDropTableString\n methodBody: public String getDropTableString(String tableName) {\nfinal StringBuilder buf=new StringBuilder(\"drop table \");\nif(supportsIfExistsBeforeTableName()){buf.append(\"if exists \");\n}buf.append(tableName).append(getCascadeConstraintsString());\nif(supportsIfExistsAfterTableName()){buf.append(\" if exists\");\n}return buf.toString();\n}",
            "methodSignature: org.hibernate.engine.jdbc.batch.internal.AbstractBatchImpl#getJdbcCoordinator\n methodBody: protected JdbcCoordinator getJdbcCoordinator(){\nreturn this.jdbcCoordinator;\n}",
            "methodSignature: org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl#sessionFactory\n methodBody: protected SessionFactoryImplementor sessionFactory() {\nreturn this.owner.getJdbcSessionContext().getSessionFactory();\n}",
            "methodSignature: org.hibernate.dialect.AbstractHANADialect.CloseSuppressingReader#close\n methodBody: public void close() {\n}",
            "methodSignature: org.hibernate.sql.ast.spi.AbstractSqlAstTranslator#getJdbcServices\n methodBody: protected JdbcServices getJdbcServices() {\nreturn getSessionFactory().getJdbcServices();\n}"
        ],
        "sourceCodeAfterRefactoring": "@Test\n\tpublic void testBatchingUsage() throws Exception {\n\t\tfinal Session session = openSession();\n\t\tfinal SessionImplementor sessionImpl = (SessionImplementor) session;\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\n\t\texportSandboxSchema( sessionImpl );\n\n\t\t// ok, now we can get down to it...\n\t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n\t\ttxn.begin();\n\n\t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n\n\t\tfinal BatchBuilderImpl batchBuilder = new BatchBuilderImpl( 2 );\n\t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\" );\n\t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, null, SANDBOX_TBL, sessionImpl, insertSql );\n\t\tassertThat( insertBatch ).isNotNull();\n\n\t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n\t\tinsertBatch.addObserver( batchObserver );\n\n\t\tfinal JdbcValueBindingsImpl jdbcValueBindings = sandboxInsertValueBindings( sessionImpl );\n\n\t\t// bind values for #1 - should do nothing at the JDBC level\n\t\tjdbcValueBindings.bindValue( 1, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n\t\tjdbcValueBindings.bindValue( \"name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isFalse();\n\n\t\t// add #1 to the batch - will acquire prepared statement to bind values\n\t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n        assertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\t// bind values for #2 - again, nothing at JDBC level (we have statement from earlier)\n\t\tjdbcValueBindings.bindValue( 2, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n\t\tjdbcValueBindings.bindValue( \"another name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n\n\t\t// add #2 to the batch -\n\t\t// \t\t- uses the previous prepared statement to bind values\n\t\t//\t\t- batch size has been exceeded, trigger an implicit execution\n\t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 1 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n\n\t\t// execute the batch - effectively only increments the explicit-execution counter\n\t\tinsertBatch.execute();\n\t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 1 );\n\t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 1 );\n\t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isFalse();\n\n\t\tinsertBatch.release();\n\n\t\ttxn.commit();\n\t\tsession.close();\n\t}\nprivate void exportSandboxSchema(SessionImplementor sessionImpl) {\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n\n\t\t// set up some tables to use\n\t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n\t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n\t\ttry {\n\t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n\t\t}\n\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n\t\tassertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n\t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n\t\tassertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n\t}",
        "diffSourceCode": "-  102:         assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n-  103: \n-  104: \t\tinsertBatch.release();\n-  105: \n-  106: \t\ttxn.commit();\n-  107: \t\tsession.close();\n-  108: \t}\n+  102: \t@Test\n+  103: \tpublic void testBatchingUsage() throws Exception {\n+  104: \t\tfinal Session session = openSession();\n+  105: \t\tfinal SessionImplementor sessionImpl = (SessionImplementor) session;\n+  106: \t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n+  107: \n+  108: \t\texportSandboxSchema( sessionImpl );\n   109: \n-  110: \t@Test\n-  111: \tpublic void testBatchingUsage() throws Exception {\n-  112: \t\tSession session = openSession();\n-  113: \t\tSessionImplementor sessionImpl = (SessionImplementor) session;\n-  114: \t\t\n-  115: \t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n-  116: \t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n-  117: \n-  118: \t\t// set up some tables to use\n-  119: \t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n-  120: \t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n-  121: \t\ttry {\n-  122: \t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n-  123: \t\t}\n-  124: \t\tcatch ( Exception e ) {\n-  125: \t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n-  126: \t\t}\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n-  127:         assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n-  128: \t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n-  129:         jdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n-  130:         assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n-  131: \t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n+  110: \t\t// ok, now we can get down to it...\n+  111: \t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n+  112: \t\ttxn.begin();\n+  113: \n+  114: \t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n+  115: \n+  116: \t\tfinal BatchBuilderImpl batchBuilder = new BatchBuilderImpl( 2 );\n+  117: \t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\" );\n+  118: \t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, null, SANDBOX_TBL, sessionImpl, insertSql );\n+  119: \t\tassertThat( insertBatch ).isNotNull();\n+  120: \n+  121: \t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n+  122: \t\tinsertBatch.addObserver( batchObserver );\n+  123: \n+  124: \t\tfinal JdbcValueBindingsImpl jdbcValueBindings = sandboxInsertValueBindings( sessionImpl );\n+  125: \n+  126: \t\t// bind values for #1 - should do nothing at the JDBC level\n+  127: \t\tjdbcValueBindings.bindValue( 1, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n+  128: \t\tjdbcValueBindings.bindValue( \"name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n+  129: \t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n+  130: \t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n+  131: \t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isFalse();\n   132: \n-  133: \t\t// ok, now we can get down to it...\n-  134: \t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n-  135: \t\ttxn.begin();\n-  136: \n-  137: \t\tfinal BatchBuilder batchBuilder = new BatchBuilderImpl( 2 );\n-  138: \t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\", Expectations.BASIC );\n-  139: \t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, jdbcCoordinator );\n-  140: \t\tassertTrue( \"unexpected Batch impl\", BatchingBatch.class.isInstance( insertBatch ) );\n-  141: \n-  142: \t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n-  143: \t\tinsertBatch.addObserver( batchObserver );\n+  133: \t\t// add #1 to the batch - will acquire prepared statement to bind values\n+  134: \t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n+  135: \t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n+  136: \t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n+  137:         assertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n+  138: \n+  139: \t\t// bind values for #2 - again, nothing at JDBC level (we have statement from earlier)\n+  140: \t\tjdbcValueBindings.bindValue( 2, SANDBOX_TBL, \"ID\", ParameterUsage.SET, sessionImpl );\n+  141: \t\tjdbcValueBindings.bindValue( \"another name\", SANDBOX_TBL, \"NAME\", ParameterUsage.SET, sessionImpl );\n+  142: \t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n+  143: \t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 0 );\n   144: \n-  145: \t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n-  146: \n-  147: \t\tPreparedStatement insert = insertBatch.getBatchStatement( insertSql, false );\n-  148: \t\tinsert.setLong( 1, 1 );\n-  149: \t\tinsert.setString( 2, \"name\" );\n-  150: \t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n-  151: \t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n-  152: \t\tinsertBatch.addToBatch();\n-  153: \t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n-  154: \t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n-  155:         assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n-  156: \n-  157: \t\tPreparedStatement insert2 = insertBatch.getBatchStatement( insertSql, false );\n-  158: \t\tassertSame( insert, insert2 );\n-  159: \t\tinsert = insert2;\n-  160: \t\tinsert.setLong( 1, 2 );\n-  161: \t\tinsert.setString( 2, \"another name\" );\n-  162: \t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n-  163: \t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n-  164: \t\tinsertBatch.addToBatch();\n-  165: \t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n-  166: \t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n-  167:         assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n-  168: \n-  169: \t\tinsertBatch.execute();\n-  170: \t\tassertEquals( 1, batchObserver.getExplicitExecutionCount() );\n-  171: \t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n-  172:         assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n-  173: \n-  174: \t\tinsertBatch.release();\n-  175: \n-  176: \t\ttxn.commit();\n-  177: \t\tsession.close();\n-  178: \t}\n+  145: \t\t// add #2 to the batch -\n+  146: \t\t// \t\t- uses the previous prepared statement to bind values\n+  147: \t\t//\t\t- batch size has been exceeded, trigger an implicit execution\n+  148: \t\tinsertBatch.addToBatch( jdbcValueBindings, null );\n+  149: \t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 0 );\n+  150: \t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 1 );\n+  151: \t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isTrue();\n+  152: \n+  153: \t\t// execute the batch - effectively only increments the explicit-execution counter\n+  154: \t\tinsertBatch.execute();\n+  155: \t\tassertThat( batchObserver.getExplicitExecutionCount() ).isEqualTo( 1 );\n+  156: \t\tassertThat( batchObserver.getImplicitExecutionCount() ).isEqualTo( 1 );\n+  157: \t\tassertThat( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() ).isFalse();\n+  158: \n+  159: \t\tinsertBatch.release();\n+  160: \n+  161: \t\ttxn.commit();\n+  162: \t\tsession.close();\n+  163: \t}\n+  164: \n+  165: \tprivate JdbcValueBindingsImpl sandboxInsertValueBindings(SessionImplementor session) {\n+  166: \t\treturn new JdbcValueBindingsImpl(\n+  167: \t\t\t\tMutationType.INSERT,\n+  168: \t\t\t\tnull,\n+  169: \t\t\t\t(tableName, columnName, usage) -> {\n+  170: \t\t\t\t\tassert tableName.equals( SANDBOX_TBL );\n+  171: \n+  172: \t\t\t\t\tif ( columnName.equals( \"ID\" ) ) {\n+  173: \t\t\t\t\t\treturn new JdbcValueDescriptor() {\n+  174: \t\t\t\t\t\t\t@Override\n+  175: \t\t\t\t\t\t\tpublic String getColumnName() {\n+  176: \t\t\t\t\t\t\t\treturn \"ID\";\n+  177: \t\t\t\t\t\t\t}\n+  178: \n+  304: \tprivate void exportSandboxSchema(SessionImplementor sessionImpl) {\n+  305: \t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n+  306: \t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n+  307: \n+  308: \t\t// set up some tables to use\n+  309: \t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n+  310: \t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n+  311: \t\ttry {\n+  312: \t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n+  313: \t\t}\n+  314: \t\tcatch ( Exception e ) {\n+  315: \t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n+  316: \t\t}\n+  317: \t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n+  318: \t\tassertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n+  319: \t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n+  320: \t\tjdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n+  321: \t\tassertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n+  322: \t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n+  323: \t}\n",
        "uniqueId": "a9ac98b364ccf52bb9cb2be5324c9c983e8bd8b3_110_178_304_323_102_163",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 11,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": true,
        "refactoredCode": "##########################\nprivate void setupTables(JdbcCoordinator jdbcCoordinator) {\n    Statement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n    String dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString(\"SANDBOX_JDBC_TST\");\n    try {\n        jdbcCoordinator.getResultSetReturn().execute(statement, dropSql);\n    } catch (Exception e) {\n        // ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n    }\n    jdbcCoordinator.getResultSetReturn().execute(statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\");\n    assertTrue(jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources());\n    assertTrue(jdbcCoordinator.getLogicalConnection().isPhysicallyConnected());\n    jdbcCoordinator.getLogicalConnection().getResourceRegistry().release(statement);\n    assertFalse(jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources());\n    assertTrue(jdbcCoordinator.getLogicalConnection().isPhysicallyConnected()); // after_transaction specified\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Test\n\tpublic void testBatchingUsage() throws Exception {\n\t\tSession session = openSession();\n\t\tSessionImplementor sessionImpl = (SessionImplementor) session;\n\t\t\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n\n\t\t// set up some tables to use\n\t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n\t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n\t\ttry {\n\t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n\t\t}\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n        jdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n\n\t\t// ok, now we can get down to it...\n\t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n\t\ttxn.begin();\n\n\t\tfinal BatchBuilder batchBuilder = new BatchBuilderImpl( 2 );\n\t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\", Expectations.BASIC );\n\t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, jdbcCoordinator );\n\t\tassertTrue( \"unexpected Batch impl\", BatchingBatch.class.isInstance( insertBatch ) );\n\n\t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n\t\tinsertBatch.addObserver( batchObserver );\n\n\t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n\n\t\tPreparedStatement insert = insertBatch.getBatchStatement( insertSql, false );\n\t\tinsert.setLong( 1, 1 );\n\t\tinsert.setString( 2, \"name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tPreparedStatement insert2 = insertBatch.getBatchStatement( insertSql, false );\n\t\tassertSame( insert, insert2 );\n\t\tinsert = insert2;\n\t\tinsert.setLong( 1, 2 );\n\t\tinsert.setString( 2, \"another name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.execute();\n\t\tassertEquals( 1, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.release();\n\n\t\ttxn.commit();\n\t\tsession.close();\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.orm.test.jdbc.internal;\n\nimport java.sql.PreparedStatement;\nimport java.sql.Statement;\n\nimport org.hibernate.Session;\nimport org.hibernate.Transaction;\nimport org.hibernate.engine.jdbc.batch.internal.BasicBatchKey;\nimport org.hibernate.engine.jdbc.batch.internal.BatchBuilderImpl;\nimport org.hibernate.engine.jdbc.batch.internal.BatchingBatch;\nimport org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch;\nimport org.hibernate.engine.jdbc.batch.spi.Batch;\nimport org.hibernate.engine.jdbc.batch.spi.BatchBuilder;\nimport org.hibernate.engine.jdbc.batch.spi.BatchKey;\nimport org.hibernate.engine.jdbc.spi.JdbcCoordinator;\nimport org.hibernate.engine.spi.SessionImplementor;\nimport org.hibernate.jdbc.Expectation;\nimport org.hibernate.jdbc.Expectations;\nimport org.hibernate.resource.jdbc.spi.LogicalConnectionImplementor;\n\nimport org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;\nimport org.hibernate.orm.test.common.JournalingBatchObserver;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertSame;\nimport static org.junit.Assert.assertTrue;\n\n/**\n * @author Steve Ebersole\n * @author Brett Meyer\n */\npublic class BatchingTest extends BaseCoreFunctionalTestCase implements BatchKey {\n\t@Override\n\tpublic int getBatchedStatementCount() {\n\t\treturn 1;\n\t}\n\n\t@Override\n\tpublic Expectation getExpectation() {\n\t\treturn Expectations.BASIC;\n\t}\n\n\t@Test\n\tpublic void testNonBatchingUsage() throws Exception {\n\t\tSession session = openSession();\n\t\tSessionImplementor sessionImpl = (SessionImplementor) session;\n\t\t\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n\n\t\t// set up some tables to use\n\t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n\t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n\t\ttry {\n\t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n\t\t}\n\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n        jdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n\n\t\t// ok, now we can get down to it...\n\t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n\t\ttxn.begin();\n\n\t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n\n\t\tfinal BatchBuilder batchBuilder = new BatchBuilderImpl( -1 );\n\t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\", Expectations.BASIC );\n\t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, jdbcCoordinator );\n\n\t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n\t\tinsertBatch.addObserver( batchObserver );\n\n\t\tassertTrue( \"unexpected Batch impl\", NonBatchingBatch.class.isInstance( insertBatch ) );\n\t\tPreparedStatement insert = insertBatch.getBatchStatement( insertSql, false );\n\t\tinsert.setLong( 1, 1 );\n\t\tinsert.setString( 2, \"name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.execute();\n\t\tassertEquals( 1, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.release();\n\n\t\ttxn.commit();\n\t\tsession.close();\n\t}\n\n\t@Test\n\tpublic void testBatchingUsage() throws Exception {\n\t\tSession session = openSession();\n\t\tSessionImplementor sessionImpl = (SessionImplementor) session;\n\t\t\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n\n\t\t// set up some tables to use\n\t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n\t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n\t\ttry {\n\t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n\t\t}\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n        jdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n\n\t\t// ok, now we can get down to it...\n\t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n\t\ttxn.begin();\n\n\t\tfinal BatchBuilder batchBuilder = new BatchBuilderImpl( 2 );\n\t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\", Expectations.BASIC );\n\t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, jdbcCoordinator );\n\t\tassertTrue( \"unexpected Batch impl\", BatchingBatch.class.isInstance( insertBatch ) );\n\n\t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n\t\tinsertBatch.addObserver( batchObserver );\n\n\t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n\n\t\tPreparedStatement insert = insertBatch.getBatchStatement( insertSql, false );\n\t\tinsert.setLong( 1, 1 );\n\t\tinsert.setString( 2, \"name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tPreparedStatement insert2 = insertBatch.getBatchStatement( insertSql, false );\n\t\tassertSame( insert, insert2 );\n\t\tinsert = insert2;\n\t\tinsert.setLong( 1, 2 );\n\t\tinsert.setString( 2, \"another name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.execute();\n\t\tassertEquals( 1, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.release();\n\n\t\ttxn.commit();\n\t\tsession.close();\n\t}\n\n\t@Test\n\tpublic void testSessionBatchingUsage() throws Exception {\n\t\tSession session = openSession();\n\t\tsession.setJdbcBatchSize( 3 );\n\t\tSessionImplementor sessionImpl = (SessionImplementor) session;\n\n\t\tfinal JdbcCoordinator jdbcCoordinator = sessionImpl.getJdbcCoordinator();\n\t\tLogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();\n\n\t\t// set up some tables to use\n\t\tStatement statement = jdbcCoordinator.getStatementPreparer().createStatement();\n\t\tString dropSql = sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" );\n\t\ttry {\n\t\t\tjdbcCoordinator.getResultSetReturn().execute( statement, dropSql );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\t// ignore if the DB doesn't support \"if exists\" and the table doesn't exist\n\t\t}\t\tjdbcCoordinator.getResultSetReturn().execute( statement, \"create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )\" );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() );\n        jdbcCoordinator.getLogicalConnection().getResourceRegistry().release( statement );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\t\tassertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified\n\n\t\t// ok, now we can get down to it...\n\t\tTransaction txn = session.getTransaction();  // same as Session#getTransaction\n\t\ttxn.begin();\n\n\t\tfinal BatchBuilder batchBuilder = new BatchBuilderImpl( 2 );\n\t\tfinal BatchKey batchKey = new BasicBatchKey( \"this\", Expectations.BASIC );\n\t\tfinal Batch insertBatch = batchBuilder.buildBatch( batchKey, jdbcCoordinator );\n\t\tassertTrue( \"unexpected Batch impl\", BatchingBatch.class.isInstance( insertBatch ) );\n\n\t\tfinal JournalingBatchObserver batchObserver = new JournalingBatchObserver();\n\t\tinsertBatch.addObserver( batchObserver );\n\n\t\tfinal String insertSql = \"insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )\";\n\n\t\tPreparedStatement insert = insertBatch.getBatchStatement( insertSql, false );\n\t\tinsert.setLong( 1, 1 );\n\t\tinsert.setString( 2, \"name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tPreparedStatement insert2 = insertBatch.getBatchStatement( insertSql, false );\n\t\tassertSame( insert, insert2 );\n\t\tinsert = insert2;\n\t\tinsert.setLong( 1, 2 );\n\t\tinsert.setString( 2, \"another name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tPreparedStatement insert3 = insertBatch.getBatchStatement( insertSql, false );\n\t\tassertSame( insert, insert3 );\n\t\tinsert = insert3;\n\t\tinsert.setLong( 1, 3 );\n\t\tinsert.setString( 2, \"yet another name\" );\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 0, batchObserver.getImplicitExecutionCount() );\n\t\tinsertBatch.addToBatch();\n\t\tassertEquals( 0, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertTrue( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.execute();\n\t\tassertEquals( 1, batchObserver.getExplicitExecutionCount() );\n\t\tassertEquals( 1, batchObserver.getImplicitExecutionCount() );\n        assertFalse( jdbcCoordinator.getLogicalConnection().getResourceRegistry().hasRegisteredResources() );\n\n\t\tinsertBatch.release();\n\n\t\ttxn.commit();\n\t\tsession.close();\n\t}\n\n\t@Override\n\tprotected void cleanupTest() throws Exception {\n\t\ttry (Session session = openSession()) {\n\t\t\tsession.doWork( connection -> {\n\t\t\t\tfinal Statement stmnt = connection.createStatement();\n\n\t\t\t\tstmnt.execute( sessionFactory().getJdbcServices().getDialect().getDropTableString( \"SANDBOX_JDBC_TST\" ) );\n\t\t\t} );\n\t\t}\n\t}\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate isQuery() : boolean extracted from public getAttributeDeclarationString() : String in class org.hibernate.processor.annotation.TypedMetaAttribute",
        "diffLocations": [
            {
                "filePath": "tooling/metamodel-generator/src/main/java/org/hibernate/processor/annotation/TypedMetaAttribute.java",
                "startLine": 42,
                "endLine": 78,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "tooling/metamodel-generator/src/main/java/org/hibernate/processor/annotation/TypedMetaAttribute.java",
                "startLine": 59,
                "endLine": 91,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "tooling/metamodel-generator/src/main/java/org/hibernate/processor/annotation/TypedMetaAttribute.java",
                "startLine": 42,
                "endLine": 44,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic String getAttributeDeclarationString() {\n\t\tfinal boolean isQuery = \"QUERY_\".equals(prefix);  //UGLY!\n\t\tfinal Metamodel entity = getHostingEntity();\n\t\tfinal StringBuilder declaration = new StringBuilder();\n\t\tdeclaration\n\t\t\t\t.append(\"\\n/**\")\n\t\t\t\t.append(\"\\n * The \")\n\t\t\t\t.append(isQuery ? \"query\" : \"entity graph\")\n\t\t\t\t.append(\" named {@value \")\n\t\t\t\t.append(prefix)\n\t\t\t\t.append(fieldName())\n\t\t\t\t.append(\"}\\n\");\n\t\tif ( query != null ) {\n\t\t\tdeclaration.append(\" * <pre>\");\n\t\t\tquery.lines()\n\t\t\t\t\t.forEach( line -> declaration.append(\"\\n * \").append( line ) );\n\t\t\tdeclaration.append(\"\\n * </pre>\\n\");\n\t\t}\n\t\tdeclaration\n\t\t\t\t.append(\" *\\n * @see \")\n\t\t\t\t.append(entity.getQualifiedName())\n\t\t\t\t.append(\"\\n **/\\n\")\n\t\t\t\t.append(\"public static volatile \")\n\t\t\t\t.append(entity.importType(referenceType))\n\t\t\t\t.append('<')\n\t\t\t\t.append(entity.importType(resultType))\n\t\t\t\t.append('>')\n\t\t\t\t.append(' ')\n\t\t\t\t.append('_')\n\t\t\t\t.append(nameToMethodName(getPropertyName()));\n\t\tif ( isQuery ) {\n\t\t\tdeclaration.append('_');\n\t\t}\n\t\tdeclaration.append(';');\n\t\treturn declaration.toString();\n\t}",
        "filePathBefore": "tooling/metamodel-generator/src/main/java/org/hibernate/processor/annotation/TypedMetaAttribute.java",
        "isPureRefactoring": true,
        "commitId": "f474cacf8adf8adc8929798a065d53fedeba5732",
        "packageNameBefore": "org.hibernate.processor.annotation",
        "classNameBefore": "org.hibernate.processor.annotation.TypedMetaAttribute",
        "methodNameBefore": "org.hibernate.processor.annotation.TypedMetaAttribute#getAttributeDeclarationString",
        "invokedMethod": "methodSignature: org.hibernate.processor.annotation.AnnotationMetaAttribute#getHostingEntity\n methodBody: public Metamodel getHostingEntity() {\nreturn parent;\n}\nmethodSignature: org.hibernate.processor.annotation.DataAnnotationMetaAttribute#getHostingEntity\n methodBody: public Metamodel getHostingEntity() {\nreturn parent;\n}\nmethodSignature: org.hibernate.processor.ImportContextImpl#importType\n methodBody: public String importType(String typeExpression) {\nString result=typeExpression;\nString preamble=\"\";\nif(result.startsWith(\"@\")){int index=result.lastIndexOf(' ');\nif(index > 0){preamble=result.substring(0,index + 1);\nresult=result.substring(index + 1);\n}}if(result.startsWith(\"?\")){int index=1;\nwhile(index < result.length() && isWhitespace(result.charAt(index))){index++;\n}if(index < result.length()){int nextIndex=-1;\nif(result.substring(index).startsWith(\"extends\")){nextIndex=index + 7;\n}if(result.substring(index).startsWith(\"super\")){nextIndex=index + 5;\n}if(nextIndex > 0 && nextIndex < result.length() && isWhitespace(result.charAt(nextIndex))){index=nextIndex;\nwhile(isWhitespace(result.charAt(index))){index++;\n}preamble=result.substring(0,index);\nresult=importType(result.substring(index));\n}}}String appendices=\"\";\nif(result.indexOf('<') >= 0){int startIndex=result.indexOf('<');\nint endIndex=result.lastIndexOf('>');\nappendices='<' + importTypes(result.substring(startIndex + 1,endIndex)) + '>' + result.substring(endIndex + 1);\nresult=result.substring(0,startIndex);\n}if(result.indexOf('[') >= 0){int index=result.indexOf('[');\nappendices=result.substring(index);\nresult=result.substring(0,index);\n}if(result.endsWith(\"...\")){appendices=\"...\";\nint index=result.indexOf(\"...\");\nresult=result.substring(0,index);\n}return (preamble + unqualifyName(result) + appendices).replace('$','.');\n}\nmethodSignature: org.hibernate.processor.annotation.DataAnnotationMetaAttribute#fieldName\n methodBody: private String fieldName() {\nreturn getUpperUnderscoreCaseFromLowerCamelCase(getPropertyName().replace('.','_'));\n}\nmethodSignature: org.hibernate.processor.annotation.AbstractQueryMethod#getPropertyName\n methodBody: public String getPropertyName() {\nreturn methodName;\n}\nmethodSignature: org.hibernate.processor.annotation.AnnotationMetaAttribute#toString\n methodBody: public String toString() {\nreturn new StringBuilder().append(\"AnnotationMetaAttribute\").append(\"{element=\").append(element).append(\", type='\").append(type).append('\\'').append('}').toString();\n}\nmethodSignature: org.hibernate.processor.annotation.DataAnnotationMetaAttribute#getPropertyName\n methodBody: public String getPropertyName() {\nfinal String propertyName=propertyName(parent,element);\nreturn path == null ? propertyName : path + '.' + propertyName;\n}\nmethodSignature: org.hibernate.processor.annotation.DataAnnotationMetaAttribute#toString\n methodBody: public String toString() {\nreturn new StringBuilder().append(\"DataAnnotationMetaAttribute\").append(\"{element=\").append(element).append(\", type='\").append(type).append('\\'').append('}').toString();\n}\nmethodSignature: org.hibernate.processor.annotation.AnnotationMetaAttribute#getPropertyName\n methodBody: public String getPropertyName() {\nreturn propertyName(parent,element);\n}\nmethodSignature: org.hibernate.processor.annotation.AnnotationMetaType#getPropertyName\n methodBody: public String getPropertyName() {\nreturn \"class\";\n}\nmethodSignature: org.hibernate.processor.annotation.AnnotationMetaType#getHostingEntity\n methodBody: public Metamodel getHostingEntity() {\nreturn annotationMetaEntity;\n}",
        "classSignatureBefore": "class TypedMetaAttribute extends NameMetaAttribute ",
        "methodNameBeforeSet": [
            "org.hibernate.processor.annotation.TypedMetaAttribute#getAttributeDeclarationString"
        ],
        "classNameBeforeSet": [
            "org.hibernate.processor.annotation.TypedMetaAttribute"
        ],
        "classSignatureBeforeSet": [
            "class TypedMetaAttribute extends NameMetaAttribute "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.processor.annotation;\n\nimport org.checkerframework.checker.nullness.qual.Nullable;\nimport org.hibernate.processor.model.Metamodel;\n\nimport static org.hibernate.processor.util.StringUtil.nameToMethodName;\n\n/**\n * Represents a named query or named entity graph.\n *\n * @author Gavin King\n */\nclass TypedMetaAttribute extends NameMetaAttribute {\n\tprivate final String prefix;\n\tprivate final String resultType;\n\tprivate final String referenceType;\n\tprivate final @Nullable String query;\n\n\tpublic TypedMetaAttribute(\n\t\t\tMetamodel annotationMetaEntity,\n\t\t\tString name,\n\t\t\tString prefix,\n\t\t\tString resultType,\n\t\t\tString referenceType,\n\t\t\t@Nullable String query) {\n\t\tsuper( annotationMetaEntity, name, prefix );\n\t\tthis.prefix = prefix;\n\t\tthis.resultType = resultType;\n\t\tthis.referenceType = referenceType;\n\t\tthis.query = query;\n\t}\n\n\t@Override\n\tpublic boolean hasTypedAttribute() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic String getAttributeDeclarationString() {\n\t\tfinal boolean isQuery = \"QUERY_\".equals(prefix);  //UGLY!\n\t\tfinal Metamodel entity = getHostingEntity();\n\t\tfinal StringBuilder declaration = new StringBuilder();\n\t\tdeclaration\n\t\t\t\t.append(\"\\n/**\")\n\t\t\t\t.append(\"\\n * The \")\n\t\t\t\t.append(isQuery ? \"query\" : \"entity graph\")\n\t\t\t\t.append(\" named {@value \")\n\t\t\t\t.append(prefix)\n\t\t\t\t.append(fieldName())\n\t\t\t\t.append(\"}\\n\");\n\t\tif ( query != null ) {\n\t\t\tdeclaration.append(\" * <pre>\");\n\t\t\tquery.lines()\n\t\t\t\t\t.forEach( line -> declaration.append(\"\\n * \").append( line ) );\n\t\t\tdeclaration.append(\"\\n * </pre>\\n\");\n\t\t}\n\t\tdeclaration\n\t\t\t\t.append(\" *\\n * @see \")\n\t\t\t\t.append(entity.getQualifiedName())\n\t\t\t\t.append(\"\\n **/\\n\")\n\t\t\t\t.append(\"public static volatile \")\n\t\t\t\t.append(entity.importType(referenceType))\n\t\t\t\t.append('<')\n\t\t\t\t.append(entity.importType(resultType))\n\t\t\t\t.append('>')\n\t\t\t\t.append(' ')\n\t\t\t\t.append('_')\n\t\t\t\t.append(nameToMethodName(getPropertyName()));\n\t\tif ( isQuery ) {\n\t\t\tdeclaration.append('_');\n\t\t}\n\t\tdeclaration.append(';');\n\t\treturn declaration.toString();\n\t}\n}\n",
        "filePathAfter": "tooling/metamodel-generator/src/main/java/org/hibernate/processor/annotation/TypedMetaAttribute.java",
        "sourceCodeAfterForWhole": "/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.processor.annotation;\n\nimport org.checkerframework.checker.nullness.qual.Nullable;\nimport org.hibernate.processor.model.Metamodel;\n\nimport static org.hibernate.processor.util.StringUtil.nameToMethodName;\n\n/**\n * Represents a named query or named entity graph.\n *\n * @author Gavin King\n */\nclass TypedMetaAttribute extends NameMetaAttribute {\n\tprivate final String prefix;\n\tprivate final String resultType;\n\tprivate final String referenceType;\n\tprivate final @Nullable String query;\n\n\tpublic TypedMetaAttribute(\n\t\t\tMetamodel annotationMetaEntity,\n\t\t\tString name,\n\t\t\tString prefix,\n\t\t\tString resultType,\n\t\t\tString referenceType,\n\t\t\t@Nullable String query) {\n\t\tsuper( annotationMetaEntity, name, prefix );\n\t\tthis.prefix = prefix;\n\t\tthis.resultType = resultType;\n\t\tthis.referenceType = referenceType;\n\t\tthis.query = query;\n\t}\n\n\t@Override\n\tpublic boolean hasTypedAttribute() {\n\t\treturn true;\n\t}\n\n\tprivate boolean isQuery() {\n\t\treturn \"QUERY_\".equals(prefix);  //UGLY!\n\t}\n\n\t@Override\n\tpublic String getAttributeNameDeclarationString() {\n\t\tStringBuilder declaration = new StringBuilder();\n\t\tdeclaration\n\t\t\t\t.append(\"\\n/**\\n * @see \")\n\t\t\t\t.append(\"#\");\n\t\tappendFieldName( declaration, isQuery() );\n\t\treturn declaration\n\t\t\t\t.append( \"\\n **/\\n\" )\n\t\t\t\t.append(super.getAttributeNameDeclarationString())\n\t\t\t\t.toString();\n\t}\n\n\t@Override\n\tpublic String getAttributeDeclarationString() {\n\t\tfinal boolean isQuery = isQuery();\n\t\tfinal Metamodel entity = getHostingEntity();\n\t\tfinal StringBuilder declaration = new StringBuilder();\n\t\tdeclaration\n\t\t\t\t.append(\"\\n/**\")\n\t\t\t\t.append(\"\\n * The \")\n\t\t\t\t.append(isQuery ? \"query\" : \"entity graph\")\n\t\t\t\t.append(\" named {@value \")\n\t\t\t\t.append(prefix)\n\t\t\t\t.append(fieldName())\n\t\t\t\t.append(\"}\\n\");\n\t\tif ( query != null ) {\n\t\t\tdeclaration.append(\" * <pre>\");\n\t\t\tquery.lines()\n\t\t\t\t\t.forEach( line -> declaration.append(\"\\n * \").append( line ) );\n\t\t\tdeclaration.append(\"\\n * </pre>\\n\");\n\t\t}\n\t\tdeclaration\n\t\t\t\t.append(\" *\\n * @see \")\n\t\t\t\t.append(entity.getQualifiedName())\n\t\t\t\t.append(\"\\n **/\\n\")\n\t\t\t\t.append(\"public static volatile \")\n\t\t\t\t.append(entity.importType(referenceType))\n\t\t\t\t.append('<')\n\t\t\t\t.append(entity.importType(resultType))\n\t\t\t\t.append('>')\n\t\t\t\t.append(' ');\n\t\tappendFieldName( declaration, isQuery );\n\t\tdeclaration.append(';');\n\t\treturn declaration.toString();\n\t}\n\n\tprivate void appendFieldName(StringBuilder declaration, boolean isQuery) {\n\t\tdeclaration\n\t\t\t\t.append('_')\n\t\t\t\t.append(nameToMethodName(getPropertyName()));\n\t\tif ( isQuery ) {\n\t\t\tdeclaration.append('_');\n\t\t}\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private boolean isQuery() {\n\t\treturn \"QUERY_\".equals(prefix);  //UGLY!\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.processor.annotation.AnnotationMetaAttribute#getHostingEntity\n methodBody: public Metamodel getHostingEntity() {\nreturn parent;\n}",
            "methodSignature: org.hibernate.processor.annotation.DataAnnotationMetaAttribute#getHostingEntity\n methodBody: public Metamodel getHostingEntity() {\nreturn parent;\n}",
            "methodSignature: org.hibernate.processor.ImportContextImpl#importType\n methodBody: public String importType(String typeExpression) {\nString result=typeExpression;\nString preamble=\"\";\nif(result.startsWith(\"@\")){int index=result.lastIndexOf(' ');\nif(index > 0){preamble=result.substring(0,index + 1);\nresult=result.substring(index + 1);\n}}if(result.startsWith(\"?\")){int index=1;\nwhile(index < result.length() && isWhitespace(result.charAt(index))){index++;\n}if(index < result.length()){int nextIndex=-1;\nif(result.substring(index).startsWith(\"extends\")){nextIndex=index + 7;\n}if(result.substring(index).startsWith(\"super\")){nextIndex=index + 5;\n}if(nextIndex > 0 && nextIndex < result.length() && isWhitespace(result.charAt(nextIndex))){index=nextIndex;\nwhile(isWhitespace(result.charAt(index))){index++;\n}preamble=result.substring(0,index);\nresult=importType(result.substring(index));\n}}}String appendices=\"\";\nif(result.indexOf('<') >= 0){int startIndex=result.indexOf('<');\nint endIndex=result.lastIndexOf('>');\nappendices='<' + importTypes(result.substring(startIndex + 1,endIndex)) + '>' + result.substring(endIndex + 1);\nresult=result.substring(0,startIndex);\n}if(result.indexOf('[') >= 0){int index=result.indexOf('[');\nappendices=result.substring(index);\nresult=result.substring(0,index);\n}if(result.endsWith(\"...\")){appendices=\"...\";\nint index=result.indexOf(\"...\");\nresult=result.substring(0,index);\n}return (preamble + unqualifyName(result) + appendices).replace('$','.');\n}",
            "methodSignature: org.hibernate.processor.annotation.DataAnnotationMetaAttribute#fieldName\n methodBody: private String fieldName() {\nreturn getUpperUnderscoreCaseFromLowerCamelCase(getPropertyName().replace('.','_'));\n}",
            "methodSignature: org.hibernate.processor.annotation.AbstractQueryMethod#getPropertyName\n methodBody: public String getPropertyName() {\nreturn methodName;\n}",
            "methodSignature: org.hibernate.processor.annotation.AnnotationMetaAttribute#toString\n methodBody: public String toString() {\nreturn new StringBuilder().append(\"AnnotationMetaAttribute\").append(\"{element=\").append(element).append(\", type='\").append(type).append('\\'').append('}').toString();\n}",
            "methodSignature: org.hibernate.processor.annotation.DataAnnotationMetaAttribute#getPropertyName\n methodBody: public String getPropertyName() {\nfinal String propertyName=propertyName(parent,element);\nreturn path == null ? propertyName : path + '.' + propertyName;\n}",
            "methodSignature: org.hibernate.processor.annotation.DataAnnotationMetaAttribute#toString\n methodBody: public String toString() {\nreturn new StringBuilder().append(\"DataAnnotationMetaAttribute\").append(\"{element=\").append(element).append(\", type='\").append(type).append('\\'').append('}').toString();\n}",
            "methodSignature: org.hibernate.processor.annotation.AnnotationMetaAttribute#getPropertyName\n methodBody: public String getPropertyName() {\nreturn propertyName(parent,element);\n}",
            "methodSignature: org.hibernate.processor.annotation.AnnotationMetaType#getPropertyName\n methodBody: public String getPropertyName() {\nreturn \"class\";\n}",
            "methodSignature: org.hibernate.processor.annotation.AnnotationMetaType#getHostingEntity\n methodBody: public Metamodel getHostingEntity() {\nreturn annotationMetaEntity;\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\tpublic String getAttributeDeclarationString() {\n\t\tfinal boolean isQuery = isQuery();\n\t\tfinal Metamodel entity = getHostingEntity();\n\t\tfinal StringBuilder declaration = new StringBuilder();\n\t\tdeclaration\n\t\t\t\t.append(\"\\n/**\")\n\t\t\t\t.append(\"\\n * The \")\n\t\t\t\t.append(isQuery ? \"query\" : \"entity graph\")\n\t\t\t\t.append(\" named {@value \")\n\t\t\t\t.append(prefix)\n\t\t\t\t.append(fieldName())\n\t\t\t\t.append(\"}\\n\");\n\t\tif ( query != null ) {\n\t\t\tdeclaration.append(\" * <pre>\");\n\t\t\tquery.lines()\n\t\t\t\t\t.forEach( line -> declaration.append(\"\\n * \").append( line ) );\n\t\t\tdeclaration.append(\"\\n * </pre>\\n\");\n\t\t}\n\t\tdeclaration\n\t\t\t\t.append(\" *\\n * @see \")\n\t\t\t\t.append(entity.getQualifiedName())\n\t\t\t\t.append(\"\\n **/\\n\")\n\t\t\t\t.append(\"public static volatile \")\n\t\t\t\t.append(entity.importType(referenceType))\n\t\t\t\t.append('<')\n\t\t\t\t.append(entity.importType(resultType))\n\t\t\t\t.append('>')\n\t\t\t\t.append(' ');\n\t\tappendFieldName( declaration, isQuery );\n\t\tdeclaration.append(';');\n\t\treturn declaration.toString();\n\t}\nprivate boolean isQuery() {\n\t\treturn \"QUERY_\".equals(prefix);  //UGLY!\n\t}",
        "diffSourceCode": "-   42: \t@Override\n-   43: \tpublic String getAttributeDeclarationString() {\n-   44: \t\tfinal boolean isQuery = \"QUERY_\".equals(prefix);  //UGLY!\n-   45: \t\tfinal Metamodel entity = getHostingEntity();\n-   46: \t\tfinal StringBuilder declaration = new StringBuilder();\n-   47: \t\tdeclaration\n-   48: \t\t\t\t.append(\"\\n/**\")\n-   49: \t\t\t\t.append(\"\\n * The \")\n-   50: \t\t\t\t.append(isQuery ? \"query\" : \"entity graph\")\n-   51: \t\t\t\t.append(\" named {@value \")\n-   52: \t\t\t\t.append(prefix)\n-   53: \t\t\t\t.append(fieldName())\n-   54: \t\t\t\t.append(\"}\\n\");\n-   55: \t\tif ( query != null ) {\n-   56: \t\t\tdeclaration.append(\" * <pre>\");\n-   57: \t\t\tquery.lines()\n-   58: \t\t\t\t\t.forEach( line -> declaration.append(\"\\n * \").append( line ) );\n-   59: \t\t\tdeclaration.append(\"\\n * </pre>\\n\");\n-   60: \t\t}\n-   61: \t\tdeclaration\n-   62: \t\t\t\t.append(\" *\\n * @see \")\n-   63: \t\t\t\t.append(entity.getQualifiedName())\n-   64: \t\t\t\t.append(\"\\n **/\\n\")\n-   65: \t\t\t\t.append(\"public static volatile \")\n-   66: \t\t\t\t.append(entity.importType(referenceType))\n-   67: \t\t\t\t.append('<')\n-   68: \t\t\t\t.append(entity.importType(resultType))\n-   69: \t\t\t\t.append('>')\n-   70: \t\t\t\t.append(' ')\n-   71: \t\t\t\t.append('_')\n-   72: \t\t\t\t.append(nameToMethodName(getPropertyName()));\n-   73: \t\tif ( isQuery ) {\n-   74: \t\t\tdeclaration.append('_');\n-   75: \t\t}\n-   76: \t\tdeclaration.append(';');\n-   77: \t\treturn declaration.toString();\n-   78: \t}\n-   79: }\n+   42: \tprivate boolean isQuery() {\n+   43: \t\treturn \"QUERY_\".equals(prefix);  //UGLY!\n+   44: \t}\n+   45: \n+   46: \t@Override\n+   47: \tpublic String getAttributeNameDeclarationString() {\n+   48: \t\tStringBuilder declaration = new StringBuilder();\n+   49: \t\tdeclaration\n+   50: \t\t\t\t.append(\"\\n/**\\n * @see \")\n+   51: \t\t\t\t.append(\"#\");\n+   52: \t\tappendFieldName( declaration, isQuery() );\n+   53: \t\treturn declaration\n+   54: \t\t\t\t.append( \"\\n **/\\n\" )\n+   55: \t\t\t\t.append(super.getAttributeNameDeclarationString())\n+   56: \t\t\t\t.toString();\n+   57: \t}\n+   58: \n+   59: \t@Override\n+   60: \tpublic String getAttributeDeclarationString() {\n+   61: \t\tfinal boolean isQuery = isQuery();\n+   62: \t\tfinal Metamodel entity = getHostingEntity();\n+   63: \t\tfinal StringBuilder declaration = new StringBuilder();\n+   64: \t\tdeclaration\n+   65: \t\t\t\t.append(\"\\n/**\")\n+   66: \t\t\t\t.append(\"\\n * The \")\n+   67: \t\t\t\t.append(isQuery ? \"query\" : \"entity graph\")\n+   68: \t\t\t\t.append(\" named {@value \")\n+   69: \t\t\t\t.append(prefix)\n+   70: \t\t\t\t.append(fieldName())\n+   71: \t\t\t\t.append(\"}\\n\");\n+   72: \t\tif ( query != null ) {\n+   73: \t\t\tdeclaration.append(\" * <pre>\");\n+   74: \t\t\tquery.lines()\n+   75: \t\t\t\t\t.forEach( line -> declaration.append(\"\\n * \").append( line ) );\n+   76: \t\t\tdeclaration.append(\"\\n * </pre>\\n\");\n+   77: \t\t}\n+   78: \t\tdeclaration\n+   79: \t\t\t\t.append(\" *\\n * @see \")\n+   80: \t\t\t\t.append(entity.getQualifiedName())\n+   81: \t\t\t\t.append(\"\\n **/\\n\")\n+   82: \t\t\t\t.append(\"public static volatile \")\n+   83: \t\t\t\t.append(entity.importType(referenceType))\n+   84: \t\t\t\t.append('<')\n+   85: \t\t\t\t.append(entity.importType(resultType))\n+   86: \t\t\t\t.append('>')\n+   87: \t\t\t\t.append(' ');\n+   88: \t\tappendFieldName( declaration, isQuery );\n+   89: \t\tdeclaration.append(';');\n+   90: \t\treturn declaration.toString();\n+   91: \t}\n",
        "uniqueId": "f474cacf8adf8adc8929798a065d53fedeba5732_42_78_42_44_59_91",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 97
            },
            "BRANCH": {
                "missed": 0,
                "covered": 6
            },
            "LINE": {
                "missed": 0,
                "covered": 32
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 4
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\nprivate String buildDeclarationString(boolean isQuery, Metamodel entity) {\n    StringBuilder declaration = new StringBuilder();\n    declaration\n            .append(\"\\n/**\")\n            .append(\"\\n * The \")\n            .append(isQuery ? \"query\" : \"entity graph\")\n            .append(\" named {@value \")\n            .append(prefix)\n            .append(fieldName())\n            .append(\"}\\n\");\n    if (query != null) {\n        declaration.append(\" * <pre>\");\n        query.lines()\n                .forEach(line -> declaration.append(\"\\n * \").append(line));\n        declaration.append(\"\\n * </pre>\\n\");\n    }\n    declaration\n            .append(\" *\\n * @see \")\n            .append(entity.getQualifiedName())\n            .append(\"\\n **/\\n\")\n            .append(\"public static volatile \")\n            .append(entity.importType(referenceType))\n            .append('<')\n            .append(entity.importType(resultType))\n            .append('>')\n            .append(' ')\n            .append('_')\n            .append(nameToMethodName(getPropertyName()));\n    if (isQuery) {\n        declaration.append('_');\n    }\n    declaration.append(';');\n    return declaration.toString();\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Override\n\tpublic String getAttributeDeclarationString() {\n\t\tfinal boolean isQuery = \"QUERY_\".equals(prefix);  //UGLY!\n\t\tfinal Metamodel entity = getHostingEntity();\n\t\tfinal StringBuilder declaration = new StringBuilder();\n\t\tdeclaration\n\t\t\t\t.append(\"\\n/**\")\n\t\t\t\t.append(\"\\n * The \")\n\t\t\t\t.append(isQuery ? \"query\" : \"entity graph\")\n\t\t\t\t.append(\" named {@value \")\n\t\t\t\t.append(prefix)\n\t\t\t\t.append(fieldName())\n\t\t\t\t.append(\"}\\n\");\n\t\tif ( query != null ) {\n\t\t\tdeclaration.append(\" * <pre>\");\n\t\t\tquery.lines()\n\t\t\t\t\t.forEach( line -> declaration.append(\"\\n * \").append( line ) );\n\t\t\tdeclaration.append(\"\\n * </pre>\\n\");\n\t\t}\n\t\tdeclaration\n\t\t\t\t.append(\" *\\n * @see \")\n\t\t\t\t.append(entity.getQualifiedName())\n\t\t\t\t.append(\"\\n **/\\n\")\n\t\t\t\t.append(\"public static volatile \")\n\t\t\t\t.append(entity.importType(referenceType))\n\t\t\t\t.append('<')\n\t\t\t\t.append(entity.importType(resultType))\n\t\t\t\t.append('>')\n\t\t\t\t.append(' ')\n\t\t\t\t.append('_')\n\t\t\t\t.append(nameToMethodName(getPropertyName()));\n\t\tif ( isQuery ) {\n\t\t\tdeclaration.append('_');\n\t\t}\n\t\tdeclaration.append(';');\n\t\treturn declaration.toString();\n\t}\n\nClass content:\n/*\n * SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright Red Hat Inc. and Hibernate Authors\n */\npackage org.hibernate.processor.annotation;\n\nimport org.checkerframework.checker.nullness.qual.Nullable;\nimport org.hibernate.processor.model.Metamodel;\n\nimport static org.hibernate.processor.util.StringUtil.nameToMethodName;\n\n/**\n * Represents a named query or named entity graph.\n *\n * @author Gavin King\n */\nclass TypedMetaAttribute extends NameMetaAttribute {\n\tprivate final String prefix;\n\tprivate final String resultType;\n\tprivate final String referenceType;\n\tprivate final @Nullable String query;\n\n\tpublic TypedMetaAttribute(\n\t\t\tMetamodel annotationMetaEntity,\n\t\t\tString name,\n\t\t\tString prefix,\n\t\t\tString resultType,\n\t\t\tString referenceType,\n\t\t\t@Nullable String query) {\n\t\tsuper( annotationMetaEntity, name, prefix );\n\t\tthis.prefix = prefix;\n\t\tthis.resultType = resultType;\n\t\tthis.referenceType = referenceType;\n\t\tthis.query = query;\n\t}\n\n\t@Override\n\tpublic boolean hasTypedAttribute() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic String getAttributeDeclarationString() {\n\t\tfinal boolean isQuery = \"QUERY_\".equals(prefix);  //UGLY!\n\t\tfinal Metamodel entity = getHostingEntity();\n\t\tfinal StringBuilder declaration = new StringBuilder();\n\t\tdeclaration\n\t\t\t\t.append(\"\\n/**\")\n\t\t\t\t.append(\"\\n * The \")\n\t\t\t\t.append(isQuery ? \"query\" : \"entity graph\")\n\t\t\t\t.append(\" named {@value \")\n\t\t\t\t.append(prefix)\n\t\t\t\t.append(fieldName())\n\t\t\t\t.append(\"}\\n\");\n\t\tif ( query != null ) {\n\t\t\tdeclaration.append(\" * <pre>\");\n\t\t\tquery.lines()\n\t\t\t\t\t.forEach( line -> declaration.append(\"\\n * \").append( line ) );\n\t\t\tdeclaration.append(\"\\n * </pre>\\n\");\n\t\t}\n\t\tdeclaration\n\t\t\t\t.append(\" *\\n * @see \")\n\t\t\t\t.append(entity.getQualifiedName())\n\t\t\t\t.append(\"\\n **/\\n\")\n\t\t\t\t.append(\"public static volatile \")\n\t\t\t\t.append(entity.importType(referenceType))\n\t\t\t\t.append('<')\n\t\t\t\t.append(entity.importType(resultType))\n\t\t\t\t.append('>')\n\t\t\t\t.append(' ')\n\t\t\t\t.append('_')\n\t\t\t\t.append(nameToMethodName(getPropertyName()));\n\t\tif ( isQuery ) {\n\t\t\tdeclaration.append('_');\n\t\t}\n\t\tdeclaration.append(';');\n\t\treturn declaration.toString();\n\t}\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate createRegistryWithMetadataAccessDisabledAndDialect(dialectClass Class<?>) : StandardServiceRegistry extracted from package testAccessDisabledExplicitDialect(productName String, dialectClass Class<?>, expectedDatabaseVersion DatabaseVersion) : void in class org.hibernate.orm.test.boot.database.metadata.MetadataAccessTests",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/boot/database/metadata/MetadataAccessTests.java",
                "startLine": 135,
                "endLine": 156,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/boot/database/metadata/MetadataAccessTests.java",
                "startLine": 142,
                "endLine": 155,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/boot/database/metadata/MetadataAccessTests.java",
                "startLine": 157,
                "endLine": 167,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "@ParameterizedTest\n\t@MethodSource(\"dialects\")\n\tvoid testAccessDisabledExplicitDialect(String productName, Class<?> dialectClass, DatabaseVersion expectedDatabaseVersion) {\n\t\tfinal StandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder();\n\t\tregistryBuilder.clearSettings();\n\n\t\tregistryBuilder.applySetting( JdbcSettings.ALLOW_METADATA_ON_BOOT, false );\n\t\tregistryBuilder.applySetting( JdbcSettings.DIALECT, dialectClass.getName() );\n\t\tassertThat( registryBuilder.getSettings() )\n\t\t\t\t.doesNotContainKeys( JdbcSettings.JAKARTA_HBM2DDL_DB_NAME );\n\n\t\ttry (StandardServiceRegistry registry = registryBuilder.build()) {\n\t\t\tfinal JdbcEnvironment jdbcEnvironment = registry.getService( JdbcEnvironment.class );\n\t\t\tfinal Dialect dialect = jdbcEnvironment.getDialect();\n\t\t\tassertThat( dialect ).isInstanceOf( dialectClass );\n\t\t\tassertThat( dialect.getVersion() ).isEqualTo( expectedDatabaseVersion );\n\t\t}\n\n\t\tassertThat( triggerable.triggerMessages() )\n\t\t\t\t.as( triggerable.toString() )\n\t\t\t\t.isEmpty();\n\t}",
        "filePathBefore": "hibernate-core/src/test/java/org/hibernate/orm/test/boot/database/metadata/MetadataAccessTests.java",
        "isPureRefactoring": true,
        "commitId": "4b33d0d067010d484702d6ee910aaa3b4584c69b",
        "packageNameBefore": "org.hibernate.orm.test.boot.database.metadata",
        "classNameBefore": "org.hibernate.orm.test.boot.database.metadata.MetadataAccessTests",
        "methodNameBefore": "org.hibernate.orm.test.boot.database.metadata.MetadataAccessTests#testAccessDisabledExplicitDialect",
        "invokedMethod": "methodSignature: org.hibernate.dialect.HANADialect.HANANClobJdbcType#toString\n methodBody: public String toString() {\nreturn \"HANANClobTypeDescriptor\";\n}\nmethodSignature: org.hibernate.dialect.HANADialect.HANAClobJdbcType#toString\n methodBody: public String toString() {\nreturn \"HANAClobTypeDescriptor\";\n}\nmethodSignature: org.hibernate.testing.orm.junit.DialectContext#getDialect\n methodBody: public static synchronized Dialect getDialect() {\nif(dialect == null){init();\n}return dialect;\n}\nmethodSignature: org.hibernate.dialect.Dialect#toString\n methodBody: public String toString() {\nreturn getClass().getName() + \", version: \" + getVersion();\n}\nmethodSignature: org.hibernate.dialect.HANADialect.HANABlobType#toString\n methodBody: public String toString() {\nreturn \"HANABlobType\";\n}\nmethodSignature: org.hibernate.dialect.SimpleDatabaseVersion#toString\n methodBody: public String toString() {\nStringBuilder version=new StringBuilder();\nif(major != NO_VERSION){version.append(major);\n}if(minor != NO_VERSION){version.append(\".\");\nversion.append(minor);\nif(micro > 0){version.append(\".\");\nversion.append(micro);\n}}return version.toString();\n}\nmethodSignature: org.hibernate.dialect.Dialect#getVersion\n methodBody: public DatabaseVersion getVersion() {\nreturn version;\n}\nmethodSignature: org.hibernate.dialect.HANADialect.HANAStreamBlobType#toString\n methodBody: public String toString() {\nreturn \"HANAStreamBlobType\";\n}",
        "classSignatureBefore": "public class MetadataAccessTests ",
        "methodNameBeforeSet": [
            "org.hibernate.orm.test.boot.database.metadata.MetadataAccessTests#testAccessDisabledExplicitDialect"
        ],
        "classNameBeforeSet": [
            "org.hibernate.orm.test.boot.database.metadata.MetadataAccessTests"
        ],
        "classSignatureBeforeSet": [
            "public class MetadataAccessTests "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html.\n */\npackage org.hibernate.orm.test.boot.database.metadata;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.hibernate.dialect.SimpleDatabaseVersion.ZERO_VERSION;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.lang.invoke.MethodHandles;\nimport java.lang.reflect.Field;\nimport java.util.stream.Stream;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.boot.registry.StandardServiceRegistry;\nimport org.hibernate.boot.registry.StandardServiceRegistryBuilder;\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.cfg.JdbcSettings;\nimport org.hibernate.dialect.DB2Dialect;\nimport org.hibernate.dialect.DatabaseVersion;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.dialect.H2Dialect;\nimport org.hibernate.dialect.HANADialect;\nimport org.hibernate.dialect.HSQLDialect;\nimport org.hibernate.dialect.MariaDBDialect;\nimport org.hibernate.dialect.MySQLDialect;\nimport org.hibernate.dialect.OracleDialect;\nimport org.hibernate.dialect.PostgreSQLDialect;\nimport org.hibernate.dialect.PostgresPlusDialect;\nimport org.hibernate.dialect.SQLServerDialect;\nimport org.hibernate.dialect.SpannerDialect;\nimport org.hibernate.dialect.SybaseDialect;\nimport org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;\nimport org.hibernate.internal.CoreMessageLogger;\nimport org.hibernate.service.spi.ServiceException;\n\nimport org.hibernate.testing.env.TestingDatabaseInfo;\nimport org.hibernate.testing.logger.Triggerable;\nimport org.hibernate.testing.orm.junit.Jira;\nimport org.hibernate.testing.orm.logger.LoggerInspectionExtension;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.RegisterExtension;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\nimport org.jboss.logging.Logger;\n\n/**\n * @author Steve Ebersole\n */\n@Jira( \"https://hibernate.atlassian.net/browse/HHH-17269\" )\npublic class MetadataAccessTests {\n\n\tprivate Triggerable triggerable;\n\n\t@RegisterExtension\n\tpublic LoggerInspectionExtension logger = LoggerInspectionExtension\n\t\t\t.builder().setLogger(\n\t\t\t\t\tLogger.getMessageLogger( MethodHandles.lookup(), CoreMessageLogger.class, Dialect.class.getName() )\n\t\t\t).build();\n\n\t@BeforeEach\n\tpublic void setUp() {\n\t\ttriggerable = logger.watchForLogMessages( \"HHH000511\" );\n\t\ttriggerable.reset();\n\t}\n\n\t@Test\n\tvoid testAccessAllowed() {\n\t\tfinal StandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder();\n\t\tregistryBuilder.clearSettings();\n\n\t\t// allow access to the jdbc metadata\n\t\tregistryBuilder.applySetting( JdbcSettings.ALLOW_METADATA_ON_BOOT, true );\n\n\t\t// configure the values needed to connect to a H2 database\n\t\tregistryBuilder.applySetting( AvailableSettings.JAKARTA_JDBC_DRIVER, TestingDatabaseInfo.DRIVER );\n\t\tregistryBuilder.applySetting( AvailableSettings.JAKARTA_JDBC_URL, TestingDatabaseInfo.URL );\n\t\tregistryBuilder.applySetting( AvailableSettings.JAKARTA_JDBC_USER, TestingDatabaseInfo.USER );\n\t\tregistryBuilder.applySetting( AvailableSettings.JAKARTA_JDBC_PASSWORD, TestingDatabaseInfo.PASS );\n\n\t\t// make certain there is no explicit dialect configured\n\t\tassertThat( registryBuilder.getSettings() )\n\t\t\t\t.doesNotContainKeys( JdbcSettings.DIALECT, JdbcSettings.JAKARTA_HBM2DDL_DB_NAME );\n\n\t\ttry (StandardServiceRegistry registry = registryBuilder.build()) {\n\t\t\tfinal JdbcEnvironment jdbcEnvironment = registry.getService( JdbcEnvironment.class );\n\t\t\tfinal Dialect dialect = jdbcEnvironment.getDialect();\n\t\t\tassertThat( dialect ).isNotNull();\n\t\t\tassertThat( dialect ).isInstanceOf( H2Dialect.class );\n\t\t}\n\n\t\tassertThat( triggerable.triggerMessages() )\n\t\t\t\t.as( triggerable.toString() )\n\t\t\t\t.isEmpty();\n\t}\n\n\tstatic Stream<Arguments> dialects() {\n\t\treturn Stream.of(\n\t\t\t\tArguments.of( \"DB2\", DB2Dialect.class,\n\t\t\t\t\t\tgetVersionConstant( DB2Dialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"EnterpriseDB\", PostgresPlusDialect.class,\n\t\t\t\t\t\tgetVersionConstant( PostgreSQLDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"H2\", H2Dialect.class,\n\t\t\t\t\t\tgetVersionConstant( H2Dialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"HSQL Database Engine\", HSQLDialect.class,\n\t\t\t\t\t\tgetVersionConstant( HSQLDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"HDB\", HANADialect.class,\n\t\t\t\t\t\tgetVersionConstant( HANADialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"MariaDB\", MariaDBDialect.class,\n\t\t\t\t\t\tgetVersionConstant( MariaDBDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"MySQL\", MySQLDialect.class,\n\t\t\t\t\t\tgetVersionConstant( MySQLDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"Oracle\", OracleDialect.class,\n\t\t\t\t\t\tgetVersionConstant( OracleDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"PostgreSQL\", PostgreSQLDialect.class,\n\t\t\t\t\t\tgetVersionConstant( PostgreSQLDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"Google Cloud Spanner\", SpannerDialect.class, ZERO_VERSION ),\n\t\t\t\tArguments.of( \"Microsoft SQL Server\", SQLServerDialect.class,\n\t\t\t\t\t\tgetVersionConstant( SQLServerDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"Sybase SQL Server\", SybaseDialect.class,\n\t\t\t\t\t\tgetVersionConstant( SybaseDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"Adaptive Server Enterprise\", SybaseDialect.class,\n\t\t\t\t\t\tgetVersionConstant( SybaseDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"ASE\", SybaseDialect.class,\n\t\t\t\t\t\tgetVersionConstant( SybaseDialect.class, \"MINIMUM_VERSION\") )\n\t\t);\n\t}\n\n\t@ParameterizedTest\n\t@MethodSource(\"dialects\")\n\tvoid testAccessDisabledExplicitDialect(String productName, Class<?> dialectClass, DatabaseVersion expectedDatabaseVersion) {\n\t\tfinal StandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder();\n\t\tregistryBuilder.clearSettings();\n\n\t\tregistryBuilder.applySetting( JdbcSettings.ALLOW_METADATA_ON_BOOT, false );\n\t\tregistryBuilder.applySetting( JdbcSettings.DIALECT, dialectClass.getName() );\n\t\tassertThat( registryBuilder.getSettings() )\n\t\t\t\t.doesNotContainKeys( JdbcSettings.JAKARTA_HBM2DDL_DB_NAME );\n\n\t\ttry (StandardServiceRegistry registry = registryBuilder.build()) {\n\t\t\tfinal JdbcEnvironment jdbcEnvironment = registry.getService( JdbcEnvironment.class );\n\t\t\tfinal Dialect dialect = jdbcEnvironment.getDialect();\n\t\t\tassertThat( dialect ).isInstanceOf( dialectClass );\n\t\t\tassertThat( dialect.getVersion() ).isEqualTo( expectedDatabaseVersion );\n\t\t}\n\n\t\tassertThat( triggerable.triggerMessages() )\n\t\t\t\t.as( triggerable.toString() )\n\t\t\t\t.isEmpty();\n\t}\n\n\t@ParameterizedTest\n\t@MethodSource(\"dialects\")\n\t@Jira(\"https://hibernate.atlassian.net/browse/HHH-18079\")\n\t@Jira(\"https://hibernate.atlassian.net/browse/HHH-18080\")\n\tvoid testAccessDisabledExplicitProductName(String productName, Class<?> dialectClass, DatabaseVersion expectedDatabaseVersion) {\n\t\tfinal StandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder();\n\t\tregistryBuilder.clearSettings();\n\n\t\tregistryBuilder.applySetting( JdbcSettings.ALLOW_METADATA_ON_BOOT, false );\n\t\tregistryBuilder.applySetting( JdbcSettings.JAKARTA_HBM2DDL_DB_NAME, productName );\n\t\tassertThat( registryBuilder.getSettings() )\n\t\t\t\t.doesNotContainKeys( JdbcSettings.DIALECT );\n\n\t\ttry (StandardServiceRegistry registry = registryBuilder.build()) {\n\t\t\tfinal JdbcEnvironment jdbcEnvironment = registry.getService( JdbcEnvironment.class );\n\t\t\tfinal Dialect dialect = jdbcEnvironment.getDialect();\n\t\t\tassertThat( dialect ).isInstanceOf( dialectClass );\n\t\t\tassertThat( dialect.getVersion() ).isEqualTo( expectedDatabaseVersion );\n\t\t}\n\n\t\tassertThat( triggerable.triggerMessages() )\n\t\t\t\t.as( triggerable.toString() )\n\t\t\t\t.isEmpty();\n\t}\n\n\t@Test\n\t@Jira(\"https://hibernate.atlassian.net/browse/HHH-18080\")\n\tvoid testAccessDisabledNoDialectNorProductName() {\n\t\tfinal StandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder();\n\t\tregistryBuilder.clearSettings();\n\t\tassertThat( registryBuilder.getSettings() )\n\t\t\t\t.doesNotContainKeys( JdbcSettings.DIALECT, JdbcSettings.JAKARTA_HBM2DDL_DB_NAME );\n\n\t\tregistryBuilder.applySetting( JdbcSettings.ALLOW_METADATA_ON_BOOT, false );\n\t\ttry (StandardServiceRegistry registry = registryBuilder.build()) {\n\t\t\tfinal JdbcEnvironment jdbcEnvironment = registry.getService( JdbcEnvironment.class );\n\t\t\tfinal Dialect dialect = jdbcEnvironment.getDialect();\n\t\t\tfail( \"Should fail to boot - \" + dialect );\n\t\t}\n\t\tcatch (ServiceException expected) {\n\t\t\tassertThat( expected.getCause() ).isInstanceOf( HibernateException.class );\n\t\t\tfinal HibernateException cause = (HibernateException) expected.getCause();\n\t\t\tassertThat( cause.getMessage() ).startsWith( \"Unable to determine Dialect without JDBC metadata\" );\n\t\t}\n\t}\n\n\t// Ugly hack because neither MINIMUM_VERSION nor getMinimumSupportedVersion()\n\t// can be accessed from this test.\n\tprivate static DatabaseVersion getVersionConstant(Class<? extends Dialect> dialectClass, String versionConstantName) {\n\t\ttry {\n\t\t\tField field = dialectClass.getDeclaredField( versionConstantName );\n\t\t\tfield.setAccessible( true );\n\t\t\treturn (DatabaseVersion) field.get( null );\n\t\t}\n\t\tcatch (IllegalAccessException | NoSuchFieldException e) {\n\t\t\tthrow new RuntimeException( \"Error extracting '\" + versionConstantName + \"' from '\" + dialectClass + \"'\", e );\n\t\t}\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/test/java/org/hibernate/orm/test/boot/database/metadata/MetadataAccessTests.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html.\n */\npackage org.hibernate.orm.test.boot.database.metadata;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.hibernate.dialect.SimpleDatabaseVersion.ZERO_VERSION;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.lang.invoke.MethodHandles;\nimport java.lang.reflect.Field;\nimport java.util.Map;\nimport java.util.stream.Stream;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.boot.registry.StandardServiceInitiator;\nimport org.hibernate.boot.registry.StandardServiceRegistry;\nimport org.hibernate.boot.registry.StandardServiceRegistryBuilder;\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.cfg.JdbcSettings;\nimport org.hibernate.dialect.DB2Dialect;\nimport org.hibernate.dialect.DatabaseVersion;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.dialect.H2Dialect;\nimport org.hibernate.dialect.HANADialect;\nimport org.hibernate.dialect.HSQLDialect;\nimport org.hibernate.dialect.MariaDBDialect;\nimport org.hibernate.dialect.MySQLDialect;\nimport org.hibernate.dialect.OracleDialect;\nimport org.hibernate.dialect.PostgreSQLDialect;\nimport org.hibernate.dialect.PostgresPlusDialect;\nimport org.hibernate.dialect.SQLServerDialect;\nimport org.hibernate.dialect.SpannerDialect;\nimport org.hibernate.dialect.SybaseDialect;\nimport org.hibernate.engine.jdbc.dialect.internal.DialectFactoryImpl;\nimport org.hibernate.engine.jdbc.dialect.spi.DialectFactory;\nimport org.hibernate.engine.jdbc.dialect.spi.DialectResolutionInfo;\nimport org.hibernate.engine.jdbc.dialect.spi.DialectResolutionInfoSource;\nimport org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;\nimport org.hibernate.internal.CoreMessageLogger;\nimport org.hibernate.service.spi.ServiceException;\nimport org.hibernate.service.spi.ServiceRegistryImplementor;\n\nimport org.hibernate.testing.env.TestingDatabaseInfo;\nimport org.hibernate.testing.logger.Triggerable;\nimport org.hibernate.testing.orm.junit.DialectContext;\nimport org.hibernate.testing.orm.junit.Jira;\nimport org.hibernate.testing.orm.logger.LoggerInspectionExtension;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.RegisterExtension;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\nimport org.jboss.logging.Logger;\n\n/**\n * @author Steve Ebersole\n */\n@Jira( \"https://hibernate.atlassian.net/browse/HHH-17269\" )\npublic class MetadataAccessTests {\n\n\tprivate Triggerable triggerable;\n\n\t@RegisterExtension\n\tpublic LoggerInspectionExtension logger = LoggerInspectionExtension\n\t\t\t.builder().setLogger(\n\t\t\t\t\tLogger.getMessageLogger( MethodHandles.lookup(), CoreMessageLogger.class, Dialect.class.getName() )\n\t\t\t).build();\n\n\t@BeforeEach\n\tpublic void setUp() {\n\t\ttriggerable = logger.watchForLogMessages( \"HHH000511\" );\n\t\ttriggerable.reset();\n\t}\n\n\t@Test\n\tvoid testAccessAllowed() {\n\t\tfinal StandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder();\n\t\tregistryBuilder.clearSettings();\n\n\t\t// allow access to the jdbc metadata\n\t\tregistryBuilder.applySetting( JdbcSettings.ALLOW_METADATA_ON_BOOT, true );\n\n\t\t// configure the values needed to connect to a H2 database\n\t\tregistryBuilder.applySetting( AvailableSettings.JAKARTA_JDBC_DRIVER, TestingDatabaseInfo.DRIVER );\n\t\tregistryBuilder.applySetting( AvailableSettings.JAKARTA_JDBC_URL, TestingDatabaseInfo.URL );\n\t\tregistryBuilder.applySetting( AvailableSettings.JAKARTA_JDBC_USER, TestingDatabaseInfo.USER );\n\t\tregistryBuilder.applySetting( AvailableSettings.JAKARTA_JDBC_PASSWORD, TestingDatabaseInfo.PASS );\n\n\t\t// make certain there is no explicit dialect configured\n\t\tassertThat( registryBuilder.getSettings() )\n\t\t\t\t.doesNotContainKeys( JdbcSettings.DIALECT, JdbcSettings.JAKARTA_HBM2DDL_DB_NAME );\n\n\t\ttry (StandardServiceRegistry registry = registryBuilder.build()) {\n\t\t\tfinal Dialect dialect = getDialect( registry );\n\t\t\tassertThat( dialect ).isNotNull();\n\t\t\tassertThat( dialect ).isInstanceOf( H2Dialect.class );\n\t\t}\n\n\t\tassertThat( triggerable.triggerMessages() )\n\t\t\t\t.as( triggerable.toString() )\n\t\t\t\t.isEmpty();\n\t}\n\n\tstatic Stream<Arguments> dialects() {\n\t\treturn Stream.of(\n\t\t\t\tArguments.of( \"DB2\", DB2Dialect.class,\n\t\t\t\t\t\tgetVersionConstant( DB2Dialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"EnterpriseDB\", PostgresPlusDialect.class,\n\t\t\t\t\t\tgetVersionConstant( PostgreSQLDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"H2\", H2Dialect.class,\n\t\t\t\t\t\tgetVersionConstant( H2Dialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"HSQL Database Engine\", HSQLDialect.class,\n\t\t\t\t\t\tgetVersionConstant( HSQLDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"HDB\", HANADialect.class,\n\t\t\t\t\t\tgetVersionConstant( HANADialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"MariaDB\", MariaDBDialect.class,\n\t\t\t\t\t\tgetVersionConstant( MariaDBDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"MySQL\", MySQLDialect.class,\n\t\t\t\t\t\tgetVersionConstant( MySQLDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"Oracle\", OracleDialect.class,\n\t\t\t\t\t\tgetVersionConstant( OracleDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"PostgreSQL\", PostgreSQLDialect.class,\n\t\t\t\t\t\tgetVersionConstant( PostgreSQLDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"Google Cloud Spanner\", SpannerDialect.class, ZERO_VERSION ),\n\t\t\t\tArguments.of( \"Microsoft SQL Server\", SQLServerDialect.class,\n\t\t\t\t\t\tgetVersionConstant( SQLServerDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"Sybase SQL Server\", SybaseDialect.class,\n\t\t\t\t\t\tgetVersionConstant( SybaseDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"Adaptive Server Enterprise\", SybaseDialect.class,\n\t\t\t\t\t\tgetVersionConstant( SybaseDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"ASE\", SybaseDialect.class,\n\t\t\t\t\t\tgetVersionConstant( SybaseDialect.class, \"MINIMUM_VERSION\") )\n\t\t);\n\t}\n\n\t@ParameterizedTest\n\t@MethodSource(\"dialects\")\n\tvoid testAccessDisabledExplicitDialect(String productName, Class<?> dialectClass,\n\t\t\tDatabaseVersion expectedDatabaseVersion) {\n\t\ttry ( StandardServiceRegistry registry = createRegistryWithMetadataAccessDisabledAndDialect( dialectClass ) ) {\n\t\t\tfinal Dialect dialect = getDialect( registry );\n\t\t\tassertThat( dialect ).isInstanceOf( dialectClass );\n\t\t\tassertThat( dialect.getVersion() ).isEqualTo( expectedDatabaseVersion );\n\t\t}\n\n\t\tassertThat( triggerable.triggerMessages() )\n\t\t\t\t.as( triggerable.toString() )\n\t\t\t\t.isEmpty();\n\t}\n\n\tprivate StandardServiceRegistry createRegistryWithMetadataAccessDisabledAndDialect(Class<?> dialectClass) {\n\t\tfinal StandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder();\n\t\tregistryBuilder.clearSettings();\n\n\t\tregistryBuilder.applySetting( JdbcSettings.ALLOW_METADATA_ON_BOOT, false );\n\t\tregistryBuilder.applySetting( JdbcSettings.DIALECT, dialectClass.getName() );\n\t\tassertThat( registryBuilder.getSettings() )\n\t\t\t\t.doesNotContainKeys( JdbcSettings.JAKARTA_HBM2DDL_DB_NAME );\n\n\t\treturn registryBuilder.build();\n\t}\n\n\t@ParameterizedTest\n\t@MethodSource(\"dialects\")\n\t@Jira(\"https://hibernate.atlassian.net/browse/HHH-18079\")\n\t@Jira(\"https://hibernate.atlassian.net/browse/HHH-18080\")\n\tvoid testAccessDisabledExplicitProductName(String productName, Class<?> dialectClass, DatabaseVersion expectedDatabaseVersion) {\n\t\tfinal StandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder();\n\t\tregistryBuilder.clearSettings();\n\n\t\tregistryBuilder.applySetting( JdbcSettings.ALLOW_METADATA_ON_BOOT, false );\n\t\tregistryBuilder.applySetting( JdbcSettings.JAKARTA_HBM2DDL_DB_NAME, productName );\n\t\tassertThat( registryBuilder.getSettings() )\n\t\t\t\t.doesNotContainKeys( JdbcSettings.DIALECT );\n\n\t\ttry (StandardServiceRegistry registry = registryBuilder.build()) {\n\t\t\tfinal JdbcEnvironment jdbcEnvironment = registry.getService( JdbcEnvironment.class );\n\t\t\tfinal Dialect dialect = jdbcEnvironment.getDialect();\n\t\t\tassertThat( dialect ).isInstanceOf( dialectClass );\n\t\t\tassertThat( dialect.getVersion() ).isEqualTo( expectedDatabaseVersion );\n\t\t}\n\n\t\tassertThat( triggerable.triggerMessages() )\n\t\t\t\t.as( triggerable.toString() )\n\t\t\t\t.isEmpty();\n\t}\n\n\t@Test\n\t@Jira(\"https://hibernate.atlassian.net/browse/HHH-18080\")\n\tvoid testAccessDisabledNoDialectNorProductName() {\n\t\tfinal StandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder();\n\t\tregistryBuilder.clearSettings();\n\t\tassertThat( registryBuilder.getSettings() )\n\t\t\t\t.doesNotContainKeys( JdbcSettings.DIALECT, JdbcSettings.JAKARTA_HBM2DDL_DB_NAME );\n\n\t\tregistryBuilder.applySetting( JdbcSettings.ALLOW_METADATA_ON_BOOT, false );\n\t\ttry (StandardServiceRegistry registry = registryBuilder.build()) {\n\t\t\tfinal Dialect dialect = getDialect( registry );\n\t\t\tfail( \"Should fail to boot - \" + dialect );\n\t\t}\n\t\tcatch (ServiceException expected) {\n\t\t\tassertThat( expected.getCause() ).isInstanceOf( HibernateException.class );\n\t\t\tfinal HibernateException cause = (HibernateException) expected.getCause();\n\t\t\tassertThat( cause.getMessage() ).startsWith( \"Unable to determine Dialect without JDBC metadata\" );\n\t\t}\n\t}\n\n\t@Test\n\tvoid testDetermineDatabaseVersion() {\n\t\tfinal Dialect metadataAccessDisabledDialect;\n\t\ttry ( StandardServiceRegistry registry =\n\t\t\t\tcreateRegistryWithMetadataAccessDisabledAndDialect( DialectContext.getDialectClass() ) ) {\n\t\t\t// The version on this dialect may be anything, but most likely will be the minimum version.\n\t\t\t// We're not interested in that, but in how determineDatabaseVersion() behaves for this dialect,\n\t\t\t// when passed actual resolution info -- which Quarkus may do.\n\t\t\tmetadataAccessDisabledDialect = getDialect( registry );\n\t\t}\n\n\t\ttry ( StandardServiceRegistry registry = createRegistryWithTestedDatabaseAndMetadataAccessAllowed() ) {\n\t\t\tfinal Dialect metadataAccessAllowedDialect = getDialect( registry );\n\n\t\t\t// We expect determineDatabaseVersion(), when called on metadataAccessDisabledDialect,\n\t\t\t// to return the version that would have been returned,\n\t\t\t// had we booted up with auto-detection of version (metadata access allowed).\n\t\t\tassertThat( metadataAccessDisabledDialect.determineDatabaseVersion( getDialectResolutionInfo( registry ) ) )\n\t\t\t\t\t.isEqualTo( metadataAccessAllowedDialect.getVersion() );\n\t\t}\n\t}\n\n\tprivate StandardServiceRegistry createRegistryWithTestedDatabaseAndMetadataAccessAllowed() {\n\t\tfinal StandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder();\n\n\t\tregistryBuilder.addInitiator( new CapturingDialectFactory.Initiator() );\n\n\t\t// allow access to the jdbc metadata\n\t\tregistryBuilder.applySetting( JdbcSettings.ALLOW_METADATA_ON_BOOT, true );\n\n\t\t// leave connection info as defined in global test configuration (most likely system properties)\n\n\t\treturn registryBuilder.build();\n\t}\n\n\tprivate static Dialect getDialect(StandardServiceRegistry registry) {\n\t\treturn registry.getService( JdbcEnvironment.class ).getDialect();\n\t}\n\n\tprivate static DialectResolutionInfo getDialectResolutionInfo(StandardServiceRegistry registry) {\n\t\treturn ( (CapturingDialectFactory) registry.getService( DialectFactory.class ) )\n\t\t\t\t.capturedDialectResolutionInfoSource.getDialectResolutionInfo();\n\t}\n\n\t// Ugly hack because neither MINIMUM_VERSION nor getMinimumSupportedVersion()\n\t// can be accessed from this test.\n\tprivate static DatabaseVersion getVersionConstant(Class<? extends Dialect> dialectClass, String versionConstantName) {\n\t\ttry {\n\t\t\tField field = dialectClass.getDeclaredField( versionConstantName );\n\t\t\tfield.setAccessible( true );\n\t\t\treturn (DatabaseVersion) field.get( null );\n\t\t}\n\t\tcatch (IllegalAccessException | NoSuchFieldException e) {\n\t\t\tthrow new RuntimeException( \"Error extracting '\" + versionConstantName + \"' from '\" + dialectClass + \"'\", e );\n\t\t}\n\t}\n\n\t// A hack to easily retrieve DialectResolutionInfo exactly as it would be constructed by Hibernate ORM\n\tprivate static class CapturingDialectFactory extends DialectFactoryImpl {\n\t\tstatic class Initiator implements StandardServiceInitiator<DialectFactory> {\n\t\t\t@Override\n\t\t\tpublic Class<DialectFactory> getServiceInitiated() {\n\t\t\t\treturn DialectFactory.class;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic DialectFactory initiateService(Map<String, Object> configurationValues,\n\t\t\t\t\tServiceRegistryImplementor registry) {\n\t\t\t\treturn new CapturingDialectFactory();\n\t\t\t}\n\t\t}\n\n\t\tDialectResolutionInfoSource capturedDialectResolutionInfoSource;\n\n\t\t@Override\n\t\tpublic Dialect buildDialect(Map<String, Object> configValues, DialectResolutionInfoSource resolutionInfoSource)\n\t\t\t\tthrows HibernateException {\n\t\t\tthis.capturedDialectResolutionInfoSource = resolutionInfoSource;\n\t\t\treturn super.buildDialect( configValues, resolutionInfoSource );\n\t\t}\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private StandardServiceRegistry createRegistryWithMetadataAccessDisabledAndDialect(Class<?> dialectClass) {\n\t\tfinal StandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder();\n\t\tregistryBuilder.clearSettings();\n\n\t\tregistryBuilder.applySetting( JdbcSettings.ALLOW_METADATA_ON_BOOT, false );\n\t\tregistryBuilder.applySetting( JdbcSettings.DIALECT, dialectClass.getName() );\n\t\tassertThat( registryBuilder.getSettings() )\n\t\t\t\t.doesNotContainKeys( JdbcSettings.JAKARTA_HBM2DDL_DB_NAME );\n\n\t\treturn registryBuilder.build();\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.dialect.HANADialect.HANANClobJdbcType#toString\n methodBody: public String toString() {\nreturn \"HANANClobTypeDescriptor\";\n}",
            "methodSignature: org.hibernate.dialect.HANADialect.HANAClobJdbcType#toString\n methodBody: public String toString() {\nreturn \"HANAClobTypeDescriptor\";\n}",
            "methodSignature: org.hibernate.testing.orm.junit.DialectContext#getDialect\n methodBody: public static synchronized Dialect getDialect() {\nif(dialect == null){init();\n}return dialect;\n}",
            "methodSignature: org.hibernate.dialect.Dialect#toString\n methodBody: public String toString() {\nreturn getClass().getName() + \", version: \" + getVersion();\n}",
            "methodSignature: org.hibernate.dialect.HANADialect.HANABlobType#toString\n methodBody: public String toString() {\nreturn \"HANABlobType\";\n}",
            "methodSignature: org.hibernate.dialect.SimpleDatabaseVersion#toString\n methodBody: public String toString() {\nStringBuilder version=new StringBuilder();\nif(major != NO_VERSION){version.append(major);\n}if(minor != NO_VERSION){version.append(\".\");\nversion.append(minor);\nif(micro > 0){version.append(\".\");\nversion.append(micro);\n}}return version.toString();\n}",
            "methodSignature: org.hibernate.dialect.Dialect#getVersion\n methodBody: public DatabaseVersion getVersion() {\nreturn version;\n}",
            "methodSignature: org.hibernate.dialect.HANADialect.HANAStreamBlobType#toString\n methodBody: public String toString() {\nreturn \"HANAStreamBlobType\";\n}"
        ],
        "sourceCodeAfterRefactoring": "@ParameterizedTest\n\t@MethodSource(\"dialects\")\n\tvoid testAccessDisabledExplicitDialect(String productName, Class<?> dialectClass,\n\t\t\tDatabaseVersion expectedDatabaseVersion) {\n\t\ttry ( StandardServiceRegistry registry = createRegistryWithMetadataAccessDisabledAndDialect( dialectClass ) ) {\n\t\t\tfinal Dialect dialect = getDialect( registry );\n\t\t\tassertThat( dialect ).isInstanceOf( dialectClass );\n\t\t\tassertThat( dialect.getVersion() ).isEqualTo( expectedDatabaseVersion );\n\t\t}\n\n\t\tassertThat( triggerable.triggerMessages() )\n\t\t\t\t.as( triggerable.toString() )\n\t\t\t\t.isEmpty();\n\t}\nprivate StandardServiceRegistry createRegistryWithMetadataAccessDisabledAndDialect(Class<?> dialectClass) {\n\t\tfinal StandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder();\n\t\tregistryBuilder.clearSettings();\n\n\t\tregistryBuilder.applySetting( JdbcSettings.ALLOW_METADATA_ON_BOOT, false );\n\t\tregistryBuilder.applySetting( JdbcSettings.DIALECT, dialectClass.getName() );\n\t\tassertThat( registryBuilder.getSettings() )\n\t\t\t\t.doesNotContainKeys( JdbcSettings.JAKARTA_HBM2DDL_DB_NAME );\n\n\t\treturn registryBuilder.build();\n\t}",
        "diffSourceCode": "-  135: \t@ParameterizedTest\n-  136: \t@MethodSource(\"dialects\")\n-  137: \tvoid testAccessDisabledExplicitDialect(String productName, Class<?> dialectClass, DatabaseVersion expectedDatabaseVersion) {\n-  138: \t\tfinal StandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder();\n-  139: \t\tregistryBuilder.clearSettings();\n-  140: \n-  141: \t\tregistryBuilder.applySetting( JdbcSettings.ALLOW_METADATA_ON_BOOT, false );\n-  142: \t\tregistryBuilder.applySetting( JdbcSettings.DIALECT, dialectClass.getName() );\n-  143: \t\tassertThat( registryBuilder.getSettings() )\n-  144: \t\t\t\t.doesNotContainKeys( JdbcSettings.JAKARTA_HBM2DDL_DB_NAME );\n-  145: \n-  146: \t\ttry (StandardServiceRegistry registry = registryBuilder.build()) {\n-  147: \t\t\tfinal JdbcEnvironment jdbcEnvironment = registry.getService( JdbcEnvironment.class );\n-  148: \t\t\tfinal Dialect dialect = jdbcEnvironment.getDialect();\n-  149: \t\t\tassertThat( dialect ).isInstanceOf( dialectClass );\n-  150: \t\t\tassertThat( dialect.getVersion() ).isEqualTo( expectedDatabaseVersion );\n-  151: \t\t}\n-  152: \n-  153: \t\tassertThat( triggerable.triggerMessages() )\n-  154: \t\t\t\t.as( triggerable.toString() )\n-  155: \t\t\t\t.isEmpty();\n-  156: \t}\n-  157: \n-  158: \t@ParameterizedTest\n-  159: \t@MethodSource(\"dialects\")\n-  160: \t@Jira(\"https://hibernate.atlassian.net/browse/HHH-18079\")\n-  161: \t@Jira(\"https://hibernate.atlassian.net/browse/HHH-18080\")\n-  162: \tvoid testAccessDisabledExplicitProductName(String productName, Class<?> dialectClass, DatabaseVersion expectedDatabaseVersion) {\n-  163: \t\tfinal StandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder();\n-  164: \t\tregistryBuilder.clearSettings();\n+  135: \t\t\t\tArguments.of( \"Adaptive Server Enterprise\", SybaseDialect.class,\n+  136: \t\t\t\t\t\tgetVersionConstant( SybaseDialect.class, \"MINIMUM_VERSION\") ),\n+  137: \t\t\t\tArguments.of( \"ASE\", SybaseDialect.class,\n+  138: \t\t\t\t\t\tgetVersionConstant( SybaseDialect.class, \"MINIMUM_VERSION\") )\n+  139: \t\t);\n+  140: \t}\n+  141: \n+  142: \t@ParameterizedTest\n+  143: \t@MethodSource(\"dialects\")\n+  144: \tvoid testAccessDisabledExplicitDialect(String productName, Class<?> dialectClass,\n+  145: \t\t\tDatabaseVersion expectedDatabaseVersion) {\n+  146: \t\ttry ( StandardServiceRegistry registry = createRegistryWithMetadataAccessDisabledAndDialect( dialectClass ) ) {\n+  147: \t\t\tfinal Dialect dialect = getDialect( registry );\n+  148: \t\t\tassertThat( dialect ).isInstanceOf( dialectClass );\n+  149: \t\t\tassertThat( dialect.getVersion() ).isEqualTo( expectedDatabaseVersion );\n+  150: \t\t}\n+  151: \n+  152: \t\tassertThat( triggerable.triggerMessages() )\n+  153: \t\t\t\t.as( triggerable.toString() )\n+  154: \t\t\t\t.isEmpty();\n+  155: \t}\n+  156: \n+  157: \tprivate StandardServiceRegistry createRegistryWithMetadataAccessDisabledAndDialect(Class<?> dialectClass) {\n+  158: \t\tfinal StandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder();\n+  159: \t\tregistryBuilder.clearSettings();\n+  160: \n+  161: \t\tregistryBuilder.applySetting( JdbcSettings.ALLOW_METADATA_ON_BOOT, false );\n+  162: \t\tregistryBuilder.applySetting( JdbcSettings.DIALECT, dialectClass.getName() );\n+  163: \t\tassertThat( registryBuilder.getSettings() )\n+  164: \t\t\t\t.doesNotContainKeys( JdbcSettings.JAKARTA_HBM2DDL_DB_NAME );\n   165: \n-  166: \t\tregistryBuilder.applySetting( JdbcSettings.ALLOW_METADATA_ON_BOOT, false );\n-  167: \t\tregistryBuilder.applySetting( JdbcSettings.JAKARTA_HBM2DDL_DB_NAME, productName );\n+  166: \t\treturn registryBuilder.build();\n+  167: \t}\n",
        "uniqueId": "4b33d0d067010d484702d6ee910aaa3b4584c69b_135_156_157_167_142_155",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17,
        "refactoringMinerResult": false,
        "compileAndTestResult": true,
        "refactoredCode": "##########################\nprivate StandardServiceRegistry buildRegistry(StandardServiceRegistryBuilder registryBuilder) {\n    return registryBuilder.build();\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@ParameterizedTest\n\t@MethodSource(\"dialects\")\n\tvoid testAccessDisabledExplicitDialect(String productName, Class<?> dialectClass, DatabaseVersion expectedDatabaseVersion) {\n\t\tfinal StandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder();\n\t\tregistryBuilder.clearSettings();\n\n\t\tregistryBuilder.applySetting( JdbcSettings.ALLOW_METADATA_ON_BOOT, false );\n\t\tregistryBuilder.applySetting( JdbcSettings.DIALECT, dialectClass.getName() );\n\t\tassertThat( registryBuilder.getSettings() )\n\t\t\t\t.doesNotContainKeys( JdbcSettings.JAKARTA_HBM2DDL_DB_NAME );\n\n\t\ttry (StandardServiceRegistry registry = registryBuilder.build()) {\n\t\t\tfinal JdbcEnvironment jdbcEnvironment = registry.getService( JdbcEnvironment.class );\n\t\t\tfinal Dialect dialect = jdbcEnvironment.getDialect();\n\t\t\tassertThat( dialect ).isInstanceOf( dialectClass );\n\t\t\tassertThat( dialect.getVersion() ).isEqualTo( expectedDatabaseVersion );\n\t\t}\n\n\t\tassertThat( triggerable.triggerMessages() )\n\t\t\t\t.as( triggerable.toString() )\n\t\t\t\t.isEmpty();\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html.\n */\npackage org.hibernate.orm.test.boot.database.metadata;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.hibernate.dialect.SimpleDatabaseVersion.ZERO_VERSION;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.lang.invoke.MethodHandles;\nimport java.lang.reflect.Field;\nimport java.util.stream.Stream;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.boot.registry.StandardServiceRegistry;\nimport org.hibernate.boot.registry.StandardServiceRegistryBuilder;\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.cfg.JdbcSettings;\nimport org.hibernate.dialect.DB2Dialect;\nimport org.hibernate.dialect.DatabaseVersion;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.dialect.H2Dialect;\nimport org.hibernate.dialect.HANADialect;\nimport org.hibernate.dialect.HSQLDialect;\nimport org.hibernate.dialect.MariaDBDialect;\nimport org.hibernate.dialect.MySQLDialect;\nimport org.hibernate.dialect.OracleDialect;\nimport org.hibernate.dialect.PostgreSQLDialect;\nimport org.hibernate.dialect.PostgresPlusDialect;\nimport org.hibernate.dialect.SQLServerDialect;\nimport org.hibernate.dialect.SpannerDialect;\nimport org.hibernate.dialect.SybaseDialect;\nimport org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;\nimport org.hibernate.internal.CoreMessageLogger;\nimport org.hibernate.service.spi.ServiceException;\n\nimport org.hibernate.testing.env.TestingDatabaseInfo;\nimport org.hibernate.testing.logger.Triggerable;\nimport org.hibernate.testing.orm.junit.Jira;\nimport org.hibernate.testing.orm.logger.LoggerInspectionExtension;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.RegisterExtension;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\nimport org.jboss.logging.Logger;\n\n/**\n * @author Steve Ebersole\n */\n@Jira( \"https://hibernate.atlassian.net/browse/HHH-17269\" )\npublic class MetadataAccessTests {\n\n\tprivate Triggerable triggerable;\n\n\t@RegisterExtension\n\tpublic LoggerInspectionExtension logger = LoggerInspectionExtension\n\t\t\t.builder().setLogger(\n\t\t\t\t\tLogger.getMessageLogger( MethodHandles.lookup(), CoreMessageLogger.class, Dialect.class.getName() )\n\t\t\t).build();\n\n\t@BeforeEach\n\tpublic void setUp() {\n\t\ttriggerable = logger.watchForLogMessages( \"HHH000511\" );\n\t\ttriggerable.reset();\n\t}\n\n\t@Test\n\tvoid testAccessAllowed() {\n\t\tfinal StandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder();\n\t\tregistryBuilder.clearSettings();\n\n\t\t// allow access to the jdbc metadata\n\t\tregistryBuilder.applySetting( JdbcSettings.ALLOW_METADATA_ON_BOOT, true );\n\n\t\t// configure the values needed to connect to a H2 database\n\t\tregistryBuilder.applySetting( AvailableSettings.JAKARTA_JDBC_DRIVER, TestingDatabaseInfo.DRIVER );\n\t\tregistryBuilder.applySetting( AvailableSettings.JAKARTA_JDBC_URL, TestingDatabaseInfo.URL );\n\t\tregistryBuilder.applySetting( AvailableSettings.JAKARTA_JDBC_USER, TestingDatabaseInfo.USER );\n\t\tregistryBuilder.applySetting( AvailableSettings.JAKARTA_JDBC_PASSWORD, TestingDatabaseInfo.PASS );\n\n\t\t// make certain there is no explicit dialect configured\n\t\tassertThat( registryBuilder.getSettings() )\n\t\t\t\t.doesNotContainKeys( JdbcSettings.DIALECT, JdbcSettings.JAKARTA_HBM2DDL_DB_NAME );\n\n\t\ttry (StandardServiceRegistry registry = registryBuilder.build()) {\n\t\t\tfinal JdbcEnvironment jdbcEnvironment = registry.getService( JdbcEnvironment.class );\n\t\t\tfinal Dialect dialect = jdbcEnvironment.getDialect();\n\t\t\tassertThat( dialect ).isNotNull();\n\t\t\tassertThat( dialect ).isInstanceOf( H2Dialect.class );\n\t\t}\n\n\t\tassertThat( triggerable.triggerMessages() )\n\t\t\t\t.as( triggerable.toString() )\n\t\t\t\t.isEmpty();\n\t}\n\n\tstatic Stream<Arguments> dialects() {\n\t\treturn Stream.of(\n\t\t\t\tArguments.of( \"DB2\", DB2Dialect.class,\n\t\t\t\t\t\tgetVersionConstant( DB2Dialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"EnterpriseDB\", PostgresPlusDialect.class,\n\t\t\t\t\t\tgetVersionConstant( PostgreSQLDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"H2\", H2Dialect.class,\n\t\t\t\t\t\tgetVersionConstant( H2Dialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"HSQL Database Engine\", HSQLDialect.class,\n\t\t\t\t\t\tgetVersionConstant( HSQLDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"HDB\", HANADialect.class,\n\t\t\t\t\t\tgetVersionConstant( HANADialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"MariaDB\", MariaDBDialect.class,\n\t\t\t\t\t\tgetVersionConstant( MariaDBDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"MySQL\", MySQLDialect.class,\n\t\t\t\t\t\tgetVersionConstant( MySQLDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"Oracle\", OracleDialect.class,\n\t\t\t\t\t\tgetVersionConstant( OracleDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"PostgreSQL\", PostgreSQLDialect.class,\n\t\t\t\t\t\tgetVersionConstant( PostgreSQLDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"Google Cloud Spanner\", SpannerDialect.class, ZERO_VERSION ),\n\t\t\t\tArguments.of( \"Microsoft SQL Server\", SQLServerDialect.class,\n\t\t\t\t\t\tgetVersionConstant( SQLServerDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"Sybase SQL Server\", SybaseDialect.class,\n\t\t\t\t\t\tgetVersionConstant( SybaseDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"Adaptive Server Enterprise\", SybaseDialect.class,\n\t\t\t\t\t\tgetVersionConstant( SybaseDialect.class, \"MINIMUM_VERSION\") ),\n\t\t\t\tArguments.of( \"ASE\", SybaseDialect.class,\n\t\t\t\t\t\tgetVersionConstant( SybaseDialect.class, \"MINIMUM_VERSION\") )\n\t\t);\n\t}\n\n\t@ParameterizedTest\n\t@MethodSource(\"dialects\")\n\tvoid testAccessDisabledExplicitDialect(String productName, Class<?> dialectClass, DatabaseVersion expectedDatabaseVersion) {\n\t\tfinal StandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder();\n\t\tregistryBuilder.clearSettings();\n\n\t\tregistryBuilder.applySetting( JdbcSettings.ALLOW_METADATA_ON_BOOT, false );\n\t\tregistryBuilder.applySetting( JdbcSettings.DIALECT, dialectClass.getName() );\n\t\tassertThat( registryBuilder.getSettings() )\n\t\t\t\t.doesNotContainKeys( JdbcSettings.JAKARTA_HBM2DDL_DB_NAME );\n\n\t\ttry (StandardServiceRegistry registry = registryBuilder.build()) {\n\t\t\tfinal JdbcEnvironment jdbcEnvironment = registry.getService( JdbcEnvironment.class );\n\t\t\tfinal Dialect dialect = jdbcEnvironment.getDialect();\n\t\t\tassertThat( dialect ).isInstanceOf( dialectClass );\n\t\t\tassertThat( dialect.getVersion() ).isEqualTo( expectedDatabaseVersion );\n\t\t}\n\n\t\tassertThat( triggerable.triggerMessages() )\n\t\t\t\t.as( triggerable.toString() )\n\t\t\t\t.isEmpty();\n\t}\n\n\t@ParameterizedTest\n\t@MethodSource(\"dialects\")\n\t@Jira(\"https://hibernate.atlassian.net/browse/HHH-18079\")\n\t@Jira(\"https://hibernate.atlassian.net/browse/HHH-18080\")\n\tvoid testAccessDisabledExplicitProductName(String productName, Class<?> dialectClass, DatabaseVersion expectedDatabaseVersion) {\n\t\tfinal StandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder();\n\t\tregistryBuilder.clearSettings();\n\n\t\tregistryBuilder.applySetting( JdbcSettings.ALLOW_METADATA_ON_BOOT, false );\n\t\tregistryBuilder.applySetting( JdbcSettings.JAKARTA_HBM2DDL_DB_NAME, productName );\n\t\tassertThat( registryBuilder.getSettings() )\n\t\t\t\t.doesNotContainKeys( JdbcSettings.DIALECT );\n\n\t\ttry (StandardServiceRegistry registry = registryBuilder.build()) {\n\t\t\tfinal JdbcEnvironment jdbcEnvironment = registry.getService( JdbcEnvironment.class );\n\t\t\tfinal Dialect dialect = jdbcEnvironment.getDialect();\n\t\t\tassertThat( dialect ).isInstanceOf( dialectClass );\n\t\t\tassertThat( dialect.getVersion() ).isEqualTo( expectedDatabaseVersion );\n\t\t}\n\n\t\tassertThat( triggerable.triggerMessages() )\n\t\t\t\t.as( triggerable.toString() )\n\t\t\t\t.isEmpty();\n\t}\n\n\t@Test\n\t@Jira(\"https://hibernate.atlassian.net/browse/HHH-18080\")\n\tvoid testAccessDisabledNoDialectNorProductName() {\n\t\tfinal StandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder();\n\t\tregistryBuilder.clearSettings();\n\t\tassertThat( registryBuilder.getSettings() )\n\t\t\t\t.doesNotContainKeys( JdbcSettings.DIALECT, JdbcSettings.JAKARTA_HBM2DDL_DB_NAME );\n\n\t\tregistryBuilder.applySetting( JdbcSettings.ALLOW_METADATA_ON_BOOT, false );\n\t\ttry (StandardServiceRegistry registry = registryBuilder.build()) {\n\t\t\tfinal JdbcEnvironment jdbcEnvironment = registry.getService( JdbcEnvironment.class );\n\t\t\tfinal Dialect dialect = jdbcEnvironment.getDialect();\n\t\t\tfail( \"Should fail to boot - \" + dialect );\n\t\t}\n\t\tcatch (ServiceException expected) {\n\t\t\tassertThat( expected.getCause() ).isInstanceOf( HibernateException.class );\n\t\t\tfinal HibernateException cause = (HibernateException) expected.getCause();\n\t\t\tassertThat( cause.getMessage() ).startsWith( \"Unable to determine Dialect without JDBC metadata\" );\n\t\t}\n\t}\n\n\t// Ugly hack because neither MINIMUM_VERSION nor getMinimumSupportedVersion()\n\t// can be accessed from this test.\n\tprivate static DatabaseVersion getVersionConstant(Class<? extends Dialect> dialectClass, String versionConstantName) {\n\t\ttry {\n\t\t\tField field = dialectClass.getDeclaredField( versionConstantName );\n\t\t\tfield.setAccessible( true );\n\t\t\treturn (DatabaseVersion) field.get( null );\n\t\t}\n\t\tcatch (IllegalAccessException | NoSuchFieldException e) {\n\t\t\tthrow new RuntimeException( \"Error extracting '\" + versionConstantName + \"' from '\" + dialectClass + \"'\", e );\n\t\t}\n\t}\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate staticDetermineDatabaseVersion(info DialectResolutionInfo) : DatabaseVersion extracted from private determineDatabaseVersion(info DialectResolutionInfo) : DatabaseVersion in class org.hibernate.dialect.SQLServerDialect",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/dialect/SQLServerDialect.java",
                "startLine": 181,
                "endLine": 189,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/dialect/SQLServerDialect.java",
                "startLine": 181,
                "endLine": 184,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/dialect/SQLServerDialect.java",
                "startLine": 187,
                "endLine": 195,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private static DatabaseVersion determineDatabaseVersion(DialectResolutionInfo info) {\n\t\tfinal Integer compatibilityLevel = getCompatibilityLevel( info );\n\t\tif ( compatibilityLevel != null ) {\n\t\t\tfinal int majorVersion = compatibilityLevel / 10;\n\t\t\tfinal int minorVersion = compatibilityLevel % 10;\n\t\t\treturn DatabaseVersion.make( majorVersion, minorVersion );\n\t\t}\n\t\treturn info.makeCopyOrDefault( MINIMUM_VERSION );\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/dialect/SQLServerDialect.java",
        "isPureRefactoring": true,
        "commitId": "4b33d0d067010d484702d6ee910aaa3b4584c69b",
        "packageNameBefore": "org.hibernate.dialect",
        "classNameBefore": "org.hibernate.dialect.SQLServerDialect",
        "methodNameBefore": "org.hibernate.dialect.SQLServerDialect#determineDatabaseVersion",
        "invokedMethod": "methodSignature: org.hibernate.dialect.SQLServerDialect#getCompatibilityLevel\n methodBody: private static Integer getCompatibilityLevel(DialectResolutionInfo info) {\nfinal DatabaseMetaData databaseMetaData=info.getDatabaseMetadata();\nif(databaseMetaData != null){try(java.sql.Statement statement=databaseMetaData.getConnection().createStatement())final ResultSet rs=statement.executeQuery(\"SELECT compatibility_level FROM sys.databases where name = db_name();\");\nif(rs.next()){return rs.getInt(1);\n}catch(SQLException e)throw BasicSQLExceptionConverter.INSTANCE.convert(e);\n}return ConfigurationHelper.getInteger(SQL_SERVER_COMPATIBILITY_LEVEL,info.getConfigurationValues());\n}",
        "classSignatureBefore": "public class SQLServerDialect extends AbstractTransactSQLDialect ",
        "methodNameBeforeSet": [
            "org.hibernate.dialect.SQLServerDialect#determineDatabaseVersion"
        ],
        "classNameBeforeSet": [
            "org.hibernate.dialect.SQLServerDialect"
        ],
        "classSignatureBeforeSet": [
            "public class SQLServerDialect extends AbstractTransactSQLDialect "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Identical statements",
                "description": "There is no replacement! - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.dialect;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Types;\nimport java.time.temporal.ChronoField;\nimport java.time.temporal.TemporalAccessor;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.TimeZone;\n\nimport org.hibernate.Length;\nimport org.hibernate.LockMode;\nimport org.hibernate.LockOptions;\nimport org.hibernate.QueryTimeoutException;\nimport org.hibernate.boot.Metadata;\nimport org.hibernate.boot.model.FunctionContributions;\nimport org.hibernate.boot.model.TypeContributions;\nimport org.hibernate.boot.model.relational.QualifiedSequenceName;\nimport org.hibernate.boot.model.relational.Sequence;\nimport org.hibernate.boot.model.relational.SqlStringGenerationContext;\nimport org.hibernate.dialect.function.CommonFunctionFactory;\nimport org.hibernate.dialect.function.CountFunction;\nimport org.hibernate.dialect.function.SQLServerFormatEmulation;\nimport org.hibernate.dialect.function.SqlServerConvertTruncFunction;\nimport org.hibernate.dialect.identity.IdentityColumnSupport;\nimport org.hibernate.dialect.identity.SQLServerIdentityColumnSupport;\nimport org.hibernate.dialect.pagination.LimitHandler;\nimport org.hibernate.dialect.pagination.SQLServer2012LimitHandler;\nimport org.hibernate.dialect.sequence.SQLServer16SequenceSupport;\nimport org.hibernate.dialect.sequence.SQLServerSequenceSupport;\nimport org.hibernate.dialect.sequence.SequenceSupport;\nimport org.hibernate.dialect.unique.AlterTableUniqueIndexDelegate;\nimport org.hibernate.dialect.unique.UniqueDelegate;\nimport org.hibernate.engine.jdbc.Size;\nimport org.hibernate.engine.jdbc.dialect.spi.BasicSQLExceptionConverter;\nimport org.hibernate.engine.jdbc.dialect.spi.DialectResolutionInfo;\nimport org.hibernate.engine.jdbc.env.spi.IdentifierCaseStrategy;\nimport org.hibernate.engine.jdbc.env.spi.IdentifierHelper;\nimport org.hibernate.engine.jdbc.env.spi.IdentifierHelperBuilder;\nimport org.hibernate.engine.jdbc.env.spi.NameQualifierSupport;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.exception.ConstraintViolationException;\nimport org.hibernate.exception.LockTimeoutException;\nimport org.hibernate.exception.spi.SQLExceptionConversionDelegate;\nimport org.hibernate.exception.spi.TemplatedViolatedConstraintNameExtractor;\nimport org.hibernate.exception.spi.ViolatedConstraintNameExtractor;\nimport org.hibernate.internal.util.JdbcExceptionHelper;\nimport org.hibernate.internal.util.config.ConfigurationHelper;\nimport org.hibernate.internal.util.StringHelper;\nimport org.hibernate.mapping.CheckConstraint;\nimport org.hibernate.mapping.Column;\nimport org.hibernate.persister.entity.mutation.EntityMutationTarget;\nimport org.hibernate.procedure.internal.SQLServerCallableStatementSupport;\nimport org.hibernate.procedure.spi.CallableStatementSupport;\nimport org.hibernate.query.sqm.CastType;\nimport org.hibernate.query.sqm.FetchClauseType;\nimport org.hibernate.query.sqm.IntervalType;\nimport org.hibernate.query.sqm.TemporalUnit;\nimport org.hibernate.query.sqm.TrimSpec;\nimport org.hibernate.service.ServiceRegistry;\nimport org.hibernate.sql.ast.SqlAstNodeRenderingMode;\nimport org.hibernate.sql.ast.SqlAstTranslator;\nimport org.hibernate.sql.ast.SqlAstTranslatorFactory;\nimport org.hibernate.sql.ast.spi.SqlAppender;\nimport org.hibernate.sql.ast.spi.StandardSqlAstTranslatorFactory;\nimport org.hibernate.sql.ast.tree.Statement;\nimport org.hibernate.sql.exec.spi.JdbcOperation;\nimport org.hibernate.sql.model.MutationOperation;\nimport org.hibernate.sql.model.internal.OptionalTableUpdate;\nimport org.hibernate.tool.schema.internal.StandardSequenceExporter;\nimport org.hibernate.tool.schema.spi.Exporter;\nimport org.hibernate.type.BasicType;\nimport org.hibernate.type.BasicTypeRegistry;\nimport org.hibernate.type.StandardBasicTypes;\nimport org.hibernate.type.descriptor.java.JavaType;\nimport org.hibernate.type.descriptor.jdbc.JdbcType;\nimport org.hibernate.type.descriptor.jdbc.TimestampUtcAsJdbcTimestampJdbcType;\nimport org.hibernate.type.descriptor.jdbc.TinyIntAsSmallIntJdbcType;\nimport org.hibernate.type.descriptor.jdbc.UUIDJdbcType;\nimport org.hibernate.type.descriptor.jdbc.XmlJdbcType;\nimport org.hibernate.type.descriptor.jdbc.spi.JdbcTypeRegistry;\nimport org.hibernate.type.descriptor.sql.internal.DdlTypeImpl;\nimport org.hibernate.type.descriptor.sql.spi.DdlTypeRegistry;\n\nimport jakarta.persistence.TemporalType;\n\nimport static org.hibernate.cfg.DialectSpecificSettings.SQL_SERVER_COMPATIBILITY_LEVEL;\nimport static org.hibernate.exception.spi.TemplatedViolatedConstraintNameExtractor.extractUsingTemplate;\nimport static org.hibernate.internal.util.JdbcExceptionHelper.extractErrorCode;\nimport static org.hibernate.internal.util.JdbcExceptionHelper.extractSqlState;\nimport static org.hibernate.internal.util.StringHelper.isNotEmpty;\nimport static org.hibernate.query.sqm.TemporalUnit.NANOSECOND;\nimport static org.hibernate.query.sqm.produce.function.FunctionParameterType.INTEGER;\nimport static org.hibernate.type.SqlTypes.BLOB;\nimport static org.hibernate.type.SqlTypes.CLOB;\nimport static org.hibernate.type.SqlTypes.DATE;\nimport static org.hibernate.type.SqlTypes.DOUBLE;\nimport static org.hibernate.type.SqlTypes.GEOGRAPHY;\nimport static org.hibernate.type.SqlTypes.GEOMETRY;\nimport static org.hibernate.type.SqlTypes.LONG32NVARCHAR;\nimport static org.hibernate.type.SqlTypes.LONG32VARBINARY;\nimport static org.hibernate.type.SqlTypes.LONG32VARCHAR;\nimport static org.hibernate.type.SqlTypes.NCLOB;\nimport static org.hibernate.type.SqlTypes.NVARCHAR;\nimport static org.hibernate.type.SqlTypes.OTHER;\nimport static org.hibernate.type.SqlTypes.SQLXML;\nimport static org.hibernate.type.SqlTypes.TIME;\nimport static org.hibernate.type.SqlTypes.TIMESTAMP;\nimport static org.hibernate.type.SqlTypes.TIMESTAMP_WITH_TIMEZONE;\nimport static org.hibernate.type.SqlTypes.TIME_WITH_TIMEZONE;\nimport static org.hibernate.type.SqlTypes.UUID;\nimport static org.hibernate.type.SqlTypes.VARBINARY;\nimport static org.hibernate.type.SqlTypes.VARCHAR;\nimport static org.hibernate.type.descriptor.DateTimeUtils.appendAsDate;\nimport static org.hibernate.type.descriptor.DateTimeUtils.appendAsTime;\nimport static org.hibernate.type.descriptor.DateTimeUtils.appendAsTimestampWithMicros;\nimport static org.hibernate.type.descriptor.DateTimeUtils.appendAsTimestampWithMillis;\n\n/**\n * A dialect for Microsoft SQL Server 2008 and above\n *\n * @author Gavin King\n */\npublic class SQLServerDialect extends AbstractTransactSQLDialect {\n\tprivate final static DatabaseVersion MINIMUM_VERSION = DatabaseVersion.make( 11, 0 );\n\n\t/**\n\t * NOTE : 2100 is the documented limit supposedly - but in my testing, sending\n\t * 2100 parameters fails saying it must be less than 2100.\n\t */\n\tprivate static final int PARAM_LIST_SIZE_LIMIT = 2048;\n\n\t// See microsoft.sql.Types.GEOMETRY\n\tprivate static final int GEOMETRY_TYPE_CODE = -157;\n\t// See microsoft.sql.Types.GEOGRAPHY\n\tprivate static final int GEOGRAPHY_TYPE_CODE = -158;\n\n\tprivate final StandardSequenceExporter exporter;\n\tprivate final UniqueDelegate uniqueDelegate = new AlterTableUniqueIndexDelegate(this);\n\n\tprivate final SizeStrategy sizeStrategy = new SizeStrategyImpl() {\n\t\t@Override\n\t\tpublic Size resolveSize(\n\t\t\t\tJdbcType jdbcType,\n\t\t\t\tJavaType<?> javaType,\n\t\t\t\tInteger precision,\n\t\t\t\tInteger scale,\n\t\t\t\tLong length) {\n\t\t\treturn switch ( jdbcType.getDdlTypeCode() ) {\n\t\t\t\tcase BLOB, CLOB, NCLOB ->\n\t\t\t\t\t\tsuper.resolveSize( jdbcType, javaType, precision, scale,\n\t\t\t\t\t\t\t\tlength == null ? getDefaultLobLength() : length );\n\t\t\t\tdefault -> super.resolveSize( jdbcType, javaType, precision, scale, length );\n\t\t\t};\n\t\t}\n\t};\n\n\tpublic SQLServerDialect() {\n\t\tthis( MINIMUM_VERSION );\n\t}\n\n\tpublic SQLServerDialect(DatabaseVersion version) {\n\t\tsuper(version);\n\t\texporter = createSequenceExporter(version);\n\t}\n\n\tpublic SQLServerDialect(DialectResolutionInfo info) {\n\t\tthis( determineDatabaseVersion( info ) );\n\t\tregisterKeywords( info );\n\t}\n\n\tprivate static DatabaseVersion determineDatabaseVersion(DialectResolutionInfo info) {\n\t\tfinal Integer compatibilityLevel = getCompatibilityLevel( info );\n\t\tif ( compatibilityLevel != null ) {\n\t\t\tfinal int majorVersion = compatibilityLevel / 10;\n\t\t\tfinal int minorVersion = compatibilityLevel % 10;\n\t\t\treturn DatabaseVersion.make( majorVersion, minorVersion );\n\t\t}\n\t\treturn info.makeCopyOrDefault( MINIMUM_VERSION );\n\t}\n\n\tprivate static Integer getCompatibilityLevel(DialectResolutionInfo info) {\n\t\tfinal DatabaseMetaData databaseMetaData = info.getDatabaseMetadata();\n\t\tif ( databaseMetaData != null ) {\n\t\t\ttry ( java.sql.Statement statement = databaseMetaData.getConnection().createStatement() ) {\n\t\t\t\tfinal ResultSet rs = statement.executeQuery( \"SELECT compatibility_level FROM sys.databases where name = db_name();\" );\n\t\t\t\tif ( rs.next() ) {\n\t\t\t\t\treturn rs.getInt( 1 );\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (SQLException e) {\n\t\t\t\tthrow BasicSQLExceptionConverter.INSTANCE.convert( e );\n\t\t\t}\n\t\t}\n\n\t\t// default to the dialect-specific configuration setting\n\t\treturn ConfigurationHelper.getInteger( SQL_SERVER_COMPATIBILITY_LEVEL, info.getConfigurationValues() );\n\t}\n\n\tprivate StandardSequenceExporter createSequenceExporter(DatabaseVersion version) {\n\t\treturn new SqlServerSequenceExporter(this);\n\t}\n\n\t@Override\n\tprotected DatabaseVersion getMinimumSupportedVersion() {\n\t\treturn MINIMUM_VERSION;\n\t}\n\n\t@Override\n\tprotected void registerDefaultKeywords() {\n\t\tsuper.registerDefaultKeywords();\n\t\tregisterKeyword( \"top\" );\n\t\tregisterKeyword( \"key\" );\n\t}\n\n\t@Override\n\tprotected String columnType(int sqlTypeCode) {\n\t\treturn switch (sqlTypeCode) {\n\t\t\t// there is no 'double' type in SQL server\n\t\t\t// but 'float' is double precision by default\n\t\t\tcase DOUBLE -> \"float\";\n\t\t\t// Prefer 'varchar(max)' and 'varbinary(max)' to\n\t\t\t// the deprecated TEXT and IMAGE types. Note that\n\t\t\t// the length of a VARCHAR or VARBINARY column must\n\t\t\t// be either between 1 and 8000 or exactly MAX, and\n\t\t\t// the length of an NVARCHAR column must be either\n\t\t\t// between 1 and 4000 or exactly MAX. (HHH-3965)\n\t\t\tcase CLOB -> \"varchar(max)\";\n\t\t\tcase NCLOB -> \"nvarchar(max)\";\n\t\t\tcase BLOB -> \"varbinary(max)\";\n\t\t\tcase DATE -> \"date\";\n\t\t\tcase TIME -> \"time\";\n\t\t\tcase TIMESTAMP -> \"datetime2($p)\";\n\t\t\tcase TIME_WITH_TIMEZONE, TIMESTAMP_WITH_TIMEZONE -> \"datetimeoffset($p)\";\n\t\t\tdefault -> super.columnType(sqlTypeCode);\n\t\t};\n\t}\n\n\t@Override\n\tprotected String castType(int sqlTypeCode) {\n\t\treturn switch (sqlTypeCode) {\n\t\t\tcase VARCHAR, LONG32VARCHAR, CLOB -> \"varchar(max)\";\n\t\t\tcase NVARCHAR, LONG32NVARCHAR, NCLOB -> \"nvarchar(max)\";\n\t\t\tcase VARBINARY, LONG32VARBINARY, BLOB -> \"varbinary(max)\";\n\t\t\tdefault -> super.castType( sqlTypeCode );\n\t\t};\n\t}\n\n\t@Override\n\tprotected void registerColumnTypes(TypeContributions typeContributions, ServiceRegistry serviceRegistry) {\n\t\tsuper.registerColumnTypes( typeContributions, serviceRegistry );\n\t\tfinal DdlTypeRegistry ddlTypeRegistry = typeContributions.getTypeConfiguration().getDdlTypeRegistry();\n\t\tddlTypeRegistry.addDescriptor( new DdlTypeImpl( GEOMETRY, \"geometry\", this ) );\n\t\tddlTypeRegistry.addDescriptor( new DdlTypeImpl( GEOGRAPHY, \"geography\", this ) );\n\t\tddlTypeRegistry.addDescriptor( new DdlTypeImpl( SQLXML, \"xml\", this ) );\n\t\tddlTypeRegistry.addDescriptor( new DdlTypeImpl( UUID, \"uniqueidentifier\", this ) );\n\t}\n\n\t@Override\n\tpublic JdbcType resolveSqlTypeDescriptor(\n\t\t\tString columnTypeName,\n\t\t\tint jdbcTypeCode,\n\t\t\tint precision,\n\t\t\tint scale,\n\t\t\tJdbcTypeRegistry jdbcTypeRegistry) {\n\t\tswitch ( jdbcTypeCode ) {\n\t\t\tcase OTHER:\n\t\t\t\tif ( columnTypeName.equals(\"uniqueidentifier\") ) {\n\t\t\t\t\tjdbcTypeCode = UUID;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GEOMETRY_TYPE_CODE:\n\t\t\t\tjdbcTypeCode = GEOMETRY;\n\t\t\t\tbreak;\n\t\t\tcase GEOGRAPHY_TYPE_CODE:\n\t\t\t\tjdbcTypeCode = GEOGRAPHY;\n\t\t\t\tbreak;\n\t\t}\n\t\treturn super.resolveSqlTypeDescriptor( columnTypeName, jdbcTypeCode, precision, scale, jdbcTypeRegistry );\n\t}\n\n\t@Override\n\tpublic int getMaxVarcharLength() {\n\t\treturn 8000;\n\t}\n\n\t@Override\n\tpublic int getMaxNVarcharLength() {\n\t\treturn 4000;\n\t}\n\n\t@Override\n\tpublic TimeZoneSupport getTimeZoneSupport() {\n\t\treturn TimeZoneSupport.NATIVE;\n\t}\n\n\t@Override\n\tpublic long getDefaultLobLength() {\n\t\t// this is essentially the only legal length for\n\t\t// a \"lob\" in SQL Server, i.e. the value of MAX\n\t\t// (caveat: for NVARCHAR it is half this value)\n\t\treturn Length.LONG32;\n\t}\n\n\t@Override\n\tpublic int getMaxIdentifierLength() {\n\t\treturn 128;\n\t}\n\n\t@Override\n\tpublic void contributeTypes(TypeContributions typeContributions, ServiceRegistry serviceRegistry) {\n\t\tsuper.contributeTypes( typeContributions, serviceRegistry );\n\n\t\t// Need to bind as java.sql.Timestamp because reading OffsetDateTime from a \"datetime2\" column fails\n\t\ttypeContributions.contributeJdbcType( TimestampUtcAsJdbcTimestampJdbcType.INSTANCE );\n\n\t\ttypeContributions.getTypeConfiguration().getJdbcTypeRegistry().addDescriptor(\n\t\t\t\tTypes.TINYINT,\n\t\t\t\tTinyIntAsSmallIntJdbcType.INSTANCE\n\t\t);\n\t\ttypeContributions.contributeJdbcType( XmlJdbcType.INSTANCE );\n\t\ttypeContributions.contributeJdbcType( UUIDJdbcType.INSTANCE );\n\t}\n\n\t@Override\n\tpublic void initializeFunctionRegistry(FunctionContributions functionContributions) {\n\t\tsuper.initializeFunctionRegistry(functionContributions);\n\n\t\tfinal BasicTypeRegistry basicTypeRegistry = functionContributions.getTypeConfiguration().getBasicTypeRegistry();\n\t\tBasicType<Date> dateType = basicTypeRegistry.resolve( StandardBasicTypes.DATE );\n\t\tBasicType<Date> timeType = basicTypeRegistry.resolve( StandardBasicTypes.TIME );\n\t\tBasicType<Date> timestampType = basicTypeRegistry.resolve( StandardBasicTypes.TIMESTAMP );\n\n\t\tCommonFunctionFactory functionFactory = new CommonFunctionFactory(functionContributions);\n\n\t\t// For SQL-Server we need to cast certain arguments to varchar(max) to be able to concat them\n\t\tfunctionContributions.getFunctionRegistry().register(\n\t\t\t\t\"count\",\n\t\t\t\tnew CountFunction(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\tfunctionContributions.getTypeConfiguration(),\n\t\t\t\t\t\tSqlAstNodeRenderingMode.DEFAULT,\n\t\t\t\t\t\t\"count_big\",\n\t\t\t\t\t\t\"+\",\n\t\t\t\t\t\t\"varchar(max)\",\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\"varbinary(max)\"\n\t\t\t\t)\n\t\t);\n\n\t\t// AVG by default uses the input type, so we possibly need to cast the argument type, hence a special function\n\t\tfunctionFactory.avg_castingNonDoubleArguments( this, SqlAstNodeRenderingMode.DEFAULT );\n\n\t\tfunctionFactory.log_log();\n\n\t\tfunctionFactory.round_round();\n\t\tfunctionFactory.everyAny_minMaxIif();\n\t\tfunctionFactory.octetLength_pattern( \"datalength(?1)\" );\n\t\tfunctionFactory.bitLength_pattern( \"datalength(?1)*8\" );\n\n\t\tfunctionFactory.locate_charindex();\n\t\tfunctionFactory.stddevPopSamp_stdevp();\n\t\tfunctionFactory.varPopSamp_varp();\n\n\t\tfunctionContributions.getFunctionRegistry().register(\n\t\t\t\t\"format\",\n\t\t\t\tnew SQLServerFormatEmulation( functionContributions.getTypeConfiguration() )\n\t\t);\n\n\t\t//actually translate() was added in 2017 but\n\t\t//it's not worth adding a new dialect for that!\n\t\tfunctionFactory.translate();\n\n\t\tfunctionFactory.median_percentileCont( true );\n\n\t\tfunctionContributions.getFunctionRegistry().namedDescriptorBuilder( \"datefromparts\" )\n\t\t\t\t.setInvariantType( dateType )\n\t\t\t\t.setExactArgumentCount( 3 )\n\t\t\t\t.setParameterTypes(INTEGER)\n\t\t\t\t.register();\n\t\tfunctionContributions.getFunctionRegistry().namedDescriptorBuilder( \"timefromparts\" )\n\t\t\t\t.setInvariantType( timeType )\n\t\t\t\t.setExactArgumentCount( 5 )\n\t\t\t\t.setParameterTypes(INTEGER)\n\t\t\t\t.register();\n\t\tfunctionContributions.getFunctionRegistry().namedDescriptorBuilder( \"smalldatetimefromparts\" )\n\t\t\t\t.setInvariantType( timestampType )\n\t\t\t\t.setExactArgumentCount( 5 )\n\t\t\t\t.setParameterTypes(INTEGER)\n\t\t\t\t.register();\n\t\tfunctionContributions.getFunctionRegistry().namedDescriptorBuilder( \"datetimefromparts\" )\n\t\t\t\t.setInvariantType( timestampType )\n\t\t\t\t.setExactArgumentCount( 7 )\n\t\t\t\t.setParameterTypes(INTEGER)\n\t\t\t\t.register();\n\t\tfunctionContributions.getFunctionRegistry().namedDescriptorBuilder( \"datetime2fromparts\" )\n\t\t\t\t.setInvariantType( timestampType )\n\t\t\t\t.setExactArgumentCount( 8 )\n\t\t\t\t.setParameterTypes(INTEGER)\n\t\t\t\t.register();\n\t\tfunctionContributions.getFunctionRegistry().namedDescriptorBuilder( \"datetimeoffsetfromparts\" )\n\t\t\t\t.setInvariantType( timestampType )\n\t\t\t\t.setExactArgumentCount( 10 )\n\t\t\t\t.setParameterTypes(INTEGER)\n\t\t\t\t.register();\n\n\t\tfunctionFactory.windowFunctions();\n\t\tfunctionFactory.inverseDistributionOrderedSetAggregates_windowEmulation();\n\t\tfunctionFactory.hypotheticalOrderedSetAggregates_windowEmulation();\n\t\tif ( getVersion().isSameOrAfter( 14 ) ) {\n\t\t\tfunctionFactory.listagg_stringAggWithinGroup( \"varchar(max)\" );\n\t\t}\n\t\tif ( getVersion().isSameOrAfter( 16 ) ) {\n\t\t\tfunctionFactory.leastGreatest();\n\t\t\tfunctionFactory.dateTrunc_datetrunc();\n\t\t\tfunctionFactory.trunc_round_datetrunc();\n\t\t}\n\t\telse {\n\t\t\tfunctionContributions.getFunctionRegistry().register(\n\t\t\t\t\t\"trunc\",\n\t\t\t\t\tnew SqlServerConvertTruncFunction( functionContributions.getTypeConfiguration() )\n\t\t\t);\n\t\t\tfunctionContributions.getFunctionRegistry().registerAlternateKey( \"truncate\", \"trunc\" );\n\t\t}\n\t}\n\n\t@Override\n\tpublic String trimPattern(TrimSpec specification, boolean isWhitespace) {\n\t\tif ( getVersion().isSameOrAfter( 16 ) ) {\n\t\t\treturn switch (specification) {\n\t\t\t\tcase BOTH -> isWhitespace ? \"trim(?1)\" : \"trim(?2 from ?1)\";\n\t\t\t\tcase LEADING -> isWhitespace ? \"ltrim(?1)\" : \"ltrim(?1,?2)\";\n\t\t\t\tcase TRAILING -> isWhitespace ? \"rtrim(?1)\" : \"rtrim(?1,?2)\";\n\t\t\t};\n\t\t}\n\t\treturn super.trimPattern( specification, isWhitespace );\n\t}\n\n\t@Override\n\tpublic SqlAstTranslatorFactory getSqlAstTranslatorFactory() {\n\t\treturn new StandardSqlAstTranslatorFactory() {\n\t\t\t@Override\n\t\t\tprotected <T extends JdbcOperation> SqlAstTranslator<T> buildTranslator(\n\t\t\t\t\tSessionFactoryImplementor sessionFactory, Statement statement) {\n\t\t\t\treturn new SQLServerSqlAstTranslator<>( sessionFactory, statement );\n\t\t\t}\n\t\t};\n\t}\n\n\t@Override\n\tpublic SizeStrategy getSizeStrategy() {\n\t\treturn sizeStrategy;\n\t}\n\n\t@Override\n\tpublic String castPattern(CastType from, CastType to) {\n\t\tif ( to == CastType.STRING ) {\n\t\t\tswitch ( from ) {\n\t\t\t\tcase TIMESTAMP:\n\t\t\t\t\t// SQL Server uses yyyy-MM-dd HH:mm:ss.nnnnnnn by default when doing a cast, but only need second precision\n\t\t\t\t\treturn \"format(?1,'yyyy-MM-dd HH:mm:ss')\";\n\t\t\t\tcase TIME:\n\t\t\t\t\t// SQL Server uses HH:mm:ss.nnnnnnn by default when doing a cast, but only need second precision\n\t\t\t\t\t// SQL Server requires quoting of ':' in time formats and the use of 'hh' instead of 'HH'\n\t\t\t\t\treturn \"format(?1,'hh\\\\:mm\\\\:ss')\";\n\t\t\t}\n\t\t}\n\t\treturn super.castPattern( from, to );\n\t}\n\n\t@Override\n\tpublic String currentTimestamp() {\n\t\treturn \"sysdatetime()\";\n\t}\n\n\t@Override\n\tpublic IdentifierHelper buildIdentifierHelper(IdentifierHelperBuilder builder, DatabaseMetaData dbMetaData)\n\t\t\tthrows SQLException {\n\n\t\tif ( dbMetaData == null ) {\n\t\t\t// TODO: if DatabaseMetaData != null, unquoted case strategy is set to IdentifierCaseStrategy.UPPER\n\t\t\t//       Check to see if this setting is correct.\n\t\t\tbuilder.setUnquotedCaseStrategy( IdentifierCaseStrategy.MIXED );\n\t\t\tbuilder.setQuotedCaseStrategy( IdentifierCaseStrategy.MIXED );\n\t\t}\n\n\t\treturn super.buildIdentifierHelper( builder, dbMetaData );\n\t}\n\n\t@Override\n\tpublic String currentTime() {\n\t\treturn \"convert(time,getdate())\";\n\t}\n\n\t@Override\n\tpublic String currentDate() {\n\t\treturn \"convert(date,getdate())\";\n\t}\n\n\t@Override\n\tpublic String currentTimestampWithTimeZone() {\n\t\treturn \"sysdatetimeoffset()\";\n\t}\n\n\t@Override\n\tpublic String getNoColumnsInsertString() {\n\t\treturn \"default values\";\n\t}\n\n\t@Override\n\tpublic LimitHandler getLimitHandler() {\n\t\treturn SQLServer2012LimitHandler.INSTANCE;\n\t}\n\n\t@Override\n\tpublic boolean supportsValuesList() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsDistinctFromPredicate() {\n\t\treturn getVersion().isSameOrAfter( 16 );\n\t}\n\n\t@Override\n\tpublic char closeQuote() {\n\t\treturn ']';\n\t}\n\n\t@Override\n\tpublic String getCurrentSchemaCommand() {\n\t\treturn \"select schema_name()\";\n\t}\n\n\t@Override\n\tpublic boolean supportsIfExistsBeforeTableName() {\n\t\treturn getVersion().isSameOrAfter( 16 ) || super.supportsIfExistsBeforeTableName();\n\t}\n\n\t@Override\n\tpublic boolean supportsIfExistsBeforeConstraintName() {\n\t\treturn getVersion().isSameOrAfter( 16 ) || super.supportsIfExistsBeforeConstraintName();\n\t}\n\n\t@Override\n\tpublic char openQuote() {\n\t\treturn '[';\n\t}\n\n\t@Override\n\tpublic String appendLockHint(LockOptions lockOptions, String tableName) {\n\t\tLockMode lockMode = lockOptions.getAliasSpecificLockMode( tableName );\n\t\tif ( lockMode == null ) {\n\t\t\tlockMode = lockOptions.getLockMode();\n\t\t}\n\n\t\tfinal String writeLockStr = lockOptions.getTimeOut() == LockOptions.SKIP_LOCKED ? \"updlock\" : \"updlock,holdlock\";\n\t\tfinal String readLockStr = lockOptions.getTimeOut() == LockOptions.SKIP_LOCKED ? \"updlock\" : \"holdlock\";\n\n\t\tfinal String noWaitStr = lockOptions.getTimeOut() == LockOptions.NO_WAIT ? \",nowait\" : \"\";\n\t\tfinal String skipLockStr = lockOptions.getTimeOut() == LockOptions.SKIP_LOCKED ? \",readpast\" : \"\";\n\n\t\treturn switch (lockMode) {\n\t\t\tcase PESSIMISTIC_WRITE, WRITE ->\n\t\t\t\t\ttableName + \" with (\" + writeLockStr + \",rowlock\" + noWaitStr + skipLockStr + \")\";\n\t\t\tcase PESSIMISTIC_READ -> tableName + \" with (\" + readLockStr + \",rowlock\" + noWaitStr + skipLockStr + \")\";\n\t\t\tcase UPGRADE_SKIPLOCKED -> tableName + \" with (updlock,rowlock,readpast\" + noWaitStr + \")\";\n\t\t\tcase UPGRADE_NOWAIT -> tableName + \" with (updlock,holdlock,rowlock,nowait)\";\n\t\t\tdefault -> tableName;\n\t\t};\n\t}\n\n\n\t/**\n\t * The current_timestamp is more accurate, but only known to be supported in SQL Server 7.0 and later and\n\t * Sybase not known to support it at all\n\t * <p>\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic String getCurrentTimestampSelectString() {\n\t\treturn \"select current_timestamp\";\n\t}\n\n\t// Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\t@Override\n\tpublic boolean supportsResultSetPositionQueryMethodsOnForwardOnlyCursor() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean supportsCircularCascadeDeleteConstraints() {\n\t\t// SQL Server (at least up through 2005) does not support defining\n\t\t// cascade delete constraints which can circle back to the mutating\n\t\t// table\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean supportsLobValueChangePropagation() {\n\t\t// note: at least my local SQL Server 2005 Express shows this not working...\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean doesReadCommittedCauseWritersToBlockReaders() {\n\t\t// here assume SQLServer2005 using snapshot isolation, which does not have this problem\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean doesRepeatableReadCauseReadersToBlockWriters() {\n\t\t// here assume SQLServer2005 using snapshot isolation, which does not have this problem\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic int getInExpressionCountLimit() {\n\t\treturn PARAM_LIST_SIZE_LIMIT;\n\t}\n\n\t@Override\n\tpublic IdentityColumnSupport getIdentityColumnSupport() {\n\t\treturn SQLServerIdentityColumnSupport.INSTANCE;\n\t}\n\n\t@Override\n\tpublic boolean supportsNonQueryWithCTE() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsSkipLocked() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsNoWait() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsWait() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic SequenceSupport getSequenceSupport() {\n\t\treturn getVersion().isSameOrAfter( 16 )\n\t\t\t\t? SQLServer16SequenceSupport.INSTANCE\n\t\t\t\t: SQLServerSequenceSupport.INSTANCE;\n\t}\n\n\t@Override\n\tpublic String getQuerySequencesString() {\n\t\t// The upper-case name should work on both case-sensitive and case-insensitive collations.\n\t\treturn \"select * from INFORMATION_SCHEMA.SEQUENCES\";\n\t}\n\n\t@Override\n\tpublic String getQueryHintString(String sql, String hints) {\n\t\tfinal StringBuilder buffer =\n\t\t\t\tnew StringBuilder( sql.length() + hints.length() + 12 );\n\t\tfinal int pos = sql.indexOf( ';' );\n\t\tif ( pos > -1 ) {\n\t\t\tbuffer.append( sql, 0, pos );\n\t\t}\n\t\telse {\n\t\t\tbuffer.append( sql );\n\t\t}\n\t\tbuffer.append( \" OPTION (\" ).append( hints ).append( \")\" );\n\t\tif ( pos > -1 ) {\n\t\t\tbuffer.append( \";\" );\n\t\t}\n\t\tsql = buffer.toString();\n\t\treturn sql;\n\t}\n\n\t@Override\n\tpublic boolean supportsNullPrecedence() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean supportsOffsetInSubquery() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsWindowFunctions() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsLateral() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsRecursiveCTE() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsFetchClause(FetchClauseType type) {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic ViolatedConstraintNameExtractor getViolatedConstraintNameExtractor() {\n\t\treturn new TemplatedViolatedConstraintNameExtractor(\n\t\t\t\tsqle -> {\n\t\t\t\t\tswitch ( extractErrorCode( sqle ) ) {\n\t\t\t\t\t\tcase 2627:\n\t\t\t\t\t\tcase 2601:\n\t\t\t\t\t\t\tString message = sqle.getMessage();\n\t\t\t\t\t\t\tif ( message.contains(\"unique index \") ) {\n\t\t\t\t\t\t\t\treturn extractUsingTemplate( \"unique index '\", \"'\", message);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\treturn extractUsingTemplate( \"'\", \"'\", message);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@Override\n\tpublic SQLExceptionConversionDelegate buildSQLExceptionConversionDelegate() {\n\t\treturn (sqlException, message, sql) -> {\n\t\t\tfinal String sqlState = extractSqlState( sqlException );\n\t\t\tif ( \"HY008\".equals( sqlState ) ) {\n\t\t\t\treturn new QueryTimeoutException( message, sqlException, sql );\n\t\t\t}\n\n\t\t\treturn switch ( extractErrorCode( sqlException ) ) {\n\t\t\t\tcase 1222 -> new LockTimeoutException( message, sqlException, sql );\n\t\t\t\tcase 2627, 2601 -> new ConstraintViolationException(\n\t\t\t\t\t\tmessage,\n\t\t\t\t\t\tsqlException,\n\t\t\t\t\t\tsql,\n\t\t\t\t\t\tConstraintViolationException.ConstraintKind.UNIQUE,\n\t\t\t\t\t\tgetViolatedConstraintNameExtractor().extractConstraintName( sqlException )\n\t\t\t\t);\n\t\t\t\tdefault -> null;\n\t\t\t};\n\t\t};\n\t}\n\n\t@Override\n\tpublic int getDefaultTimestampPrecision() {\n\t\treturn 7;\n\t}\n\n\t/**\n\t * Even though SQL Server only supports 1/10th microsecond precision,\n\t * we use nanosecond as the \"native\" precision for datetime arithmetic\n\t * since it simplifies calculations.\n\t */\n\t@Override\n\tpublic long getFractionalSecondPrecisionInNanos() {\n//\t\treturn 100; // 1/10th microsecond\n\t\treturn 1;\n\t}\n\n\t@Override\n\tpublic String extractPattern(TemporalUnit unit) {\n\t\treturn switch (unit) {\n\t\t\tcase TIMEZONE_HOUR -> \"(datepart(tz,?2)/60)\";\n\t\t\tcase TIMEZONE_MINUTE -> \"(datepart(tz,?2)%60)\";\n\t\t\t// currently Dialect.extract() doesn't need\n\t\t\t// to handle NANOSECOND (might change that?)\n//\t\t\tcase NANOSECOND ->\n//\t\t\t\t// this should evaluate to a bigint type\n//\t\t\t\t\t\"(datepart(second,?2)*1000000000+datepart(nanosecond,?2))\";\n\t\t\tcase SECOND ->\n\t\t\t\t//this should evaluate to a floating point type\n\t\t\t\t\t\"(datepart(second,?2)+datepart(nanosecond,?2)/1000000000)\";\n\t\t\tcase EPOCH -> \"datediff_big(second, '1970-01-01', ?2)\";\n\t\t\tdefault -> \"datepart(?1,?2)\";\n\t\t};\n\t}\n\n\t@Override @SuppressWarnings(\"deprecation\")\n\tpublic String timestampaddPattern(TemporalUnit unit, TemporalType temporalType, IntervalType intervalType) {\n\t\t// dateadd() supports only especially small magnitudes\n\t\t// since it casts its argument to int (and unfortunately\n\t\t// there's no dateadd_big()) so here we need to use two\n\t\t// calls to dateadd() to add a whole duration\n\t\treturn switch (unit) { //use nanosecond as the \"native\" precision\n\t\t\tcase NANOSECOND, NATIVE -> \"dateadd(nanosecond,?2%1000000000,dateadd(second,?2/1000000000,?3))\";\n\t\t\t// we could, in principle, use 1/10th microsecond as the \"native\" precision\n//\t\t\tcase NATIVE -> \"dateadd(nanosecond,?2%10000000,dateadd(second,?2/10000000,?3))\";\n\t\t\tcase SECOND -> \"dateadd(nanosecond,cast(?2*1e9 as bigint)%1000000000,dateadd(second,?2,?3))\";\n\t\t\tdefault -> \"dateadd(?1,?2,?3)\";\n\t\t};\n\t}\n\n\t@Override @SuppressWarnings(\"deprecation\")\n\tpublic String timestampdiffPattern(TemporalUnit unit, TemporalType fromTemporalType, TemporalType toTemporalType) {\n\t\tif ( unit == TemporalUnit.NATIVE ) {\n\t\t\t//use nanosecond as the \"native\" precision\n\t\t\treturn \"datediff_big(nanosecond,?2,?3)\";\n\t\t}\n\t\telse {\n\t\t\t//datediff() returns an int, and can easily\n\t\t\t//overflow when dealing with \"physical\"\n\t\t\t//durations, so use datediff_big()\n\t\t\treturn unit.normalized() == NANOSECOND\n\t\t\t\t\t? \"datediff_big(?1,?2,?3)\"\n\t\t\t\t\t: \"datediff(?1,?2,?3)\";\n\t\t}\n\t}\n\n\t@Override\n\tpublic String translateDurationField(TemporalUnit unit) {\n\t\t//use nanosecond as the \"native\" precision\n\t\treturn unit == TemporalUnit.NATIVE\n\t\t\t\t? \"nanosecond\"\n\t\t\t\t: super.translateDurationField( unit );\n\t}\n\n\t@Override\n\tpublic String translateExtractField(TemporalUnit unit) {\n\t\treturn switch (unit) {\n\t\t\t//the ISO week number (behavior of \"week\" depends on a system property)\n\t\t\tcase WEEK -> \"isowk\";\n\t\t\tcase OFFSET -> \"tz\";\n\t\t\tdefault -> super.translateExtractField( unit );\n\t\t};\n\t}\n\n\t@Override\n\tpublic void appendDatetimeFormat(SqlAppender appender, String format) {\n\t\tappender.appendSql( datetimeFormat(format).result() );\n\t}\n\n\tpublic static Replacer datetimeFormat(String format) {\n\t\treturn new Replacer( format, \"'\", \"\\\"\" )\n\t\t\t\t//era\n\t\t\t\t.replace(\"G\", \"g\")\n\n\t\t\t\t//y nothing to do\n\t\t\t\t//M nothing to do\n\n\t\t\t\t//w no equivalent\n\t\t\t\t//W no equivalent\n\t\t\t\t//Y no equivalent\n\n\t\t\t\t//day of week\n\t\t\t\t.replace(\"EEEE\", \"dddd\")\n\t\t\t\t.replace(\"EEE\", \"ddd\")\n\t\t\t\t//e no equivalent\n\n\t\t\t\t//d nothing to do\n\t\t\t\t//D no equivalent\n\n\t\t\t\t//am pm\n\t\t\t\t.replace(\"a\", \"tt\")\n\n\t\t\t\t//h nothing to do\n\t\t\t\t//H nothing to do\n\n\t\t\t\t//m nothing to do\n\t\t\t\t//s nothing to do\n\n\t\t\t\t//fractional seconds\n\t\t\t\t.replace(\"S\", \"F\")\n\n\t\t\t\t//timezones\n\t\t\t\t.replace(\"XXX\", \"K\") //UTC represented as \"Z\"\n\t\t\t\t.replace(\"xxx\", \"zzz\")\n\t\t\t\t.replace(\"x\", \"zz\");\n\t}\n\n\t@Override\n\tpublic void appendUUIDLiteral(SqlAppender appender, java.util.UUID literal) {\n\t\tappender.appendSql( \"cast('\" );\n\t\tappender.appendSql( literal.toString() );\n\t\tappender.appendSql( \"' as uniqueidentifier)\" );\n\t}\n\n\t@Override\n\tpublic void appendDateTimeLiteral(\n\t\t\tSqlAppender appender,\n\t\t\tTemporalAccessor temporalAccessor,\n\t\t\t@SuppressWarnings(\"deprecation\")\n\t\t\tTemporalType precision,\n\t\t\tTimeZone jdbcTimeZone) {\n\t\tswitch ( precision ) {\n\t\t\tcase DATE:\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsDate( appender, temporalAccessor );\n\t\t\t\tappender.appendSql( \"' as date)\" );\n\t\t\t\tbreak;\n\t\t\tcase TIME:\n\t\t\t\t//needed because the {t ... } JDBC is just buggy\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsTime( appender, temporalAccessor, supportsTemporalLiteralOffset(), jdbcTimeZone );\n\t\t\t\tappender.appendSql( \"' as time)\" );\n\t\t\t\tbreak;\n\t\t\tcase TIMESTAMP:\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\t//needed because the {ts ... } JDBC escape chokes on microseconds\n\t\t\t\tif ( supportsTemporalLiteralOffset() && temporalAccessor.isSupported( ChronoField.OFFSET_SECONDS ) ) {\n\t\t\t\t\tappendAsTimestampWithMicros( appender, temporalAccessor, true, jdbcTimeZone );\n\t\t\t\t\tappender.appendSql( \"' as datetimeoffset)\" );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tappendAsTimestampWithMicros( appender, temporalAccessor, false, jdbcTimeZone );\n\t\t\t\t\tappender.appendSql( \"' as datetime2)\" );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void appendDateTimeLiteral(\n\t\t\tSqlAppender appender,\n\t\t\tDate date,\n\t\t\t@SuppressWarnings(\"deprecation\")\n\t\t\tTemporalType precision,\n\t\t\tTimeZone jdbcTimeZone) {\n\t\tswitch ( precision ) {\n\t\t\tcase DATE:\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsDate( appender, date );\n\t\t\t\tappender.appendSql( \"' as date)\" );\n\t\t\t\tbreak;\n\t\t\tcase TIME:\n\t\t\t\t//needed because the {t ... } JDBC is just buggy\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsTime( appender, date );\n\t\t\t\tappender.appendSql( \"' as time)\" );\n\t\t\t\tbreak;\n\t\t\tcase TIMESTAMP:\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsTimestampWithMicros( appender, date, jdbcTimeZone );\n\t\t\t\tappender.appendSql( \"' as datetimeoffset)\" );\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void appendDateTimeLiteral(\n\t\t\tSqlAppender appender,\n\t\t\tCalendar calendar,\n\t\t\t@SuppressWarnings(\"deprecation\")\n\t\t\tTemporalType precision,\n\t\t\tTimeZone jdbcTimeZone) {\n\t\tswitch ( precision ) {\n\t\t\tcase DATE:\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsDate( appender, calendar );\n\t\t\t\tappender.appendSql( \"' as date)\" );\n\t\t\t\tbreak;\n\t\t\tcase TIME:\n\t\t\t\t//needed because the {t ... } JDBC is just buggy\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsTime( appender, calendar );\n\t\t\t\tappender.appendSql( \"' as time)\" );\n\t\t\t\tbreak;\n\t\t\tcase TIMESTAMP:\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsTimestampWithMillis( appender, calendar, jdbcTimeZone );\n\t\t\t\tappender.appendSql( \"' as datetime2)\" );\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getCreateTemporaryTableColumnAnnotation(int sqlTypeCode) {\n\t\treturn switch (sqlTypeCode) {\n\t\t\tcase Types.CHAR, Types.NCHAR, Types.VARCHAR, Types.NVARCHAR, Types.LONGVARCHAR, Types.LONGNVARCHAR ->\n\t\t\t\t\t\"collate database_default\";\n\t\t\tdefault -> \"\";\n\t\t};\n\t}\n\n\t@Override\n\tpublic String[] getDropSchemaCommand(String schemaName) {\n\t\treturn getVersion().isSameOrAfter( 13 )\n\t\t\t\t? new String[] { \"drop schema if exists \" + schemaName }\n\t\t\t\t: super.getDropSchemaCommand( schemaName );\n\t}\n\n\t@Override\n\tpublic String getCreateIndexString(boolean unique) {\n\t\t// we only create unique indexes, as opposed to unique constraints,\n\t\t// when the column is nullable, so safe to infer unique => nullable\n\t\treturn unique ? \"create unique nonclustered index\" : \"create index\";\n\t}\n\n\t@Override\n\tpublic String getCreateIndexTail(boolean unique, List<Column> columns) {\n\t\tif ( unique ) {\n\t\t\tfinal StringBuilder tail = new StringBuilder();\n\t\t\tfor ( Column column : columns ) {\n\t\t\t\tif ( column.isNullable() ) {\n\t\t\t\t\ttail.append( tail.isEmpty() ? \" where \" : \" and \" )\n\t\t\t\t\t\t\t.append( column.getQuotedName( this ) )\n\t\t\t\t\t\t\t.append( \" is not null\" );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tail.toString();\n\t\t}\n\t\telse {\n\t\t\treturn \"\";\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getAlterColumnTypeString(String columnName, String columnType, String columnDefinition) {\n\t\treturn \"alter column \" + columnName + \" \" + columnType;\n\t}\n\n\t@Override\n\tpublic boolean supportsAlterColumnType() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic NameQualifierSupport getNameQualifierSupport() {\n\t\treturn NameQualifierSupport.BOTH;\n\t}\n\n\t@Override\n\tpublic UniqueDelegate getUniqueDelegate() {\n\t\treturn uniqueDelegate;\n\t}\n\n\t@Override\n\tpublic Exporter<Sequence> getSequenceExporter() {\n\t\treturn exporter == null ? super.getSequenceExporter() : exporter;\n\t}\n\n\tprivate static class SqlServerSequenceExporter extends StandardSequenceExporter {\n\n\t\tpublic SqlServerSequenceExporter(Dialect dialect) {\n\t\t\tsuper( dialect );\n\t\t}\n\n\t\t@Override\n\t\tprotected String getFormattedSequenceName(QualifiedSequenceName name, Metadata metadata,\n\t\t\t\tSqlStringGenerationContext context) {\n\t\t\t// SQL Server does not allow the catalog in the sequence name.\n\t\t\t// See https://docs.microsoft.com/en-us/sql/t-sql/statements/create-sequence-transact-sql?view=sql-server-ver15&viewFallbackFrom=sql-server-ver12\n\t\t\t// Keeping the catalog in the name does not break on ORM, but it fails using Vert.X for Reactive.\n\t\t\treturn context.formatWithoutCatalog( name );\n\t\t}\n\t}\n\n\t@Override\n\tpublic String generatedAs(String generatedAs) {\n\t\treturn \" as (\" + generatedAs + \") persisted\";\n\t}\n\n\t@Override\n\tpublic boolean hasDataTypeBeforeGeneratedAs() {\n\t\treturn false;\n\t}\n\n\t// disabled foreign key constraints still prevent 'truncate table'\n\t// (these would help if we used 'delete' instead of 'truncate')\n\n//\t@Override\n//\tpublic String getDisableConstraintStatement(String tableName, String name) {\n//\t\treturn \"alter table \" + tableName + \" nocheck constraint \" + name;\n//\t}\n//\n//\t@Override\n//\tpublic String getEnableConstraintStatement(String tableName, String name) {\n//\t\treturn \"alter table \" + tableName + \" with check check constraint \" + name;\n//\t}\n\n\n\t@Override\n\tpublic MutationOperation createOptionalTableUpdateOperation(\n\t\t\tEntityMutationTarget mutationTarget,\n\t\t\tOptionalTableUpdate optionalTableUpdate,\n\t\t\tSessionFactoryImplementor factory) {\n\t\tfinal SQLServerSqlAstTranslator<JdbcOperation> translator =\n\t\t\t\tnew SQLServerSqlAstTranslator<>( factory, optionalTableUpdate );\n\t\treturn translator.createMergeOperation( optionalTableUpdate );\n\t}\n\n\t@Override\n\tpublic DmlTargetColumnQualifierSupport getDmlTargetColumnQualifierSupport() {\n\t\treturn DmlTargetColumnQualifierSupport.TABLE_ALIAS;\n\t}\n\n\t@Override\n\tpublic boolean supportsFromClauseInUpdate() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic CallableStatementSupport getCallableStatementSupport() {\n\t\treturn SQLServerCallableStatementSupport.INSTANCE;\n\t}\n\n\t@Override\n\tpublic String getCheckConstraintString(CheckConstraint checkConstraint) {\n\t\tfinal String constraintName = checkConstraint.getName();\n\t\treturn constraintName == null\n\t\t\t\t? \" check \" + getCheckConstraintOptions( checkConstraint )\n\t\t\t\t\t\t+ \"(\" + checkConstraint.getConstraint() + \")\"\n\t\t\t\t: \" constraint \" + constraintName + \" check \" + getCheckConstraintOptions( checkConstraint )\n\t\t\t\t\t\t+ \"(\" + checkConstraint.getConstraint() + \")\";\n\t}\n\n\tprivate String getCheckConstraintOptions(CheckConstraint checkConstraint) {\n\t\treturn isNotEmpty( checkConstraint.getOptions() ) ? checkConstraint.getOptions() + \" \" : \"\";\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/dialect/SQLServerDialect.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.dialect;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Types;\nimport java.time.temporal.ChronoField;\nimport java.time.temporal.TemporalAccessor;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.TimeZone;\n\nimport org.hibernate.Length;\nimport org.hibernate.LockMode;\nimport org.hibernate.LockOptions;\nimport org.hibernate.QueryTimeoutException;\nimport org.hibernate.boot.Metadata;\nimport org.hibernate.boot.model.FunctionContributions;\nimport org.hibernate.boot.model.TypeContributions;\nimport org.hibernate.boot.model.relational.QualifiedSequenceName;\nimport org.hibernate.boot.model.relational.Sequence;\nimport org.hibernate.boot.model.relational.SqlStringGenerationContext;\nimport org.hibernate.dialect.function.CommonFunctionFactory;\nimport org.hibernate.dialect.function.CountFunction;\nimport org.hibernate.dialect.function.SQLServerFormatEmulation;\nimport org.hibernate.dialect.function.SqlServerConvertTruncFunction;\nimport org.hibernate.dialect.identity.IdentityColumnSupport;\nimport org.hibernate.dialect.identity.SQLServerIdentityColumnSupport;\nimport org.hibernate.dialect.pagination.LimitHandler;\nimport org.hibernate.dialect.pagination.SQLServer2012LimitHandler;\nimport org.hibernate.dialect.sequence.SQLServer16SequenceSupport;\nimport org.hibernate.dialect.sequence.SQLServerSequenceSupport;\nimport org.hibernate.dialect.sequence.SequenceSupport;\nimport org.hibernate.dialect.unique.AlterTableUniqueIndexDelegate;\nimport org.hibernate.dialect.unique.UniqueDelegate;\nimport org.hibernate.engine.jdbc.Size;\nimport org.hibernate.engine.jdbc.dialect.spi.BasicSQLExceptionConverter;\nimport org.hibernate.engine.jdbc.dialect.spi.DialectResolutionInfo;\nimport org.hibernate.engine.jdbc.env.spi.IdentifierCaseStrategy;\nimport org.hibernate.engine.jdbc.env.spi.IdentifierHelper;\nimport org.hibernate.engine.jdbc.env.spi.IdentifierHelperBuilder;\nimport org.hibernate.engine.jdbc.env.spi.NameQualifierSupport;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.exception.ConstraintViolationException;\nimport org.hibernate.exception.LockTimeoutException;\nimport org.hibernate.exception.spi.SQLExceptionConversionDelegate;\nimport org.hibernate.exception.spi.TemplatedViolatedConstraintNameExtractor;\nimport org.hibernate.exception.spi.ViolatedConstraintNameExtractor;\nimport org.hibernate.internal.util.JdbcExceptionHelper;\nimport org.hibernate.internal.util.config.ConfigurationHelper;\nimport org.hibernate.internal.util.StringHelper;\nimport org.hibernate.mapping.CheckConstraint;\nimport org.hibernate.mapping.Column;\nimport org.hibernate.persister.entity.mutation.EntityMutationTarget;\nimport org.hibernate.procedure.internal.SQLServerCallableStatementSupport;\nimport org.hibernate.procedure.spi.CallableStatementSupport;\nimport org.hibernate.query.sqm.CastType;\nimport org.hibernate.query.sqm.FetchClauseType;\nimport org.hibernate.query.sqm.IntervalType;\nimport org.hibernate.query.sqm.TemporalUnit;\nimport org.hibernate.query.sqm.TrimSpec;\nimport org.hibernate.service.ServiceRegistry;\nimport org.hibernate.sql.ast.SqlAstNodeRenderingMode;\nimport org.hibernate.sql.ast.SqlAstTranslator;\nimport org.hibernate.sql.ast.SqlAstTranslatorFactory;\nimport org.hibernate.sql.ast.spi.SqlAppender;\nimport org.hibernate.sql.ast.spi.StandardSqlAstTranslatorFactory;\nimport org.hibernate.sql.ast.tree.Statement;\nimport org.hibernate.sql.exec.spi.JdbcOperation;\nimport org.hibernate.sql.model.MutationOperation;\nimport org.hibernate.sql.model.internal.OptionalTableUpdate;\nimport org.hibernate.tool.schema.internal.StandardSequenceExporter;\nimport org.hibernate.tool.schema.spi.Exporter;\nimport org.hibernate.type.BasicType;\nimport org.hibernate.type.BasicTypeRegistry;\nimport org.hibernate.type.StandardBasicTypes;\nimport org.hibernate.type.descriptor.java.JavaType;\nimport org.hibernate.type.descriptor.jdbc.JdbcType;\nimport org.hibernate.type.descriptor.jdbc.TimestampUtcAsJdbcTimestampJdbcType;\nimport org.hibernate.type.descriptor.jdbc.TinyIntAsSmallIntJdbcType;\nimport org.hibernate.type.descriptor.jdbc.UUIDJdbcType;\nimport org.hibernate.type.descriptor.jdbc.XmlJdbcType;\nimport org.hibernate.type.descriptor.jdbc.spi.JdbcTypeRegistry;\nimport org.hibernate.type.descriptor.sql.internal.DdlTypeImpl;\nimport org.hibernate.type.descriptor.sql.spi.DdlTypeRegistry;\n\nimport jakarta.persistence.TemporalType;\n\nimport static org.hibernate.cfg.DialectSpecificSettings.SQL_SERVER_COMPATIBILITY_LEVEL;\nimport static org.hibernate.exception.spi.TemplatedViolatedConstraintNameExtractor.extractUsingTemplate;\nimport static org.hibernate.internal.util.JdbcExceptionHelper.extractErrorCode;\nimport static org.hibernate.internal.util.JdbcExceptionHelper.extractSqlState;\nimport static org.hibernate.internal.util.StringHelper.isNotEmpty;\nimport static org.hibernate.query.sqm.TemporalUnit.NANOSECOND;\nimport static org.hibernate.query.sqm.produce.function.FunctionParameterType.INTEGER;\nimport static org.hibernate.type.SqlTypes.BLOB;\nimport static org.hibernate.type.SqlTypes.CLOB;\nimport static org.hibernate.type.SqlTypes.DATE;\nimport static org.hibernate.type.SqlTypes.DOUBLE;\nimport static org.hibernate.type.SqlTypes.GEOGRAPHY;\nimport static org.hibernate.type.SqlTypes.GEOMETRY;\nimport static org.hibernate.type.SqlTypes.LONG32NVARCHAR;\nimport static org.hibernate.type.SqlTypes.LONG32VARBINARY;\nimport static org.hibernate.type.SqlTypes.LONG32VARCHAR;\nimport static org.hibernate.type.SqlTypes.NCLOB;\nimport static org.hibernate.type.SqlTypes.NVARCHAR;\nimport static org.hibernate.type.SqlTypes.OTHER;\nimport static org.hibernate.type.SqlTypes.SQLXML;\nimport static org.hibernate.type.SqlTypes.TIME;\nimport static org.hibernate.type.SqlTypes.TIMESTAMP;\nimport static org.hibernate.type.SqlTypes.TIMESTAMP_WITH_TIMEZONE;\nimport static org.hibernate.type.SqlTypes.TIME_WITH_TIMEZONE;\nimport static org.hibernate.type.SqlTypes.UUID;\nimport static org.hibernate.type.SqlTypes.VARBINARY;\nimport static org.hibernate.type.SqlTypes.VARCHAR;\nimport static org.hibernate.type.descriptor.DateTimeUtils.appendAsDate;\nimport static org.hibernate.type.descriptor.DateTimeUtils.appendAsTime;\nimport static org.hibernate.type.descriptor.DateTimeUtils.appendAsTimestampWithMicros;\nimport static org.hibernate.type.descriptor.DateTimeUtils.appendAsTimestampWithMillis;\n\n/**\n * A dialect for Microsoft SQL Server 2008 and above\n *\n * @author Gavin King\n */\npublic class SQLServerDialect extends AbstractTransactSQLDialect {\n\tprivate final static DatabaseVersion MINIMUM_VERSION = DatabaseVersion.make( 11, 0 );\n\n\t/**\n\t * NOTE : 2100 is the documented limit supposedly - but in my testing, sending\n\t * 2100 parameters fails saying it must be less than 2100.\n\t */\n\tprivate static final int PARAM_LIST_SIZE_LIMIT = 2048;\n\n\t// See microsoft.sql.Types.GEOMETRY\n\tprivate static final int GEOMETRY_TYPE_CODE = -157;\n\t// See microsoft.sql.Types.GEOGRAPHY\n\tprivate static final int GEOGRAPHY_TYPE_CODE = -158;\n\n\tprivate final StandardSequenceExporter exporter;\n\tprivate final UniqueDelegate uniqueDelegate = new AlterTableUniqueIndexDelegate(this);\n\n\tprivate final SizeStrategy sizeStrategy = new SizeStrategyImpl() {\n\t\t@Override\n\t\tpublic Size resolveSize(\n\t\t\t\tJdbcType jdbcType,\n\t\t\t\tJavaType<?> javaType,\n\t\t\t\tInteger precision,\n\t\t\t\tInteger scale,\n\t\t\t\tLong length) {\n\t\t\treturn switch ( jdbcType.getDdlTypeCode() ) {\n\t\t\t\tcase BLOB, CLOB, NCLOB ->\n\t\t\t\t\t\tsuper.resolveSize( jdbcType, javaType, precision, scale,\n\t\t\t\t\t\t\t\tlength == null ? getDefaultLobLength() : length );\n\t\t\t\tdefault -> super.resolveSize( jdbcType, javaType, precision, scale, length );\n\t\t\t};\n\t\t}\n\t};\n\n\tpublic SQLServerDialect() {\n\t\tthis( MINIMUM_VERSION );\n\t}\n\n\tpublic SQLServerDialect(DatabaseVersion version) {\n\t\tsuper(version);\n\t\texporter = createSequenceExporter(version);\n\t}\n\n\tpublic SQLServerDialect(DialectResolutionInfo info) {\n\t\tthis( staticDetermineDatabaseVersion( info ) );\n\t\tregisterKeywords( info );\n\t}\n\n\t@Override\n\tpublic DatabaseVersion determineDatabaseVersion(DialectResolutionInfo info) {\n\t\treturn staticDetermineDatabaseVersion(info);\n\t}\n\n\t// Static version necessary to call from constructor\n\tprivate static DatabaseVersion staticDetermineDatabaseVersion(DialectResolutionInfo info) {\n\t\tfinal Integer compatibilityLevel = getCompatibilityLevel( info );\n\t\tif ( compatibilityLevel != null ) {\n\t\t\tfinal int majorVersion = compatibilityLevel / 10;\n\t\t\tfinal int minorVersion = compatibilityLevel % 10;\n\t\t\treturn DatabaseVersion.make( majorVersion, minorVersion );\n\t\t}\n\t\treturn info.makeCopyOrDefault( MINIMUM_VERSION );\n\t}\n\n\tprivate static Integer getCompatibilityLevel(DialectResolutionInfo info) {\n\t\tfinal DatabaseMetaData databaseMetaData = info.getDatabaseMetadata();\n\t\tif ( databaseMetaData != null ) {\n\t\t\ttry ( java.sql.Statement statement = databaseMetaData.getConnection().createStatement() ) {\n\t\t\t\tfinal ResultSet rs = statement.executeQuery( \"SELECT compatibility_level FROM sys.databases where name = db_name();\" );\n\t\t\t\tif ( rs.next() ) {\n\t\t\t\t\treturn rs.getInt( 1 );\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (SQLException e) {\n\t\t\t\tthrow BasicSQLExceptionConverter.INSTANCE.convert( e );\n\t\t\t}\n\t\t}\n\n\t\t// default to the dialect-specific configuration setting\n\t\treturn ConfigurationHelper.getInteger( SQL_SERVER_COMPATIBILITY_LEVEL, info.getConfigurationValues() );\n\t}\n\n\tprivate StandardSequenceExporter createSequenceExporter(DatabaseVersion version) {\n\t\treturn new SqlServerSequenceExporter(this);\n\t}\n\n\t@Override\n\tprotected DatabaseVersion getMinimumSupportedVersion() {\n\t\treturn MINIMUM_VERSION;\n\t}\n\n\t@Override\n\tprotected void registerDefaultKeywords() {\n\t\tsuper.registerDefaultKeywords();\n\t\tregisterKeyword( \"top\" );\n\t\tregisterKeyword( \"key\" );\n\t}\n\n\t@Override\n\tprotected String columnType(int sqlTypeCode) {\n\t\treturn switch (sqlTypeCode) {\n\t\t\t// there is no 'double' type in SQL server\n\t\t\t// but 'float' is double precision by default\n\t\t\tcase DOUBLE -> \"float\";\n\t\t\t// Prefer 'varchar(max)' and 'varbinary(max)' to\n\t\t\t// the deprecated TEXT and IMAGE types. Note that\n\t\t\t// the length of a VARCHAR or VARBINARY column must\n\t\t\t// be either between 1 and 8000 or exactly MAX, and\n\t\t\t// the length of an NVARCHAR column must be either\n\t\t\t// between 1 and 4000 or exactly MAX. (HHH-3965)\n\t\t\tcase CLOB -> \"varchar(max)\";\n\t\t\tcase NCLOB -> \"nvarchar(max)\";\n\t\t\tcase BLOB -> \"varbinary(max)\";\n\t\t\tcase DATE -> \"date\";\n\t\t\tcase TIME -> \"time\";\n\t\t\tcase TIMESTAMP -> \"datetime2($p)\";\n\t\t\tcase TIME_WITH_TIMEZONE, TIMESTAMP_WITH_TIMEZONE -> \"datetimeoffset($p)\";\n\t\t\tdefault -> super.columnType(sqlTypeCode);\n\t\t};\n\t}\n\n\t@Override\n\tprotected String castType(int sqlTypeCode) {\n\t\treturn switch (sqlTypeCode) {\n\t\t\tcase VARCHAR, LONG32VARCHAR, CLOB -> \"varchar(max)\";\n\t\t\tcase NVARCHAR, LONG32NVARCHAR, NCLOB -> \"nvarchar(max)\";\n\t\t\tcase VARBINARY, LONG32VARBINARY, BLOB -> \"varbinary(max)\";\n\t\t\tdefault -> super.castType( sqlTypeCode );\n\t\t};\n\t}\n\n\t@Override\n\tprotected void registerColumnTypes(TypeContributions typeContributions, ServiceRegistry serviceRegistry) {\n\t\tsuper.registerColumnTypes( typeContributions, serviceRegistry );\n\t\tfinal DdlTypeRegistry ddlTypeRegistry = typeContributions.getTypeConfiguration().getDdlTypeRegistry();\n\t\tddlTypeRegistry.addDescriptor( new DdlTypeImpl( GEOMETRY, \"geometry\", this ) );\n\t\tddlTypeRegistry.addDescriptor( new DdlTypeImpl( GEOGRAPHY, \"geography\", this ) );\n\t\tddlTypeRegistry.addDescriptor( new DdlTypeImpl( SQLXML, \"xml\", this ) );\n\t\tddlTypeRegistry.addDescriptor( new DdlTypeImpl( UUID, \"uniqueidentifier\", this ) );\n\t}\n\n\t@Override\n\tpublic JdbcType resolveSqlTypeDescriptor(\n\t\t\tString columnTypeName,\n\t\t\tint jdbcTypeCode,\n\t\t\tint precision,\n\t\t\tint scale,\n\t\t\tJdbcTypeRegistry jdbcTypeRegistry) {\n\t\tswitch ( jdbcTypeCode ) {\n\t\t\tcase OTHER:\n\t\t\t\tif ( columnTypeName.equals(\"uniqueidentifier\") ) {\n\t\t\t\t\tjdbcTypeCode = UUID;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GEOMETRY_TYPE_CODE:\n\t\t\t\tjdbcTypeCode = GEOMETRY;\n\t\t\t\tbreak;\n\t\t\tcase GEOGRAPHY_TYPE_CODE:\n\t\t\t\tjdbcTypeCode = GEOGRAPHY;\n\t\t\t\tbreak;\n\t\t}\n\t\treturn super.resolveSqlTypeDescriptor( columnTypeName, jdbcTypeCode, precision, scale, jdbcTypeRegistry );\n\t}\n\n\t@Override\n\tpublic int getMaxVarcharLength() {\n\t\treturn 8000;\n\t}\n\n\t@Override\n\tpublic int getMaxNVarcharLength() {\n\t\treturn 4000;\n\t}\n\n\t@Override\n\tpublic TimeZoneSupport getTimeZoneSupport() {\n\t\treturn TimeZoneSupport.NATIVE;\n\t}\n\n\t@Override\n\tpublic long getDefaultLobLength() {\n\t\t// this is essentially the only legal length for\n\t\t// a \"lob\" in SQL Server, i.e. the value of MAX\n\t\t// (caveat: for NVARCHAR it is half this value)\n\t\treturn Length.LONG32;\n\t}\n\n\t@Override\n\tpublic int getMaxIdentifierLength() {\n\t\treturn 128;\n\t}\n\n\t@Override\n\tpublic void contributeTypes(TypeContributions typeContributions, ServiceRegistry serviceRegistry) {\n\t\tsuper.contributeTypes( typeContributions, serviceRegistry );\n\n\t\t// Need to bind as java.sql.Timestamp because reading OffsetDateTime from a \"datetime2\" column fails\n\t\ttypeContributions.contributeJdbcType( TimestampUtcAsJdbcTimestampJdbcType.INSTANCE );\n\n\t\ttypeContributions.getTypeConfiguration().getJdbcTypeRegistry().addDescriptor(\n\t\t\t\tTypes.TINYINT,\n\t\t\t\tTinyIntAsSmallIntJdbcType.INSTANCE\n\t\t);\n\t\ttypeContributions.contributeJdbcType( XmlJdbcType.INSTANCE );\n\t\ttypeContributions.contributeJdbcType( UUIDJdbcType.INSTANCE );\n\t}\n\n\t@Override\n\tpublic void initializeFunctionRegistry(FunctionContributions functionContributions) {\n\t\tsuper.initializeFunctionRegistry(functionContributions);\n\n\t\tfinal BasicTypeRegistry basicTypeRegistry = functionContributions.getTypeConfiguration().getBasicTypeRegistry();\n\t\tBasicType<Date> dateType = basicTypeRegistry.resolve( StandardBasicTypes.DATE );\n\t\tBasicType<Date> timeType = basicTypeRegistry.resolve( StandardBasicTypes.TIME );\n\t\tBasicType<Date> timestampType = basicTypeRegistry.resolve( StandardBasicTypes.TIMESTAMP );\n\n\t\tCommonFunctionFactory functionFactory = new CommonFunctionFactory(functionContributions);\n\n\t\t// For SQL-Server we need to cast certain arguments to varchar(max) to be able to concat them\n\t\tfunctionContributions.getFunctionRegistry().register(\n\t\t\t\t\"count\",\n\t\t\t\tnew CountFunction(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\tfunctionContributions.getTypeConfiguration(),\n\t\t\t\t\t\tSqlAstNodeRenderingMode.DEFAULT,\n\t\t\t\t\t\t\"count_big\",\n\t\t\t\t\t\t\"+\",\n\t\t\t\t\t\t\"varchar(max)\",\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\"varbinary(max)\"\n\t\t\t\t)\n\t\t);\n\n\t\t// AVG by default uses the input type, so we possibly need to cast the argument type, hence a special function\n\t\tfunctionFactory.avg_castingNonDoubleArguments( this, SqlAstNodeRenderingMode.DEFAULT );\n\n\t\tfunctionFactory.log_log();\n\n\t\tfunctionFactory.round_round();\n\t\tfunctionFactory.everyAny_minMaxIif();\n\t\tfunctionFactory.octetLength_pattern( \"datalength(?1)\" );\n\t\tfunctionFactory.bitLength_pattern( \"datalength(?1)*8\" );\n\n\t\tfunctionFactory.locate_charindex();\n\t\tfunctionFactory.stddevPopSamp_stdevp();\n\t\tfunctionFactory.varPopSamp_varp();\n\n\t\tfunctionContributions.getFunctionRegistry().register(\n\t\t\t\t\"format\",\n\t\t\t\tnew SQLServerFormatEmulation( functionContributions.getTypeConfiguration() )\n\t\t);\n\n\t\t//actually translate() was added in 2017 but\n\t\t//it's not worth adding a new dialect for that!\n\t\tfunctionFactory.translate();\n\n\t\tfunctionFactory.median_percentileCont( true );\n\n\t\tfunctionContributions.getFunctionRegistry().namedDescriptorBuilder( \"datefromparts\" )\n\t\t\t\t.setInvariantType( dateType )\n\t\t\t\t.setExactArgumentCount( 3 )\n\t\t\t\t.setParameterTypes(INTEGER)\n\t\t\t\t.register();\n\t\tfunctionContributions.getFunctionRegistry().namedDescriptorBuilder( \"timefromparts\" )\n\t\t\t\t.setInvariantType( timeType )\n\t\t\t\t.setExactArgumentCount( 5 )\n\t\t\t\t.setParameterTypes(INTEGER)\n\t\t\t\t.register();\n\t\tfunctionContributions.getFunctionRegistry().namedDescriptorBuilder( \"smalldatetimefromparts\" )\n\t\t\t\t.setInvariantType( timestampType )\n\t\t\t\t.setExactArgumentCount( 5 )\n\t\t\t\t.setParameterTypes(INTEGER)\n\t\t\t\t.register();\n\t\tfunctionContributions.getFunctionRegistry().namedDescriptorBuilder( \"datetimefromparts\" )\n\t\t\t\t.setInvariantType( timestampType )\n\t\t\t\t.setExactArgumentCount( 7 )\n\t\t\t\t.setParameterTypes(INTEGER)\n\t\t\t\t.register();\n\t\tfunctionContributions.getFunctionRegistry().namedDescriptorBuilder( \"datetime2fromparts\" )\n\t\t\t\t.setInvariantType( timestampType )\n\t\t\t\t.setExactArgumentCount( 8 )\n\t\t\t\t.setParameterTypes(INTEGER)\n\t\t\t\t.register();\n\t\tfunctionContributions.getFunctionRegistry().namedDescriptorBuilder( \"datetimeoffsetfromparts\" )\n\t\t\t\t.setInvariantType( timestampType )\n\t\t\t\t.setExactArgumentCount( 10 )\n\t\t\t\t.setParameterTypes(INTEGER)\n\t\t\t\t.register();\n\n\t\tfunctionFactory.windowFunctions();\n\t\tfunctionFactory.inverseDistributionOrderedSetAggregates_windowEmulation();\n\t\tfunctionFactory.hypotheticalOrderedSetAggregates_windowEmulation();\n\t\tif ( getVersion().isSameOrAfter( 14 ) ) {\n\t\t\tfunctionFactory.listagg_stringAggWithinGroup( \"varchar(max)\" );\n\t\t}\n\t\tif ( getVersion().isSameOrAfter( 16 ) ) {\n\t\t\tfunctionFactory.leastGreatest();\n\t\t\tfunctionFactory.dateTrunc_datetrunc();\n\t\t\tfunctionFactory.trunc_round_datetrunc();\n\t\t}\n\t\telse {\n\t\t\tfunctionContributions.getFunctionRegistry().register(\n\t\t\t\t\t\"trunc\",\n\t\t\t\t\tnew SqlServerConvertTruncFunction( functionContributions.getTypeConfiguration() )\n\t\t\t);\n\t\t\tfunctionContributions.getFunctionRegistry().registerAlternateKey( \"truncate\", \"trunc\" );\n\t\t}\n\t}\n\n\t@Override\n\tpublic String trimPattern(TrimSpec specification, boolean isWhitespace) {\n\t\tif ( getVersion().isSameOrAfter( 16 ) ) {\n\t\t\treturn switch (specification) {\n\t\t\t\tcase BOTH -> isWhitespace ? \"trim(?1)\" : \"trim(?2 from ?1)\";\n\t\t\t\tcase LEADING -> isWhitespace ? \"ltrim(?1)\" : \"ltrim(?1,?2)\";\n\t\t\t\tcase TRAILING -> isWhitespace ? \"rtrim(?1)\" : \"rtrim(?1,?2)\";\n\t\t\t};\n\t\t}\n\t\treturn super.trimPattern( specification, isWhitespace );\n\t}\n\n\t@Override\n\tpublic SqlAstTranslatorFactory getSqlAstTranslatorFactory() {\n\t\treturn new StandardSqlAstTranslatorFactory() {\n\t\t\t@Override\n\t\t\tprotected <T extends JdbcOperation> SqlAstTranslator<T> buildTranslator(\n\t\t\t\t\tSessionFactoryImplementor sessionFactory, Statement statement) {\n\t\t\t\treturn new SQLServerSqlAstTranslator<>( sessionFactory, statement );\n\t\t\t}\n\t\t};\n\t}\n\n\t@Override\n\tpublic SizeStrategy getSizeStrategy() {\n\t\treturn sizeStrategy;\n\t}\n\n\t@Override\n\tpublic String castPattern(CastType from, CastType to) {\n\t\tif ( to == CastType.STRING ) {\n\t\t\tswitch ( from ) {\n\t\t\t\tcase TIMESTAMP:\n\t\t\t\t\t// SQL Server uses yyyy-MM-dd HH:mm:ss.nnnnnnn by default when doing a cast, but only need second precision\n\t\t\t\t\treturn \"format(?1,'yyyy-MM-dd HH:mm:ss')\";\n\t\t\t\tcase TIME:\n\t\t\t\t\t// SQL Server uses HH:mm:ss.nnnnnnn by default when doing a cast, but only need second precision\n\t\t\t\t\t// SQL Server requires quoting of ':' in time formats and the use of 'hh' instead of 'HH'\n\t\t\t\t\treturn \"format(?1,'hh\\\\:mm\\\\:ss')\";\n\t\t\t}\n\t\t}\n\t\treturn super.castPattern( from, to );\n\t}\n\n\t@Override\n\tpublic String currentTimestamp() {\n\t\treturn \"sysdatetime()\";\n\t}\n\n\t@Override\n\tpublic IdentifierHelper buildIdentifierHelper(IdentifierHelperBuilder builder, DatabaseMetaData dbMetaData)\n\t\t\tthrows SQLException {\n\n\t\tif ( dbMetaData == null ) {\n\t\t\t// TODO: if DatabaseMetaData != null, unquoted case strategy is set to IdentifierCaseStrategy.UPPER\n\t\t\t//       Check to see if this setting is correct.\n\t\t\tbuilder.setUnquotedCaseStrategy( IdentifierCaseStrategy.MIXED );\n\t\t\tbuilder.setQuotedCaseStrategy( IdentifierCaseStrategy.MIXED );\n\t\t}\n\n\t\treturn super.buildIdentifierHelper( builder, dbMetaData );\n\t}\n\n\t@Override\n\tpublic String currentTime() {\n\t\treturn \"convert(time,getdate())\";\n\t}\n\n\t@Override\n\tpublic String currentDate() {\n\t\treturn \"convert(date,getdate())\";\n\t}\n\n\t@Override\n\tpublic String currentTimestampWithTimeZone() {\n\t\treturn \"sysdatetimeoffset()\";\n\t}\n\n\t@Override\n\tpublic String getNoColumnsInsertString() {\n\t\treturn \"default values\";\n\t}\n\n\t@Override\n\tpublic LimitHandler getLimitHandler() {\n\t\treturn SQLServer2012LimitHandler.INSTANCE;\n\t}\n\n\t@Override\n\tpublic boolean supportsValuesList() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsDistinctFromPredicate() {\n\t\treturn getVersion().isSameOrAfter( 16 );\n\t}\n\n\t@Override\n\tpublic char closeQuote() {\n\t\treturn ']';\n\t}\n\n\t@Override\n\tpublic String getCurrentSchemaCommand() {\n\t\treturn \"select schema_name()\";\n\t}\n\n\t@Override\n\tpublic boolean supportsIfExistsBeforeTableName() {\n\t\treturn getVersion().isSameOrAfter( 16 ) || super.supportsIfExistsBeforeTableName();\n\t}\n\n\t@Override\n\tpublic boolean supportsIfExistsBeforeConstraintName() {\n\t\treturn getVersion().isSameOrAfter( 16 ) || super.supportsIfExistsBeforeConstraintName();\n\t}\n\n\t@Override\n\tpublic char openQuote() {\n\t\treturn '[';\n\t}\n\n\t@Override\n\tpublic String appendLockHint(LockOptions lockOptions, String tableName) {\n\t\tLockMode lockMode = lockOptions.getAliasSpecificLockMode( tableName );\n\t\tif ( lockMode == null ) {\n\t\t\tlockMode = lockOptions.getLockMode();\n\t\t}\n\n\t\tfinal String writeLockStr = lockOptions.getTimeOut() == LockOptions.SKIP_LOCKED ? \"updlock\" : \"updlock,holdlock\";\n\t\tfinal String readLockStr = lockOptions.getTimeOut() == LockOptions.SKIP_LOCKED ? \"updlock\" : \"holdlock\";\n\n\t\tfinal String noWaitStr = lockOptions.getTimeOut() == LockOptions.NO_WAIT ? \",nowait\" : \"\";\n\t\tfinal String skipLockStr = lockOptions.getTimeOut() == LockOptions.SKIP_LOCKED ? \",readpast\" : \"\";\n\n\t\treturn switch (lockMode) {\n\t\t\tcase PESSIMISTIC_WRITE, WRITE ->\n\t\t\t\t\ttableName + \" with (\" + writeLockStr + \",rowlock\" + noWaitStr + skipLockStr + \")\";\n\t\t\tcase PESSIMISTIC_READ -> tableName + \" with (\" + readLockStr + \",rowlock\" + noWaitStr + skipLockStr + \")\";\n\t\t\tcase UPGRADE_SKIPLOCKED -> tableName + \" with (updlock,rowlock,readpast\" + noWaitStr + \")\";\n\t\t\tcase UPGRADE_NOWAIT -> tableName + \" with (updlock,holdlock,rowlock,nowait)\";\n\t\t\tdefault -> tableName;\n\t\t};\n\t}\n\n\n\t/**\n\t * The current_timestamp is more accurate, but only known to be supported in SQL Server 7.0 and later and\n\t * Sybase not known to support it at all\n\t * <p>\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic String getCurrentTimestampSelectString() {\n\t\treturn \"select current_timestamp\";\n\t}\n\n\t// Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\t@Override\n\tpublic boolean supportsResultSetPositionQueryMethodsOnForwardOnlyCursor() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean supportsCircularCascadeDeleteConstraints() {\n\t\t// SQL Server (at least up through 2005) does not support defining\n\t\t// cascade delete constraints which can circle back to the mutating\n\t\t// table\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean supportsLobValueChangePropagation() {\n\t\t// note: at least my local SQL Server 2005 Express shows this not working...\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean doesReadCommittedCauseWritersToBlockReaders() {\n\t\t// here assume SQLServer2005 using snapshot isolation, which does not have this problem\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean doesRepeatableReadCauseReadersToBlockWriters() {\n\t\t// here assume SQLServer2005 using snapshot isolation, which does not have this problem\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic int getInExpressionCountLimit() {\n\t\treturn PARAM_LIST_SIZE_LIMIT;\n\t}\n\n\t@Override\n\tpublic IdentityColumnSupport getIdentityColumnSupport() {\n\t\treturn SQLServerIdentityColumnSupport.INSTANCE;\n\t}\n\n\t@Override\n\tpublic boolean supportsNonQueryWithCTE() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsSkipLocked() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsNoWait() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsWait() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic SequenceSupport getSequenceSupport() {\n\t\treturn getVersion().isSameOrAfter( 16 )\n\t\t\t\t? SQLServer16SequenceSupport.INSTANCE\n\t\t\t\t: SQLServerSequenceSupport.INSTANCE;\n\t}\n\n\t@Override\n\tpublic String getQuerySequencesString() {\n\t\t// The upper-case name should work on both case-sensitive and case-insensitive collations.\n\t\treturn \"select * from INFORMATION_SCHEMA.SEQUENCES\";\n\t}\n\n\t@Override\n\tpublic String getQueryHintString(String sql, String hints) {\n\t\tfinal StringBuilder buffer =\n\t\t\t\tnew StringBuilder( sql.length() + hints.length() + 12 );\n\t\tfinal int pos = sql.indexOf( ';' );\n\t\tif ( pos > -1 ) {\n\t\t\tbuffer.append( sql, 0, pos );\n\t\t}\n\t\telse {\n\t\t\tbuffer.append( sql );\n\t\t}\n\t\tbuffer.append( \" OPTION (\" ).append( hints ).append( \")\" );\n\t\tif ( pos > -1 ) {\n\t\t\tbuffer.append( \";\" );\n\t\t}\n\t\tsql = buffer.toString();\n\t\treturn sql;\n\t}\n\n\t@Override\n\tpublic boolean supportsNullPrecedence() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean supportsOffsetInSubquery() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsWindowFunctions() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsLateral() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsRecursiveCTE() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsFetchClause(FetchClauseType type) {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic ViolatedConstraintNameExtractor getViolatedConstraintNameExtractor() {\n\t\treturn new TemplatedViolatedConstraintNameExtractor(\n\t\t\t\tsqle -> {\n\t\t\t\t\tswitch ( extractErrorCode( sqle ) ) {\n\t\t\t\t\t\tcase 2627:\n\t\t\t\t\t\tcase 2601:\n\t\t\t\t\t\t\tString message = sqle.getMessage();\n\t\t\t\t\t\t\tif ( message.contains(\"unique index \") ) {\n\t\t\t\t\t\t\t\treturn extractUsingTemplate( \"unique index '\", \"'\", message);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\treturn extractUsingTemplate( \"'\", \"'\", message);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@Override\n\tpublic SQLExceptionConversionDelegate buildSQLExceptionConversionDelegate() {\n\t\treturn (sqlException, message, sql) -> {\n\t\t\tfinal String sqlState = extractSqlState( sqlException );\n\t\t\tif ( \"HY008\".equals( sqlState ) ) {\n\t\t\t\treturn new QueryTimeoutException( message, sqlException, sql );\n\t\t\t}\n\n\t\t\treturn switch ( extractErrorCode( sqlException ) ) {\n\t\t\t\tcase 1222 -> new LockTimeoutException( message, sqlException, sql );\n\t\t\t\tcase 2627, 2601 -> new ConstraintViolationException(\n\t\t\t\t\t\tmessage,\n\t\t\t\t\t\tsqlException,\n\t\t\t\t\t\tsql,\n\t\t\t\t\t\tConstraintViolationException.ConstraintKind.UNIQUE,\n\t\t\t\t\t\tgetViolatedConstraintNameExtractor().extractConstraintName( sqlException )\n\t\t\t\t);\n\t\t\t\tdefault -> null;\n\t\t\t};\n\t\t};\n\t}\n\n\t@Override\n\tpublic int getDefaultTimestampPrecision() {\n\t\treturn 7;\n\t}\n\n\t/**\n\t * Even though SQL Server only supports 1/10th microsecond precision,\n\t * we use nanosecond as the \"native\" precision for datetime arithmetic\n\t * since it simplifies calculations.\n\t */\n\t@Override\n\tpublic long getFractionalSecondPrecisionInNanos() {\n//\t\treturn 100; // 1/10th microsecond\n\t\treturn 1;\n\t}\n\n\t@Override\n\tpublic String extractPattern(TemporalUnit unit) {\n\t\treturn switch (unit) {\n\t\t\tcase TIMEZONE_HOUR -> \"(datepart(tz,?2)/60)\";\n\t\t\tcase TIMEZONE_MINUTE -> \"(datepart(tz,?2)%60)\";\n\t\t\t// currently Dialect.extract() doesn't need\n\t\t\t// to handle NANOSECOND (might change that?)\n//\t\t\tcase NANOSECOND ->\n//\t\t\t\t// this should evaluate to a bigint type\n//\t\t\t\t\t\"(datepart(second,?2)*1000000000+datepart(nanosecond,?2))\";\n\t\t\tcase SECOND ->\n\t\t\t\t//this should evaluate to a floating point type\n\t\t\t\t\t\"(datepart(second,?2)+datepart(nanosecond,?2)/1000000000)\";\n\t\t\tcase EPOCH -> \"datediff_big(second, '1970-01-01', ?2)\";\n\t\t\tdefault -> \"datepart(?1,?2)\";\n\t\t};\n\t}\n\n\t@Override @SuppressWarnings(\"deprecation\")\n\tpublic String timestampaddPattern(TemporalUnit unit, TemporalType temporalType, IntervalType intervalType) {\n\t\t// dateadd() supports only especially small magnitudes\n\t\t// since it casts its argument to int (and unfortunately\n\t\t// there's no dateadd_big()) so here we need to use two\n\t\t// calls to dateadd() to add a whole duration\n\t\treturn switch (unit) { //use nanosecond as the \"native\" precision\n\t\t\tcase NANOSECOND, NATIVE -> \"dateadd(nanosecond,?2%1000000000,dateadd(second,?2/1000000000,?3))\";\n\t\t\t// we could, in principle, use 1/10th microsecond as the \"native\" precision\n//\t\t\tcase NATIVE -> \"dateadd(nanosecond,?2%10000000,dateadd(second,?2/10000000,?3))\";\n\t\t\tcase SECOND -> \"dateadd(nanosecond,cast(?2*1e9 as bigint)%1000000000,dateadd(second,?2,?3))\";\n\t\t\tdefault -> \"dateadd(?1,?2,?3)\";\n\t\t};\n\t}\n\n\t@Override @SuppressWarnings(\"deprecation\")\n\tpublic String timestampdiffPattern(TemporalUnit unit, TemporalType fromTemporalType, TemporalType toTemporalType) {\n\t\tif ( unit == TemporalUnit.NATIVE ) {\n\t\t\t//use nanosecond as the \"native\" precision\n\t\t\treturn \"datediff_big(nanosecond,?2,?3)\";\n\t\t}\n\t\telse {\n\t\t\t//datediff() returns an int, and can easily\n\t\t\t//overflow when dealing with \"physical\"\n\t\t\t//durations, so use datediff_big()\n\t\t\treturn unit.normalized() == NANOSECOND\n\t\t\t\t\t? \"datediff_big(?1,?2,?3)\"\n\t\t\t\t\t: \"datediff(?1,?2,?3)\";\n\t\t}\n\t}\n\n\t@Override\n\tpublic String translateDurationField(TemporalUnit unit) {\n\t\t//use nanosecond as the \"native\" precision\n\t\treturn unit == TemporalUnit.NATIVE\n\t\t\t\t? \"nanosecond\"\n\t\t\t\t: super.translateDurationField( unit );\n\t}\n\n\t@Override\n\tpublic String translateExtractField(TemporalUnit unit) {\n\t\treturn switch (unit) {\n\t\t\t//the ISO week number (behavior of \"week\" depends on a system property)\n\t\t\tcase WEEK -> \"isowk\";\n\t\t\tcase OFFSET -> \"tz\";\n\t\t\tdefault -> super.translateExtractField( unit );\n\t\t};\n\t}\n\n\t@Override\n\tpublic void appendDatetimeFormat(SqlAppender appender, String format) {\n\t\tappender.appendSql( datetimeFormat(format).result() );\n\t}\n\n\tpublic static Replacer datetimeFormat(String format) {\n\t\treturn new Replacer( format, \"'\", \"\\\"\" )\n\t\t\t\t//era\n\t\t\t\t.replace(\"G\", \"g\")\n\n\t\t\t\t//y nothing to do\n\t\t\t\t//M nothing to do\n\n\t\t\t\t//w no equivalent\n\t\t\t\t//W no equivalent\n\t\t\t\t//Y no equivalent\n\n\t\t\t\t//day of week\n\t\t\t\t.replace(\"EEEE\", \"dddd\")\n\t\t\t\t.replace(\"EEE\", \"ddd\")\n\t\t\t\t//e no equivalent\n\n\t\t\t\t//d nothing to do\n\t\t\t\t//D no equivalent\n\n\t\t\t\t//am pm\n\t\t\t\t.replace(\"a\", \"tt\")\n\n\t\t\t\t//h nothing to do\n\t\t\t\t//H nothing to do\n\n\t\t\t\t//m nothing to do\n\t\t\t\t//s nothing to do\n\n\t\t\t\t//fractional seconds\n\t\t\t\t.replace(\"S\", \"F\")\n\n\t\t\t\t//timezones\n\t\t\t\t.replace(\"XXX\", \"K\") //UTC represented as \"Z\"\n\t\t\t\t.replace(\"xxx\", \"zzz\")\n\t\t\t\t.replace(\"x\", \"zz\");\n\t}\n\n\t@Override\n\tpublic void appendUUIDLiteral(SqlAppender appender, java.util.UUID literal) {\n\t\tappender.appendSql( \"cast('\" );\n\t\tappender.appendSql( literal.toString() );\n\t\tappender.appendSql( \"' as uniqueidentifier)\" );\n\t}\n\n\t@Override\n\tpublic void appendDateTimeLiteral(\n\t\t\tSqlAppender appender,\n\t\t\tTemporalAccessor temporalAccessor,\n\t\t\t@SuppressWarnings(\"deprecation\")\n\t\t\tTemporalType precision,\n\t\t\tTimeZone jdbcTimeZone) {\n\t\tswitch ( precision ) {\n\t\t\tcase DATE:\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsDate( appender, temporalAccessor );\n\t\t\t\tappender.appendSql( \"' as date)\" );\n\t\t\t\tbreak;\n\t\t\tcase TIME:\n\t\t\t\t//needed because the {t ... } JDBC is just buggy\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsTime( appender, temporalAccessor, supportsTemporalLiteralOffset(), jdbcTimeZone );\n\t\t\t\tappender.appendSql( \"' as time)\" );\n\t\t\t\tbreak;\n\t\t\tcase TIMESTAMP:\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\t//needed because the {ts ... } JDBC escape chokes on microseconds\n\t\t\t\tif ( supportsTemporalLiteralOffset() && temporalAccessor.isSupported( ChronoField.OFFSET_SECONDS ) ) {\n\t\t\t\t\tappendAsTimestampWithMicros( appender, temporalAccessor, true, jdbcTimeZone );\n\t\t\t\t\tappender.appendSql( \"' as datetimeoffset)\" );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tappendAsTimestampWithMicros( appender, temporalAccessor, false, jdbcTimeZone );\n\t\t\t\t\tappender.appendSql( \"' as datetime2)\" );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void appendDateTimeLiteral(\n\t\t\tSqlAppender appender,\n\t\t\tDate date,\n\t\t\t@SuppressWarnings(\"deprecation\")\n\t\t\tTemporalType precision,\n\t\t\tTimeZone jdbcTimeZone) {\n\t\tswitch ( precision ) {\n\t\t\tcase DATE:\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsDate( appender, date );\n\t\t\t\tappender.appendSql( \"' as date)\" );\n\t\t\t\tbreak;\n\t\t\tcase TIME:\n\t\t\t\t//needed because the {t ... } JDBC is just buggy\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsTime( appender, date );\n\t\t\t\tappender.appendSql( \"' as time)\" );\n\t\t\t\tbreak;\n\t\t\tcase TIMESTAMP:\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsTimestampWithMicros( appender, date, jdbcTimeZone );\n\t\t\t\tappender.appendSql( \"' as datetimeoffset)\" );\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void appendDateTimeLiteral(\n\t\t\tSqlAppender appender,\n\t\t\tCalendar calendar,\n\t\t\t@SuppressWarnings(\"deprecation\")\n\t\t\tTemporalType precision,\n\t\t\tTimeZone jdbcTimeZone) {\n\t\tswitch ( precision ) {\n\t\t\tcase DATE:\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsDate( appender, calendar );\n\t\t\t\tappender.appendSql( \"' as date)\" );\n\t\t\t\tbreak;\n\t\t\tcase TIME:\n\t\t\t\t//needed because the {t ... } JDBC is just buggy\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsTime( appender, calendar );\n\t\t\t\tappender.appendSql( \"' as time)\" );\n\t\t\t\tbreak;\n\t\t\tcase TIMESTAMP:\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsTimestampWithMillis( appender, calendar, jdbcTimeZone );\n\t\t\t\tappender.appendSql( \"' as datetime2)\" );\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getCreateTemporaryTableColumnAnnotation(int sqlTypeCode) {\n\t\treturn switch (sqlTypeCode) {\n\t\t\tcase Types.CHAR, Types.NCHAR, Types.VARCHAR, Types.NVARCHAR, Types.LONGVARCHAR, Types.LONGNVARCHAR ->\n\t\t\t\t\t\"collate database_default\";\n\t\t\tdefault -> \"\";\n\t\t};\n\t}\n\n\t@Override\n\tpublic String[] getDropSchemaCommand(String schemaName) {\n\t\treturn getVersion().isSameOrAfter( 13 )\n\t\t\t\t? new String[] { \"drop schema if exists \" + schemaName }\n\t\t\t\t: super.getDropSchemaCommand( schemaName );\n\t}\n\n\t@Override\n\tpublic String getCreateIndexString(boolean unique) {\n\t\t// we only create unique indexes, as opposed to unique constraints,\n\t\t// when the column is nullable, so safe to infer unique => nullable\n\t\treturn unique ? \"create unique nonclustered index\" : \"create index\";\n\t}\n\n\t@Override\n\tpublic String getCreateIndexTail(boolean unique, List<Column> columns) {\n\t\tif ( unique ) {\n\t\t\tfinal StringBuilder tail = new StringBuilder();\n\t\t\tfor ( Column column : columns ) {\n\t\t\t\tif ( column.isNullable() ) {\n\t\t\t\t\ttail.append( tail.isEmpty() ? \" where \" : \" and \" )\n\t\t\t\t\t\t\t.append( column.getQuotedName( this ) )\n\t\t\t\t\t\t\t.append( \" is not null\" );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tail.toString();\n\t\t}\n\t\telse {\n\t\t\treturn \"\";\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getAlterColumnTypeString(String columnName, String columnType, String columnDefinition) {\n\t\treturn \"alter column \" + columnName + \" \" + columnType;\n\t}\n\n\t@Override\n\tpublic boolean supportsAlterColumnType() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic NameQualifierSupport getNameQualifierSupport() {\n\t\treturn NameQualifierSupport.BOTH;\n\t}\n\n\t@Override\n\tpublic UniqueDelegate getUniqueDelegate() {\n\t\treturn uniqueDelegate;\n\t}\n\n\t@Override\n\tpublic Exporter<Sequence> getSequenceExporter() {\n\t\treturn exporter == null ? super.getSequenceExporter() : exporter;\n\t}\n\n\tprivate static class SqlServerSequenceExporter extends StandardSequenceExporter {\n\n\t\tpublic SqlServerSequenceExporter(Dialect dialect) {\n\t\t\tsuper( dialect );\n\t\t}\n\n\t\t@Override\n\t\tprotected String getFormattedSequenceName(QualifiedSequenceName name, Metadata metadata,\n\t\t\t\tSqlStringGenerationContext context) {\n\t\t\t// SQL Server does not allow the catalog in the sequence name.\n\t\t\t// See https://docs.microsoft.com/en-us/sql/t-sql/statements/create-sequence-transact-sql?view=sql-server-ver15&viewFallbackFrom=sql-server-ver12\n\t\t\t// Keeping the catalog in the name does not break on ORM, but it fails using Vert.X for Reactive.\n\t\t\treturn context.formatWithoutCatalog( name );\n\t\t}\n\t}\n\n\t@Override\n\tpublic String generatedAs(String generatedAs) {\n\t\treturn \" as (\" + generatedAs + \") persisted\";\n\t}\n\n\t@Override\n\tpublic boolean hasDataTypeBeforeGeneratedAs() {\n\t\treturn false;\n\t}\n\n\t// disabled foreign key constraints still prevent 'truncate table'\n\t// (these would help if we used 'delete' instead of 'truncate')\n\n//\t@Override\n//\tpublic String getDisableConstraintStatement(String tableName, String name) {\n//\t\treturn \"alter table \" + tableName + \" nocheck constraint \" + name;\n//\t}\n//\n//\t@Override\n//\tpublic String getEnableConstraintStatement(String tableName, String name) {\n//\t\treturn \"alter table \" + tableName + \" with check check constraint \" + name;\n//\t}\n\n\n\t@Override\n\tpublic MutationOperation createOptionalTableUpdateOperation(\n\t\t\tEntityMutationTarget mutationTarget,\n\t\t\tOptionalTableUpdate optionalTableUpdate,\n\t\t\tSessionFactoryImplementor factory) {\n\t\tfinal SQLServerSqlAstTranslator<JdbcOperation> translator =\n\t\t\t\tnew SQLServerSqlAstTranslator<>( factory, optionalTableUpdate );\n\t\treturn translator.createMergeOperation( optionalTableUpdate );\n\t}\n\n\t@Override\n\tpublic DmlTargetColumnQualifierSupport getDmlTargetColumnQualifierSupport() {\n\t\treturn DmlTargetColumnQualifierSupport.TABLE_ALIAS;\n\t}\n\n\t@Override\n\tpublic boolean supportsFromClauseInUpdate() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic CallableStatementSupport getCallableStatementSupport() {\n\t\treturn SQLServerCallableStatementSupport.INSTANCE;\n\t}\n\n\t@Override\n\tpublic String getCheckConstraintString(CheckConstraint checkConstraint) {\n\t\tfinal String constraintName = checkConstraint.getName();\n\t\treturn constraintName == null\n\t\t\t\t? \" check \" + getCheckConstraintOptions( checkConstraint )\n\t\t\t\t\t\t+ \"(\" + checkConstraint.getConstraint() + \")\"\n\t\t\t\t: \" constraint \" + constraintName + \" check \" + getCheckConstraintOptions( checkConstraint )\n\t\t\t\t\t\t+ \"(\" + checkConstraint.getConstraint() + \")\";\n\t}\n\n\tprivate String getCheckConstraintOptions(CheckConstraint checkConstraint) {\n\t\treturn isNotEmpty( checkConstraint.getOptions() ) ? checkConstraint.getOptions() + \" \" : \"\";\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private static DatabaseVersion staticDetermineDatabaseVersion(DialectResolutionInfo info) {\n\t\tfinal Integer compatibilityLevel = getCompatibilityLevel( info );\n\t\tif ( compatibilityLevel != null ) {\n\t\t\tfinal int majorVersion = compatibilityLevel / 10;\n\t\t\tfinal int minorVersion = compatibilityLevel % 10;\n\t\t\treturn DatabaseVersion.make( majorVersion, minorVersion );\n\t\t}\n\t\treturn info.makeCopyOrDefault( MINIMUM_VERSION );\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.dialect.SQLServerDialect#getCompatibilityLevel\n methodBody: private static Integer getCompatibilityLevel(DialectResolutionInfo info) {\nfinal DatabaseMetaData databaseMetaData=info.getDatabaseMetadata();\nif(databaseMetaData != null){try(java.sql.Statement statement=databaseMetaData.getConnection().createStatement())final ResultSet rs=statement.executeQuery(\"SELECT compatibility_level FROM sys.databases where name = db_name();\");\nif(rs.next()){return rs.getInt(1);\n}catch(SQLException e)throw BasicSQLExceptionConverter.INSTANCE.convert(e);\n}return ConfigurationHelper.getInteger(SQL_SERVER_COMPATIBILITY_LEVEL,info.getConfigurationValues());\n}"
        ],
        "sourceCodeAfterRefactoring": "@Override\n\tpublic DatabaseVersion determineDatabaseVersion(DialectResolutionInfo info) {\n\t\treturn staticDetermineDatabaseVersion(info);\n\t}\nprivate static DatabaseVersion staticDetermineDatabaseVersion(DialectResolutionInfo info) {\n\t\tfinal Integer compatibilityLevel = getCompatibilityLevel( info );\n\t\tif ( compatibilityLevel != null ) {\n\t\t\tfinal int majorVersion = compatibilityLevel / 10;\n\t\t\tfinal int minorVersion = compatibilityLevel % 10;\n\t\t\treturn DatabaseVersion.make( majorVersion, minorVersion );\n\t\t}\n\t\treturn info.makeCopyOrDefault( MINIMUM_VERSION );\n\t}",
        "diffSourceCode": "-  181: \tprivate static DatabaseVersion determineDatabaseVersion(DialectResolutionInfo info) {\n-  182: \t\tfinal Integer compatibilityLevel = getCompatibilityLevel( info );\n-  183: \t\tif ( compatibilityLevel != null ) {\n-  184: \t\t\tfinal int majorVersion = compatibilityLevel / 10;\n-  185: \t\t\tfinal int minorVersion = compatibilityLevel % 10;\n-  186: \t\t\treturn DatabaseVersion.make( majorVersion, minorVersion );\n-  187: \t\t}\n-  188: \t\treturn info.makeCopyOrDefault( MINIMUM_VERSION );\n-  189: \t}\n-  190: \n-  191: \tprivate static Integer getCompatibilityLevel(DialectResolutionInfo info) {\n-  192: \t\tfinal DatabaseMetaData databaseMetaData = info.getDatabaseMetadata();\n-  193: \t\tif ( databaseMetaData != null ) {\n-  194: \t\t\ttry ( java.sql.Statement statement = databaseMetaData.getConnection().createStatement() ) {\n-  195: \t\t\t\tfinal ResultSet rs = statement.executeQuery( \"SELECT compatibility_level FROM sys.databases where name = db_name();\" );\n+  181: \t@Override\n+  182: \tpublic DatabaseVersion determineDatabaseVersion(DialectResolutionInfo info) {\n+  183: \t\treturn staticDetermineDatabaseVersion(info);\n+  184: \t}\n+  185: \n+  186: \t// Static version necessary to call from constructor\n+  187: \tprivate static DatabaseVersion staticDetermineDatabaseVersion(DialectResolutionInfo info) {\n+  188: \t\tfinal Integer compatibilityLevel = getCompatibilityLevel( info );\n+  189: \t\tif ( compatibilityLevel != null ) {\n+  190: \t\t\tfinal int majorVersion = compatibilityLevel / 10;\n+  191: \t\t\tfinal int minorVersion = compatibilityLevel % 10;\n+  192: \t\t\treturn DatabaseVersion.make( majorVersion, minorVersion );\n+  193: \t\t}\n+  194: \t\treturn info.makeCopyOrDefault( MINIMUM_VERSION );\n+  195: \t}\n",
        "uniqueId": "4b33d0d067010d484702d6ee910aaa3b4584c69b_181_189_187_195_181_184",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 17,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 16,
                "covered": 9
            },
            "BRANCH": {
                "missed": 1,
                "covered": 1
            },
            "LINE": {
                "missed": 3,
                "covered": 3
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": true,
        "refactoredCode": "##########################\nprivate static DatabaseVersion determineDatabaseVersion(DialectResolutionInfo info) {\n    final Integer compatibilityLevel = getCompatibilityLevel(info);\n    if (compatibilityLevel != null) {\n        final int majorVersion = compatibilityLevel / 10;\n        final int minorVersion = compatibilityLevel % 10;\n        return DatabaseVersion.make(majorVersion, minorVersion);\n    }\n    return info.makeCopyOrDefault(MINIMUM_VERSION);\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprivate static DatabaseVersion determineDatabaseVersion(DialectResolutionInfo info) {\n\t\tfinal Integer compatibilityLevel = getCompatibilityLevel( info );\n\t\tif ( compatibilityLevel != null ) {\n\t\t\tfinal int majorVersion = compatibilityLevel / 10;\n\t\t\tfinal int minorVersion = compatibilityLevel % 10;\n\t\t\treturn DatabaseVersion.make( majorVersion, minorVersion );\n\t\t}\n\t\treturn info.makeCopyOrDefault( MINIMUM_VERSION );\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.dialect;\n\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Types;\nimport java.time.temporal.ChronoField;\nimport java.time.temporal.TemporalAccessor;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.TimeZone;\n\nimport org.hibernate.Length;\nimport org.hibernate.LockMode;\nimport org.hibernate.LockOptions;\nimport org.hibernate.QueryTimeoutException;\nimport org.hibernate.boot.Metadata;\nimport org.hibernate.boot.model.FunctionContributions;\nimport org.hibernate.boot.model.TypeContributions;\nimport org.hibernate.boot.model.relational.QualifiedSequenceName;\nimport org.hibernate.boot.model.relational.Sequence;\nimport org.hibernate.boot.model.relational.SqlStringGenerationContext;\nimport org.hibernate.dialect.function.CommonFunctionFactory;\nimport org.hibernate.dialect.function.CountFunction;\nimport org.hibernate.dialect.function.SQLServerFormatEmulation;\nimport org.hibernate.dialect.function.SqlServerConvertTruncFunction;\nimport org.hibernate.dialect.identity.IdentityColumnSupport;\nimport org.hibernate.dialect.identity.SQLServerIdentityColumnSupport;\nimport org.hibernate.dialect.pagination.LimitHandler;\nimport org.hibernate.dialect.pagination.SQLServer2012LimitHandler;\nimport org.hibernate.dialect.sequence.SQLServer16SequenceSupport;\nimport org.hibernate.dialect.sequence.SQLServerSequenceSupport;\nimport org.hibernate.dialect.sequence.SequenceSupport;\nimport org.hibernate.dialect.unique.AlterTableUniqueIndexDelegate;\nimport org.hibernate.dialect.unique.UniqueDelegate;\nimport org.hibernate.engine.jdbc.Size;\nimport org.hibernate.engine.jdbc.dialect.spi.BasicSQLExceptionConverter;\nimport org.hibernate.engine.jdbc.dialect.spi.DialectResolutionInfo;\nimport org.hibernate.engine.jdbc.env.spi.IdentifierCaseStrategy;\nimport org.hibernate.engine.jdbc.env.spi.IdentifierHelper;\nimport org.hibernate.engine.jdbc.env.spi.IdentifierHelperBuilder;\nimport org.hibernate.engine.jdbc.env.spi.NameQualifierSupport;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.exception.ConstraintViolationException;\nimport org.hibernate.exception.LockTimeoutException;\nimport org.hibernate.exception.spi.SQLExceptionConversionDelegate;\nimport org.hibernate.exception.spi.TemplatedViolatedConstraintNameExtractor;\nimport org.hibernate.exception.spi.ViolatedConstraintNameExtractor;\nimport org.hibernate.internal.util.JdbcExceptionHelper;\nimport org.hibernate.internal.util.config.ConfigurationHelper;\nimport org.hibernate.internal.util.StringHelper;\nimport org.hibernate.mapping.CheckConstraint;\nimport org.hibernate.mapping.Column;\nimport org.hibernate.persister.entity.mutation.EntityMutationTarget;\nimport org.hibernate.procedure.internal.SQLServerCallableStatementSupport;\nimport org.hibernate.procedure.spi.CallableStatementSupport;\nimport org.hibernate.query.sqm.CastType;\nimport org.hibernate.query.sqm.FetchClauseType;\nimport org.hibernate.query.sqm.IntervalType;\nimport org.hibernate.query.sqm.TemporalUnit;\nimport org.hibernate.query.sqm.TrimSpec;\nimport org.hibernate.service.ServiceRegistry;\nimport org.hibernate.sql.ast.SqlAstNodeRenderingMode;\nimport org.hibernate.sql.ast.SqlAstTranslator;\nimport org.hibernate.sql.ast.SqlAstTranslatorFactory;\nimport org.hibernate.sql.ast.spi.SqlAppender;\nimport org.hibernate.sql.ast.spi.StandardSqlAstTranslatorFactory;\nimport org.hibernate.sql.ast.tree.Statement;\nimport org.hibernate.sql.exec.spi.JdbcOperation;\nimport org.hibernate.sql.model.MutationOperation;\nimport org.hibernate.sql.model.internal.OptionalTableUpdate;\nimport org.hibernate.tool.schema.internal.StandardSequenceExporter;\nimport org.hibernate.tool.schema.spi.Exporter;\nimport org.hibernate.type.BasicType;\nimport org.hibernate.type.BasicTypeRegistry;\nimport org.hibernate.type.StandardBasicTypes;\nimport org.hibernate.type.descriptor.java.JavaType;\nimport org.hibernate.type.descriptor.jdbc.JdbcType;\nimport org.hibernate.type.descriptor.jdbc.TimestampUtcAsJdbcTimestampJdbcType;\nimport org.hibernate.type.descriptor.jdbc.TinyIntAsSmallIntJdbcType;\nimport org.hibernate.type.descriptor.jdbc.UUIDJdbcType;\nimport org.hibernate.type.descriptor.jdbc.XmlJdbcType;\nimport org.hibernate.type.descriptor.jdbc.spi.JdbcTypeRegistry;\nimport org.hibernate.type.descriptor.sql.internal.DdlTypeImpl;\nimport org.hibernate.type.descriptor.sql.spi.DdlTypeRegistry;\n\nimport jakarta.persistence.TemporalType;\n\nimport static org.hibernate.cfg.DialectSpecificSettings.SQL_SERVER_COMPATIBILITY_LEVEL;\nimport static org.hibernate.exception.spi.TemplatedViolatedConstraintNameExtractor.extractUsingTemplate;\nimport static org.hibernate.internal.util.JdbcExceptionHelper.extractErrorCode;\nimport static org.hibernate.internal.util.JdbcExceptionHelper.extractSqlState;\nimport static org.hibernate.internal.util.StringHelper.isNotEmpty;\nimport static org.hibernate.query.sqm.TemporalUnit.NANOSECOND;\nimport static org.hibernate.query.sqm.produce.function.FunctionParameterType.INTEGER;\nimport static org.hibernate.type.SqlTypes.BLOB;\nimport static org.hibernate.type.SqlTypes.CLOB;\nimport static org.hibernate.type.SqlTypes.DATE;\nimport static org.hibernate.type.SqlTypes.DOUBLE;\nimport static org.hibernate.type.SqlTypes.GEOGRAPHY;\nimport static org.hibernate.type.SqlTypes.GEOMETRY;\nimport static org.hibernate.type.SqlTypes.LONG32NVARCHAR;\nimport static org.hibernate.type.SqlTypes.LONG32VARBINARY;\nimport static org.hibernate.type.SqlTypes.LONG32VARCHAR;\nimport static org.hibernate.type.SqlTypes.NCLOB;\nimport static org.hibernate.type.SqlTypes.NVARCHAR;\nimport static org.hibernate.type.SqlTypes.OTHER;\nimport static org.hibernate.type.SqlTypes.SQLXML;\nimport static org.hibernate.type.SqlTypes.TIME;\nimport static org.hibernate.type.SqlTypes.TIMESTAMP;\nimport static org.hibernate.type.SqlTypes.TIMESTAMP_WITH_TIMEZONE;\nimport static org.hibernate.type.SqlTypes.TIME_WITH_TIMEZONE;\nimport static org.hibernate.type.SqlTypes.UUID;\nimport static org.hibernate.type.SqlTypes.VARBINARY;\nimport static org.hibernate.type.SqlTypes.VARCHAR;\nimport static org.hibernate.type.descriptor.DateTimeUtils.appendAsDate;\nimport static org.hibernate.type.descriptor.DateTimeUtils.appendAsTime;\nimport static org.hibernate.type.descriptor.DateTimeUtils.appendAsTimestampWithMicros;\nimport static org.hibernate.type.descriptor.DateTimeUtils.appendAsTimestampWithMillis;\n\n/**\n * A dialect for Microsoft SQL Server 2008 and above\n *\n * @author Gavin King\n */\npublic class SQLServerDialect extends AbstractTransactSQLDialect {\n\tprivate final static DatabaseVersion MINIMUM_VERSION = DatabaseVersion.make( 11, 0 );\n\n\t/**\n\t * NOTE : 2100 is the documented limit supposedly - but in my testing, sending\n\t * 2100 parameters fails saying it must be less than 2100.\n\t */\n\tprivate static final int PARAM_LIST_SIZE_LIMIT = 2048;\n\n\t// See microsoft.sql.Types.GEOMETRY\n\tprivate static final int GEOMETRY_TYPE_CODE = -157;\n\t// See microsoft.sql.Types.GEOGRAPHY\n\tprivate static final int GEOGRAPHY_TYPE_CODE = -158;\n\n\tprivate final StandardSequenceExporter exporter;\n\tprivate final UniqueDelegate uniqueDelegate = new AlterTableUniqueIndexDelegate(this);\n\n\tprivate final SizeStrategy sizeStrategy = new SizeStrategyImpl() {\n\t\t@Override\n\t\tpublic Size resolveSize(\n\t\t\t\tJdbcType jdbcType,\n\t\t\t\tJavaType<?> javaType,\n\t\t\t\tInteger precision,\n\t\t\t\tInteger scale,\n\t\t\t\tLong length) {\n\t\t\treturn switch ( jdbcType.getDdlTypeCode() ) {\n\t\t\t\tcase BLOB, CLOB, NCLOB ->\n\t\t\t\t\t\tsuper.resolveSize( jdbcType, javaType, precision, scale,\n\t\t\t\t\t\t\t\tlength == null ? getDefaultLobLength() : length );\n\t\t\t\tdefault -> super.resolveSize( jdbcType, javaType, precision, scale, length );\n\t\t\t};\n\t\t}\n\t};\n\n\tpublic SQLServerDialect() {\n\t\tthis( MINIMUM_VERSION );\n\t}\n\n\tpublic SQLServerDialect(DatabaseVersion version) {\n\t\tsuper(version);\n\t\texporter = createSequenceExporter(version);\n\t}\n\n\tpublic SQLServerDialect(DialectResolutionInfo info) {\n\t\tthis( determineDatabaseVersion( info ) );\n\t\tregisterKeywords( info );\n\t}\n\n\tprivate static DatabaseVersion determineDatabaseVersion(DialectResolutionInfo info) {\n\t\tfinal Integer compatibilityLevel = getCompatibilityLevel( info );\n\t\tif ( compatibilityLevel != null ) {\n\t\t\tfinal int majorVersion = compatibilityLevel / 10;\n\t\t\tfinal int minorVersion = compatibilityLevel % 10;\n\t\t\treturn DatabaseVersion.make( majorVersion, minorVersion );\n\t\t}\n\t\treturn info.makeCopyOrDefault( MINIMUM_VERSION );\n\t}\n\n\tprivate static Integer getCompatibilityLevel(DialectResolutionInfo info) {\n\t\tfinal DatabaseMetaData databaseMetaData = info.getDatabaseMetadata();\n\t\tif ( databaseMetaData != null ) {\n\t\t\ttry ( java.sql.Statement statement = databaseMetaData.getConnection().createStatement() ) {\n\t\t\t\tfinal ResultSet rs = statement.executeQuery( \"SELECT compatibility_level FROM sys.databases where name = db_name();\" );\n\t\t\t\tif ( rs.next() ) {\n\t\t\t\t\treturn rs.getInt( 1 );\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (SQLException e) {\n\t\t\t\tthrow BasicSQLExceptionConverter.INSTANCE.convert( e );\n\t\t\t}\n\t\t}\n\n\t\t// default to the dialect-specific configuration setting\n\t\treturn ConfigurationHelper.getInteger( SQL_SERVER_COMPATIBILITY_LEVEL, info.getConfigurationValues() );\n\t}\n\n\tprivate StandardSequenceExporter createSequenceExporter(DatabaseVersion version) {\n\t\treturn new SqlServerSequenceExporter(this);\n\t}\n\n\t@Override\n\tprotected DatabaseVersion getMinimumSupportedVersion() {\n\t\treturn MINIMUM_VERSION;\n\t}\n\n\t@Override\n\tprotected void registerDefaultKeywords() {\n\t\tsuper.registerDefaultKeywords();\n\t\tregisterKeyword( \"top\" );\n\t\tregisterKeyword( \"key\" );\n\t}\n\n\t@Override\n\tprotected String columnType(int sqlTypeCode) {\n\t\treturn switch (sqlTypeCode) {\n\t\t\t// there is no 'double' type in SQL server\n\t\t\t// but 'float' is double precision by default\n\t\t\tcase DOUBLE -> \"float\";\n\t\t\t// Prefer 'varchar(max)' and 'varbinary(max)' to\n\t\t\t// the deprecated TEXT and IMAGE types. Note that\n\t\t\t// the length of a VARCHAR or VARBINARY column must\n\t\t\t// be either between 1 and 8000 or exactly MAX, and\n\t\t\t// the length of an NVARCHAR column must be either\n\t\t\t// between 1 and 4000 or exactly MAX. (HHH-3965)\n\t\t\tcase CLOB -> \"varchar(max)\";\n\t\t\tcase NCLOB -> \"nvarchar(max)\";\n\t\t\tcase BLOB -> \"varbinary(max)\";\n\t\t\tcase DATE -> \"date\";\n\t\t\tcase TIME -> \"time\";\n\t\t\tcase TIMESTAMP -> \"datetime2($p)\";\n\t\t\tcase TIME_WITH_TIMEZONE, TIMESTAMP_WITH_TIMEZONE -> \"datetimeoffset($p)\";\n\t\t\tdefault -> super.columnType(sqlTypeCode);\n\t\t};\n\t}\n\n\t@Override\n\tprotected String castType(int sqlTypeCode) {\n\t\treturn switch (sqlTypeCode) {\n\t\t\tcase VARCHAR, LONG32VARCHAR, CLOB -> \"varchar(max)\";\n\t\t\tcase NVARCHAR, LONG32NVARCHAR, NCLOB -> \"nvarchar(max)\";\n\t\t\tcase VARBINARY, LONG32VARBINARY, BLOB -> \"varbinary(max)\";\n\t\t\tdefault -> super.castType( sqlTypeCode );\n\t\t};\n\t}\n\n\t@Override\n\tprotected void registerColumnTypes(TypeContributions typeContributions, ServiceRegistry serviceRegistry) {\n\t\tsuper.registerColumnTypes( typeContributions, serviceRegistry );\n\t\tfinal DdlTypeRegistry ddlTypeRegistry = typeContributions.getTypeConfiguration().getDdlTypeRegistry();\n\t\tddlTypeRegistry.addDescriptor( new DdlTypeImpl( GEOMETRY, \"geometry\", this ) );\n\t\tddlTypeRegistry.addDescriptor( new DdlTypeImpl( GEOGRAPHY, \"geography\", this ) );\n\t\tddlTypeRegistry.addDescriptor( new DdlTypeImpl( SQLXML, \"xml\", this ) );\n\t\tddlTypeRegistry.addDescriptor( new DdlTypeImpl( UUID, \"uniqueidentifier\", this ) );\n\t}\n\n\t@Override\n\tpublic JdbcType resolveSqlTypeDescriptor(\n\t\t\tString columnTypeName,\n\t\t\tint jdbcTypeCode,\n\t\t\tint precision,\n\t\t\tint scale,\n\t\t\tJdbcTypeRegistry jdbcTypeRegistry) {\n\t\tswitch ( jdbcTypeCode ) {\n\t\t\tcase OTHER:\n\t\t\t\tif ( columnTypeName.equals(\"uniqueidentifier\") ) {\n\t\t\t\t\tjdbcTypeCode = UUID;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GEOMETRY_TYPE_CODE:\n\t\t\t\tjdbcTypeCode = GEOMETRY;\n\t\t\t\tbreak;\n\t\t\tcase GEOGRAPHY_TYPE_CODE:\n\t\t\t\tjdbcTypeCode = GEOGRAPHY;\n\t\t\t\tbreak;\n\t\t}\n\t\treturn super.resolveSqlTypeDescriptor( columnTypeName, jdbcTypeCode, precision, scale, jdbcTypeRegistry );\n\t}\n\n\t@Override\n\tpublic int getMaxVarcharLength() {\n\t\treturn 8000;\n\t}\n\n\t@Override\n\tpublic int getMaxNVarcharLength() {\n\t\treturn 4000;\n\t}\n\n\t@Override\n\tpublic TimeZoneSupport getTimeZoneSupport() {\n\t\treturn TimeZoneSupport.NATIVE;\n\t}\n\n\t@Override\n\tpublic long getDefaultLobLength() {\n\t\t// this is essentially the only legal length for\n\t\t// a \"lob\" in SQL Server, i.e. the value of MAX\n\t\t// (caveat: for NVARCHAR it is half this value)\n\t\treturn Length.LONG32;\n\t}\n\n\t@Override\n\tpublic int getMaxIdentifierLength() {\n\t\treturn 128;\n\t}\n\n\t@Override\n\tpublic void contributeTypes(TypeContributions typeContributions, ServiceRegistry serviceRegistry) {\n\t\tsuper.contributeTypes( typeContributions, serviceRegistry );\n\n\t\t// Need to bind as java.sql.Timestamp because reading OffsetDateTime from a \"datetime2\" column fails\n\t\ttypeContributions.contributeJdbcType( TimestampUtcAsJdbcTimestampJdbcType.INSTANCE );\n\n\t\ttypeContributions.getTypeConfiguration().getJdbcTypeRegistry().addDescriptor(\n\t\t\t\tTypes.TINYINT,\n\t\t\t\tTinyIntAsSmallIntJdbcType.INSTANCE\n\t\t);\n\t\ttypeContributions.contributeJdbcType( XmlJdbcType.INSTANCE );\n\t\ttypeContributions.contributeJdbcType( UUIDJdbcType.INSTANCE );\n\t}\n\n\t@Override\n\tpublic void initializeFunctionRegistry(FunctionContributions functionContributions) {\n\t\tsuper.initializeFunctionRegistry(functionContributions);\n\n\t\tfinal BasicTypeRegistry basicTypeRegistry = functionContributions.getTypeConfiguration().getBasicTypeRegistry();\n\t\tBasicType<Date> dateType = basicTypeRegistry.resolve( StandardBasicTypes.DATE );\n\t\tBasicType<Date> timeType = basicTypeRegistry.resolve( StandardBasicTypes.TIME );\n\t\tBasicType<Date> timestampType = basicTypeRegistry.resolve( StandardBasicTypes.TIMESTAMP );\n\n\t\tCommonFunctionFactory functionFactory = new CommonFunctionFactory(functionContributions);\n\n\t\t// For SQL-Server we need to cast certain arguments to varchar(max) to be able to concat them\n\t\tfunctionContributions.getFunctionRegistry().register(\n\t\t\t\t\"count\",\n\t\t\t\tnew CountFunction(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\tfunctionContributions.getTypeConfiguration(),\n\t\t\t\t\t\tSqlAstNodeRenderingMode.DEFAULT,\n\t\t\t\t\t\t\"count_big\",\n\t\t\t\t\t\t\"+\",\n\t\t\t\t\t\t\"varchar(max)\",\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\"varbinary(max)\"\n\t\t\t\t)\n\t\t);\n\n\t\t// AVG by default uses the input type, so we possibly need to cast the argument type, hence a special function\n\t\tfunctionFactory.avg_castingNonDoubleArguments( this, SqlAstNodeRenderingMode.DEFAULT );\n\n\t\tfunctionFactory.log_log();\n\n\t\tfunctionFactory.round_round();\n\t\tfunctionFactory.everyAny_minMaxIif();\n\t\tfunctionFactory.octetLength_pattern( \"datalength(?1)\" );\n\t\tfunctionFactory.bitLength_pattern( \"datalength(?1)*8\" );\n\n\t\tfunctionFactory.locate_charindex();\n\t\tfunctionFactory.stddevPopSamp_stdevp();\n\t\tfunctionFactory.varPopSamp_varp();\n\n\t\tfunctionContributions.getFunctionRegistry().register(\n\t\t\t\t\"format\",\n\t\t\t\tnew SQLServerFormatEmulation( functionContributions.getTypeConfiguration() )\n\t\t);\n\n\t\t//actually translate() was added in 2017 but\n\t\t//it's not worth adding a new dialect for that!\n\t\tfunctionFactory.translate();\n\n\t\tfunctionFactory.median_percentileCont( true );\n\n\t\tfunctionContributions.getFunctionRegistry().namedDescriptorBuilder( \"datefromparts\" )\n\t\t\t\t.setInvariantType( dateType )\n\t\t\t\t.setExactArgumentCount( 3 )\n\t\t\t\t.setParameterTypes(INTEGER)\n\t\t\t\t.register();\n\t\tfunctionContributions.getFunctionRegistry().namedDescriptorBuilder( \"timefromparts\" )\n\t\t\t\t.setInvariantType( timeType )\n\t\t\t\t.setExactArgumentCount( 5 )\n\t\t\t\t.setParameterTypes(INTEGER)\n\t\t\t\t.register();\n\t\tfunctionContributions.getFunctionRegistry().namedDescriptorBuilder( \"smalldatetimefromparts\" )\n\t\t\t\t.setInvariantType( timestampType )\n\t\t\t\t.setExactArgumentCount( 5 )\n\t\t\t\t.setParameterTypes(INTEGER)\n\t\t\t\t.register();\n\t\tfunctionContributions.getFunctionRegistry().namedDescriptorBuilder( \"datetimefromparts\" )\n\t\t\t\t.setInvariantType( timestampType )\n\t\t\t\t.setExactArgumentCount( 7 )\n\t\t\t\t.setParameterTypes(INTEGER)\n\t\t\t\t.register();\n\t\tfunctionContributions.getFunctionRegistry().namedDescriptorBuilder( \"datetime2fromparts\" )\n\t\t\t\t.setInvariantType( timestampType )\n\t\t\t\t.setExactArgumentCount( 8 )\n\t\t\t\t.setParameterTypes(INTEGER)\n\t\t\t\t.register();\n\t\tfunctionContributions.getFunctionRegistry().namedDescriptorBuilder( \"datetimeoffsetfromparts\" )\n\t\t\t\t.setInvariantType( timestampType )\n\t\t\t\t.setExactArgumentCount( 10 )\n\t\t\t\t.setParameterTypes(INTEGER)\n\t\t\t\t.register();\n\n\t\tfunctionFactory.windowFunctions();\n\t\tfunctionFactory.inverseDistributionOrderedSetAggregates_windowEmulation();\n\t\tfunctionFactory.hypotheticalOrderedSetAggregates_windowEmulation();\n\t\tif ( getVersion().isSameOrAfter( 14 ) ) {\n\t\t\tfunctionFactory.listagg_stringAggWithinGroup( \"varchar(max)\" );\n\t\t}\n\t\tif ( getVersion().isSameOrAfter( 16 ) ) {\n\t\t\tfunctionFactory.leastGreatest();\n\t\t\tfunctionFactory.dateTrunc_datetrunc();\n\t\t\tfunctionFactory.trunc_round_datetrunc();\n\t\t}\n\t\telse {\n\t\t\tfunctionContributions.getFunctionRegistry().register(\n\t\t\t\t\t\"trunc\",\n\t\t\t\t\tnew SqlServerConvertTruncFunction( functionContributions.getTypeConfiguration() )\n\t\t\t);\n\t\t\tfunctionContributions.getFunctionRegistry().registerAlternateKey( \"truncate\", \"trunc\" );\n\t\t}\n\t}\n\n\t@Override\n\tpublic String trimPattern(TrimSpec specification, boolean isWhitespace) {\n\t\tif ( getVersion().isSameOrAfter( 16 ) ) {\n\t\t\treturn switch (specification) {\n\t\t\t\tcase BOTH -> isWhitespace ? \"trim(?1)\" : \"trim(?2 from ?1)\";\n\t\t\t\tcase LEADING -> isWhitespace ? \"ltrim(?1)\" : \"ltrim(?1,?2)\";\n\t\t\t\tcase TRAILING -> isWhitespace ? \"rtrim(?1)\" : \"rtrim(?1,?2)\";\n\t\t\t};\n\t\t}\n\t\treturn super.trimPattern( specification, isWhitespace );\n\t}\n\n\t@Override\n\tpublic SqlAstTranslatorFactory getSqlAstTranslatorFactory() {\n\t\treturn new StandardSqlAstTranslatorFactory() {\n\t\t\t@Override\n\t\t\tprotected <T extends JdbcOperation> SqlAstTranslator<T> buildTranslator(\n\t\t\t\t\tSessionFactoryImplementor sessionFactory, Statement statement) {\n\t\t\t\treturn new SQLServerSqlAstTranslator<>( sessionFactory, statement );\n\t\t\t}\n\t\t};\n\t}\n\n\t@Override\n\tpublic SizeStrategy getSizeStrategy() {\n\t\treturn sizeStrategy;\n\t}\n\n\t@Override\n\tpublic String castPattern(CastType from, CastType to) {\n\t\tif ( to == CastType.STRING ) {\n\t\t\tswitch ( from ) {\n\t\t\t\tcase TIMESTAMP:\n\t\t\t\t\t// SQL Server uses yyyy-MM-dd HH:mm:ss.nnnnnnn by default when doing a cast, but only need second precision\n\t\t\t\t\treturn \"format(?1,'yyyy-MM-dd HH:mm:ss')\";\n\t\t\t\tcase TIME:\n\t\t\t\t\t// SQL Server uses HH:mm:ss.nnnnnnn by default when doing a cast, but only need second precision\n\t\t\t\t\t// SQL Server requires quoting of ':' in time formats and the use of 'hh' instead of 'HH'\n\t\t\t\t\treturn \"format(?1,'hh\\\\:mm\\\\:ss')\";\n\t\t\t}\n\t\t}\n\t\treturn super.castPattern( from, to );\n\t}\n\n\t@Override\n\tpublic String currentTimestamp() {\n\t\treturn \"sysdatetime()\";\n\t}\n\n\t@Override\n\tpublic IdentifierHelper buildIdentifierHelper(IdentifierHelperBuilder builder, DatabaseMetaData dbMetaData)\n\t\t\tthrows SQLException {\n\n\t\tif ( dbMetaData == null ) {\n\t\t\t// TODO: if DatabaseMetaData != null, unquoted case strategy is set to IdentifierCaseStrategy.UPPER\n\t\t\t//       Check to see if this setting is correct.\n\t\t\tbuilder.setUnquotedCaseStrategy( IdentifierCaseStrategy.MIXED );\n\t\t\tbuilder.setQuotedCaseStrategy( IdentifierCaseStrategy.MIXED );\n\t\t}\n\n\t\treturn super.buildIdentifierHelper( builder, dbMetaData );\n\t}\n\n\t@Override\n\tpublic String currentTime() {\n\t\treturn \"convert(time,getdate())\";\n\t}\n\n\t@Override\n\tpublic String currentDate() {\n\t\treturn \"convert(date,getdate())\";\n\t}\n\n\t@Override\n\tpublic String currentTimestampWithTimeZone() {\n\t\treturn \"sysdatetimeoffset()\";\n\t}\n\n\t@Override\n\tpublic String getNoColumnsInsertString() {\n\t\treturn \"default values\";\n\t}\n\n\t@Override\n\tpublic LimitHandler getLimitHandler() {\n\t\treturn SQLServer2012LimitHandler.INSTANCE;\n\t}\n\n\t@Override\n\tpublic boolean supportsValuesList() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsDistinctFromPredicate() {\n\t\treturn getVersion().isSameOrAfter( 16 );\n\t}\n\n\t@Override\n\tpublic char closeQuote() {\n\t\treturn ']';\n\t}\n\n\t@Override\n\tpublic String getCurrentSchemaCommand() {\n\t\treturn \"select schema_name()\";\n\t}\n\n\t@Override\n\tpublic boolean supportsIfExistsBeforeTableName() {\n\t\treturn getVersion().isSameOrAfter( 16 ) || super.supportsIfExistsBeforeTableName();\n\t}\n\n\t@Override\n\tpublic boolean supportsIfExistsBeforeConstraintName() {\n\t\treturn getVersion().isSameOrAfter( 16 ) || super.supportsIfExistsBeforeConstraintName();\n\t}\n\n\t@Override\n\tpublic char openQuote() {\n\t\treturn '[';\n\t}\n\n\t@Override\n\tpublic String appendLockHint(LockOptions lockOptions, String tableName) {\n\t\tLockMode lockMode = lockOptions.getAliasSpecificLockMode( tableName );\n\t\tif ( lockMode == null ) {\n\t\t\tlockMode = lockOptions.getLockMode();\n\t\t}\n\n\t\tfinal String writeLockStr = lockOptions.getTimeOut() == LockOptions.SKIP_LOCKED ? \"updlock\" : \"updlock,holdlock\";\n\t\tfinal String readLockStr = lockOptions.getTimeOut() == LockOptions.SKIP_LOCKED ? \"updlock\" : \"holdlock\";\n\n\t\tfinal String noWaitStr = lockOptions.getTimeOut() == LockOptions.NO_WAIT ? \",nowait\" : \"\";\n\t\tfinal String skipLockStr = lockOptions.getTimeOut() == LockOptions.SKIP_LOCKED ? \",readpast\" : \"\";\n\n\t\treturn switch (lockMode) {\n\t\t\tcase PESSIMISTIC_WRITE, WRITE ->\n\t\t\t\t\ttableName + \" with (\" + writeLockStr + \",rowlock\" + noWaitStr + skipLockStr + \")\";\n\t\t\tcase PESSIMISTIC_READ -> tableName + \" with (\" + readLockStr + \",rowlock\" + noWaitStr + skipLockStr + \")\";\n\t\t\tcase UPGRADE_SKIPLOCKED -> tableName + \" with (updlock,rowlock,readpast\" + noWaitStr + \")\";\n\t\t\tcase UPGRADE_NOWAIT -> tableName + \" with (updlock,holdlock,rowlock,nowait)\";\n\t\t\tdefault -> tableName;\n\t\t};\n\t}\n\n\n\t/**\n\t * The current_timestamp is more accurate, but only known to be supported in SQL Server 7.0 and later and\n\t * Sybase not known to support it at all\n\t * <p>\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic String getCurrentTimestampSelectString() {\n\t\treturn \"select current_timestamp\";\n\t}\n\n\t// Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\t@Override\n\tpublic boolean supportsResultSetPositionQueryMethodsOnForwardOnlyCursor() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean supportsCircularCascadeDeleteConstraints() {\n\t\t// SQL Server (at least up through 2005) does not support defining\n\t\t// cascade delete constraints which can circle back to the mutating\n\t\t// table\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean supportsLobValueChangePropagation() {\n\t\t// note: at least my local SQL Server 2005 Express shows this not working...\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean doesReadCommittedCauseWritersToBlockReaders() {\n\t\t// here assume SQLServer2005 using snapshot isolation, which does not have this problem\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean doesRepeatableReadCauseReadersToBlockWriters() {\n\t\t// here assume SQLServer2005 using snapshot isolation, which does not have this problem\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic int getInExpressionCountLimit() {\n\t\treturn PARAM_LIST_SIZE_LIMIT;\n\t}\n\n\t@Override\n\tpublic IdentityColumnSupport getIdentityColumnSupport() {\n\t\treturn SQLServerIdentityColumnSupport.INSTANCE;\n\t}\n\n\t@Override\n\tpublic boolean supportsNonQueryWithCTE() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsSkipLocked() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsNoWait() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsWait() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic SequenceSupport getSequenceSupport() {\n\t\treturn getVersion().isSameOrAfter( 16 )\n\t\t\t\t? SQLServer16SequenceSupport.INSTANCE\n\t\t\t\t: SQLServerSequenceSupport.INSTANCE;\n\t}\n\n\t@Override\n\tpublic String getQuerySequencesString() {\n\t\t// The upper-case name should work on both case-sensitive and case-insensitive collations.\n\t\treturn \"select * from INFORMATION_SCHEMA.SEQUENCES\";\n\t}\n\n\t@Override\n\tpublic String getQueryHintString(String sql, String hints) {\n\t\tfinal StringBuilder buffer =\n\t\t\t\tnew StringBuilder( sql.length() + hints.length() + 12 );\n\t\tfinal int pos = sql.indexOf( ';' );\n\t\tif ( pos > -1 ) {\n\t\t\tbuffer.append( sql, 0, pos );\n\t\t}\n\t\telse {\n\t\t\tbuffer.append( sql );\n\t\t}\n\t\tbuffer.append( \" OPTION (\" ).append( hints ).append( \")\" );\n\t\tif ( pos > -1 ) {\n\t\t\tbuffer.append( \";\" );\n\t\t}\n\t\tsql = buffer.toString();\n\t\treturn sql;\n\t}\n\n\t@Override\n\tpublic boolean supportsNullPrecedence() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean supportsOffsetInSubquery() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsWindowFunctions() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsLateral() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsRecursiveCTE() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean supportsFetchClause(FetchClauseType type) {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic ViolatedConstraintNameExtractor getViolatedConstraintNameExtractor() {\n\t\treturn new TemplatedViolatedConstraintNameExtractor(\n\t\t\t\tsqle -> {\n\t\t\t\t\tswitch ( extractErrorCode( sqle ) ) {\n\t\t\t\t\t\tcase 2627:\n\t\t\t\t\t\tcase 2601:\n\t\t\t\t\t\t\tString message = sqle.getMessage();\n\t\t\t\t\t\t\tif ( message.contains(\"unique index \") ) {\n\t\t\t\t\t\t\t\treturn extractUsingTemplate( \"unique index '\", \"'\", message);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\treturn extractUsingTemplate( \"'\", \"'\", message);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t}\n\n\t@Override\n\tpublic SQLExceptionConversionDelegate buildSQLExceptionConversionDelegate() {\n\t\treturn (sqlException, message, sql) -> {\n\t\t\tfinal String sqlState = extractSqlState( sqlException );\n\t\t\tif ( \"HY008\".equals( sqlState ) ) {\n\t\t\t\treturn new QueryTimeoutException( message, sqlException, sql );\n\t\t\t}\n\n\t\t\treturn switch ( extractErrorCode( sqlException ) ) {\n\t\t\t\tcase 1222 -> new LockTimeoutException( message, sqlException, sql );\n\t\t\t\tcase 2627, 2601 -> new ConstraintViolationException(\n\t\t\t\t\t\tmessage,\n\t\t\t\t\t\tsqlException,\n\t\t\t\t\t\tsql,\n\t\t\t\t\t\tConstraintViolationException.ConstraintKind.UNIQUE,\n\t\t\t\t\t\tgetViolatedConstraintNameExtractor().extractConstraintName( sqlException )\n\t\t\t\t);\n\t\t\t\tdefault -> null;\n\t\t\t};\n\t\t};\n\t}\n\n\t@Override\n\tpublic int getDefaultTimestampPrecision() {\n\t\treturn 7;\n\t}\n\n\t/**\n\t * Even though SQL Server only supports 1/10th microsecond precision,\n\t * we use nanosecond as the \"native\" precision for datetime arithmetic\n\t * since it simplifies calculations.\n\t */\n\t@Override\n\tpublic long getFractionalSecondPrecisionInNanos() {\n//\t\treturn 100; // 1/10th microsecond\n\t\treturn 1;\n\t}\n\n\t@Override\n\tpublic String extractPattern(TemporalUnit unit) {\n\t\treturn switch (unit) {\n\t\t\tcase TIMEZONE_HOUR -> \"(datepart(tz,?2)/60)\";\n\t\t\tcase TIMEZONE_MINUTE -> \"(datepart(tz,?2)%60)\";\n\t\t\t// currently Dialect.extract() doesn't need\n\t\t\t// to handle NANOSECOND (might change that?)\n//\t\t\tcase NANOSECOND ->\n//\t\t\t\t// this should evaluate to a bigint type\n//\t\t\t\t\t\"(datepart(second,?2)*1000000000+datepart(nanosecond,?2))\";\n\t\t\tcase SECOND ->\n\t\t\t\t//this should evaluate to a floating point type\n\t\t\t\t\t\"(datepart(second,?2)+datepart(nanosecond,?2)/1000000000)\";\n\t\t\tcase EPOCH -> \"datediff_big(second, '1970-01-01', ?2)\";\n\t\t\tdefault -> \"datepart(?1,?2)\";\n\t\t};\n\t}\n\n\t@Override @SuppressWarnings(\"deprecation\")\n\tpublic String timestampaddPattern(TemporalUnit unit, TemporalType temporalType, IntervalType intervalType) {\n\t\t// dateadd() supports only especially small magnitudes\n\t\t// since it casts its argument to int (and unfortunately\n\t\t// there's no dateadd_big()) so here we need to use two\n\t\t// calls to dateadd() to add a whole duration\n\t\treturn switch (unit) { //use nanosecond as the \"native\" precision\n\t\t\tcase NANOSECOND, NATIVE -> \"dateadd(nanosecond,?2%1000000000,dateadd(second,?2/1000000000,?3))\";\n\t\t\t// we could, in principle, use 1/10th microsecond as the \"native\" precision\n//\t\t\tcase NATIVE -> \"dateadd(nanosecond,?2%10000000,dateadd(second,?2/10000000,?3))\";\n\t\t\tcase SECOND -> \"dateadd(nanosecond,cast(?2*1e9 as bigint)%1000000000,dateadd(second,?2,?3))\";\n\t\t\tdefault -> \"dateadd(?1,?2,?3)\";\n\t\t};\n\t}\n\n\t@Override @SuppressWarnings(\"deprecation\")\n\tpublic String timestampdiffPattern(TemporalUnit unit, TemporalType fromTemporalType, TemporalType toTemporalType) {\n\t\tif ( unit == TemporalUnit.NATIVE ) {\n\t\t\t//use nanosecond as the \"native\" precision\n\t\t\treturn \"datediff_big(nanosecond,?2,?3)\";\n\t\t}\n\t\telse {\n\t\t\t//datediff() returns an int, and can easily\n\t\t\t//overflow when dealing with \"physical\"\n\t\t\t//durations, so use datediff_big()\n\t\t\treturn unit.normalized() == NANOSECOND\n\t\t\t\t\t? \"datediff_big(?1,?2,?3)\"\n\t\t\t\t\t: \"datediff(?1,?2,?3)\";\n\t\t}\n\t}\n\n\t@Override\n\tpublic String translateDurationField(TemporalUnit unit) {\n\t\t//use nanosecond as the \"native\" precision\n\t\treturn unit == TemporalUnit.NATIVE\n\t\t\t\t? \"nanosecond\"\n\t\t\t\t: super.translateDurationField( unit );\n\t}\n\n\t@Override\n\tpublic String translateExtractField(TemporalUnit unit) {\n\t\treturn switch (unit) {\n\t\t\t//the ISO week number (behavior of \"week\" depends on a system property)\n\t\t\tcase WEEK -> \"isowk\";\n\t\t\tcase OFFSET -> \"tz\";\n\t\t\tdefault -> super.translateExtractField( unit );\n\t\t};\n\t}\n\n\t@Override\n\tpublic void appendDatetimeFormat(SqlAppender appender, String format) {\n\t\tappender.appendSql( datetimeFormat(format).result() );\n\t}\n\n\tpublic static Replacer datetimeFormat(String format) {\n\t\treturn new Replacer( format, \"'\", \"\\\"\" )\n\t\t\t\t//era\n\t\t\t\t.replace(\"G\", \"g\")\n\n\t\t\t\t//y nothing to do\n\t\t\t\t//M nothing to do\n\n\t\t\t\t//w no equivalent\n\t\t\t\t//W no equivalent\n\t\t\t\t//Y no equivalent\n\n\t\t\t\t//day of week\n\t\t\t\t.replace(\"EEEE\", \"dddd\")\n\t\t\t\t.replace(\"EEE\", \"ddd\")\n\t\t\t\t//e no equivalent\n\n\t\t\t\t//d nothing to do\n\t\t\t\t//D no equivalent\n\n\t\t\t\t//am pm\n\t\t\t\t.replace(\"a\", \"tt\")\n\n\t\t\t\t//h nothing to do\n\t\t\t\t//H nothing to do\n\n\t\t\t\t//m nothing to do\n\t\t\t\t//s nothing to do\n\n\t\t\t\t//fractional seconds\n\t\t\t\t.replace(\"S\", \"F\")\n\n\t\t\t\t//timezones\n\t\t\t\t.replace(\"XXX\", \"K\") //UTC represented as \"Z\"\n\t\t\t\t.replace(\"xxx\", \"zzz\")\n\t\t\t\t.replace(\"x\", \"zz\");\n\t}\n\n\t@Override\n\tpublic void appendUUIDLiteral(SqlAppender appender, java.util.UUID literal) {\n\t\tappender.appendSql( \"cast('\" );\n\t\tappender.appendSql( literal.toString() );\n\t\tappender.appendSql( \"' as uniqueidentifier)\" );\n\t}\n\n\t@Override\n\tpublic void appendDateTimeLiteral(\n\t\t\tSqlAppender appender,\n\t\t\tTemporalAccessor temporalAccessor,\n\t\t\t@SuppressWarnings(\"deprecation\")\n\t\t\tTemporalType precision,\n\t\t\tTimeZone jdbcTimeZone) {\n\t\tswitch ( precision ) {\n\t\t\tcase DATE:\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsDate( appender, temporalAccessor );\n\t\t\t\tappender.appendSql( \"' as date)\" );\n\t\t\t\tbreak;\n\t\t\tcase TIME:\n\t\t\t\t//needed because the {t ... } JDBC is just buggy\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsTime( appender, temporalAccessor, supportsTemporalLiteralOffset(), jdbcTimeZone );\n\t\t\t\tappender.appendSql( \"' as time)\" );\n\t\t\t\tbreak;\n\t\t\tcase TIMESTAMP:\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\t//needed because the {ts ... } JDBC escape chokes on microseconds\n\t\t\t\tif ( supportsTemporalLiteralOffset() && temporalAccessor.isSupported( ChronoField.OFFSET_SECONDS ) ) {\n\t\t\t\t\tappendAsTimestampWithMicros( appender, temporalAccessor, true, jdbcTimeZone );\n\t\t\t\t\tappender.appendSql( \"' as datetimeoffset)\" );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tappendAsTimestampWithMicros( appender, temporalAccessor, false, jdbcTimeZone );\n\t\t\t\t\tappender.appendSql( \"' as datetime2)\" );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void appendDateTimeLiteral(\n\t\t\tSqlAppender appender,\n\t\t\tDate date,\n\t\t\t@SuppressWarnings(\"deprecation\")\n\t\t\tTemporalType precision,\n\t\t\tTimeZone jdbcTimeZone) {\n\t\tswitch ( precision ) {\n\t\t\tcase DATE:\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsDate( appender, date );\n\t\t\t\tappender.appendSql( \"' as date)\" );\n\t\t\t\tbreak;\n\t\t\tcase TIME:\n\t\t\t\t//needed because the {t ... } JDBC is just buggy\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsTime( appender, date );\n\t\t\t\tappender.appendSql( \"' as time)\" );\n\t\t\t\tbreak;\n\t\t\tcase TIMESTAMP:\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsTimestampWithMicros( appender, date, jdbcTimeZone );\n\t\t\t\tappender.appendSql( \"' as datetimeoffset)\" );\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void appendDateTimeLiteral(\n\t\t\tSqlAppender appender,\n\t\t\tCalendar calendar,\n\t\t\t@SuppressWarnings(\"deprecation\")\n\t\t\tTemporalType precision,\n\t\t\tTimeZone jdbcTimeZone) {\n\t\tswitch ( precision ) {\n\t\t\tcase DATE:\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsDate( appender, calendar );\n\t\t\t\tappender.appendSql( \"' as date)\" );\n\t\t\t\tbreak;\n\t\t\tcase TIME:\n\t\t\t\t//needed because the {t ... } JDBC is just buggy\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsTime( appender, calendar );\n\t\t\t\tappender.appendSql( \"' as time)\" );\n\t\t\t\tbreak;\n\t\t\tcase TIMESTAMP:\n\t\t\t\tappender.appendSql( \"cast('\" );\n\t\t\t\tappendAsTimestampWithMillis( appender, calendar, jdbcTimeZone );\n\t\t\t\tappender.appendSql( \"' as datetime2)\" );\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getCreateTemporaryTableColumnAnnotation(int sqlTypeCode) {\n\t\treturn switch (sqlTypeCode) {\n\t\t\tcase Types.CHAR, Types.NCHAR, Types.VARCHAR, Types.NVARCHAR, Types.LONGVARCHAR, Types.LONGNVARCHAR ->\n\t\t\t\t\t\"collate database_default\";\n\t\t\tdefault -> \"\";\n\t\t};\n\t}\n\n\t@Override\n\tpublic String[] getDropSchemaCommand(String schemaName) {\n\t\treturn getVersion().isSameOrAfter( 13 )\n\t\t\t\t? new String[] { \"drop schema if exists \" + schemaName }\n\t\t\t\t: super.getDropSchemaCommand( schemaName );\n\t}\n\n\t@Override\n\tpublic String getCreateIndexString(boolean unique) {\n\t\t// we only create unique indexes, as opposed to unique constraints,\n\t\t// when the column is nullable, so safe to infer unique => nullable\n\t\treturn unique ? \"create unique nonclustered index\" : \"create index\";\n\t}\n\n\t@Override\n\tpublic String getCreateIndexTail(boolean unique, List<Column> columns) {\n\t\tif ( unique ) {\n\t\t\tfinal StringBuilder tail = new StringBuilder();\n\t\t\tfor ( Column column : columns ) {\n\t\t\t\tif ( column.isNullable() ) {\n\t\t\t\t\ttail.append( tail.isEmpty() ? \" where \" : \" and \" )\n\t\t\t\t\t\t\t.append( column.getQuotedName( this ) )\n\t\t\t\t\t\t\t.append( \" is not null\" );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tail.toString();\n\t\t}\n\t\telse {\n\t\t\treturn \"\";\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getAlterColumnTypeString(String columnName, String columnType, String columnDefinition) {\n\t\treturn \"alter column \" + columnName + \" \" + columnType;\n\t}\n\n\t@Override\n\tpublic boolean supportsAlterColumnType() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic NameQualifierSupport getNameQualifierSupport() {\n\t\treturn NameQualifierSupport.BOTH;\n\t}\n\n\t@Override\n\tpublic UniqueDelegate getUniqueDelegate() {\n\t\treturn uniqueDelegate;\n\t}\n\n\t@Override\n\tpublic Exporter<Sequence> getSequenceExporter() {\n\t\treturn exporter == null ? super.getSequenceExporter() : exporter;\n\t}\n\n\tprivate static class SqlServerSequenceExporter extends StandardSequenceExporter {\n\n\t\tpublic SqlServerSequenceExporter(Dialect dialect) {\n\t\t\tsuper( dialect );\n\t\t}\n\n\t\t@Override\n\t\tprotected String getFormattedSequenceName(QualifiedSequenceName name, Metadata metadata,\n\t\t\t\tSqlStringGenerationContext context) {\n\t\t\t// SQL Server does not allow the catalog in the sequence name.\n\t\t\t// See https://docs.microsoft.com/en-us/sql/t-sql/statements/create-sequence-transact-sql?view=sql-server-ver15&viewFallbackFrom=sql-server-ver12\n\t\t\t// Keeping the catalog in the name does not break on ORM, but it fails using Vert.X for Reactive.\n\t\t\treturn context.formatWithoutCatalog( name );\n\t\t}\n\t}\n\n\t@Override\n\tpublic String generatedAs(String generatedAs) {\n\t\treturn \" as (\" + generatedAs + \") persisted\";\n\t}\n\n\t@Override\n\tpublic boolean hasDataTypeBeforeGeneratedAs() {\n\t\treturn false;\n\t}\n\n\t// disabled foreign key constraints still prevent 'truncate table'\n\t// (these would help if we used 'delete' instead of 'truncate')\n\n//\t@Override\n//\tpublic String getDisableConstraintStatement(String tableName, String name) {\n//\t\treturn \"alter table \" + tableName + \" nocheck constraint \" + name;\n//\t}\n//\n//\t@Override\n//\tpublic String getEnableConstraintStatement(String tableName, String name) {\n//\t\treturn \"alter table \" + tableName + \" with check check constraint \" + name;\n//\t}\n\n\n\t@Override\n\tpublic MutationOperation createOptionalTableUpdateOperation(\n\t\t\tEntityMutationTarget mutationTarget,\n\t\t\tOptionalTableUpdate optionalTableUpdate,\n\t\t\tSessionFactoryImplementor factory) {\n\t\tfinal SQLServerSqlAstTranslator<JdbcOperation> translator =\n\t\t\t\tnew SQLServerSqlAstTranslator<>( factory, optionalTableUpdate );\n\t\treturn translator.createMergeOperation( optionalTableUpdate );\n\t}\n\n\t@Override\n\tpublic DmlTargetColumnQualifierSupport getDmlTargetColumnQualifierSupport() {\n\t\treturn DmlTargetColumnQualifierSupport.TABLE_ALIAS;\n\t}\n\n\t@Override\n\tpublic boolean supportsFromClauseInUpdate() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic CallableStatementSupport getCallableStatementSupport() {\n\t\treturn SQLServerCallableStatementSupport.INSTANCE;\n\t}\n\n\t@Override\n\tpublic String getCheckConstraintString(CheckConstraint checkConstraint) {\n\t\tfinal String constraintName = checkConstraint.getName();\n\t\treturn constraintName == null\n\t\t\t\t? \" check \" + getCheckConstraintOptions( checkConstraint )\n\t\t\t\t\t\t+ \"(\" + checkConstraint.getConstraint() + \")\"\n\t\t\t\t: \" constraint \" + constraintName + \" check \" + getCheckConstraintOptions( checkConstraint )\n\t\t\t\t\t\t+ \"(\" + checkConstraint.getConstraint() + \")\";\n\t}\n\n\tprivate String getCheckConstraintOptions(CheckConstraint checkConstraint) {\n\t\treturn isNotEmpty( checkConstraint.getOptions() ) ? checkConstraint.getOptions() + \" \" : \"\";\n\t}\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate javaType(typeConfiguration TypeConfiguration, impliedJavaType java.lang.reflect.Type) : JavaType<Object> extracted from private determineReflectedJavaType() : JavaType<?> in class org.hibernate.mapping.BasicValue",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/mapping/BasicValue.java",
                "startLine": 731,
                "endLine": 792,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/mapping/BasicValue.java",
                "startLine": 745,
                "endLine": 755,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/mapping/BasicValue.java",
                "startLine": 773,
                "endLine": 776,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private JavaType<?> determineReflectedJavaType() {\n\t\tfinal java.lang.reflect.Type impliedJavaType;\n\n\t\tfinal TypeConfiguration typeConfiguration = getTypeConfiguration();\n\t\tif ( resolvedJavaType != null ) {\n\t\t\timpliedJavaType = resolvedJavaType;\n\t\t}\n\t\telse if ( implicitJavaTypeAccess != null ) {\n\t\t\timpliedJavaType = implicitJavaTypeAccess.apply( typeConfiguration );\n\t\t}\n\t\telse if ( ownerName != null && propertyName != null ) {\n\t\t\timpliedJavaType = ReflectHelper.reflectedPropertyType(\n\t\t\t\t\townerName,\n\t\t\t\t\tpropertyName,\n\t\t\t\t\tgetServiceRegistry().requireService( ClassLoaderService.class )\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\n\t\tresolvedJavaType = impliedJavaType;\n\n\t\tif ( impliedJavaType == null ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal JavaTypeRegistry javaTypeRegistry = typeConfiguration.getJavaTypeRegistry();\n\t\tfinal JavaType<Object> javaType = javaTypeRegistry.findDescriptor( impliedJavaType );\n\t\tfinal MutabilityPlan<Object> explicitMutabilityPlan = explicitMutabilityPlanAccess != null\n\t\t\t\t? explicitMutabilityPlanAccess.apply( typeConfiguration )\n\t\t\t\t: null;\n\t\tfinal MutabilityPlan<Object> determinedMutabilityPlan = explicitMutabilityPlan != null\n\t\t\t\t? explicitMutabilityPlan\n\t\t\t\t: RegistryHelper.INSTANCE.determineMutabilityPlan( impliedJavaType, typeConfiguration );\n\t\tif ( javaType == null ) {\n\t\t\tif ( jdbcTypeCode != null ) {\n\t\t\t\t// Construct special JavaType instances for JSON/XML types which can report recommended JDBC types\n\t\t\t\t// and implement toString/fromString as well as copying based on FormatMapper operations\n\t\t\t\tswitch ( jdbcTypeCode ) {\n\t\t\t\t\tcase SqlTypes.JSON:\n\t\t\t\t\t\tfinal JavaType<Object> jsonJavaType = new JsonJavaType<>(\n\t\t\t\t\t\t\t\timpliedJavaType,\n\t\t\t\t\t\t\t\tdeterminedMutabilityPlan,\n\t\t\t\t\t\t\t\ttypeConfiguration\n\t\t\t\t\t\t);\n\t\t\t\t\t\tjavaTypeRegistry.addDescriptor( jsonJavaType );\n\t\t\t\t\t\treturn jsonJavaType;\n\t\t\t\t\tcase SqlTypes.SQLXML:\n\t\t\t\t\t\tfinal JavaType<Object> xmlJavaType = new XmlJavaType<>(\n\t\t\t\t\t\t\t\timpliedJavaType,\n\t\t\t\t\t\t\t\tdeterminedMutabilityPlan,\n\t\t\t\t\t\t\t\ttypeConfiguration\n\t\t\t\t\t\t);\n\t\t\t\t\t\tjavaTypeRegistry.addDescriptor( xmlJavaType );\n\t\t\t\t\t\treturn xmlJavaType;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn javaTypeRegistry.resolveDescriptor( impliedJavaType );\n\t\t}\n\t\treturn javaType;\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/mapping/BasicValue.java",
        "isPureRefactoring": true,
        "commitId": "6c6c92e88d4535be020b4acb3d81f96df39a65d8",
        "packageNameBefore": "org.hibernate.mapping",
        "classNameBefore": "org.hibernate.mapping.BasicValue",
        "methodNameBefore": "org.hibernate.mapping.BasicValue#determineReflectedJavaType",
        "invokedMethod": "methodSignature: org.hibernate.type.spi.TypeConfiguration#getJavaTypeRegistry\n methodBody: public JavaTypeRegistry getJavaTypeRegistry() {\nreturn javaTypeRegistry;\n}\nmethodSignature: org.hibernate.type.spi.TypeConfiguration.Scope#getTypeConfiguration\n methodBody: public TypeConfiguration getTypeConfiguration() {\nreturn typeConfiguration;\n}\nmethodSignature: org.hibernate.type.spi.TypeConfiguration.Scope#getServiceRegistry\n methodBody: private ServiceRegistry getServiceRegistry() {\nif(metadataBuildingContext != null){return metadataBuildingContext.getBootstrapContext().getServiceRegistry();\n}if(sessionFactory != null){return sessionFactory.getServiceRegistry();\n}{return null;\n}}\nmethodSignature: org.hibernate.type.spi.TypeConfiguration#getServiceRegistry\n methodBody: public ServiceRegistry getServiceRegistry() {\nreturn scope.getServiceRegistry();\n}",
        "classSignatureBefore": "public class BasicValue extends SimpleValue implements JdbcTypeIndicators, Resolvable, JpaAttributeConverterCreationContext ",
        "methodNameBeforeSet": [
            "org.hibernate.mapping.BasicValue#determineReflectedJavaType"
        ],
        "classNameBeforeSet": [
            "org.hibernate.mapping.BasicValue"
        ],
        "classSignatureBeforeSet": [
            "public class BasicValue extends SimpleValue implements JdbcTypeIndicators, Resolvable, JpaAttributeConverterCreationContext "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Overlapped refactoring - can be identical by undoing the overlapped refactoring\n- Inline Variable- Severe changes",
                "description": "Return expression has been added within the Extract Method mechanics - with non-mapped leaves",
                "mappingState": 2
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.mapping;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\n\nimport org.hibernate.Incubating;\nimport org.hibernate.Internal;\nimport org.hibernate.MappingException;\nimport org.hibernate.TimeZoneStorageStrategy;\nimport org.hibernate.annotations.SoftDelete;\nimport org.hibernate.annotations.SoftDeleteType;\nimport org.hibernate.annotations.TimeZoneStorageType;\nimport org.hibernate.boot.model.TypeDefinition;\nimport org.hibernate.boot.model.convert.internal.AutoApplicableConverterDescriptorBypassedImpl;\nimport org.hibernate.boot.model.convert.internal.ClassBasedConverterDescriptor;\nimport org.hibernate.boot.model.convert.internal.InstanceBasedConverterDescriptor;\nimport org.hibernate.boot.model.convert.spi.AutoApplicableConverterDescriptor;\nimport org.hibernate.boot.model.convert.spi.ConverterDescriptor;\nimport org.hibernate.boot.model.convert.spi.JpaAttributeConverterCreationContext;\nimport org.hibernate.boot.model.process.internal.InferredBasicValueResolution;\nimport org.hibernate.boot.model.process.internal.InferredBasicValueResolver;\nimport org.hibernate.boot.model.process.internal.NamedBasicTypeResolution;\nimport org.hibernate.boot.model.process.internal.NamedConverterResolution;\nimport org.hibernate.boot.model.process.internal.UserTypeResolution;\nimport org.hibernate.boot.model.process.internal.VersionResolution;\nimport org.hibernate.boot.registry.StandardServiceRegistry;\nimport org.hibernate.boot.registry.classloading.spi.ClassLoaderService;\nimport org.hibernate.boot.registry.classloading.spi.ClassLoadingException;\nimport org.hibernate.boot.spi.MetadataBuildingContext;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.Size;\nimport org.hibernate.internal.CoreLogging;\nimport org.hibernate.internal.CoreMessageLogger;\nimport org.hibernate.internal.util.ReflectHelper;\nimport org.hibernate.internal.util.StringHelper;\nimport org.hibernate.internal.util.collections.CollectionHelper;\nimport org.hibernate.metamodel.mapping.JdbcMapping;\nimport org.hibernate.metamodel.mapping.SelectablePath;\nimport org.hibernate.resource.beans.internal.FallbackBeanInstanceProducer;\nimport org.hibernate.resource.beans.spi.BeanInstanceProducer;\nimport org.hibernate.resource.beans.spi.ManagedBean;\nimport org.hibernate.resource.beans.spi.ManagedBeanRegistry;\nimport org.hibernate.tool.schema.extract.spi.ColumnTypeInformation;\nimport org.hibernate.type.BasicType;\nimport org.hibernate.type.CustomType;\nimport org.hibernate.type.NumericBooleanConverter;\nimport org.hibernate.type.SqlTypes;\nimport org.hibernate.type.TrueFalseConverter;\nimport org.hibernate.type.Type;\nimport org.hibernate.type.WrapperArrayHandling;\nimport org.hibernate.type.descriptor.converter.spi.BasicValueConverter;\nimport org.hibernate.type.descriptor.converter.spi.JpaAttributeConverter;\nimport org.hibernate.type.descriptor.java.BasicJavaType;\nimport org.hibernate.type.descriptor.java.BasicPluralJavaType;\nimport org.hibernate.type.descriptor.java.JavaType;\nimport org.hibernate.type.descriptor.java.MutabilityPlan;\nimport org.hibernate.type.descriptor.java.spi.JavaTypeRegistry;\nimport org.hibernate.type.descriptor.java.spi.JsonJavaType;\nimport org.hibernate.type.descriptor.java.spi.RegistryHelper;\nimport org.hibernate.type.descriptor.java.spi.XmlJavaType;\nimport org.hibernate.type.descriptor.jdbc.BooleanJdbcType;\nimport org.hibernate.type.descriptor.jdbc.JdbcType;\nimport org.hibernate.type.descriptor.jdbc.JdbcTypeIndicators;\nimport org.hibernate.type.internal.BasicTypeImpl;\nimport org.hibernate.type.spi.TypeConfiguration;\nimport org.hibernate.type.spi.TypeConfigurationAware;\nimport org.hibernate.usertype.DynamicParameterizedType;\nimport org.hibernate.usertype.UserType;\n\nimport com.fasterxml.classmate.ResolvedType;\nimport jakarta.persistence.AttributeConverter;\nimport jakarta.persistence.EnumType;\nimport jakarta.persistence.TemporalType;\n\nimport static java.lang.Boolean.parseBoolean;\nimport static org.hibernate.internal.util.collections.CollectionHelper.isNotEmpty;\nimport static org.hibernate.mapping.MappingHelper.injectParameters;\n\n/**\n * @author Steve Ebersole\n */\npublic class BasicValue extends SimpleValue implements JdbcTypeIndicators, Resolvable, JpaAttributeConverterCreationContext {\n\tprivate static final CoreMessageLogger log = CoreLogging.messageLogger( BasicValue.class );\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// incoming \"configuration\" values\n\n\tprivate String explicitTypeName;\n\tprivate Map<String,String> explicitLocalTypeParams;\n\n\tprivate Function<TypeConfiguration, BasicJavaType> explicitJavaTypeAccess;\n\tprivate Function<TypeConfiguration, JdbcType> explicitJdbcTypeAccess;\n\tprivate Function<TypeConfiguration, MutabilityPlan> explicitMutabilityPlanAccess;\n\tprivate Function<TypeConfiguration, java.lang.reflect.Type> implicitJavaTypeAccess;\n\n\tprivate EnumType enumerationStyle;\n\tprivate TemporalType temporalPrecision;\n\tprivate TimeZoneStorageType timeZoneStorageType;\n\tprivate boolean isSoftDelete;\n\tprivate SoftDeleteType softDeleteStrategy;\n\n\tprivate java.lang.reflect.Type resolvedJavaType;\n\n\tprivate String ownerName;\n\tprivate String propertyName;\n\tprivate AggregateColumn aggregateColumn;\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// Resolved state - available after `#resolve`\n\tprivate Resolution<?> resolution;\n\tprivate Integer jdbcTypeCode;\n\n\n\tpublic BasicValue(MetadataBuildingContext buildingContext) {\n\t\tthis( buildingContext, null );\n\t}\n\n\tpublic BasicValue(MetadataBuildingContext buildingContext, Table table) {\n\t\tsuper( buildingContext, table );\n\t\tbuildingContext.getMetadataCollector().registerValueMappingResolver( this::resolve );\n\t}\n\n\tpublic BasicValue(BasicValue original) {\n\t\tsuper( original );\n\t\tthis.explicitTypeName = original.explicitTypeName;\n\t\tthis.explicitLocalTypeParams = original.explicitLocalTypeParams == null\n\t\t\t\t? null\n\t\t\t\t: new HashMap<>(original.explicitLocalTypeParams);\n\t\tthis.explicitJavaTypeAccess = original.explicitJavaTypeAccess;\n\t\tthis.explicitJdbcTypeAccess = original.explicitJdbcTypeAccess;\n\t\tthis.explicitMutabilityPlanAccess = original.explicitMutabilityPlanAccess;\n\t\tthis.implicitJavaTypeAccess = original.implicitJavaTypeAccess;\n\t\tthis.enumerationStyle = original.enumerationStyle;\n\t\tthis.temporalPrecision = original.temporalPrecision;\n\t\tthis.timeZoneStorageType = original.timeZoneStorageType;\n\t\tthis.resolvedJavaType = original.resolvedJavaType;\n\t\tthis.ownerName = original.ownerName;\n\t\tthis.propertyName = original.propertyName;\n\t}\n\n\t@Override\n\tpublic BasicValue copy() {\n\t\treturn new BasicValue( this );\n\t}\n\n\tpublic boolean isSoftDelete() {\n\t\treturn isSoftDelete;\n\t}\n\n\tpublic SoftDeleteType getSoftDeleteStrategy() {\n\t\treturn softDeleteStrategy;\n\t}\n\n\tpublic void makeSoftDelete(SoftDeleteType strategy) {\n\t\tisSoftDelete = true;\n\t\tsoftDeleteStrategy = strategy;\n\t}\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// Setters - in preparation of resolution\n\n\t@Override\n\tpublic void setTypeUsingReflection(String className, String propertyName) throws MappingException {\n\t\tif ( resolution != null ) {\n\t\t\tthrow new IllegalStateException( \"BasicValue already resolved\" );\n\t\t}\n\n\t\tthis.ownerName = className;\n\t\tthis.propertyName = propertyName;\n\n\t\tsuper.setTypeUsingReflection( className, propertyName );\n\t}\n\n\tpublic void setEnumerationStyle(EnumType enumerationStyle) {\n\t\tthis.enumerationStyle = enumerationStyle;\n\t}\n\n\tpublic EnumType getEnumerationStyle() {\n\t\treturn enumerationStyle;\n\t}\n\n\tpublic TimeZoneStorageType getTimeZoneStorageType() {\n\t\treturn timeZoneStorageType;\n\t}\n\n\tpublic void setTimeZoneStorageType(TimeZoneStorageType timeZoneStorageType) {\n\t\tthis.timeZoneStorageType = timeZoneStorageType;\n\t}\n\n\tpublic void setJpaAttributeConverterDescriptor(ConverterDescriptor descriptor) {\n\t\tsetAttributeConverterDescriptor( descriptor );\n\n\t\tsuper.setJpaAttributeConverterDescriptor( descriptor );\n\t}\n\n\t@SuppressWarnings(\"rawtypes\")\n\tpublic void setExplicitJavaTypeAccess(Function<TypeConfiguration, BasicJavaType> explicitJavaTypeAccess) {\n\t\tthis.explicitJavaTypeAccess = explicitJavaTypeAccess;\n\t}\n\n\tpublic void setExplicitJdbcTypeAccess(Function<TypeConfiguration, JdbcType> jdbcTypeAccess) {\n\t\tthis.explicitJdbcTypeAccess = jdbcTypeAccess;\n\t}\n\n\tpublic void setExplicitMutabilityPlanAccess(Function<TypeConfiguration, MutabilityPlan> explicitMutabilityPlanAccess) {\n\t\tthis.explicitMutabilityPlanAccess = explicitMutabilityPlanAccess;\n\t}\n\n\tpublic void setImplicitJavaTypeAccess(Function<TypeConfiguration, java.lang.reflect.Type> implicitJavaTypeAccess) {\n\t\tthis.implicitJavaTypeAccess = implicitJavaTypeAccess;\n\t}\n\n\tpublic Selectable getColumn() {\n\t\tif ( getColumnSpan() == 0 ) {\n\t\t\treturn null;\n\t\t}\n\t\treturn getColumn( 0 );\n\t}\n\n\tpublic java.lang.reflect.Type getResolvedJavaType() {\n\t\treturn resolvedJavaType;\n\t}\n\n\t@Override\n\tpublic long getColumnLength() {\n\t\tfinal Selectable selectable = getColumn();\n\t\tif ( selectable instanceof Column ) {\n\t\t\tfinal Column column = (Column) selectable;\n\t\t\tfinal Long length = column.getLength();\n\t\t\treturn length == null ? NO_COLUMN_LENGTH : length;\n\t\t}\n\t\telse {\n\t\t\treturn NO_COLUMN_LENGTH;\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getColumnPrecision() {\n\t\tfinal Selectable selectable = getColumn();\n\t\tif ( selectable instanceof Column ) {\n\t\t\tfinal Column column = (Column) selectable;\n\t\t\tif ( column.getTemporalPrecision() != null ) {\n\t\t\t\treturn column.getTemporalPrecision();\n\t\t\t}\n\t\t\tfinal Integer precision = column.getPrecision();\n\t\t\treturn precision == null ? NO_COLUMN_PRECISION : precision;\n\t\t}\n\t\telse {\n\t\t\treturn NO_COLUMN_PRECISION;\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getColumnScale() {\n\t\tfinal Selectable selectable = getColumn();\n\t\tif ( selectable instanceof Column ) {\n\t\t\tfinal Column column = (Column) selectable;\n\t\t\tfinal Integer scale = column.getScale();\n\t\t\treturn scale == null ? NO_COLUMN_SCALE : scale;\n\t\t}\n\t\telse {\n\t\t\treturn NO_COLUMN_SCALE;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void addColumn(Column incomingColumn) {\n\t\tsuper.addColumn( incomingColumn );\n\n\t\tcheckSelectable( incomingColumn );\n\t}\n\n\t@Override\n\tpublic void copyTypeFrom(SimpleValue sourceValue) {\n\t\tsuper.copyTypeFrom( sourceValue );\n\t\tif ( sourceValue instanceof BasicValue ) {\n\t\t\tfinal BasicValue basicValue = (BasicValue) sourceValue;\n\t\t\tthis.resolution = basicValue.resolution;\n\t\t\tthis.implicitJavaTypeAccess = (typeConfiguration) -> basicValue.implicitJavaTypeAccess.apply( typeConfiguration );\n\t\t}\n\t}\n\n\tprivate void checkSelectable(Selectable incomingColumn) {\n\t\tif ( incomingColumn == null ) {\n\t\t\tthrow new IllegalArgumentException( \"Incoming column was null\" );\n\t\t}\n\n\t\tfinal Selectable column = getColumn();\n\t\tif ( column == incomingColumn || column.getText().equals( incomingColumn.getText() ) ) {\n\t\t\tlog.debugf( \"Skipping column re-registration: %s.%s\", getTable().getName(), column.getText() );\n\t\t}\n//\t\telse {\n//\t\t\tthrow new IllegalStateException(\n//\t\t\t\t\t\"BasicValue [\" + ownerName + \".\" + propertyName +\n//\t\t\t\t\t\t\t\"] already had column associated: `\" + column.getText() +\n//\t\t\t\t\t\t\t\"` -> `\" + incomingColumn.getText() + \"`\"\n//\t\t\t);\n//\t\t}\n\t}\n\n\t@Override\n\tpublic void addColumn(Column incomingColumn, boolean isInsertable, boolean isUpdatable) {\n\t\tsuper.addColumn( incomingColumn, isInsertable, isUpdatable );\n\t\tcheckSelectable( incomingColumn );\n\t}\n\n\t@Override\n\tpublic void addFormula(Formula formula) {\n\t\tsuper.addFormula( formula );\n\n\t\tcheckSelectable( formula );\n\t}\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// Resolution\n\n\t@Override\n\tpublic Type getType() throws MappingException {\n\t\tresolve();\n\t\tassert getResolution() != null;\n\n\t\treturn getResolution().getLegacyResolvedBasicType();\n\t}\n\n\tpublic Resolution<?> getResolution() {\n\t\treturn resolution;\n\t}\n\n\t@Override\n\tpublic boolean resolve(MetadataBuildingContext buildingContext) {\n\t\tresolve();\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic Resolution<?> resolve() {\n\t\tif ( resolution != null ) {\n\t\t\treturn resolution;\n\t\t}\n\n\t\tresolution = buildResolution();\n\n\t\tif ( resolution == null ) {\n\t\t\tthrow new IllegalStateException( \"Unable to resolve BasicValue : \" + this );\n\t\t}\n\n\t\tfinal Selectable selectable = getColumn();\n\t\tfinal Size size;\n\t\tif ( selectable instanceof Column column ) {\n\t\t\tresolveColumn( column, getDialect() );\n\t\t\tsize = column.calculateColumnSize( getDialect(), getBuildingContext().getMetadataCollector() );\n\t\t}\n\t\telse {\n\t\t\tsize = Size.nil();\n\t\t}\n\n\t\tresolution.getJdbcType().addAuxiliaryDatabaseObjects(\n\t\t\t\tresolution.getRelationalJavaType(),\n\t\t\t\tresolution.getValueConverter(),\n\t\t\t\tsize,\n\t\t\t\tgetBuildingContext().getMetadataCollector().getDatabase(),\n\t\t\t\tthis\n\t\t);\n\n\t\treturn resolution;\n\t}\n\n\t@Override\n\tpublic String getExtraCreateTableInfo() {\n\t\treturn resolution.getJdbcType()\n\t\t\t\t.getExtraCreateTableInfo(\n\t\t\t\t\t\tresolution.getRelationalJavaType(),\n\t\t\t\t\t\tgetColumn().getText(),\n\t\t\t\t\t\tgetTable().getName(),\n\t\t\t\t\t\tgetBuildingContext().getMetadataCollector().getDatabase()\n\t\t\t\t);\n\t}\n\n\t@Override\n\tpublic Dialect getDialect() {\n\t\treturn getMetadata().getDatabase().getDialect();\n\t}\n\n\tprivate void resolveColumn(Column column, Dialect dialect) {\n\n\t\tif ( column.getSqlTypeCode() == null ) {\n\t\t\tcolumn.setSqlTypeCode( resolution.getJdbcType().getDdlTypeCode() );\n\t\t}\n\n//\t\tfinal String declaration = resolution.getLegacyResolvedBasicType().getSpecializedTypeDeclaration( dialect );\n//\t\tif ( declaration != null ) {\n//\t\t\tcolumn.setSpecializedTypeDeclaration( declaration );\n//\t\t}\n\n\t\tif ( dialect.supportsColumnCheck() ) {\n\t\t\tfinal String checkCondition = resolution.getLegacyResolvedBasicType()\n\t\t\t\t\t.getCheckCondition( column.getQuotedName( dialect ), dialect );\n\t\t\tif ( checkCondition != null ) {\n\t\t\t\tcolumn.addCheckConstraint( new CheckConstraint( checkCondition ) );\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic AggregateColumn getAggregateColumn() {\n\t\treturn aggregateColumn;\n\t}\n\n\tpublic void setAggregateColumn(AggregateColumn aggregateColumn) {\n\t\tthis.aggregateColumn = aggregateColumn;\n\t}\n\n\tpublic SelectablePath createSelectablePath(String selectableName) {\n\t\tif ( aggregateColumn != null ) {\n\t\t\treturn aggregateColumn.getSelectablePath().append( selectableName );\n\t\t}\n\t\treturn new SelectablePath( selectableName );\n\t}\n\n\tprotected Resolution<?> buildResolution() {\n\t\tfinal Properties typeParameters = getTypeParameters();\n\t\tif ( typeParameters != null\n\t\t\t\t&& parseBoolean( typeParameters.getProperty(DynamicParameterizedType.IS_DYNAMIC) )\n\t\t\t\t&& typeParameters.get(DynamicParameterizedType.PARAMETER_TYPE) == null ) {\n\t\t\tcreateParameterImpl();\n\t\t}\n\n\t\tif ( explicitTypeName != null ) {\n\t\t\treturn interpretExplicitlyNamedType(\n\t\t\t\t\texplicitTypeName,\n\t\t\t\t\texplicitJavaTypeAccess,\n\t\t\t\t\texplicitJdbcTypeAccess,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tgetAttributeConverterDescriptor(),\n\t\t\t\t\ttypeParameters,\n\t\t\t\t\tthis::setTypeParameters,\n\t\t\t\t\tthis,\n\t\t\t\t\tgetBuildingContext()\n\t\t\t);\n\t\t}\n\n\t\tif ( isVersion() ) {\n\t\t\treturn VersionResolution.from( implicitJavaTypeAccess, timeZoneStorageType, getBuildingContext() );\n\t\t}\n\n\t\t// determine JavaType if we can\n\t\tfinal BasicJavaType<?> explicitJavaType = explicitJavaTypeAccess == null\n\t\t\t\t? null\n\t\t\t\t: explicitJavaTypeAccess.apply( getTypeConfiguration() );\n\n\t\tJavaType<?> javaType = determineJavaType( explicitJavaType );\n\t\tConverterDescriptor attributeConverterDescriptor = getAttributeConverterDescriptor();\n\n\t\tif ( isSoftDelete() ) {\n\t\t\tassert attributeConverterDescriptor != null;\n\t\t\tfinal boolean conversionWasUnspecified = SoftDelete.UnspecifiedConversion.class.equals( attributeConverterDescriptor.getAttributeConverterClass() );\n\t\t\tif ( conversionWasUnspecified ) {\n\t\t\t\tfinal JdbcType jdbcType = BooleanJdbcType.INSTANCE.resolveIndicatedType( this, javaType );\n\t\t\t\tif ( jdbcType.isNumber() ) {\n\t\t\t\t\tattributeConverterDescriptor = new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\t\tNumericBooleanConverter.INSTANCE,\n\t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\telse if ( jdbcType.isString() ) {\n\t\t\t\t\t// here we pick 'T' / 'F' storage, though 'Y' / 'N' is equally valid - its 50/50\n\t\t\t\t\tattributeConverterDescriptor = new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\t\tTrueFalseConverter.INSTANCE,\n\t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// should indicate BIT or BOOLEAN == no conversion needed\n\t\t\t\t\t//\t\t- we still create the converter to properly set up JDBC type, etc\n\t\t\t\t\tattributeConverterDescriptor = new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\t\tPassThruSoftDeleteConverter.INSTANCE,\n\t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( getSoftDeleteStrategy() == SoftDeleteType.ACTIVE ) {\n\t\t\t\tattributeConverterDescriptor = new ReversedConverterDescriptor<>( attributeConverterDescriptor );\n\t\t\t}\n\t\t}\n\n\t\treturn attributeConverterDescriptor != null\n\t\t\t\t? converterResolution( javaType, attributeConverterDescriptor )\n\t\t\t\t: resolution( explicitJavaType, javaType );\n\t}\n\n\tprivate static class ReversedConverterDescriptor<R> implements ConverterDescriptor {\n\t\tprivate final ConverterDescriptor underlyingDescriptor;\n\n\t\tpublic ReversedConverterDescriptor(ConverterDescriptor underlyingDescriptor) {\n\t\t\tthis.underlyingDescriptor = underlyingDescriptor;\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<? extends AttributeConverter<Boolean,R>> getAttributeConverterClass() {\n\t\t\t//noinspection unchecked\n\t\t\treturn (Class<? extends AttributeConverter<Boolean, R>>) getClass();\n\t\t}\n\n\t\t@Override\n\t\tpublic ResolvedType getDomainValueResolvedType() {\n\t\t\treturn underlyingDescriptor.getDomainValueResolvedType();\n\t\t}\n\n\t\t@Override\n\t\tpublic ResolvedType getRelationalValueResolvedType() {\n\t\t\treturn underlyingDescriptor.getRelationalValueResolvedType();\n\t\t}\n\n\t\t@Override\n\t\tpublic AutoApplicableConverterDescriptor getAutoApplyDescriptor() {\n\t\t\treturn AutoApplicableConverterDescriptorBypassedImpl.INSTANCE;\n\t\t}\n\n\t\t@Override\n\t\tpublic JpaAttributeConverter<Boolean,R> createJpaAttributeConverter(JpaAttributeConverterCreationContext context) {\n\t\t\t//noinspection unchecked\n\t\t\treturn new ReversedJpaAttributeConverter<>(\n\t\t\t\t\t(JpaAttributeConverter<Boolean, R>) underlyingDescriptor.createJpaAttributeConverter( context ),\n\t\t\t\t\tcontext.getJavaTypeRegistry().getDescriptor( ReversedJpaAttributeConverter.class )\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate static class ReversedJpaAttributeConverter<R, B extends AttributeConverter<Boolean, R>>\n\t\t\timplements JpaAttributeConverter<Boolean,R>, AttributeConverter<Boolean,R>, ManagedBean<B> {\n\t\tprivate final JpaAttributeConverter<Boolean,R> underlyingJpaConverter;\n\t\tprivate final JavaType<ReversedJpaAttributeConverter<R,B>> converterJavaType;\n\n\t\tpublic ReversedJpaAttributeConverter(\n\t\t\t\tJpaAttributeConverter<Boolean, R> underlyingJpaConverter,\n\t\t\t\tJavaType<ReversedJpaAttributeConverter<R,B>> converterJavaType) {\n\t\t\tthis.underlyingJpaConverter = underlyingJpaConverter;\n\t\t\tthis.converterJavaType = converterJavaType;\n\t\t}\n\n\t\t@Override\n\t\tpublic Boolean toDomainValue(R relationalValue) {\n\t\t\treturn !underlyingJpaConverter.toDomainValue( relationalValue );\n\t\t}\n\n\t\t@Override\n\t\tpublic R toRelationalValue(Boolean domainValue) {\n\t\t\treturn underlyingJpaConverter.toRelationalValue( domainValue != null ? !domainValue : null );\n\t\t}\n\n\t\t@Override\n\t\tpublic Boolean convertToEntityAttribute(R relationalValue) {\n\t\t\treturn toDomainValue( relationalValue );\n\t\t}\n\n\t\t@Override\n\t\tpublic R convertToDatabaseColumn(Boolean domainValue) {\n\t\t\treturn toRelationalValue( domainValue );\n\t\t}\n\n\t\t@Override\n\t\tpublic JavaType<Boolean> getDomainJavaType() {\n\t\t\treturn underlyingJpaConverter.getDomainJavaType();\n\t\t}\n\n\t\t@Override\n\t\tpublic JavaType<R> getRelationalJavaType() {\n\t\t\treturn underlyingJpaConverter.getRelationalJavaType();\n\t\t}\n\n\t\t@Override\n\t\tpublic JavaType<? extends AttributeConverter<Boolean, R>> getConverterJavaType() {\n\t\t\treturn converterJavaType;\n\t\t}\n\n\t\t@Override\n\t\tpublic ManagedBean<? extends AttributeConverter<Boolean, R>> getConverterBean() {\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<B> getBeanClass() {\n\t\t\t//noinspection unchecked\n\t\t\treturn (Class<B>) getClass();\n\t\t}\n\n\t\t@Override\n\t\tpublic B getBeanInstance() {\n\t\t\t//noinspection unchecked\n\t\t\treturn (B) this;\n\t\t}\n\t}\n\n\tprivate static class PassThruSoftDeleteConverter implements AttributeConverter<Boolean,Boolean> {\n\t\tprivate static final PassThruSoftDeleteConverter INSTANCE = new PassThruSoftDeleteConverter();\n\n\t\t@Override\n\t\tpublic Boolean convertToDatabaseColumn(Boolean domainValue) {\n\t\t\treturn domainValue;\n\t\t}\n\n\t\t@Override\n\t\tpublic Boolean convertToEntityAttribute(Boolean relationalValue) {\n\t\t\treturn relationalValue;\n\t\t}\n\t}\n\n\tprivate Resolution<?> resolution(BasicJavaType explicitJavaType, JavaType<?> javaType) {\n\t\tfinal JavaType<?> basicJavaType;\n\t\tfinal JdbcType jdbcType;\n\t\tif ( explicitJdbcTypeAccess != null ) {\n\t\t\tfinal TypeConfiguration typeConfiguration = getTypeConfiguration();\n\t\t\tjdbcType = explicitJdbcTypeAccess.apply( typeConfiguration );\n\t\t\tbasicJavaType = javaType == null && jdbcType != null\n\t\t\t\t\t? jdbcType.getJdbcRecommendedJavaTypeMapping(null, null, typeConfiguration)\n\t\t\t\t\t: javaType;\n\t\t}\n\t\telse {\n\t\t\tjdbcType = null;\n\t\t\tbasicJavaType = javaType;\n\t\t}\n\t\tif ( basicJavaType == null ) {\n\t\t\tthrow new MappingException( \"Unable to determine JavaType to use : \" + this );\n\t\t}\n\n\t\tif ( basicJavaType instanceof BasicJavaType<?>\n\t\t\t\t&& ( !basicJavaType.getJavaTypeClass().isEnum() || enumerationStyle == null ) ) {\n\t\t\tfinal TypeDefinition autoAppliedTypeDef =\n\t\t\t\t\tgetBuildingContext().getTypeDefinitionRegistry()\n\t\t\t\t\t\t\t.resolveAutoApplied( (BasicJavaType<?>) basicJavaType );\n\t\t\tif ( autoAppliedTypeDef != null ) {\n\t\t\t\tlog.debug(\"BasicValue resolution matched auto-applied type-definition\");\n\t\t\t\treturn autoAppliedTypeDef.resolve( getTypeParameters(), null, getBuildingContext(), this );\n\t\t\t}\n\t\t}\n\n\t\treturn InferredBasicValueResolver.from(\n\t\t\t\texplicitJavaType,\n\t\t\t\tjdbcType,\n\t\t\t\tresolvedJavaType,\n\t\t\t\tthis::determineReflectedJavaType,\n\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\tthis,\n\t\t\t\tgetTable(),\n\t\t\t\tgetColumn(),\n\t\t\t\townerName,\n\t\t\t\tpropertyName,\n\t\t\t\tgetBuildingContext()\n\t\t);\n\t}\n\n\t@Override\n\tpublic ManagedBeanRegistry getManagedBeanRegistry() {\n\t\treturn getServiceRegistry().requireService( ManagedBeanRegistry.class );\n\t}\n\n\tprivate Resolution<?> converterResolution(JavaType<?> javaType, ConverterDescriptor attributeConverterDescriptor) {\n\t\tfinal NamedConverterResolution<?> converterResolution = NamedConverterResolution.from(\n\t\t\t\tattributeConverterDescriptor,\n\t\t\t\texplicitJavaTypeAccess,\n\t\t\t\texplicitJdbcTypeAccess,\n\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\tresolvedJavaType,\n\t\t\t\tthis,\n\t\t\t\tthis,\n\t\t\t\tgetBuildingContext()\n\t\t);\n\n\t\tif ( javaType instanceof BasicPluralJavaType<?>\n\t\t\t\t&& !attributeConverterDescriptor.getDomainValueResolvedType().getErasedType()\n\t\t\t\t\t\t.isAssignableFrom( javaType.getJavaTypeClass() ) ) {\n\t\t\t// In this case, the converter applies to the element of a BasicPluralJavaType\n\t\t\tfinal BasicPluralJavaType<?> containerJtd = (BasicPluralJavaType<?>) javaType;\n\t\t\tfinal BasicType registeredElementType = converterResolution.getLegacyResolvedBasicType();\n\t\t\tfinal Selectable column = getColumn();\n\t\t\tfinal BasicType<?> registeredType = registeredElementType == null ? null\n\t\t\t\t\t: containerJtd.resolveType(\n\t\t\t\t\t\t\tgetTypeConfiguration(),\n\t\t\t\t\t\t\tgetDialect(),\n\t\t\t\t\t\t\tregisteredElementType,\n\t\t\t\t\t\t\tcolumn instanceof ColumnTypeInformation ? (ColumnTypeInformation) column : null,\n\t\t\t\t\t\t\tthis\n\t\t\t);\n\t\t\tif ( registeredType != null ) {\n\t\t\t\tgetTypeConfiguration().getBasicTypeRegistry().register( registeredType );\n\t\t\t\treturn new InferredBasicValueResolution(\n\t\t\t\t\t\tregisteredType,\n\t\t\t\t\t\tregisteredType.getJavaTypeDescriptor(),\n\t\t\t\t\t\tregisteredType.getJavaTypeDescriptor(),\n\t\t\t\t\t\tregisteredType.getJdbcType(),\n\t\t\t\t\t\tregisteredType,\n\t\t\t\t\t\tnull\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn converterResolution;\n\t}\n\n\tprivate JavaType<?> determineJavaType(JavaType<?> explicitJavaType) {\n\t\tJavaType<?> javaType = explicitJavaType;\n//\n//\t\tif ( javaType == null ) {\n//\t\t\tif ( implicitJavaTypeAccess != null ) {\n//\t\t\t\tfinal java.lang.reflect.Type implicitJtd = implicitJavaTypeAccess.apply( getTypeConfiguration() );\n//\t\t\t\tif ( implicitJtd != null ) {\n//\t\t\t\t\tjavaType = getTypeConfiguration().getJavaTypeRegistry().getDescriptor( implicitJtd );\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n\n\t\tif ( javaType == null ) {\n\t\t\tfinal JavaType<?> reflectedJtd = determineReflectedJavaType();\n\t\t\tif ( reflectedJtd != null ) {\n\t\t\t\tjavaType = reflectedJtd;\n\t\t\t}\n\t\t}\n\n\t\treturn javaType;\n\t}\n\n\tprivate JavaType<?> determineReflectedJavaType() {\n\t\tfinal java.lang.reflect.Type impliedJavaType;\n\n\t\tfinal TypeConfiguration typeConfiguration = getTypeConfiguration();\n\t\tif ( resolvedJavaType != null ) {\n\t\t\timpliedJavaType = resolvedJavaType;\n\t\t}\n\t\telse if ( implicitJavaTypeAccess != null ) {\n\t\t\timpliedJavaType = implicitJavaTypeAccess.apply( typeConfiguration );\n\t\t}\n\t\telse if ( ownerName != null && propertyName != null ) {\n\t\t\timpliedJavaType = ReflectHelper.reflectedPropertyType(\n\t\t\t\t\townerName,\n\t\t\t\t\tpropertyName,\n\t\t\t\t\tgetServiceRegistry().requireService( ClassLoaderService.class )\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\n\t\tresolvedJavaType = impliedJavaType;\n\n\t\tif ( impliedJavaType == null ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal JavaTypeRegistry javaTypeRegistry = typeConfiguration.getJavaTypeRegistry();\n\t\tfinal JavaType<Object> javaType = javaTypeRegistry.findDescriptor( impliedJavaType );\n\t\tfinal MutabilityPlan<Object> explicitMutabilityPlan = explicitMutabilityPlanAccess != null\n\t\t\t\t? explicitMutabilityPlanAccess.apply( typeConfiguration )\n\t\t\t\t: null;\n\t\tfinal MutabilityPlan<Object> determinedMutabilityPlan = explicitMutabilityPlan != null\n\t\t\t\t? explicitMutabilityPlan\n\t\t\t\t: RegistryHelper.INSTANCE.determineMutabilityPlan( impliedJavaType, typeConfiguration );\n\t\tif ( javaType == null ) {\n\t\t\tif ( jdbcTypeCode != null ) {\n\t\t\t\t// Construct special JavaType instances for JSON/XML types which can report recommended JDBC types\n\t\t\t\t// and implement toString/fromString as well as copying based on FormatMapper operations\n\t\t\t\tswitch ( jdbcTypeCode ) {\n\t\t\t\t\tcase SqlTypes.JSON:\n\t\t\t\t\t\tfinal JavaType<Object> jsonJavaType = new JsonJavaType<>(\n\t\t\t\t\t\t\t\timpliedJavaType,\n\t\t\t\t\t\t\t\tdeterminedMutabilityPlan,\n\t\t\t\t\t\t\t\ttypeConfiguration\n\t\t\t\t\t\t);\n\t\t\t\t\t\tjavaTypeRegistry.addDescriptor( jsonJavaType );\n\t\t\t\t\t\treturn jsonJavaType;\n\t\t\t\t\tcase SqlTypes.SQLXML:\n\t\t\t\t\t\tfinal JavaType<Object> xmlJavaType = new XmlJavaType<>(\n\t\t\t\t\t\t\t\timpliedJavaType,\n\t\t\t\t\t\t\t\tdeterminedMutabilityPlan,\n\t\t\t\t\t\t\t\ttypeConfiguration\n\t\t\t\t\t\t);\n\t\t\t\t\t\tjavaTypeRegistry.addDescriptor( xmlJavaType );\n\t\t\t\t\t\treturn xmlJavaType;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn javaTypeRegistry.resolveDescriptor( impliedJavaType );\n\t\t}\n\t\treturn javaType;\n\t}\n\n\tprivate static Resolution<?> interpretExplicitlyNamedType(\n\t\t\tString name,\n\t\t\tFunction<TypeConfiguration, BasicJavaType> explicitJtdAccess,\n\t\t\tFunction<TypeConfiguration, JdbcType> explicitStdAccess,\n\t\t\tFunction<TypeConfiguration, MutabilityPlan> explicitMutabilityPlanAccess,\n\t\t\tConverterDescriptor converterDescriptor,\n\t\t\tMap<Object,Object> localTypeParams,\n\t\t\tConsumer<Properties> combinedParameterConsumer,\n\t\t\tJdbcTypeIndicators stdIndicators,\n\t\t\tMetadataBuildingContext context) {\n\n\t\tfinal StandardServiceRegistry serviceRegistry = context.getBootstrapContext().getServiceRegistry();\n\t\tfinal ManagedBeanRegistry managedBeanRegistry = serviceRegistry.requireService( ManagedBeanRegistry.class );\n\t\tfinal TypeConfiguration typeConfiguration = context.getBootstrapContext().getTypeConfiguration();\n\n\t\tfinal JpaAttributeConverterCreationContext converterCreationContext = new JpaAttributeConverterCreationContext() {\n\t\t\t@Override\n\t\t\tpublic ManagedBeanRegistry getManagedBeanRegistry() {\n\t\t\t\treturn managedBeanRegistry;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic TypeConfiguration getTypeConfiguration() {\n\t\t\t\treturn typeConfiguration;\n\t\t\t}\n\t\t};\n\n\t\t// Name could refer to:\n\t\t//\t\t1) a named converter - HBM support for JPA's AttributeConverter via its `type=\"...\"` XML attribute\n\t\t//\t\t2) a \"named composed\" mapping - like (1), this is mainly to support envers since it tells\n\t\t//\t\t\tHibernate the mappings via DOM.  See `org.hibernate.type.internal.BasicTypeImpl`\n\t\t//\t\t3) basic type \"resolution key\"\n\t\t//\t\t4) UserType or BasicType class name - directly, or through a TypeDefinition\n\n\t\tif ( name.startsWith( ConverterDescriptor.TYPE_NAME_PREFIX  ) ) {\n\t\t\treturn NamedConverterResolution.from(\n\t\t\t\t\tname,\n\t\t\t\t\texplicitJtdAccess,\n\t\t\t\t\texplicitStdAccess,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tstdIndicators,\n\t\t\t\t\tconverterCreationContext,\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\n//\t\tif ( name.startsWith( EnumeratedValueResolution.PREFIX ) ) {\n//\t\t\treturn EnumeratedValueResolution.fromName( name, stdIndicators, context );\n//\t\t}\n\n\t\tif ( name.startsWith( BasicTypeImpl.EXTERNALIZED_PREFIX ) ) {\n\t\t\tfinal BasicType<Object> basicType = context.getBootstrapContext().resolveAdHocBasicType( name );\n\t\t\treturn new NamedBasicTypeResolution<>(\n\t\t\t\t\tbasicType.getJavaTypeDescriptor(),\n\t\t\t\t\tbasicType,\n\t\t\t\t\tnull,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\n\t\t// see if it is a named basic type\n\t\tfinal BasicType<?> basicTypeByName = typeConfiguration.getBasicTypeRegistry().getRegisteredType( name );\n\t\tif ( basicTypeByName != null ) {\n\t\t\tfinal BasicValueConverter<?,?> valueConverter;\n\t\t\tfinal JavaType<?> domainJtd;\n\t\t\tif ( converterDescriptor != null ) {\n\t\t\t\tvalueConverter = converterDescriptor.createJpaAttributeConverter( converterCreationContext );\n\t\t\t\tdomainJtd = valueConverter.getDomainJavaType();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalueConverter = basicTypeByName.getValueConverter();\n\t\t\t\tdomainJtd = basicTypeByName.getJavaTypeDescriptor();\n\t\t\t}\n\n\t\t\treturn new NamedBasicTypeResolution<>(\n\t\t\t\t\tdomainJtd,\n\t\t\t\t\tbasicTypeByName,\n\t\t\t\t\tvalueConverter,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\n\t\t// see if it is a named TypeDefinition\n\t\tfinal TypeDefinition typeDefinition = context.getTypeDefinitionRegistry().resolve( name );\n\t\tif ( typeDefinition != null ) {\n\t\t\tfinal Resolution<?> resolution = typeDefinition.resolve(\n\t\t\t\t\tlocalTypeParams,\n\t\t\t\t\texplicitMutabilityPlanAccess != null\n\t\t\t\t\t\t\t? explicitMutabilityPlanAccess.apply( typeConfiguration )\n\t\t\t\t\t\t\t: null,\n\t\t\t\t\tcontext,\n\t\t\t\t\tstdIndicators\n\t\t\t);\n\t\t\tcombinedParameterConsumer.accept( resolution.getCombinedTypeParameters() );\n\t\t\treturn resolution;\n\t\t}\n\n\n\t\t// see if the name is a UserType or BasicType implementor class name\n\t\tfinal ClassLoaderService cls = serviceRegistry.requireService( ClassLoaderService.class );\n\t\ttry {\n\t\t\tfinal Class<?> typeNamedClass = cls.classForName( name );\n\n\t\t\t// if there are no local config params, register an implicit TypeDefinition for this custom type .\n\t\t\t//  later uses may find it and re-use its cacheable reference...\n\t\t\tif ( CollectionHelper.isEmpty( localTypeParams ) ) {\n\t\t\t\tfinal TypeDefinition implicitDefinition = new TypeDefinition(\n\t\t\t\t\t\tname,\n\t\t\t\t\t\ttypeNamedClass,\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\tnull\n\t\t\t\t);\n\t\t\t\tcontext.getTypeDefinitionRegistry().register( implicitDefinition );\n\t\t\t\treturn implicitDefinition.resolve(\n\t\t\t\t\t\tlocalTypeParams,\n\t\t\t\t\t\texplicitMutabilityPlanAccess != null\n\t\t\t\t\t\t\t\t? explicitMutabilityPlanAccess.apply( typeConfiguration )\n\t\t\t\t\t\t\t\t: null,\n\t\t\t\t\t\tcontext,\n\t\t\t\t\t\tstdIndicators\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn TypeDefinition.createLocalResolution( name, typeNamedClass, localTypeParams, context );\n\t\t}\n\t\tcatch (ClassLoadingException e) {\n\t\t\t// allow the exception below to trigger\n\t\t\tlog.debugf( \"Could not resolve type-name [%s] as Java type : %s\", name, e );\n\t\t}\n\n\t\tthrow new MappingException( \"Could not resolve named type : \" + name );\n\t}\n\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// SqlTypeDescriptorIndicators\n\n\t@Override\n\tpublic EnumType getEnumeratedType() {\n\t\treturn getEnumerationStyle();\n\t}\n\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForBoolean() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForBoolean() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForDuration() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForDuration() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForUuid() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForUuid() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForInstant() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForInstant() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForArray() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForArray() );\n\t}\n\n\t@Override\n\tpublic int resolveJdbcTypeCode(int jdbcTypeCode) {\n\t\treturn aggregateColumn == null\n\t\t\t\t? jdbcTypeCode\n\t\t\t\t: getDialect().getAggregateSupport()\n\t\t\t\t.aggregateComponentSqlTypeCode( aggregateColumn.getSqlTypeCode( getMetadata() ), jdbcTypeCode );\n\t}\n\n\t@Override\n\tpublic TimeZoneStorageStrategy getDefaultTimeZoneStorageStrategy() {\n\t\treturn timeZoneStorageStrategy( timeZoneStorageType, getBuildingContext() );\n\t}\n\n\t@Internal\n\tpublic static TimeZoneStorageStrategy timeZoneStorageStrategy(\n\t\t\tTimeZoneStorageType timeZoneStorageType,\n\t\t\tMetadataBuildingContext buildingContext) {\n\t\tif ( timeZoneStorageType != null ) {\n\t\t\tswitch ( timeZoneStorageType ) {\n\t\t\t\tcase COLUMN:\n\t\t\t\t\treturn TimeZoneStorageStrategy.COLUMN;\n\t\t\t\tcase NATIVE:\n\t\t\t\t\treturn TimeZoneStorageStrategy.NATIVE;\n\t\t\t\tcase NORMALIZE:\n\t\t\t\t\treturn TimeZoneStorageStrategy.NORMALIZE;\n\t\t\t\tcase NORMALIZE_UTC:\n\t\t\t\t\treturn TimeZoneStorageStrategy.NORMALIZE_UTC;\n\t\t\t}\n\t\t}\n\t\treturn buildingContext.getBuildingOptions().getDefaultTimeZoneStorage();\n\t}\n\n\tpublic void setExplicitTypeParams(Map<String,String> explicitLocalTypeParams) {\n\t\tthis.explicitLocalTypeParams = explicitLocalTypeParams;\n\t}\n\n\tpublic void setExplicitTypeName(String typeName) {\n\t\tthis.explicitTypeName = typeName;\n\t}\n\n\tpublic void setTypeName(String typeName) {\n\t\tif ( StringHelper.isNotEmpty( typeName ) ) {\n\t\t\tif ( typeName.startsWith( ConverterDescriptor.TYPE_NAME_PREFIX ) ) {\n\t\t\t\tfinal String converterClassName = typeName.substring( ConverterDescriptor.TYPE_NAME_PREFIX.length() );\n\t\t\t\tfinal ClassLoaderService cls = getServiceRegistry().requireService( ClassLoaderService.class );\n\t\t\t\ttry {\n\t\t\t\t\tfinal Class<AttributeConverter<?,?>> converterClass = cls.classForName( converterClassName );\n\t\t\t\t\tsetAttributeConverterDescriptor( new ClassBasedConverterDescriptor(\n\t\t\t\t\t\t\tconverterClass,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t\t) );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tlog.logBadHbmAttributeConverterType( typeName, e.getMessage() );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsetExplicitTypeName( typeName );\n\t\t\t}\n\t\t}\n\n\t\tsuper.setTypeName( typeName );\n\t}\n\n\tprivate static int COUNTER;\n\n\tpublic void setExplicitCustomType(Class<? extends UserType<?>> explicitCustomType) {\n\t\tif ( explicitCustomType != null ) {\n\t\t\tif ( resolution != null ) {\n\t\t\t\tthrow new UnsupportedOperationException( \"Unsupported attempt to set an explicit-custom-type when value is already resolved\" );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresolution = new UserTypeResolution<>(\n\t\t\t\t\t\tnew CustomType<>(\n\t\t\t\t\t\t\t\tgetConfiguredUserTypeBean( explicitCustomType, getCustomTypeProperties() ),\n\t\t\t\t\t\t\t\tgetTypeConfiguration()\n\t\t\t\t\t\t),\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\tgetCustomTypeProperties()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate Properties getCustomTypeProperties() {\n\t\tfinal Properties properties = new Properties();\n\t\tif ( isNotEmpty( getTypeParameters() ) ) {\n\t\t\tproperties.putAll( getTypeParameters() );\n\t\t}\n\t\tif ( isNotEmpty( explicitLocalTypeParams ) ) {\n\t\t\tproperties.putAll( explicitLocalTypeParams );\n\t\t}\n\t\treturn properties;\n\t}\n\n\tprivate UserType<?> getConfiguredUserTypeBean(Class<? extends UserType<?>> explicitCustomType, Properties properties) {\n\t\tfinal UserType<?> typeInstance =\n\t\t\t\t!getBuildingContext().getBuildingOptions().isAllowExtensionsInCdi()\n\t\t\t\t\t\t? FallbackBeanInstanceProducer.INSTANCE.produceBeanInstance( explicitCustomType )\n\t\t\t\t\t\t: getUserTypeBean( explicitCustomType, properties ).getBeanInstance();\n\n\t\tif ( typeInstance instanceof TypeConfigurationAware ) {\n\t\t\tfinal TypeConfigurationAware configurationAware = (TypeConfigurationAware) typeInstance;\n\t\t\tconfigurationAware.setTypeConfiguration( getTypeConfiguration() );\n\t\t}\n\n\t\tif ( typeInstance instanceof DynamicParameterizedType ) {\n\t\t\tif ( parseBoolean( properties.getProperty( DynamicParameterizedType.IS_DYNAMIC ) ) ) {\n\t\t\t\tif ( properties.get( DynamicParameterizedType.PARAMETER_TYPE ) == null ) {\n\t\t\t\t\tproperties.put( DynamicParameterizedType.PARAMETER_TYPE, makeParameterImpl() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tinjectParameters( typeInstance, properties);\n\t\t// envers - grr\n\t\tsetTypeParameters( properties );\n\n\t\treturn typeInstance;\n\t}\n\n\tprivate <T> ManagedBean<T> getUserTypeBean(Class<T> explicitCustomType, Properties properties) {\n\t\tfinal BeanInstanceProducer producer = getBuildingContext().getBootstrapContext().getCustomTypeProducer();\n\t\tfinal ManagedBeanRegistry registry = getServiceRegistry().requireService( ManagedBeanRegistry.class );\n\t\tif ( isNotEmpty( properties ) ) {\n\t\t\tfinal String name = explicitCustomType.getName() + COUNTER++;\n\t\t\treturn registry.getBean( name, explicitCustomType, producer );\n\t\t}\n\t\telse {\n\t\t\treturn registry.getBean( explicitCustomType, producer );\n\t\t}\n\t}\n\n\tpublic void setTemporalPrecision(TemporalType temporalPrecision) {\n\t\tthis.temporalPrecision = temporalPrecision;\n\t}\n\n\t@Override\n\tpublic TemporalType getTemporalPrecision() {\n\t\treturn temporalPrecision;\n\t}\n\n\t@Override\n\tpublic boolean isPreferJavaTimeJdbcTypesEnabled() {\n\t\treturn getBuildingContext().isPreferJavaTimeJdbcTypesEnabled();\n\t}\n\n\t@Override\n\tpublic boolean isPreferNativeEnumTypesEnabled() {\n\t\treturn getBuildingContext().isPreferNativeEnumTypesEnabled();\n\t}\n\n\t@Override\n\tpublic Object accept(ValueVisitor visitor) {\n\t\treturn visitor.accept(this);\n\t}\n\n\t@Internal\n\tpublic boolean isDisallowedWrapperArray() {\n\t\treturn getBuildingContext().getBuildingOptions().getWrapperArrayHandling() == WrapperArrayHandling.DISALLOW\n\t\t\t&& !isLob()\n\t\t\t&& ( explicitJavaTypeAccess == null || explicitJavaTypeAccess.apply( getTypeConfiguration() ) == null )\n\t\t\t&& isWrapperByteOrCharacterArray();\n\t}\n\n\tprivate boolean isWrapperByteOrCharacterArray() {\n\t\tfinal Class<?> javaTypeClass = getResolution().getDomainJavaType().getJavaTypeClass();\n\t\treturn javaTypeClass == Byte[].class || javaTypeClass == Character[].class;\n\t}\n\n\t@Incubating\n\tpublic void setExplicitJdbcTypeCode(Integer jdbcTypeCode) {\n\t\tthis.jdbcTypeCode = jdbcTypeCode;\n\t}\n\n\t@Override\n\tpublic Integer getExplicitJdbcTypeCode() {\n\t\treturn jdbcTypeCode == null ? getPreferredSqlTypeCodeForArray() : jdbcTypeCode;\n\t}\n\n\t/**\n\t * Resolved form of {@link BasicValue} as part of interpreting the\n\t * boot-time model into the run-time model\n\t */\n\tpublic interface Resolution<J> {\n\t\t/**\n\t\t * The BasicType resolved using the pre-6.0 rules.  This is temporarily\n\t\t * needed because of the split in extracting / binding\n\t\t */\n\t\tBasicType<J> getLegacyResolvedBasicType();\n\n\t\t/**\n\t\t * Get the collection of type-parameters collected both locally as well\n\t\t * as from the applied type-def, if one\n\t\t */\n\t\tdefault Properties getCombinedTypeParameters() {\n\t\t\treturn null;\n\t\t}\n\n\t\tJdbcMapping getJdbcMapping();\n\n\t\t/**\n\t\t * The JavaType for the value as part of the domain model\n\t\t */\n\t\tJavaType<J> getDomainJavaType();\n\n\t\t/**\n\t\t * The JavaType for the relational value as part of\n\t\t * the relational model (its JDBC representation)\n\t\t */\n\t\tJavaType<?> getRelationalJavaType();\n\n\t\t/**\n\t\t * The JavaType for the relational value as part of\n\t\t * the relational model (its JDBC representation)\n\t\t */\n\t\tJdbcType getJdbcType();\n\n\t\t/**\n\t\t * Converter, if any, to convert values between the\n\t\t * domain and relational JavaType representations\n\t\t */\n\t\tBasicValueConverter<J,?> getValueConverter();\n\n\t\t/**\n\t\t * The resolved MutabilityPlan\n\t\t */\n\t\tMutabilityPlan<J> getMutabilityPlan();\n\n\t\tdefault void updateResolution(BasicType<?> type) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/mapping/BasicValue.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.mapping;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\n\nimport org.hibernate.Incubating;\nimport org.hibernate.Internal;\nimport org.hibernate.MappingException;\nimport org.hibernate.TimeZoneStorageStrategy;\nimport org.hibernate.annotations.SoftDelete;\nimport org.hibernate.annotations.SoftDeleteType;\nimport org.hibernate.annotations.TimeZoneStorageType;\nimport org.hibernate.boot.model.TypeDefinition;\nimport org.hibernate.boot.model.convert.internal.AutoApplicableConverterDescriptorBypassedImpl;\nimport org.hibernate.boot.model.convert.internal.ClassBasedConverterDescriptor;\nimport org.hibernate.boot.model.convert.internal.InstanceBasedConverterDescriptor;\nimport org.hibernate.boot.model.convert.spi.AutoApplicableConverterDescriptor;\nimport org.hibernate.boot.model.convert.spi.ConverterDescriptor;\nimport org.hibernate.boot.model.convert.spi.JpaAttributeConverterCreationContext;\nimport org.hibernate.boot.model.process.internal.InferredBasicValueResolution;\nimport org.hibernate.boot.model.process.internal.InferredBasicValueResolver;\nimport org.hibernate.boot.model.process.internal.NamedBasicTypeResolution;\nimport org.hibernate.boot.model.process.internal.NamedConverterResolution;\nimport org.hibernate.boot.model.process.internal.UserTypeResolution;\nimport org.hibernate.boot.model.process.internal.VersionResolution;\nimport org.hibernate.boot.registry.StandardServiceRegistry;\nimport org.hibernate.boot.registry.classloading.spi.ClassLoaderService;\nimport org.hibernate.boot.registry.classloading.spi.ClassLoadingException;\nimport org.hibernate.boot.spi.MetadataBuildingContext;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.Size;\nimport org.hibernate.internal.CoreLogging;\nimport org.hibernate.internal.CoreMessageLogger;\nimport org.hibernate.internal.util.StringHelper;\nimport org.hibernate.internal.util.collections.CollectionHelper;\nimport org.hibernate.metamodel.mapping.JdbcMapping;\nimport org.hibernate.metamodel.mapping.SelectablePath;\nimport org.hibernate.resource.beans.internal.FallbackBeanInstanceProducer;\nimport org.hibernate.resource.beans.spi.BeanInstanceProducer;\nimport org.hibernate.resource.beans.spi.ManagedBean;\nimport org.hibernate.resource.beans.spi.ManagedBeanRegistry;\nimport org.hibernate.tool.schema.extract.spi.ColumnTypeInformation;\nimport org.hibernate.type.BasicType;\nimport org.hibernate.type.CustomType;\nimport org.hibernate.type.NumericBooleanConverter;\nimport org.hibernate.type.SqlTypes;\nimport org.hibernate.type.TrueFalseConverter;\nimport org.hibernate.type.Type;\nimport org.hibernate.type.WrapperArrayHandling;\nimport org.hibernate.type.descriptor.converter.spi.BasicValueConverter;\nimport org.hibernate.type.descriptor.converter.spi.JpaAttributeConverter;\nimport org.hibernate.type.descriptor.java.BasicJavaType;\nimport org.hibernate.type.descriptor.java.BasicPluralJavaType;\nimport org.hibernate.type.descriptor.java.JavaType;\nimport org.hibernate.type.descriptor.java.MutabilityPlan;\nimport org.hibernate.type.descriptor.java.spi.JavaTypeRegistry;\nimport org.hibernate.type.descriptor.java.spi.JsonJavaType;\nimport org.hibernate.type.descriptor.java.spi.RegistryHelper;\nimport org.hibernate.type.descriptor.java.spi.XmlJavaType;\nimport org.hibernate.type.descriptor.jdbc.BooleanJdbcType;\nimport org.hibernate.type.descriptor.jdbc.JdbcType;\nimport org.hibernate.type.descriptor.jdbc.JdbcTypeIndicators;\nimport org.hibernate.type.internal.BasicTypeImpl;\nimport org.hibernate.type.spi.TypeConfiguration;\nimport org.hibernate.type.spi.TypeConfigurationAware;\nimport org.hibernate.usertype.DynamicParameterizedType;\nimport org.hibernate.usertype.UserType;\n\nimport com.fasterxml.classmate.ResolvedType;\nimport jakarta.persistence.AttributeConverter;\nimport jakarta.persistence.EnumType;\nimport jakarta.persistence.TemporalType;\n\nimport static java.lang.Boolean.parseBoolean;\nimport static org.hibernate.internal.util.ReflectHelper.reflectedPropertyType;\nimport static org.hibernate.internal.util.collections.CollectionHelper.isNotEmpty;\nimport static org.hibernate.mapping.MappingHelper.injectParameters;\n\n/**\n * @author Steve Ebersole\n */\npublic class BasicValue extends SimpleValue implements JdbcTypeIndicators, Resolvable, JpaAttributeConverterCreationContext {\n\tprivate static final CoreMessageLogger log = CoreLogging.messageLogger( BasicValue.class );\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// incoming \"configuration\" values\n\n\tprivate String explicitTypeName;\n\tprivate Map<String,String> explicitLocalTypeParams;\n\n\tprivate Function<TypeConfiguration, BasicJavaType> explicitJavaTypeAccess;\n\tprivate Function<TypeConfiguration, JdbcType> explicitJdbcTypeAccess;\n\tprivate Function<TypeConfiguration, MutabilityPlan> explicitMutabilityPlanAccess;\n\tprivate Function<TypeConfiguration, java.lang.reflect.Type> implicitJavaTypeAccess;\n\n\tprivate EnumType enumerationStyle;\n\t@SuppressWarnings(\"deprecation\")\n\tprivate TemporalType temporalPrecision;\n\tprivate TimeZoneStorageType timeZoneStorageType;\n\tprivate boolean isSoftDelete;\n\tprivate SoftDeleteType softDeleteStrategy;\n\n\tprivate java.lang.reflect.Type resolvedJavaType;\n\n\tprivate String ownerName;\n\tprivate String propertyName;\n\tprivate AggregateColumn aggregateColumn;\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// Resolved state - available after `#resolve`\n\tprivate Resolution<?> resolution;\n\tprivate Integer jdbcTypeCode;\n\n\n\tpublic BasicValue(MetadataBuildingContext buildingContext) {\n\t\tthis( buildingContext, null );\n\t}\n\n\tpublic BasicValue(MetadataBuildingContext buildingContext, Table table) {\n\t\tsuper( buildingContext, table );\n\t\tbuildingContext.getMetadataCollector().registerValueMappingResolver( this::resolve );\n\t}\n\n\tpublic BasicValue(BasicValue original) {\n\t\tsuper( original );\n\t\tthis.explicitTypeName = original.explicitTypeName;\n\t\tthis.explicitLocalTypeParams = original.explicitLocalTypeParams == null\n\t\t\t\t? null\n\t\t\t\t: new HashMap<>(original.explicitLocalTypeParams);\n\t\tthis.explicitJavaTypeAccess = original.explicitJavaTypeAccess;\n\t\tthis.explicitJdbcTypeAccess = original.explicitJdbcTypeAccess;\n\t\tthis.explicitMutabilityPlanAccess = original.explicitMutabilityPlanAccess;\n\t\tthis.implicitJavaTypeAccess = original.implicitJavaTypeAccess;\n\t\tthis.enumerationStyle = original.enumerationStyle;\n\t\tthis.temporalPrecision = original.temporalPrecision;\n\t\tthis.timeZoneStorageType = original.timeZoneStorageType;\n\t\tthis.resolvedJavaType = original.resolvedJavaType;\n\t\tthis.ownerName = original.ownerName;\n\t\tthis.propertyName = original.propertyName;\n\t}\n\n\t@Override\n\tpublic BasicValue copy() {\n\t\treturn new BasicValue( this );\n\t}\n\n\tpublic boolean isSoftDelete() {\n\t\treturn isSoftDelete;\n\t}\n\n\tpublic SoftDeleteType getSoftDeleteStrategy() {\n\t\treturn softDeleteStrategy;\n\t}\n\n\tpublic void makeSoftDelete(SoftDeleteType strategy) {\n\t\tisSoftDelete = true;\n\t\tsoftDeleteStrategy = strategy;\n\t}\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// Setters - in preparation of resolution\n\n\t@Override\n\tpublic void setTypeUsingReflection(String className, String propertyName) throws MappingException {\n\t\tif ( resolution != null ) {\n\t\t\tthrow new IllegalStateException( \"BasicValue already resolved\" );\n\t\t}\n\n\t\tthis.ownerName = className;\n\t\tthis.propertyName = propertyName;\n\n\t\tsuper.setTypeUsingReflection( className, propertyName );\n\t}\n\n\tpublic void setEnumerationStyle(EnumType enumerationStyle) {\n\t\tthis.enumerationStyle = enumerationStyle;\n\t}\n\n\tpublic EnumType getEnumerationStyle() {\n\t\treturn enumerationStyle;\n\t}\n\n\tpublic TimeZoneStorageType getTimeZoneStorageType() {\n\t\treturn timeZoneStorageType;\n\t}\n\n\tpublic void setTimeZoneStorageType(TimeZoneStorageType timeZoneStorageType) {\n\t\tthis.timeZoneStorageType = timeZoneStorageType;\n\t}\n\n\tpublic void setJpaAttributeConverterDescriptor(ConverterDescriptor descriptor) {\n\t\tsetAttributeConverterDescriptor( descriptor );\n\n\t\tsuper.setJpaAttributeConverterDescriptor( descriptor );\n\t}\n\n\t@SuppressWarnings(\"rawtypes\")\n\tpublic void setExplicitJavaTypeAccess(Function<TypeConfiguration, BasicJavaType> explicitJavaTypeAccess) {\n\t\tthis.explicitJavaTypeAccess = explicitJavaTypeAccess;\n\t}\n\n\tpublic void setExplicitJdbcTypeAccess(Function<TypeConfiguration, JdbcType> jdbcTypeAccess) {\n\t\tthis.explicitJdbcTypeAccess = jdbcTypeAccess;\n\t}\n\n\tpublic void setExplicitMutabilityPlanAccess(Function<TypeConfiguration, MutabilityPlan> explicitMutabilityPlanAccess) {\n\t\tthis.explicitMutabilityPlanAccess = explicitMutabilityPlanAccess;\n\t}\n\n\tpublic void setImplicitJavaTypeAccess(Function<TypeConfiguration, java.lang.reflect.Type> implicitJavaTypeAccess) {\n\t\tthis.implicitJavaTypeAccess = implicitJavaTypeAccess;\n\t}\n\n\tpublic Selectable getColumn() {\n\t\tif ( getColumnSpan() == 0 ) {\n\t\t\treturn null;\n\t\t}\n\t\treturn getColumn( 0 );\n\t}\n\n\tpublic java.lang.reflect.Type getResolvedJavaType() {\n\t\treturn resolvedJavaType;\n\t}\n\n\t@Override\n\tpublic long getColumnLength() {\n\t\tfinal Selectable selectable = getColumn();\n\t\tif ( selectable instanceof Column column ) {\n\t\t\tfinal Long length = column.getLength();\n\t\t\treturn length == null ? NO_COLUMN_LENGTH : length;\n\t\t}\n\t\telse {\n\t\t\treturn NO_COLUMN_LENGTH;\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getColumnPrecision() {\n\t\tfinal Selectable selectable = getColumn();\n\t\tif ( selectable instanceof Column column ) {\n\t\t\tfinal Integer temporalPrecision = column.getTemporalPrecision();\n\t\t\tif ( temporalPrecision != null ) {\n\t\t\t\treturn temporalPrecision;\n\t\t\t}\n\t\t\tfinal Integer precision = column.getPrecision();\n\t\t\treturn precision == null ? NO_COLUMN_PRECISION : precision;\n\t\t}\n\t\telse {\n\t\t\treturn NO_COLUMN_PRECISION;\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getColumnScale() {\n\t\tfinal Selectable selectable = getColumn();\n\t\tif ( selectable instanceof Column column ) {\n\t\t\tfinal Integer scale = column.getScale();\n\t\t\treturn scale == null ? NO_COLUMN_SCALE : scale;\n\t\t}\n\t\telse {\n\t\t\treturn NO_COLUMN_SCALE;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void addColumn(Column incomingColumn) {\n\t\tsuper.addColumn( incomingColumn );\n\n\t\tcheckSelectable( incomingColumn );\n\t}\n\n\t@Override\n\tpublic void copyTypeFrom(SimpleValue sourceValue) {\n\t\tsuper.copyTypeFrom( sourceValue );\n\t\tif ( sourceValue instanceof BasicValue basicValue ) {\n\t\t\tresolution = basicValue.resolution;\n\t\t\timplicitJavaTypeAccess =\n\t\t\t\t\ttypeConfiguration -> basicValue.implicitJavaTypeAccess.apply( typeConfiguration );\n\t\t}\n\t}\n\n\tprivate void checkSelectable(Selectable incomingColumn) {\n\t\tif ( incomingColumn == null ) {\n\t\t\tthrow new IllegalArgumentException( \"Incoming column was null\" );\n\t\t}\n\n\t\tfinal Selectable column = getColumn();\n\t\tif ( column == incomingColumn || column.getText().equals( incomingColumn.getText() ) ) {\n\t\t\tlog.debugf( \"Skipping column re-registration: %s.%s\", getTable().getName(), column.getText() );\n\t\t}\n//\t\telse {\n//\t\t\tthrow new IllegalStateException(\n//\t\t\t\t\t\"BasicValue [\" + ownerName + \".\" + propertyName +\n//\t\t\t\t\t\t\t\"] already had column associated: `\" + column.getText() +\n//\t\t\t\t\t\t\t\"` -> `\" + incomingColumn.getText() + \"`\"\n//\t\t\t);\n//\t\t}\n\t}\n\n\t@Override\n\tpublic void addColumn(Column incomingColumn, boolean isInsertable, boolean isUpdatable) {\n\t\tsuper.addColumn( incomingColumn, isInsertable, isUpdatable );\n\t\tcheckSelectable( incomingColumn );\n\t}\n\n\t@Override\n\tpublic void addFormula(Formula formula) {\n\t\tsuper.addFormula( formula );\n\n\t\tcheckSelectable( formula );\n\t}\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// Resolution\n\n\t@Override\n\tpublic Type getType() throws MappingException {\n\t\tresolve();\n\t\tassert getResolution() != null;\n\n\t\treturn getResolution().getLegacyResolvedBasicType();\n\t}\n\n\tpublic Resolution<?> getResolution() {\n\t\treturn resolution;\n\t}\n\n\t@Override\n\tpublic boolean resolve(MetadataBuildingContext buildingContext) {\n\t\tresolve();\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic Resolution<?> resolve() {\n\t\tif ( resolution != null ) {\n\t\t\treturn resolution;\n\t\t}\n\n\t\tresolution = buildResolution();\n\n\t\tif ( resolution == null ) {\n\t\t\tthrow new IllegalStateException( \"Unable to resolve BasicValue : \" + this );\n\t\t}\n\n\t\tfinal Selectable selectable = getColumn();\n\t\tfinal Size size;\n\t\tif ( selectable instanceof Column column ) {\n\t\t\tresolveColumn( column, getDialect() );\n\t\t\tsize = column.calculateColumnSize( getDialect(), getBuildingContext().getMetadataCollector() );\n\t\t}\n\t\telse {\n\t\t\tsize = Size.nil();\n\t\t}\n\n\t\tresolution.getJdbcType().addAuxiliaryDatabaseObjects(\n\t\t\t\tresolution.getRelationalJavaType(),\n\t\t\t\tresolution.getValueConverter(),\n\t\t\t\tsize,\n\t\t\t\tgetBuildingContext().getMetadataCollector().getDatabase(),\n\t\t\t\tthis\n\t\t);\n\n\t\treturn resolution;\n\t}\n\n\t@Override\n\tpublic String getExtraCreateTableInfo() {\n\t\treturn resolution.getJdbcType()\n\t\t\t\t.getExtraCreateTableInfo(\n\t\t\t\t\t\tresolution.getRelationalJavaType(),\n\t\t\t\t\t\tgetColumn().getText(),\n\t\t\t\t\t\tgetTable().getName(),\n\t\t\t\t\t\tgetBuildingContext().getMetadataCollector().getDatabase()\n\t\t\t\t);\n\t}\n\n\t@Override\n\tpublic Dialect getDialect() {\n\t\treturn getMetadata().getDatabase().getDialect();\n\t}\n\n\tprivate void resolveColumn(Column column, Dialect dialect) {\n\n\t\tif ( column.getSqlTypeCode() == null ) {\n\t\t\tcolumn.setSqlTypeCode( resolution.getJdbcType().getDdlTypeCode() );\n\t\t}\n\n//\t\tfinal String declaration = resolution.getLegacyResolvedBasicType().getSpecializedTypeDeclaration( dialect );\n//\t\tif ( declaration != null ) {\n//\t\t\tcolumn.setSpecializedTypeDeclaration( declaration );\n//\t\t}\n\n\t\tif ( dialect.supportsColumnCheck() ) {\n\t\t\tfinal String checkCondition = resolution.getLegacyResolvedBasicType()\n\t\t\t\t\t.getCheckCondition( column.getQuotedName( dialect ), dialect );\n\t\t\tif ( checkCondition != null ) {\n\t\t\t\tcolumn.addCheckConstraint( new CheckConstraint( checkCondition ) );\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic AggregateColumn getAggregateColumn() {\n\t\treturn aggregateColumn;\n\t}\n\n\tpublic void setAggregateColumn(AggregateColumn aggregateColumn) {\n\t\tthis.aggregateColumn = aggregateColumn;\n\t}\n\n\tpublic SelectablePath createSelectablePath(String selectableName) {\n\t\tif ( aggregateColumn != null ) {\n\t\t\treturn aggregateColumn.getSelectablePath().append( selectableName );\n\t\t}\n\t\treturn new SelectablePath( selectableName );\n\t}\n\n\tprotected Resolution<?> buildResolution() {\n\t\tfinal Properties typeParameters = getTypeParameters();\n\t\tif ( typeParameters != null\n\t\t\t\t&& parseBoolean( typeParameters.getProperty(DynamicParameterizedType.IS_DYNAMIC) )\n\t\t\t\t&& typeParameters.get(DynamicParameterizedType.PARAMETER_TYPE) == null ) {\n\t\t\tcreateParameterImpl();\n\t\t}\n\n\t\tif ( explicitTypeName != null ) {\n\t\t\treturn interpretExplicitlyNamedType(\n\t\t\t\t\texplicitTypeName,\n\t\t\t\t\texplicitJavaTypeAccess,\n\t\t\t\t\texplicitJdbcTypeAccess,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tgetAttributeConverterDescriptor(),\n\t\t\t\t\ttypeParameters,\n\t\t\t\t\tthis::setTypeParameters,\n\t\t\t\t\tthis,\n\t\t\t\t\tgetBuildingContext()\n\t\t\t);\n\t\t}\n\t\telse if ( isVersion() ) {\n\t\t\treturn VersionResolution.from( implicitJavaTypeAccess, timeZoneStorageType, getBuildingContext() );\n\t\t}\n\t\telse {\n\t\t\t// determine JavaType if we can\n\t\t\tfinal BasicJavaType<?> explicitJavaType = getExplicitJavaType();\n\t\t\tfinal JavaType<?> javaType = determineJavaType( explicitJavaType );\n\t\t\tfinal ConverterDescriptor converterDescriptor = getConverterDescriptor( javaType );\n\t\t\treturn converterDescriptor != null\n\t\t\t\t\t? converterResolution( javaType, converterDescriptor )\n\t\t\t\t\t: resolution( explicitJavaType, javaType );\n\t\t}\n\t}\n\n\tprivate BasicJavaType<?> getExplicitJavaType() {\n\t\treturn explicitJavaTypeAccess == null ? null\n\t\t\t\t: explicitJavaTypeAccess.apply( getTypeConfiguration() );\n\t}\n\n\tprivate ConverterDescriptor getConverterDescriptor(JavaType<?> javaType) {\n\t\tfinal ConverterDescriptor converterDescriptor = getAttributeConverterDescriptor();\n\t\tif ( isSoftDelete() ) {\n\t\t\tassert converterDescriptor != null;\n\t\t\tfinal ConverterDescriptor softDeleteConverterDescriptor =\n\t\t\t\t\tgetSoftDeleteConverterDescriptor( converterDescriptor, javaType);\n\t\t\treturn getSoftDeleteStrategy() == SoftDeleteType.ACTIVE\n\t\t\t\t\t? new ReversedConverterDescriptor<>( softDeleteConverterDescriptor )\n\t\t\t\t\t: softDeleteConverterDescriptor;\n\t\t}\n\t\telse {\n\t\t\treturn converterDescriptor;\n\t\t}\n\t}\n\n\tprivate ConverterDescriptor getSoftDeleteConverterDescriptor(\n\t\t\tConverterDescriptor attributeConverterDescriptor, JavaType<?> javaType) {\n\t\tfinal boolean conversionWasUnspecified =\n\t\t\t\tSoftDelete.UnspecifiedConversion.class.equals( attributeConverterDescriptor.getAttributeConverterClass() );\n\t\tif ( conversionWasUnspecified ) {\n\t\t\tfinal JdbcType jdbcType = BooleanJdbcType.INSTANCE.resolveIndicatedType( this, javaType);\n\t\t\tif ( jdbcType.isNumber() ) {\n\t\t\t\treturn new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\tNumericBooleanConverter.INSTANCE,\n\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t);\n\t\t\t}\n\t\t\telse if ( jdbcType.isString() ) {\n\t\t\t\t// here we pick 'T' / 'F' storage, though 'Y' / 'N' is equally valid - its 50/50\n\t\t\t\treturn new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\tTrueFalseConverter.INSTANCE,\n\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// should indicate BIT or BOOLEAN == no conversion needed\n\t\t\t\t//\t\t- we still create the converter to properly set up JDBC type, etc\n\t\t\t\treturn new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\tPassThruSoftDeleteConverter.INSTANCE,\n\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn attributeConverterDescriptor;\n\t\t}\n\t}\n\n\tprivate static class ReversedConverterDescriptor<R> implements ConverterDescriptor {\n\t\tprivate final ConverterDescriptor underlyingDescriptor;\n\n\t\tpublic ReversedConverterDescriptor(ConverterDescriptor underlyingDescriptor) {\n\t\t\tthis.underlyingDescriptor = underlyingDescriptor;\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<? extends AttributeConverter<Boolean,R>> getAttributeConverterClass() {\n\t\t\t//noinspection unchecked\n\t\t\treturn (Class<? extends AttributeConverter<Boolean, R>>) getClass();\n\t\t}\n\n\t\t@Override\n\t\tpublic ResolvedType getDomainValueResolvedType() {\n\t\t\treturn underlyingDescriptor.getDomainValueResolvedType();\n\t\t}\n\n\t\t@Override\n\t\tpublic ResolvedType getRelationalValueResolvedType() {\n\t\t\treturn underlyingDescriptor.getRelationalValueResolvedType();\n\t\t}\n\n\t\t@Override\n\t\tpublic AutoApplicableConverterDescriptor getAutoApplyDescriptor() {\n\t\t\treturn AutoApplicableConverterDescriptorBypassedImpl.INSTANCE;\n\t\t}\n\n\t\t@Override\n\t\tpublic JpaAttributeConverter<Boolean,R> createJpaAttributeConverter(JpaAttributeConverterCreationContext context) {\n\t\t\t//noinspection unchecked\n\t\t\treturn new ReversedJpaAttributeConverter<>(\n\t\t\t\t\t(JpaAttributeConverter<Boolean, R>) underlyingDescriptor.createJpaAttributeConverter( context ),\n\t\t\t\t\tcontext.getJavaTypeRegistry().getDescriptor( ReversedJpaAttributeConverter.class )\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate static class ReversedJpaAttributeConverter<R, B extends AttributeConverter<Boolean, R>>\n\t\t\timplements JpaAttributeConverter<Boolean,R>, AttributeConverter<Boolean,R>, ManagedBean<B> {\n\t\tprivate final JpaAttributeConverter<Boolean,R> underlyingJpaConverter;\n\t\tprivate final JavaType<ReversedJpaAttributeConverter<R,B>> converterJavaType;\n\n\t\tpublic ReversedJpaAttributeConverter(\n\t\t\t\tJpaAttributeConverter<Boolean, R> underlyingJpaConverter,\n\t\t\t\tJavaType<ReversedJpaAttributeConverter<R,B>> converterJavaType) {\n\t\t\tthis.underlyingJpaConverter = underlyingJpaConverter;\n\t\t\tthis.converterJavaType = converterJavaType;\n\t\t}\n\n\t\t@Override\n\t\tpublic Boolean toDomainValue(R relationalValue) {\n\t\t\treturn !underlyingJpaConverter.toDomainValue( relationalValue );\n\t\t}\n\n\t\t@Override\n\t\tpublic R toRelationalValue(Boolean domainValue) {\n\t\t\treturn underlyingJpaConverter.toRelationalValue( domainValue != null ? !domainValue : null );\n\t\t}\n\n\t\t@Override\n\t\tpublic Boolean convertToEntityAttribute(R relationalValue) {\n\t\t\treturn toDomainValue( relationalValue );\n\t\t}\n\n\t\t@Override\n\t\tpublic R convertToDatabaseColumn(Boolean domainValue) {\n\t\t\treturn toRelationalValue( domainValue );\n\t\t}\n\n\t\t@Override\n\t\tpublic JavaType<Boolean> getDomainJavaType() {\n\t\t\treturn underlyingJpaConverter.getDomainJavaType();\n\t\t}\n\n\t\t@Override\n\t\tpublic JavaType<R> getRelationalJavaType() {\n\t\t\treturn underlyingJpaConverter.getRelationalJavaType();\n\t\t}\n\n\t\t@Override\n\t\tpublic JavaType<? extends AttributeConverter<Boolean, R>> getConverterJavaType() {\n\t\t\treturn converterJavaType;\n\t\t}\n\n\t\t@Override\n\t\tpublic ManagedBean<? extends AttributeConverter<Boolean, R>> getConverterBean() {\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<B> getBeanClass() {\n\t\t\t//noinspection unchecked\n\t\t\treturn (Class<B>) getClass();\n\t\t}\n\n\t\t@Override\n\t\tpublic B getBeanInstance() {\n\t\t\t//noinspection unchecked\n\t\t\treturn (B) this;\n\t\t}\n\t}\n\n\tprivate static class PassThruSoftDeleteConverter implements AttributeConverter<Boolean,Boolean> {\n\t\tprivate static final PassThruSoftDeleteConverter INSTANCE = new PassThruSoftDeleteConverter();\n\n\t\t@Override\n\t\tpublic Boolean convertToDatabaseColumn(Boolean domainValue) {\n\t\t\treturn domainValue;\n\t\t}\n\n\t\t@Override\n\t\tpublic Boolean convertToEntityAttribute(Boolean relationalValue) {\n\t\t\treturn relationalValue;\n\t\t}\n\t}\n\n\tprivate Resolution<?> resolution(BasicJavaType explicitJavaType, JavaType<?> javaType) {\n\t\tfinal JavaType<?> basicJavaType;\n\t\tfinal JdbcType jdbcType;\n\t\tif ( explicitJdbcTypeAccess != null ) {\n\t\t\tfinal TypeConfiguration typeConfiguration = getTypeConfiguration();\n\t\t\tjdbcType = explicitJdbcTypeAccess.apply( typeConfiguration );\n\t\t\tbasicJavaType = javaType == null && jdbcType != null\n\t\t\t\t\t? jdbcType.getJdbcRecommendedJavaTypeMapping(null, null, typeConfiguration)\n\t\t\t\t\t: javaType;\n\t\t}\n\t\telse {\n\t\t\tjdbcType = null;\n\t\t\tbasicJavaType = javaType;\n\t\t}\n\t\tif ( basicJavaType == null ) {\n\t\t\tthrow new MappingException( \"Unable to determine JavaType to use : \" + this );\n\t\t}\n\n\t\tif ( basicJavaType instanceof BasicJavaType<?>\n\t\t\t\t&& ( !basicJavaType.getJavaTypeClass().isEnum() || enumerationStyle == null ) ) {\n\t\t\tfinal TypeDefinition autoAppliedTypeDef =\n\t\t\t\t\tgetBuildingContext().getTypeDefinitionRegistry()\n\t\t\t\t\t\t\t.resolveAutoApplied( (BasicJavaType<?>) basicJavaType );\n\t\t\tif ( autoAppliedTypeDef != null ) {\n\t\t\t\tlog.debug(\"BasicValue resolution matched auto-applied type-definition\");\n\t\t\t\treturn autoAppliedTypeDef.resolve( getTypeParameters(), null, getBuildingContext(), this );\n\t\t\t}\n\t\t}\n\n\t\treturn InferredBasicValueResolver.from(\n\t\t\t\texplicitJavaType,\n\t\t\t\tjdbcType,\n\t\t\t\tresolvedJavaType,\n\t\t\t\tthis::determineReflectedJavaType,\n\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\tthis,\n\t\t\t\tgetTable(),\n\t\t\t\tgetColumn(),\n\t\t\t\townerName,\n\t\t\t\tpropertyName,\n\t\t\t\tgetBuildingContext()\n\t\t);\n\t}\n\n\t@Override\n\tpublic ManagedBeanRegistry getManagedBeanRegistry() {\n\t\treturn getServiceRegistry().requireService( ManagedBeanRegistry.class );\n\t}\n\n\tprivate Resolution<?> converterResolution(JavaType<?> javaType, ConverterDescriptor attributeConverterDescriptor) {\n\t\tfinal NamedConverterResolution<?> converterResolution = NamedConverterResolution.from(\n\t\t\t\tattributeConverterDescriptor,\n\t\t\t\texplicitJavaTypeAccess,\n\t\t\t\texplicitJdbcTypeAccess,\n\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\tresolvedJavaType,\n\t\t\t\tthis,\n\t\t\t\tthis,\n\t\t\t\tgetBuildingContext()\n\t\t);\n\n\t\tif ( javaType instanceof BasicPluralJavaType<?> containerJtd\n\t\t\t\t&& !attributeConverterDescriptor.getDomainValueResolvedType().getErasedType()\n\t\t\t\t\t\t.isAssignableFrom( javaType.getJavaTypeClass() ) ) {\n\t\t\t// In this case, the converter applies to the element of a BasicPluralJavaType\n\t\t\tfinal BasicType registeredElementType = converterResolution.getLegacyResolvedBasicType();\n\t\t\tfinal Selectable column = getColumn();\n\t\t\tfinal BasicType<?> registeredType = registeredElementType == null ? null\n\t\t\t\t\t: containerJtd.resolveType(\n\t\t\t\t\t\t\tgetTypeConfiguration(),\n\t\t\t\t\t\t\tgetDialect(),\n\t\t\t\t\t\t\tregisteredElementType,\n\t\t\t\t\t\t\tcolumn instanceof ColumnTypeInformation ? (ColumnTypeInformation) column : null,\n\t\t\t\t\t\t\tthis\n\t\t\t);\n\t\t\tif ( registeredType != null ) {\n\t\t\t\tgetTypeConfiguration().getBasicTypeRegistry().register( registeredType );\n\t\t\t\treturn new InferredBasicValueResolution(\n\t\t\t\t\t\tregisteredType,\n\t\t\t\t\t\tregisteredType.getJavaTypeDescriptor(),\n\t\t\t\t\t\tregisteredType.getJavaTypeDescriptor(),\n\t\t\t\t\t\tregisteredType.getJdbcType(),\n\t\t\t\t\t\tregisteredType,\n\t\t\t\t\t\tnull\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn converterResolution;\n\t}\n\n\tprivate JavaType<?> determineJavaType(JavaType<?> explicitJavaType) {\n\t\tJavaType<?> javaType = explicitJavaType;\n//\n//\t\tif ( javaType == null ) {\n//\t\t\tif ( implicitJavaTypeAccess != null ) {\n//\t\t\t\tfinal java.lang.reflect.Type implicitJtd = implicitJavaTypeAccess.apply( getTypeConfiguration() );\n//\t\t\t\tif ( implicitJtd != null ) {\n//\t\t\t\t\tjavaType = getTypeConfiguration().getJavaTypeRegistry().getDescriptor( implicitJtd );\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n\n\t\tif ( javaType == null ) {\n\t\t\tfinal JavaType<?> reflectedJtd = determineReflectedJavaType();\n\t\t\tif ( reflectedJtd != null ) {\n\t\t\t\tjavaType = reflectedJtd;\n\t\t\t}\n\t\t}\n\n\t\treturn javaType;\n\t}\n\n\tprivate JavaType<?> determineReflectedJavaType() {\n\t\tfinal TypeConfiguration typeConfiguration = getTypeConfiguration();\n\t\tfinal java.lang.reflect.Type impliedJavaType = impliedJavaType( typeConfiguration );\n\t\tif ( impliedJavaType == null ) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tresolvedJavaType = impliedJavaType;\n\t\t\treturn javaType( typeConfiguration, impliedJavaType );\n\t\t}\n\t}\n\n\tprivate java.lang.reflect.Type impliedJavaType(TypeConfiguration typeConfiguration) {\n\t\tif ( resolvedJavaType != null ) {\n\t\t\treturn resolvedJavaType;\n\t\t}\n\t\telse if ( implicitJavaTypeAccess != null ) {\n\t\t\treturn implicitJavaTypeAccess.apply(typeConfiguration);\n\t\t}\n\t\telse if ( ownerName != null && propertyName != null ) {\n\t\t\treturn reflectedPropertyType( ownerName, propertyName,\n\t\t\t\t\tgetServiceRegistry().requireService( ClassLoaderService.class ) );\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate JavaType<Object> javaType(TypeConfiguration typeConfiguration, java.lang.reflect.Type impliedJavaType) {\n\t\tfinal JavaType<Object> javaType = typeConfiguration.getJavaTypeRegistry().findDescriptor( impliedJavaType );\n\t\treturn javaType == null ? specialJavaType( typeConfiguration, impliedJavaType ) : javaType;\n\t}\n\n\tprivate JavaType<Object> specialJavaType(\n\t\t\tTypeConfiguration typeConfiguration,\n\t\t\tjava.lang.reflect.Type impliedJavaType) {\n\t\tfinal JavaTypeRegistry javaTypeRegistry = typeConfiguration.getJavaTypeRegistry();\n\t\tif ( jdbcTypeCode != null ) {\n\t\t\t// Construct special JavaType instances for JSON/XML types which can report recommended JDBC types\n\t\t\t// and implement toString/fromString as well as copying based on FormatMapper operations\n\t\t\tswitch ( jdbcTypeCode ) {\n\t\t\t\tcase SqlTypes.JSON:\n\t\t\t\t\tfinal JavaType<Object> jsonJavaType =\n\t\t\t\t\t\t\tnew JsonJavaType<>( impliedJavaType,\n\t\t\t\t\t\t\t\t\tmutabilityPlan( typeConfiguration, impliedJavaType ),\n\t\t\t\t\t\t\t\t\ttypeConfiguration );\n\t\t\t\t\tjavaTypeRegistry.addDescriptor( jsonJavaType );\n\t\t\t\t\treturn jsonJavaType;\n\t\t\t\tcase SqlTypes.SQLXML:\n\t\t\t\t\tfinal JavaType<Object> xmlJavaType =\n\t\t\t\t\t\t\tnew XmlJavaType<>( impliedJavaType,\n\t\t\t\t\t\t\t\t\tmutabilityPlan( typeConfiguration, impliedJavaType ),\n\t\t\t\t\t\t\t\t\ttypeConfiguration );\n\t\t\t\t\tjavaTypeRegistry.addDescriptor( xmlJavaType );\n\t\t\t\t\treturn xmlJavaType;\n\t\t\t}\n\t\t}\n\t\treturn javaTypeRegistry.resolveDescriptor( impliedJavaType );\n\t}\n\n\tprivate MutabilityPlan<Object> mutabilityPlan(\n\t\t\tTypeConfiguration typeConfiguration, java.lang.reflect.Type impliedJavaType) {\n\t\tfinal MutabilityPlan<Object> explicitMutabilityPlan = getExplicitMutabilityPlan();\n\t\treturn explicitMutabilityPlan != null\n\t\t\t\t? explicitMutabilityPlan\n\t\t\t\t: RegistryHelper.INSTANCE.determineMutabilityPlan( impliedJavaType, typeConfiguration );\n\t}\n\n\tprivate MutabilityPlan<Object> getExplicitMutabilityPlan() {\n\t\treturn explicitMutabilityPlanAccess == null ? null\n\t\t\t\t: explicitMutabilityPlanAccess.apply( getTypeConfiguration()  );\n\t}\n\n\tprivate static Resolution<?> interpretExplicitlyNamedType(\n\t\t\tString name,\n\t\t\tFunction<TypeConfiguration, BasicJavaType> explicitJtdAccess,\n\t\t\tFunction<TypeConfiguration, JdbcType> explicitStdAccess,\n\t\t\tFunction<TypeConfiguration, MutabilityPlan> explicitMutabilityPlanAccess,\n\t\t\tConverterDescriptor converterDescriptor,\n\t\t\tMap<Object,Object> localTypeParams,\n\t\t\tConsumer<Properties> combinedParameterConsumer,\n\t\t\tJdbcTypeIndicators stdIndicators,\n\t\t\tMetadataBuildingContext context) {\n\n\t\tfinal StandardServiceRegistry serviceRegistry = context.getBootstrapContext().getServiceRegistry();\n\t\tfinal ManagedBeanRegistry managedBeanRegistry = serviceRegistry.requireService( ManagedBeanRegistry.class );\n\t\tfinal TypeConfiguration typeConfiguration = context.getBootstrapContext().getTypeConfiguration();\n\n\t\tfinal JpaAttributeConverterCreationContext converterCreationContext = new JpaAttributeConverterCreationContext() {\n\t\t\t@Override\n\t\t\tpublic ManagedBeanRegistry getManagedBeanRegistry() {\n\t\t\t\treturn managedBeanRegistry;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic TypeConfiguration getTypeConfiguration() {\n\t\t\t\treturn typeConfiguration;\n\t\t\t}\n\t\t};\n\n\t\t// Name could refer to:\n\t\t//\t\t1) a named converter - HBM support for JPA's AttributeConverter via its `type=\"...\"` XML attribute\n\t\t//\t\t2) a \"named composed\" mapping - like (1), this is mainly to support envers since it tells\n\t\t//\t\t\tHibernate the mappings via DOM.  See `org.hibernate.type.internal.BasicTypeImpl`\n\t\t//\t\t3) basic type \"resolution key\"\n\t\t//\t\t4) UserType or BasicType class name - directly, or through a TypeDefinition\n\n\t\tif ( name.startsWith( ConverterDescriptor.TYPE_NAME_PREFIX  ) ) {\n\t\t\treturn NamedConverterResolution.from(\n\t\t\t\t\tname,\n\t\t\t\t\texplicitJtdAccess,\n\t\t\t\t\texplicitStdAccess,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tstdIndicators,\n\t\t\t\t\tconverterCreationContext,\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\n//\t\tif ( name.startsWith( EnumeratedValueResolution.PREFIX ) ) {\n//\t\t\treturn EnumeratedValueResolution.fromName( name, stdIndicators, context );\n//\t\t}\n\n\t\tif ( name.startsWith( BasicTypeImpl.EXTERNALIZED_PREFIX ) ) {\n\t\t\tfinal BasicType<Object> basicType = context.getBootstrapContext().resolveAdHocBasicType( name );\n\t\t\treturn new NamedBasicTypeResolution<>(\n\t\t\t\t\tbasicType.getJavaTypeDescriptor(),\n\t\t\t\t\tbasicType,\n\t\t\t\t\tnull,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\n\t\t// see if it is a named basic type\n\t\tfinal BasicType<?> basicTypeByName = typeConfiguration.getBasicTypeRegistry().getRegisteredType( name );\n\t\tif ( basicTypeByName != null ) {\n\t\t\tfinal BasicValueConverter<?,?> valueConverter;\n\t\t\tfinal JavaType<?> domainJtd;\n\t\t\tif ( converterDescriptor != null ) {\n\t\t\t\tvalueConverter = converterDescriptor.createJpaAttributeConverter( converterCreationContext );\n\t\t\t\tdomainJtd = valueConverter.getDomainJavaType();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalueConverter = basicTypeByName.getValueConverter();\n\t\t\t\tdomainJtd = basicTypeByName.getJavaTypeDescriptor();\n\t\t\t}\n\n\t\t\treturn new NamedBasicTypeResolution<>(\n\t\t\t\t\tdomainJtd,\n\t\t\t\t\tbasicTypeByName,\n\t\t\t\t\tvalueConverter,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\n\t\t// see if it is a named TypeDefinition\n\t\tfinal TypeDefinition typeDefinition = context.getTypeDefinitionRegistry().resolve( name );\n\t\tif ( typeDefinition != null ) {\n\t\t\tfinal Resolution<?> resolution = typeDefinition.resolve(\n\t\t\t\t\tlocalTypeParams,\n\t\t\t\t\texplicitMutabilityPlanAccess != null\n\t\t\t\t\t\t\t? explicitMutabilityPlanAccess.apply( typeConfiguration )\n\t\t\t\t\t\t\t: null,\n\t\t\t\t\tcontext,\n\t\t\t\t\tstdIndicators\n\t\t\t);\n\t\t\tcombinedParameterConsumer.accept( resolution.getCombinedTypeParameters() );\n\t\t\treturn resolution;\n\t\t}\n\n\n\t\t// see if the name is a UserType or BasicType implementor class name\n\t\tfinal ClassLoaderService cls = serviceRegistry.requireService( ClassLoaderService.class );\n\t\ttry {\n\t\t\tfinal Class<?> typeNamedClass = cls.classForName( name );\n\n\t\t\t// if there are no local config params, register an implicit TypeDefinition for this custom type .\n\t\t\t//  later uses may find it and re-use its cacheable reference...\n\t\t\tif ( CollectionHelper.isEmpty( localTypeParams ) ) {\n\t\t\t\tfinal TypeDefinition implicitDefinition = new TypeDefinition(\n\t\t\t\t\t\tname,\n\t\t\t\t\t\ttypeNamedClass,\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\tnull\n\t\t\t\t);\n\t\t\t\tcontext.getTypeDefinitionRegistry().register( implicitDefinition );\n\t\t\t\treturn implicitDefinition.resolve(\n\t\t\t\t\t\tlocalTypeParams,\n\t\t\t\t\t\texplicitMutabilityPlanAccess != null\n\t\t\t\t\t\t\t\t? explicitMutabilityPlanAccess.apply( typeConfiguration )\n\t\t\t\t\t\t\t\t: null,\n\t\t\t\t\t\tcontext,\n\t\t\t\t\t\tstdIndicators\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn TypeDefinition.createLocalResolution( name, typeNamedClass, localTypeParams, context );\n\t\t}\n\t\tcatch (ClassLoadingException e) {\n\t\t\t// allow the exception below to trigger\n\t\t\tlog.debugf( \"Could not resolve type-name [%s] as Java type : %s\", name, e );\n\t\t}\n\n\t\tthrow new MappingException( \"Could not resolve named type : \" + name );\n\t}\n\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// SqlTypeDescriptorIndicators\n\n\t@Override\n\tpublic EnumType getEnumeratedType() {\n\t\treturn getEnumerationStyle();\n\t}\n\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForBoolean() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForBoolean() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForDuration() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForDuration() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForUuid() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForUuid() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForInstant() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForInstant() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForArray() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForArray() );\n\t}\n\n\t@Override\n\tpublic int resolveJdbcTypeCode(int jdbcTypeCode) {\n\t\treturn aggregateColumn == null\n\t\t\t\t? jdbcTypeCode\n\t\t\t\t: getDialect().getAggregateSupport()\n\t\t\t\t.aggregateComponentSqlTypeCode( aggregateColumn.getSqlTypeCode( getMetadata() ), jdbcTypeCode );\n\t}\n\n\t@Override\n\tpublic TimeZoneStorageStrategy getDefaultTimeZoneStorageStrategy() {\n\t\treturn timeZoneStorageStrategy( timeZoneStorageType, getBuildingContext() );\n\t}\n\n\t@Internal\n\tpublic static TimeZoneStorageStrategy timeZoneStorageStrategy(\n\t\t\tTimeZoneStorageType timeZoneStorageType,\n\t\t\tMetadataBuildingContext buildingContext) {\n\t\tif ( timeZoneStorageType != null ) {\n\t\t\tswitch ( timeZoneStorageType ) {\n\t\t\t\tcase COLUMN:\n\t\t\t\t\treturn TimeZoneStorageStrategy.COLUMN;\n\t\t\t\tcase NATIVE:\n\t\t\t\t\treturn TimeZoneStorageStrategy.NATIVE;\n\t\t\t\tcase NORMALIZE:\n\t\t\t\t\treturn TimeZoneStorageStrategy.NORMALIZE;\n\t\t\t\tcase NORMALIZE_UTC:\n\t\t\t\t\treturn TimeZoneStorageStrategy.NORMALIZE_UTC;\n\t\t\t}\n\t\t}\n\t\treturn buildingContext.getBuildingOptions().getDefaultTimeZoneStorage();\n\t}\n\n\tpublic void setExplicitTypeParams(Map<String,String> explicitLocalTypeParams) {\n\t\tthis.explicitLocalTypeParams = explicitLocalTypeParams;\n\t}\n\n\tpublic void setExplicitTypeName(String typeName) {\n\t\tthis.explicitTypeName = typeName;\n\t}\n\n\tpublic void setTypeName(String typeName) {\n\t\tif ( StringHelper.isNotEmpty( typeName ) ) {\n\t\t\tif ( typeName.startsWith( ConverterDescriptor.TYPE_NAME_PREFIX ) ) {\n\t\t\t\tfinal String converterClassName = typeName.substring( ConverterDescriptor.TYPE_NAME_PREFIX.length() );\n\t\t\t\tfinal ClassLoaderService cls = getServiceRegistry().requireService( ClassLoaderService.class );\n\t\t\t\ttry {\n\t\t\t\t\tfinal Class<AttributeConverter<?,?>> converterClass = cls.classForName( converterClassName );\n\t\t\t\t\tsetAttributeConverterDescriptor( new ClassBasedConverterDescriptor(\n\t\t\t\t\t\t\tconverterClass,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t\t) );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tlog.logBadHbmAttributeConverterType( typeName, e.getMessage() );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsetExplicitTypeName( typeName );\n\t\t\t}\n\t\t}\n\n\t\tsuper.setTypeName( typeName );\n\t}\n\n\tprivate static int COUNTER;\n\n\tpublic void setExplicitCustomType(Class<? extends UserType<?>> explicitCustomType) {\n\t\tif ( explicitCustomType != null ) {\n\t\t\tif ( resolution != null ) {\n\t\t\t\tthrow new UnsupportedOperationException( \"Unsupported attempt to set an explicit-custom-type when value is already resolved\" );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresolution = new UserTypeResolution<>(\n\t\t\t\t\t\tnew CustomType<>(\n\t\t\t\t\t\t\t\tgetConfiguredUserTypeBean( explicitCustomType, getCustomTypeProperties() ),\n\t\t\t\t\t\t\t\tgetTypeConfiguration()\n\t\t\t\t\t\t),\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\tgetCustomTypeProperties()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate Properties getCustomTypeProperties() {\n\t\tfinal Properties properties = new Properties();\n\t\tif ( isNotEmpty( getTypeParameters() ) ) {\n\t\t\tproperties.putAll( getTypeParameters() );\n\t\t}\n\t\tif ( isNotEmpty( explicitLocalTypeParams ) ) {\n\t\t\tproperties.putAll( explicitLocalTypeParams );\n\t\t}\n\t\treturn properties;\n\t}\n\n\tprivate UserType<?> getConfiguredUserTypeBean(Class<? extends UserType<?>> explicitCustomType, Properties properties) {\n\t\tfinal UserType<?> typeInstance =\n\t\t\t\t!getBuildingContext().getBuildingOptions().isAllowExtensionsInCdi()\n\t\t\t\t\t\t? FallbackBeanInstanceProducer.INSTANCE.produceBeanInstance( explicitCustomType )\n\t\t\t\t\t\t: getUserTypeBean( explicitCustomType, properties ).getBeanInstance();\n\n\t\tif ( typeInstance instanceof TypeConfigurationAware configurationAware ) {\n\t\t\tconfigurationAware.setTypeConfiguration( getTypeConfiguration() );\n\t\t}\n\n\t\tif ( typeInstance instanceof DynamicParameterizedType ) {\n\t\t\tif ( parseBoolean( properties.getProperty( DynamicParameterizedType.IS_DYNAMIC ) ) ) {\n\t\t\t\tif ( properties.get( DynamicParameterizedType.PARAMETER_TYPE ) == null ) {\n\t\t\t\t\tproperties.put( DynamicParameterizedType.PARAMETER_TYPE, makeParameterImpl() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tinjectParameters( typeInstance, properties);\n\t\t// envers - grr\n\t\tsetTypeParameters( properties );\n\n\t\treturn typeInstance;\n\t}\n\n\tprivate <T> ManagedBean<T> getUserTypeBean(Class<T> explicitCustomType, Properties properties) {\n\t\tfinal BeanInstanceProducer producer = getBuildingContext().getBootstrapContext().getCustomTypeProducer();\n\t\tfinal ManagedBeanRegistry registry = getServiceRegistry().requireService( ManagedBeanRegistry.class );\n\t\tif ( isNotEmpty( properties ) ) {\n\t\t\tfinal String name = explicitCustomType.getName() + COUNTER++;\n\t\t\treturn registry.getBean( name, explicitCustomType, producer );\n\t\t}\n\t\telse {\n\t\t\treturn registry.getBean( explicitCustomType, producer );\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"deprecation\")\n\tpublic void setTemporalPrecision(TemporalType temporalPrecision) {\n\t\tthis.temporalPrecision = temporalPrecision;\n\t}\n\n\t@Override @SuppressWarnings(\"deprecation\")\n\tpublic TemporalType getTemporalPrecision() {\n\t\treturn temporalPrecision;\n\t}\n\n\t@Override\n\tpublic boolean isPreferJavaTimeJdbcTypesEnabled() {\n\t\treturn getBuildingContext().isPreferJavaTimeJdbcTypesEnabled();\n\t}\n\n\t@Override\n\tpublic boolean isPreferNativeEnumTypesEnabled() {\n\t\treturn getBuildingContext().isPreferNativeEnumTypesEnabled();\n\t}\n\n\t@Override\n\tpublic Object accept(ValueVisitor visitor) {\n\t\treturn visitor.accept(this);\n\t}\n\n\t@Internal\n\tpublic boolean isDisallowedWrapperArray() {\n\t\treturn getBuildingContext().getBuildingOptions().getWrapperArrayHandling() == WrapperArrayHandling.DISALLOW\n\t\t\t&& !isLob()\n\t\t\t&& ( explicitJavaTypeAccess == null || explicitJavaTypeAccess.apply( getTypeConfiguration() ) == null )\n\t\t\t&& isWrapperByteOrCharacterArray();\n\t}\n\n\tprivate boolean isWrapperByteOrCharacterArray() {\n\t\tfinal Class<?> javaTypeClass = getResolution().getDomainJavaType().getJavaTypeClass();\n\t\treturn javaTypeClass == Byte[].class || javaTypeClass == Character[].class;\n\t}\n\n\t@Incubating\n\tpublic void setExplicitJdbcTypeCode(Integer jdbcTypeCode) {\n\t\tthis.jdbcTypeCode = jdbcTypeCode;\n\t}\n\n\t@Override\n\tpublic Integer getExplicitJdbcTypeCode() {\n\t\treturn jdbcTypeCode == null ? getPreferredSqlTypeCodeForArray() : jdbcTypeCode;\n\t}\n\n\t/**\n\t * Resolved form of {@link BasicValue} as part of interpreting the\n\t * boot-time model into the run-time model\n\t */\n\tpublic interface Resolution<J> {\n\t\t/**\n\t\t * The BasicType resolved using the pre-6.0 rules.  This is temporarily\n\t\t * needed because of the split in extracting / binding\n\t\t */\n\t\tBasicType<J> getLegacyResolvedBasicType();\n\n\t\t/**\n\t\t * Get the collection of type-parameters collected both locally as well\n\t\t * as from the applied type-def, if one\n\t\t */\n\t\tdefault Properties getCombinedTypeParameters() {\n\t\t\treturn null;\n\t\t}\n\n\t\tJdbcMapping getJdbcMapping();\n\n\t\t/**\n\t\t * The JavaType for the value as part of the domain model\n\t\t */\n\t\tJavaType<J> getDomainJavaType();\n\n\t\t/**\n\t\t * The JavaType for the relational value as part of\n\t\t * the relational model (its JDBC representation)\n\t\t */\n\t\tJavaType<?> getRelationalJavaType();\n\n\t\t/**\n\t\t * The JavaType for the relational value as part of\n\t\t * the relational model (its JDBC representation)\n\t\t */\n\t\tJdbcType getJdbcType();\n\n\t\t/**\n\t\t * Converter, if any, to convert values between the\n\t\t * domain and relational JavaType representations\n\t\t */\n\t\tBasicValueConverter<J,?> getValueConverter();\n\n\t\t/**\n\t\t * The resolved MutabilityPlan\n\t\t */\n\t\tMutabilityPlan<J> getMutabilityPlan();\n\n\t\tdefault void updateResolution(BasicType<?> type) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private JavaType<Object> javaType(TypeConfiguration typeConfiguration, java.lang.reflect.Type impliedJavaType) {\n\t\tfinal JavaType<Object> javaType = typeConfiguration.getJavaTypeRegistry().findDescriptor( impliedJavaType );\n\t\treturn javaType == null ? specialJavaType( typeConfiguration, impliedJavaType ) : javaType;\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.type.spi.TypeConfiguration#getJavaTypeRegistry\n methodBody: public JavaTypeRegistry getJavaTypeRegistry() {\nreturn javaTypeRegistry;\n}",
            "methodSignature: org.hibernate.type.spi.TypeConfiguration.Scope#getTypeConfiguration\n methodBody: public TypeConfiguration getTypeConfiguration() {\nreturn typeConfiguration;\n}",
            "methodSignature: org.hibernate.type.spi.TypeConfiguration.Scope#getServiceRegistry\n methodBody: private ServiceRegistry getServiceRegistry() {\nif(metadataBuildingContext != null){return metadataBuildingContext.getBootstrapContext().getServiceRegistry();\n}if(sessionFactory != null){return sessionFactory.getServiceRegistry();\n}{return null;\n}}",
            "methodSignature: org.hibernate.type.spi.TypeConfiguration#getServiceRegistry\n methodBody: public ServiceRegistry getServiceRegistry() {\nreturn scope.getServiceRegistry();\n}"
        ],
        "sourceCodeAfterRefactoring": "private JavaType<?> determineReflectedJavaType() {\n\t\tfinal TypeConfiguration typeConfiguration = getTypeConfiguration();\n\t\tfinal java.lang.reflect.Type impliedJavaType = impliedJavaType( typeConfiguration );\n\t\tif ( impliedJavaType == null ) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tresolvedJavaType = impliedJavaType;\n\t\t\treturn javaType( typeConfiguration, impliedJavaType );\n\t\t}\n\t}\nprivate JavaType<Object> javaType(TypeConfiguration typeConfiguration, java.lang.reflect.Type impliedJavaType) {\n\t\tfinal JavaType<Object> javaType = typeConfiguration.getJavaTypeRegistry().findDescriptor( impliedJavaType );\n\t\treturn javaType == null ? specialJavaType( typeConfiguration, impliedJavaType ) : javaType;\n\t}",
        "diffSourceCode": "-  731: \tprivate JavaType<?> determineReflectedJavaType() {\n-  732: \t\tfinal java.lang.reflect.Type impliedJavaType;\n-  733: \n-  734: \t\tfinal TypeConfiguration typeConfiguration = getTypeConfiguration();\n-  735: \t\tif ( resolvedJavaType != null ) {\n-  736: \t\t\timpliedJavaType = resolvedJavaType;\n-  737: \t\t}\n-  738: \t\telse if ( implicitJavaTypeAccess != null ) {\n-  739: \t\t\timpliedJavaType = implicitJavaTypeAccess.apply( typeConfiguration );\n+  731: //\t\t\t\t}\n+  732: //\t\t\t}\n+  733: //\t\t}\n+  734: \n+  735: \t\tif ( javaType == null ) {\n+  736: \t\t\tfinal JavaType<?> reflectedJtd = determineReflectedJavaType();\n+  737: \t\t\tif ( reflectedJtd != null ) {\n+  738: \t\t\t\tjavaType = reflectedJtd;\n+  739: \t\t\t}\n   740: \t\t}\n-  741: \t\telse if ( ownerName != null && propertyName != null ) {\n-  742: \t\t\timpliedJavaType = ReflectHelper.reflectedPropertyType(\n-  743: \t\t\t\t\townerName,\n-  744: \t\t\t\t\tpropertyName,\n-  745: \t\t\t\t\tgetServiceRegistry().requireService( ClassLoaderService.class )\n-  746: \t\t\t);\n-  747: \t\t}\n-  748: \t\telse {\n+  741: \n+  742: \t\treturn javaType;\n+  743: \t}\n+  744: \n+  745: \tprivate JavaType<?> determineReflectedJavaType() {\n+  746: \t\tfinal TypeConfiguration typeConfiguration = getTypeConfiguration();\n+  747: \t\tfinal java.lang.reflect.Type impliedJavaType = impliedJavaType( typeConfiguration );\n+  748: \t\tif ( impliedJavaType == null ) {\n   749: \t\t\treturn null;\n   750: \t\t}\n-  751: \n-  752: \t\tresolvedJavaType = impliedJavaType;\n-  753: \n-  754: \t\tif ( impliedJavaType == null ) {\n-  755: \t\t\treturn null;\n-  756: \t\t}\n-  757: \n-  758: \t\tfinal JavaTypeRegistry javaTypeRegistry = typeConfiguration.getJavaTypeRegistry();\n-  759: \t\tfinal JavaType<Object> javaType = javaTypeRegistry.findDescriptor( impliedJavaType );\n-  760: \t\tfinal MutabilityPlan<Object> explicitMutabilityPlan = explicitMutabilityPlanAccess != null\n-  761: \t\t\t\t? explicitMutabilityPlanAccess.apply( typeConfiguration )\n-  762: \t\t\t\t: null;\n-  763: \t\tfinal MutabilityPlan<Object> determinedMutabilityPlan = explicitMutabilityPlan != null\n-  764: \t\t\t\t? explicitMutabilityPlan\n-  765: \t\t\t\t: RegistryHelper.INSTANCE.determineMutabilityPlan( impliedJavaType, typeConfiguration );\n-  766: \t\tif ( javaType == null ) {\n-  767: \t\t\tif ( jdbcTypeCode != null ) {\n-  768: \t\t\t\t// Construct special JavaType instances for JSON/XML types which can report recommended JDBC types\n-  769: \t\t\t\t// and implement toString/fromString as well as copying based on FormatMapper operations\n-  770: \t\t\t\tswitch ( jdbcTypeCode ) {\n-  771: \t\t\t\t\tcase SqlTypes.JSON:\n-  772: \t\t\t\t\t\tfinal JavaType<Object> jsonJavaType = new JsonJavaType<>(\n-  773: \t\t\t\t\t\t\t\timpliedJavaType,\n-  774: \t\t\t\t\t\t\t\tdeterminedMutabilityPlan,\n-  775: \t\t\t\t\t\t\t\ttypeConfiguration\n-  776: \t\t\t\t\t\t);\n-  777: \t\t\t\t\t\tjavaTypeRegistry.addDescriptor( jsonJavaType );\n-  778: \t\t\t\t\t\treturn jsonJavaType;\n-  779: \t\t\t\t\tcase SqlTypes.SQLXML:\n-  780: \t\t\t\t\t\tfinal JavaType<Object> xmlJavaType = new XmlJavaType<>(\n-  781: \t\t\t\t\t\t\t\timpliedJavaType,\n-  782: \t\t\t\t\t\t\t\tdeterminedMutabilityPlan,\n-  783: \t\t\t\t\t\t\t\ttypeConfiguration\n-  784: \t\t\t\t\t\t);\n-  785: \t\t\t\t\t\tjavaTypeRegistry.addDescriptor( xmlJavaType );\n-  786: \t\t\t\t\t\treturn xmlJavaType;\n-  787: \t\t\t\t}\n-  788: \t\t\t}\n-  789: \t\t\treturn javaTypeRegistry.resolveDescriptor( impliedJavaType );\n-  790: \t\t}\n-  791: \t\treturn javaType;\n-  792: \t}\n+  751: \t\telse {\n+  752: \t\t\tresolvedJavaType = impliedJavaType;\n+  753: \t\t\treturn javaType( typeConfiguration, impliedJavaType );\n+  754: \t\t}\n+  755: \t}\n+  756: \n+  757: \tprivate java.lang.reflect.Type impliedJavaType(TypeConfiguration typeConfiguration) {\n+  758: \t\tif ( resolvedJavaType != null ) {\n+  759: \t\t\treturn resolvedJavaType;\n+  760: \t\t}\n+  761: \t\telse if ( implicitJavaTypeAccess != null ) {\n+  762: \t\t\treturn implicitJavaTypeAccess.apply(typeConfiguration);\n+  763: \t\t}\n+  764: \t\telse if ( ownerName != null && propertyName != null ) {\n+  765: \t\t\treturn reflectedPropertyType( ownerName, propertyName,\n+  766: \t\t\t\t\tgetServiceRegistry().requireService( ClassLoaderService.class ) );\n+  767: \t\t}\n+  768: \t\telse {\n+  769: \t\t\treturn null;\n+  770: \t\t}\n+  771: \t}\n+  772: \n+  773: \tprivate JavaType<Object> javaType(TypeConfiguration typeConfiguration, java.lang.reflect.Type impliedJavaType) {\n+  774: \t\tfinal JavaType<Object> javaType = typeConfiguration.getJavaTypeRegistry().findDescriptor( impliedJavaType );\n+  775: \t\treturn javaType == null ? specialJavaType( typeConfiguration, impliedJavaType ) : javaType;\n+  776: \t}\n+  777: \n+  778: \tprivate JavaType<Object> specialJavaType(\n+  779: \t\t\tTypeConfiguration typeConfiguration,\n+  780: \t\t\tjava.lang.reflect.Type impliedJavaType) {\n+  781: \t\tfinal JavaTypeRegistry javaTypeRegistry = typeConfiguration.getJavaTypeRegistry();\n+  782: \t\tif ( jdbcTypeCode != null ) {\n+  783: \t\t\t// Construct special JavaType instances for JSON/XML types which can report recommended JDBC types\n+  784: \t\t\t// and implement toString/fromString as well as copying based on FormatMapper operations\n+  785: \t\t\tswitch ( jdbcTypeCode ) {\n+  786: \t\t\t\tcase SqlTypes.JSON:\n+  787: \t\t\t\t\tfinal JavaType<Object> jsonJavaType =\n+  788: \t\t\t\t\t\t\tnew JsonJavaType<>( impliedJavaType,\n+  789: \t\t\t\t\t\t\t\t\tmutabilityPlan( typeConfiguration, impliedJavaType ),\n+  790: \t\t\t\t\t\t\t\t\ttypeConfiguration );\n+  791: \t\t\t\t\tjavaTypeRegistry.addDescriptor( jsonJavaType );\n+  792: \t\t\t\t\treturn jsonJavaType;\n",
        "uniqueId": "6c6c92e88d4535be020b4acb3d81f96df39a65d8_731_792_773_776_745_755",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 0,
                "covered": 19
            },
            "BRANCH": {
                "missed": 0,
                "covered": 2
            },
            "LINE": {
                "missed": 0,
                "covered": 6
            },
            "COMPLEXITY": {
                "missed": 0,
                "covered": 2
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": true,
        "refactoredCode": "##########################\nprivate JavaType<?> determineReflectedJavaType() {\n    final java.lang.reflect.Type impliedJavaType;\n\n    final TypeConfiguration typeConfiguration = getTypeConfiguration();\n    if (resolvedJavaType != null) {\n        impliedJavaType = resolvedJavaType;\n    } else if (implicitJavaTypeAccess != null) {\n        impliedJavaType = implicitJavaTypeAccess.apply(typeConfiguration);\n    } else if (ownerName != null && propertyName != null) {\n        impliedJavaType = ReflectHelper.reflectedPropertyType(\n                ownerName,\n                propertyName,\n                getServiceRegistry().requireService(ClassLoaderService.class)\n        );\n    } else {\n        return null;\n    }\n\n    resolvedJavaType = impliedJavaType;\n\n    if (impliedJavaType == null) {\n        return null;\n    }\n\n    final JavaTypeRegistry javaTypeRegistry = typeConfiguration.getJavaTypeRegistry();\n    final JavaType<Object> javaType = javaTypeRegistry.findDescriptor(impliedJavaType);\n    final MutabilityPlan<Object> explicitMutabilityPlan = explicitMutabilityPlanAccess != null\n            ? explicitMutabilityPlanAccess.apply(typeConfiguration)\n            : null;\n    final MutabilityPlan<Object> determinedMutabilityPlan = explicitMutabilityPlan != null\n            ? explicitMutabilityPlan\n            : RegistryHelper.INSTANCE.determineMutabilityPlan(impliedJavaType, typeConfiguration);\n    if (javaType == null) {\n        if (jdbcTypeCode != null) {\n            // Construct special JavaType instances for JSON/XML types which can report recommended JDBC types\n            // and implement toString/fromString as well as copying based on FormatMapper operations\n            switch (jdbcTypeCode) {\n                case SqlTypes.JSON:\n                    final JavaType<Object> jsonJavaType = new JsonJavaType<>(\n                            impliedJavaType,\n                            determinedMutabilityPlan,\n                            typeConfiguration\n                    );\n                    javaTypeRegistry.addDescriptor(jsonJavaType);\n                    return jsonJavaType;\n                case SqlTypes.SQLXML:\n                    final JavaType<Object> xmlJavaType = new XmlJavaType<>(\n                            impliedJavaType,\n                            determinedMutabilityPlan,\n                            typeConfiguration\n                    );\n                    javaTypeRegistry.addDescriptor(xmlJavaType);\n                    return xmlJavaType;\n            }\n        }\n        return javaTypeRegistry.resolveDescriptor(impliedJavaType);\n    }\n    return javaType;\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprivate JavaType<?> determineReflectedJavaType() {\n\t\tfinal java.lang.reflect.Type impliedJavaType;\n\n\t\tfinal TypeConfiguration typeConfiguration = getTypeConfiguration();\n\t\tif ( resolvedJavaType != null ) {\n\t\t\timpliedJavaType = resolvedJavaType;\n\t\t}\n\t\telse if ( implicitJavaTypeAccess != null ) {\n\t\t\timpliedJavaType = implicitJavaTypeAccess.apply( typeConfiguration );\n\t\t}\n\t\telse if ( ownerName != null && propertyName != null ) {\n\t\t\timpliedJavaType = ReflectHelper.reflectedPropertyType(\n\t\t\t\t\townerName,\n\t\t\t\t\tpropertyName,\n\t\t\t\t\tgetServiceRegistry().requireService( ClassLoaderService.class )\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\n\t\tresolvedJavaType = impliedJavaType;\n\n\t\tif ( impliedJavaType == null ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal JavaTypeRegistry javaTypeRegistry = typeConfiguration.getJavaTypeRegistry();\n\t\tfinal JavaType<Object> javaType = javaTypeRegistry.findDescriptor( impliedJavaType );\n\t\tfinal MutabilityPlan<Object> explicitMutabilityPlan = explicitMutabilityPlanAccess != null\n\t\t\t\t? explicitMutabilityPlanAccess.apply( typeConfiguration )\n\t\t\t\t: null;\n\t\tfinal MutabilityPlan<Object> determinedMutabilityPlan = explicitMutabilityPlan != null\n\t\t\t\t? explicitMutabilityPlan\n\t\t\t\t: RegistryHelper.INSTANCE.determineMutabilityPlan( impliedJavaType, typeConfiguration );\n\t\tif ( javaType == null ) {\n\t\t\tif ( jdbcTypeCode != null ) {\n\t\t\t\t// Construct special JavaType instances for JSON/XML types which can report recommended JDBC types\n\t\t\t\t// and implement toString/fromString as well as copying based on FormatMapper operations\n\t\t\t\tswitch ( jdbcTypeCode ) {\n\t\t\t\t\tcase SqlTypes.JSON:\n\t\t\t\t\t\tfinal JavaType<Object> jsonJavaType = new JsonJavaType<>(\n\t\t\t\t\t\t\t\timpliedJavaType,\n\t\t\t\t\t\t\t\tdeterminedMutabilityPlan,\n\t\t\t\t\t\t\t\ttypeConfiguration\n\t\t\t\t\t\t);\n\t\t\t\t\t\tjavaTypeRegistry.addDescriptor( jsonJavaType );\n\t\t\t\t\t\treturn jsonJavaType;\n\t\t\t\t\tcase SqlTypes.SQLXML:\n\t\t\t\t\t\tfinal JavaType<Object> xmlJavaType = new XmlJavaType<>(\n\t\t\t\t\t\t\t\timpliedJavaType,\n\t\t\t\t\t\t\t\tdeterminedMutabilityPlan,\n\t\t\t\t\t\t\t\ttypeConfiguration\n\t\t\t\t\t\t);\n\t\t\t\t\t\tjavaTypeRegistry.addDescriptor( xmlJavaType );\n\t\t\t\t\t\treturn xmlJavaType;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn javaTypeRegistry.resolveDescriptor( impliedJavaType );\n\t\t}\n\t\treturn javaType;\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.mapping;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\n\nimport org.hibernate.Incubating;\nimport org.hibernate.Internal;\nimport org.hibernate.MappingException;\nimport org.hibernate.TimeZoneStorageStrategy;\nimport org.hibernate.annotations.SoftDelete;\nimport org.hibernate.annotations.SoftDeleteType;\nimport org.hibernate.annotations.TimeZoneStorageType;\nimport org.hibernate.boot.model.TypeDefinition;\nimport org.hibernate.boot.model.convert.internal.AutoApplicableConverterDescriptorBypassedImpl;\nimport org.hibernate.boot.model.convert.internal.ClassBasedConverterDescriptor;\nimport org.hibernate.boot.model.convert.internal.InstanceBasedConverterDescriptor;\nimport org.hibernate.boot.model.convert.spi.AutoApplicableConverterDescriptor;\nimport org.hibernate.boot.model.convert.spi.ConverterDescriptor;\nimport org.hibernate.boot.model.convert.spi.JpaAttributeConverterCreationContext;\nimport org.hibernate.boot.model.process.internal.InferredBasicValueResolution;\nimport org.hibernate.boot.model.process.internal.InferredBasicValueResolver;\nimport org.hibernate.boot.model.process.internal.NamedBasicTypeResolution;\nimport org.hibernate.boot.model.process.internal.NamedConverterResolution;\nimport org.hibernate.boot.model.process.internal.UserTypeResolution;\nimport org.hibernate.boot.model.process.internal.VersionResolution;\nimport org.hibernate.boot.registry.StandardServiceRegistry;\nimport org.hibernate.boot.registry.classloading.spi.ClassLoaderService;\nimport org.hibernate.boot.registry.classloading.spi.ClassLoadingException;\nimport org.hibernate.boot.spi.MetadataBuildingContext;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.jdbc.Size;\nimport org.hibernate.internal.CoreLogging;\nimport org.hibernate.internal.CoreMessageLogger;\nimport org.hibernate.internal.util.ReflectHelper;\nimport org.hibernate.internal.util.StringHelper;\nimport org.hibernate.internal.util.collections.CollectionHelper;\nimport org.hibernate.metamodel.mapping.JdbcMapping;\nimport org.hibernate.metamodel.mapping.SelectablePath;\nimport org.hibernate.resource.beans.internal.FallbackBeanInstanceProducer;\nimport org.hibernate.resource.beans.spi.BeanInstanceProducer;\nimport org.hibernate.resource.beans.spi.ManagedBean;\nimport org.hibernate.resource.beans.spi.ManagedBeanRegistry;\nimport org.hibernate.tool.schema.extract.spi.ColumnTypeInformation;\nimport org.hibernate.type.BasicType;\nimport org.hibernate.type.CustomType;\nimport org.hibernate.type.NumericBooleanConverter;\nimport org.hibernate.type.SqlTypes;\nimport org.hibernate.type.TrueFalseConverter;\nimport org.hibernate.type.Type;\nimport org.hibernate.type.WrapperArrayHandling;\nimport org.hibernate.type.descriptor.converter.spi.BasicValueConverter;\nimport org.hibernate.type.descriptor.converter.spi.JpaAttributeConverter;\nimport org.hibernate.type.descriptor.java.BasicJavaType;\nimport org.hibernate.type.descriptor.java.BasicPluralJavaType;\nimport org.hibernate.type.descriptor.java.JavaType;\nimport org.hibernate.type.descriptor.java.MutabilityPlan;\nimport org.hibernate.type.descriptor.java.spi.JavaTypeRegistry;\nimport org.hibernate.type.descriptor.java.spi.JsonJavaType;\nimport org.hibernate.type.descriptor.java.spi.RegistryHelper;\nimport org.hibernate.type.descriptor.java.spi.XmlJavaType;\nimport org.hibernate.type.descriptor.jdbc.BooleanJdbcType;\nimport org.hibernate.type.descriptor.jdbc.JdbcType;\nimport org.hibernate.type.descriptor.jdbc.JdbcTypeIndicators;\nimport org.hibernate.type.internal.BasicTypeImpl;\nimport org.hibernate.type.spi.TypeConfiguration;\nimport org.hibernate.type.spi.TypeConfigurationAware;\nimport org.hibernate.usertype.DynamicParameterizedType;\nimport org.hibernate.usertype.UserType;\n\nimport com.fasterxml.classmate.ResolvedType;\nimport jakarta.persistence.AttributeConverter;\nimport jakarta.persistence.EnumType;\nimport jakarta.persistence.TemporalType;\n\nimport static java.lang.Boolean.parseBoolean;\nimport static org.hibernate.internal.util.collections.CollectionHelper.isNotEmpty;\nimport static org.hibernate.mapping.MappingHelper.injectParameters;\n\n/**\n * @author Steve Ebersole\n */\npublic class BasicValue extends SimpleValue implements JdbcTypeIndicators, Resolvable, JpaAttributeConverterCreationContext {\n\tprivate static final CoreMessageLogger log = CoreLogging.messageLogger( BasicValue.class );\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// incoming \"configuration\" values\n\n\tprivate String explicitTypeName;\n\tprivate Map<String,String> explicitLocalTypeParams;\n\n\tprivate Function<TypeConfiguration, BasicJavaType> explicitJavaTypeAccess;\n\tprivate Function<TypeConfiguration, JdbcType> explicitJdbcTypeAccess;\n\tprivate Function<TypeConfiguration, MutabilityPlan> explicitMutabilityPlanAccess;\n\tprivate Function<TypeConfiguration, java.lang.reflect.Type> implicitJavaTypeAccess;\n\n\tprivate EnumType enumerationStyle;\n\tprivate TemporalType temporalPrecision;\n\tprivate TimeZoneStorageType timeZoneStorageType;\n\tprivate boolean isSoftDelete;\n\tprivate SoftDeleteType softDeleteStrategy;\n\n\tprivate java.lang.reflect.Type resolvedJavaType;\n\n\tprivate String ownerName;\n\tprivate String propertyName;\n\tprivate AggregateColumn aggregateColumn;\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// Resolved state - available after `#resolve`\n\tprivate Resolution<?> resolution;\n\tprivate Integer jdbcTypeCode;\n\n\n\tpublic BasicValue(MetadataBuildingContext buildingContext) {\n\t\tthis( buildingContext, null );\n\t}\n\n\tpublic BasicValue(MetadataBuildingContext buildingContext, Table table) {\n\t\tsuper( buildingContext, table );\n\t\tbuildingContext.getMetadataCollector().registerValueMappingResolver( this::resolve );\n\t}\n\n\tpublic BasicValue(BasicValue original) {\n\t\tsuper( original );\n\t\tthis.explicitTypeName = original.explicitTypeName;\n\t\tthis.explicitLocalTypeParams = original.explicitLocalTypeParams == null\n\t\t\t\t? null\n\t\t\t\t: new HashMap<>(original.explicitLocalTypeParams);\n\t\tthis.explicitJavaTypeAccess = original.explicitJavaTypeAccess;\n\t\tthis.explicitJdbcTypeAccess = original.explicitJdbcTypeAccess;\n\t\tthis.explicitMutabilityPlanAccess = original.explicitMutabilityPlanAccess;\n\t\tthis.implicitJavaTypeAccess = original.implicitJavaTypeAccess;\n\t\tthis.enumerationStyle = original.enumerationStyle;\n\t\tthis.temporalPrecision = original.temporalPrecision;\n\t\tthis.timeZoneStorageType = original.timeZoneStorageType;\n\t\tthis.resolvedJavaType = original.resolvedJavaType;\n\t\tthis.ownerName = original.ownerName;\n\t\tthis.propertyName = original.propertyName;\n\t}\n\n\t@Override\n\tpublic BasicValue copy() {\n\t\treturn new BasicValue( this );\n\t}\n\n\tpublic boolean isSoftDelete() {\n\t\treturn isSoftDelete;\n\t}\n\n\tpublic SoftDeleteType getSoftDeleteStrategy() {\n\t\treturn softDeleteStrategy;\n\t}\n\n\tpublic void makeSoftDelete(SoftDeleteType strategy) {\n\t\tisSoftDelete = true;\n\t\tsoftDeleteStrategy = strategy;\n\t}\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// Setters - in preparation of resolution\n\n\t@Override\n\tpublic void setTypeUsingReflection(String className, String propertyName) throws MappingException {\n\t\tif ( resolution != null ) {\n\t\t\tthrow new IllegalStateException( \"BasicValue already resolved\" );\n\t\t}\n\n\t\tthis.ownerName = className;\n\t\tthis.propertyName = propertyName;\n\n\t\tsuper.setTypeUsingReflection( className, propertyName );\n\t}\n\n\tpublic void setEnumerationStyle(EnumType enumerationStyle) {\n\t\tthis.enumerationStyle = enumerationStyle;\n\t}\n\n\tpublic EnumType getEnumerationStyle() {\n\t\treturn enumerationStyle;\n\t}\n\n\tpublic TimeZoneStorageType getTimeZoneStorageType() {\n\t\treturn timeZoneStorageType;\n\t}\n\n\tpublic void setTimeZoneStorageType(TimeZoneStorageType timeZoneStorageType) {\n\t\tthis.timeZoneStorageType = timeZoneStorageType;\n\t}\n\n\tpublic void setJpaAttributeConverterDescriptor(ConverterDescriptor descriptor) {\n\t\tsetAttributeConverterDescriptor( descriptor );\n\n\t\tsuper.setJpaAttributeConverterDescriptor( descriptor );\n\t}\n\n\t@SuppressWarnings(\"rawtypes\")\n\tpublic void setExplicitJavaTypeAccess(Function<TypeConfiguration, BasicJavaType> explicitJavaTypeAccess) {\n\t\tthis.explicitJavaTypeAccess = explicitJavaTypeAccess;\n\t}\n\n\tpublic void setExplicitJdbcTypeAccess(Function<TypeConfiguration, JdbcType> jdbcTypeAccess) {\n\t\tthis.explicitJdbcTypeAccess = jdbcTypeAccess;\n\t}\n\n\tpublic void setExplicitMutabilityPlanAccess(Function<TypeConfiguration, MutabilityPlan> explicitMutabilityPlanAccess) {\n\t\tthis.explicitMutabilityPlanAccess = explicitMutabilityPlanAccess;\n\t}\n\n\tpublic void setImplicitJavaTypeAccess(Function<TypeConfiguration, java.lang.reflect.Type> implicitJavaTypeAccess) {\n\t\tthis.implicitJavaTypeAccess = implicitJavaTypeAccess;\n\t}\n\n\tpublic Selectable getColumn() {\n\t\tif ( getColumnSpan() == 0 ) {\n\t\t\treturn null;\n\t\t}\n\t\treturn getColumn( 0 );\n\t}\n\n\tpublic java.lang.reflect.Type getResolvedJavaType() {\n\t\treturn resolvedJavaType;\n\t}\n\n\t@Override\n\tpublic long getColumnLength() {\n\t\tfinal Selectable selectable = getColumn();\n\t\tif ( selectable instanceof Column ) {\n\t\t\tfinal Column column = (Column) selectable;\n\t\t\tfinal Long length = column.getLength();\n\t\t\treturn length == null ? NO_COLUMN_LENGTH : length;\n\t\t}\n\t\telse {\n\t\t\treturn NO_COLUMN_LENGTH;\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getColumnPrecision() {\n\t\tfinal Selectable selectable = getColumn();\n\t\tif ( selectable instanceof Column ) {\n\t\t\tfinal Column column = (Column) selectable;\n\t\t\tif ( column.getTemporalPrecision() != null ) {\n\t\t\t\treturn column.getTemporalPrecision();\n\t\t\t}\n\t\t\tfinal Integer precision = column.getPrecision();\n\t\t\treturn precision == null ? NO_COLUMN_PRECISION : precision;\n\t\t}\n\t\telse {\n\t\t\treturn NO_COLUMN_PRECISION;\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getColumnScale() {\n\t\tfinal Selectable selectable = getColumn();\n\t\tif ( selectable instanceof Column ) {\n\t\t\tfinal Column column = (Column) selectable;\n\t\t\tfinal Integer scale = column.getScale();\n\t\t\treturn scale == null ? NO_COLUMN_SCALE : scale;\n\t\t}\n\t\telse {\n\t\t\treturn NO_COLUMN_SCALE;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void addColumn(Column incomingColumn) {\n\t\tsuper.addColumn( incomingColumn );\n\n\t\tcheckSelectable( incomingColumn );\n\t}\n\n\t@Override\n\tpublic void copyTypeFrom(SimpleValue sourceValue) {\n\t\tsuper.copyTypeFrom( sourceValue );\n\t\tif ( sourceValue instanceof BasicValue ) {\n\t\t\tfinal BasicValue basicValue = (BasicValue) sourceValue;\n\t\t\tthis.resolution = basicValue.resolution;\n\t\t\tthis.implicitJavaTypeAccess = (typeConfiguration) -> basicValue.implicitJavaTypeAccess.apply( typeConfiguration );\n\t\t}\n\t}\n\n\tprivate void checkSelectable(Selectable incomingColumn) {\n\t\tif ( incomingColumn == null ) {\n\t\t\tthrow new IllegalArgumentException( \"Incoming column was null\" );\n\t\t}\n\n\t\tfinal Selectable column = getColumn();\n\t\tif ( column == incomingColumn || column.getText().equals( incomingColumn.getText() ) ) {\n\t\t\tlog.debugf( \"Skipping column re-registration: %s.%s\", getTable().getName(), column.getText() );\n\t\t}\n//\t\telse {\n//\t\t\tthrow new IllegalStateException(\n//\t\t\t\t\t\"BasicValue [\" + ownerName + \".\" + propertyName +\n//\t\t\t\t\t\t\t\"] already had column associated: `\" + column.getText() +\n//\t\t\t\t\t\t\t\"` -> `\" + incomingColumn.getText() + \"`\"\n//\t\t\t);\n//\t\t}\n\t}\n\n\t@Override\n\tpublic void addColumn(Column incomingColumn, boolean isInsertable, boolean isUpdatable) {\n\t\tsuper.addColumn( incomingColumn, isInsertable, isUpdatable );\n\t\tcheckSelectable( incomingColumn );\n\t}\n\n\t@Override\n\tpublic void addFormula(Formula formula) {\n\t\tsuper.addFormula( formula );\n\n\t\tcheckSelectable( formula );\n\t}\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// Resolution\n\n\t@Override\n\tpublic Type getType() throws MappingException {\n\t\tresolve();\n\t\tassert getResolution() != null;\n\n\t\treturn getResolution().getLegacyResolvedBasicType();\n\t}\n\n\tpublic Resolution<?> getResolution() {\n\t\treturn resolution;\n\t}\n\n\t@Override\n\tpublic boolean resolve(MetadataBuildingContext buildingContext) {\n\t\tresolve();\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic Resolution<?> resolve() {\n\t\tif ( resolution != null ) {\n\t\t\treturn resolution;\n\t\t}\n\n\t\tresolution = buildResolution();\n\n\t\tif ( resolution == null ) {\n\t\t\tthrow new IllegalStateException( \"Unable to resolve BasicValue : \" + this );\n\t\t}\n\n\t\tfinal Selectable selectable = getColumn();\n\t\tfinal Size size;\n\t\tif ( selectable instanceof Column column ) {\n\t\t\tresolveColumn( column, getDialect() );\n\t\t\tsize = column.calculateColumnSize( getDialect(), getBuildingContext().getMetadataCollector() );\n\t\t}\n\t\telse {\n\t\t\tsize = Size.nil();\n\t\t}\n\n\t\tresolution.getJdbcType().addAuxiliaryDatabaseObjects(\n\t\t\t\tresolution.getRelationalJavaType(),\n\t\t\t\tresolution.getValueConverter(),\n\t\t\t\tsize,\n\t\t\t\tgetBuildingContext().getMetadataCollector().getDatabase(),\n\t\t\t\tthis\n\t\t);\n\n\t\treturn resolution;\n\t}\n\n\t@Override\n\tpublic String getExtraCreateTableInfo() {\n\t\treturn resolution.getJdbcType()\n\t\t\t\t.getExtraCreateTableInfo(\n\t\t\t\t\t\tresolution.getRelationalJavaType(),\n\t\t\t\t\t\tgetColumn().getText(),\n\t\t\t\t\t\tgetTable().getName(),\n\t\t\t\t\t\tgetBuildingContext().getMetadataCollector().getDatabase()\n\t\t\t\t);\n\t}\n\n\t@Override\n\tpublic Dialect getDialect() {\n\t\treturn getMetadata().getDatabase().getDialect();\n\t}\n\n\tprivate void resolveColumn(Column column, Dialect dialect) {\n\n\t\tif ( column.getSqlTypeCode() == null ) {\n\t\t\tcolumn.setSqlTypeCode( resolution.getJdbcType().getDdlTypeCode() );\n\t\t}\n\n//\t\tfinal String declaration = resolution.getLegacyResolvedBasicType().getSpecializedTypeDeclaration( dialect );\n//\t\tif ( declaration != null ) {\n//\t\t\tcolumn.setSpecializedTypeDeclaration( declaration );\n//\t\t}\n\n\t\tif ( dialect.supportsColumnCheck() ) {\n\t\t\tfinal String checkCondition = resolution.getLegacyResolvedBasicType()\n\t\t\t\t\t.getCheckCondition( column.getQuotedName( dialect ), dialect );\n\t\t\tif ( checkCondition != null ) {\n\t\t\t\tcolumn.addCheckConstraint( new CheckConstraint( checkCondition ) );\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic AggregateColumn getAggregateColumn() {\n\t\treturn aggregateColumn;\n\t}\n\n\tpublic void setAggregateColumn(AggregateColumn aggregateColumn) {\n\t\tthis.aggregateColumn = aggregateColumn;\n\t}\n\n\tpublic SelectablePath createSelectablePath(String selectableName) {\n\t\tif ( aggregateColumn != null ) {\n\t\t\treturn aggregateColumn.getSelectablePath().append( selectableName );\n\t\t}\n\t\treturn new SelectablePath( selectableName );\n\t}\n\n\tprotected Resolution<?> buildResolution() {\n\t\tfinal Properties typeParameters = getTypeParameters();\n\t\tif ( typeParameters != null\n\t\t\t\t&& parseBoolean( typeParameters.getProperty(DynamicParameterizedType.IS_DYNAMIC) )\n\t\t\t\t&& typeParameters.get(DynamicParameterizedType.PARAMETER_TYPE) == null ) {\n\t\t\tcreateParameterImpl();\n\t\t}\n\n\t\tif ( explicitTypeName != null ) {\n\t\t\treturn interpretExplicitlyNamedType(\n\t\t\t\t\texplicitTypeName,\n\t\t\t\t\texplicitJavaTypeAccess,\n\t\t\t\t\texplicitJdbcTypeAccess,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tgetAttributeConverterDescriptor(),\n\t\t\t\t\ttypeParameters,\n\t\t\t\t\tthis::setTypeParameters,\n\t\t\t\t\tthis,\n\t\t\t\t\tgetBuildingContext()\n\t\t\t);\n\t\t}\n\n\t\tif ( isVersion() ) {\n\t\t\treturn VersionResolution.from( implicitJavaTypeAccess, timeZoneStorageType, getBuildingContext() );\n\t\t}\n\n\t\t// determine JavaType if we can\n\t\tfinal BasicJavaType<?> explicitJavaType = explicitJavaTypeAccess == null\n\t\t\t\t? null\n\t\t\t\t: explicitJavaTypeAccess.apply( getTypeConfiguration() );\n\n\t\tJavaType<?> javaType = determineJavaType( explicitJavaType );\n\t\tConverterDescriptor attributeConverterDescriptor = getAttributeConverterDescriptor();\n\n\t\tif ( isSoftDelete() ) {\n\t\t\tassert attributeConverterDescriptor != null;\n\t\t\tfinal boolean conversionWasUnspecified = SoftDelete.UnspecifiedConversion.class.equals( attributeConverterDescriptor.getAttributeConverterClass() );\n\t\t\tif ( conversionWasUnspecified ) {\n\t\t\t\tfinal JdbcType jdbcType = BooleanJdbcType.INSTANCE.resolveIndicatedType( this, javaType );\n\t\t\t\tif ( jdbcType.isNumber() ) {\n\t\t\t\t\tattributeConverterDescriptor = new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\t\tNumericBooleanConverter.INSTANCE,\n\t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\telse if ( jdbcType.isString() ) {\n\t\t\t\t\t// here we pick 'T' / 'F' storage, though 'Y' / 'N' is equally valid - its 50/50\n\t\t\t\t\tattributeConverterDescriptor = new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\t\tTrueFalseConverter.INSTANCE,\n\t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// should indicate BIT or BOOLEAN == no conversion needed\n\t\t\t\t\t//\t\t- we still create the converter to properly set up JDBC type, etc\n\t\t\t\t\tattributeConverterDescriptor = new InstanceBasedConverterDescriptor(\n\t\t\t\t\t\t\tPassThruSoftDeleteConverter.INSTANCE,\n\t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( getSoftDeleteStrategy() == SoftDeleteType.ACTIVE ) {\n\t\t\t\tattributeConverterDescriptor = new ReversedConverterDescriptor<>( attributeConverterDescriptor );\n\t\t\t}\n\t\t}\n\n\t\treturn attributeConverterDescriptor != null\n\t\t\t\t? converterResolution( javaType, attributeConverterDescriptor )\n\t\t\t\t: resolution( explicitJavaType, javaType );\n\t}\n\n\tprivate static class ReversedConverterDescriptor<R> implements ConverterDescriptor {\n\t\tprivate final ConverterDescriptor underlyingDescriptor;\n\n\t\tpublic ReversedConverterDescriptor(ConverterDescriptor underlyingDescriptor) {\n\t\t\tthis.underlyingDescriptor = underlyingDescriptor;\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<? extends AttributeConverter<Boolean,R>> getAttributeConverterClass() {\n\t\t\t//noinspection unchecked\n\t\t\treturn (Class<? extends AttributeConverter<Boolean, R>>) getClass();\n\t\t}\n\n\t\t@Override\n\t\tpublic ResolvedType getDomainValueResolvedType() {\n\t\t\treturn underlyingDescriptor.getDomainValueResolvedType();\n\t\t}\n\n\t\t@Override\n\t\tpublic ResolvedType getRelationalValueResolvedType() {\n\t\t\treturn underlyingDescriptor.getRelationalValueResolvedType();\n\t\t}\n\n\t\t@Override\n\t\tpublic AutoApplicableConverterDescriptor getAutoApplyDescriptor() {\n\t\t\treturn AutoApplicableConverterDescriptorBypassedImpl.INSTANCE;\n\t\t}\n\n\t\t@Override\n\t\tpublic JpaAttributeConverter<Boolean,R> createJpaAttributeConverter(JpaAttributeConverterCreationContext context) {\n\t\t\t//noinspection unchecked\n\t\t\treturn new ReversedJpaAttributeConverter<>(\n\t\t\t\t\t(JpaAttributeConverter<Boolean, R>) underlyingDescriptor.createJpaAttributeConverter( context ),\n\t\t\t\t\tcontext.getJavaTypeRegistry().getDescriptor( ReversedJpaAttributeConverter.class )\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate static class ReversedJpaAttributeConverter<R, B extends AttributeConverter<Boolean, R>>\n\t\t\timplements JpaAttributeConverter<Boolean,R>, AttributeConverter<Boolean,R>, ManagedBean<B> {\n\t\tprivate final JpaAttributeConverter<Boolean,R> underlyingJpaConverter;\n\t\tprivate final JavaType<ReversedJpaAttributeConverter<R,B>> converterJavaType;\n\n\t\tpublic ReversedJpaAttributeConverter(\n\t\t\t\tJpaAttributeConverter<Boolean, R> underlyingJpaConverter,\n\t\t\t\tJavaType<ReversedJpaAttributeConverter<R,B>> converterJavaType) {\n\t\t\tthis.underlyingJpaConverter = underlyingJpaConverter;\n\t\t\tthis.converterJavaType = converterJavaType;\n\t\t}\n\n\t\t@Override\n\t\tpublic Boolean toDomainValue(R relationalValue) {\n\t\t\treturn !underlyingJpaConverter.toDomainValue( relationalValue );\n\t\t}\n\n\t\t@Override\n\t\tpublic R toRelationalValue(Boolean domainValue) {\n\t\t\treturn underlyingJpaConverter.toRelationalValue( domainValue != null ? !domainValue : null );\n\t\t}\n\n\t\t@Override\n\t\tpublic Boolean convertToEntityAttribute(R relationalValue) {\n\t\t\treturn toDomainValue( relationalValue );\n\t\t}\n\n\t\t@Override\n\t\tpublic R convertToDatabaseColumn(Boolean domainValue) {\n\t\t\treturn toRelationalValue( domainValue );\n\t\t}\n\n\t\t@Override\n\t\tpublic JavaType<Boolean> getDomainJavaType() {\n\t\t\treturn underlyingJpaConverter.getDomainJavaType();\n\t\t}\n\n\t\t@Override\n\t\tpublic JavaType<R> getRelationalJavaType() {\n\t\t\treturn underlyingJpaConverter.getRelationalJavaType();\n\t\t}\n\n\t\t@Override\n\t\tpublic JavaType<? extends AttributeConverter<Boolean, R>> getConverterJavaType() {\n\t\t\treturn converterJavaType;\n\t\t}\n\n\t\t@Override\n\t\tpublic ManagedBean<? extends AttributeConverter<Boolean, R>> getConverterBean() {\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<B> getBeanClass() {\n\t\t\t//noinspection unchecked\n\t\t\treturn (Class<B>) getClass();\n\t\t}\n\n\t\t@Override\n\t\tpublic B getBeanInstance() {\n\t\t\t//noinspection unchecked\n\t\t\treturn (B) this;\n\t\t}\n\t}\n\n\tprivate static class PassThruSoftDeleteConverter implements AttributeConverter<Boolean,Boolean> {\n\t\tprivate static final PassThruSoftDeleteConverter INSTANCE = new PassThruSoftDeleteConverter();\n\n\t\t@Override\n\t\tpublic Boolean convertToDatabaseColumn(Boolean domainValue) {\n\t\t\treturn domainValue;\n\t\t}\n\n\t\t@Override\n\t\tpublic Boolean convertToEntityAttribute(Boolean relationalValue) {\n\t\t\treturn relationalValue;\n\t\t}\n\t}\n\n\tprivate Resolution<?> resolution(BasicJavaType explicitJavaType, JavaType<?> javaType) {\n\t\tfinal JavaType<?> basicJavaType;\n\t\tfinal JdbcType jdbcType;\n\t\tif ( explicitJdbcTypeAccess != null ) {\n\t\t\tfinal TypeConfiguration typeConfiguration = getTypeConfiguration();\n\t\t\tjdbcType = explicitJdbcTypeAccess.apply( typeConfiguration );\n\t\t\tbasicJavaType = javaType == null && jdbcType != null\n\t\t\t\t\t? jdbcType.getJdbcRecommendedJavaTypeMapping(null, null, typeConfiguration)\n\t\t\t\t\t: javaType;\n\t\t}\n\t\telse {\n\t\t\tjdbcType = null;\n\t\t\tbasicJavaType = javaType;\n\t\t}\n\t\tif ( basicJavaType == null ) {\n\t\t\tthrow new MappingException( \"Unable to determine JavaType to use : \" + this );\n\t\t}\n\n\t\tif ( basicJavaType instanceof BasicJavaType<?>\n\t\t\t\t&& ( !basicJavaType.getJavaTypeClass().isEnum() || enumerationStyle == null ) ) {\n\t\t\tfinal TypeDefinition autoAppliedTypeDef =\n\t\t\t\t\tgetBuildingContext().getTypeDefinitionRegistry()\n\t\t\t\t\t\t\t.resolveAutoApplied( (BasicJavaType<?>) basicJavaType );\n\t\t\tif ( autoAppliedTypeDef != null ) {\n\t\t\t\tlog.debug(\"BasicValue resolution matched auto-applied type-definition\");\n\t\t\t\treturn autoAppliedTypeDef.resolve( getTypeParameters(), null, getBuildingContext(), this );\n\t\t\t}\n\t\t}\n\n\t\treturn InferredBasicValueResolver.from(\n\t\t\t\texplicitJavaType,\n\t\t\t\tjdbcType,\n\t\t\t\tresolvedJavaType,\n\t\t\t\tthis::determineReflectedJavaType,\n\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\tthis,\n\t\t\t\tgetTable(),\n\t\t\t\tgetColumn(),\n\t\t\t\townerName,\n\t\t\t\tpropertyName,\n\t\t\t\tgetBuildingContext()\n\t\t);\n\t}\n\n\t@Override\n\tpublic ManagedBeanRegistry getManagedBeanRegistry() {\n\t\treturn getServiceRegistry().requireService( ManagedBeanRegistry.class );\n\t}\n\n\tprivate Resolution<?> converterResolution(JavaType<?> javaType, ConverterDescriptor attributeConverterDescriptor) {\n\t\tfinal NamedConverterResolution<?> converterResolution = NamedConverterResolution.from(\n\t\t\t\tattributeConverterDescriptor,\n\t\t\t\texplicitJavaTypeAccess,\n\t\t\t\texplicitJdbcTypeAccess,\n\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\tresolvedJavaType,\n\t\t\t\tthis,\n\t\t\t\tthis,\n\t\t\t\tgetBuildingContext()\n\t\t);\n\n\t\tif ( javaType instanceof BasicPluralJavaType<?>\n\t\t\t\t&& !attributeConverterDescriptor.getDomainValueResolvedType().getErasedType()\n\t\t\t\t\t\t.isAssignableFrom( javaType.getJavaTypeClass() ) ) {\n\t\t\t// In this case, the converter applies to the element of a BasicPluralJavaType\n\t\t\tfinal BasicPluralJavaType<?> containerJtd = (BasicPluralJavaType<?>) javaType;\n\t\t\tfinal BasicType registeredElementType = converterResolution.getLegacyResolvedBasicType();\n\t\t\tfinal Selectable column = getColumn();\n\t\t\tfinal BasicType<?> registeredType = registeredElementType == null ? null\n\t\t\t\t\t: containerJtd.resolveType(\n\t\t\t\t\t\t\tgetTypeConfiguration(),\n\t\t\t\t\t\t\tgetDialect(),\n\t\t\t\t\t\t\tregisteredElementType,\n\t\t\t\t\t\t\tcolumn instanceof ColumnTypeInformation ? (ColumnTypeInformation) column : null,\n\t\t\t\t\t\t\tthis\n\t\t\t);\n\t\t\tif ( registeredType != null ) {\n\t\t\t\tgetTypeConfiguration().getBasicTypeRegistry().register( registeredType );\n\t\t\t\treturn new InferredBasicValueResolution(\n\t\t\t\t\t\tregisteredType,\n\t\t\t\t\t\tregisteredType.getJavaTypeDescriptor(),\n\t\t\t\t\t\tregisteredType.getJavaTypeDescriptor(),\n\t\t\t\t\t\tregisteredType.getJdbcType(),\n\t\t\t\t\t\tregisteredType,\n\t\t\t\t\t\tnull\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn converterResolution;\n\t}\n\n\tprivate JavaType<?> determineJavaType(JavaType<?> explicitJavaType) {\n\t\tJavaType<?> javaType = explicitJavaType;\n//\n//\t\tif ( javaType == null ) {\n//\t\t\tif ( implicitJavaTypeAccess != null ) {\n//\t\t\t\tfinal java.lang.reflect.Type implicitJtd = implicitJavaTypeAccess.apply( getTypeConfiguration() );\n//\t\t\t\tif ( implicitJtd != null ) {\n//\t\t\t\t\tjavaType = getTypeConfiguration().getJavaTypeRegistry().getDescriptor( implicitJtd );\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n\n\t\tif ( javaType == null ) {\n\t\t\tfinal JavaType<?> reflectedJtd = determineReflectedJavaType();\n\t\t\tif ( reflectedJtd != null ) {\n\t\t\t\tjavaType = reflectedJtd;\n\t\t\t}\n\t\t}\n\n\t\treturn javaType;\n\t}\n\n\tprivate JavaType<?> determineReflectedJavaType() {\n\t\tfinal java.lang.reflect.Type impliedJavaType;\n\n\t\tfinal TypeConfiguration typeConfiguration = getTypeConfiguration();\n\t\tif ( resolvedJavaType != null ) {\n\t\t\timpliedJavaType = resolvedJavaType;\n\t\t}\n\t\telse if ( implicitJavaTypeAccess != null ) {\n\t\t\timpliedJavaType = implicitJavaTypeAccess.apply( typeConfiguration );\n\t\t}\n\t\telse if ( ownerName != null && propertyName != null ) {\n\t\t\timpliedJavaType = ReflectHelper.reflectedPropertyType(\n\t\t\t\t\townerName,\n\t\t\t\t\tpropertyName,\n\t\t\t\t\tgetServiceRegistry().requireService( ClassLoaderService.class )\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\n\t\tresolvedJavaType = impliedJavaType;\n\n\t\tif ( impliedJavaType == null ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal JavaTypeRegistry javaTypeRegistry = typeConfiguration.getJavaTypeRegistry();\n\t\tfinal JavaType<Object> javaType = javaTypeRegistry.findDescriptor( impliedJavaType );\n\t\tfinal MutabilityPlan<Object> explicitMutabilityPlan = explicitMutabilityPlanAccess != null\n\t\t\t\t? explicitMutabilityPlanAccess.apply( typeConfiguration )\n\t\t\t\t: null;\n\t\tfinal MutabilityPlan<Object> determinedMutabilityPlan = explicitMutabilityPlan != null\n\t\t\t\t? explicitMutabilityPlan\n\t\t\t\t: RegistryHelper.INSTANCE.determineMutabilityPlan( impliedJavaType, typeConfiguration );\n\t\tif ( javaType == null ) {\n\t\t\tif ( jdbcTypeCode != null ) {\n\t\t\t\t// Construct special JavaType instances for JSON/XML types which can report recommended JDBC types\n\t\t\t\t// and implement toString/fromString as well as copying based on FormatMapper operations\n\t\t\t\tswitch ( jdbcTypeCode ) {\n\t\t\t\t\tcase SqlTypes.JSON:\n\t\t\t\t\t\tfinal JavaType<Object> jsonJavaType = new JsonJavaType<>(\n\t\t\t\t\t\t\t\timpliedJavaType,\n\t\t\t\t\t\t\t\tdeterminedMutabilityPlan,\n\t\t\t\t\t\t\t\ttypeConfiguration\n\t\t\t\t\t\t);\n\t\t\t\t\t\tjavaTypeRegistry.addDescriptor( jsonJavaType );\n\t\t\t\t\t\treturn jsonJavaType;\n\t\t\t\t\tcase SqlTypes.SQLXML:\n\t\t\t\t\t\tfinal JavaType<Object> xmlJavaType = new XmlJavaType<>(\n\t\t\t\t\t\t\t\timpliedJavaType,\n\t\t\t\t\t\t\t\tdeterminedMutabilityPlan,\n\t\t\t\t\t\t\t\ttypeConfiguration\n\t\t\t\t\t\t);\n\t\t\t\t\t\tjavaTypeRegistry.addDescriptor( xmlJavaType );\n\t\t\t\t\t\treturn xmlJavaType;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn javaTypeRegistry.resolveDescriptor( impliedJavaType );\n\t\t}\n\t\treturn javaType;\n\t}\n\n\tprivate static Resolution<?> interpretExplicitlyNamedType(\n\t\t\tString name,\n\t\t\tFunction<TypeConfiguration, BasicJavaType> explicitJtdAccess,\n\t\t\tFunction<TypeConfiguration, JdbcType> explicitStdAccess,\n\t\t\tFunction<TypeConfiguration, MutabilityPlan> explicitMutabilityPlanAccess,\n\t\t\tConverterDescriptor converterDescriptor,\n\t\t\tMap<Object,Object> localTypeParams,\n\t\t\tConsumer<Properties> combinedParameterConsumer,\n\t\t\tJdbcTypeIndicators stdIndicators,\n\t\t\tMetadataBuildingContext context) {\n\n\t\tfinal StandardServiceRegistry serviceRegistry = context.getBootstrapContext().getServiceRegistry();\n\t\tfinal ManagedBeanRegistry managedBeanRegistry = serviceRegistry.requireService( ManagedBeanRegistry.class );\n\t\tfinal TypeConfiguration typeConfiguration = context.getBootstrapContext().getTypeConfiguration();\n\n\t\tfinal JpaAttributeConverterCreationContext converterCreationContext = new JpaAttributeConverterCreationContext() {\n\t\t\t@Override\n\t\t\tpublic ManagedBeanRegistry getManagedBeanRegistry() {\n\t\t\t\treturn managedBeanRegistry;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic TypeConfiguration getTypeConfiguration() {\n\t\t\t\treturn typeConfiguration;\n\t\t\t}\n\t\t};\n\n\t\t// Name could refer to:\n\t\t//\t\t1) a named converter - HBM support for JPA's AttributeConverter via its `type=\"...\"` XML attribute\n\t\t//\t\t2) a \"named composed\" mapping - like (1), this is mainly to support envers since it tells\n\t\t//\t\t\tHibernate the mappings via DOM.  See `org.hibernate.type.internal.BasicTypeImpl`\n\t\t//\t\t3) basic type \"resolution key\"\n\t\t//\t\t4) UserType or BasicType class name - directly, or through a TypeDefinition\n\n\t\tif ( name.startsWith( ConverterDescriptor.TYPE_NAME_PREFIX  ) ) {\n\t\t\treturn NamedConverterResolution.from(\n\t\t\t\t\tname,\n\t\t\t\t\texplicitJtdAccess,\n\t\t\t\t\texplicitStdAccess,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tstdIndicators,\n\t\t\t\t\tconverterCreationContext,\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\n//\t\tif ( name.startsWith( EnumeratedValueResolution.PREFIX ) ) {\n//\t\t\treturn EnumeratedValueResolution.fromName( name, stdIndicators, context );\n//\t\t}\n\n\t\tif ( name.startsWith( BasicTypeImpl.EXTERNALIZED_PREFIX ) ) {\n\t\t\tfinal BasicType<Object> basicType = context.getBootstrapContext().resolveAdHocBasicType( name );\n\t\t\treturn new NamedBasicTypeResolution<>(\n\t\t\t\t\tbasicType.getJavaTypeDescriptor(),\n\t\t\t\t\tbasicType,\n\t\t\t\t\tnull,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\n\t\t// see if it is a named basic type\n\t\tfinal BasicType<?> basicTypeByName = typeConfiguration.getBasicTypeRegistry().getRegisteredType( name );\n\t\tif ( basicTypeByName != null ) {\n\t\t\tfinal BasicValueConverter<?,?> valueConverter;\n\t\t\tfinal JavaType<?> domainJtd;\n\t\t\tif ( converterDescriptor != null ) {\n\t\t\t\tvalueConverter = converterDescriptor.createJpaAttributeConverter( converterCreationContext );\n\t\t\t\tdomainJtd = valueConverter.getDomainJavaType();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalueConverter = basicTypeByName.getValueConverter();\n\t\t\t\tdomainJtd = basicTypeByName.getJavaTypeDescriptor();\n\t\t\t}\n\n\t\t\treturn new NamedBasicTypeResolution<>(\n\t\t\t\t\tdomainJtd,\n\t\t\t\t\tbasicTypeByName,\n\t\t\t\t\tvalueConverter,\n\t\t\t\t\texplicitMutabilityPlanAccess,\n\t\t\t\t\tcontext\n\t\t\t);\n\t\t}\n\n\t\t// see if it is a named TypeDefinition\n\t\tfinal TypeDefinition typeDefinition = context.getTypeDefinitionRegistry().resolve( name );\n\t\tif ( typeDefinition != null ) {\n\t\t\tfinal Resolution<?> resolution = typeDefinition.resolve(\n\t\t\t\t\tlocalTypeParams,\n\t\t\t\t\texplicitMutabilityPlanAccess != null\n\t\t\t\t\t\t\t? explicitMutabilityPlanAccess.apply( typeConfiguration )\n\t\t\t\t\t\t\t: null,\n\t\t\t\t\tcontext,\n\t\t\t\t\tstdIndicators\n\t\t\t);\n\t\t\tcombinedParameterConsumer.accept( resolution.getCombinedTypeParameters() );\n\t\t\treturn resolution;\n\t\t}\n\n\n\t\t// see if the name is a UserType or BasicType implementor class name\n\t\tfinal ClassLoaderService cls = serviceRegistry.requireService( ClassLoaderService.class );\n\t\ttry {\n\t\t\tfinal Class<?> typeNamedClass = cls.classForName( name );\n\n\t\t\t// if there are no local config params, register an implicit TypeDefinition for this custom type .\n\t\t\t//  later uses may find it and re-use its cacheable reference...\n\t\t\tif ( CollectionHelper.isEmpty( localTypeParams ) ) {\n\t\t\t\tfinal TypeDefinition implicitDefinition = new TypeDefinition(\n\t\t\t\t\t\tname,\n\t\t\t\t\t\ttypeNamedClass,\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\tnull\n\t\t\t\t);\n\t\t\t\tcontext.getTypeDefinitionRegistry().register( implicitDefinition );\n\t\t\t\treturn implicitDefinition.resolve(\n\t\t\t\t\t\tlocalTypeParams,\n\t\t\t\t\t\texplicitMutabilityPlanAccess != null\n\t\t\t\t\t\t\t\t? explicitMutabilityPlanAccess.apply( typeConfiguration )\n\t\t\t\t\t\t\t\t: null,\n\t\t\t\t\t\tcontext,\n\t\t\t\t\t\tstdIndicators\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn TypeDefinition.createLocalResolution( name, typeNamedClass, localTypeParams, context );\n\t\t}\n\t\tcatch (ClassLoadingException e) {\n\t\t\t// allow the exception below to trigger\n\t\t\tlog.debugf( \"Could not resolve type-name [%s] as Java type : %s\", name, e );\n\t\t}\n\n\t\tthrow new MappingException( \"Could not resolve named type : \" + name );\n\t}\n\n\n\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// SqlTypeDescriptorIndicators\n\n\t@Override\n\tpublic EnumType getEnumeratedType() {\n\t\treturn getEnumerationStyle();\n\t}\n\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForBoolean() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForBoolean() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForDuration() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForDuration() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForUuid() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForUuid() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForInstant() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForInstant() );\n\t}\n\n\t@Override\n\tpublic int getPreferredSqlTypeCodeForArray() {\n\t\treturn resolveJdbcTypeCode( getBuildingContext().getPreferredSqlTypeCodeForArray() );\n\t}\n\n\t@Override\n\tpublic int resolveJdbcTypeCode(int jdbcTypeCode) {\n\t\treturn aggregateColumn == null\n\t\t\t\t? jdbcTypeCode\n\t\t\t\t: getDialect().getAggregateSupport()\n\t\t\t\t.aggregateComponentSqlTypeCode( aggregateColumn.getSqlTypeCode( getMetadata() ), jdbcTypeCode );\n\t}\n\n\t@Override\n\tpublic TimeZoneStorageStrategy getDefaultTimeZoneStorageStrategy() {\n\t\treturn timeZoneStorageStrategy( timeZoneStorageType, getBuildingContext() );\n\t}\n\n\t@Internal\n\tpublic static TimeZoneStorageStrategy timeZoneStorageStrategy(\n\t\t\tTimeZoneStorageType timeZoneStorageType,\n\t\t\tMetadataBuildingContext buildingContext) {\n\t\tif ( timeZoneStorageType != null ) {\n\t\t\tswitch ( timeZoneStorageType ) {\n\t\t\t\tcase COLUMN:\n\t\t\t\t\treturn TimeZoneStorageStrategy.COLUMN;\n\t\t\t\tcase NATIVE:\n\t\t\t\t\treturn TimeZoneStorageStrategy.NATIVE;\n\t\t\t\tcase NORMALIZE:\n\t\t\t\t\treturn TimeZoneStorageStrategy.NORMALIZE;\n\t\t\t\tcase NORMALIZE_UTC:\n\t\t\t\t\treturn TimeZoneStorageStrategy.NORMALIZE_UTC;\n\t\t\t}\n\t\t}\n\t\treturn buildingContext.getBuildingOptions().getDefaultTimeZoneStorage();\n\t}\n\n\tpublic void setExplicitTypeParams(Map<String,String> explicitLocalTypeParams) {\n\t\tthis.explicitLocalTypeParams = explicitLocalTypeParams;\n\t}\n\n\tpublic void setExplicitTypeName(String typeName) {\n\t\tthis.explicitTypeName = typeName;\n\t}\n\n\tpublic void setTypeName(String typeName) {\n\t\tif ( StringHelper.isNotEmpty( typeName ) ) {\n\t\t\tif ( typeName.startsWith( ConverterDescriptor.TYPE_NAME_PREFIX ) ) {\n\t\t\t\tfinal String converterClassName = typeName.substring( ConverterDescriptor.TYPE_NAME_PREFIX.length() );\n\t\t\t\tfinal ClassLoaderService cls = getServiceRegistry().requireService( ClassLoaderService.class );\n\t\t\t\ttry {\n\t\t\t\t\tfinal Class<AttributeConverter<?,?>> converterClass = cls.classForName( converterClassName );\n\t\t\t\t\tsetAttributeConverterDescriptor( new ClassBasedConverterDescriptor(\n\t\t\t\t\t\t\tconverterClass,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tgetBuildingContext().getBootstrapContext().getClassmateContext()\n\t\t\t\t\t) );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tlog.logBadHbmAttributeConverterType( typeName, e.getMessage() );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsetExplicitTypeName( typeName );\n\t\t\t}\n\t\t}\n\n\t\tsuper.setTypeName( typeName );\n\t}\n\n\tprivate static int COUNTER;\n\n\tpublic void setExplicitCustomType(Class<? extends UserType<?>> explicitCustomType) {\n\t\tif ( explicitCustomType != null ) {\n\t\t\tif ( resolution != null ) {\n\t\t\t\tthrow new UnsupportedOperationException( \"Unsupported attempt to set an explicit-custom-type when value is already resolved\" );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresolution = new UserTypeResolution<>(\n\t\t\t\t\t\tnew CustomType<>(\n\t\t\t\t\t\t\t\tgetConfiguredUserTypeBean( explicitCustomType, getCustomTypeProperties() ),\n\t\t\t\t\t\t\t\tgetTypeConfiguration()\n\t\t\t\t\t\t),\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\tgetCustomTypeProperties()\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate Properties getCustomTypeProperties() {\n\t\tfinal Properties properties = new Properties();\n\t\tif ( isNotEmpty( getTypeParameters() ) ) {\n\t\t\tproperties.putAll( getTypeParameters() );\n\t\t}\n\t\tif ( isNotEmpty( explicitLocalTypeParams ) ) {\n\t\t\tproperties.putAll( explicitLocalTypeParams );\n\t\t}\n\t\treturn properties;\n\t}\n\n\tprivate UserType<?> getConfiguredUserTypeBean(Class<? extends UserType<?>> explicitCustomType, Properties properties) {\n\t\tfinal UserType<?> typeInstance =\n\t\t\t\t!getBuildingContext().getBuildingOptions().isAllowExtensionsInCdi()\n\t\t\t\t\t\t? FallbackBeanInstanceProducer.INSTANCE.produceBeanInstance( explicitCustomType )\n\t\t\t\t\t\t: getUserTypeBean( explicitCustomType, properties ).getBeanInstance();\n\n\t\tif ( typeInstance instanceof TypeConfigurationAware ) {\n\t\t\tfinal TypeConfigurationAware configurationAware = (TypeConfigurationAware) typeInstance;\n\t\t\tconfigurationAware.setTypeConfiguration( getTypeConfiguration() );\n\t\t}\n\n\t\tif ( typeInstance instanceof DynamicParameterizedType ) {\n\t\t\tif ( parseBoolean( properties.getProperty( DynamicParameterizedType.IS_DYNAMIC ) ) ) {\n\t\t\t\tif ( properties.get( DynamicParameterizedType.PARAMETER_TYPE ) == null ) {\n\t\t\t\t\tproperties.put( DynamicParameterizedType.PARAMETER_TYPE, makeParameterImpl() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tinjectParameters( typeInstance, properties);\n\t\t// envers - grr\n\t\tsetTypeParameters( properties );\n\n\t\treturn typeInstance;\n\t}\n\n\tprivate <T> ManagedBean<T> getUserTypeBean(Class<T> explicitCustomType, Properties properties) {\n\t\tfinal BeanInstanceProducer producer = getBuildingContext().getBootstrapContext().getCustomTypeProducer();\n\t\tfinal ManagedBeanRegistry registry = getServiceRegistry().requireService( ManagedBeanRegistry.class );\n\t\tif ( isNotEmpty( properties ) ) {\n\t\t\tfinal String name = explicitCustomType.getName() + COUNTER++;\n\t\t\treturn registry.getBean( name, explicitCustomType, producer );\n\t\t}\n\t\telse {\n\t\t\treturn registry.getBean( explicitCustomType, producer );\n\t\t}\n\t}\n\n\tpublic void setTemporalPrecision(TemporalType temporalPrecision) {\n\t\tthis.temporalPrecision = temporalPrecision;\n\t}\n\n\t@Override\n\tpublic TemporalType getTemporalPrecision() {\n\t\treturn temporalPrecision;\n\t}\n\n\t@Override\n\tpublic boolean isPreferJavaTimeJdbcTypesEnabled() {\n\t\treturn getBuildingContext().isPreferJavaTimeJdbcTypesEnabled();\n\t}\n\n\t@Override\n\tpublic boolean isPreferNativeEnumTypesEnabled() {\n\t\treturn getBuildingContext().isPreferNativeEnumTypesEnabled();\n\t}\n\n\t@Override\n\tpublic Object accept(ValueVisitor visitor) {\n\t\treturn visitor.accept(this);\n\t}\n\n\t@Internal\n\tpublic boolean isDisallowedWrapperArray() {\n\t\treturn getBuildingContext().getBuildingOptions().getWrapperArrayHandling() == WrapperArrayHandling.DISALLOW\n\t\t\t&& !isLob()\n\t\t\t&& ( explicitJavaTypeAccess == null || explicitJavaTypeAccess.apply( getTypeConfiguration() ) == null )\n\t\t\t&& isWrapperByteOrCharacterArray();\n\t}\n\n\tprivate boolean isWrapperByteOrCharacterArray() {\n\t\tfinal Class<?> javaTypeClass = getResolution().getDomainJavaType().getJavaTypeClass();\n\t\treturn javaTypeClass == Byte[].class || javaTypeClass == Character[].class;\n\t}\n\n\t@Incubating\n\tpublic void setExplicitJdbcTypeCode(Integer jdbcTypeCode) {\n\t\tthis.jdbcTypeCode = jdbcTypeCode;\n\t}\n\n\t@Override\n\tpublic Integer getExplicitJdbcTypeCode() {\n\t\treturn jdbcTypeCode == null ? getPreferredSqlTypeCodeForArray() : jdbcTypeCode;\n\t}\n\n\t/**\n\t * Resolved form of {@link BasicValue} as part of interpreting the\n\t * boot-time model into the run-time model\n\t */\n\tpublic interface Resolution<J> {\n\t\t/**\n\t\t * The BasicType resolved using the pre-6.0 rules.  This is temporarily\n\t\t * needed because of the split in extracting / binding\n\t\t */\n\t\tBasicType<J> getLegacyResolvedBasicType();\n\n\t\t/**\n\t\t * Get the collection of type-parameters collected both locally as well\n\t\t * as from the applied type-def, if one\n\t\t */\n\t\tdefault Properties getCombinedTypeParameters() {\n\t\t\treturn null;\n\t\t}\n\n\t\tJdbcMapping getJdbcMapping();\n\n\t\t/**\n\t\t * The JavaType for the value as part of the domain model\n\t\t */\n\t\tJavaType<J> getDomainJavaType();\n\n\t\t/**\n\t\t * The JavaType for the relational value as part of\n\t\t * the relational model (its JDBC representation)\n\t\t */\n\t\tJavaType<?> getRelationalJavaType();\n\n\t\t/**\n\t\t * The JavaType for the relational value as part of\n\t\t * the relational model (its JDBC representation)\n\t\t */\n\t\tJdbcType getJdbcType();\n\n\t\t/**\n\t\t * Converter, if any, to convert values between the\n\t\t * domain and relational JavaType representations\n\t\t */\n\t\tBasicValueConverter<J,?> getValueConverter();\n\n\t\t/**\n\t\t * The resolved MutabilityPlan\n\t\t */\n\t\tMutabilityPlan<J> getMutabilityPlan();\n\n\t\tdefault void updateResolution(BasicType<?> type) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate createPersistenceUnitInfo(jpa Jpa) : PersistenceUnitInfoImpl extracted from public findEntityManagerFactoryScope(testScope Object, emfAnnWrapper Optional<Jpa>, context ExtensionContext) : EntityManagerFactoryScope in class org.hibernate.testing.orm.junit.EntityManagerFactoryExtension",
        "diffLocations": [
            {
                "filePath": "hibernate-testing/src/main/java/org/hibernate/testing/orm/junit/EntityManagerFactoryExtension.java",
                "startLine": 66,
                "endLine": 203,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-testing/src/main/java/org/hibernate/testing/orm/junit/EntityManagerFactoryExtension.java",
                "startLine": 61,
                "endLine": 91,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-testing/src/main/java/org/hibernate/testing/orm/junit/EntityManagerFactoryExtension.java",
                "startLine": 113,
                "endLine": 121,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public static EntityManagerFactoryScope findEntityManagerFactoryScope(\n\t\t\tObject testScope,\n\t\t\tOptional<Jpa> emfAnnWrapper,\n\t\t\tExtensionContext context) {\n\n\t\tif ( emfAnnWrapper.isEmpty() ) {\n\t\t\t// No annotation on the test class, should be on the test methods\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n\t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n\t\tif ( existing != null ) {\n\t\t\treturn existing;\n\t\t}\n\n\t\tif ( !context.getElement().isPresent() ) {\n\t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \" + context.getDisplayName() );\n\t\t}\n\t\tfinal Jpa emfAnn = emfAnnWrapper.get();\n\n\t\tfinal PersistenceUnitInfoImpl pui = new PersistenceUnitInfoImpl( emfAnn.persistenceUnitName() );\n\t\t( (Map<Object, Object>) Environment.getProperties() ).forEach(\n\t\t\t\t(key, value) ->\n\t\t\t\t\t\tpui.getProperties().put( key, value )\n\t\t);\n\n\t\tpui.setTransactionType( emfAnn.transactionType() );\n\t\tpui.setCacheMode( emfAnn.sharedCacheMode() );\n\t\tpui.setValidationMode( emfAnn.validationMode() );\n\t\tpui.setExcludeUnlistedClasses( emfAnn.excludeUnlistedClasses() );\n\n\t\t// JpaCompliance\n\t\tpui.getProperties().put( AvailableSettings.JPA_COMPLIANCE, emfAnn.jpaComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_QUERY_COMPLIANCE, emfAnn.queryComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, emfAnn.transactionComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_CLOSED_COMPLIANCE, emfAnn.closedComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_PROXY_COMPLIANCE, emfAnn.proxyComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_CACHING_COMPLIANCE, emfAnn.cacheComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, emfAnn.generatorScopeComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, emfAnn.orderByMappingComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, emfAnn.loadByIdComplianceEnabled() );\n\n\t\tfinal Setting[] properties = emfAnn.properties();\n\t\tfor ( int i = 0; i < properties.length; i++ ) {\n\t\t\tfinal Setting property = properties[i];\n\t\t\tpui.getProperties().setProperty( property.name(), property.value() );\n\t\t}\n\n\t\tpui.getProperties().setProperty(\n\t\t\t\tAvailableSettings.GENERATE_STATISTICS,\n\t\t\t\tBoolean.toString( emfAnn.generateStatistics() )\n\t\t);\n\n\t\tif ( emfAnn.exportSchema() ) {\n\t\t\tpui.getProperties().setProperty(\n\t\t\t\t\tAvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,\n\t\t\t\t\tAction.CREATE_DROP.getExternalHbm2ddlName()\n\t\t\t);\n\t\t}\n\n\t\tif ( emfAnn.annotatedPackageNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( emfAnn.annotatedPackageNames() );\n\t\t}\n\n\t\tif ( emfAnn.annotatedClassNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClassNames() );\n\t\t}\n\n\t\tif ( emfAnn.annotatedClasses().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.annotatedClasses().length; i++ ) {\n\t\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClasses()[i].getName() );\n\t\t\t}\n\t\t}\n\n\t\tif ( emfAnn.xmlMappings().length > 0 ) {\n\t\t\tpui.applyMappingFiles( emfAnn.xmlMappings() );\n\t\t}\n\n\t\tif ( emfAnn.standardModels().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.standardModels().length; i++ ) {\n\t\t\t\tfinal StandardDomainModel standardDomainModel = emfAnn.standardModels()[i];\n\t\t\t\tfor ( int i1 = 0; i1 < standardDomainModel.getDescriptor().getAnnotatedClasses().length; i1++ ) {\n\t\t\t\t\tfinal Class<?> annotatedClass = standardDomainModel.getDescriptor().getAnnotatedClasses()[i1];\n\t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( emfAnn.modelDescriptorClasses().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.modelDescriptorClasses().length; i++ ) {\n\t\t\t\tfinal Class<? extends DomainModelDescriptor> modelDescriptorClass = emfAnn.modelDescriptorClasses()[i];\n\t\t\t\tfinal DomainModelDescriptor domainModelDescriptor = instantiateDomainModelDescriptor(\n\t\t\t\t\t\tmodelDescriptorClass );\n\t\t\t\tfor ( int i1 = 0; i1 < domainModelDescriptor.getAnnotatedClasses().length; i1++ ) {\n\t\t\t\t\tfinal Class<?> annotatedClass = domainModelDescriptor.getAnnotatedClasses()[i1];\n\t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfinal Map<String, Object> integrationSettings = new HashMap<>();\n\n\t\tintegrationSettings.put( PersistentTableStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( GlobalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( LocalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tfor ( int i = 0; i < emfAnn.integrationSettings().length; i++ ) {\n\t\t\tfinal Setting setting = emfAnn.integrationSettings()[i];\n\t\t\tintegrationSettings.put( setting.name(), setting.value() );\n\t\t}\n\n\t\tfor ( SettingProvider providerAnn : emfAnn.settingProviders() ) {\n\t\t\tfinal Class<? extends SettingProvider.Provider<?>> providerImpl = providerAnn.provider();\n\t\t\ttry {\n\t\t\t\tfinal SettingProvider.Provider<?> provider = providerImpl.getConstructor().newInstance();\n\t\t\t\tintegrationSettings.put( providerAnn.settingName(), provider.getSetting() );\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tlog.error( \"Error obtaining setting provider for \" + providerImpl.getName(), e );\n\t\t\t}\n\t\t}\n\n\t\t// statement inspector\n\t\tif ( emfAnn.useCollectingStatementInspector() ) {\n\t\t\tString inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n\t\t\tif ( !(inspectorSetting == null || inspectorSetting.isBlank()) ) {\n\t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n\t\t\t}\n\t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n\t\t}\n\n\t\tServiceRegistryUtil.applySettings( integrationSettings );\n\t\tfinal EntityManagerFactoryScopeImpl scope = new EntityManagerFactoryScopeImpl( pui, integrationSettings );\n\n\t\tstore.put( EMF_KEY, scope );\n\n\t\treturn scope;\n\t}",
        "filePathBefore": "hibernate-testing/src/main/java/org/hibernate/testing/orm/junit/EntityManagerFactoryExtension.java",
        "isPureRefactoring": true,
        "commitId": "4781c09d0df0eb4ce05b2fa0d2a12747023ae024",
        "packageNameBefore": "org.hibernate.testing.orm.junit",
        "classNameBefore": "org.hibernate.testing.orm.junit.EntityManagerFactoryExtension",
        "methodNameBefore": "org.hibernate.testing.orm.junit.EntityManagerFactoryExtension#findEntityManagerFactoryScope",
        "invokedMethod": "methodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#setValidationMode\n methodBody: public void setValidationMode(String validationMode) {\nsetValidationMode(ValidationMode.valueOf(validationMode));\n}\nmethodSignature: org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}\nmethodSignature: org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor#getName\n methodBody: public String getName() {\nreturn persistenceUnitInfo.getPersistenceUnitName();\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setTransactionType\n methodBody: public void setTransactionType(PersistenceUnitTransactionType transactionType) {\nthis.transactionType=transactionType;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest#applySettings\n methodBody: protected void applySettings(Map<Object, Object> settings) {\nString[] mappings=getMappings();\nif(mappings != null){settings.put(AvailableSettings.HBM_XML_FILES,String.join(\",\",mappings));\n}}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setValidationMode\n methodBody: public void setValidationMode(ValidationMode validationMode) {\nthis.validationMode=validationMode;\n}\nmethodSignature: org.hibernate.collection.spi.AbstractPersistentCollection.SetProxy#isEmpty\n methodBody: public boolean isEmpty() {\nreturn set.isEmpty();\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#applyMappingFiles\n methodBody: public void applyMappingFiles(String... mappingFiles) {\nif(this.mappingFiles == null){this.mappingFiles=new ArrayList<>();\n}Collections.addAll(this.mappingFiles,mappingFiles);\n}\nmethodSignature: org.hibernate.testing.util.jpa.DelegatingPersistenceUnitInfo#getProperties\n methodBody: public Properties getProperties() {\nreturn delegate.getProperties();\n}\nmethodSignature: org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentList#get\n methodBody: public E get(int index) {\nif(index < 0){throw new ArrayIndexOutOfBoundsException(\"negative index\");\n}final Object result=readElementByIndex(index);\nreturn result == UNKNOWN ? list.get(index) : (E)result;\n}\nmethodSignature: org.hibernate.orm.test.bootstrap.BootstrapTest.PersistenceUnitInfoImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest.TestingPersistenceUnitDescriptorImpl#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.jpa.boot.spi.PersistenceConfigurationDescriptor#getName\n methodBody: public String getName() {\nreturn persistenceConfiguration.name();\n}\nmethodSignature: org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor#getProperties\n methodBody: public Properties getProperties() {\nreturn persistenceUnitInfo.getProperties();\n}\nmethodSignature: org.hibernate.jpa.boot.spi.PersistenceUnitDescriptor#getProperties\n methodBody: Properties getProperties();\nmethodSignature: org.hibernate.testing.orm.junit.BaseSessionFactoryFunctionalTest#getAnnotatedClasses\n methodBody: protected Class[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}\nmethodSignature: org.hibernate.testing.orm.junit.BaseSessionFactoryFunctionalTest#applySettings\n methodBody: protected void applySettings(StandardServiceRegistryBuilder builder) {\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoAdapter#getProperties\n methodBody: public Properties getProperties() {\nif(properties == null){properties=new Properties();\n}return properties;\n}\nmethodSignature: org.hibernate.testing.util.jpa.DelegatingPersistenceUnitInfo#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn delegate.excludeUnlistedClasses();\n}\nmethodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoAdapter#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setCacheMode\n methodBody: public void setCacheMode(SharedCacheMode cacheMode) {\nthis.cacheMode=cacheMode;\n}\nmethodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.orm.test.jpa.BaseEntityManagerFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn excludeUnlistedClasses;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}\nmethodSignature: org.hibernate.collection.spi.AbstractPersistentCollection.ListProxy#get\n methodBody: public E get(int i) {\nreturn list.get(i);\n}\nmethodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoAdapter#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}\nmethodSignature: org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}\nmethodSignature: org.hibernate.orm.test.bootstrap.BootstrapTest.PersistenceUnitInfoImpl#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}\nmethodSignature: org.hibernate.jpa.boot.spi.PersistenceConfigurationDescriptor#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitDescriptorAdapter#getProperties\n methodBody: public Properties getProperties() {\nif(properties == null){properties=new Properties();\n}return properties;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentBag#get\n methodBody: public E get(int i) {\nread();\nreturn bag.get(i);\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoAdapter#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setExcludeUnlistedClasses\n methodBody: public void setExcludeUnlistedClasses(boolean excludeUnlistedClasses) {\nthis.excludeUnlistedClasses=excludeUnlistedClasses;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentList#toString\n methodBody: public String toString() {\nread();\nreturn list.toString();\n}\nmethodSignature: org.hibernate.testing.junit4.BaseCoreFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentBag#getElement\n methodBody: public Object getElement(Object entry) {\nreturn entry;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentBag#isEmpty\n methodBody: public boolean isEmpty() {\nreturn readSize() ? getCachedSize() == 0 : bag.isEmpty();\n}\nmethodSignature: org.hibernate.orm.test.jpa.xml.versions.JpaXsdVersionsTest.PersistenceUnitInfoImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}\nmethodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#setTransactionType\n methodBody: public void setTransactionType(PersistenceUnitTransactionType transactionType) {\nthis.transactionType=transactionType;\n}\nmethodSignature: org.hibernate.orm.test.jpa.EntityManagerTest#getAnnotatedClasses\n methodBody: public Class[] getAnnotatedClasses() {\nreturn new Class[]{Item.class,Distributor.class,Wallet.class};\n}\nmethodSignature: org.hibernate.orm.test.jpa.BaseEntityManagerFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest#exportSchema\n methodBody: protected boolean exportSchema() {\nreturn true;\n}\nmethodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}\nmethodSignature: org.hibernate.internal.SessionFactoryImpl#getProperties\n methodBody: public Map<String, Object> getProperties() {\nvalidateNotClosed();\nreturn settings;\n}\nmethodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoPropertiesWrapper#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}\nmethodSignature: org.hibernate.orm.test.jpa.xml.versions.JpaXsdVersionsTest.PersistenceUnitInfoImpl#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}\nmethodSignature: org.hibernate.jpa.boot.spi.PersistenceUnitDescriptor#getName\n methodBody: String getName();\nmethodSignature: org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn null;\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitDescriptorAdapter#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryExtension#locateExtensionStore\n methodBody: private static ExtensionContext.Store locateExtensionStore(Object testScope, ExtensionContext context) {\nreturn JUnitHelper.locateExtensionStore(EntityManagerFactoryExtension.class,context,testScope);\n}\nmethodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#setExcludeUnlistedClasses\n methodBody: public void setExcludeUnlistedClasses(boolean excludeUnlistedClasses) {\nthis.excludeUnlistedClasses=excludeUnlistedClasses;\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#applyManagedClassNames\n methodBody: public void applyManagedClassNames(String... managedClassNames) {\nif(this.managedClassNames == null){this.managedClassNames=new ArrayList<>();\n}Collections.addAll(this.managedClassNames,managedClassNames);\n}\nmethodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoPropertiesWrapper#getProperties\n methodBody: public Properties getProperties() {\nif(properties == null){properties=new Properties();\n}return properties;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentList#getElement\n methodBody: public Object getElement(Object entry) {\nreturn entry;\n}\nmethodSignature: org.hibernate.orm.test.jpa.BaseEntityManagerFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn null;\n}\nmethodSignature: org.hibernate.internal.SessionFactoryImpl#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest.TestingPersistenceUnitDescriptorImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn null;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentList#isEmpty\n methodBody: public boolean isEmpty() {\nreturn readSize() ? getCachedSize() == 0 : list.isEmpty();\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryExtension#instantiateDomainModelDescriptor\n methodBody: private static DomainModelDescriptor instantiateDomainModelDescriptor(Class<? extends DomainModelDescriptor> modelDescriptorClass) {\ntryfinal Field[] declaredFields=modelDescriptorClass.getDeclaredFields();\nfor(int i=0; i < declaredFields.length; i++){final Field field=declaredFields[i];\nif(ReflectHelper.isStaticField(field)){final Object value=field.get(null);\nif(value instanceof DomainModelDescriptor){return (DomainModelDescriptor)value;\n}}}catch(IllegalAccessException e)throw new RuntimeException(\"Problem accessing DomainModelDescriptor fields : \" + modelDescriptorClass.getName(),e);\ntryreturn modelDescriptorClass.getConstructor(null).newInstance(null);\ncatch(InstantiationException|IllegalAccessException|InvocationTargetException|NoSuchMethodException e)throw new RuntimeException(\"Problem instantiation DomainModelDescriptor : \" + modelDescriptorClass.getName(),e);\n}\nmethodSignature: org.hibernate.testing.orm.junit.BaseSessionFactoryFunctionalTest#exportSchema\n methodBody: protected boolean exportSchema() {\nreturn true;\n}\nmethodSignature: org.hibernate.collection.spi.AbstractPersistentCollection.ListProxy#isEmpty\n methodBody: public boolean isEmpty() {\nreturn list.isEmpty();\n}\nmethodSignature: org.hibernate.collection.spi.PersistentBag#toString\n methodBody: public String toString() {\nread();\nreturn bag.toString();\n}",
        "classSignatureBefore": "public class EntityManagerFactoryExtension\n\t\timplements TestInstancePostProcessor, BeforeEachCallback, TestExecutionExceptionHandler ",
        "methodNameBeforeSet": [
            "org.hibernate.testing.orm.junit.EntityManagerFactoryExtension#findEntityManagerFactoryScope"
        ],
        "classNameBeforeSet": [
            "org.hibernate.testing.orm.junit.EntityManagerFactoryExtension"
        ],
        "classSignatureBeforeSet": [
            "public class EntityManagerFactoryExtension\n\t\timplements TestInstancePostProcessor, BeforeEachCallback, TestExecutionExceptionHandler "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Overlapped refactoring - can be identical by undoing the overlapped refactoring\n- Rename Variable- Severe changes",
                "description": "Return expression has been added within the Extract Method mechanics - with non-mapped leaves",
                "mappingState": 2
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.testing.orm.junit;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport jakarta.persistence.spi.PersistenceUnitInfo;\n\nimport org.hibernate.SessionFactoryObserver;\nimport org.hibernate.boot.registry.StandardServiceRegistry;\nimport org.hibernate.boot.spi.MetadataImplementor;\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.cfg.Environment;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.internal.util.ReflectHelper;\nimport org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor;\nimport org.hibernate.jpa.boot.spi.Bootstrap;\nimport org.hibernate.jpa.boot.spi.EntityManagerFactoryBuilder;\nimport org.hibernate.query.sqm.mutation.internal.temptable.GlobalTemporaryTableMutationStrategy;\nimport org.hibernate.query.sqm.mutation.internal.temptable.LocalTemporaryTableMutationStrategy;\nimport org.hibernate.query.sqm.mutation.internal.temptable.PersistentTableStrategy;\nimport org.hibernate.tool.schema.Action;\nimport org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator;\nimport org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator.ActionGrouping;\n\nimport org.hibernate.testing.jdbc.SQLStatementInspector;\nimport org.hibernate.testing.orm.domain.DomainModelDescriptor;\nimport org.hibernate.testing.orm.domain.StandardDomainModel;\nimport org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl;\nimport org.hibernate.testing.util.ServiceRegistryUtil;\nimport org.junit.jupiter.api.extension.BeforeEachCallback;\nimport org.junit.jupiter.api.extension.ExtensionContext;\nimport org.junit.jupiter.api.extension.TestExecutionExceptionHandler;\nimport org.junit.jupiter.api.extension.TestInstancePostProcessor;\nimport org.junit.platform.commons.support.AnnotationSupport;\n\nimport org.jboss.logging.Logger;\n\n/**\n * hibernate-testing implementation of a few JUnit5 contracts to support SessionFactory-based testing,\n * including argument injection (or see {@link SessionFactoryScopeAware})\n *\n * @author Steve Ebersole\n *\n * @see DomainModelExtension\n * @see SessionFactoryExtension\n */\npublic class EntityManagerFactoryExtension\n\t\timplements TestInstancePostProcessor, BeforeEachCallback, TestExecutionExceptionHandler {\n\n\tprivate static final Logger log = Logger.getLogger( EntityManagerFactoryExtension.class );\n\tprivate static final String EMF_KEY = EntityManagerFactoryScope.class.getName();\n\n\tprivate static ExtensionContext.Store locateExtensionStore(Object testScope, ExtensionContext context) {\n\t\treturn JUnitHelper.locateExtensionStore( EntityManagerFactoryExtension.class, context, testScope );\n\t}\n\n\tpublic static EntityManagerFactoryScope findEntityManagerFactoryScope(\n\t\t\tObject testScope,\n\t\t\tOptional<Jpa> emfAnnWrapper,\n\t\t\tExtensionContext context) {\n\n\t\tif ( emfAnnWrapper.isEmpty() ) {\n\t\t\t// No annotation on the test class, should be on the test methods\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n\t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n\t\tif ( existing != null ) {\n\t\t\treturn existing;\n\t\t}\n\n\t\tif ( !context.getElement().isPresent() ) {\n\t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \" + context.getDisplayName() );\n\t\t}\n\t\tfinal Jpa emfAnn = emfAnnWrapper.get();\n\n\t\tfinal PersistenceUnitInfoImpl pui = new PersistenceUnitInfoImpl( emfAnn.persistenceUnitName() );\n\t\t( (Map<Object, Object>) Environment.getProperties() ).forEach(\n\t\t\t\t(key, value) ->\n\t\t\t\t\t\tpui.getProperties().put( key, value )\n\t\t);\n\n\t\tpui.setTransactionType( emfAnn.transactionType() );\n\t\tpui.setCacheMode( emfAnn.sharedCacheMode() );\n\t\tpui.setValidationMode( emfAnn.validationMode() );\n\t\tpui.setExcludeUnlistedClasses( emfAnn.excludeUnlistedClasses() );\n\n\t\t// JpaCompliance\n\t\tpui.getProperties().put( AvailableSettings.JPA_COMPLIANCE, emfAnn.jpaComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_QUERY_COMPLIANCE, emfAnn.queryComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, emfAnn.transactionComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_CLOSED_COMPLIANCE, emfAnn.closedComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_PROXY_COMPLIANCE, emfAnn.proxyComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_CACHING_COMPLIANCE, emfAnn.cacheComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, emfAnn.generatorScopeComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, emfAnn.orderByMappingComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, emfAnn.loadByIdComplianceEnabled() );\n\n\t\tfinal Setting[] properties = emfAnn.properties();\n\t\tfor ( int i = 0; i < properties.length; i++ ) {\n\t\t\tfinal Setting property = properties[i];\n\t\t\tpui.getProperties().setProperty( property.name(), property.value() );\n\t\t}\n\n\t\tpui.getProperties().setProperty(\n\t\t\t\tAvailableSettings.GENERATE_STATISTICS,\n\t\t\t\tBoolean.toString( emfAnn.generateStatistics() )\n\t\t);\n\n\t\tif ( emfAnn.exportSchema() ) {\n\t\t\tpui.getProperties().setProperty(\n\t\t\t\t\tAvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,\n\t\t\t\t\tAction.CREATE_DROP.getExternalHbm2ddlName()\n\t\t\t);\n\t\t}\n\n\t\tif ( emfAnn.annotatedPackageNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( emfAnn.annotatedPackageNames() );\n\t\t}\n\n\t\tif ( emfAnn.annotatedClassNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClassNames() );\n\t\t}\n\n\t\tif ( emfAnn.annotatedClasses().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.annotatedClasses().length; i++ ) {\n\t\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClasses()[i].getName() );\n\t\t\t}\n\t\t}\n\n\t\tif ( emfAnn.xmlMappings().length > 0 ) {\n\t\t\tpui.applyMappingFiles( emfAnn.xmlMappings() );\n\t\t}\n\n\t\tif ( emfAnn.standardModels().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.standardModels().length; i++ ) {\n\t\t\t\tfinal StandardDomainModel standardDomainModel = emfAnn.standardModels()[i];\n\t\t\t\tfor ( int i1 = 0; i1 < standardDomainModel.getDescriptor().getAnnotatedClasses().length; i1++ ) {\n\t\t\t\t\tfinal Class<?> annotatedClass = standardDomainModel.getDescriptor().getAnnotatedClasses()[i1];\n\t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( emfAnn.modelDescriptorClasses().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.modelDescriptorClasses().length; i++ ) {\n\t\t\t\tfinal Class<? extends DomainModelDescriptor> modelDescriptorClass = emfAnn.modelDescriptorClasses()[i];\n\t\t\t\tfinal DomainModelDescriptor domainModelDescriptor = instantiateDomainModelDescriptor(\n\t\t\t\t\t\tmodelDescriptorClass );\n\t\t\t\tfor ( int i1 = 0; i1 < domainModelDescriptor.getAnnotatedClasses().length; i1++ ) {\n\t\t\t\t\tfinal Class<?> annotatedClass = domainModelDescriptor.getAnnotatedClasses()[i1];\n\t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfinal Map<String, Object> integrationSettings = new HashMap<>();\n\n\t\tintegrationSettings.put( PersistentTableStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( GlobalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( LocalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tfor ( int i = 0; i < emfAnn.integrationSettings().length; i++ ) {\n\t\t\tfinal Setting setting = emfAnn.integrationSettings()[i];\n\t\t\tintegrationSettings.put( setting.name(), setting.value() );\n\t\t}\n\n\t\tfor ( SettingProvider providerAnn : emfAnn.settingProviders() ) {\n\t\t\tfinal Class<? extends SettingProvider.Provider<?>> providerImpl = providerAnn.provider();\n\t\t\ttry {\n\t\t\t\tfinal SettingProvider.Provider<?> provider = providerImpl.getConstructor().newInstance();\n\t\t\t\tintegrationSettings.put( providerAnn.settingName(), provider.getSetting() );\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tlog.error( \"Error obtaining setting provider for \" + providerImpl.getName(), e );\n\t\t\t}\n\t\t}\n\n\t\t// statement inspector\n\t\tif ( emfAnn.useCollectingStatementInspector() ) {\n\t\t\tString inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n\t\t\tif ( !(inspectorSetting == null || inspectorSetting.isBlank()) ) {\n\t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n\t\t\t}\n\t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n\t\t}\n\n\t\tServiceRegistryUtil.applySettings( integrationSettings );\n\t\tfinal EntityManagerFactoryScopeImpl scope = new EntityManagerFactoryScopeImpl( pui, integrationSettings );\n\n\t\tstore.put( EMF_KEY, scope );\n\n\t\treturn scope;\n\t}\n\n\tprivate static DomainModelDescriptor instantiateDomainModelDescriptor(Class<? extends DomainModelDescriptor> modelDescriptorClass) {\n\t\t// first, see if it has a static singleton reference and use that if so\n\t\ttry {\n\t\t\tfinal Field[] declaredFields = modelDescriptorClass.getDeclaredFields();\n\t\t\tfor ( int i = 0; i < declaredFields.length; i++ ) {\n\t\t\t\tfinal Field field = declaredFields[i];\n\t\t\t\tif ( ReflectHelper.isStaticField( field ) ) {\n\t\t\t\t\tfinal Object value = field.get( null );\n\t\t\t\t\tif ( value instanceof DomainModelDescriptor ) {\n\t\t\t\t\t\treturn (DomainModelDescriptor) value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalAccessException e) {\n\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\"Problem accessing DomainModelDescriptor fields : \" + modelDescriptorClass.getName(),\n\t\t\t\t\te\n\t\t\t);\n\t\t}\n\n\t\t// no singleton field, try to instantiate it via reflection\n\t\ttry {\n\t\t\treturn modelDescriptorClass.getConstructor( null ).newInstance( null );\n\t\t}\n\t\tcatch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {\n\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\"Problem instantiation DomainModelDescriptor : \" + modelDescriptorClass.getName(),\n\t\t\t\t\te\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate static void prepareSchemaExport(\n\t\t\tSessionFactoryImplementor sessionFactory,\n\t\t\tMetadataImplementor model) {\n\t\tfinal Map<String, Object> baseProperties = sessionFactory.getProperties();\n\n\t\tfinal Set<ActionGrouping> groupings = ActionGrouping.interpret( model, baseProperties );\n\t\tif ( !groupings.isEmpty() ) {\n\t\t\t// the properties contained explicit settings for auto schema tooling - skip the annotation\n\t\t\treturn;\n\t\t}\n\n\t\tfinal HashMap<String,Object> settings = new HashMap<>( baseProperties );\n\t\tsettings.put( AvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION, Action.CREATE_DROP );\n\n\t\tfinal StandardServiceRegistry serviceRegistry = model.getMetadataBuildingOptions().getServiceRegistry();\n\n\n\t\tSchemaManagementToolCoordinator.process(\n\t\t\t\tmodel,\n\t\t\t\tserviceRegistry,\n\t\t\t\tsettings,\n\t\t\t\taction -> sessionFactory.addObserver(\n\t\t\t\t\t\tnew SessionFactoryObserver() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void sessionFactoryClosing(org.hibernate.SessionFactory factory) {\n\t\t\t\t\t\t\t\taction.perform( serviceRegistry );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t)\n\t\t);\n\t}\n\n\t@Override\n\tpublic void beforeEach(ExtensionContext context) {\n\t\tlog.tracef( \"#beforeEach(%s)\", context.getDisplayName() );\n\t\tfinal Optional<Jpa> emfAnnWrapper = AnnotationSupport.findAnnotation(\n\t\t\t\tcontext.getRequiredTestMethod(),\n\t\t\t\tJpa.class\n\t\t);\n\n\t\tif ( emfAnnWrapper.isEmpty() ) {\n\t\t\t// assume the annotation is defined on the class-level...\n\t\t\treturn;\n\t\t}\n\n\t\tfindEntityManagerFactoryScope( context.getRequiredTestMethod(), emfAnnWrapper, context );\n\t}\n\n\t@Override\n\tpublic void postProcessTestInstance(Object testInstance, ExtensionContext context) {\n\t\tlog.tracef( \"#postProcessTestInstance(%s, %s)\", testInstance, context.getDisplayName() );\n\n\t\tfinal Optional<Jpa> emfAnnWrapper = AnnotationSupport.findAnnotation(\n\t\t\t\tcontext.getRequiredTestClass(),\n\t\t\t\tJpa.class\n\t\t);\n\n\t\tfindEntityManagerFactoryScope( testInstance, emfAnnWrapper, context );\n\t}\n\n\t@Override\n\tpublic void handleTestExecutionException(ExtensionContext context, Throwable throwable) throws Throwable {\n\t\tlog.tracef( \"#handleTestExecutionException(%s, %s)\", context.getDisplayName(), throwable );\n\n\t\ttry {\n\t\t\tfinal Object testInstance = context.getRequiredTestInstance();\n\t\t\tfinal ExtensionContext.Store store = locateExtensionStore( testInstance, context );\n\t\t\tfinal EntityManagerFactoryScopeImpl scope = (EntityManagerFactoryScopeImpl) store.get( EMF_KEY );\n\t\t\tscope.releaseEntityManagerFactory();\n\t\t}\n\t\tcatch (Exception ignore) {\n\t\t}\n\n\t\tthrow throwable;\n\t}\n\n\tprivate static class EntityManagerFactoryScopeImpl extends AbstractEntityManagerFactoryScope {\n\t\tprivate final PersistenceUnitInfo persistenceUnitInfo;\n\t\tprivate final Map<String, Object> integrationSettings;\n\n\t\tprivate EntityManagerFactoryScopeImpl(\n\t\t\t\tPersistenceUnitInfo persistenceUnitInfo,\n\t\t\t\tMap<String, Object> integrationSettings) {\n\t\t\tthis.persistenceUnitInfo = persistenceUnitInfo;\n\t\t\tthis.integrationSettings = integrationSettings;\n\t\t}\n\n\t\tprotected jakarta.persistence.EntityManagerFactory createEntityManagerFactory() {\n\t\t\tfinal EntityManagerFactoryBuilder emfBuilder = Bootstrap.getEntityManagerFactoryBuilder(\n\t\t\t\t\tnew PersistenceUnitInfoDescriptor( persistenceUnitInfo ),\n\t\t\t\t\tintegrationSettings\n\t\t\t);\n\n\t\t\treturn emfBuilder.build();\n\t\t}\n\t}\n}\n",
        "filePathAfter": "hibernate-testing/src/main/java/org/hibernate/testing/orm/junit/EntityManagerFactoryExtension.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.testing.orm.junit;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Properties;\n\nimport jakarta.persistence.spi.PersistenceUnitInfo;\n\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.cfg.Environment;\nimport org.hibernate.internal.util.ReflectHelper;\nimport org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor;\nimport org.hibernate.query.sqm.mutation.internal.temptable.GlobalTemporaryTableMutationStrategy;\nimport org.hibernate.query.sqm.mutation.internal.temptable.LocalTemporaryTableMutationStrategy;\nimport org.hibernate.query.sqm.mutation.internal.temptable.PersistentTableStrategy;\nimport org.hibernate.tool.schema.Action;\n\nimport org.hibernate.testing.jdbc.SQLStatementInspector;\nimport org.hibernate.testing.orm.domain.DomainModelDescriptor;\nimport org.hibernate.testing.orm.domain.StandardDomainModel;\nimport org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl;\nimport org.hibernate.testing.util.ServiceRegistryUtil;\nimport org.junit.jupiter.api.extension.BeforeEachCallback;\nimport org.junit.jupiter.api.extension.ExtensionContext;\nimport org.junit.jupiter.api.extension.TestExecutionExceptionHandler;\nimport org.junit.jupiter.api.extension.TestInstancePostProcessor;\n\nimport org.jboss.logging.Logger;\n\nimport static org.hibernate.jpa.boot.spi.Bootstrap.getEntityManagerFactoryBuilder;\nimport static org.junit.platform.commons.support.AnnotationSupport.findAnnotation;\n\n/**\n * hibernate-testing implementation of a few JUnit5 contracts to support SessionFactory-based testing,\n * including argument injection (or see {@link SessionFactoryScopeAware})\n *\n * @author Steve Ebersole\n *\n * @see DomainModelExtension\n * @see SessionFactoryExtension\n */\npublic class EntityManagerFactoryExtension\n\t\timplements TestInstancePostProcessor, BeforeEachCallback, TestExecutionExceptionHandler {\n\n\tprivate static final Logger log = Logger.getLogger( EntityManagerFactoryExtension.class );\n\tprivate static final String EMF_KEY = EntityManagerFactoryScope.class.getName();\n\n\tprivate static ExtensionContext.Store locateExtensionStore(Object testScope, ExtensionContext context) {\n\t\treturn JUnitHelper.locateExtensionStore( EntityManagerFactoryExtension.class, context, testScope );\n\t}\n\n\tpublic static EntityManagerFactoryScope findEntityManagerFactoryScope(\n\t\t\tObject testScope, Optional<Jpa> optionalJpa, ExtensionContext context) {\n\n\t\tif ( optionalJpa.isEmpty() ) {\n\t\t\t// No annotation on the test class, should be on the test methods\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n\t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n\t\tif ( existing != null ) {\n\t\t\treturn existing;\n\t\t}\n\t\tif ( context.getElement().isEmpty() ) {\n\t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \"\n\t\t\t\t\t+ context.getDisplayName() );\n\t\t}\n\n\t\tfinal Jpa jpa = optionalJpa.get();\n\t\tfinal PersistenceUnitInfoImpl pui = createPersistenceUnitInfo( jpa );\n\t\tcollectProperties( pui, jpa );\n\t\tmanagedClassesAndMappings( jpa, pui );\n\t\tfinal Map<String, Object> integrationSettings = collectIntegrationSettings( jpa );\n\t\t// statement inspector\n\t\tsetupStatementInspector( jpa, integrationSettings );\n\t\tServiceRegistryUtil.applySettings( integrationSettings );\n\t\tfinal EntityManagerFactoryScopeImpl scope =\n\t\t\t\tnew EntityManagerFactoryScopeImpl( pui, integrationSettings );\n\t\tstore.put( EMF_KEY, scope );\n\t\treturn scope;\n\t}\n\n\tprivate static void collectProperties(PersistenceUnitInfoImpl pui, Jpa jpa) {\n\t\tfinal Properties properties = pui.getProperties();\n\t\tproperties.putAll( Environment.getProperties() );\n\t\t// JpaCompliance\n\t\tsetJpaComplianceProperties( properties, jpa );\n\t\tfor ( Setting property : jpa.properties() ) {\n\t\t\tproperties.setProperty( property.name(), property.value() );\n\t\t}\n\t\tproperties.setProperty(\n\t\t\t\tAvailableSettings.GENERATE_STATISTICS,\n\t\t\t\tBoolean.toString( jpa.generateStatistics() )\n\t\t);\n\t\tif ( jpa.exportSchema() ) {\n\t\t\tproperties.setProperty(\n\t\t\t\t\tAvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,\n\t\t\t\t\tAction.CREATE_DROP.getExternalHbm2ddlName()\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate static PersistenceUnitInfoImpl createPersistenceUnitInfo(Jpa jpa) {\n\t\tfinal PersistenceUnitInfoImpl pui =\n\t\t\t\tnew PersistenceUnitInfoImpl( jpa.persistenceUnitName() );\n\t\tpui.setTransactionType( jpa.transactionType() );\n\t\tpui.setCacheMode( jpa.sharedCacheMode() );\n\t\tpui.setValidationMode( jpa.validationMode() );\n\t\tpui.setExcludeUnlistedClasses( jpa.excludeUnlistedClasses() );\n\t\treturn pui;\n\t}\n\n\tprivate static void managedClassesAndMappings(Jpa jpa, PersistenceUnitInfoImpl pui) {\n\t\tif ( jpa.annotatedPackageNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( jpa.annotatedPackageNames() );\n\t\t}\n\n\t\tif ( jpa.annotatedClassNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( jpa.annotatedClassNames() );\n\t\t}\n\n\t\tif ( jpa.annotatedClasses().length > 0 ) {\n\t\t\tfor (int i = 0; i < jpa.annotatedClasses().length; i++ ) {\n\t\t\t\tpui.applyManagedClassNames( jpa.annotatedClasses()[i].getName() );\n\t\t\t}\n\t\t}\n\n\t\tif ( jpa.xmlMappings().length > 0 ) {\n\t\t\tpui.applyMappingFiles( jpa.xmlMappings() );\n\t\t}\n\n\t\tfor ( StandardDomainModel standardDomainModel : jpa.standardModels() ) {\n\t\t\tfor ( Class<?> annotatedClass : standardDomainModel.getDescriptor().getAnnotatedClasses() ) {\n\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t}\n\t\t}\n\n\t\tfor ( Class<? extends DomainModelDescriptor> modelDescriptorClass :\n\t\t\t\tjpa.modelDescriptorClasses() ) {\n\t\t\tfinal DomainModelDescriptor domainModelDescriptor =\n\t\t\t\t\tinstantiateDomainModelDescriptor( modelDescriptorClass );\n\t\t\tfinal Class<?>[] annotatedClasses = domainModelDescriptor.getAnnotatedClasses();\n\t\t\tfor ( Class<?> annotatedClass : annotatedClasses ) {\n\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static Map<String, Object> collectIntegrationSettings(Jpa jpa) {\n\t\tfinal Map<String, Object> integrationSettings = new HashMap<>();\n\t\tintegrationSettings.put( PersistentTableStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( GlobalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( LocalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tfinal Setting[] settings = jpa.integrationSettings();\n\t\tfor ( Setting setting : settings ) {\n\t\t\tintegrationSettings.put( setting.name(), setting.value() );\n\t\t}\n\t\tfor ( SettingProvider providerAnn : jpa.settingProviders() ) {\n\t\t\tfinal Class<? extends SettingProvider.Provider<?>> providerImpl = providerAnn.provider();\n\t\t\ttry {\n\t\t\t\tintegrationSettings.put( providerAnn.settingName(),\n\t\t\t\t\t\tproviderImpl.getConstructor().newInstance().getSetting() );\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tlog.error( \"Error obtaining setting provider for \" + providerImpl.getName(), e );\n\t\t\t}\n\t\t}\n\t\treturn integrationSettings;\n\t}\n\n\tprivate static void setupStatementInspector(Jpa jpa, Map<String, Object> integrationSettings) {\n\t\tif ( jpa.useCollectingStatementInspector() ) {\n\t\t\tfinal String inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n\t\t\tif ( inspectorSetting != null && !inspectorSetting.isBlank() ) {\n\t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n\t\t\t}\n\t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n\t\t}\n\t}\n\n\tprivate static void setJpaComplianceProperties(Properties properties, Jpa jpa) {\n\t\tproperties.put( AvailableSettings.JPA_COMPLIANCE, jpa.jpaComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_QUERY_COMPLIANCE, jpa.queryComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, jpa.transactionComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_CLOSED_COMPLIANCE, jpa.closedComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_PROXY_COMPLIANCE, jpa.proxyComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_CACHING_COMPLIANCE, jpa.cacheComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, jpa.generatorScopeComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, jpa.orderByMappingComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, jpa.loadByIdComplianceEnabled() );\n\t}\n\n\tprivate static DomainModelDescriptor instantiateDomainModelDescriptor(\n\t\t\tClass<? extends DomainModelDescriptor> modelDescriptorClass) {\n\t\t// first, see if it has a static singleton reference and use that if so\n\t\ttry {\n\t\t\tfor ( Field field : modelDescriptorClass.getDeclaredFields() ) {\n\t\t\t\tif ( ReflectHelper.isStaticField(field) ) {\n\t\t\t\t\tfinal Object value = field.get( null );\n\t\t\t\t\tif ( value instanceof DomainModelDescriptor descriptor ) {\n\t\t\t\t\t\treturn descriptor;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalAccessException e) {\n\t\t\tthrow new RuntimeException( \"Problem accessing DomainModelDescriptor fields : \"\n\t\t\t\t\t+ modelDescriptorClass.getName(), e );\n\t\t}\n\n\t\t// no singleton field, try to instantiate it via reflection\n\t\ttry {\n\t\t\treturn modelDescriptorClass.getConstructor( null ).newInstance( null );\n\t\t}\n\t\tcatch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {\n\t\t\tthrow new RuntimeException( \"Problem instantiation DomainModelDescriptor : \"\n\t\t\t\t\t+ modelDescriptorClass.getName(), e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void beforeEach(ExtensionContext context) {\n\t\tlog.tracef( \"#beforeEach(%s)\", context.getDisplayName() );\n\t\tfinal Optional<Jpa> optionalJpa = findAnnotation( context.getRequiredTestMethod(), Jpa.class );\n\t\tif ( optionalJpa.isPresent() ) {\n\t\t\tfindEntityManagerFactoryScope( context.getRequiredTestMethod(), optionalJpa, context );\n\t\t}\n\t\t// else assume the annotation is defined on the class-level...\n\t}\n\n\t@Override\n\tpublic void postProcessTestInstance(Object testInstance, ExtensionContext context) {\n\t\tlog.tracef( \"#postProcessTestInstance(%s, %s)\", testInstance, context.getDisplayName() );\n\t\tfinal Optional<Jpa> optionalJpa = findAnnotation( context.getRequiredTestClass(), Jpa.class );\n\t\tfindEntityManagerFactoryScope( testInstance, optionalJpa, context );\n\t}\n\n\t@Override\n\tpublic void handleTestExecutionException(ExtensionContext context, Throwable throwable) throws Throwable {\n\t\tlog.tracef( \"#handleTestExecutionException(%s, %s)\", context.getDisplayName(), throwable );\n\t\ttry {\n\t\t\tfinal ExtensionContext.Store store = locateExtensionStore( context.getRequiredTestInstance(), context );\n\t\t\tfinal EntityManagerFactoryScopeImpl scope = (EntityManagerFactoryScopeImpl) store.get( EMF_KEY );\n\t\t\tscope.releaseEntityManagerFactory();\n\t\t}\n\t\tcatch (Exception ignore) {\n\t\t}\n\t\tthrow throwable;\n\t}\n\n\tprivate static class EntityManagerFactoryScopeImpl extends AbstractEntityManagerFactoryScope {\n\t\tprivate final PersistenceUnitInfo persistenceUnitInfo;\n\t\tprivate final Map<String, Object> integrationSettings;\n\n\t\tprivate EntityManagerFactoryScopeImpl(\n\t\t\t\tPersistenceUnitInfo persistenceUnitInfo,\n\t\t\t\tMap<String, Object> integrationSettings) {\n\t\t\tthis.persistenceUnitInfo = persistenceUnitInfo;\n\t\t\tthis.integrationSettings = integrationSettings;\n\t\t}\n\n\t\tprotected jakarta.persistence.EntityManagerFactory createEntityManagerFactory() {\n\t\t\tfinal PersistenceUnitInfoDescriptor descriptor = new PersistenceUnitInfoDescriptor( persistenceUnitInfo );\n\t\t\treturn getEntityManagerFactoryBuilder( descriptor, integrationSettings ).build();\n\t\t}\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private static PersistenceUnitInfoImpl createPersistenceUnitInfo(Jpa jpa) {\n\t\tfinal PersistenceUnitInfoImpl pui =\n\t\t\t\tnew PersistenceUnitInfoImpl( jpa.persistenceUnitName() );\n\t\tpui.setTransactionType( jpa.transactionType() );\n\t\tpui.setCacheMode( jpa.sharedCacheMode() );\n\t\tpui.setValidationMode( jpa.validationMode() );\n\t\tpui.setExcludeUnlistedClasses( jpa.excludeUnlistedClasses() );\n\t\treturn pui;\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#setValidationMode\n methodBody: public void setValidationMode(String validationMode) {\nsetValidationMode(ValidationMode.valueOf(validationMode));\n}",
            "methodSignature: org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}",
            "methodSignature: org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor#getName\n methodBody: public String getName() {\nreturn persistenceUnitInfo.getPersistenceUnitName();\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setTransactionType\n methodBody: public void setTransactionType(PersistenceUnitTransactionType transactionType) {\nthis.transactionType=transactionType;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest#applySettings\n methodBody: protected void applySettings(Map<Object, Object> settings) {\nString[] mappings=getMappings();\nif(mappings != null){settings.put(AvailableSettings.HBM_XML_FILES,String.join(\",\",mappings));\n}}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setValidationMode\n methodBody: public void setValidationMode(ValidationMode validationMode) {\nthis.validationMode=validationMode;\n}",
            "methodSignature: org.hibernate.collection.spi.AbstractPersistentCollection.SetProxy#isEmpty\n methodBody: public boolean isEmpty() {\nreturn set.isEmpty();\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#applyMappingFiles\n methodBody: public void applyMappingFiles(String... mappingFiles) {\nif(this.mappingFiles == null){this.mappingFiles=new ArrayList<>();\n}Collections.addAll(this.mappingFiles,mappingFiles);\n}",
            "methodSignature: org.hibernate.testing.util.jpa.DelegatingPersistenceUnitInfo#getProperties\n methodBody: public Properties getProperties() {\nreturn delegate.getProperties();\n}",
            "methodSignature: org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentList#get\n methodBody: public E get(int index) {\nif(index < 0){throw new ArrayIndexOutOfBoundsException(\"negative index\");\n}final Object result=readElementByIndex(index);\nreturn result == UNKNOWN ? list.get(index) : (E)result;\n}",
            "methodSignature: org.hibernate.orm.test.bootstrap.BootstrapTest.PersistenceUnitInfoImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest.TestingPersistenceUnitDescriptorImpl#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.jpa.boot.spi.PersistenceConfigurationDescriptor#getName\n methodBody: public String getName() {\nreturn persistenceConfiguration.name();\n}",
            "methodSignature: org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor#getProperties\n methodBody: public Properties getProperties() {\nreturn persistenceUnitInfo.getProperties();\n}",
            "methodSignature: org.hibernate.jpa.boot.spi.PersistenceUnitDescriptor#getProperties\n methodBody: Properties getProperties();",
            "methodSignature: org.hibernate.testing.orm.junit.BaseSessionFactoryFunctionalTest#getAnnotatedClasses\n methodBody: protected Class[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.BaseSessionFactoryFunctionalTest#applySettings\n methodBody: protected void applySettings(StandardServiceRegistryBuilder builder) {\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoAdapter#getProperties\n methodBody: public Properties getProperties() {\nif(properties == null){properties=new Properties();\n}return properties;\n}",
            "methodSignature: org.hibernate.testing.util.jpa.DelegatingPersistenceUnitInfo#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn delegate.excludeUnlistedClasses();\n}",
            "methodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoAdapter#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setCacheMode\n methodBody: public void setCacheMode(SharedCacheMode cacheMode) {\nthis.cacheMode=cacheMode;\n}",
            "methodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.orm.test.jpa.BaseEntityManagerFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn excludeUnlistedClasses;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}",
            "methodSignature: org.hibernate.collection.spi.AbstractPersistentCollection.ListProxy#get\n methodBody: public E get(int i) {\nreturn list.get(i);\n}",
            "methodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoAdapter#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}",
            "methodSignature: org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}",
            "methodSignature: org.hibernate.orm.test.bootstrap.BootstrapTest.PersistenceUnitInfoImpl#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}",
            "methodSignature: org.hibernate.jpa.boot.spi.PersistenceConfigurationDescriptor#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitDescriptorAdapter#getProperties\n methodBody: public Properties getProperties() {\nif(properties == null){properties=new Properties();\n}return properties;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentBag#get\n methodBody: public E get(int i) {\nread();\nreturn bag.get(i);\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoAdapter#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setExcludeUnlistedClasses\n methodBody: public void setExcludeUnlistedClasses(boolean excludeUnlistedClasses) {\nthis.excludeUnlistedClasses=excludeUnlistedClasses;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentList#toString\n methodBody: public String toString() {\nread();\nreturn list.toString();\n}",
            "methodSignature: org.hibernate.testing.junit4.BaseCoreFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentBag#getElement\n methodBody: public Object getElement(Object entry) {\nreturn entry;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentBag#isEmpty\n methodBody: public boolean isEmpty() {\nreturn readSize() ? getCachedSize() == 0 : bag.isEmpty();\n}",
            "methodSignature: org.hibernate.orm.test.jpa.xml.versions.JpaXsdVersionsTest.PersistenceUnitInfoImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}",
            "methodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#setTransactionType\n methodBody: public void setTransactionType(PersistenceUnitTransactionType transactionType) {\nthis.transactionType=transactionType;\n}",
            "methodSignature: org.hibernate.orm.test.jpa.EntityManagerTest#getAnnotatedClasses\n methodBody: public Class[] getAnnotatedClasses() {\nreturn new Class[]{Item.class,Distributor.class,Wallet.class};\n}",
            "methodSignature: org.hibernate.orm.test.jpa.BaseEntityManagerFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest#exportSchema\n methodBody: protected boolean exportSchema() {\nreturn true;\n}",
            "methodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}",
            "methodSignature: org.hibernate.internal.SessionFactoryImpl#getProperties\n methodBody: public Map<String, Object> getProperties() {\nvalidateNotClosed();\nreturn settings;\n}",
            "methodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoPropertiesWrapper#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}",
            "methodSignature: org.hibernate.orm.test.jpa.xml.versions.JpaXsdVersionsTest.PersistenceUnitInfoImpl#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}",
            "methodSignature: org.hibernate.jpa.boot.spi.PersistenceUnitDescriptor#getName\n methodBody: String getName();",
            "methodSignature: org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn null;\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitDescriptorAdapter#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryExtension#locateExtensionStore\n methodBody: private static ExtensionContext.Store locateExtensionStore(Object testScope, ExtensionContext context) {\nreturn JUnitHelper.locateExtensionStore(EntityManagerFactoryExtension.class,context,testScope);\n}",
            "methodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#setExcludeUnlistedClasses\n methodBody: public void setExcludeUnlistedClasses(boolean excludeUnlistedClasses) {\nthis.excludeUnlistedClasses=excludeUnlistedClasses;\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#applyManagedClassNames\n methodBody: public void applyManagedClassNames(String... managedClassNames) {\nif(this.managedClassNames == null){this.managedClassNames=new ArrayList<>();\n}Collections.addAll(this.managedClassNames,managedClassNames);\n}",
            "methodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoPropertiesWrapper#getProperties\n methodBody: public Properties getProperties() {\nif(properties == null){properties=new Properties();\n}return properties;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentList#getElement\n methodBody: public Object getElement(Object entry) {\nreturn entry;\n}",
            "methodSignature: org.hibernate.orm.test.jpa.BaseEntityManagerFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn null;\n}",
            "methodSignature: org.hibernate.internal.SessionFactoryImpl#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest.TestingPersistenceUnitDescriptorImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn null;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentList#isEmpty\n methodBody: public boolean isEmpty() {\nreturn readSize() ? getCachedSize() == 0 : list.isEmpty();\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryExtension#instantiateDomainModelDescriptor\n methodBody: private static DomainModelDescriptor instantiateDomainModelDescriptor(Class<? extends DomainModelDescriptor> modelDescriptorClass) {\ntryfinal Field[] declaredFields=modelDescriptorClass.getDeclaredFields();\nfor(int i=0; i < declaredFields.length; i++){final Field field=declaredFields[i];\nif(ReflectHelper.isStaticField(field)){final Object value=field.get(null);\nif(value instanceof DomainModelDescriptor){return (DomainModelDescriptor)value;\n}}}catch(IllegalAccessException e)throw new RuntimeException(\"Problem accessing DomainModelDescriptor fields : \" + modelDescriptorClass.getName(),e);\ntryreturn modelDescriptorClass.getConstructor(null).newInstance(null);\ncatch(InstantiationException|IllegalAccessException|InvocationTargetException|NoSuchMethodException e)throw new RuntimeException(\"Problem instantiation DomainModelDescriptor : \" + modelDescriptorClass.getName(),e);\n}",
            "methodSignature: org.hibernate.testing.orm.junit.BaseSessionFactoryFunctionalTest#exportSchema\n methodBody: protected boolean exportSchema() {\nreturn true;\n}",
            "methodSignature: org.hibernate.collection.spi.AbstractPersistentCollection.ListProxy#isEmpty\n methodBody: public boolean isEmpty() {\nreturn list.isEmpty();\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentBag#toString\n methodBody: public String toString() {\nread();\nreturn bag.toString();\n}"
        ],
        "sourceCodeAfterRefactoring": "public static EntityManagerFactoryScope findEntityManagerFactoryScope(\n\t\t\tObject testScope, Optional<Jpa> optionalJpa, ExtensionContext context) {\n\n\t\tif ( optionalJpa.isEmpty() ) {\n\t\t\t// No annotation on the test class, should be on the test methods\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n\t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n\t\tif ( existing != null ) {\n\t\t\treturn existing;\n\t\t}\n\t\tif ( context.getElement().isEmpty() ) {\n\t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \"\n\t\t\t\t\t+ context.getDisplayName() );\n\t\t}\n\n\t\tfinal Jpa jpa = optionalJpa.get();\n\t\tfinal PersistenceUnitInfoImpl pui = createPersistenceUnitInfo( jpa );\n\t\tcollectProperties( pui, jpa );\n\t\tmanagedClassesAndMappings( jpa, pui );\n\t\tfinal Map<String, Object> integrationSettings = collectIntegrationSettings( jpa );\n\t\t// statement inspector\n\t\tsetupStatementInspector( jpa, integrationSettings );\n\t\tServiceRegistryUtil.applySettings( integrationSettings );\n\t\tfinal EntityManagerFactoryScopeImpl scope =\n\t\t\t\tnew EntityManagerFactoryScopeImpl( pui, integrationSettings );\n\t\tstore.put( EMF_KEY, scope );\n\t\treturn scope;\n\t}\nprivate static PersistenceUnitInfoImpl createPersistenceUnitInfo(Jpa jpa) {\n\t\tfinal PersistenceUnitInfoImpl pui =\n\t\t\t\tnew PersistenceUnitInfoImpl( jpa.persistenceUnitName() );\n\t\tpui.setTransactionType( jpa.transactionType() );\n\t\tpui.setCacheMode( jpa.sharedCacheMode() );\n\t\tpui.setValidationMode( jpa.validationMode() );\n\t\tpui.setExcludeUnlistedClasses( jpa.excludeUnlistedClasses() );\n\t\treturn pui;\n\t}",
        "diffSourceCode": "-   61: \n-   62: \tprivate static ExtensionContext.Store locateExtensionStore(Object testScope, ExtensionContext context) {\n-   63: \t\treturn JUnitHelper.locateExtensionStore( EntityManagerFactoryExtension.class, context, testScope );\n-   64: \t}\n-   65: \n-   66: \tpublic static EntityManagerFactoryScope findEntityManagerFactoryScope(\n-   67: \t\t\tObject testScope,\n-   68: \t\t\tOptional<Jpa> emfAnnWrapper,\n-   69: \t\t\tExtensionContext context) {\n-   70: \n-   71: \t\tif ( emfAnnWrapper.isEmpty() ) {\n-   72: \t\t\t// No annotation on the test class, should be on the test methods\n-   73: \t\t\treturn null;\n-   74: \t\t}\n-   75: \n-   76: \t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n-   77: \t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n-   78: \t\tif ( existing != null ) {\n-   79: \t\t\treturn existing;\n-   80: \t\t}\n-   81: \n-   82: \t\tif ( !context.getElement().isPresent() ) {\n-   83: \t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \" + context.getDisplayName() );\n-   84: \t\t}\n-   85: \t\tfinal Jpa emfAnn = emfAnnWrapper.get();\n-   86: \n-   87: \t\tfinal PersistenceUnitInfoImpl pui = new PersistenceUnitInfoImpl( emfAnn.persistenceUnitName() );\n-   88: \t\t( (Map<Object, Object>) Environment.getProperties() ).forEach(\n-   89: \t\t\t\t(key, value) ->\n-   90: \t\t\t\t\t\tpui.getProperties().put( key, value )\n-   91: \t\t);\n+   61: \tpublic static EntityManagerFactoryScope findEntityManagerFactoryScope(\n+   62: \t\t\tObject testScope, Optional<Jpa> optionalJpa, ExtensionContext context) {\n+   63: \n+   64: \t\tif ( optionalJpa.isEmpty() ) {\n+   65: \t\t\t// No annotation on the test class, should be on the test methods\n+   66: \t\t\treturn null;\n+   67: \t\t}\n+   68: \n+   69: \t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n+   70: \t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n+   71: \t\tif ( existing != null ) {\n+   72: \t\t\treturn existing;\n+   73: \t\t}\n+   74: \t\tif ( context.getElement().isEmpty() ) {\n+   75: \t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \"\n+   76: \t\t\t\t\t+ context.getDisplayName() );\n+   77: \t\t}\n+   78: \n+   79: \t\tfinal Jpa jpa = optionalJpa.get();\n+   80: \t\tfinal PersistenceUnitInfoImpl pui = createPersistenceUnitInfo( jpa );\n+   81: \t\tcollectProperties( pui, jpa );\n+   82: \t\tmanagedClassesAndMappings( jpa, pui );\n+   83: \t\tfinal Map<String, Object> integrationSettings = collectIntegrationSettings( jpa );\n+   84: \t\t// statement inspector\n+   85: \t\tsetupStatementInspector( jpa, integrationSettings );\n+   86: \t\tServiceRegistryUtil.applySettings( integrationSettings );\n+   87: \t\tfinal EntityManagerFactoryScopeImpl scope =\n+   88: \t\t\t\tnew EntityManagerFactoryScopeImpl( pui, integrationSettings );\n+   89: \t\tstore.put( EMF_KEY, scope );\n+   90: \t\treturn scope;\n+   91: \t}\n    92: \n-   93: \t\tpui.setTransactionType( emfAnn.transactionType() );\n-   94: \t\tpui.setCacheMode( emfAnn.sharedCacheMode() );\n-   95: \t\tpui.setValidationMode( emfAnn.validationMode() );\n-   96: \t\tpui.setExcludeUnlistedClasses( emfAnn.excludeUnlistedClasses() );\n-   97: \n-   98: \t\t// JpaCompliance\n-   99: \t\tpui.getProperties().put( AvailableSettings.JPA_COMPLIANCE, emfAnn.jpaComplianceEnabled() );\n-  100: \t\tpui.getProperties().put( AvailableSettings.JPA_QUERY_COMPLIANCE, emfAnn.queryComplianceEnabled() );\n-  101: \t\tpui.getProperties().put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, emfAnn.transactionComplianceEnabled() );\n-  102: \t\tpui.getProperties().put( AvailableSettings.JPA_CLOSED_COMPLIANCE, emfAnn.closedComplianceEnabled() );\n-  103: \t\tpui.getProperties().put( AvailableSettings.JPA_PROXY_COMPLIANCE, emfAnn.proxyComplianceEnabled() );\n-  104: \t\tpui.getProperties().put( AvailableSettings.JPA_CACHING_COMPLIANCE, emfAnn.cacheComplianceEnabled() );\n-  105: \t\tpui.getProperties().put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, emfAnn.generatorScopeComplianceEnabled() );\n-  106: \t\tpui.getProperties().put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, emfAnn.orderByMappingComplianceEnabled() );\n-  107: \t\tpui.getProperties().put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, emfAnn.loadByIdComplianceEnabled() );\n-  108: \n-  109: \t\tfinal Setting[] properties = emfAnn.properties();\n-  110: \t\tfor ( int i = 0; i < properties.length; i++ ) {\n-  111: \t\t\tfinal Setting property = properties[i];\n-  112: \t\t\tpui.getProperties().setProperty( property.name(), property.value() );\n-  113: \t\t}\n-  114: \n-  115: \t\tpui.getProperties().setProperty(\n-  116: \t\t\t\tAvailableSettings.GENERATE_STATISTICS,\n-  117: \t\t\t\tBoolean.toString( emfAnn.generateStatistics() )\n-  118: \t\t);\n-  119: \n-  120: \t\tif ( emfAnn.exportSchema() ) {\n-  121: \t\t\tpui.getProperties().setProperty(\n-  122: \t\t\t\t\tAvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,\n-  123: \t\t\t\t\tAction.CREATE_DROP.getExternalHbm2ddlName()\n-  124: \t\t\t);\n-  125: \t\t}\n-  126: \n-  127: \t\tif ( emfAnn.annotatedPackageNames().length > 0 ) {\n-  128: \t\t\tpui.applyManagedClassNames( emfAnn.annotatedPackageNames() );\n-  129: \t\t}\n-  130: \n-  131: \t\tif ( emfAnn.annotatedClassNames().length > 0 ) {\n-  132: \t\t\tpui.applyManagedClassNames( emfAnn.annotatedClassNames() );\n-  133: \t\t}\n-  134: \n-  135: \t\tif ( emfAnn.annotatedClasses().length > 0 ) {\n-  136: \t\t\tfor ( int i = 0; i < emfAnn.annotatedClasses().length; i++ ) {\n-  137: \t\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClasses()[i].getName() );\n-  138: \t\t\t}\n-  139: \t\t}\n-  140: \n-  141: \t\tif ( emfAnn.xmlMappings().length > 0 ) {\n-  142: \t\t\tpui.applyMappingFiles( emfAnn.xmlMappings() );\n-  143: \t\t}\n-  144: \n-  145: \t\tif ( emfAnn.standardModels().length > 0 ) {\n-  146: \t\t\tfor ( int i = 0; i < emfAnn.standardModels().length; i++ ) {\n-  147: \t\t\t\tfinal StandardDomainModel standardDomainModel = emfAnn.standardModels()[i];\n-  148: \t\t\t\tfor ( int i1 = 0; i1 < standardDomainModel.getDescriptor().getAnnotatedClasses().length; i1++ ) {\n-  149: \t\t\t\t\tfinal Class<?> annotatedClass = standardDomainModel.getDescriptor().getAnnotatedClasses()[i1];\n-  150: \t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n-  151: \t\t\t\t}\n-  152: \t\t\t}\n-  153: \t\t}\n-  154: \n-  155: \t\tif ( emfAnn.modelDescriptorClasses().length > 0 ) {\n-  156: \t\t\tfor ( int i = 0; i < emfAnn.modelDescriptorClasses().length; i++ ) {\n-  157: \t\t\t\tfinal Class<? extends DomainModelDescriptor> modelDescriptorClass = emfAnn.modelDescriptorClasses()[i];\n-  158: \t\t\t\tfinal DomainModelDescriptor domainModelDescriptor = instantiateDomainModelDescriptor(\n-  159: \t\t\t\t\t\tmodelDescriptorClass );\n-  160: \t\t\t\tfor ( int i1 = 0; i1 < domainModelDescriptor.getAnnotatedClasses().length; i1++ ) {\n-  161: \t\t\t\t\tfinal Class<?> annotatedClass = domainModelDescriptor.getAnnotatedClasses()[i1];\n-  162: \t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n-  163: \t\t\t\t}\n-  164: \t\t\t}\n-  165: \t\t}\n-  166: \n-  167: \t\tfinal Map<String, Object> integrationSettings = new HashMap<>();\n-  168: \n-  169: \t\tintegrationSettings.put( PersistentTableStrategy.DROP_ID_TABLES, \"true\" );\n-  170: \t\tintegrationSettings.put( GlobalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n-  171: \t\tintegrationSettings.put( LocalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n-  172: \t\tfor ( int i = 0; i < emfAnn.integrationSettings().length; i++ ) {\n-  173: \t\t\tfinal Setting setting = emfAnn.integrationSettings()[i];\n-  174: \t\t\tintegrationSettings.put( setting.name(), setting.value() );\n-  175: \t\t}\n-  176: \n-  177: \t\tfor ( SettingProvider providerAnn : emfAnn.settingProviders() ) {\n-  178: \t\t\tfinal Class<? extends SettingProvider.Provider<?>> providerImpl = providerAnn.provider();\n-  179: \t\t\ttry {\n-  180: \t\t\t\tfinal SettingProvider.Provider<?> provider = providerImpl.getConstructor().newInstance();\n-  181: \t\t\t\tintegrationSettings.put( providerAnn.settingName(), provider.getSetting() );\n-  182: \t\t\t}\n-  183: \t\t\tcatch (Exception e) {\n-  184: \t\t\t\tlog.error( \"Error obtaining setting provider for \" + providerImpl.getName(), e );\n-  185: \t\t\t}\n-  186: \t\t}\n-  187: \n-  188: \t\t// statement inspector\n-  189: \t\tif ( emfAnn.useCollectingStatementInspector() ) {\n-  190: \t\t\tString inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n-  191: \t\t\tif ( !(inspectorSetting == null || inspectorSetting.isBlank()) ) {\n-  192: \t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n-  193: \t\t\t}\n-  194: \t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n-  195: \t\t}\n-  196: \n-  197: \t\tServiceRegistryUtil.applySettings( integrationSettings );\n-  198: \t\tfinal EntityManagerFactoryScopeImpl scope = new EntityManagerFactoryScopeImpl( pui, integrationSettings );\n-  199: \n-  200: \t\tstore.put( EMF_KEY, scope );\n-  201: \n-  202: \t\treturn scope;\n-  203: \t}\n+   93: \tprivate static void collectProperties(PersistenceUnitInfoImpl pui, Jpa jpa) {\n+   94: \t\tfinal Properties properties = pui.getProperties();\n+   95: \t\tproperties.putAll( Environment.getProperties() );\n+   96: \t\t// JpaCompliance\n+   97: \t\tsetJpaComplianceProperties( properties, jpa );\n+   98: \t\tfor ( Setting property : jpa.properties() ) {\n+   99: \t\t\tproperties.setProperty( property.name(), property.value() );\n+  100: \t\t}\n+  101: \t\tproperties.setProperty(\n+  102: \t\t\t\tAvailableSettings.GENERATE_STATISTICS,\n+  103: \t\t\t\tBoolean.toString( jpa.generateStatistics() )\n+  104: \t\t);\n+  105: \t\tif ( jpa.exportSchema() ) {\n+  106: \t\t\tproperties.setProperty(\n+  107: \t\t\t\t\tAvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,\n+  108: \t\t\t\t\tAction.CREATE_DROP.getExternalHbm2ddlName()\n+  109: \t\t\t);\n+  110: \t\t}\n+  111: \t}\n+  112: \n+  113: \tprivate static PersistenceUnitInfoImpl createPersistenceUnitInfo(Jpa jpa) {\n+  114: \t\tfinal PersistenceUnitInfoImpl pui =\n+  115: \t\t\t\tnew PersistenceUnitInfoImpl( jpa.persistenceUnitName() );\n+  116: \t\tpui.setTransactionType( jpa.transactionType() );\n+  117: \t\tpui.setCacheMode( jpa.sharedCacheMode() );\n+  118: \t\tpui.setValidationMode( jpa.validationMode() );\n+  119: \t\tpui.setExcludeUnlistedClasses( jpa.excludeUnlistedClasses() );\n+  120: \t\treturn pui;\n+  121: \t}\n+  122: \n+  123: \tprivate static void managedClassesAndMappings(Jpa jpa, PersistenceUnitInfoImpl pui) {\n+  124: \t\tif ( jpa.annotatedPackageNames().length > 0 ) {\n+  125: \t\t\tpui.applyManagedClassNames( jpa.annotatedPackageNames() );\n+  126: \t\t}\n+  127: \n+  128: \t\tif ( jpa.annotatedClassNames().length > 0 ) {\n+  129: \t\t\tpui.applyManagedClassNames( jpa.annotatedClassNames() );\n+  130: \t\t}\n+  131: \n+  132: \t\tif ( jpa.annotatedClasses().length > 0 ) {\n+  133: \t\t\tfor (int i = 0; i < jpa.annotatedClasses().length; i++ ) {\n+  134: \t\t\t\tpui.applyManagedClassNames( jpa.annotatedClasses()[i].getName() );\n+  135: \t\t\t}\n+  136: \t\t}\n+  137: \n+  138: \t\tif ( jpa.xmlMappings().length > 0 ) {\n+  139: \t\t\tpui.applyMappingFiles( jpa.xmlMappings() );\n+  140: \t\t}\n+  141: \n+  142: \t\tfor ( StandardDomainModel standardDomainModel : jpa.standardModels() ) {\n+  143: \t\t\tfor ( Class<?> annotatedClass : standardDomainModel.getDescriptor().getAnnotatedClasses() ) {\n+  144: \t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n+  145: \t\t\t}\n+  146: \t\t}\n+  147: \n+  148: \t\tfor ( Class<? extends DomainModelDescriptor> modelDescriptorClass :\n+  149: \t\t\t\tjpa.modelDescriptorClasses() ) {\n+  150: \t\t\tfinal DomainModelDescriptor domainModelDescriptor =\n+  151: \t\t\t\t\tinstantiateDomainModelDescriptor( modelDescriptorClass );\n+  152: \t\t\tfinal Class<?>[] annotatedClasses = domainModelDescriptor.getAnnotatedClasses();\n+  153: \t\t\tfor ( Class<?> annotatedClass : annotatedClasses ) {\n+  154: \t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n+  155: \t\t\t}\n+  156: \t\t}\n+  157: \t}\n+  158: \n+  159: \tprivate static Map<String, Object> collectIntegrationSettings(Jpa jpa) {\n+  160: \t\tfinal Map<String, Object> integrationSettings = new HashMap<>();\n+  161: \t\tintegrationSettings.put( PersistentTableStrategy.DROP_ID_TABLES, \"true\" );\n+  162: \t\tintegrationSettings.put( GlobalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n+  163: \t\tintegrationSettings.put( LocalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n+  164: \t\tfinal Setting[] settings = jpa.integrationSettings();\n+  165: \t\tfor ( Setting setting : settings ) {\n+  166: \t\t\tintegrationSettings.put( setting.name(), setting.value() );\n+  167: \t\t}\n+  168: \t\tfor ( SettingProvider providerAnn : jpa.settingProviders() ) {\n+  169: \t\t\tfinal Class<? extends SettingProvider.Provider<?>> providerImpl = providerAnn.provider();\n+  170: \t\t\ttry {\n+  171: \t\t\t\tintegrationSettings.put( providerAnn.settingName(),\n+  172: \t\t\t\t\t\tproviderImpl.getConstructor().newInstance().getSetting() );\n+  173: \t\t\t}\n+  174: \t\t\tcatch (Exception e) {\n+  175: \t\t\t\tlog.error( \"Error obtaining setting provider for \" + providerImpl.getName(), e );\n+  176: \t\t\t}\n+  177: \t\t}\n+  178: \t\treturn integrationSettings;\n+  179: \t}\n+  180: \n+  181: \tprivate static void setupStatementInspector(Jpa jpa, Map<String, Object> integrationSettings) {\n+  182: \t\tif ( jpa.useCollectingStatementInspector() ) {\n+  183: \t\t\tfinal String inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n+  184: \t\t\tif ( inspectorSetting != null && !inspectorSetting.isBlank() ) {\n+  185: \t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n+  186: \t\t\t}\n+  187: \t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n+  188: \t\t}\n+  189: \t}\n+  190: \n+  191: \tprivate static void setJpaComplianceProperties(Properties properties, Jpa jpa) {\n+  192: \t\tproperties.put( AvailableSettings.JPA_COMPLIANCE, jpa.jpaComplianceEnabled() );\n+  193: \t\tproperties.put( AvailableSettings.JPA_QUERY_COMPLIANCE, jpa.queryComplianceEnabled() );\n+  194: \t\tproperties.put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, jpa.transactionComplianceEnabled() );\n+  195: \t\tproperties.put( AvailableSettings.JPA_CLOSED_COMPLIANCE, jpa.closedComplianceEnabled() );\n+  196: \t\tproperties.put( AvailableSettings.JPA_PROXY_COMPLIANCE, jpa.proxyComplianceEnabled() );\n+  197: \t\tproperties.put( AvailableSettings.JPA_CACHING_COMPLIANCE, jpa.cacheComplianceEnabled() );\n+  198: \t\tproperties.put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, jpa.generatorScopeComplianceEnabled() );\n+  199: \t\tproperties.put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, jpa.orderByMappingComplianceEnabled() );\n+  200: \t\tproperties.put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, jpa.loadByIdComplianceEnabled() );\n+  201: \t}\n+  202: \n+  203: \tprivate static DomainModelDescriptor instantiateDomainModelDescriptor(\n",
        "uniqueId": "4781c09d0df0eb4ce05b2fa0d2a12747023ae024_66_203_113_121_61_91",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 7,
                "covered": 55
            },
            "BRANCH": {
                "missed": 1,
                "covered": 5
            },
            "LINE": {
                "missed": 2,
                "covered": 17
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 3
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\nprivate static ExtensionContext.Store locateExtensionStore(Object testScope, ExtensionContext context) {\n    return JUnitHelper.locateExtensionStore(EntityManagerFactoryExtension.class, context, testScope);\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\npublic static EntityManagerFactoryScope findEntityManagerFactoryScope(\n\t\t\tObject testScope,\n\t\t\tOptional<Jpa> emfAnnWrapper,\n\t\t\tExtensionContext context) {\n\n\t\tif ( emfAnnWrapper.isEmpty() ) {\n\t\t\t// No annotation on the test class, should be on the test methods\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n\t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n\t\tif ( existing != null ) {\n\t\t\treturn existing;\n\t\t}\n\n\t\tif ( !context.getElement().isPresent() ) {\n\t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \" + context.getDisplayName() );\n\t\t}\n\t\tfinal Jpa emfAnn = emfAnnWrapper.get();\n\n\t\tfinal PersistenceUnitInfoImpl pui = new PersistenceUnitInfoImpl( emfAnn.persistenceUnitName() );\n\t\t( (Map<Object, Object>) Environment.getProperties() ).forEach(\n\t\t\t\t(key, value) ->\n\t\t\t\t\t\tpui.getProperties().put( key, value )\n\t\t);\n\n\t\tpui.setTransactionType( emfAnn.transactionType() );\n\t\tpui.setCacheMode( emfAnn.sharedCacheMode() );\n\t\tpui.setValidationMode( emfAnn.validationMode() );\n\t\tpui.setExcludeUnlistedClasses( emfAnn.excludeUnlistedClasses() );\n\n\t\t// JpaCompliance\n\t\tpui.getProperties().put( AvailableSettings.JPA_COMPLIANCE, emfAnn.jpaComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_QUERY_COMPLIANCE, emfAnn.queryComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, emfAnn.transactionComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_CLOSED_COMPLIANCE, emfAnn.closedComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_PROXY_COMPLIANCE, emfAnn.proxyComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_CACHING_COMPLIANCE, emfAnn.cacheComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, emfAnn.generatorScopeComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, emfAnn.orderByMappingComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, emfAnn.loadByIdComplianceEnabled() );\n\n\t\tfinal Setting[] properties = emfAnn.properties();\n\t\tfor ( int i = 0; i < properties.length; i++ ) {\n\t\t\tfinal Setting property = properties[i];\n\t\t\tpui.getProperties().setProperty( property.name(), property.value() );\n\t\t}\n\n\t\tpui.getProperties().setProperty(\n\t\t\t\tAvailableSettings.GENERATE_STATISTICS,\n\t\t\t\tBoolean.toString( emfAnn.generateStatistics() )\n\t\t);\n\n\t\tif ( emfAnn.exportSchema() ) {\n\t\t\tpui.getProperties().setProperty(\n\t\t\t\t\tAvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,\n\t\t\t\t\tAction.CREATE_DROP.getExternalHbm2ddlName()\n\t\t\t);\n\t\t}\n\n\t\tif ( emfAnn.annotatedPackageNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( emfAnn.annotatedPackageNames() );\n\t\t}\n\n\t\tif ( emfAnn.annotatedClassNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClassNames() );\n\t\t}\n\n\t\tif ( emfAnn.annotatedClasses().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.annotatedClasses().length; i++ ) {\n\t\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClasses()[i].getName() );\n\t\t\t}\n\t\t}\n\n\t\tif ( emfAnn.xmlMappings().length > 0 ) {\n\t\t\tpui.applyMappingFiles( emfAnn.xmlMappings() );\n\t\t}\n\n\t\tif ( emfAnn.standardModels().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.standardModels().length; i++ ) {\n\t\t\t\tfinal StandardDomainModel standardDomainModel = emfAnn.standardModels()[i];\n\t\t\t\tfor ( int i1 = 0; i1 < standardDomainModel.getDescriptor().getAnnotatedClasses().length; i1++ ) {\n\t\t\t\t\tfinal Class<?> annotatedClass = standardDomainModel.getDescriptor().getAnnotatedClasses()[i1];\n\t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( emfAnn.modelDescriptorClasses().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.modelDescriptorClasses().length; i++ ) {\n\t\t\t\tfinal Class<? extends DomainModelDescriptor> modelDescriptorClass = emfAnn.modelDescriptorClasses()[i];\n\t\t\t\tfinal DomainModelDescriptor domainModelDescriptor = instantiateDomainModelDescriptor(\n\t\t\t\t\t\tmodelDescriptorClass );\n\t\t\t\tfor ( int i1 = 0; i1 < domainModelDescriptor.getAnnotatedClasses().length; i1++ ) {\n\t\t\t\t\tfinal Class<?> annotatedClass = domainModelDescriptor.getAnnotatedClasses()[i1];\n\t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfinal Map<String, Object> integrationSettings = new HashMap<>();\n\n\t\tintegrationSettings.put( PersistentTableStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( GlobalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( LocalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tfor ( int i = 0; i < emfAnn.integrationSettings().length; i++ ) {\n\t\t\tfinal Setting setting = emfAnn.integrationSettings()[i];\n\t\t\tintegrationSettings.put( setting.name(), setting.value() );\n\t\t}\n\n\t\tfor ( SettingProvider providerAnn : emfAnn.settingProviders() ) {\n\t\t\tfinal Class<? extends SettingProvider.Provider<?>> providerImpl = providerAnn.provider();\n\t\t\ttry {\n\t\t\t\tfinal SettingProvider.Provider<?> provider = providerImpl.getConstructor().newInstance();\n\t\t\t\tintegrationSettings.put( providerAnn.settingName(), provider.getSetting() );\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tlog.error( \"Error obtaining setting provider for \" + providerImpl.getName(), e );\n\t\t\t}\n\t\t}\n\n\t\t// statement inspector\n\t\tif ( emfAnn.useCollectingStatementInspector() ) {\n\t\t\tString inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n\t\t\tif ( !(inspectorSetting == null || inspectorSetting.isBlank()) ) {\n\t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n\t\t\t}\n\t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n\t\t}\n\n\t\tServiceRegistryUtil.applySettings( integrationSettings );\n\t\tfinal EntityManagerFactoryScopeImpl scope = new EntityManagerFactoryScopeImpl( pui, integrationSettings );\n\n\t\tstore.put( EMF_KEY, scope );\n\n\t\treturn scope;\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.testing.orm.junit;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport jakarta.persistence.spi.PersistenceUnitInfo;\n\nimport org.hibernate.SessionFactoryObserver;\nimport org.hibernate.boot.registry.StandardServiceRegistry;\nimport org.hibernate.boot.spi.MetadataImplementor;\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.cfg.Environment;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.internal.util.ReflectHelper;\nimport org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor;\nimport org.hibernate.jpa.boot.spi.Bootstrap;\nimport org.hibernate.jpa.boot.spi.EntityManagerFactoryBuilder;\nimport org.hibernate.query.sqm.mutation.internal.temptable.GlobalTemporaryTableMutationStrategy;\nimport org.hibernate.query.sqm.mutation.internal.temptable.LocalTemporaryTableMutationStrategy;\nimport org.hibernate.query.sqm.mutation.internal.temptable.PersistentTableStrategy;\nimport org.hibernate.tool.schema.Action;\nimport org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator;\nimport org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator.ActionGrouping;\n\nimport org.hibernate.testing.jdbc.SQLStatementInspector;\nimport org.hibernate.testing.orm.domain.DomainModelDescriptor;\nimport org.hibernate.testing.orm.domain.StandardDomainModel;\nimport org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl;\nimport org.hibernate.testing.util.ServiceRegistryUtil;\nimport org.junit.jupiter.api.extension.BeforeEachCallback;\nimport org.junit.jupiter.api.extension.ExtensionContext;\nimport org.junit.jupiter.api.extension.TestExecutionExceptionHandler;\nimport org.junit.jupiter.api.extension.TestInstancePostProcessor;\nimport org.junit.platform.commons.support.AnnotationSupport;\n\nimport org.jboss.logging.Logger;\n\n/**\n * hibernate-testing implementation of a few JUnit5 contracts to support SessionFactory-based testing,\n * including argument injection (or see {@link SessionFactoryScopeAware})\n *\n * @author Steve Ebersole\n *\n * @see DomainModelExtension\n * @see SessionFactoryExtension\n */\npublic class EntityManagerFactoryExtension\n\t\timplements TestInstancePostProcessor, BeforeEachCallback, TestExecutionExceptionHandler {\n\n\tprivate static final Logger log = Logger.getLogger( EntityManagerFactoryExtension.class );\n\tprivate static final String EMF_KEY = EntityManagerFactoryScope.class.getName();\n\n\tprivate static ExtensionContext.Store locateExtensionStore(Object testScope, ExtensionContext context) {\n\t\treturn JUnitHelper.locateExtensionStore( EntityManagerFactoryExtension.class, context, testScope );\n\t}\n\n\tpublic static EntityManagerFactoryScope findEntityManagerFactoryScope(\n\t\t\tObject testScope,\n\t\t\tOptional<Jpa> emfAnnWrapper,\n\t\t\tExtensionContext context) {\n\n\t\tif ( emfAnnWrapper.isEmpty() ) {\n\t\t\t// No annotation on the test class, should be on the test methods\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n\t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n\t\tif ( existing != null ) {\n\t\t\treturn existing;\n\t\t}\n\n\t\tif ( !context.getElement().isPresent() ) {\n\t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \" + context.getDisplayName() );\n\t\t}\n\t\tfinal Jpa emfAnn = emfAnnWrapper.get();\n\n\t\tfinal PersistenceUnitInfoImpl pui = new PersistenceUnitInfoImpl( emfAnn.persistenceUnitName() );\n\t\t( (Map<Object, Object>) Environment.getProperties() ).forEach(\n\t\t\t\t(key, value) ->\n\t\t\t\t\t\tpui.getProperties().put( key, value )\n\t\t);\n\n\t\tpui.setTransactionType( emfAnn.transactionType() );\n\t\tpui.setCacheMode( emfAnn.sharedCacheMode() );\n\t\tpui.setValidationMode( emfAnn.validationMode() );\n\t\tpui.setExcludeUnlistedClasses( emfAnn.excludeUnlistedClasses() );\n\n\t\t// JpaCompliance\n\t\tpui.getProperties().put( AvailableSettings.JPA_COMPLIANCE, emfAnn.jpaComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_QUERY_COMPLIANCE, emfAnn.queryComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, emfAnn.transactionComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_CLOSED_COMPLIANCE, emfAnn.closedComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_PROXY_COMPLIANCE, emfAnn.proxyComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_CACHING_COMPLIANCE, emfAnn.cacheComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, emfAnn.generatorScopeComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, emfAnn.orderByMappingComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, emfAnn.loadByIdComplianceEnabled() );\n\n\t\tfinal Setting[] properties = emfAnn.properties();\n\t\tfor ( int i = 0; i < properties.length; i++ ) {\n\t\t\tfinal Setting property = properties[i];\n\t\t\tpui.getProperties().setProperty( property.name(), property.value() );\n\t\t}\n\n\t\tpui.getProperties().setProperty(\n\t\t\t\tAvailableSettings.GENERATE_STATISTICS,\n\t\t\t\tBoolean.toString( emfAnn.generateStatistics() )\n\t\t);\n\n\t\tif ( emfAnn.exportSchema() ) {\n\t\t\tpui.getProperties().setProperty(\n\t\t\t\t\tAvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,\n\t\t\t\t\tAction.CREATE_DROP.getExternalHbm2ddlName()\n\t\t\t);\n\t\t}\n\n\t\tif ( emfAnn.annotatedPackageNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( emfAnn.annotatedPackageNames() );\n\t\t}\n\n\t\tif ( emfAnn.annotatedClassNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClassNames() );\n\t\t}\n\n\t\tif ( emfAnn.annotatedClasses().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.annotatedClasses().length; i++ ) {\n\t\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClasses()[i].getName() );\n\t\t\t}\n\t\t}\n\n\t\tif ( emfAnn.xmlMappings().length > 0 ) {\n\t\t\tpui.applyMappingFiles( emfAnn.xmlMappings() );\n\t\t}\n\n\t\tif ( emfAnn.standardModels().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.standardModels().length; i++ ) {\n\t\t\t\tfinal StandardDomainModel standardDomainModel = emfAnn.standardModels()[i];\n\t\t\t\tfor ( int i1 = 0; i1 < standardDomainModel.getDescriptor().getAnnotatedClasses().length; i1++ ) {\n\t\t\t\t\tfinal Class<?> annotatedClass = standardDomainModel.getDescriptor().getAnnotatedClasses()[i1];\n\t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( emfAnn.modelDescriptorClasses().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.modelDescriptorClasses().length; i++ ) {\n\t\t\t\tfinal Class<? extends DomainModelDescriptor> modelDescriptorClass = emfAnn.modelDescriptorClasses()[i];\n\t\t\t\tfinal DomainModelDescriptor domainModelDescriptor = instantiateDomainModelDescriptor(\n\t\t\t\t\t\tmodelDescriptorClass );\n\t\t\t\tfor ( int i1 = 0; i1 < domainModelDescriptor.getAnnotatedClasses().length; i1++ ) {\n\t\t\t\t\tfinal Class<?> annotatedClass = domainModelDescriptor.getAnnotatedClasses()[i1];\n\t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfinal Map<String, Object> integrationSettings = new HashMap<>();\n\n\t\tintegrationSettings.put( PersistentTableStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( GlobalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( LocalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tfor ( int i = 0; i < emfAnn.integrationSettings().length; i++ ) {\n\t\t\tfinal Setting setting = emfAnn.integrationSettings()[i];\n\t\t\tintegrationSettings.put( setting.name(), setting.value() );\n\t\t}\n\n\t\tfor ( SettingProvider providerAnn : emfAnn.settingProviders() ) {\n\t\t\tfinal Class<? extends SettingProvider.Provider<?>> providerImpl = providerAnn.provider();\n\t\t\ttry {\n\t\t\t\tfinal SettingProvider.Provider<?> provider = providerImpl.getConstructor().newInstance();\n\t\t\t\tintegrationSettings.put( providerAnn.settingName(), provider.getSetting() );\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tlog.error( \"Error obtaining setting provider for \" + providerImpl.getName(), e );\n\t\t\t}\n\t\t}\n\n\t\t// statement inspector\n\t\tif ( emfAnn.useCollectingStatementInspector() ) {\n\t\t\tString inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n\t\t\tif ( !(inspectorSetting == null || inspectorSetting.isBlank()) ) {\n\t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n\t\t\t}\n\t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n\t\t}\n\n\t\tServiceRegistryUtil.applySettings( integrationSettings );\n\t\tfinal EntityManagerFactoryScopeImpl scope = new EntityManagerFactoryScopeImpl( pui, integrationSettings );\n\n\t\tstore.put( EMF_KEY, scope );\n\n\t\treturn scope;\n\t}\n\n\tprivate static DomainModelDescriptor instantiateDomainModelDescriptor(Class<? extends DomainModelDescriptor> modelDescriptorClass) {\n\t\t// first, see if it has a static singleton reference and use that if so\n\t\ttry {\n\t\t\tfinal Field[] declaredFields = modelDescriptorClass.getDeclaredFields();\n\t\t\tfor ( int i = 0; i < declaredFields.length; i++ ) {\n\t\t\t\tfinal Field field = declaredFields[i];\n\t\t\t\tif ( ReflectHelper.isStaticField( field ) ) {\n\t\t\t\t\tfinal Object value = field.get( null );\n\t\t\t\t\tif ( value instanceof DomainModelDescriptor ) {\n\t\t\t\t\t\treturn (DomainModelDescriptor) value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalAccessException e) {\n\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\"Problem accessing DomainModelDescriptor fields : \" + modelDescriptorClass.getName(),\n\t\t\t\t\te\n\t\t\t);\n\t\t}\n\n\t\t// no singleton field, try to instantiate it via reflection\n\t\ttry {\n\t\t\treturn modelDescriptorClass.getConstructor( null ).newInstance( null );\n\t\t}\n\t\tcatch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {\n\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\"Problem instantiation DomainModelDescriptor : \" + modelDescriptorClass.getName(),\n\t\t\t\t\te\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate static void prepareSchemaExport(\n\t\t\tSessionFactoryImplementor sessionFactory,\n\t\t\tMetadataImplementor model) {\n\t\tfinal Map<String, Object> baseProperties = sessionFactory.getProperties();\n\n\t\tfinal Set<ActionGrouping> groupings = ActionGrouping.interpret( model, baseProperties );\n\t\tif ( !groupings.isEmpty() ) {\n\t\t\t// the properties contained explicit settings for auto schema tooling - skip the annotation\n\t\t\treturn;\n\t\t}\n\n\t\tfinal HashMap<String,Object> settings = new HashMap<>( baseProperties );\n\t\tsettings.put( AvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION, Action.CREATE_DROP );\n\n\t\tfinal StandardServiceRegistry serviceRegistry = model.getMetadataBuildingOptions().getServiceRegistry();\n\n\n\t\tSchemaManagementToolCoordinator.process(\n\t\t\t\tmodel,\n\t\t\t\tserviceRegistry,\n\t\t\t\tsettings,\n\t\t\t\taction -> sessionFactory.addObserver(\n\t\t\t\t\t\tnew SessionFactoryObserver() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void sessionFactoryClosing(org.hibernate.SessionFactory factory) {\n\t\t\t\t\t\t\t\taction.perform( serviceRegistry );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t)\n\t\t);\n\t}\n\n\t@Override\n\tpublic void beforeEach(ExtensionContext context) {\n\t\tlog.tracef( \"#beforeEach(%s)\", context.getDisplayName() );\n\t\tfinal Optional<Jpa> emfAnnWrapper = AnnotationSupport.findAnnotation(\n\t\t\t\tcontext.getRequiredTestMethod(),\n\t\t\t\tJpa.class\n\t\t);\n\n\t\tif ( emfAnnWrapper.isEmpty() ) {\n\t\t\t// assume the annotation is defined on the class-level...\n\t\t\treturn;\n\t\t}\n\n\t\tfindEntityManagerFactoryScope( context.getRequiredTestMethod(), emfAnnWrapper, context );\n\t}\n\n\t@Override\n\tpublic void postProcessTestInstance(Object testInstance, ExtensionContext context) {\n\t\tlog.tracef( \"#postProcessTestInstance(%s, %s)\", testInstance, context.getDisplayName() );\n\n\t\tfinal Optional<Jpa> emfAnnWrapper = AnnotationSupport.findAnnotation(\n\t\t\t\tcontext.getRequiredTestClass(),\n\t\t\t\tJpa.class\n\t\t);\n\n\t\tfindEntityManagerFactoryScope( testInstance, emfAnnWrapper, context );\n\t}\n\n\t@Override\n\tpublic void handleTestExecutionException(ExtensionContext context, Throwable throwable) throws Throwable {\n\t\tlog.tracef( \"#handleTestExecutionException(%s, %s)\", context.getDisplayName(), throwable );\n\n\t\ttry {\n\t\t\tfinal Object testInstance = context.getRequiredTestInstance();\n\t\t\tfinal ExtensionContext.Store store = locateExtensionStore( testInstance, context );\n\t\t\tfinal EntityManagerFactoryScopeImpl scope = (EntityManagerFactoryScopeImpl) store.get( EMF_KEY );\n\t\t\tscope.releaseEntityManagerFactory();\n\t\t}\n\t\tcatch (Exception ignore) {\n\t\t}\n\n\t\tthrow throwable;\n\t}\n\n\tprivate static class EntityManagerFactoryScopeImpl extends AbstractEntityManagerFactoryScope {\n\t\tprivate final PersistenceUnitInfo persistenceUnitInfo;\n\t\tprivate final Map<String, Object> integrationSettings;\n\n\t\tprivate EntityManagerFactoryScopeImpl(\n\t\t\t\tPersistenceUnitInfo persistenceUnitInfo,\n\t\t\t\tMap<String, Object> integrationSettings) {\n\t\t\tthis.persistenceUnitInfo = persistenceUnitInfo;\n\t\t\tthis.integrationSettings = integrationSettings;\n\t\t}\n\n\t\tprotected jakarta.persistence.EntityManagerFactory createEntityManagerFactory() {\n\t\t\tfinal EntityManagerFactoryBuilder emfBuilder = Bootstrap.getEntityManagerFactoryBuilder(\n\t\t\t\t\tnew PersistenceUnitInfoDescriptor( persistenceUnitInfo ),\n\t\t\t\t\tintegrationSettings\n\t\t\t);\n\n\t\t\treturn emfBuilder.build();\n\t\t}\n\t}\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate setJpaComplianceProperties(properties Properties, jpa Jpa) : void extracted from public findEntityManagerFactoryScope(testScope Object, emfAnnWrapper Optional<Jpa>, context ExtensionContext) : EntityManagerFactoryScope in class org.hibernate.testing.orm.junit.EntityManagerFactoryExtension",
        "diffLocations": [
            {
                "filePath": "hibernate-testing/src/main/java/org/hibernate/testing/orm/junit/EntityManagerFactoryExtension.java",
                "startLine": 66,
                "endLine": 203,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-testing/src/main/java/org/hibernate/testing/orm/junit/EntityManagerFactoryExtension.java",
                "startLine": 93,
                "endLine": 111,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-testing/src/main/java/org/hibernate/testing/orm/junit/EntityManagerFactoryExtension.java",
                "startLine": 191,
                "endLine": 201,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "public static EntityManagerFactoryScope findEntityManagerFactoryScope(\n\t\t\tObject testScope,\n\t\t\tOptional<Jpa> emfAnnWrapper,\n\t\t\tExtensionContext context) {\n\n\t\tif ( emfAnnWrapper.isEmpty() ) {\n\t\t\t// No annotation on the test class, should be on the test methods\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n\t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n\t\tif ( existing != null ) {\n\t\t\treturn existing;\n\t\t}\n\n\t\tif ( !context.getElement().isPresent() ) {\n\t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \" + context.getDisplayName() );\n\t\t}\n\t\tfinal Jpa emfAnn = emfAnnWrapper.get();\n\n\t\tfinal PersistenceUnitInfoImpl pui = new PersistenceUnitInfoImpl( emfAnn.persistenceUnitName() );\n\t\t( (Map<Object, Object>) Environment.getProperties() ).forEach(\n\t\t\t\t(key, value) ->\n\t\t\t\t\t\tpui.getProperties().put( key, value )\n\t\t);\n\n\t\tpui.setTransactionType( emfAnn.transactionType() );\n\t\tpui.setCacheMode( emfAnn.sharedCacheMode() );\n\t\tpui.setValidationMode( emfAnn.validationMode() );\n\t\tpui.setExcludeUnlistedClasses( emfAnn.excludeUnlistedClasses() );\n\n\t\t// JpaCompliance\n\t\tpui.getProperties().put( AvailableSettings.JPA_COMPLIANCE, emfAnn.jpaComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_QUERY_COMPLIANCE, emfAnn.queryComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, emfAnn.transactionComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_CLOSED_COMPLIANCE, emfAnn.closedComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_PROXY_COMPLIANCE, emfAnn.proxyComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_CACHING_COMPLIANCE, emfAnn.cacheComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, emfAnn.generatorScopeComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, emfAnn.orderByMappingComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, emfAnn.loadByIdComplianceEnabled() );\n\n\t\tfinal Setting[] properties = emfAnn.properties();\n\t\tfor ( int i = 0; i < properties.length; i++ ) {\n\t\t\tfinal Setting property = properties[i];\n\t\t\tpui.getProperties().setProperty( property.name(), property.value() );\n\t\t}\n\n\t\tpui.getProperties().setProperty(\n\t\t\t\tAvailableSettings.GENERATE_STATISTICS,\n\t\t\t\tBoolean.toString( emfAnn.generateStatistics() )\n\t\t);\n\n\t\tif ( emfAnn.exportSchema() ) {\n\t\t\tpui.getProperties().setProperty(\n\t\t\t\t\tAvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,\n\t\t\t\t\tAction.CREATE_DROP.getExternalHbm2ddlName()\n\t\t\t);\n\t\t}\n\n\t\tif ( emfAnn.annotatedPackageNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( emfAnn.annotatedPackageNames() );\n\t\t}\n\n\t\tif ( emfAnn.annotatedClassNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClassNames() );\n\t\t}\n\n\t\tif ( emfAnn.annotatedClasses().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.annotatedClasses().length; i++ ) {\n\t\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClasses()[i].getName() );\n\t\t\t}\n\t\t}\n\n\t\tif ( emfAnn.xmlMappings().length > 0 ) {\n\t\t\tpui.applyMappingFiles( emfAnn.xmlMappings() );\n\t\t}\n\n\t\tif ( emfAnn.standardModels().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.standardModels().length; i++ ) {\n\t\t\t\tfinal StandardDomainModel standardDomainModel = emfAnn.standardModels()[i];\n\t\t\t\tfor ( int i1 = 0; i1 < standardDomainModel.getDescriptor().getAnnotatedClasses().length; i1++ ) {\n\t\t\t\t\tfinal Class<?> annotatedClass = standardDomainModel.getDescriptor().getAnnotatedClasses()[i1];\n\t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( emfAnn.modelDescriptorClasses().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.modelDescriptorClasses().length; i++ ) {\n\t\t\t\tfinal Class<? extends DomainModelDescriptor> modelDescriptorClass = emfAnn.modelDescriptorClasses()[i];\n\t\t\t\tfinal DomainModelDescriptor domainModelDescriptor = instantiateDomainModelDescriptor(\n\t\t\t\t\t\tmodelDescriptorClass );\n\t\t\t\tfor ( int i1 = 0; i1 < domainModelDescriptor.getAnnotatedClasses().length; i1++ ) {\n\t\t\t\t\tfinal Class<?> annotatedClass = domainModelDescriptor.getAnnotatedClasses()[i1];\n\t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfinal Map<String, Object> integrationSettings = new HashMap<>();\n\n\t\tintegrationSettings.put( PersistentTableStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( GlobalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( LocalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tfor ( int i = 0; i < emfAnn.integrationSettings().length; i++ ) {\n\t\t\tfinal Setting setting = emfAnn.integrationSettings()[i];\n\t\t\tintegrationSettings.put( setting.name(), setting.value() );\n\t\t}\n\n\t\tfor ( SettingProvider providerAnn : emfAnn.settingProviders() ) {\n\t\t\tfinal Class<? extends SettingProvider.Provider<?>> providerImpl = providerAnn.provider();\n\t\t\ttry {\n\t\t\t\tfinal SettingProvider.Provider<?> provider = providerImpl.getConstructor().newInstance();\n\t\t\t\tintegrationSettings.put( providerAnn.settingName(), provider.getSetting() );\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tlog.error( \"Error obtaining setting provider for \" + providerImpl.getName(), e );\n\t\t\t}\n\t\t}\n\n\t\t// statement inspector\n\t\tif ( emfAnn.useCollectingStatementInspector() ) {\n\t\t\tString inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n\t\t\tif ( !(inspectorSetting == null || inspectorSetting.isBlank()) ) {\n\t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n\t\t\t}\n\t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n\t\t}\n\n\t\tServiceRegistryUtil.applySettings( integrationSettings );\n\t\tfinal EntityManagerFactoryScopeImpl scope = new EntityManagerFactoryScopeImpl( pui, integrationSettings );\n\n\t\tstore.put( EMF_KEY, scope );\n\n\t\treturn scope;\n\t}",
        "filePathBefore": "hibernate-testing/src/main/java/org/hibernate/testing/orm/junit/EntityManagerFactoryExtension.java",
        "isPureRefactoring": true,
        "commitId": "4781c09d0df0eb4ce05b2fa0d2a12747023ae024",
        "packageNameBefore": "org.hibernate.testing.orm.junit",
        "classNameBefore": "org.hibernate.testing.orm.junit.EntityManagerFactoryExtension",
        "methodNameBefore": "org.hibernate.testing.orm.junit.EntityManagerFactoryExtension#findEntityManagerFactoryScope",
        "invokedMethod": "methodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#setValidationMode\n methodBody: public void setValidationMode(String validationMode) {\nsetValidationMode(ValidationMode.valueOf(validationMode));\n}\nmethodSignature: org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}\nmethodSignature: org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor#getName\n methodBody: public String getName() {\nreturn persistenceUnitInfo.getPersistenceUnitName();\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setTransactionType\n methodBody: public void setTransactionType(PersistenceUnitTransactionType transactionType) {\nthis.transactionType=transactionType;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest#applySettings\n methodBody: protected void applySettings(Map<Object, Object> settings) {\nString[] mappings=getMappings();\nif(mappings != null){settings.put(AvailableSettings.HBM_XML_FILES,String.join(\",\",mappings));\n}}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setValidationMode\n methodBody: public void setValidationMode(ValidationMode validationMode) {\nthis.validationMode=validationMode;\n}\nmethodSignature: org.hibernate.collection.spi.AbstractPersistentCollection.SetProxy#isEmpty\n methodBody: public boolean isEmpty() {\nreturn set.isEmpty();\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#applyMappingFiles\n methodBody: public void applyMappingFiles(String... mappingFiles) {\nif(this.mappingFiles == null){this.mappingFiles=new ArrayList<>();\n}Collections.addAll(this.mappingFiles,mappingFiles);\n}\nmethodSignature: org.hibernate.testing.util.jpa.DelegatingPersistenceUnitInfo#getProperties\n methodBody: public Properties getProperties() {\nreturn delegate.getProperties();\n}\nmethodSignature: org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentList#get\n methodBody: public E get(int index) {\nif(index < 0){throw new ArrayIndexOutOfBoundsException(\"negative index\");\n}final Object result=readElementByIndex(index);\nreturn result == UNKNOWN ? list.get(index) : (E)result;\n}\nmethodSignature: org.hibernate.orm.test.bootstrap.BootstrapTest.PersistenceUnitInfoImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest.TestingPersistenceUnitDescriptorImpl#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.jpa.boot.spi.PersistenceConfigurationDescriptor#getName\n methodBody: public String getName() {\nreturn persistenceConfiguration.name();\n}\nmethodSignature: org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor#getProperties\n methodBody: public Properties getProperties() {\nreturn persistenceUnitInfo.getProperties();\n}\nmethodSignature: org.hibernate.jpa.boot.spi.PersistenceUnitDescriptor#getProperties\n methodBody: Properties getProperties();\nmethodSignature: org.hibernate.testing.orm.junit.BaseSessionFactoryFunctionalTest#getAnnotatedClasses\n methodBody: protected Class[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}\nmethodSignature: org.hibernate.testing.orm.junit.BaseSessionFactoryFunctionalTest#applySettings\n methodBody: protected void applySettings(StandardServiceRegistryBuilder builder) {\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoAdapter#getProperties\n methodBody: public Properties getProperties() {\nif(properties == null){properties=new Properties();\n}return properties;\n}\nmethodSignature: org.hibernate.testing.util.jpa.DelegatingPersistenceUnitInfo#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn delegate.excludeUnlistedClasses();\n}\nmethodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoAdapter#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setCacheMode\n methodBody: public void setCacheMode(SharedCacheMode cacheMode) {\nthis.cacheMode=cacheMode;\n}\nmethodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.orm.test.jpa.BaseEntityManagerFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn excludeUnlistedClasses;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}\nmethodSignature: org.hibernate.collection.spi.AbstractPersistentCollection.ListProxy#get\n methodBody: public E get(int i) {\nreturn list.get(i);\n}\nmethodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoAdapter#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}\nmethodSignature: org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}\nmethodSignature: org.hibernate.orm.test.bootstrap.BootstrapTest.PersistenceUnitInfoImpl#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}\nmethodSignature: org.hibernate.jpa.boot.spi.PersistenceConfigurationDescriptor#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitDescriptorAdapter#getProperties\n methodBody: public Properties getProperties() {\nif(properties == null){properties=new Properties();\n}return properties;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentBag#get\n methodBody: public E get(int i) {\nread();\nreturn bag.get(i);\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoAdapter#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setExcludeUnlistedClasses\n methodBody: public void setExcludeUnlistedClasses(boolean excludeUnlistedClasses) {\nthis.excludeUnlistedClasses=excludeUnlistedClasses;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentList#toString\n methodBody: public String toString() {\nread();\nreturn list.toString();\n}\nmethodSignature: org.hibernate.testing.junit4.BaseCoreFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentBag#getElement\n methodBody: public Object getElement(Object entry) {\nreturn entry;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentBag#isEmpty\n methodBody: public boolean isEmpty() {\nreturn readSize() ? getCachedSize() == 0 : bag.isEmpty();\n}\nmethodSignature: org.hibernate.orm.test.jpa.xml.versions.JpaXsdVersionsTest.PersistenceUnitInfoImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}\nmethodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#setTransactionType\n methodBody: public void setTransactionType(PersistenceUnitTransactionType transactionType) {\nthis.transactionType=transactionType;\n}\nmethodSignature: org.hibernate.orm.test.jpa.EntityManagerTest#getAnnotatedClasses\n methodBody: public Class[] getAnnotatedClasses() {\nreturn new Class[]{Item.class,Distributor.class,Wallet.class};\n}\nmethodSignature: org.hibernate.orm.test.jpa.BaseEntityManagerFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest#exportSchema\n methodBody: protected boolean exportSchema() {\nreturn true;\n}\nmethodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}\nmethodSignature: org.hibernate.internal.SessionFactoryImpl#getProperties\n methodBody: public Map<String, Object> getProperties() {\nvalidateNotClosed();\nreturn settings;\n}\nmethodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoPropertiesWrapper#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}\nmethodSignature: org.hibernate.orm.test.jpa.xml.versions.JpaXsdVersionsTest.PersistenceUnitInfoImpl#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}\nmethodSignature: org.hibernate.jpa.boot.spi.PersistenceUnitDescriptor#getName\n methodBody: String getName();\nmethodSignature: org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn null;\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitDescriptorAdapter#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryExtension#locateExtensionStore\n methodBody: private static ExtensionContext.Store locateExtensionStore(Object testScope, ExtensionContext context) {\nreturn JUnitHelper.locateExtensionStore(EntityManagerFactoryExtension.class,context,testScope);\n}\nmethodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#setExcludeUnlistedClasses\n methodBody: public void setExcludeUnlistedClasses(boolean excludeUnlistedClasses) {\nthis.excludeUnlistedClasses=excludeUnlistedClasses;\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#applyManagedClassNames\n methodBody: public void applyManagedClassNames(String... managedClassNames) {\nif(this.managedClassNames == null){this.managedClassNames=new ArrayList<>();\n}Collections.addAll(this.managedClassNames,managedClassNames);\n}\nmethodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoPropertiesWrapper#getProperties\n methodBody: public Properties getProperties() {\nif(properties == null){properties=new Properties();\n}return properties;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentList#getElement\n methodBody: public Object getElement(Object entry) {\nreturn entry;\n}\nmethodSignature: org.hibernate.orm.test.jpa.BaseEntityManagerFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn null;\n}\nmethodSignature: org.hibernate.internal.SessionFactoryImpl#getName\n methodBody: public String getName() {\nreturn name;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest.TestingPersistenceUnitDescriptorImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn null;\n}\nmethodSignature: org.hibernate.collection.spi.PersistentList#isEmpty\n methodBody: public boolean isEmpty() {\nreturn readSize() ? getCachedSize() == 0 : list.isEmpty();\n}\nmethodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}\nmethodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryExtension#instantiateDomainModelDescriptor\n methodBody: private static DomainModelDescriptor instantiateDomainModelDescriptor(Class<? extends DomainModelDescriptor> modelDescriptorClass) {\ntryfinal Field[] declaredFields=modelDescriptorClass.getDeclaredFields();\nfor(int i=0; i < declaredFields.length; i++){final Field field=declaredFields[i];\nif(ReflectHelper.isStaticField(field)){final Object value=field.get(null);\nif(value instanceof DomainModelDescriptor){return (DomainModelDescriptor)value;\n}}}catch(IllegalAccessException e)throw new RuntimeException(\"Problem accessing DomainModelDescriptor fields : \" + modelDescriptorClass.getName(),e);\ntryreturn modelDescriptorClass.getConstructor(null).newInstance(null);\ncatch(InstantiationException|IllegalAccessException|InvocationTargetException|NoSuchMethodException e)throw new RuntimeException(\"Problem instantiation DomainModelDescriptor : \" + modelDescriptorClass.getName(),e);\n}\nmethodSignature: org.hibernate.testing.orm.junit.BaseSessionFactoryFunctionalTest#exportSchema\n methodBody: protected boolean exportSchema() {\nreturn true;\n}\nmethodSignature: org.hibernate.collection.spi.AbstractPersistentCollection.ListProxy#isEmpty\n methodBody: public boolean isEmpty() {\nreturn list.isEmpty();\n}\nmethodSignature: org.hibernate.collection.spi.PersistentBag#toString\n methodBody: public String toString() {\nread();\nreturn bag.toString();\n}",
        "classSignatureBefore": "public class EntityManagerFactoryExtension\n\t\timplements TestInstancePostProcessor, BeforeEachCallback, TestExecutionExceptionHandler ",
        "methodNameBeforeSet": [
            "org.hibernate.testing.orm.junit.EntityManagerFactoryExtension#findEntityManagerFactoryScope"
        ],
        "classNameBeforeSet": [
            "org.hibernate.testing.orm.junit.EntityManagerFactoryExtension"
        ],
        "classSignatureBeforeSet": [
            "public class EntityManagerFactoryExtension\n\t\timplements TestInstancePostProcessor, BeforeEachCallback, TestExecutionExceptionHandler "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics\nOverlapped refactoring - can be identical by undoing the overlapped refactoring\n- Rename Variable-",
                "description": "Rename Variable on top of the extract method - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.testing.orm.junit;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport jakarta.persistence.spi.PersistenceUnitInfo;\n\nimport org.hibernate.SessionFactoryObserver;\nimport org.hibernate.boot.registry.StandardServiceRegistry;\nimport org.hibernate.boot.spi.MetadataImplementor;\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.cfg.Environment;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.internal.util.ReflectHelper;\nimport org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor;\nimport org.hibernate.jpa.boot.spi.Bootstrap;\nimport org.hibernate.jpa.boot.spi.EntityManagerFactoryBuilder;\nimport org.hibernate.query.sqm.mutation.internal.temptable.GlobalTemporaryTableMutationStrategy;\nimport org.hibernate.query.sqm.mutation.internal.temptable.LocalTemporaryTableMutationStrategy;\nimport org.hibernate.query.sqm.mutation.internal.temptable.PersistentTableStrategy;\nimport org.hibernate.tool.schema.Action;\nimport org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator;\nimport org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator.ActionGrouping;\n\nimport org.hibernate.testing.jdbc.SQLStatementInspector;\nimport org.hibernate.testing.orm.domain.DomainModelDescriptor;\nimport org.hibernate.testing.orm.domain.StandardDomainModel;\nimport org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl;\nimport org.hibernate.testing.util.ServiceRegistryUtil;\nimport org.junit.jupiter.api.extension.BeforeEachCallback;\nimport org.junit.jupiter.api.extension.ExtensionContext;\nimport org.junit.jupiter.api.extension.TestExecutionExceptionHandler;\nimport org.junit.jupiter.api.extension.TestInstancePostProcessor;\nimport org.junit.platform.commons.support.AnnotationSupport;\n\nimport org.jboss.logging.Logger;\n\n/**\n * hibernate-testing implementation of a few JUnit5 contracts to support SessionFactory-based testing,\n * including argument injection (or see {@link SessionFactoryScopeAware})\n *\n * @author Steve Ebersole\n *\n * @see DomainModelExtension\n * @see SessionFactoryExtension\n */\npublic class EntityManagerFactoryExtension\n\t\timplements TestInstancePostProcessor, BeforeEachCallback, TestExecutionExceptionHandler {\n\n\tprivate static final Logger log = Logger.getLogger( EntityManagerFactoryExtension.class );\n\tprivate static final String EMF_KEY = EntityManagerFactoryScope.class.getName();\n\n\tprivate static ExtensionContext.Store locateExtensionStore(Object testScope, ExtensionContext context) {\n\t\treturn JUnitHelper.locateExtensionStore( EntityManagerFactoryExtension.class, context, testScope );\n\t}\n\n\tpublic static EntityManagerFactoryScope findEntityManagerFactoryScope(\n\t\t\tObject testScope,\n\t\t\tOptional<Jpa> emfAnnWrapper,\n\t\t\tExtensionContext context) {\n\n\t\tif ( emfAnnWrapper.isEmpty() ) {\n\t\t\t// No annotation on the test class, should be on the test methods\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n\t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n\t\tif ( existing != null ) {\n\t\t\treturn existing;\n\t\t}\n\n\t\tif ( !context.getElement().isPresent() ) {\n\t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \" + context.getDisplayName() );\n\t\t}\n\t\tfinal Jpa emfAnn = emfAnnWrapper.get();\n\n\t\tfinal PersistenceUnitInfoImpl pui = new PersistenceUnitInfoImpl( emfAnn.persistenceUnitName() );\n\t\t( (Map<Object, Object>) Environment.getProperties() ).forEach(\n\t\t\t\t(key, value) ->\n\t\t\t\t\t\tpui.getProperties().put( key, value )\n\t\t);\n\n\t\tpui.setTransactionType( emfAnn.transactionType() );\n\t\tpui.setCacheMode( emfAnn.sharedCacheMode() );\n\t\tpui.setValidationMode( emfAnn.validationMode() );\n\t\tpui.setExcludeUnlistedClasses( emfAnn.excludeUnlistedClasses() );\n\n\t\t// JpaCompliance\n\t\tpui.getProperties().put( AvailableSettings.JPA_COMPLIANCE, emfAnn.jpaComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_QUERY_COMPLIANCE, emfAnn.queryComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, emfAnn.transactionComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_CLOSED_COMPLIANCE, emfAnn.closedComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_PROXY_COMPLIANCE, emfAnn.proxyComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_CACHING_COMPLIANCE, emfAnn.cacheComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, emfAnn.generatorScopeComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, emfAnn.orderByMappingComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, emfAnn.loadByIdComplianceEnabled() );\n\n\t\tfinal Setting[] properties = emfAnn.properties();\n\t\tfor ( int i = 0; i < properties.length; i++ ) {\n\t\t\tfinal Setting property = properties[i];\n\t\t\tpui.getProperties().setProperty( property.name(), property.value() );\n\t\t}\n\n\t\tpui.getProperties().setProperty(\n\t\t\t\tAvailableSettings.GENERATE_STATISTICS,\n\t\t\t\tBoolean.toString( emfAnn.generateStatistics() )\n\t\t);\n\n\t\tif ( emfAnn.exportSchema() ) {\n\t\t\tpui.getProperties().setProperty(\n\t\t\t\t\tAvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,\n\t\t\t\t\tAction.CREATE_DROP.getExternalHbm2ddlName()\n\t\t\t);\n\t\t}\n\n\t\tif ( emfAnn.annotatedPackageNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( emfAnn.annotatedPackageNames() );\n\t\t}\n\n\t\tif ( emfAnn.annotatedClassNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClassNames() );\n\t\t}\n\n\t\tif ( emfAnn.annotatedClasses().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.annotatedClasses().length; i++ ) {\n\t\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClasses()[i].getName() );\n\t\t\t}\n\t\t}\n\n\t\tif ( emfAnn.xmlMappings().length > 0 ) {\n\t\t\tpui.applyMappingFiles( emfAnn.xmlMappings() );\n\t\t}\n\n\t\tif ( emfAnn.standardModels().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.standardModels().length; i++ ) {\n\t\t\t\tfinal StandardDomainModel standardDomainModel = emfAnn.standardModels()[i];\n\t\t\t\tfor ( int i1 = 0; i1 < standardDomainModel.getDescriptor().getAnnotatedClasses().length; i1++ ) {\n\t\t\t\t\tfinal Class<?> annotatedClass = standardDomainModel.getDescriptor().getAnnotatedClasses()[i1];\n\t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( emfAnn.modelDescriptorClasses().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.modelDescriptorClasses().length; i++ ) {\n\t\t\t\tfinal Class<? extends DomainModelDescriptor> modelDescriptorClass = emfAnn.modelDescriptorClasses()[i];\n\t\t\t\tfinal DomainModelDescriptor domainModelDescriptor = instantiateDomainModelDescriptor(\n\t\t\t\t\t\tmodelDescriptorClass );\n\t\t\t\tfor ( int i1 = 0; i1 < domainModelDescriptor.getAnnotatedClasses().length; i1++ ) {\n\t\t\t\t\tfinal Class<?> annotatedClass = domainModelDescriptor.getAnnotatedClasses()[i1];\n\t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfinal Map<String, Object> integrationSettings = new HashMap<>();\n\n\t\tintegrationSettings.put( PersistentTableStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( GlobalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( LocalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tfor ( int i = 0; i < emfAnn.integrationSettings().length; i++ ) {\n\t\t\tfinal Setting setting = emfAnn.integrationSettings()[i];\n\t\t\tintegrationSettings.put( setting.name(), setting.value() );\n\t\t}\n\n\t\tfor ( SettingProvider providerAnn : emfAnn.settingProviders() ) {\n\t\t\tfinal Class<? extends SettingProvider.Provider<?>> providerImpl = providerAnn.provider();\n\t\t\ttry {\n\t\t\t\tfinal SettingProvider.Provider<?> provider = providerImpl.getConstructor().newInstance();\n\t\t\t\tintegrationSettings.put( providerAnn.settingName(), provider.getSetting() );\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tlog.error( \"Error obtaining setting provider for \" + providerImpl.getName(), e );\n\t\t\t}\n\t\t}\n\n\t\t// statement inspector\n\t\tif ( emfAnn.useCollectingStatementInspector() ) {\n\t\t\tString inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n\t\t\tif ( !(inspectorSetting == null || inspectorSetting.isBlank()) ) {\n\t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n\t\t\t}\n\t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n\t\t}\n\n\t\tServiceRegistryUtil.applySettings( integrationSettings );\n\t\tfinal EntityManagerFactoryScopeImpl scope = new EntityManagerFactoryScopeImpl( pui, integrationSettings );\n\n\t\tstore.put( EMF_KEY, scope );\n\n\t\treturn scope;\n\t}\n\n\tprivate static DomainModelDescriptor instantiateDomainModelDescriptor(Class<? extends DomainModelDescriptor> modelDescriptorClass) {\n\t\t// first, see if it has a static singleton reference and use that if so\n\t\ttry {\n\t\t\tfinal Field[] declaredFields = modelDescriptorClass.getDeclaredFields();\n\t\t\tfor ( int i = 0; i < declaredFields.length; i++ ) {\n\t\t\t\tfinal Field field = declaredFields[i];\n\t\t\t\tif ( ReflectHelper.isStaticField( field ) ) {\n\t\t\t\t\tfinal Object value = field.get( null );\n\t\t\t\t\tif ( value instanceof DomainModelDescriptor ) {\n\t\t\t\t\t\treturn (DomainModelDescriptor) value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalAccessException e) {\n\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\"Problem accessing DomainModelDescriptor fields : \" + modelDescriptorClass.getName(),\n\t\t\t\t\te\n\t\t\t);\n\t\t}\n\n\t\t// no singleton field, try to instantiate it via reflection\n\t\ttry {\n\t\t\treturn modelDescriptorClass.getConstructor( null ).newInstance( null );\n\t\t}\n\t\tcatch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {\n\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\"Problem instantiation DomainModelDescriptor : \" + modelDescriptorClass.getName(),\n\t\t\t\t\te\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate static void prepareSchemaExport(\n\t\t\tSessionFactoryImplementor sessionFactory,\n\t\t\tMetadataImplementor model) {\n\t\tfinal Map<String, Object> baseProperties = sessionFactory.getProperties();\n\n\t\tfinal Set<ActionGrouping> groupings = ActionGrouping.interpret( model, baseProperties );\n\t\tif ( !groupings.isEmpty() ) {\n\t\t\t// the properties contained explicit settings for auto schema tooling - skip the annotation\n\t\t\treturn;\n\t\t}\n\n\t\tfinal HashMap<String,Object> settings = new HashMap<>( baseProperties );\n\t\tsettings.put( AvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION, Action.CREATE_DROP );\n\n\t\tfinal StandardServiceRegistry serviceRegistry = model.getMetadataBuildingOptions().getServiceRegistry();\n\n\n\t\tSchemaManagementToolCoordinator.process(\n\t\t\t\tmodel,\n\t\t\t\tserviceRegistry,\n\t\t\t\tsettings,\n\t\t\t\taction -> sessionFactory.addObserver(\n\t\t\t\t\t\tnew SessionFactoryObserver() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void sessionFactoryClosing(org.hibernate.SessionFactory factory) {\n\t\t\t\t\t\t\t\taction.perform( serviceRegistry );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t)\n\t\t);\n\t}\n\n\t@Override\n\tpublic void beforeEach(ExtensionContext context) {\n\t\tlog.tracef( \"#beforeEach(%s)\", context.getDisplayName() );\n\t\tfinal Optional<Jpa> emfAnnWrapper = AnnotationSupport.findAnnotation(\n\t\t\t\tcontext.getRequiredTestMethod(),\n\t\t\t\tJpa.class\n\t\t);\n\n\t\tif ( emfAnnWrapper.isEmpty() ) {\n\t\t\t// assume the annotation is defined on the class-level...\n\t\t\treturn;\n\t\t}\n\n\t\tfindEntityManagerFactoryScope( context.getRequiredTestMethod(), emfAnnWrapper, context );\n\t}\n\n\t@Override\n\tpublic void postProcessTestInstance(Object testInstance, ExtensionContext context) {\n\t\tlog.tracef( \"#postProcessTestInstance(%s, %s)\", testInstance, context.getDisplayName() );\n\n\t\tfinal Optional<Jpa> emfAnnWrapper = AnnotationSupport.findAnnotation(\n\t\t\t\tcontext.getRequiredTestClass(),\n\t\t\t\tJpa.class\n\t\t);\n\n\t\tfindEntityManagerFactoryScope( testInstance, emfAnnWrapper, context );\n\t}\n\n\t@Override\n\tpublic void handleTestExecutionException(ExtensionContext context, Throwable throwable) throws Throwable {\n\t\tlog.tracef( \"#handleTestExecutionException(%s, %s)\", context.getDisplayName(), throwable );\n\n\t\ttry {\n\t\t\tfinal Object testInstance = context.getRequiredTestInstance();\n\t\t\tfinal ExtensionContext.Store store = locateExtensionStore( testInstance, context );\n\t\t\tfinal EntityManagerFactoryScopeImpl scope = (EntityManagerFactoryScopeImpl) store.get( EMF_KEY );\n\t\t\tscope.releaseEntityManagerFactory();\n\t\t}\n\t\tcatch (Exception ignore) {\n\t\t}\n\n\t\tthrow throwable;\n\t}\n\n\tprivate static class EntityManagerFactoryScopeImpl extends AbstractEntityManagerFactoryScope {\n\t\tprivate final PersistenceUnitInfo persistenceUnitInfo;\n\t\tprivate final Map<String, Object> integrationSettings;\n\n\t\tprivate EntityManagerFactoryScopeImpl(\n\t\t\t\tPersistenceUnitInfo persistenceUnitInfo,\n\t\t\t\tMap<String, Object> integrationSettings) {\n\t\t\tthis.persistenceUnitInfo = persistenceUnitInfo;\n\t\t\tthis.integrationSettings = integrationSettings;\n\t\t}\n\n\t\tprotected jakarta.persistence.EntityManagerFactory createEntityManagerFactory() {\n\t\t\tfinal EntityManagerFactoryBuilder emfBuilder = Bootstrap.getEntityManagerFactoryBuilder(\n\t\t\t\t\tnew PersistenceUnitInfoDescriptor( persistenceUnitInfo ),\n\t\t\t\t\tintegrationSettings\n\t\t\t);\n\n\t\t\treturn emfBuilder.build();\n\t\t}\n\t}\n}\n",
        "filePathAfter": "hibernate-testing/src/main/java/org/hibernate/testing/orm/junit/EntityManagerFactoryExtension.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.testing.orm.junit;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Properties;\n\nimport jakarta.persistence.spi.PersistenceUnitInfo;\n\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.cfg.Environment;\nimport org.hibernate.internal.util.ReflectHelper;\nimport org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor;\nimport org.hibernate.query.sqm.mutation.internal.temptable.GlobalTemporaryTableMutationStrategy;\nimport org.hibernate.query.sqm.mutation.internal.temptable.LocalTemporaryTableMutationStrategy;\nimport org.hibernate.query.sqm.mutation.internal.temptable.PersistentTableStrategy;\nimport org.hibernate.tool.schema.Action;\n\nimport org.hibernate.testing.jdbc.SQLStatementInspector;\nimport org.hibernate.testing.orm.domain.DomainModelDescriptor;\nimport org.hibernate.testing.orm.domain.StandardDomainModel;\nimport org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl;\nimport org.hibernate.testing.util.ServiceRegistryUtil;\nimport org.junit.jupiter.api.extension.BeforeEachCallback;\nimport org.junit.jupiter.api.extension.ExtensionContext;\nimport org.junit.jupiter.api.extension.TestExecutionExceptionHandler;\nimport org.junit.jupiter.api.extension.TestInstancePostProcessor;\n\nimport org.jboss.logging.Logger;\n\nimport static org.hibernate.jpa.boot.spi.Bootstrap.getEntityManagerFactoryBuilder;\nimport static org.junit.platform.commons.support.AnnotationSupport.findAnnotation;\n\n/**\n * hibernate-testing implementation of a few JUnit5 contracts to support SessionFactory-based testing,\n * including argument injection (or see {@link SessionFactoryScopeAware})\n *\n * @author Steve Ebersole\n *\n * @see DomainModelExtension\n * @see SessionFactoryExtension\n */\npublic class EntityManagerFactoryExtension\n\t\timplements TestInstancePostProcessor, BeforeEachCallback, TestExecutionExceptionHandler {\n\n\tprivate static final Logger log = Logger.getLogger( EntityManagerFactoryExtension.class );\n\tprivate static final String EMF_KEY = EntityManagerFactoryScope.class.getName();\n\n\tprivate static ExtensionContext.Store locateExtensionStore(Object testScope, ExtensionContext context) {\n\t\treturn JUnitHelper.locateExtensionStore( EntityManagerFactoryExtension.class, context, testScope );\n\t}\n\n\tpublic static EntityManagerFactoryScope findEntityManagerFactoryScope(\n\t\t\tObject testScope, Optional<Jpa> optionalJpa, ExtensionContext context) {\n\n\t\tif ( optionalJpa.isEmpty() ) {\n\t\t\t// No annotation on the test class, should be on the test methods\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n\t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n\t\tif ( existing != null ) {\n\t\t\treturn existing;\n\t\t}\n\t\tif ( context.getElement().isEmpty() ) {\n\t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \"\n\t\t\t\t\t+ context.getDisplayName() );\n\t\t}\n\n\t\tfinal Jpa jpa = optionalJpa.get();\n\t\tfinal PersistenceUnitInfoImpl pui = createPersistenceUnitInfo( jpa );\n\t\tcollectProperties( pui, jpa );\n\t\tmanagedClassesAndMappings( jpa, pui );\n\t\tfinal Map<String, Object> integrationSettings = collectIntegrationSettings( jpa );\n\t\t// statement inspector\n\t\tsetupStatementInspector( jpa, integrationSettings );\n\t\tServiceRegistryUtil.applySettings( integrationSettings );\n\t\tfinal EntityManagerFactoryScopeImpl scope =\n\t\t\t\tnew EntityManagerFactoryScopeImpl( pui, integrationSettings );\n\t\tstore.put( EMF_KEY, scope );\n\t\treturn scope;\n\t}\n\n\tprivate static void collectProperties(PersistenceUnitInfoImpl pui, Jpa jpa) {\n\t\tfinal Properties properties = pui.getProperties();\n\t\tproperties.putAll( Environment.getProperties() );\n\t\t// JpaCompliance\n\t\tsetJpaComplianceProperties( properties, jpa );\n\t\tfor ( Setting property : jpa.properties() ) {\n\t\t\tproperties.setProperty( property.name(), property.value() );\n\t\t}\n\t\tproperties.setProperty(\n\t\t\t\tAvailableSettings.GENERATE_STATISTICS,\n\t\t\t\tBoolean.toString( jpa.generateStatistics() )\n\t\t);\n\t\tif ( jpa.exportSchema() ) {\n\t\t\tproperties.setProperty(\n\t\t\t\t\tAvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,\n\t\t\t\t\tAction.CREATE_DROP.getExternalHbm2ddlName()\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate static PersistenceUnitInfoImpl createPersistenceUnitInfo(Jpa jpa) {\n\t\tfinal PersistenceUnitInfoImpl pui =\n\t\t\t\tnew PersistenceUnitInfoImpl( jpa.persistenceUnitName() );\n\t\tpui.setTransactionType( jpa.transactionType() );\n\t\tpui.setCacheMode( jpa.sharedCacheMode() );\n\t\tpui.setValidationMode( jpa.validationMode() );\n\t\tpui.setExcludeUnlistedClasses( jpa.excludeUnlistedClasses() );\n\t\treturn pui;\n\t}\n\n\tprivate static void managedClassesAndMappings(Jpa jpa, PersistenceUnitInfoImpl pui) {\n\t\tif ( jpa.annotatedPackageNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( jpa.annotatedPackageNames() );\n\t\t}\n\n\t\tif ( jpa.annotatedClassNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( jpa.annotatedClassNames() );\n\t\t}\n\n\t\tif ( jpa.annotatedClasses().length > 0 ) {\n\t\t\tfor (int i = 0; i < jpa.annotatedClasses().length; i++ ) {\n\t\t\t\tpui.applyManagedClassNames( jpa.annotatedClasses()[i].getName() );\n\t\t\t}\n\t\t}\n\n\t\tif ( jpa.xmlMappings().length > 0 ) {\n\t\t\tpui.applyMappingFiles( jpa.xmlMappings() );\n\t\t}\n\n\t\tfor ( StandardDomainModel standardDomainModel : jpa.standardModels() ) {\n\t\t\tfor ( Class<?> annotatedClass : standardDomainModel.getDescriptor().getAnnotatedClasses() ) {\n\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t}\n\t\t}\n\n\t\tfor ( Class<? extends DomainModelDescriptor> modelDescriptorClass :\n\t\t\t\tjpa.modelDescriptorClasses() ) {\n\t\t\tfinal DomainModelDescriptor domainModelDescriptor =\n\t\t\t\t\tinstantiateDomainModelDescriptor( modelDescriptorClass );\n\t\t\tfinal Class<?>[] annotatedClasses = domainModelDescriptor.getAnnotatedClasses();\n\t\t\tfor ( Class<?> annotatedClass : annotatedClasses ) {\n\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static Map<String, Object> collectIntegrationSettings(Jpa jpa) {\n\t\tfinal Map<String, Object> integrationSettings = new HashMap<>();\n\t\tintegrationSettings.put( PersistentTableStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( GlobalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( LocalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tfinal Setting[] settings = jpa.integrationSettings();\n\t\tfor ( Setting setting : settings ) {\n\t\t\tintegrationSettings.put( setting.name(), setting.value() );\n\t\t}\n\t\tfor ( SettingProvider providerAnn : jpa.settingProviders() ) {\n\t\t\tfinal Class<? extends SettingProvider.Provider<?>> providerImpl = providerAnn.provider();\n\t\t\ttry {\n\t\t\t\tintegrationSettings.put( providerAnn.settingName(),\n\t\t\t\t\t\tproviderImpl.getConstructor().newInstance().getSetting() );\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tlog.error( \"Error obtaining setting provider for \" + providerImpl.getName(), e );\n\t\t\t}\n\t\t}\n\t\treturn integrationSettings;\n\t}\n\n\tprivate static void setupStatementInspector(Jpa jpa, Map<String, Object> integrationSettings) {\n\t\tif ( jpa.useCollectingStatementInspector() ) {\n\t\t\tfinal String inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n\t\t\tif ( inspectorSetting != null && !inspectorSetting.isBlank() ) {\n\t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n\t\t\t}\n\t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n\t\t}\n\t}\n\n\tprivate static void setJpaComplianceProperties(Properties properties, Jpa jpa) {\n\t\tproperties.put( AvailableSettings.JPA_COMPLIANCE, jpa.jpaComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_QUERY_COMPLIANCE, jpa.queryComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, jpa.transactionComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_CLOSED_COMPLIANCE, jpa.closedComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_PROXY_COMPLIANCE, jpa.proxyComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_CACHING_COMPLIANCE, jpa.cacheComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, jpa.generatorScopeComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, jpa.orderByMappingComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, jpa.loadByIdComplianceEnabled() );\n\t}\n\n\tprivate static DomainModelDescriptor instantiateDomainModelDescriptor(\n\t\t\tClass<? extends DomainModelDescriptor> modelDescriptorClass) {\n\t\t// first, see if it has a static singleton reference and use that if so\n\t\ttry {\n\t\t\tfor ( Field field : modelDescriptorClass.getDeclaredFields() ) {\n\t\t\t\tif ( ReflectHelper.isStaticField(field) ) {\n\t\t\t\t\tfinal Object value = field.get( null );\n\t\t\t\t\tif ( value instanceof DomainModelDescriptor descriptor ) {\n\t\t\t\t\t\treturn descriptor;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalAccessException e) {\n\t\t\tthrow new RuntimeException( \"Problem accessing DomainModelDescriptor fields : \"\n\t\t\t\t\t+ modelDescriptorClass.getName(), e );\n\t\t}\n\n\t\t// no singleton field, try to instantiate it via reflection\n\t\ttry {\n\t\t\treturn modelDescriptorClass.getConstructor( null ).newInstance( null );\n\t\t}\n\t\tcatch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {\n\t\t\tthrow new RuntimeException( \"Problem instantiation DomainModelDescriptor : \"\n\t\t\t\t\t+ modelDescriptorClass.getName(), e );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void beforeEach(ExtensionContext context) {\n\t\tlog.tracef( \"#beforeEach(%s)\", context.getDisplayName() );\n\t\tfinal Optional<Jpa> optionalJpa = findAnnotation( context.getRequiredTestMethod(), Jpa.class );\n\t\tif ( optionalJpa.isPresent() ) {\n\t\t\tfindEntityManagerFactoryScope( context.getRequiredTestMethod(), optionalJpa, context );\n\t\t}\n\t\t// else assume the annotation is defined on the class-level...\n\t}\n\n\t@Override\n\tpublic void postProcessTestInstance(Object testInstance, ExtensionContext context) {\n\t\tlog.tracef( \"#postProcessTestInstance(%s, %s)\", testInstance, context.getDisplayName() );\n\t\tfinal Optional<Jpa> optionalJpa = findAnnotation( context.getRequiredTestClass(), Jpa.class );\n\t\tfindEntityManagerFactoryScope( testInstance, optionalJpa, context );\n\t}\n\n\t@Override\n\tpublic void handleTestExecutionException(ExtensionContext context, Throwable throwable) throws Throwable {\n\t\tlog.tracef( \"#handleTestExecutionException(%s, %s)\", context.getDisplayName(), throwable );\n\t\ttry {\n\t\t\tfinal ExtensionContext.Store store = locateExtensionStore( context.getRequiredTestInstance(), context );\n\t\t\tfinal EntityManagerFactoryScopeImpl scope = (EntityManagerFactoryScopeImpl) store.get( EMF_KEY );\n\t\t\tscope.releaseEntityManagerFactory();\n\t\t}\n\t\tcatch (Exception ignore) {\n\t\t}\n\t\tthrow throwable;\n\t}\n\n\tprivate static class EntityManagerFactoryScopeImpl extends AbstractEntityManagerFactoryScope {\n\t\tprivate final PersistenceUnitInfo persistenceUnitInfo;\n\t\tprivate final Map<String, Object> integrationSettings;\n\n\t\tprivate EntityManagerFactoryScopeImpl(\n\t\t\t\tPersistenceUnitInfo persistenceUnitInfo,\n\t\t\t\tMap<String, Object> integrationSettings) {\n\t\t\tthis.persistenceUnitInfo = persistenceUnitInfo;\n\t\t\tthis.integrationSettings = integrationSettings;\n\t\t}\n\n\t\tprotected jakarta.persistence.EntityManagerFactory createEntityManagerFactory() {\n\t\t\tfinal PersistenceUnitInfoDescriptor descriptor = new PersistenceUnitInfoDescriptor( persistenceUnitInfo );\n\t\t\treturn getEntityManagerFactoryBuilder( descriptor, integrationSettings ).build();\n\t\t}\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private static void setJpaComplianceProperties(Properties properties, Jpa jpa) {\n\t\tproperties.put( AvailableSettings.JPA_COMPLIANCE, jpa.jpaComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_QUERY_COMPLIANCE, jpa.queryComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, jpa.transactionComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_CLOSED_COMPLIANCE, jpa.closedComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_PROXY_COMPLIANCE, jpa.proxyComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_CACHING_COMPLIANCE, jpa.cacheComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, jpa.generatorScopeComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, jpa.orderByMappingComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, jpa.loadByIdComplianceEnabled() );\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#setValidationMode\n methodBody: public void setValidationMode(String validationMode) {\nsetValidationMode(ValidationMode.valueOf(validationMode));\n}",
            "methodSignature: org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}",
            "methodSignature: org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor#getName\n methodBody: public String getName() {\nreturn persistenceUnitInfo.getPersistenceUnitName();\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setTransactionType\n methodBody: public void setTransactionType(PersistenceUnitTransactionType transactionType) {\nthis.transactionType=transactionType;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest#applySettings\n methodBody: protected void applySettings(Map<Object, Object> settings) {\nString[] mappings=getMappings();\nif(mappings != null){settings.put(AvailableSettings.HBM_XML_FILES,String.join(\",\",mappings));\n}}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setValidationMode\n methodBody: public void setValidationMode(ValidationMode validationMode) {\nthis.validationMode=validationMode;\n}",
            "methodSignature: org.hibernate.collection.spi.AbstractPersistentCollection.SetProxy#isEmpty\n methodBody: public boolean isEmpty() {\nreturn set.isEmpty();\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#applyMappingFiles\n methodBody: public void applyMappingFiles(String... mappingFiles) {\nif(this.mappingFiles == null){this.mappingFiles=new ArrayList<>();\n}Collections.addAll(this.mappingFiles,mappingFiles);\n}",
            "methodSignature: org.hibernate.testing.util.jpa.DelegatingPersistenceUnitInfo#getProperties\n methodBody: public Properties getProperties() {\nreturn delegate.getProperties();\n}",
            "methodSignature: org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentList#get\n methodBody: public E get(int index) {\nif(index < 0){throw new ArrayIndexOutOfBoundsException(\"negative index\");\n}final Object result=readElementByIndex(index);\nreturn result == UNKNOWN ? list.get(index) : (E)result;\n}",
            "methodSignature: org.hibernate.orm.test.bootstrap.BootstrapTest.PersistenceUnitInfoImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest.TestingPersistenceUnitDescriptorImpl#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.jpa.boot.spi.PersistenceConfigurationDescriptor#getName\n methodBody: public String getName() {\nreturn persistenceConfiguration.name();\n}",
            "methodSignature: org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor#getProperties\n methodBody: public Properties getProperties() {\nreturn persistenceUnitInfo.getProperties();\n}",
            "methodSignature: org.hibernate.jpa.boot.spi.PersistenceUnitDescriptor#getProperties\n methodBody: Properties getProperties();",
            "methodSignature: org.hibernate.testing.orm.junit.BaseSessionFactoryFunctionalTest#getAnnotatedClasses\n methodBody: protected Class[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.BaseSessionFactoryFunctionalTest#applySettings\n methodBody: protected void applySettings(StandardServiceRegistryBuilder builder) {\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoAdapter#getProperties\n methodBody: public Properties getProperties() {\nif(properties == null){properties=new Properties();\n}return properties;\n}",
            "methodSignature: org.hibernate.testing.util.jpa.DelegatingPersistenceUnitInfo#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn delegate.excludeUnlistedClasses();\n}",
            "methodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoAdapter#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setCacheMode\n methodBody: public void setCacheMode(SharedCacheMode cacheMode) {\nthis.cacheMode=cacheMode;\n}",
            "methodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.orm.test.jpa.BaseEntityManagerFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn excludeUnlistedClasses;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}",
            "methodSignature: org.hibernate.collection.spi.AbstractPersistentCollection.ListProxy#get\n methodBody: public E get(int i) {\nreturn list.get(i);\n}",
            "methodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoAdapter#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}",
            "methodSignature: org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}",
            "methodSignature: org.hibernate.orm.test.bootstrap.BootstrapTest.PersistenceUnitInfoImpl#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}",
            "methodSignature: org.hibernate.jpa.boot.spi.PersistenceConfigurationDescriptor#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitDescriptorAdapter#getProperties\n methodBody: public Properties getProperties() {\nif(properties == null){properties=new Properties();\n}return properties;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentBag#get\n methodBody: public E get(int i) {\nread();\nreturn bag.get(i);\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoAdapter#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#setExcludeUnlistedClasses\n methodBody: public void setExcludeUnlistedClasses(boolean excludeUnlistedClasses) {\nthis.excludeUnlistedClasses=excludeUnlistedClasses;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentList#toString\n methodBody: public String toString() {\nread();\nreturn list.toString();\n}",
            "methodSignature: org.hibernate.testing.junit4.BaseCoreFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentBag#getElement\n methodBody: public Object getElement(Object entry) {\nreturn entry;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentBag#isEmpty\n methodBody: public boolean isEmpty() {\nreturn readSize() ? getCachedSize() == 0 : bag.isEmpty();\n}",
            "methodSignature: org.hibernate.orm.test.jpa.xml.versions.JpaXsdVersionsTest.PersistenceUnitInfoImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}",
            "methodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#setTransactionType\n methodBody: public void setTransactionType(PersistenceUnitTransactionType transactionType) {\nthis.transactionType=transactionType;\n}",
            "methodSignature: org.hibernate.orm.test.jpa.EntityManagerTest#getAnnotatedClasses\n methodBody: public Class[] getAnnotatedClasses() {\nreturn new Class[]{Item.class,Distributor.class,Wallet.class};\n}",
            "methodSignature: org.hibernate.orm.test.jpa.BaseEntityManagerFunctionalTestCase#getAnnotatedClasses\n methodBody: protected Class<?>[] getAnnotatedClasses() {\nreturn NO_CLASSES;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest#exportSchema\n methodBody: protected boolean exportSchema() {\nreturn true;\n}",
            "methodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}",
            "methodSignature: org.hibernate.internal.SessionFactoryImpl#getProperties\n methodBody: public Map<String, Object> getProperties() {\nvalidateNotClosed();\nreturn settings;\n}",
            "methodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoPropertiesWrapper#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}",
            "methodSignature: org.hibernate.orm.test.jpa.xml.versions.JpaXsdVersionsTest.PersistenceUnitInfoImpl#excludeUnlistedClasses\n methodBody: public boolean excludeUnlistedClasses() {\nreturn false;\n}",
            "methodSignature: org.hibernate.jpa.boot.spi.PersistenceUnitDescriptor#getName\n methodBody: String getName();",
            "methodSignature: org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn null;\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitDescriptorAdapter#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryExtension#locateExtensionStore\n methodBody: private static ExtensionContext.Store locateExtensionStore(Object testScope, ExtensionContext context) {\nreturn JUnitHelper.locateExtensionStore(EntityManagerFactoryExtension.class,context,testScope);\n}",
            "methodSignature: org.hibernate.jpa.boot.internal.ParsedPersistenceXmlDescriptor#setExcludeUnlistedClasses\n methodBody: public void setExcludeUnlistedClasses(boolean excludeUnlistedClasses) {\nthis.excludeUnlistedClasses=excludeUnlistedClasses;\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#applyManagedClassNames\n methodBody: public void applyManagedClassNames(String... managedClassNames) {\nif(this.managedClassNames == null){this.managedClassNames=new ArrayList<>();\n}Collections.addAll(this.managedClassNames,managedClassNames);\n}",
            "methodSignature: org.hibernate.testing.util.jpa.PersistenceUnitInfoPropertiesWrapper#getProperties\n methodBody: public Properties getProperties() {\nif(properties == null){properties=new Properties();\n}return properties;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentList#getElement\n methodBody: public Object getElement(Object entry) {\nreturn entry;\n}",
            "methodSignature: org.hibernate.orm.test.jpa.BaseEntityManagerFunctionalTestCase.TestingPersistenceUnitDescriptorImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn null;\n}",
            "methodSignature: org.hibernate.internal.SessionFactoryImpl#getName\n methodBody: public String getName() {\nreturn name;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryBasedFunctionalTest.TestingPersistenceUnitDescriptorImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn null;\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentList#isEmpty\n methodBody: public boolean isEmpty() {\nreturn readSize() ? getCachedSize() == 0 : list.isEmpty();\n}",
            "methodSignature: org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl#getProperties\n methodBody: public Properties getProperties() {\nreturn properties;\n}",
            "methodSignature: org.hibernate.testing.orm.junit.EntityManagerFactoryExtension#instantiateDomainModelDescriptor\n methodBody: private static DomainModelDescriptor instantiateDomainModelDescriptor(Class<? extends DomainModelDescriptor> modelDescriptorClass) {\ntryfinal Field[] declaredFields=modelDescriptorClass.getDeclaredFields();\nfor(int i=0; i < declaredFields.length; i++){final Field field=declaredFields[i];\nif(ReflectHelper.isStaticField(field)){final Object value=field.get(null);\nif(value instanceof DomainModelDescriptor){return (DomainModelDescriptor)value;\n}}}catch(IllegalAccessException e)throw new RuntimeException(\"Problem accessing DomainModelDescriptor fields : \" + modelDescriptorClass.getName(),e);\ntryreturn modelDescriptorClass.getConstructor(null).newInstance(null);\ncatch(InstantiationException|IllegalAccessException|InvocationTargetException|NoSuchMethodException e)throw new RuntimeException(\"Problem instantiation DomainModelDescriptor : \" + modelDescriptorClass.getName(),e);\n}",
            "methodSignature: org.hibernate.testing.orm.junit.BaseSessionFactoryFunctionalTest#exportSchema\n methodBody: protected boolean exportSchema() {\nreturn true;\n}",
            "methodSignature: org.hibernate.collection.spi.AbstractPersistentCollection.ListProxy#isEmpty\n methodBody: public boolean isEmpty() {\nreturn list.isEmpty();\n}",
            "methodSignature: org.hibernate.collection.spi.PersistentBag#toString\n methodBody: public String toString() {\nread();\nreturn bag.toString();\n}"
        ],
        "sourceCodeAfterRefactoring": "private static void collectProperties(PersistenceUnitInfoImpl pui, Jpa jpa) {\n\t\tfinal Properties properties = pui.getProperties();\n\t\tproperties.putAll( Environment.getProperties() );\n\t\t// JpaCompliance\n\t\tsetJpaComplianceProperties( properties, jpa );\n\t\tfor ( Setting property : jpa.properties() ) {\n\t\t\tproperties.setProperty( property.name(), property.value() );\n\t\t}\n\t\tproperties.setProperty(\n\t\t\t\tAvailableSettings.GENERATE_STATISTICS,\n\t\t\t\tBoolean.toString( jpa.generateStatistics() )\n\t\t);\n\t\tif ( jpa.exportSchema() ) {\n\t\t\tproperties.setProperty(\n\t\t\t\t\tAvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,\n\t\t\t\t\tAction.CREATE_DROP.getExternalHbm2ddlName()\n\t\t\t);\n\t\t}\n\t}\nprivate static void setJpaComplianceProperties(Properties properties, Jpa jpa) {\n\t\tproperties.put( AvailableSettings.JPA_COMPLIANCE, jpa.jpaComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_QUERY_COMPLIANCE, jpa.queryComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, jpa.transactionComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_CLOSED_COMPLIANCE, jpa.closedComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_PROXY_COMPLIANCE, jpa.proxyComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_CACHING_COMPLIANCE, jpa.cacheComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, jpa.generatorScopeComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, jpa.orderByMappingComplianceEnabled() );\n\t\tproperties.put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, jpa.loadByIdComplianceEnabled() );\n\t}",
        "diffSourceCode": "-   66: \tpublic static EntityManagerFactoryScope findEntityManagerFactoryScope(\n-   67: \t\t\tObject testScope,\n-   68: \t\t\tOptional<Jpa> emfAnnWrapper,\n-   69: \t\t\tExtensionContext context) {\n-   70: \n-   71: \t\tif ( emfAnnWrapper.isEmpty() ) {\n-   72: \t\t\t// No annotation on the test class, should be on the test methods\n-   73: \t\t\treturn null;\n-   74: \t\t}\n-   75: \n-   76: \t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n-   77: \t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n-   78: \t\tif ( existing != null ) {\n-   79: \t\t\treturn existing;\n-   80: \t\t}\n-   81: \n-   82: \t\tif ( !context.getElement().isPresent() ) {\n-   83: \t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \" + context.getDisplayName() );\n-   84: \t\t}\n-   85: \t\tfinal Jpa emfAnn = emfAnnWrapper.get();\n-   86: \n-   87: \t\tfinal PersistenceUnitInfoImpl pui = new PersistenceUnitInfoImpl( emfAnn.persistenceUnitName() );\n-   88: \t\t( (Map<Object, Object>) Environment.getProperties() ).forEach(\n-   89: \t\t\t\t(key, value) ->\n-   90: \t\t\t\t\t\tpui.getProperties().put( key, value )\n-   91: \t\t);\n+   66: \t\t\treturn null;\n+   67: \t\t}\n+   68: \n+   69: \t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n+   70: \t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n+   71: \t\tif ( existing != null ) {\n+   72: \t\t\treturn existing;\n+   73: \t\t}\n+   74: \t\tif ( context.getElement().isEmpty() ) {\n+   75: \t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \"\n+   76: \t\t\t\t\t+ context.getDisplayName() );\n+   77: \t\t}\n+   78: \n+   79: \t\tfinal Jpa jpa = optionalJpa.get();\n+   80: \t\tfinal PersistenceUnitInfoImpl pui = createPersistenceUnitInfo( jpa );\n+   81: \t\tcollectProperties( pui, jpa );\n+   82: \t\tmanagedClassesAndMappings( jpa, pui );\n+   83: \t\tfinal Map<String, Object> integrationSettings = collectIntegrationSettings( jpa );\n+   84: \t\t// statement inspector\n+   85: \t\tsetupStatementInspector( jpa, integrationSettings );\n+   86: \t\tServiceRegistryUtil.applySettings( integrationSettings );\n+   87: \t\tfinal EntityManagerFactoryScopeImpl scope =\n+   88: \t\t\t\tnew EntityManagerFactoryScopeImpl( pui, integrationSettings );\n+   89: \t\tstore.put( EMF_KEY, scope );\n+   90: \t\treturn scope;\n+   91: \t}\n    92: \n-   93: \t\tpui.setTransactionType( emfAnn.transactionType() );\n-   94: \t\tpui.setCacheMode( emfAnn.sharedCacheMode() );\n-   95: \t\tpui.setValidationMode( emfAnn.validationMode() );\n-   96: \t\tpui.setExcludeUnlistedClasses( emfAnn.excludeUnlistedClasses() );\n-   97: \n-   98: \t\t// JpaCompliance\n-   99: \t\tpui.getProperties().put( AvailableSettings.JPA_COMPLIANCE, emfAnn.jpaComplianceEnabled() );\n-  100: \t\tpui.getProperties().put( AvailableSettings.JPA_QUERY_COMPLIANCE, emfAnn.queryComplianceEnabled() );\n-  101: \t\tpui.getProperties().put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, emfAnn.transactionComplianceEnabled() );\n-  102: \t\tpui.getProperties().put( AvailableSettings.JPA_CLOSED_COMPLIANCE, emfAnn.closedComplianceEnabled() );\n-  103: \t\tpui.getProperties().put( AvailableSettings.JPA_PROXY_COMPLIANCE, emfAnn.proxyComplianceEnabled() );\n-  104: \t\tpui.getProperties().put( AvailableSettings.JPA_CACHING_COMPLIANCE, emfAnn.cacheComplianceEnabled() );\n-  105: \t\tpui.getProperties().put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, emfAnn.generatorScopeComplianceEnabled() );\n-  106: \t\tpui.getProperties().put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, emfAnn.orderByMappingComplianceEnabled() );\n-  107: \t\tpui.getProperties().put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, emfAnn.loadByIdComplianceEnabled() );\n-  108: \n-  109: \t\tfinal Setting[] properties = emfAnn.properties();\n-  110: \t\tfor ( int i = 0; i < properties.length; i++ ) {\n-  111: \t\t\tfinal Setting property = properties[i];\n-  112: \t\t\tpui.getProperties().setProperty( property.name(), property.value() );\n-  113: \t\t}\n-  114: \n-  115: \t\tpui.getProperties().setProperty(\n-  116: \t\t\t\tAvailableSettings.GENERATE_STATISTICS,\n-  117: \t\t\t\tBoolean.toString( emfAnn.generateStatistics() )\n-  118: \t\t);\n-  119: \n-  120: \t\tif ( emfAnn.exportSchema() ) {\n-  121: \t\t\tpui.getProperties().setProperty(\n-  122: \t\t\t\t\tAvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,\n-  123: \t\t\t\t\tAction.CREATE_DROP.getExternalHbm2ddlName()\n-  124: \t\t\t);\n-  125: \t\t}\n-  126: \n-  127: \t\tif ( emfAnn.annotatedPackageNames().length > 0 ) {\n-  128: \t\t\tpui.applyManagedClassNames( emfAnn.annotatedPackageNames() );\n-  129: \t\t}\n-  130: \n-  131: \t\tif ( emfAnn.annotatedClassNames().length > 0 ) {\n-  132: \t\t\tpui.applyManagedClassNames( emfAnn.annotatedClassNames() );\n-  133: \t\t}\n-  134: \n-  135: \t\tif ( emfAnn.annotatedClasses().length > 0 ) {\n-  136: \t\t\tfor ( int i = 0; i < emfAnn.annotatedClasses().length; i++ ) {\n-  137: \t\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClasses()[i].getName() );\n-  138: \t\t\t}\n-  139: \t\t}\n-  140: \n-  141: \t\tif ( emfAnn.xmlMappings().length > 0 ) {\n-  142: \t\t\tpui.applyMappingFiles( emfAnn.xmlMappings() );\n-  143: \t\t}\n-  144: \n-  145: \t\tif ( emfAnn.standardModels().length > 0 ) {\n-  146: \t\t\tfor ( int i = 0; i < emfAnn.standardModels().length; i++ ) {\n-  147: \t\t\t\tfinal StandardDomainModel standardDomainModel = emfAnn.standardModels()[i];\n-  148: \t\t\t\tfor ( int i1 = 0; i1 < standardDomainModel.getDescriptor().getAnnotatedClasses().length; i1++ ) {\n-  149: \t\t\t\t\tfinal Class<?> annotatedClass = standardDomainModel.getDescriptor().getAnnotatedClasses()[i1];\n-  150: \t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n-  151: \t\t\t\t}\n-  152: \t\t\t}\n-  153: \t\t}\n-  154: \n-  155: \t\tif ( emfAnn.modelDescriptorClasses().length > 0 ) {\n-  156: \t\t\tfor ( int i = 0; i < emfAnn.modelDescriptorClasses().length; i++ ) {\n-  157: \t\t\t\tfinal Class<? extends DomainModelDescriptor> modelDescriptorClass = emfAnn.modelDescriptorClasses()[i];\n-  158: \t\t\t\tfinal DomainModelDescriptor domainModelDescriptor = instantiateDomainModelDescriptor(\n-  159: \t\t\t\t\t\tmodelDescriptorClass );\n-  160: \t\t\t\tfor ( int i1 = 0; i1 < domainModelDescriptor.getAnnotatedClasses().length; i1++ ) {\n-  161: \t\t\t\t\tfinal Class<?> annotatedClass = domainModelDescriptor.getAnnotatedClasses()[i1];\n-  162: \t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n-  163: \t\t\t\t}\n-  164: \t\t\t}\n-  165: \t\t}\n-  166: \n-  167: \t\tfinal Map<String, Object> integrationSettings = new HashMap<>();\n-  168: \n-  169: \t\tintegrationSettings.put( PersistentTableStrategy.DROP_ID_TABLES, \"true\" );\n-  170: \t\tintegrationSettings.put( GlobalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n-  171: \t\tintegrationSettings.put( LocalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n-  172: \t\tfor ( int i = 0; i < emfAnn.integrationSettings().length; i++ ) {\n-  173: \t\t\tfinal Setting setting = emfAnn.integrationSettings()[i];\n-  174: \t\t\tintegrationSettings.put( setting.name(), setting.value() );\n-  175: \t\t}\n-  176: \n-  177: \t\tfor ( SettingProvider providerAnn : emfAnn.settingProviders() ) {\n-  178: \t\t\tfinal Class<? extends SettingProvider.Provider<?>> providerImpl = providerAnn.provider();\n-  179: \t\t\ttry {\n-  180: \t\t\t\tfinal SettingProvider.Provider<?> provider = providerImpl.getConstructor().newInstance();\n-  181: \t\t\t\tintegrationSettings.put( providerAnn.settingName(), provider.getSetting() );\n-  182: \t\t\t}\n-  183: \t\t\tcatch (Exception e) {\n-  184: \t\t\t\tlog.error( \"Error obtaining setting provider for \" + providerImpl.getName(), e );\n-  185: \t\t\t}\n-  186: \t\t}\n-  187: \n-  188: \t\t// statement inspector\n-  189: \t\tif ( emfAnn.useCollectingStatementInspector() ) {\n-  190: \t\t\tString inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n-  191: \t\t\tif ( !(inspectorSetting == null || inspectorSetting.isBlank()) ) {\n-  192: \t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n-  193: \t\t\t}\n-  194: \t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n-  195: \t\t}\n-  196: \n-  197: \t\tServiceRegistryUtil.applySettings( integrationSettings );\n-  198: \t\tfinal EntityManagerFactoryScopeImpl scope = new EntityManagerFactoryScopeImpl( pui, integrationSettings );\n-  199: \n-  200: \t\tstore.put( EMF_KEY, scope );\n-  201: \n-  202: \t\treturn scope;\n-  203: \t}\n+   93: \tprivate static void collectProperties(PersistenceUnitInfoImpl pui, Jpa jpa) {\n+   94: \t\tfinal Properties properties = pui.getProperties();\n+   95: \t\tproperties.putAll( Environment.getProperties() );\n+   96: \t\t// JpaCompliance\n+   97: \t\tsetJpaComplianceProperties( properties, jpa );\n+   98: \t\tfor ( Setting property : jpa.properties() ) {\n+   99: \t\t\tproperties.setProperty( property.name(), property.value() );\n+  100: \t\t}\n+  101: \t\tproperties.setProperty(\n+  102: \t\t\t\tAvailableSettings.GENERATE_STATISTICS,\n+  103: \t\t\t\tBoolean.toString( jpa.generateStatistics() )\n+  104: \t\t);\n+  105: \t\tif ( jpa.exportSchema() ) {\n+  106: \t\t\tproperties.setProperty(\n+  107: \t\t\t\t\tAvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,\n+  108: \t\t\t\t\tAction.CREATE_DROP.getExternalHbm2ddlName()\n+  109: \t\t\t);\n+  110: \t\t}\n+  111: \t}\n+  112: \n+  113: \tprivate static PersistenceUnitInfoImpl createPersistenceUnitInfo(Jpa jpa) {\n+  114: \t\tfinal PersistenceUnitInfoImpl pui =\n+  115: \t\t\t\tnew PersistenceUnitInfoImpl( jpa.persistenceUnitName() );\n+  116: \t\tpui.setTransactionType( jpa.transactionType() );\n+  117: \t\tpui.setCacheMode( jpa.sharedCacheMode() );\n+  118: \t\tpui.setValidationMode( jpa.validationMode() );\n+  119: \t\tpui.setExcludeUnlistedClasses( jpa.excludeUnlistedClasses() );\n+  120: \t\treturn pui;\n+  121: \t}\n+  122: \n+  123: \tprivate static void managedClassesAndMappings(Jpa jpa, PersistenceUnitInfoImpl pui) {\n+  124: \t\tif ( jpa.annotatedPackageNames().length > 0 ) {\n+  125: \t\t\tpui.applyManagedClassNames( jpa.annotatedPackageNames() );\n+  126: \t\t}\n+  127: \n+  128: \t\tif ( jpa.annotatedClassNames().length > 0 ) {\n+  129: \t\t\tpui.applyManagedClassNames( jpa.annotatedClassNames() );\n+  130: \t\t}\n+  131: \n+  132: \t\tif ( jpa.annotatedClasses().length > 0 ) {\n+  133: \t\t\tfor (int i = 0; i < jpa.annotatedClasses().length; i++ ) {\n+  134: \t\t\t\tpui.applyManagedClassNames( jpa.annotatedClasses()[i].getName() );\n+  135: \t\t\t}\n+  136: \t\t}\n+  137: \n+  138: \t\tif ( jpa.xmlMappings().length > 0 ) {\n+  139: \t\t\tpui.applyMappingFiles( jpa.xmlMappings() );\n+  140: \t\t}\n+  141: \n+  142: \t\tfor ( StandardDomainModel standardDomainModel : jpa.standardModels() ) {\n+  143: \t\t\tfor ( Class<?> annotatedClass : standardDomainModel.getDescriptor().getAnnotatedClasses() ) {\n+  144: \t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n+  145: \t\t\t}\n+  146: \t\t}\n+  147: \n+  148: \t\tfor ( Class<? extends DomainModelDescriptor> modelDescriptorClass :\n+  149: \t\t\t\tjpa.modelDescriptorClasses() ) {\n+  150: \t\t\tfinal DomainModelDescriptor domainModelDescriptor =\n+  151: \t\t\t\t\tinstantiateDomainModelDescriptor( modelDescriptorClass );\n+  152: \t\t\tfinal Class<?>[] annotatedClasses = domainModelDescriptor.getAnnotatedClasses();\n+  153: \t\t\tfor ( Class<?> annotatedClass : annotatedClasses ) {\n+  154: \t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n+  155: \t\t\t}\n+  156: \t\t}\n+  157: \t}\n+  158: \n+  159: \tprivate static Map<String, Object> collectIntegrationSettings(Jpa jpa) {\n+  160: \t\tfinal Map<String, Object> integrationSettings = new HashMap<>();\n+  161: \t\tintegrationSettings.put( PersistentTableStrategy.DROP_ID_TABLES, \"true\" );\n+  162: \t\tintegrationSettings.put( GlobalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n+  163: \t\tintegrationSettings.put( LocalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n+  164: \t\tfinal Setting[] settings = jpa.integrationSettings();\n+  165: \t\tfor ( Setting setting : settings ) {\n+  166: \t\t\tintegrationSettings.put( setting.name(), setting.value() );\n+  167: \t\t}\n+  168: \t\tfor ( SettingProvider providerAnn : jpa.settingProviders() ) {\n+  169: \t\t\tfinal Class<? extends SettingProvider.Provider<?>> providerImpl = providerAnn.provider();\n+  170: \t\t\ttry {\n+  171: \t\t\t\tintegrationSettings.put( providerAnn.settingName(),\n+  172: \t\t\t\t\t\tproviderImpl.getConstructor().newInstance().getSetting() );\n+  173: \t\t\t}\n+  174: \t\t\tcatch (Exception e) {\n+  175: \t\t\t\tlog.error( \"Error obtaining setting provider for \" + providerImpl.getName(), e );\n+  176: \t\t\t}\n+  177: \t\t}\n+  178: \t\treturn integrationSettings;\n+  179: \t}\n+  180: \n+  181: \tprivate static void setupStatementInspector(Jpa jpa, Map<String, Object> integrationSettings) {\n+  182: \t\tif ( jpa.useCollectingStatementInspector() ) {\n+  183: \t\t\tfinal String inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n+  184: \t\t\tif ( inspectorSetting != null && !inspectorSetting.isBlank() ) {\n+  185: \t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n+  186: \t\t\t}\n+  187: \t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n+  188: \t\t}\n+  189: \t}\n+  190: \n+  191: \tprivate static void setJpaComplianceProperties(Properties properties, Jpa jpa) {\n+  192: \t\tproperties.put( AvailableSettings.JPA_COMPLIANCE, jpa.jpaComplianceEnabled() );\n+  193: \t\tproperties.put( AvailableSettings.JPA_QUERY_COMPLIANCE, jpa.queryComplianceEnabled() );\n+  194: \t\tproperties.put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, jpa.transactionComplianceEnabled() );\n+  195: \t\tproperties.put( AvailableSettings.JPA_CLOSED_COMPLIANCE, jpa.closedComplianceEnabled() );\n+  196: \t\tproperties.put( AvailableSettings.JPA_PROXY_COMPLIANCE, jpa.proxyComplianceEnabled() );\n+  197: \t\tproperties.put( AvailableSettings.JPA_CACHING_COMPLIANCE, jpa.cacheComplianceEnabled() );\n+  198: \t\tproperties.put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, jpa.generatorScopeComplianceEnabled() );\n+  199: \t\tproperties.put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, jpa.orderByMappingComplianceEnabled() );\n+  200: \t\tproperties.put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, jpa.loadByIdComplianceEnabled() );\n+  201: \t}\n+  202: \n+  203: \tprivate static DomainModelDescriptor instantiateDomainModelDescriptor(\n",
        "uniqueId": "4781c09d0df0eb4ce05b2fa0d2a12747023ae024_66_203_191_201_93_111",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 7,
                "covered": 55
            },
            "BRANCH": {
                "missed": 1,
                "covered": 5
            },
            "LINE": {
                "missed": 2,
                "covered": 17
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 3
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\nprivate static ExtensionContext.Store locateExtensionStore(Object testScope, ExtensionContext context) {\n    return JUnitHelper.locateExtensionStore(EntityManagerFactoryExtension.class, context, testScope);\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\npublic static EntityManagerFactoryScope findEntityManagerFactoryScope(\n\t\t\tObject testScope,\n\t\t\tOptional<Jpa> emfAnnWrapper,\n\t\t\tExtensionContext context) {\n\n\t\tif ( emfAnnWrapper.isEmpty() ) {\n\t\t\t// No annotation on the test class, should be on the test methods\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n\t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n\t\tif ( existing != null ) {\n\t\t\treturn existing;\n\t\t}\n\n\t\tif ( !context.getElement().isPresent() ) {\n\t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \" + context.getDisplayName() );\n\t\t}\n\t\tfinal Jpa emfAnn = emfAnnWrapper.get();\n\n\t\tfinal PersistenceUnitInfoImpl pui = new PersistenceUnitInfoImpl( emfAnn.persistenceUnitName() );\n\t\t( (Map<Object, Object>) Environment.getProperties() ).forEach(\n\t\t\t\t(key, value) ->\n\t\t\t\t\t\tpui.getProperties().put( key, value )\n\t\t);\n\n\t\tpui.setTransactionType( emfAnn.transactionType() );\n\t\tpui.setCacheMode( emfAnn.sharedCacheMode() );\n\t\tpui.setValidationMode( emfAnn.validationMode() );\n\t\tpui.setExcludeUnlistedClasses( emfAnn.excludeUnlistedClasses() );\n\n\t\t// JpaCompliance\n\t\tpui.getProperties().put( AvailableSettings.JPA_COMPLIANCE, emfAnn.jpaComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_QUERY_COMPLIANCE, emfAnn.queryComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, emfAnn.transactionComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_CLOSED_COMPLIANCE, emfAnn.closedComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_PROXY_COMPLIANCE, emfAnn.proxyComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_CACHING_COMPLIANCE, emfAnn.cacheComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, emfAnn.generatorScopeComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, emfAnn.orderByMappingComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, emfAnn.loadByIdComplianceEnabled() );\n\n\t\tfinal Setting[] properties = emfAnn.properties();\n\t\tfor ( int i = 0; i < properties.length; i++ ) {\n\t\t\tfinal Setting property = properties[i];\n\t\t\tpui.getProperties().setProperty( property.name(), property.value() );\n\t\t}\n\n\t\tpui.getProperties().setProperty(\n\t\t\t\tAvailableSettings.GENERATE_STATISTICS,\n\t\t\t\tBoolean.toString( emfAnn.generateStatistics() )\n\t\t);\n\n\t\tif ( emfAnn.exportSchema() ) {\n\t\t\tpui.getProperties().setProperty(\n\t\t\t\t\tAvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,\n\t\t\t\t\tAction.CREATE_DROP.getExternalHbm2ddlName()\n\t\t\t);\n\t\t}\n\n\t\tif ( emfAnn.annotatedPackageNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( emfAnn.annotatedPackageNames() );\n\t\t}\n\n\t\tif ( emfAnn.annotatedClassNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClassNames() );\n\t\t}\n\n\t\tif ( emfAnn.annotatedClasses().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.annotatedClasses().length; i++ ) {\n\t\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClasses()[i].getName() );\n\t\t\t}\n\t\t}\n\n\t\tif ( emfAnn.xmlMappings().length > 0 ) {\n\t\t\tpui.applyMappingFiles( emfAnn.xmlMappings() );\n\t\t}\n\n\t\tif ( emfAnn.standardModels().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.standardModels().length; i++ ) {\n\t\t\t\tfinal StandardDomainModel standardDomainModel = emfAnn.standardModels()[i];\n\t\t\t\tfor ( int i1 = 0; i1 < standardDomainModel.getDescriptor().getAnnotatedClasses().length; i1++ ) {\n\t\t\t\t\tfinal Class<?> annotatedClass = standardDomainModel.getDescriptor().getAnnotatedClasses()[i1];\n\t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( emfAnn.modelDescriptorClasses().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.modelDescriptorClasses().length; i++ ) {\n\t\t\t\tfinal Class<? extends DomainModelDescriptor> modelDescriptorClass = emfAnn.modelDescriptorClasses()[i];\n\t\t\t\tfinal DomainModelDescriptor domainModelDescriptor = instantiateDomainModelDescriptor(\n\t\t\t\t\t\tmodelDescriptorClass );\n\t\t\t\tfor ( int i1 = 0; i1 < domainModelDescriptor.getAnnotatedClasses().length; i1++ ) {\n\t\t\t\t\tfinal Class<?> annotatedClass = domainModelDescriptor.getAnnotatedClasses()[i1];\n\t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfinal Map<String, Object> integrationSettings = new HashMap<>();\n\n\t\tintegrationSettings.put( PersistentTableStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( GlobalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( LocalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tfor ( int i = 0; i < emfAnn.integrationSettings().length; i++ ) {\n\t\t\tfinal Setting setting = emfAnn.integrationSettings()[i];\n\t\t\tintegrationSettings.put( setting.name(), setting.value() );\n\t\t}\n\n\t\tfor ( SettingProvider providerAnn : emfAnn.settingProviders() ) {\n\t\t\tfinal Class<? extends SettingProvider.Provider<?>> providerImpl = providerAnn.provider();\n\t\t\ttry {\n\t\t\t\tfinal SettingProvider.Provider<?> provider = providerImpl.getConstructor().newInstance();\n\t\t\t\tintegrationSettings.put( providerAnn.settingName(), provider.getSetting() );\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tlog.error( \"Error obtaining setting provider for \" + providerImpl.getName(), e );\n\t\t\t}\n\t\t}\n\n\t\t// statement inspector\n\t\tif ( emfAnn.useCollectingStatementInspector() ) {\n\t\t\tString inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n\t\t\tif ( !(inspectorSetting == null || inspectorSetting.isBlank()) ) {\n\t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n\t\t\t}\n\t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n\t\t}\n\n\t\tServiceRegistryUtil.applySettings( integrationSettings );\n\t\tfinal EntityManagerFactoryScopeImpl scope = new EntityManagerFactoryScopeImpl( pui, integrationSettings );\n\n\t\tstore.put( EMF_KEY, scope );\n\n\t\treturn scope;\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n */\npackage org.hibernate.testing.orm.junit;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport jakarta.persistence.spi.PersistenceUnitInfo;\n\nimport org.hibernate.SessionFactoryObserver;\nimport org.hibernate.boot.registry.StandardServiceRegistry;\nimport org.hibernate.boot.spi.MetadataImplementor;\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.cfg.Environment;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.internal.util.ReflectHelper;\nimport org.hibernate.jpa.boot.internal.PersistenceUnitInfoDescriptor;\nimport org.hibernate.jpa.boot.spi.Bootstrap;\nimport org.hibernate.jpa.boot.spi.EntityManagerFactoryBuilder;\nimport org.hibernate.query.sqm.mutation.internal.temptable.GlobalTemporaryTableMutationStrategy;\nimport org.hibernate.query.sqm.mutation.internal.temptable.LocalTemporaryTableMutationStrategy;\nimport org.hibernate.query.sqm.mutation.internal.temptable.PersistentTableStrategy;\nimport org.hibernate.tool.schema.Action;\nimport org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator;\nimport org.hibernate.tool.schema.spi.SchemaManagementToolCoordinator.ActionGrouping;\n\nimport org.hibernate.testing.jdbc.SQLStatementInspector;\nimport org.hibernate.testing.orm.domain.DomainModelDescriptor;\nimport org.hibernate.testing.orm.domain.StandardDomainModel;\nimport org.hibernate.testing.orm.jpa.PersistenceUnitInfoImpl;\nimport org.hibernate.testing.util.ServiceRegistryUtil;\nimport org.junit.jupiter.api.extension.BeforeEachCallback;\nimport org.junit.jupiter.api.extension.ExtensionContext;\nimport org.junit.jupiter.api.extension.TestExecutionExceptionHandler;\nimport org.junit.jupiter.api.extension.TestInstancePostProcessor;\nimport org.junit.platform.commons.support.AnnotationSupport;\n\nimport org.jboss.logging.Logger;\n\n/**\n * hibernate-testing implementation of a few JUnit5 contracts to support SessionFactory-based testing,\n * including argument injection (or see {@link SessionFactoryScopeAware})\n *\n * @author Steve Ebersole\n *\n * @see DomainModelExtension\n * @see SessionFactoryExtension\n */\npublic class EntityManagerFactoryExtension\n\t\timplements TestInstancePostProcessor, BeforeEachCallback, TestExecutionExceptionHandler {\n\n\tprivate static final Logger log = Logger.getLogger( EntityManagerFactoryExtension.class );\n\tprivate static final String EMF_KEY = EntityManagerFactoryScope.class.getName();\n\n\tprivate static ExtensionContext.Store locateExtensionStore(Object testScope, ExtensionContext context) {\n\t\treturn JUnitHelper.locateExtensionStore( EntityManagerFactoryExtension.class, context, testScope );\n\t}\n\n\tpublic static EntityManagerFactoryScope findEntityManagerFactoryScope(\n\t\t\tObject testScope,\n\t\t\tOptional<Jpa> emfAnnWrapper,\n\t\t\tExtensionContext context) {\n\n\t\tif ( emfAnnWrapper.isEmpty() ) {\n\t\t\t// No annotation on the test class, should be on the test methods\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal ExtensionContext.Store store = locateExtensionStore( testScope, context );\n\t\tfinal EntityManagerFactoryScope existing = (EntityManagerFactoryScope) store.get( EMF_KEY );\n\t\tif ( existing != null ) {\n\t\t\treturn existing;\n\t\t}\n\n\t\tif ( !context.getElement().isPresent() ) {\n\t\t\tthrow new RuntimeException( \"Unable to determine how to handle given ExtensionContext : \" + context.getDisplayName() );\n\t\t}\n\t\tfinal Jpa emfAnn = emfAnnWrapper.get();\n\n\t\tfinal PersistenceUnitInfoImpl pui = new PersistenceUnitInfoImpl( emfAnn.persistenceUnitName() );\n\t\t( (Map<Object, Object>) Environment.getProperties() ).forEach(\n\t\t\t\t(key, value) ->\n\t\t\t\t\t\tpui.getProperties().put( key, value )\n\t\t);\n\n\t\tpui.setTransactionType( emfAnn.transactionType() );\n\t\tpui.setCacheMode( emfAnn.sharedCacheMode() );\n\t\tpui.setValidationMode( emfAnn.validationMode() );\n\t\tpui.setExcludeUnlistedClasses( emfAnn.excludeUnlistedClasses() );\n\n\t\t// JpaCompliance\n\t\tpui.getProperties().put( AvailableSettings.JPA_COMPLIANCE, emfAnn.jpaComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_QUERY_COMPLIANCE, emfAnn.queryComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_TRANSACTION_COMPLIANCE, emfAnn.transactionComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_CLOSED_COMPLIANCE, emfAnn.closedComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_PROXY_COMPLIANCE, emfAnn.proxyComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_CACHING_COMPLIANCE, emfAnn.cacheComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE, emfAnn.generatorScopeComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_ORDER_BY_MAPPING_COMPLIANCE, emfAnn.orderByMappingComplianceEnabled() );\n\t\tpui.getProperties().put( AvailableSettings.JPA_LOAD_BY_ID_COMPLIANCE, emfAnn.loadByIdComplianceEnabled() );\n\n\t\tfinal Setting[] properties = emfAnn.properties();\n\t\tfor ( int i = 0; i < properties.length; i++ ) {\n\t\t\tfinal Setting property = properties[i];\n\t\t\tpui.getProperties().setProperty( property.name(), property.value() );\n\t\t}\n\n\t\tpui.getProperties().setProperty(\n\t\t\t\tAvailableSettings.GENERATE_STATISTICS,\n\t\t\t\tBoolean.toString( emfAnn.generateStatistics() )\n\t\t);\n\n\t\tif ( emfAnn.exportSchema() ) {\n\t\t\tpui.getProperties().setProperty(\n\t\t\t\t\tAvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,\n\t\t\t\t\tAction.CREATE_DROP.getExternalHbm2ddlName()\n\t\t\t);\n\t\t}\n\n\t\tif ( emfAnn.annotatedPackageNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( emfAnn.annotatedPackageNames() );\n\t\t}\n\n\t\tif ( emfAnn.annotatedClassNames().length > 0 ) {\n\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClassNames() );\n\t\t}\n\n\t\tif ( emfAnn.annotatedClasses().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.annotatedClasses().length; i++ ) {\n\t\t\t\tpui.applyManagedClassNames( emfAnn.annotatedClasses()[i].getName() );\n\t\t\t}\n\t\t}\n\n\t\tif ( emfAnn.xmlMappings().length > 0 ) {\n\t\t\tpui.applyMappingFiles( emfAnn.xmlMappings() );\n\t\t}\n\n\t\tif ( emfAnn.standardModels().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.standardModels().length; i++ ) {\n\t\t\t\tfinal StandardDomainModel standardDomainModel = emfAnn.standardModels()[i];\n\t\t\t\tfor ( int i1 = 0; i1 < standardDomainModel.getDescriptor().getAnnotatedClasses().length; i1++ ) {\n\t\t\t\t\tfinal Class<?> annotatedClass = standardDomainModel.getDescriptor().getAnnotatedClasses()[i1];\n\t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( emfAnn.modelDescriptorClasses().length > 0 ) {\n\t\t\tfor ( int i = 0; i < emfAnn.modelDescriptorClasses().length; i++ ) {\n\t\t\t\tfinal Class<? extends DomainModelDescriptor> modelDescriptorClass = emfAnn.modelDescriptorClasses()[i];\n\t\t\t\tfinal DomainModelDescriptor domainModelDescriptor = instantiateDomainModelDescriptor(\n\t\t\t\t\t\tmodelDescriptorClass );\n\t\t\t\tfor ( int i1 = 0; i1 < domainModelDescriptor.getAnnotatedClasses().length; i1++ ) {\n\t\t\t\t\tfinal Class<?> annotatedClass = domainModelDescriptor.getAnnotatedClasses()[i1];\n\t\t\t\t\tpui.applyManagedClassNames( annotatedClass.getName() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfinal Map<String, Object> integrationSettings = new HashMap<>();\n\n\t\tintegrationSettings.put( PersistentTableStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( GlobalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tintegrationSettings.put( LocalTemporaryTableMutationStrategy.DROP_ID_TABLES, \"true\" );\n\t\tfor ( int i = 0; i < emfAnn.integrationSettings().length; i++ ) {\n\t\t\tfinal Setting setting = emfAnn.integrationSettings()[i];\n\t\t\tintegrationSettings.put( setting.name(), setting.value() );\n\t\t}\n\n\t\tfor ( SettingProvider providerAnn : emfAnn.settingProviders() ) {\n\t\t\tfinal Class<? extends SettingProvider.Provider<?>> providerImpl = providerAnn.provider();\n\t\t\ttry {\n\t\t\t\tfinal SettingProvider.Provider<?> provider = providerImpl.getConstructor().newInstance();\n\t\t\t\tintegrationSettings.put( providerAnn.settingName(), provider.getSetting() );\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tlog.error( \"Error obtaining setting provider for \" + providerImpl.getName(), e );\n\t\t\t}\n\t\t}\n\n\t\t// statement inspector\n\t\tif ( emfAnn.useCollectingStatementInspector() ) {\n\t\t\tString inspectorSetting = (String) integrationSettings.get( AvailableSettings.STATEMENT_INSPECTOR );\n\t\t\tif ( !(inspectorSetting == null || inspectorSetting.isBlank()) ) {\n\t\t\t\tlog.warn( String.format( \"Overriding the explicit \\\"%1s\\\" statement inspector setting\", inspectorSetting ) );\n\t\t\t}\n\t\t\tintegrationSettings.put( AvailableSettings.STATEMENT_INSPECTOR, new SQLStatementInspector() );\n\t\t}\n\n\t\tServiceRegistryUtil.applySettings( integrationSettings );\n\t\tfinal EntityManagerFactoryScopeImpl scope = new EntityManagerFactoryScopeImpl( pui, integrationSettings );\n\n\t\tstore.put( EMF_KEY, scope );\n\n\t\treturn scope;\n\t}\n\n\tprivate static DomainModelDescriptor instantiateDomainModelDescriptor(Class<? extends DomainModelDescriptor> modelDescriptorClass) {\n\t\t// first, see if it has a static singleton reference and use that if so\n\t\ttry {\n\t\t\tfinal Field[] declaredFields = modelDescriptorClass.getDeclaredFields();\n\t\t\tfor ( int i = 0; i < declaredFields.length; i++ ) {\n\t\t\t\tfinal Field field = declaredFields[i];\n\t\t\t\tif ( ReflectHelper.isStaticField( field ) ) {\n\t\t\t\t\tfinal Object value = field.get( null );\n\t\t\t\t\tif ( value instanceof DomainModelDescriptor ) {\n\t\t\t\t\t\treturn (DomainModelDescriptor) value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IllegalAccessException e) {\n\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\"Problem accessing DomainModelDescriptor fields : \" + modelDescriptorClass.getName(),\n\t\t\t\t\te\n\t\t\t);\n\t\t}\n\n\t\t// no singleton field, try to instantiate it via reflection\n\t\ttry {\n\t\t\treturn modelDescriptorClass.getConstructor( null ).newInstance( null );\n\t\t}\n\t\tcatch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {\n\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\"Problem instantiation DomainModelDescriptor : \" + modelDescriptorClass.getName(),\n\t\t\t\t\te\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate static void prepareSchemaExport(\n\t\t\tSessionFactoryImplementor sessionFactory,\n\t\t\tMetadataImplementor model) {\n\t\tfinal Map<String, Object> baseProperties = sessionFactory.getProperties();\n\n\t\tfinal Set<ActionGrouping> groupings = ActionGrouping.interpret( model, baseProperties );\n\t\tif ( !groupings.isEmpty() ) {\n\t\t\t// the properties contained explicit settings for auto schema tooling - skip the annotation\n\t\t\treturn;\n\t\t}\n\n\t\tfinal HashMap<String,Object> settings = new HashMap<>( baseProperties );\n\t\tsettings.put( AvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION, Action.CREATE_DROP );\n\n\t\tfinal StandardServiceRegistry serviceRegistry = model.getMetadataBuildingOptions().getServiceRegistry();\n\n\n\t\tSchemaManagementToolCoordinator.process(\n\t\t\t\tmodel,\n\t\t\t\tserviceRegistry,\n\t\t\t\tsettings,\n\t\t\t\taction -> sessionFactory.addObserver(\n\t\t\t\t\t\tnew SessionFactoryObserver() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void sessionFactoryClosing(org.hibernate.SessionFactory factory) {\n\t\t\t\t\t\t\t\taction.perform( serviceRegistry );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t)\n\t\t);\n\t}\n\n\t@Override\n\tpublic void beforeEach(ExtensionContext context) {\n\t\tlog.tracef( \"#beforeEach(%s)\", context.getDisplayName() );\n\t\tfinal Optional<Jpa> emfAnnWrapper = AnnotationSupport.findAnnotation(\n\t\t\t\tcontext.getRequiredTestMethod(),\n\t\t\t\tJpa.class\n\t\t);\n\n\t\tif ( emfAnnWrapper.isEmpty() ) {\n\t\t\t// assume the annotation is defined on the class-level...\n\t\t\treturn;\n\t\t}\n\n\t\tfindEntityManagerFactoryScope( context.getRequiredTestMethod(), emfAnnWrapper, context );\n\t}\n\n\t@Override\n\tpublic void postProcessTestInstance(Object testInstance, ExtensionContext context) {\n\t\tlog.tracef( \"#postProcessTestInstance(%s, %s)\", testInstance, context.getDisplayName() );\n\n\t\tfinal Optional<Jpa> emfAnnWrapper = AnnotationSupport.findAnnotation(\n\t\t\t\tcontext.getRequiredTestClass(),\n\t\t\t\tJpa.class\n\t\t);\n\n\t\tfindEntityManagerFactoryScope( testInstance, emfAnnWrapper, context );\n\t}\n\n\t@Override\n\tpublic void handleTestExecutionException(ExtensionContext context, Throwable throwable) throws Throwable {\n\t\tlog.tracef( \"#handleTestExecutionException(%s, %s)\", context.getDisplayName(), throwable );\n\n\t\ttry {\n\t\t\tfinal Object testInstance = context.getRequiredTestInstance();\n\t\t\tfinal ExtensionContext.Store store = locateExtensionStore( testInstance, context );\n\t\t\tfinal EntityManagerFactoryScopeImpl scope = (EntityManagerFactoryScopeImpl) store.get( EMF_KEY );\n\t\t\tscope.releaseEntityManagerFactory();\n\t\t}\n\t\tcatch (Exception ignore) {\n\t\t}\n\n\t\tthrow throwable;\n\t}\n\n\tprivate static class EntityManagerFactoryScopeImpl extends AbstractEntityManagerFactoryScope {\n\t\tprivate final PersistenceUnitInfo persistenceUnitInfo;\n\t\tprivate final Map<String, Object> integrationSettings;\n\n\t\tprivate EntityManagerFactoryScopeImpl(\n\t\t\t\tPersistenceUnitInfo persistenceUnitInfo,\n\t\t\t\tMap<String, Object> integrationSettings) {\n\t\t\tthis.persistenceUnitInfo = persistenceUnitInfo;\n\t\t\tthis.integrationSettings = integrationSettings;\n\t\t}\n\n\t\tprotected jakarta.persistence.EntityManagerFactory createEntityManagerFactory() {\n\t\t\tfinal EntityManagerFactoryBuilder emfBuilder = Bootstrap.getEntityManagerFactoryBuilder(\n\t\t\t\t\tnew PersistenceUnitInfoDescriptor( persistenceUnitInfo ),\n\t\t\t\t\tintegrationSettings\n\t\t\t);\n\n\t\t\treturn emfBuilder.build();\n\t\t}\n\t}\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate canRollBack(sessionImplementor SessionImplementor) : boolean extracted from private completeStrayTransaction() : void in class org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/exceptionhandling/BaseJpaOrNativeBootstrapFunctionalTestCase.java",
                "startLine": 361,
                "endLine": 384,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/exceptionhandling/BaseJpaOrNativeBootstrapFunctionalTestCase.java",
                "startLine": 352,
                "endLine": 374,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/test/java/org/hibernate/orm/test/exceptionhandling/BaseJpaOrNativeBootstrapFunctionalTestCase.java",
                "startLine": 376,
                "endLine": 379,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private void completeStrayTransaction() {\n\t\tif ( session == null ) {\n\t\t\t// nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif ( ( (SessionImplementor) session ).isClosed() ) {\n\t\t\t// nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !session.isConnected() ) {\n\t\t\t// nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tfinal TransactionCoordinator.TransactionDriver tdc =\n\t\t\t\t( (SessionImplementor) session ).getTransactionCoordinator().getTransactionDriverControl();\n\n\t\tif ( tdc.getStatus().canRollback() ) {\n\t\t\tsession.getTransaction().rollback();\n\t\t}\n\t\tsession.close();\n\t}",
        "filePathBefore": "hibernate-core/src/test/java/org/hibernate/orm/test/exceptionhandling/BaseJpaOrNativeBootstrapFunctionalTestCase.java",
        "isPureRefactoring": true,
        "commitId": "4781c09d0df0eb4ce05b2fa0d2a12747023ae024",
        "packageNameBefore": "org.hibernate.orm.test.exceptionhandling",
        "classNameBefore": "org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase",
        "methodNameBefore": "org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase#completeStrayTransaction",
        "invokedMethod": "methodSignature: org.hibernate.internal.SessionFactoryImpl#isClosed\n methodBody: public boolean isClosed() {\nreturn status == Status.CLOSED;\n}\nmethodSignature: org.hibernate.internal.SessionFactoryImpl#close\n methodBody: public void close() throws HibernateException {\nsynchronized(this){if(status != Status.OPEN){if(getSessionFactoryOptions().getJpaCompliance().isJpaClosedComplianceEnabled()){throw new IllegalStateException(\"EntityManagerFactory is already closed\");\n}LOG.trace(\"Already closed\");\nreturn;\n}status=Status.CLOSING;\n}tryLOG.closing();\nobserver.sessionFactoryClosing(this);\nif(cacheAccess != null){cacheAccess.close();\n}if(runtimeMetamodels != null && runtimeMetamodels.getMappingMetamodel() != null){final JdbcConnectionAccess jdbcConnectionAccess=jdbcServices.getBootstrapJdbcConnectionAccess();\nruntimeMetamodels.getMappingMetamodel().forEachEntityDescriptor(entityPersister -> {\n  if (entityPersister.getSqmMultiTableMutationStrategy() != null) {\n    entityPersister.getSqmMultiTableMutationStrategy().release(this,jdbcConnectionAccess);\n  }\n  if (entityPersister.getSqmMultiTableInsertStrategy() != null) {\n    entityPersister.getSqmMultiTableInsertStrategy().release(this,jdbcConnectionAccess);\n  }\n}\n);\n((MappingMetamodelImpl)runtimeMetamodels.getMappingMetamodel()).close();\n}if(queryEngine != null){queryEngine.close();\n}if(eventEngine != null){eventEngine.stop();\n}finallystatus=Status.CLOSED;\nobserver.sessionFactoryClosed(this);\nserviceRegistry.destroy();\n}",
        "classSignatureBefore": "public abstract class BaseJpaOrNativeBootstrapFunctionalTestCase extends BaseUnitTestCase ",
        "methodNameBeforeSet": [
            "org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase#completeStrayTransaction"
        ],
        "classNameBeforeSet": [
            "org.hibernate.orm.test.exceptionhandling.BaseJpaOrNativeBootstrapFunctionalTestCase"
        ],
        "classSignatureBeforeSet": [
            "public abstract class BaseJpaOrNativeBootstrapFunctionalTestCase extends BaseUnitTestCase "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Overlapped refactoring - can be identical by undoing the overlapped refactoring\n- Inline Variable-",
                "description": "Inline Variable on top of the extracted method - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.orm.test.exceptionhandling;\n\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.Interceptor;\nimport org.hibernate.Session;\nimport org.hibernate.boot.registry.BootstrapServiceRegistry;\nimport org.hibernate.boot.registry.BootstrapServiceRegistryBuilder;\nimport org.hibernate.boot.registry.StandardServiceRegistryBuilder;\nimport org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;\nimport org.hibernate.bytecode.enhance.spi.EnhancementContext;\nimport org.hibernate.bytecode.spi.ClassTransformer;\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.cfg.Configuration;\nimport org.hibernate.cfg.Environment;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.engine.spi.SessionImplementor;\nimport org.hibernate.internal.util.PropertiesHelper;\nimport org.hibernate.internal.util.config.ConfigurationHelper;\nimport org.hibernate.jpa.HibernatePersistenceProvider;\nimport org.hibernate.jpa.boot.spi.Bootstrap;\nimport org.hibernate.jpa.boot.spi.PersistenceUnitDescriptor;\nimport org.hibernate.resource.transaction.spi.TransactionCoordinator;\n\nimport org.hibernate.testing.AfterClassOnce;\nimport org.hibernate.testing.BeforeClassOnce;\nimport org.hibernate.testing.cache.CachingRegionFactory;\nimport org.hibernate.testing.junit4.BaseUnitTestCase;\nimport org.hibernate.testing.orm.junit.DialectContext;\nimport org.hibernate.testing.util.ServiceRegistryUtil;\nimport org.junit.After;\n\nimport jakarta.persistence.EntityManager;\nimport jakarta.persistence.SharedCacheMode;\nimport jakarta.persistence.ValidationMode;\nimport jakarta.persistence.spi.PersistenceUnitTransactionType;\n\nimport static org.junit.Assert.fail;\n\n/**\n * A base class for all functional tests.\n */\npublic abstract class BaseJpaOrNativeBootstrapFunctionalTestCase extends BaseUnitTestCase {\n\n\t// IMPL NOTE : Here we use @Before and @After (instead of @BeforeClassOnce and @AfterClassOnce like we do in\n\t// BaseCoreFunctionalTestCase) because the old HEM test methodology was to create an EMF for each test method.\n\n\tprivate static final Dialect dialect = DialectContext.getDialect();\n\n\tpublic enum BootstrapMethod {\n\t\tJPA,\n\t\tNATIVE\n\t}\n\n\tprivate final BootstrapMethod bootstrapMethod;\n\n\tprivate StandardServiceRegistryImpl serviceRegistry;\n\tprivate SessionFactoryImplementor sessionFactory;\n\n\tprivate Session session;\n\n\tprotected Dialect getDialect() {\n\t\treturn dialect;\n\t}\n\n\tprotected SessionFactoryImplementor sessionFactory() {\n\t\treturn sessionFactory;\n\t}\n\n\tprotected StandardServiceRegistryImpl serviceRegistry() {\n\t\treturn serviceRegistry;\n\t}\n\n\tprotected Session openSession() throws HibernateException {\n\t\tsession = sessionFactory().openSession();\n\t\treturn session;\n\t}\n\n\tprotected Session openSession(Interceptor interceptor) throws HibernateException {\n\t\tsession = sessionFactory().withOptions().interceptor( interceptor ).openSession();\n\t\treturn session;\n\t}\n\n\tprotected EntityManager openEntityManager() throws HibernateException {\n\t\treturn openSession().unwrap( EntityManager.class );\n\t}\n\n\tprotected BaseJpaOrNativeBootstrapFunctionalTestCase(BootstrapMethod bootstrapMethod) {\n\t\tthis.bootstrapMethod = bootstrapMethod;\n\t}\n\n\t@BeforeClassOnce\n\t@SuppressWarnings( {\"UnusedDeclaration\"})\n\tpublic void buildSessionOrEntityManagerFactory() {\n\t\tswitch ( bootstrapMethod ) {\n\t\t\tcase JPA:\n\t\t\t\tbuildEntityManagerFactory();\n\t\t\t\tbreak;\n\t\t\tcase NATIVE:\n\t\t\t\tbuildSessionFactory();\n\t\t\t\tbreak;\n\t\t}\n\n\t\tafterSessionOrEntityManagerFactoryBuilt();\n\t}\n\n\tprivate void buildEntityManagerFactory() {\n\t\tlog.trace( \"Building EntityManagerFactory\" );\n\n\t\tProperties properties = buildProperties();\n\t\tArrayList<Class> classes = new ArrayList<Class>();\n\n\t\tclasses.addAll( Arrays.asList( getAnnotatedClasses() ) );\n\t\tproperties.put( org.hibernate.cfg.AvailableSettings.LOADED_CLASSES, classes );\n\t\tServiceRegistryUtil.applySettings( properties );\n\n\t\tsessionFactory =  Bootstrap.getEntityManagerFactoryBuilder(\n\t\t\t\tbuildPersistenceUnitDescriptor(),\n\t\t\t\tproperties\n\t\t).build().unwrap( SessionFactoryImplementor.class );\n\n\t\tserviceRegistry = (StandardServiceRegistryImpl) sessionFactory.getServiceRegistry()\n\t\t\t\t.getParentServiceRegistry();\n\t}\n\n\tprivate void buildSessionFactory() {\n\t\t// for now, build the configuration to get all the property settings\n\t\tConfiguration configuration = new Configuration();\n\t\tconfiguration.setProperties( buildProperties() );\n\n\t\tClass<?>[] annotatedClasses = getAnnotatedClasses();\n\t\tif ( annotatedClasses != null ) {\n\t\t\tfor ( Class<?> annotatedClass : annotatedClasses ) {\n\t\t\t\tconfiguration.addAnnotatedClass( annotatedClass );\n\t\t\t}\n\t\t}\n\n\t\tBootstrapServiceRegistry bootRegistry = buildBootstrapServiceRegistry();\n\t\tserviceRegistry = buildServiceRegistry( bootRegistry, configuration );\n\t\tsessionFactory = ( SessionFactoryImplementor ) configuration.buildSessionFactory( serviceRegistry );\n\n\t\tafterSessionOrEntityManagerFactoryBuilt();\n\t}\n\n\n\tprivate PersistenceUnitDescriptor buildPersistenceUnitDescriptor() {\n\t\treturn new TestingPersistenceUnitDescriptorImpl( getClass().getSimpleName() );\n\t}\n\n\tpublic static class TestingPersistenceUnitDescriptorImpl implements PersistenceUnitDescriptor {\n\t\tprivate final String name;\n\n\t\tpublic TestingPersistenceUnitDescriptorImpl(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\t@Override\n\t\tpublic URL getPersistenceUnitRootUrl() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getName() {\n\t\t\treturn name;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getProviderClassName() {\n\t\t\treturn HibernatePersistenceProvider.class.getName();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isUseQuotedIdentifiers() {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isExcludeUnlistedClasses() {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic PersistenceUnitTransactionType getTransactionType() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic ValidationMode getValidationMode() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic SharedCacheMode getSharedCacheMode() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> getManagedClassNames() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> getMappingFileNames() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<URL> getJarFileUrls() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getNonJtaDataSource() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getJtaDataSource() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic Properties getProperties() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic ClassLoader getClassLoader() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic ClassLoader getTempClassLoader() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pushClassTransformer(EnhancementContext enhancementContext) {\n\t\t}\n\n\t\t@Override\n\t\tpublic ClassTransformer getClassTransformer() {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate BootstrapServiceRegistry buildBootstrapServiceRegistry() {\n\t\tfinal BootstrapServiceRegistryBuilder builder = new BootstrapServiceRegistryBuilder();\n\t\tbuilder.applyClassLoader( getClass().getClassLoader() );\n\t\tprepareBootstrapRegistryBuilder( builder );\n\t\treturn builder.build();\n\t}\n\n\tprotected void prepareBootstrapRegistryBuilder(BootstrapServiceRegistryBuilder builder) {\n\t}\n\n\tprivate StandardServiceRegistryImpl buildServiceRegistry(BootstrapServiceRegistry bootRegistry, Configuration configuration) {\n\t\tProperties properties = new Properties();\n\t\tproperties.putAll( configuration.getProperties() );\n\t\tConfigurationHelper.resolvePlaceHolders( properties );\n\n\t\tStandardServiceRegistryBuilder cfgRegistryBuilder = configuration.getStandardServiceRegistryBuilder();\n\n\t\tStandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder( bootRegistry, cfgRegistryBuilder.getAggregatedCfgXml() )\n\t\t\t\t.applySettings( properties );\n\t\tServiceRegistryUtil.applySettings( registryBuilder );\n\n\t\treturn (StandardServiceRegistryImpl) registryBuilder.build();\n\t}\n\n\tprivate Properties buildProperties() {\n\t\tProperties properties = Environment.getProperties();\n\n\t\tproperties.put( AvailableSettings.CACHE_REGION_FACTORY, CachingRegionFactory.class.getName() );\n\t\tfor ( Map.Entry<Class, String> entry : getCachedClasses().entrySet() ) {\n\t\t\tproperties.put( AvailableSettings.CLASS_CACHE_PREFIX + \".\" + entry.getKey().getName(), entry.getValue() );\n\t\t}\n\t\tfor ( Map.Entry<String, String> entry : getCachedCollections().entrySet() ) {\n\t\t\tproperties.put( AvailableSettings.COLLECTION_CACHE_PREFIX + \".\" + entry.getKey(), entry.getValue() );\n\t\t}\n\n\t\tconfigure( PropertiesHelper.map( properties ) );\n\n\t\tif ( createSchema() ) {\n\t\t\tproperties.put( AvailableSettings.HBM2DDL_AUTO, \"create-drop\" );\n\t\t}\n\t\tproperties.put( AvailableSettings.DIALECT, getDialect().getClass().getName() );\n\n\t\treturn properties;\n\t}\n\n\tprotected void configure(Map<String, Object> properties) {\n\t}\n\n\tprotected static final Class<?>[] NO_CLASSES = new Class[0];\n\n\tprotected Class<?>[] getAnnotatedClasses() {\n\t\treturn NO_CLASSES;\n\t}\n\n\tpublic Map<Class, String> getCachedClasses() {\n\t\treturn new HashMap<>();\n\t}\n\n\tpublic Map<String, String> getCachedCollections() {\n\t\treturn new HashMap<>();\n\t}\n\n\tprotected void afterSessionOrEntityManagerFactoryBuilt() {\n\t}\n\n\tprotected boolean createSchema() {\n\t\treturn true;\n\t}\n\n\t@After\n\tpublic final void afterTest() throws Exception {\n\t\tcompleteStrayTransaction();\n\n\t\tcleanupSession();\n\n\t}\n\n\t@AfterClassOnce\n\t@SuppressWarnings( {\"UnusedDeclaration\"})\n\tprotected void releaseSessionFactory() {\n\t\tif ( sessionFactory == null ) {\n\t\t\treturn;\n\t\t}\n\t\tsessionFactory.close();\n\t\tsessionFactory = null;\n\t\tif ( serviceRegistry != null ) {\n\t\t\tif ( serviceRegistry.isActive() ) {\n\t\t\t\ttry {\n\t\t\t\t\tserviceRegistry.destroy();\n\t\t\t\t}\n\t\t\t\tcatch (Exception ignore) {\n\t\t\t\t}\n\t\t\t\tfail( \"StandardServiceRegistry was not closed down as expected\" );\n\t\t\t}\n\t\t}\n\t\tserviceRegistry=null;\n\t}\n\n\tprivate void completeStrayTransaction() {\n\t\tif ( session == null ) {\n\t\t\t// nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif ( ( (SessionImplementor) session ).isClosed() ) {\n\t\t\t// nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !session.isConnected() ) {\n\t\t\t// nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tfinal TransactionCoordinator.TransactionDriver tdc =\n\t\t\t\t( (SessionImplementor) session ).getTransactionCoordinator().getTransactionDriverControl();\n\n\t\tif ( tdc.getStatus().canRollback() ) {\n\t\t\tsession.getTransaction().rollback();\n\t\t}\n\t\tsession.close();\n\t}\n\n\tprivate void cleanupSession() {\n\t\tif ( session != null && ! ( (SessionImplementor) session ).isClosed() ) {\n\t\t\tsession.close();\n\t\t}\n\t\tsession = null;\n\t}\n}\n",
        "filePathAfter": "hibernate-core/src/test/java/org/hibernate/orm/test/exceptionhandling/BaseJpaOrNativeBootstrapFunctionalTestCase.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.orm.test.exceptionhandling;\n\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.Interceptor;\nimport org.hibernate.Session;\nimport org.hibernate.boot.cfgxml.spi.LoadedConfig;\nimport org.hibernate.boot.registry.BootstrapServiceRegistry;\nimport org.hibernate.boot.registry.BootstrapServiceRegistryBuilder;\nimport org.hibernate.boot.registry.StandardServiceRegistryBuilder;\nimport org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;\nimport org.hibernate.bytecode.enhance.spi.EnhancementContext;\nimport org.hibernate.bytecode.spi.ClassTransformer;\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.cfg.Configuration;\nimport org.hibernate.cfg.Environment;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.engine.spi.SessionImplementor;\nimport org.hibernate.internal.util.PropertiesHelper;\nimport org.hibernate.jpa.HibernatePersistenceProvider;\nimport org.hibernate.jpa.boot.spi.PersistenceUnitDescriptor;\n\nimport org.hibernate.testing.AfterClassOnce;\nimport org.hibernate.testing.BeforeClassOnce;\nimport org.hibernate.testing.cache.CachingRegionFactory;\nimport org.hibernate.testing.junit4.BaseUnitTestCase;\nimport org.hibernate.testing.orm.junit.DialectContext;\nimport org.hibernate.testing.util.ServiceRegistryUtil;\nimport org.junit.After;\n\nimport jakarta.persistence.EntityManager;\nimport jakarta.persistence.SharedCacheMode;\nimport jakarta.persistence.ValidationMode;\nimport jakarta.persistence.PersistenceUnitTransactionType;\n\nimport static org.hibernate.internal.util.config.ConfigurationHelper.resolvePlaceHolders;\nimport static org.hibernate.jpa.boot.spi.Bootstrap.getEntityManagerFactoryBuilder;\nimport static org.junit.Assert.fail;\n\n/**\n * A base class for all functional tests.\n */\npublic abstract class BaseJpaOrNativeBootstrapFunctionalTestCase extends BaseUnitTestCase {\n\n\t// IMPL NOTE : Here we use @Before and @After (instead of @BeforeClassOnce and @AfterClassOnce like we do in\n\t// BaseCoreFunctionalTestCase) because the old HEM test methodology was to create an EMF for each test method.\n\n\tprivate static final Dialect dialect = DialectContext.getDialect();\n\n\tpublic enum BootstrapMethod {\n\t\tJPA,\n\t\tNATIVE\n\t}\n\n\tprivate final BootstrapMethod bootstrapMethod;\n\n\tprivate StandardServiceRegistryImpl serviceRegistry;\n\tprivate SessionFactoryImplementor sessionFactory;\n\n\tprivate Session session;\n\n\tprotected Dialect getDialect() {\n\t\treturn dialect;\n\t}\n\n\tprotected SessionFactoryImplementor sessionFactory() {\n\t\treturn sessionFactory;\n\t}\n\n\tprotected StandardServiceRegistryImpl serviceRegistry() {\n\t\treturn serviceRegistry;\n\t}\n\n\tprotected Session openSession() throws HibernateException {\n\t\tsession = sessionFactory().openSession();\n\t\treturn session;\n\t}\n\n\tprotected Session openSession(Interceptor interceptor) throws HibernateException {\n\t\tsession = sessionFactory().withOptions().interceptor( interceptor ).openSession();\n\t\treturn session;\n\t}\n\n\tprotected EntityManager openEntityManager() throws HibernateException {\n\t\treturn openSession().unwrap( EntityManager.class );\n\t}\n\n\tprotected BaseJpaOrNativeBootstrapFunctionalTestCase(BootstrapMethod bootstrapMethod) {\n\t\tthis.bootstrapMethod = bootstrapMethod;\n\t}\n\n\t@BeforeClassOnce\n\tpublic void buildSessionOrEntityManagerFactory() {\n\t\tswitch ( bootstrapMethod ) {\n\t\t\tcase JPA:\n\t\t\t\tbuildEntityManagerFactory();\n\t\t\t\tbreak;\n\t\t\tcase NATIVE:\n\t\t\t\tbuildSessionFactory();\n\t\t\t\tbreak;\n\t\t}\n\t\tafterSessionOrEntityManagerFactoryBuilt();\n\t}\n\n\tprivate void buildEntityManagerFactory() {\n\t\tlog.trace( \"Building EntityManagerFactory\" );\n\n\t\tfinal Properties properties = buildProperties();\n\t\tproperties.put( AvailableSettings.LOADED_CLASSES, List.of( getAnnotatedClasses() ) );\n\t\tServiceRegistryUtil.applySettings( properties );\n\n\t\tsessionFactory =\n\t\t\t\tgetEntityManagerFactoryBuilder( buildPersistenceUnitDescriptor(), properties )\n\t\t\t\t\t\t.build().unwrap( SessionFactoryImplementor.class );\n\n\t\tserviceRegistry = (StandardServiceRegistryImpl)\n\t\t\t\tsessionFactory.getServiceRegistry().getParentServiceRegistry();\n\t}\n\n\tprivate void buildSessionFactory() {\n\t\t// for now, build the configuration to get all the property settings\n\t\tfinal Configuration configuration = new Configuration();\n\t\tconfiguration.setProperties( buildProperties() );\n\n\t\tfinal Class<?>[] annotatedClasses = getAnnotatedClasses();\n\t\tif ( annotatedClasses != null ) {\n\t\t\tfor ( Class<?> annotatedClass : annotatedClasses ) {\n\t\t\t\tconfiguration.addAnnotatedClass( annotatedClass );\n\t\t\t}\n\t\t}\n\n\t\tserviceRegistry = buildServiceRegistry( buildBootstrapServiceRegistry(), configuration );\n\t\tsessionFactory = (SessionFactoryImplementor) configuration.buildSessionFactory( serviceRegistry );\n\n\t\tafterSessionOrEntityManagerFactoryBuilt();\n\t}\n\n\n\tprivate PersistenceUnitDescriptor buildPersistenceUnitDescriptor() {\n\t\treturn new TestingPersistenceUnitDescriptorImpl( getClass().getSimpleName() );\n\t}\n\n\tpublic static class TestingPersistenceUnitDescriptorImpl implements PersistenceUnitDescriptor {\n\t\tprivate final String name;\n\n\t\tpublic TestingPersistenceUnitDescriptorImpl(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\t@Override\n\t\tpublic URL getPersistenceUnitRootUrl() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getName() {\n\t\t\treturn name;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getProviderClassName() {\n\t\t\treturn HibernatePersistenceProvider.class.getName();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isUseQuotedIdentifiers() {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isExcludeUnlistedClasses() {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic PersistenceUnitTransactionType getPersistenceUnitTransactionType() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override @SuppressWarnings(\"removal\")\n\t\tpublic jakarta.persistence.spi.PersistenceUnitTransactionType getTransactionType() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic ValidationMode getValidationMode() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic SharedCacheMode getSharedCacheMode() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> getManagedClassNames() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> getMappingFileNames() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<URL> getJarFileUrls() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getNonJtaDataSource() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getJtaDataSource() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic Properties getProperties() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic ClassLoader getClassLoader() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic ClassLoader getTempClassLoader() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pushClassTransformer(EnhancementContext enhancementContext) {\n\t\t}\n\n\t\t@Override\n\t\tpublic ClassTransformer getClassTransformer() {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate BootstrapServiceRegistry buildBootstrapServiceRegistry() {\n\t\tfinal BootstrapServiceRegistryBuilder builder = new BootstrapServiceRegistryBuilder();\n\t\tbuilder.applyClassLoader( getClass().getClassLoader() );\n\t\tprepareBootstrapRegistryBuilder( builder );\n\t\treturn builder.build();\n\t}\n\n\tprotected void prepareBootstrapRegistryBuilder(BootstrapServiceRegistryBuilder builder) {\n\t}\n\n\tprivate StandardServiceRegistryImpl buildServiceRegistry(\n\t\t\tBootstrapServiceRegistry bootRegistry, Configuration configuration) {\n\t\tfinal Properties properties = new Properties();\n\t\tproperties.putAll( configuration.getProperties() );\n\t\tresolvePlaceHolders( properties );\n\t\tfinal LoadedConfig loadedConfig =\n\t\t\t\tconfiguration.getStandardServiceRegistryBuilder().getAggregatedCfgXml();\n\t\tfinal StandardServiceRegistryBuilder registryBuilder =\n\t\t\t\tnew StandardServiceRegistryBuilder( bootRegistry, loadedConfig )\n\t\t\t\t\t\t.applySettings( properties );\n\t\tServiceRegistryUtil.applySettings( registryBuilder );\n\t\treturn (StandardServiceRegistryImpl) registryBuilder.build();\n\t}\n\n\tprivate Properties buildProperties() {\n\t\tfinal Properties properties = Environment.getProperties();\n\t\tproperties.put( AvailableSettings.CACHE_REGION_FACTORY, CachingRegionFactory.class.getName() );\n\t\tfor ( Map.Entry<Class<?>, String> entry : getCachedClasses().entrySet() ) {\n\t\t\tproperties.put( AvailableSettings.CLASS_CACHE_PREFIX + \".\" + entry.getKey().getName(), entry.getValue() );\n\t\t}\n\t\tfor ( Map.Entry<String, String> entry : getCachedCollections().entrySet() ) {\n\t\t\tproperties.put( AvailableSettings.COLLECTION_CACHE_PREFIX + \".\" + entry.getKey(), entry.getValue() );\n\t\t}\n\n\t\tconfigure( PropertiesHelper.map( properties ) );\n\n\t\tif ( createSchema() ) {\n\t\t\tproperties.put( AvailableSettings.HBM2DDL_AUTO, \"create-drop\" );\n\t\t}\n\t\tproperties.put( AvailableSettings.DIALECT, getDialect().getClass().getName() );\n\n\t\treturn properties;\n\t}\n\n\tprotected void configure(Map<String, Object> properties) {\n\t}\n\n\tprotected static final Class<?>[] NO_CLASSES = new Class[0];\n\n\tprotected Class<?>[] getAnnotatedClasses() {\n\t\treturn NO_CLASSES;\n\t}\n\n\tpublic Map<Class<?>, String> getCachedClasses() {\n\t\treturn new HashMap<>();\n\t}\n\n\tpublic Map<String, String> getCachedCollections() {\n\t\treturn new HashMap<>();\n\t}\n\n\tprotected void afterSessionOrEntityManagerFactoryBuilt() {\n\t}\n\n\tprotected boolean createSchema() {\n\t\treturn true;\n\t}\n\n\t@After\n\tpublic final void afterTest()  {\n\t\tcompleteStrayTransaction();\n\t\tcleanupSession();\n\t}\n\n\t@AfterClassOnce\n\t@SuppressWarnings(\"UnusedDeclaration\")\n\tprotected void releaseSessionFactory() {\n\t\tif ( sessionFactory == null ) {\n\t\t\treturn;\n\t\t}\n\t\tsessionFactory.close();\n\t\tsessionFactory = null;\n\t\tif ( serviceRegistry != null ) {\n\t\t\tif ( serviceRegistry.isActive() ) {\n\t\t\t\ttry {\n\t\t\t\t\tserviceRegistry.destroy();\n\t\t\t\t}\n\t\t\t\tcatch (Exception ignore) {\n\t\t\t\t}\n\t\t\t\tfail( \"StandardServiceRegistry was not closed down as expected\" );\n\t\t\t}\n\t\t}\n\t\tserviceRegistry=null;\n\t}\n\n\tprivate void completeStrayTransaction() {\n\t\tif ( session == null ) {\n\t\t\t// nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tfinal SessionImplementor sessionImplementor = (SessionImplementor) session;\n\n\t\tif ( sessionImplementor.isClosed() ) {\n\t\t\t// nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !session.isConnected() ) {\n\t\t\t// nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif ( canRollBack( sessionImplementor ) ) {\n\t\t\tsession.getTransaction().rollback();\n\t\t}\n\t\tsession.close();\n\t}\n\n\tprivate static boolean canRollBack(SessionImplementor sessionImplementor) {\n\t\treturn sessionImplementor.getTransactionCoordinator()\n\t\t\t\t.getTransactionDriverControl().getStatus().canRollback();\n\t}\n\n\tprivate void cleanupSession() {\n\t\tif ( session != null && ! ( (SessionImplementor) session ).isClosed() ) {\n\t\t\tsession.close();\n\t\t}\n\t\tsession = null;\n\t}\n}\n",
        "diffSourceCodeSet": [
            "private static boolean canRollBack(SessionImplementor sessionImplementor) {\n\t\treturn sessionImplementor.getTransactionCoordinator()\n\t\t\t\t.getTransactionDriverControl().getStatus().canRollback();\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.internal.SessionFactoryImpl#isClosed\n methodBody: public boolean isClosed() {\nreturn status == Status.CLOSED;\n}",
            "methodSignature: org.hibernate.internal.SessionFactoryImpl#close\n methodBody: public void close() throws HibernateException {\nsynchronized(this){if(status != Status.OPEN){if(getSessionFactoryOptions().getJpaCompliance().isJpaClosedComplianceEnabled()){throw new IllegalStateException(\"EntityManagerFactory is already closed\");\n}LOG.trace(\"Already closed\");\nreturn;\n}status=Status.CLOSING;\n}tryLOG.closing();\nobserver.sessionFactoryClosing(this);\nif(cacheAccess != null){cacheAccess.close();\n}if(runtimeMetamodels != null && runtimeMetamodels.getMappingMetamodel() != null){final JdbcConnectionAccess jdbcConnectionAccess=jdbcServices.getBootstrapJdbcConnectionAccess();\nruntimeMetamodels.getMappingMetamodel().forEachEntityDescriptor(entityPersister -> {\n  if (entityPersister.getSqmMultiTableMutationStrategy() != null) {\n    entityPersister.getSqmMultiTableMutationStrategy().release(this,jdbcConnectionAccess);\n  }\n  if (entityPersister.getSqmMultiTableInsertStrategy() != null) {\n    entityPersister.getSqmMultiTableInsertStrategy().release(this,jdbcConnectionAccess);\n  }\n}\n);\n((MappingMetamodelImpl)runtimeMetamodels.getMappingMetamodel()).close();\n}if(queryEngine != null){queryEngine.close();\n}if(eventEngine != null){eventEngine.stop();\n}finallystatus=Status.CLOSED;\nobserver.sessionFactoryClosed(this);\nserviceRegistry.destroy();\n}"
        ],
        "sourceCodeAfterRefactoring": "private void completeStrayTransaction() {\n\t\tif ( session == null ) {\n\t\t\t// nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tfinal SessionImplementor sessionImplementor = (SessionImplementor) session;\n\n\t\tif ( sessionImplementor.isClosed() ) {\n\t\t\t// nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !session.isConnected() ) {\n\t\t\t// nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif ( canRollBack( sessionImplementor ) ) {\n\t\t\tsession.getTransaction().rollback();\n\t\t}\n\t\tsession.close();\n\t}\nprivate static boolean canRollBack(SessionImplementor sessionImplementor) {\n\t\treturn sessionImplementor.getTransactionCoordinator()\n\t\t\t\t.getTransactionDriverControl().getStatus().canRollback();\n\t}",
        "diffSourceCode": "-  352: \t\t\t\t}\n-  353: \t\t\t\tcatch (Exception ignore) {\n-  354: \t\t\t\t}\n-  355: \t\t\t\tfail( \"StandardServiceRegistry was not closed down as expected\" );\n-  356: \t\t\t}\n-  357: \t\t}\n-  358: \t\tserviceRegistry=null;\n-  359: \t}\n-  360: \n-  361: \tprivate void completeStrayTransaction() {\n-  362: \t\tif ( session == null ) {\n-  363: \t\t\t// nothing to do\n-  364: \t\t\treturn;\n-  365: \t\t}\n-  366: \n-  367: \t\tif ( ( (SessionImplementor) session ).isClosed() ) {\n-  368: \t\t\t// nothing to do\n-  369: \t\t\treturn;\n-  370: \t\t}\n-  371: \n-  372: \t\tif ( !session.isConnected() ) {\n-  373: \t\t\t// nothing to do\n-  374: \t\t\treturn;\n-  375: \t\t}\n-  376: \n-  377: \t\tfinal TransactionCoordinator.TransactionDriver tdc =\n-  378: \t\t\t\t( (SessionImplementor) session ).getTransactionCoordinator().getTransactionDriverControl();\n-  379: \n-  380: \t\tif ( tdc.getStatus().canRollback() ) {\n-  381: \t\t\tsession.getTransaction().rollback();\n-  382: \t\t}\n-  383: \t\tsession.close();\n-  384: \t}\n+  352: \tprivate void completeStrayTransaction() {\n+  353: \t\tif ( session == null ) {\n+  354: \t\t\t// nothing to do\n+  355: \t\t\treturn;\n+  356: \t\t}\n+  357: \n+  358: \t\tfinal SessionImplementor sessionImplementor = (SessionImplementor) session;\n+  359: \n+  360: \t\tif ( sessionImplementor.isClosed() ) {\n+  361: \t\t\t// nothing to do\n+  362: \t\t\treturn;\n+  363: \t\t}\n+  364: \n+  365: \t\tif ( !session.isConnected() ) {\n+  366: \t\t\t// nothing to do\n+  367: \t\t\treturn;\n+  368: \t\t}\n+  369: \n+  370: \t\tif ( canRollBack( sessionImplementor ) ) {\n+  371: \t\t\tsession.getTransaction().rollback();\n+  372: \t\t}\n+  373: \t\tsession.close();\n+  374: \t}\n+  375: \n+  376: \tprivate static boolean canRollBack(SessionImplementor sessionImplementor) {\n+  377: \t\treturn sessionImplementor.getTransactionCoordinator()\n+  378: \t\t\t\t.getTransactionDriverControl().getStatus().canRollback();\n+  379: \t}\n+  380: \n+  381: \tprivate void cleanupSession() {\n+  382: \t\tif ( session != null && ! ( (SessionImplementor) session ).isClosed() ) {\n+  383: \t\t\tsession.close();\n+  384: \t\t}\n",
        "uniqueId": "4781c09d0df0eb4ce05b2fa0d2a12747023ae024_361_384_376_379_352_374",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "testMethod": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\nprivate void checkAndRollbackTransaction() {\n\t\tif (session == null || ((SessionImplementor) session).isClosed() || !session.isConnected()) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal TransactionCoordinator.TransactionDriver tdc =\n\t\t\t\t((SessionImplementor) session).getTransactionCoordinator().getTransactionDriverControl();\n\n\t\tif (tdc.getStatus().canRollback()) {\n\t\t\tsession.getTransaction().rollback();\n\t\t}\n\t\tsession.close();\n\t}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprivate void completeStrayTransaction() {\n\t\tif ( session == null ) {\n\t\t\t// nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif ( ( (SessionImplementor) session ).isClosed() ) {\n\t\t\t// nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !session.isConnected() ) {\n\t\t\t// nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tfinal TransactionCoordinator.TransactionDriver tdc =\n\t\t\t\t( (SessionImplementor) session ).getTransactionCoordinator().getTransactionDriverControl();\n\n\t\tif ( tdc.getStatus().canRollback() ) {\n\t\t\tsession.getTransaction().rollback();\n\t\t}\n\t\tsession.close();\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.orm.test.exceptionhandling;\n\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.Interceptor;\nimport org.hibernate.Session;\nimport org.hibernate.boot.registry.BootstrapServiceRegistry;\nimport org.hibernate.boot.registry.BootstrapServiceRegistryBuilder;\nimport org.hibernate.boot.registry.StandardServiceRegistryBuilder;\nimport org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;\nimport org.hibernate.bytecode.enhance.spi.EnhancementContext;\nimport org.hibernate.bytecode.spi.ClassTransformer;\nimport org.hibernate.cfg.AvailableSettings;\nimport org.hibernate.cfg.Configuration;\nimport org.hibernate.cfg.Environment;\nimport org.hibernate.dialect.Dialect;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.engine.spi.SessionImplementor;\nimport org.hibernate.internal.util.PropertiesHelper;\nimport org.hibernate.internal.util.config.ConfigurationHelper;\nimport org.hibernate.jpa.HibernatePersistenceProvider;\nimport org.hibernate.jpa.boot.spi.Bootstrap;\nimport org.hibernate.jpa.boot.spi.PersistenceUnitDescriptor;\nimport org.hibernate.resource.transaction.spi.TransactionCoordinator;\n\nimport org.hibernate.testing.AfterClassOnce;\nimport org.hibernate.testing.BeforeClassOnce;\nimport org.hibernate.testing.cache.CachingRegionFactory;\nimport org.hibernate.testing.junit4.BaseUnitTestCase;\nimport org.hibernate.testing.orm.junit.DialectContext;\nimport org.hibernate.testing.util.ServiceRegistryUtil;\nimport org.junit.After;\n\nimport jakarta.persistence.EntityManager;\nimport jakarta.persistence.SharedCacheMode;\nimport jakarta.persistence.ValidationMode;\nimport jakarta.persistence.spi.PersistenceUnitTransactionType;\n\nimport static org.junit.Assert.fail;\n\n/**\n * A base class for all functional tests.\n */\npublic abstract class BaseJpaOrNativeBootstrapFunctionalTestCase extends BaseUnitTestCase {\n\n\t// IMPL NOTE : Here we use @Before and @After (instead of @BeforeClassOnce and @AfterClassOnce like we do in\n\t// BaseCoreFunctionalTestCase) because the old HEM test methodology was to create an EMF for each test method.\n\n\tprivate static final Dialect dialect = DialectContext.getDialect();\n\n\tpublic enum BootstrapMethod {\n\t\tJPA,\n\t\tNATIVE\n\t}\n\n\tprivate final BootstrapMethod bootstrapMethod;\n\n\tprivate StandardServiceRegistryImpl serviceRegistry;\n\tprivate SessionFactoryImplementor sessionFactory;\n\n\tprivate Session session;\n\n\tprotected Dialect getDialect() {\n\t\treturn dialect;\n\t}\n\n\tprotected SessionFactoryImplementor sessionFactory() {\n\t\treturn sessionFactory;\n\t}\n\n\tprotected StandardServiceRegistryImpl serviceRegistry() {\n\t\treturn serviceRegistry;\n\t}\n\n\tprotected Session openSession() throws HibernateException {\n\t\tsession = sessionFactory().openSession();\n\t\treturn session;\n\t}\n\n\tprotected Session openSession(Interceptor interceptor) throws HibernateException {\n\t\tsession = sessionFactory().withOptions().interceptor( interceptor ).openSession();\n\t\treturn session;\n\t}\n\n\tprotected EntityManager openEntityManager() throws HibernateException {\n\t\treturn openSession().unwrap( EntityManager.class );\n\t}\n\n\tprotected BaseJpaOrNativeBootstrapFunctionalTestCase(BootstrapMethod bootstrapMethod) {\n\t\tthis.bootstrapMethod = bootstrapMethod;\n\t}\n\n\t@BeforeClassOnce\n\t@SuppressWarnings( {\"UnusedDeclaration\"})\n\tpublic void buildSessionOrEntityManagerFactory() {\n\t\tswitch ( bootstrapMethod ) {\n\t\t\tcase JPA:\n\t\t\t\tbuildEntityManagerFactory();\n\t\t\t\tbreak;\n\t\t\tcase NATIVE:\n\t\t\t\tbuildSessionFactory();\n\t\t\t\tbreak;\n\t\t}\n\n\t\tafterSessionOrEntityManagerFactoryBuilt();\n\t}\n\n\tprivate void buildEntityManagerFactory() {\n\t\tlog.trace( \"Building EntityManagerFactory\" );\n\n\t\tProperties properties = buildProperties();\n\t\tArrayList<Class> classes = new ArrayList<Class>();\n\n\t\tclasses.addAll( Arrays.asList( getAnnotatedClasses() ) );\n\t\tproperties.put( org.hibernate.cfg.AvailableSettings.LOADED_CLASSES, classes );\n\t\tServiceRegistryUtil.applySettings( properties );\n\n\t\tsessionFactory =  Bootstrap.getEntityManagerFactoryBuilder(\n\t\t\t\tbuildPersistenceUnitDescriptor(),\n\t\t\t\tproperties\n\t\t).build().unwrap( SessionFactoryImplementor.class );\n\n\t\tserviceRegistry = (StandardServiceRegistryImpl) sessionFactory.getServiceRegistry()\n\t\t\t\t.getParentServiceRegistry();\n\t}\n\n\tprivate void buildSessionFactory() {\n\t\t// for now, build the configuration to get all the property settings\n\t\tConfiguration configuration = new Configuration();\n\t\tconfiguration.setProperties( buildProperties() );\n\n\t\tClass<?>[] annotatedClasses = getAnnotatedClasses();\n\t\tif ( annotatedClasses != null ) {\n\t\t\tfor ( Class<?> annotatedClass : annotatedClasses ) {\n\t\t\t\tconfiguration.addAnnotatedClass( annotatedClass );\n\t\t\t}\n\t\t}\n\n\t\tBootstrapServiceRegistry bootRegistry = buildBootstrapServiceRegistry();\n\t\tserviceRegistry = buildServiceRegistry( bootRegistry, configuration );\n\t\tsessionFactory = ( SessionFactoryImplementor ) configuration.buildSessionFactory( serviceRegistry );\n\n\t\tafterSessionOrEntityManagerFactoryBuilt();\n\t}\n\n\n\tprivate PersistenceUnitDescriptor buildPersistenceUnitDescriptor() {\n\t\treturn new TestingPersistenceUnitDescriptorImpl( getClass().getSimpleName() );\n\t}\n\n\tpublic static class TestingPersistenceUnitDescriptorImpl implements PersistenceUnitDescriptor {\n\t\tprivate final String name;\n\n\t\tpublic TestingPersistenceUnitDescriptorImpl(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\n\t\t@Override\n\t\tpublic URL getPersistenceUnitRootUrl() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getName() {\n\t\t\treturn name;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getProviderClassName() {\n\t\t\treturn HibernatePersistenceProvider.class.getName();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isUseQuotedIdentifiers() {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isExcludeUnlistedClasses() {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic PersistenceUnitTransactionType getTransactionType() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic ValidationMode getValidationMode() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic SharedCacheMode getSharedCacheMode() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> getManagedClassNames() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<String> getMappingFileNames() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<URL> getJarFileUrls() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getNonJtaDataSource() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getJtaDataSource() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic Properties getProperties() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic ClassLoader getClassLoader() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic ClassLoader getTempClassLoader() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pushClassTransformer(EnhancementContext enhancementContext) {\n\t\t}\n\n\t\t@Override\n\t\tpublic ClassTransformer getClassTransformer() {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate BootstrapServiceRegistry buildBootstrapServiceRegistry() {\n\t\tfinal BootstrapServiceRegistryBuilder builder = new BootstrapServiceRegistryBuilder();\n\t\tbuilder.applyClassLoader( getClass().getClassLoader() );\n\t\tprepareBootstrapRegistryBuilder( builder );\n\t\treturn builder.build();\n\t}\n\n\tprotected void prepareBootstrapRegistryBuilder(BootstrapServiceRegistryBuilder builder) {\n\t}\n\n\tprivate StandardServiceRegistryImpl buildServiceRegistry(BootstrapServiceRegistry bootRegistry, Configuration configuration) {\n\t\tProperties properties = new Properties();\n\t\tproperties.putAll( configuration.getProperties() );\n\t\tConfigurationHelper.resolvePlaceHolders( properties );\n\n\t\tStandardServiceRegistryBuilder cfgRegistryBuilder = configuration.getStandardServiceRegistryBuilder();\n\n\t\tStandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder( bootRegistry, cfgRegistryBuilder.getAggregatedCfgXml() )\n\t\t\t\t.applySettings( properties );\n\t\tServiceRegistryUtil.applySettings( registryBuilder );\n\n\t\treturn (StandardServiceRegistryImpl) registryBuilder.build();\n\t}\n\n\tprivate Properties buildProperties() {\n\t\tProperties properties = Environment.getProperties();\n\n\t\tproperties.put( AvailableSettings.CACHE_REGION_FACTORY, CachingRegionFactory.class.getName() );\n\t\tfor ( Map.Entry<Class, String> entry : getCachedClasses().entrySet() ) {\n\t\t\tproperties.put( AvailableSettings.CLASS_CACHE_PREFIX + \".\" + entry.getKey().getName(), entry.getValue() );\n\t\t}\n\t\tfor ( Map.Entry<String, String> entry : getCachedCollections().entrySet() ) {\n\t\t\tproperties.put( AvailableSettings.COLLECTION_CACHE_PREFIX + \".\" + entry.getKey(), entry.getValue() );\n\t\t}\n\n\t\tconfigure( PropertiesHelper.map( properties ) );\n\n\t\tif ( createSchema() ) {\n\t\t\tproperties.put( AvailableSettings.HBM2DDL_AUTO, \"create-drop\" );\n\t\t}\n\t\tproperties.put( AvailableSettings.DIALECT, getDialect().getClass().getName() );\n\n\t\treturn properties;\n\t}\n\n\tprotected void configure(Map<String, Object> properties) {\n\t}\n\n\tprotected static final Class<?>[] NO_CLASSES = new Class[0];\n\n\tprotected Class<?>[] getAnnotatedClasses() {\n\t\treturn NO_CLASSES;\n\t}\n\n\tpublic Map<Class, String> getCachedClasses() {\n\t\treturn new HashMap<>();\n\t}\n\n\tpublic Map<String, String> getCachedCollections() {\n\t\treturn new HashMap<>();\n\t}\n\n\tprotected void afterSessionOrEntityManagerFactoryBuilt() {\n\t}\n\n\tprotected boolean createSchema() {\n\t\treturn true;\n\t}\n\n\t@After\n\tpublic final void afterTest() throws Exception {\n\t\tcompleteStrayTransaction();\n\n\t\tcleanupSession();\n\n\t}\n\n\t@AfterClassOnce\n\t@SuppressWarnings( {\"UnusedDeclaration\"})\n\tprotected void releaseSessionFactory() {\n\t\tif ( sessionFactory == null ) {\n\t\t\treturn;\n\t\t}\n\t\tsessionFactory.close();\n\t\tsessionFactory = null;\n\t\tif ( serviceRegistry != null ) {\n\t\t\tif ( serviceRegistry.isActive() ) {\n\t\t\t\ttry {\n\t\t\t\t\tserviceRegistry.destroy();\n\t\t\t\t}\n\t\t\t\tcatch (Exception ignore) {\n\t\t\t\t}\n\t\t\t\tfail( \"StandardServiceRegistry was not closed down as expected\" );\n\t\t\t}\n\t\t}\n\t\tserviceRegistry=null;\n\t}\n\n\tprivate void completeStrayTransaction() {\n\t\tif ( session == null ) {\n\t\t\t// nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif ( ( (SessionImplementor) session ).isClosed() ) {\n\t\t\t// nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !session.isConnected() ) {\n\t\t\t// nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tfinal TransactionCoordinator.TransactionDriver tdc =\n\t\t\t\t( (SessionImplementor) session ).getTransactionCoordinator().getTransactionDriverControl();\n\n\t\tif ( tdc.getStatus().canRollback() ) {\n\t\t\tsession.getTransaction().rollback();\n\t\t}\n\t\tsession.close();\n\t}\n\n\tprivate void cleanupSession() {\n\t\tif ( session != null && ! ( (SessionImplementor) session ).isClosed() ) {\n\t\t\tsession.close();\n\t\t}\n\t\tsession = null;\n\t}\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate createListenerArrayForWrite(len int) : T[] extracted from private handleListenerAddition(listener T, additionHandler Consumer<T>) : void in class org.hibernate.event.service.internal.EventListenerGroupImpl",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerGroupImpl.java",
                "startLine": 277,
                "endLine": 342,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerGroupImpl.java",
                "startLine": 288,
                "endLine": 352,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerGroupImpl.java",
                "startLine": 354,
                "endLine": 357,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private void handleListenerAddition(T listener, Consumer<T> additionHandler) {\n\t\tfinal T[] listenersRead = this.listeners;\n\t\tif ( listenersRead == null ) {\n\t\t\tadditionHandler.accept( listener );\n\t\t\treturn;\n\t\t}\n\t\tfinal T[] listenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), listenersRead.length );\n\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 0, listenersRead.length );\n\n\t\tfinal boolean debugEnabled = log.isDebugEnabled();\n\n\t\tfor ( DuplicationStrategy strategy : duplicationStrategies ) {\n\n\t\t\t// for each strategy, see if the strategy indicates that any of the existing\n\t\t\t//\t\tlisteners match the listener being added.  If so, we want to apply that\n\t\t\t//\t\tstrategy's action.  Control it returned immediately after applying the action\n\t\t\t//\t\ton match - meaning no further strategies are checked...\n\n\t\t\tfor ( int i = 0; i < listenersRead.length; i++ ) {\n\t\t\t\tfinal T existingListener = listenersRead[i];\n\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\tlog.debugf(\n\t\t\t\t\t\t\t\"Checking incoming listener [`%s`] for match against existing listener [`%s`]\",\n\t\t\t\t\t\t\tlistener,\n\t\t\t\t\t\t\texistingListener\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif ( strategy.areMatch( listener,  existingListener ) ) {\n\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\tlog.debugf( \"Found listener match between `%s` and `%s`\", listener, existingListener );\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch ( strategy.getAction() ) {\n\t\t\t\t\t\tcase ERROR: {\n\t\t\t\t\t\t\tthrow new EventListenerRegistrationException( \"Duplicate event listener found\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase KEEP_ORIGINAL: {\n\t\t\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\t\t\tlog.debugf( \"Skipping listener registration (%s) : `%s`\", strategy.getAction(), listener );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase REPLACE_ORIGINAL: {\n\t\t\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\t\t\tlog.debugf( \"Replacing listener registration (%s) : `%s` -> `%s`\", strategy.getAction(), existingListener, listener );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tprepareListener( listener );\n\n\t\t\t\t\t\t\tlistenersWrite[i] = listener;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// we've found a match - we should return: the match action has already been applied at this point\n\t\t\t\t\t// apply all pending changes:\n\t\t\t\t\tsetListeners( listenersWrite );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// we did not find any match.. add it\n\t\tcheckAgainstBaseInterface( listener );\n\t\tperformInjections( listener );\n\t\tadditionHandler.accept( listener );\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerGroupImpl.java",
        "isPureRefactoring": true,
        "commitId": "052eb0b78c6d5864e0a1b1ec63b487382c82ec1b",
        "packageNameBefore": "org.hibernate.event.service.internal",
        "classNameBefore": "org.hibernate.event.service.internal.EventListenerGroupImpl",
        "methodNameBefore": "org.hibernate.event.service.internal.EventListenerGroupImpl#handleListenerAddition",
        "invokedMethod": "methodSignature: org.hibernate.event.service.internal.EventListenerGroupImpl#prepareListener\n methodBody: private void prepareListener(T listener) {\ncheckAgainstBaseInterface(listener);\nperformInjections(listener);\n}\nmethodSignature: org.hibernate.event.service.internal.EventListenerGroupImpl#checkAgainstBaseInterface\n methodBody: private void checkAgainstBaseInterface(T listener) {\nif(!eventType.baseListenerInterface().isInstance(listener)){throw new EventListenerRegistrationException(\"Listener did not implement expected interface [\" + eventType.baseListenerInterface().getName() + \"]\");\n}}\nmethodSignature: org.hibernate.event.service.internal.EventListenerGroupImpl#setListeners\n methodBody: private synchronized void setListeners(T[] newListeners) {\nthis.listeners=newListeners;\nif(newListeners == null || newListeners.length == 0){this.listenersAsList=emptyList();\n}{this.listenersAsList=asList(newListeners);\n}}\nmethodSignature: org.hibernate.event.service.internal.EventListenerGroupImpl#performInjections\n methodBody: private void performInjections(T listener) {\nif(listener instanceof CallbackRegistryConsumer){((CallbackRegistryConsumer)listener).injectCallbackRegistry(callbackRegistry);\n}if(listener instanceof JpaBootstrapSensitive){((JpaBootstrapSensitive)listener).wasJpaBootstrap(isJpaBootstrap);\n}}",
        "classSignatureBefore": "class EventListenerGroupImpl<T> implements EventListenerGroup<T> ",
        "methodNameBeforeSet": [
            "org.hibernate.event.service.internal.EventListenerGroupImpl#handleListenerAddition"
        ],
        "classNameBeforeSet": [
            "org.hibernate.event.service.internal.EventListenerGroupImpl"
        ],
        "classSignatureBeforeSet": [
            "class EventListenerGroupImpl<T> implements EventListenerGroup<T> "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Overlapped refactoring - can be identical by undoing the overlapped refactoring\n- Extract Variable-",
                "description": "Extract variable on the top of the extract method - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.event.service.internal;\n\nimport java.lang.reflect.Array;\nimport java.util.Collections;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.CompletionStage;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiFunction;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\nimport org.hibernate.event.service.spi.DuplicationStrategy;\nimport org.hibernate.event.service.spi.EventActionWithParameter;\nimport org.hibernate.event.service.spi.EventListenerGroup;\nimport org.hibernate.event.service.spi.EventListenerRegistrationException;\nimport org.hibernate.event.service.spi.JpaBootstrapSensitive;\nimport org.hibernate.event.spi.EventType;\nimport org.hibernate.jpa.event.spi.CallbackRegistry;\nimport org.hibernate.jpa.event.spi.CallbackRegistryConsumer;\n\nimport org.jboss.logging.Logger;\n\nimport static java.util.Arrays.asList;\nimport static java.util.Collections.emptyList;\n\n/**\n * Standard EventListenerGroup implementation\n *\n * @author Steve Ebersole\n * @author Sanne Grinovero\n */\nclass EventListenerGroupImpl<T> implements EventListenerGroup<T> {\n\n\tprivate static final Logger log = Logger.getLogger( EventListenerGroupImpl.class );\n\tprivate static final Set<DuplicationStrategy> DEFAULT_DUPLICATION_STRATEGIES = Collections.unmodifiableSet( makeDefaultDuplicationStrategy() );\n\tprivate static final CompletableFuture COMPLETED = CompletableFuture.completedFuture( null );\n\n\tprivate final EventType<T> eventType;\n\tprivate final CallbackRegistry callbackRegistry;\n\tprivate final boolean isJpaBootstrap;\n\n\t//TODO at least the list of listeners should be made constant;\n\t//unfortunately a number of external integrations rely on being able to make\n\t//changes to listeners at runtime, so this will require some planning.\n\tprivate volatile Set<DuplicationStrategy> duplicationStrategies = DEFAULT_DUPLICATION_STRATEGIES;\n\tprivate volatile T[] listeners = null;\n\tprivate volatile List<T> listenersAsList = emptyList();\n\n\tpublic EventListenerGroupImpl(\n\t\t\tEventType<T> eventType,\n\t\t\tCallbackRegistry callbackRegistry,\n\t\t\tboolean isJpaBootstrap) {\n\t\tthis.eventType = eventType;\n\t\tthis.callbackRegistry = callbackRegistry;\n\t\tthis.isJpaBootstrap = isJpaBootstrap;\n\t}\n\n\t@Override\n\tpublic EventType<T> getEventType() {\n\t\treturn eventType;\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn count() <= 0;\n\t}\n\n\t@Override\n\tpublic int count() {\n\t\tfinal T[] ls = listeners;\n\t\treturn ls == null ? 0 : ls.length;\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\t//Odd semantics: we're expected (for backwards compatibility) to also clear the default DuplicationStrategy.\n\t\tduplicationStrategies = new LinkedHashSet<>();\n\t\tsetListeners( null );\n\t}\n\n\t// For efficiency reasons we use both a representation as List and as array;\n\t// ensure consistency between the two fields by delegating any mutation to both\n\t// fields to this method.\n\tprivate synchronized void setListeners(T[] newListeners) {\n\t\tthis.listeners = newListeners;\n\t\tif ( newListeners == null || newListeners.length == 0 ) {\n\t\t\tthis.listenersAsList = emptyList();\n\t\t}\n\t\telse {\n\t\t\tthis.listenersAsList = asList( newListeners );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void clearListeners() {\n\t\tsetListeners( null );\n\t}\n\n\t@Override\n\tpublic final <U> void fireLazyEventOnEachListener(final Supplier<U> eventSupplier, final BiConsumer<T,U> actionOnEvent) {\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null && ls.length != 0 ) {\n\t\t\tfinal U event = eventSupplier.get();\n\t\t\t//noinspection ForLoopReplaceableByForEach\n\t\t\tfor ( int i = 0; i < ls.length; i++ ) {\n\t\t\t\tactionOnEvent.accept( ls[i], event );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic final <U> void fireEventOnEachListener(final U event, final BiConsumer<T,U> actionOnEvent) {\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null ) {\n\t\t\t//noinspection ForLoopReplaceableByForEach\n\t\t\tfor ( int i = 0; i < ls.length; i++ ) {\n\t\t\t\tactionOnEvent.accept( ls[i], event );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic <U,X> void fireEventOnEachListener(final U event, final X parameter, final EventActionWithParameter<T, U, X> actionOnEvent) {\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null ) {\n\t\t\t//noinspection ForLoopReplaceableByForEach\n\t\t\tfor ( int i = 0; i < ls.length; i++ ) {\n\t\t\t\tactionOnEvent.applyEventToListener( ls[i], event, parameter );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic <R, U, RL> CompletionStage<R> fireEventOnEachListener(\n\t\t\tfinal U event,\n\t\t\tfinal Function<RL, Function<U, CompletionStage<R>>> fun) {\n\t\tCompletionStage<R> ret = COMPLETED;\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null && ls.length != 0 ) {\n\t\t\tfor ( T listener : ls ) {\n\t\t\t\t//to preserve atomicity of the Session methods\n\t\t\t\t//call apply() from within the arg of thenCompose()\n\t\t\t\tret = ret.thenCompose( v -> fun.apply( (RL) listener ).apply( event ) );\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic <R, U, RL, X> CompletionStage<R> fireEventOnEachListener(\n\t\t\tU event, X param, Function<RL, BiFunction<U, X, CompletionStage<R>>> fun) {\n\t\tCompletionStage<R> ret = COMPLETED;\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null && ls.length != 0 ) {\n\t\t\tfor ( T listener : ls ) {\n\t\t\t\t//to preserve atomicity of the Session methods\n\t\t\t\t//call apply() from within the arg of thenCompose()\n\t\t\t\tret = ret.thenCompose( v -> fun.apply( (RL) listener ).apply( event, param ) );\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic <R, U, RL> CompletionStage<R> fireLazyEventOnEachListener(\n\t\t\tfinal Supplier<U> eventSupplier,\n\t\t\tfinal Function<RL, Function<U, CompletionStage<R>>> fun) {\n\t\tCompletionStage<R> ret = COMPLETED;\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null && ls.length != 0 ) {\n\t\t\tfinal U event = eventSupplier.get();\n\t\t\tfor ( T listener : ls ) {\n\t\t\t\t//to preserve atomicity of the Session methods\n\t\t\t\t//call apply() from within the arg of thenCompose()\n\t\t\t\tret = ret.thenCompose( v -> fun.apply( (RL) listener ).apply( event ) );\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic void addDuplicationStrategy(DuplicationStrategy strategy) {\n\t\tif ( duplicationStrategies == DEFAULT_DUPLICATION_STRATEGIES ) {\n\t\t\tduplicationStrategies = makeDefaultDuplicationStrategy();\n\t\t}\n\t\tduplicationStrategies.add( strategy );\n\t}\n\n\t@Override\n\tpublic void appendListener(T listener) {\n\t\thandleListenerAddition( listener, this::internalAppend );\n\t}\n\n\t@Override\n\t@SafeVarargs\n\tpublic final void appendListeners(T... listeners) {\n\t\t//noinspection ForLoopReplaceableByForEach\n\t\tfor ( int i = 0; i < listeners.length; i++ ) {\n\t\t\thandleListenerAddition( listeners[i], this::internalAppend );\n\t\t}\n\t}\n\n\tprivate void internalAppend(T listener) {\n\t\tprepareListener( listener );\n\t\tfinal T[] listenersRead = this.listeners;\n\t\tfinal T[] listenersWrite;\n\n\t\tif ( listenersRead == null ) {\n\t\t\t//noinspection unchecked\n\t\t\tlistenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), 1 );\n\t\t\tlistenersWrite[0] = listener;\n\t\t}\n\t\telse {\n\t\t\tfinal int size = listenersRead.length;\n\n\t\t\t//noinspection unchecked\n\t\t\tlistenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), size+1 );\n\n\t\t\t// first copy the existing listeners\n\t\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 0, size );\n\n\t\t\t// and then put the new one after them\n\t\t\tlistenersWrite[size] = listener;\n\t\t}\n\t\tsetListeners( listenersWrite );\n\t}\n\n\t@Override\n\tpublic void prependListener(T listener) {\n\t\thandleListenerAddition( listener, this::internalPrepend );\n\t}\n\n\t@Override\n\t@SafeVarargs\n\tpublic final void prependListeners(T... listeners) {\n\t\t//noinspection ForLoopReplaceableByForEach\n\t\tfor ( int i = 0; i < listeners.length; i++ ) {\n\t\t\thandleListenerAddition( listeners[i], this::internalPrepend );\n\t\t}\n\t}\n\n\tprivate void internalPrepend(T listener) {\n\t\tprepareListener( listener );\n\t\tfinal T[] listenersRead = this.listeners;\n\t\tfinal T[] listenersWrite;\n\n\t\tif ( listenersRead == null ) {\n\t\t\t//noinspection unchecked\n\t\t\tlistenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), 1 );\n\t\t\tlistenersWrite[0] = listener;\n\t\t}\n\t\telse {\n\t\t\tfinal int size = listenersRead.length;\n\n\t\t\t//noinspection unchecked\n\t\t\tlistenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), size+1 );\n\n\t\t\t// put the new one first\n\t\t\tlistenersWrite[0] = listener;\n\n\t\t\t// and copy the rest after it\n\t\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 1, size );\n\t\t}\n\t\tsetListeners( listenersWrite );\n\t}\n\n\tprivate void handleListenerAddition(T listener, Consumer<T> additionHandler) {\n\t\tfinal T[] listenersRead = this.listeners;\n\t\tif ( listenersRead == null ) {\n\t\t\tadditionHandler.accept( listener );\n\t\t\treturn;\n\t\t}\n\t\tfinal T[] listenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), listenersRead.length );\n\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 0, listenersRead.length );\n\n\t\tfinal boolean debugEnabled = log.isDebugEnabled();\n\n\t\tfor ( DuplicationStrategy strategy : duplicationStrategies ) {\n\n\t\t\t// for each strategy, see if the strategy indicates that any of the existing\n\t\t\t//\t\tlisteners match the listener being added.  If so, we want to apply that\n\t\t\t//\t\tstrategy's action.  Control it returned immediately after applying the action\n\t\t\t//\t\ton match - meaning no further strategies are checked...\n\n\t\t\tfor ( int i = 0; i < listenersRead.length; i++ ) {\n\t\t\t\tfinal T existingListener = listenersRead[i];\n\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\tlog.debugf(\n\t\t\t\t\t\t\t\"Checking incoming listener [`%s`] for match against existing listener [`%s`]\",\n\t\t\t\t\t\t\tlistener,\n\t\t\t\t\t\t\texistingListener\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif ( strategy.areMatch( listener,  existingListener ) ) {\n\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\tlog.debugf( \"Found listener match between `%s` and `%s`\", listener, existingListener );\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch ( strategy.getAction() ) {\n\t\t\t\t\t\tcase ERROR: {\n\t\t\t\t\t\t\tthrow new EventListenerRegistrationException( \"Duplicate event listener found\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase KEEP_ORIGINAL: {\n\t\t\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\t\t\tlog.debugf( \"Skipping listener registration (%s) : `%s`\", strategy.getAction(), listener );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase REPLACE_ORIGINAL: {\n\t\t\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\t\t\tlog.debugf( \"Replacing listener registration (%s) : `%s` -> `%s`\", strategy.getAction(), existingListener, listener );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tprepareListener( listener );\n\n\t\t\t\t\t\t\tlistenersWrite[i] = listener;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// we've found a match - we should return: the match action has already been applied at this point\n\t\t\t\t\t// apply all pending changes:\n\t\t\t\t\tsetListeners( listenersWrite );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// we did not find any match.. add it\n\t\tcheckAgainstBaseInterface( listener );\n\t\tperformInjections( listener );\n\t\tadditionHandler.accept( listener );\n\t}\n\n\tprivate void prepareListener(T listener) {\n\t\tcheckAgainstBaseInterface( listener );\n\t\tperformInjections( listener );\n\t}\n\n\tprivate void performInjections(T listener) {\n\t\tif ( listener instanceof CallbackRegistryConsumer ) {\n\t\t\t( (CallbackRegistryConsumer) listener ).injectCallbackRegistry( callbackRegistry );\n\t\t}\n\n\t\tif ( listener instanceof JpaBootstrapSensitive ) {\n\t\t\t( (JpaBootstrapSensitive) listener ).wasJpaBootstrap( isJpaBootstrap );\n\t\t}\n\t}\n\n\tprivate void checkAgainstBaseInterface(T listener) {\n\t\tif ( !eventType.baseListenerInterface().isInstance( listener ) ) {\n\t\t\tthrow new EventListenerRegistrationException(\n\t\t\t\t\t\"Listener did not implement expected interface [\" + eventType.baseListenerInterface().getName() + \"]\"\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Implementation note: should be final for performance reasons.\n\t * @deprecated this is not the most efficient way for iterating the event listeners.\n\t * See {@link #fireEventOnEachListener(Object, BiConsumer)} and co. for better alternatives.\n\t */\n\t@Override\n\t@Deprecated\n\tpublic final Iterable<T> listeners() {\n\t\treturn this.listenersAsList;\n\t}\n\n\tprivate static Set<DuplicationStrategy> makeDefaultDuplicationStrategy() {\n\t\tfinal Set<DuplicationStrategy> duplicationStrategies = new LinkedHashSet<>();\n\t\tduplicationStrategies.add(\n\t\t\t\t// At minimum make sure we do not register the same exact listener class multiple times.\n\t\t\t\tnew DuplicationStrategy() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean areMatch(Object listener, Object original) {\n\t\t\t\t\t\treturn listener.getClass().equals( original.getClass() );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Action getAction() {\n\t\t\t\t\t\treturn Action.ERROR;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\treturn duplicationStrategies;\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerGroupImpl.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.event.service.internal;\n\nimport java.lang.reflect.Array;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.CompletionStage;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiFunction;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\nimport org.hibernate.event.service.spi.DuplicationStrategy;\nimport org.hibernate.event.service.spi.EventActionWithParameter;\nimport org.hibernate.event.service.spi.EventListenerGroup;\nimport org.hibernate.event.service.spi.EventListenerRegistrationException;\nimport org.hibernate.event.service.spi.JpaBootstrapSensitive;\nimport org.hibernate.event.spi.EventType;\nimport org.hibernate.jpa.event.spi.CallbackRegistry;\nimport org.hibernate.jpa.event.spi.CallbackRegistryConsumer;\n\nimport org.jboss.logging.Logger;\n\nimport static java.util.Arrays.asList;\nimport static java.util.Collections.emptyList;\nimport static java.util.Collections.singleton;\nimport static java.util.concurrent.CompletableFuture.completedFuture;\n\n/**\n * Standard EventListenerGroup implementation\n *\n * @author Steve Ebersole\n * @author Sanne Grinovero\n */\nclass EventListenerGroupImpl<T> implements EventListenerGroup<T> {\n\n\tprivate static final Logger log = Logger.getLogger( EventListenerGroupImpl.class );\n\n\tprivate static final DuplicationStrategy DEFAULT_DUPLICATION_STRATEGY =\n\t\t\tnew DuplicationStrategy() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean areMatch(Object listener, Object original) {\n\t\t\t\t\treturn listener.getClass().equals( original.getClass() );\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic Action getAction() {\n\t\t\t\t\treturn Action.ERROR;\n\t\t\t\t}\n\t\t\t};\n\tprivate static final Set<DuplicationStrategy> DEFAULT_DUPLICATION_STRATEGIES =\n\t\t\tsingleton( DEFAULT_DUPLICATION_STRATEGY );\n\n\tprivate static final CompletableFuture<?> COMPLETED = completedFuture( null );\n\t@SuppressWarnings(\"unchecked\")\n\tprivate static <R> CompletableFuture<R> nullCompletion() {\n\t\treturn (CompletableFuture<R>) COMPLETED;\n\t}\n\n\tprivate final EventType<T> eventType;\n\tprivate final CallbackRegistry callbackRegistry;\n\tprivate final boolean isJpaBootstrap;\n\n\t//TODO at least the list of listeners should be made constant;\n\t//unfortunately a number of external integrations rely on being able to make\n\t//changes to listeners at runtime, so this will require some planning.\n\tprivate volatile Set<DuplicationStrategy> duplicationStrategies = DEFAULT_DUPLICATION_STRATEGIES;\n\tprivate volatile T[] listeners = null;\n\tprivate volatile List<T> listenersAsList = emptyList();\n\n\tpublic EventListenerGroupImpl(EventType<T> eventType, CallbackRegistry callbackRegistry, boolean isJpaBootstrap) {\n\t\tthis.eventType = eventType;\n\t\tthis.callbackRegistry = callbackRegistry;\n\t\tthis.isJpaBootstrap = isJpaBootstrap;\n\t}\n\n\t@Override\n\tpublic EventType<T> getEventType() {\n\t\treturn eventType;\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn count() <= 0;\n\t}\n\n\t@Override\n\tpublic int count() {\n\t\tfinal T[] ls = listeners;\n\t\treturn ls == null ? 0 : ls.length;\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\t//Odd semantics: we're expected (for backwards compatibility)\n\t\t//               to also clear the default DuplicationStrategy.\n\t\tduplicationStrategies = new LinkedHashSet<>();\n\t\tsetListeners( null );\n\t}\n\n\t// For efficiency reasons we use both a representation as List and as array;\n\t// ensure consistency between the two fields by delegating any mutation to both\n\t// fields to this method.\n\tprivate synchronized void setListeners(T[] newListeners) {\n\t\tlisteners = newListeners;\n\t\tlistenersAsList = newListeners == null || newListeners.length == 0\n\t\t\t\t? emptyList()\n\t\t\t\t: asList( newListeners );\n\t}\n\n\t@Override\n\tpublic void clearListeners() {\n\t\tsetListeners( null );\n\t}\n\n\t@Override\n\tpublic final <U> void fireLazyEventOnEachListener(Supplier<U> eventSupplier, BiConsumer<T,U> actionOnEvent) {\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null && ls.length != 0 ) {\n\t\t\tfinal U event = eventSupplier.get();\n\t\t\t//noinspection ForLoopReplaceableByForEach\n\t\t\tfor ( int i = 0; i < ls.length; i++ ) {\n\t\t\t\tactionOnEvent.accept( ls[i], event );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic final <U> void fireEventOnEachListener(U event, BiConsumer<T,U> actionOnEvent) {\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null ) {\n\t\t\t//noinspection ForLoopReplaceableByForEach\n\t\t\tfor ( int i = 0; i < ls.length; i++ ) {\n\t\t\t\tactionOnEvent.accept( ls[i], event );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic <U,X> void fireEventOnEachListener(U event, X parameter, EventActionWithParameter<T, U, X> actionOnEvent) {\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null ) {\n\t\t\t//noinspection ForLoopReplaceableByForEach\n\t\t\tfor ( int i = 0; i < ls.length; i++ ) {\n\t\t\t\tactionOnEvent.applyEventToListener( ls[i], event, parameter );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic <R, U, RL> CompletionStage<R> fireEventOnEachListener(\n\t\t\tfinal U event,\n\t\t\tfinal Function<RL, Function<U, CompletionStage<R>>> fun) {\n\t\tCompletionStage<R> ret = nullCompletion();\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null ) {\n\t\t\tfor ( T listener : ls ) {\n\t\t\t\t//to preserve atomicity of the Session methods\n\t\t\t\t//call apply() from within the arg of thenCompose()\n\t\t\t\tret = ret.thenCompose( v -> fun.apply( (RL) listener ).apply( event ) );\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic <R, U, RL, X> CompletionStage<R> fireEventOnEachListener(\n\t\t\tU event, X param, Function<RL, BiFunction<U, X, CompletionStage<R>>> fun) {\n\t\tCompletionStage<R> ret = nullCompletion();\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null ) {\n\t\t\tfor ( T listener : ls ) {\n\t\t\t\t//to preserve atomicity of the Session methods\n\t\t\t\t//call apply() from within the arg of thenCompose()\n\t\t\t\tret = ret.thenCompose( v -> fun.apply( (RL) listener ).apply( event, param ) );\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic <R, U, RL> CompletionStage<R> fireLazyEventOnEachListener(\n\t\t\tSupplier<U> eventSupplier,\n\t\t\tFunction<RL, Function<U, CompletionStage<R>>> fun) {\n\t\tCompletionStage<R> ret = nullCompletion();\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null && ls.length != 0 ) {\n\t\t\tfinal U event = eventSupplier.get();\n\t\t\tfor ( T listener : ls ) {\n\t\t\t\t//to preserve atomicity of the Session methods\n\t\t\t\t//call apply() from within the arg of thenCompose()\n\t\t\t\tret = ret.thenCompose( v -> fun.apply( (RL) listener ).apply( event ) );\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic void addDuplicationStrategy(DuplicationStrategy strategy) {\n\t\tif ( duplicationStrategies == DEFAULT_DUPLICATION_STRATEGIES ) {\n\t\t\t// At minimum make sure we do not register the same exact listener class multiple times.\n\t\t\tduplicationStrategies = new LinkedHashSet<>( DEFAULT_DUPLICATION_STRATEGIES );\n\t\t}\n\t\tduplicationStrategies.add( strategy );\n\t}\n\n\t@Override\n\tpublic void appendListener(T listener) {\n\t\thandleListenerAddition( listener, this::internalAppend );\n\t}\n\n\t@Override\n\t@SafeVarargs\n\tpublic final void appendListeners(T... listeners) {\n\t\t//noinspection ForLoopReplaceableByForEach\n\t\tfor ( int i = 0; i < listeners.length; i++ ) {\n\t\t\thandleListenerAddition( listeners[i], this::internalAppend );\n\t\t}\n\t}\n\n\tprivate void internalAppend(T listener) {\n\t\tprepareListener( listener );\n\t\tfinal T[] listenersRead = listeners;\n\t\tfinal T[] listenersWrite;\n\n\t\tif ( listenersRead == null ) {\n\t\t\tlistenersWrite = createListenerArrayForWrite( 1 );\n\t\t\tlistenersWrite[0] = listener;\n\t\t}\n\t\telse {\n\t\t\tfinal int size = listenersRead.length;\n\n\t\t\tlistenersWrite = createListenerArrayForWrite( size + 1 );\n\n\t\t\t// first copy the existing listeners\n\t\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 0, size );\n\n\t\t\t// and then put the new one after them\n\t\t\tlistenersWrite[size] = listener;\n\t\t}\n\t\tsetListeners( listenersWrite );\n\t}\n\n\t@Override\n\tpublic void prependListener(T listener) {\n\t\thandleListenerAddition( listener, this::internalPrepend );\n\t}\n\n\t@Override\n\t@SafeVarargs\n\tpublic final void prependListeners(T... listeners) {\n\t\t//noinspection ForLoopReplaceableByForEach\n\t\tfor ( int i = 0; i < listeners.length; i++ ) {\n\t\t\thandleListenerAddition( listeners[i], this::internalPrepend );\n\t\t}\n\t}\n\n\tprivate void internalPrepend(T listener) {\n\t\tprepareListener( listener );\n\t\tfinal T[] listenersRead = listeners;\n\t\tfinal T[] listenersWrite;\n\n\t\tif ( listenersRead == null ) {\n\t\t\tlistenersWrite = createListenerArrayForWrite( 1 );\n\t\t\tlistenersWrite[0] = listener;\n\t\t}\n\t\telse {\n\t\t\tfinal int size = listenersRead.length;\n\n\t\t\tlistenersWrite = createListenerArrayForWrite( size + 1 );\n\n\t\t\t// put the new one first\n\t\t\tlistenersWrite[0] = listener;\n\n\t\t\t// and copy the rest after it\n\t\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 1, size );\n\t\t}\n\t\tsetListeners( listenersWrite );\n\t}\n\n\tprivate void handleListenerAddition(T listener, Consumer<T> additionHandler) {\n\t\tfinal T[] listenersRead = listeners;\n\t\tif ( listenersRead == null ) {\n\t\t\tadditionHandler.accept( listener );\n\t\t\treturn;\n\t\t}\n\t\tint size = listenersRead.length;\n\n\t\tfinal T[] listenersWrite = createListenerArrayForWrite( size );\n\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 0, size );\n\n\t\tfinal boolean debugEnabled = log.isDebugEnabled();\n\n\t\tfor ( DuplicationStrategy strategy : duplicationStrategies ) {\n\n\t\t\t// for each strategy, see if the strategy indicates that any of the existing\n\t\t\t//\t\tlisteners match the listener being added.  If so, we want to apply that\n\t\t\t//\t\tstrategy's action.  Control it returned immediately after applying the action\n\t\t\t//\t\ton match - meaning no further strategies are checked...\n\n\t\t\tfor ( int i = 0; i < size; i++ ) {\n\t\t\t\tfinal T existingListener = listenersRead[i];\n\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\tlog.debugf( \"Checking incoming listener [`%s`] for match against existing listener [`%s`]\",\n\t\t\t\t\t\t\tlistener, existingListener );\n\t\t\t\t}\n\n\t\t\t\tif ( strategy.areMatch( listener,  existingListener ) ) {\n\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\tlog.debugf( \"Found listener match between `%s` and `%s`\",\n\t\t\t\t\t\t\t\tlistener, existingListener );\n\t\t\t\t\t}\n\n\t\t\t\t\tfinal DuplicationStrategy.Action action = strategy.getAction();\n\t\t\t\t\tswitch (action) {\n\t\t\t\t\t\tcase ERROR:\n\t\t\t\t\t\t\tthrow new EventListenerRegistrationException( \"Duplicate event listener found\" );\n\t\t\t\t\t\tcase KEEP_ORIGINAL:\n\t\t\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\t\t\tlog.debugf( \"Skipping listener registration (%s) : `%s`\",\n\t\t\t\t\t\t\t\t\t\taction, listener );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tcase REPLACE_ORIGINAL:\n\t\t\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\t\t\tlog.debugf( \"Replacing listener registration (%s) : `%s` -> `%s`\",\n\t\t\t\t\t\t\t\t\t\taction, existingListener, listener );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tprepareListener( listener );\n\t\t\t\t\t\t\tlistenersWrite[i] = listener;\n\t\t\t\t\t}\n\n\t\t\t\t\t// we've found a match - we should return: the match action has already been applied at this point\n\t\t\t\t\t// apply all pending changes:\n\t\t\t\t\tsetListeners( listenersWrite );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// we did not find any match, add it\n\t\tcheckAgainstBaseInterface( listener );\n\t\tperformInjections( listener );\n\t\tadditionHandler.accept( listener );\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate T[] createListenerArrayForWrite(int len) {\n\t\treturn (T[]) Array.newInstance( eventType.baseListenerInterface(), len );\n\t}\n\n\tprivate void prepareListener(T listener) {\n\t\tcheckAgainstBaseInterface( listener );\n\t\tperformInjections( listener );\n\t}\n\n\tprivate void performInjections(T listener) {\n\t\tif ( listener instanceof CallbackRegistryConsumer consumer ) {\n\t\t\tconsumer.injectCallbackRegistry( callbackRegistry );\n\t\t}\n\t\tif ( listener instanceof JpaBootstrapSensitive sensitive ) {\n\t\t\tsensitive.wasJpaBootstrap( isJpaBootstrap );\n\t\t}\n\t}\n\n\tprivate void checkAgainstBaseInterface(T listener) {\n\t\tif ( !eventType.baseListenerInterface().isInstance( listener ) ) {\n\t\t\tthrow new EventListenerRegistrationException( \"Listener did not implement expected interface [\"\n\t\t\t\t\t+ eventType.baseListenerInterface().getName() + \"]\" );\n\t\t}\n\t}\n\n\t/**\n\t * Implementation note: should be final for performance reasons.\n\t * @deprecated this is not the most efficient way for iterating the event listeners.\n\t * See {@link #fireEventOnEachListener(Object, BiConsumer)} and co. for better alternatives.\n\t */\n\t@Override\n\t@Deprecated\n\tpublic final Iterable<T> listeners() {\n\t\treturn listenersAsList;\n\t}\n}\n",
        "diffSourceCodeSet": [
            "@SuppressWarnings(\"unchecked\")\n\tprivate T[] createListenerArrayForWrite(int len) {\n\t\treturn (T[]) Array.newInstance( eventType.baseListenerInterface(), len );\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.event.service.internal.EventListenerGroupImpl#prepareListener\n methodBody: private void prepareListener(T listener) {\ncheckAgainstBaseInterface(listener);\nperformInjections(listener);\n}",
            "methodSignature: org.hibernate.event.service.internal.EventListenerGroupImpl#checkAgainstBaseInterface\n methodBody: private void checkAgainstBaseInterface(T listener) {\nif(!eventType.baseListenerInterface().isInstance(listener)){throw new EventListenerRegistrationException(\"Listener did not implement expected interface [\" + eventType.baseListenerInterface().getName() + \"]\");\n}}",
            "methodSignature: org.hibernate.event.service.internal.EventListenerGroupImpl#setListeners\n methodBody: private synchronized void setListeners(T[] newListeners) {\nthis.listeners=newListeners;\nif(newListeners == null || newListeners.length == 0){this.listenersAsList=emptyList();\n}{this.listenersAsList=asList(newListeners);\n}}",
            "methodSignature: org.hibernate.event.service.internal.EventListenerGroupImpl#performInjections\n methodBody: private void performInjections(T listener) {\nif(listener instanceof CallbackRegistryConsumer){((CallbackRegistryConsumer)listener).injectCallbackRegistry(callbackRegistry);\n}if(listener instanceof JpaBootstrapSensitive){((JpaBootstrapSensitive)listener).wasJpaBootstrap(isJpaBootstrap);\n}}"
        ],
        "sourceCodeAfterRefactoring": "private void handleListenerAddition(T listener, Consumer<T> additionHandler) {\n\t\tfinal T[] listenersRead = listeners;\n\t\tif ( listenersRead == null ) {\n\t\t\tadditionHandler.accept( listener );\n\t\t\treturn;\n\t\t}\n\t\tint size = listenersRead.length;\n\n\t\tfinal T[] listenersWrite = createListenerArrayForWrite( size );\n\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 0, size );\n\n\t\tfinal boolean debugEnabled = log.isDebugEnabled();\n\n\t\tfor ( DuplicationStrategy strategy : duplicationStrategies ) {\n\n\t\t\t// for each strategy, see if the strategy indicates that any of the existing\n\t\t\t//\t\tlisteners match the listener being added.  If so, we want to apply that\n\t\t\t//\t\tstrategy's action.  Control it returned immediately after applying the action\n\t\t\t//\t\ton match - meaning no further strategies are checked...\n\n\t\t\tfor ( int i = 0; i < size; i++ ) {\n\t\t\t\tfinal T existingListener = listenersRead[i];\n\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\tlog.debugf( \"Checking incoming listener [`%s`] for match against existing listener [`%s`]\",\n\t\t\t\t\t\t\tlistener, existingListener );\n\t\t\t\t}\n\n\t\t\t\tif ( strategy.areMatch( listener,  existingListener ) ) {\n\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\tlog.debugf( \"Found listener match between `%s` and `%s`\",\n\t\t\t\t\t\t\t\tlistener, existingListener );\n\t\t\t\t\t}\n\n\t\t\t\t\tfinal DuplicationStrategy.Action action = strategy.getAction();\n\t\t\t\t\tswitch (action) {\n\t\t\t\t\t\tcase ERROR:\n\t\t\t\t\t\t\tthrow new EventListenerRegistrationException( \"Duplicate event listener found\" );\n\t\t\t\t\t\tcase KEEP_ORIGINAL:\n\t\t\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\t\t\tlog.debugf( \"Skipping listener registration (%s) : `%s`\",\n\t\t\t\t\t\t\t\t\t\taction, listener );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tcase REPLACE_ORIGINAL:\n\t\t\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\t\t\tlog.debugf( \"Replacing listener registration (%s) : `%s` -> `%s`\",\n\t\t\t\t\t\t\t\t\t\taction, existingListener, listener );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tprepareListener( listener );\n\t\t\t\t\t\t\tlistenersWrite[i] = listener;\n\t\t\t\t\t}\n\n\t\t\t\t\t// we've found a match - we should return: the match action has already been applied at this point\n\t\t\t\t\t// apply all pending changes:\n\t\t\t\t\tsetListeners( listenersWrite );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// we did not find any match, add it\n\t\tcheckAgainstBaseInterface( listener );\n\t\tperformInjections( listener );\n\t\tadditionHandler.accept( listener );\n\t}\n@SuppressWarnings(\"unchecked\")\n\tprivate T[] createListenerArrayForWrite(int len) {\n\t\treturn (T[]) Array.newInstance( eventType.baseListenerInterface(), len );\n\t}",
        "diffSourceCode": "-  277: \tprivate void handleListenerAddition(T listener, Consumer<T> additionHandler) {\n-  278: \t\tfinal T[] listenersRead = this.listeners;\n-  279: \t\tif ( listenersRead == null ) {\n-  280: \t\t\tadditionHandler.accept( listener );\n-  281: \t\t\treturn;\n-  282: \t\t}\n-  283: \t\tfinal T[] listenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), listenersRead.length );\n-  284: \t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 0, listenersRead.length );\n-  285: \n-  286: \t\tfinal boolean debugEnabled = log.isDebugEnabled();\n+  277: \t\t\tlistenersWrite = createListenerArrayForWrite( size + 1 );\n+  278: \n+  279: \t\t\t// put the new one first\n+  280: \t\t\tlistenersWrite[0] = listener;\n+  281: \n+  282: \t\t\t// and copy the rest after it\n+  283: \t\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 1, size );\n+  284: \t\t}\n+  285: \t\tsetListeners( listenersWrite );\n+  286: \t}\n   287: \n-  288: \t\tfor ( DuplicationStrategy strategy : duplicationStrategies ) {\n-  289: \n-  290: \t\t\t// for each strategy, see if the strategy indicates that any of the existing\n-  291: \t\t\t//\t\tlisteners match the listener being added.  If so, we want to apply that\n-  292: \t\t\t//\t\tstrategy's action.  Control it returned immediately after applying the action\n-  293: \t\t\t//\t\ton match - meaning no further strategies are checked...\n-  294: \n-  295: \t\t\tfor ( int i = 0; i < listenersRead.length; i++ ) {\n-  296: \t\t\t\tfinal T existingListener = listenersRead[i];\n-  297: \t\t\t\tif ( debugEnabled ) {\n-  298: \t\t\t\t\tlog.debugf(\n-  299: \t\t\t\t\t\t\t\"Checking incoming listener [`%s`] for match against existing listener [`%s`]\",\n-  300: \t\t\t\t\t\t\tlistener,\n-  301: \t\t\t\t\t\t\texistingListener\n-  302: \t\t\t\t\t);\n-  303: \t\t\t\t}\n-  304: \n-  305: \t\t\t\tif ( strategy.areMatch( listener,  existingListener ) ) {\n-  306: \t\t\t\t\tif ( debugEnabled ) {\n-  307: \t\t\t\t\t\tlog.debugf( \"Found listener match between `%s` and `%s`\", listener, existingListener );\n-  308: \t\t\t\t\t}\n-  309: \n-  310: \t\t\t\t\tswitch ( strategy.getAction() ) {\n-  311: \t\t\t\t\t\tcase ERROR: {\n-  312: \t\t\t\t\t\t\tthrow new EventListenerRegistrationException( \"Duplicate event listener found\" );\n-  313: \t\t\t\t\t\t}\n-  314: \t\t\t\t\t\tcase KEEP_ORIGINAL: {\n-  315: \t\t\t\t\t\t\tif ( debugEnabled ) {\n-  316: \t\t\t\t\t\t\t\tlog.debugf( \"Skipping listener registration (%s) : `%s`\", strategy.getAction(), listener );\n-  317: \t\t\t\t\t\t\t}\n-  318: \t\t\t\t\t\t\treturn;\n-  319: \t\t\t\t\t\t}\n-  320: \t\t\t\t\t\tcase REPLACE_ORIGINAL: {\n-  321: \t\t\t\t\t\t\tif ( debugEnabled ) {\n-  322: \t\t\t\t\t\t\t\tlog.debugf( \"Replacing listener registration (%s) : `%s` -> `%s`\", strategy.getAction(), existingListener, listener );\n-  323: \t\t\t\t\t\t\t}\n-  324: \t\t\t\t\t\t\tprepareListener( listener );\n-  325: \n-  326: \t\t\t\t\t\t\tlistenersWrite[i] = listener;\n-  327: \t\t\t\t\t\t}\n-  328: \t\t\t\t\t}\n-  329: \n-  330: \t\t\t\t\t// we've found a match - we should return: the match action has already been applied at this point\n-  331: \t\t\t\t\t// apply all pending changes:\n-  332: \t\t\t\t\tsetListeners( listenersWrite );\n-  333: \t\t\t\t\treturn;\n-  334: \t\t\t\t}\n-  335: \t\t\t}\n-  336: \t\t}\n-  337: \n-  338: \t\t// we did not find any match.. add it\n-  339: \t\tcheckAgainstBaseInterface( listener );\n-  340: \t\tperformInjections( listener );\n-  341: \t\tadditionHandler.accept( listener );\n-  342: \t}\n-  343: \n-  344: \tprivate void prepareListener(T listener) {\n-  345: \t\tcheckAgainstBaseInterface( listener );\n-  346: \t\tperformInjections( listener );\n-  347: \t}\n-  348: \n-  349: \tprivate void performInjections(T listener) {\n-  350: \t\tif ( listener instanceof CallbackRegistryConsumer ) {\n-  351: \t\t\t( (CallbackRegistryConsumer) listener ).injectCallbackRegistry( callbackRegistry );\n-  352: \t\t}\n-  354: \t\tif ( listener instanceof JpaBootstrapSensitive ) {\n-  355: \t\t\t( (JpaBootstrapSensitive) listener ).wasJpaBootstrap( isJpaBootstrap );\n-  356: \t\t}\n+  288: \tprivate void handleListenerAddition(T listener, Consumer<T> additionHandler) {\n+  289: \t\tfinal T[] listenersRead = listeners;\n+  290: \t\tif ( listenersRead == null ) {\n+  291: \t\t\tadditionHandler.accept( listener );\n+  292: \t\t\treturn;\n+  293: \t\t}\n+  294: \t\tint size = listenersRead.length;\n+  295: \n+  296: \t\tfinal T[] listenersWrite = createListenerArrayForWrite( size );\n+  297: \t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 0, size );\n+  298: \n+  299: \t\tfinal boolean debugEnabled = log.isDebugEnabled();\n+  300: \n+  301: \t\tfor ( DuplicationStrategy strategy : duplicationStrategies ) {\n+  302: \n+  303: \t\t\t// for each strategy, see if the strategy indicates that any of the existing\n+  304: \t\t\t//\t\tlisteners match the listener being added.  If so, we want to apply that\n+  305: \t\t\t//\t\tstrategy's action.  Control it returned immediately after applying the action\n+  306: \t\t\t//\t\ton match - meaning no further strategies are checked...\n+  307: \n+  308: \t\t\tfor ( int i = 0; i < size; i++ ) {\n+  309: \t\t\t\tfinal T existingListener = listenersRead[i];\n+  310: \t\t\t\tif ( debugEnabled ) {\n+  311: \t\t\t\t\tlog.debugf( \"Checking incoming listener [`%s`] for match against existing listener [`%s`]\",\n+  312: \t\t\t\t\t\t\tlistener, existingListener );\n+  313: \t\t\t\t}\n+  314: \n+  315: \t\t\t\tif ( strategy.areMatch( listener,  existingListener ) ) {\n+  316: \t\t\t\t\tif ( debugEnabled ) {\n+  317: \t\t\t\t\t\tlog.debugf( \"Found listener match between `%s` and `%s`\",\n+  318: \t\t\t\t\t\t\t\tlistener, existingListener );\n+  319: \t\t\t\t\t}\n+  320: \n+  321: \t\t\t\t\tfinal DuplicationStrategy.Action action = strategy.getAction();\n+  322: \t\t\t\t\tswitch (action) {\n+  323: \t\t\t\t\t\tcase ERROR:\n+  324: \t\t\t\t\t\t\tthrow new EventListenerRegistrationException( \"Duplicate event listener found\" );\n+  325: \t\t\t\t\t\tcase KEEP_ORIGINAL:\n+  326: \t\t\t\t\t\t\tif ( debugEnabled ) {\n+  327: \t\t\t\t\t\t\t\tlog.debugf( \"Skipping listener registration (%s) : `%s`\",\n+  328: \t\t\t\t\t\t\t\t\t\taction, listener );\n+  329: \t\t\t\t\t\t\t}\n+  330: \t\t\t\t\t\t\treturn;\n+  331: \t\t\t\t\t\tcase REPLACE_ORIGINAL:\n+  332: \t\t\t\t\t\t\tif ( debugEnabled ) {\n+  333: \t\t\t\t\t\t\t\tlog.debugf( \"Replacing listener registration (%s) : `%s` -> `%s`\",\n+  334: \t\t\t\t\t\t\t\t\t\taction, existingListener, listener );\n+  335: \t\t\t\t\t\t\t}\n+  336: \t\t\t\t\t\t\tprepareListener( listener );\n+  337: \t\t\t\t\t\t\tlistenersWrite[i] = listener;\n+  338: \t\t\t\t\t}\n+  339: \n+  340: \t\t\t\t\t// we've found a match - we should return: the match action has already been applied at this point\n+  341: \t\t\t\t\t// apply all pending changes:\n+  342: \t\t\t\t\tsetListeners( listenersWrite );\n+  343: \t\t\t\t\treturn;\n+  344: \t\t\t\t}\n+  345: \t\t\t}\n+  346: \t\t}\n+  347: \n+  348: \t\t// we did not find any match, add it\n+  349: \t\tcheckAgainstBaseInterface( listener );\n+  350: \t\tperformInjections( listener );\n+  351: \t\tadditionHandler.accept( listener );\n+  352: \t}\n+  354: \t@SuppressWarnings(\"unchecked\")\n+  355: \tprivate T[] createListenerArrayForWrite(int len) {\n+  356: \t\treturn (T[]) Array.newInstance( eventType.baseListenerInterface(), len );\n   357: \t}\n",
        "uniqueId": "052eb0b78c6d5864e0a1b1ec63b487382c82ec1b_277_342_354_357_288_352",
        "moveFileExist": true,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 23,
                "covered": 97
            },
            "BRANCH": {
                "missed": 5,
                "covered": 15
            },
            "LINE": {
                "missed": 4,
                "covered": 27
            },
            "COMPLEXITY": {
                "missed": 5,
                "covered": 7
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\nprivate void applyStrategyAction(DuplicationStrategy strategy, T listener, T existingListener, boolean debugEnabled, T[] listenersWrite) {\n    if (strategy.areMatch(listener, existingListener)) {\n        if (debugEnabled) {\n            log.debugf(\"Found listener match between `%s` and `%s`\", listener, existingListener);\n        }\n\n        switch (strategy.getAction()) {\n            case ERROR: {\n                throw new EventListenerRegistrationException(\"Duplicate event listener found\");\n            }\n            case KEEP_ORIGINAL: {\n                if (debugEnabled) {\n                    log.debugf(\"Skipping listener registration (%s) : `%s`\", strategy.getAction(), listener);\n                }\n                return;\n            }\n            case REPLACE_ORIGINAL: {\n                if (debugEnabled) {\n                    log.debugf(\"Replacing listener registration (%s) : `%s` -> `%s`\", strategy.getAction(), existingListener, listener);\n                }\n                prepareListener(listener);\n\n                listenersWrite[i] = listener;\n            }\n        }\n\n        // we've found a match - we should return: the match action has already been applied at this point\n        // apply all pending changes:\n        setListeners(listenersWrite);\n        return;\n    }\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprivate void handleListenerAddition(T listener, Consumer<T> additionHandler) {\n\t\tfinal T[] listenersRead = this.listeners;\n\t\tif ( listenersRead == null ) {\n\t\t\tadditionHandler.accept( listener );\n\t\t\treturn;\n\t\t}\n\t\tfinal T[] listenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), listenersRead.length );\n\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 0, listenersRead.length );\n\n\t\tfinal boolean debugEnabled = log.isDebugEnabled();\n\n\t\tfor ( DuplicationStrategy strategy : duplicationStrategies ) {\n\n\t\t\t// for each strategy, see if the strategy indicates that any of the existing\n\t\t\t//\t\tlisteners match the listener being added.  If so, we want to apply that\n\t\t\t//\t\tstrategy's action.  Control it returned immediately after applying the action\n\t\t\t//\t\ton match - meaning no further strategies are checked...\n\n\t\t\tfor ( int i = 0; i < listenersRead.length; i++ ) {\n\t\t\t\tfinal T existingListener = listenersRead[i];\n\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\tlog.debugf(\n\t\t\t\t\t\t\t\"Checking incoming listener [`%s`] for match against existing listener [`%s`]\",\n\t\t\t\t\t\t\tlistener,\n\t\t\t\t\t\t\texistingListener\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif ( strategy.areMatch( listener,  existingListener ) ) {\n\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\tlog.debugf( \"Found listener match between `%s` and `%s`\", listener, existingListener );\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch ( strategy.getAction() ) {\n\t\t\t\t\t\tcase ERROR: {\n\t\t\t\t\t\t\tthrow new EventListenerRegistrationException( \"Duplicate event listener found\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase KEEP_ORIGINAL: {\n\t\t\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\t\t\tlog.debugf( \"Skipping listener registration (%s) : `%s`\", strategy.getAction(), listener );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase REPLACE_ORIGINAL: {\n\t\t\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\t\t\tlog.debugf( \"Replacing listener registration (%s) : `%s` -> `%s`\", strategy.getAction(), existingListener, listener );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tprepareListener( listener );\n\n\t\t\t\t\t\t\tlistenersWrite[i] = listener;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// we've found a match - we should return: the match action has already been applied at this point\n\t\t\t\t\t// apply all pending changes:\n\t\t\t\t\tsetListeners( listenersWrite );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// we did not find any match.. add it\n\t\tcheckAgainstBaseInterface( listener );\n\t\tperformInjections( listener );\n\t\tadditionHandler.accept( listener );\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.event.service.internal;\n\nimport java.lang.reflect.Array;\nimport java.util.Collections;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.CompletionStage;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiFunction;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\nimport org.hibernate.event.service.spi.DuplicationStrategy;\nimport org.hibernate.event.service.spi.EventActionWithParameter;\nimport org.hibernate.event.service.spi.EventListenerGroup;\nimport org.hibernate.event.service.spi.EventListenerRegistrationException;\nimport org.hibernate.event.service.spi.JpaBootstrapSensitive;\nimport org.hibernate.event.spi.EventType;\nimport org.hibernate.jpa.event.spi.CallbackRegistry;\nimport org.hibernate.jpa.event.spi.CallbackRegistryConsumer;\n\nimport org.jboss.logging.Logger;\n\nimport static java.util.Arrays.asList;\nimport static java.util.Collections.emptyList;\n\n/**\n * Standard EventListenerGroup implementation\n *\n * @author Steve Ebersole\n * @author Sanne Grinovero\n */\nclass EventListenerGroupImpl<T> implements EventListenerGroup<T> {\n\n\tprivate static final Logger log = Logger.getLogger( EventListenerGroupImpl.class );\n\tprivate static final Set<DuplicationStrategy> DEFAULT_DUPLICATION_STRATEGIES = Collections.unmodifiableSet( makeDefaultDuplicationStrategy() );\n\tprivate static final CompletableFuture COMPLETED = CompletableFuture.completedFuture( null );\n\n\tprivate final EventType<T> eventType;\n\tprivate final CallbackRegistry callbackRegistry;\n\tprivate final boolean isJpaBootstrap;\n\n\t//TODO at least the list of listeners should be made constant;\n\t//unfortunately a number of external integrations rely on being able to make\n\t//changes to listeners at runtime, so this will require some planning.\n\tprivate volatile Set<DuplicationStrategy> duplicationStrategies = DEFAULT_DUPLICATION_STRATEGIES;\n\tprivate volatile T[] listeners = null;\n\tprivate volatile List<T> listenersAsList = emptyList();\n\n\tpublic EventListenerGroupImpl(\n\t\t\tEventType<T> eventType,\n\t\t\tCallbackRegistry callbackRegistry,\n\t\t\tboolean isJpaBootstrap) {\n\t\tthis.eventType = eventType;\n\t\tthis.callbackRegistry = callbackRegistry;\n\t\tthis.isJpaBootstrap = isJpaBootstrap;\n\t}\n\n\t@Override\n\tpublic EventType<T> getEventType() {\n\t\treturn eventType;\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn count() <= 0;\n\t}\n\n\t@Override\n\tpublic int count() {\n\t\tfinal T[] ls = listeners;\n\t\treturn ls == null ? 0 : ls.length;\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\t//Odd semantics: we're expected (for backwards compatibility) to also clear the default DuplicationStrategy.\n\t\tduplicationStrategies = new LinkedHashSet<>();\n\t\tsetListeners( null );\n\t}\n\n\t// For efficiency reasons we use both a representation as List and as array;\n\t// ensure consistency between the two fields by delegating any mutation to both\n\t// fields to this method.\n\tprivate synchronized void setListeners(T[] newListeners) {\n\t\tthis.listeners = newListeners;\n\t\tif ( newListeners == null || newListeners.length == 0 ) {\n\t\t\tthis.listenersAsList = emptyList();\n\t\t}\n\t\telse {\n\t\t\tthis.listenersAsList = asList( newListeners );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void clearListeners() {\n\t\tsetListeners( null );\n\t}\n\n\t@Override\n\tpublic final <U> void fireLazyEventOnEachListener(final Supplier<U> eventSupplier, final BiConsumer<T,U> actionOnEvent) {\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null && ls.length != 0 ) {\n\t\t\tfinal U event = eventSupplier.get();\n\t\t\t//noinspection ForLoopReplaceableByForEach\n\t\t\tfor ( int i = 0; i < ls.length; i++ ) {\n\t\t\t\tactionOnEvent.accept( ls[i], event );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic final <U> void fireEventOnEachListener(final U event, final BiConsumer<T,U> actionOnEvent) {\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null ) {\n\t\t\t//noinspection ForLoopReplaceableByForEach\n\t\t\tfor ( int i = 0; i < ls.length; i++ ) {\n\t\t\t\tactionOnEvent.accept( ls[i], event );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic <U,X> void fireEventOnEachListener(final U event, final X parameter, final EventActionWithParameter<T, U, X> actionOnEvent) {\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null ) {\n\t\t\t//noinspection ForLoopReplaceableByForEach\n\t\t\tfor ( int i = 0; i < ls.length; i++ ) {\n\t\t\t\tactionOnEvent.applyEventToListener( ls[i], event, parameter );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic <R, U, RL> CompletionStage<R> fireEventOnEachListener(\n\t\t\tfinal U event,\n\t\t\tfinal Function<RL, Function<U, CompletionStage<R>>> fun) {\n\t\tCompletionStage<R> ret = COMPLETED;\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null && ls.length != 0 ) {\n\t\t\tfor ( T listener : ls ) {\n\t\t\t\t//to preserve atomicity of the Session methods\n\t\t\t\t//call apply() from within the arg of thenCompose()\n\t\t\t\tret = ret.thenCompose( v -> fun.apply( (RL) listener ).apply( event ) );\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic <R, U, RL, X> CompletionStage<R> fireEventOnEachListener(\n\t\t\tU event, X param, Function<RL, BiFunction<U, X, CompletionStage<R>>> fun) {\n\t\tCompletionStage<R> ret = COMPLETED;\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null && ls.length != 0 ) {\n\t\t\tfor ( T listener : ls ) {\n\t\t\t\t//to preserve atomicity of the Session methods\n\t\t\t\t//call apply() from within the arg of thenCompose()\n\t\t\t\tret = ret.thenCompose( v -> fun.apply( (RL) listener ).apply( event, param ) );\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic <R, U, RL> CompletionStage<R> fireLazyEventOnEachListener(\n\t\t\tfinal Supplier<U> eventSupplier,\n\t\t\tfinal Function<RL, Function<U, CompletionStage<R>>> fun) {\n\t\tCompletionStage<R> ret = COMPLETED;\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null && ls.length != 0 ) {\n\t\t\tfinal U event = eventSupplier.get();\n\t\t\tfor ( T listener : ls ) {\n\t\t\t\t//to preserve atomicity of the Session methods\n\t\t\t\t//call apply() from within the arg of thenCompose()\n\t\t\t\tret = ret.thenCompose( v -> fun.apply( (RL) listener ).apply( event ) );\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic void addDuplicationStrategy(DuplicationStrategy strategy) {\n\t\tif ( duplicationStrategies == DEFAULT_DUPLICATION_STRATEGIES ) {\n\t\t\tduplicationStrategies = makeDefaultDuplicationStrategy();\n\t\t}\n\t\tduplicationStrategies.add( strategy );\n\t}\n\n\t@Override\n\tpublic void appendListener(T listener) {\n\t\thandleListenerAddition( listener, this::internalAppend );\n\t}\n\n\t@Override\n\t@SafeVarargs\n\tpublic final void appendListeners(T... listeners) {\n\t\t//noinspection ForLoopReplaceableByForEach\n\t\tfor ( int i = 0; i < listeners.length; i++ ) {\n\t\t\thandleListenerAddition( listeners[i], this::internalAppend );\n\t\t}\n\t}\n\n\tprivate void internalAppend(T listener) {\n\t\tprepareListener( listener );\n\t\tfinal T[] listenersRead = this.listeners;\n\t\tfinal T[] listenersWrite;\n\n\t\tif ( listenersRead == null ) {\n\t\t\t//noinspection unchecked\n\t\t\tlistenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), 1 );\n\t\t\tlistenersWrite[0] = listener;\n\t\t}\n\t\telse {\n\t\t\tfinal int size = listenersRead.length;\n\n\t\t\t//noinspection unchecked\n\t\t\tlistenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), size+1 );\n\n\t\t\t// first copy the existing listeners\n\t\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 0, size );\n\n\t\t\t// and then put the new one after them\n\t\t\tlistenersWrite[size] = listener;\n\t\t}\n\t\tsetListeners( listenersWrite );\n\t}\n\n\t@Override\n\tpublic void prependListener(T listener) {\n\t\thandleListenerAddition( listener, this::internalPrepend );\n\t}\n\n\t@Override\n\t@SafeVarargs\n\tpublic final void prependListeners(T... listeners) {\n\t\t//noinspection ForLoopReplaceableByForEach\n\t\tfor ( int i = 0; i < listeners.length; i++ ) {\n\t\t\thandleListenerAddition( listeners[i], this::internalPrepend );\n\t\t}\n\t}\n\n\tprivate void internalPrepend(T listener) {\n\t\tprepareListener( listener );\n\t\tfinal T[] listenersRead = this.listeners;\n\t\tfinal T[] listenersWrite;\n\n\t\tif ( listenersRead == null ) {\n\t\t\t//noinspection unchecked\n\t\t\tlistenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), 1 );\n\t\t\tlistenersWrite[0] = listener;\n\t\t}\n\t\telse {\n\t\t\tfinal int size = listenersRead.length;\n\n\t\t\t//noinspection unchecked\n\t\t\tlistenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), size+1 );\n\n\t\t\t// put the new one first\n\t\t\tlistenersWrite[0] = listener;\n\n\t\t\t// and copy the rest after it\n\t\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 1, size );\n\t\t}\n\t\tsetListeners( listenersWrite );\n\t}\n\n\tprivate void handleListenerAddition(T listener, Consumer<T> additionHandler) {\n\t\tfinal T[] listenersRead = this.listeners;\n\t\tif ( listenersRead == null ) {\n\t\t\tadditionHandler.accept( listener );\n\t\t\treturn;\n\t\t}\n\t\tfinal T[] listenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), listenersRead.length );\n\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 0, listenersRead.length );\n\n\t\tfinal boolean debugEnabled = log.isDebugEnabled();\n\n\t\tfor ( DuplicationStrategy strategy : duplicationStrategies ) {\n\n\t\t\t// for each strategy, see if the strategy indicates that any of the existing\n\t\t\t//\t\tlisteners match the listener being added.  If so, we want to apply that\n\t\t\t//\t\tstrategy's action.  Control it returned immediately after applying the action\n\t\t\t//\t\ton match - meaning no further strategies are checked...\n\n\t\t\tfor ( int i = 0; i < listenersRead.length; i++ ) {\n\t\t\t\tfinal T existingListener = listenersRead[i];\n\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\tlog.debugf(\n\t\t\t\t\t\t\t\"Checking incoming listener [`%s`] for match against existing listener [`%s`]\",\n\t\t\t\t\t\t\tlistener,\n\t\t\t\t\t\t\texistingListener\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif ( strategy.areMatch( listener,  existingListener ) ) {\n\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\tlog.debugf( \"Found listener match between `%s` and `%s`\", listener, existingListener );\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch ( strategy.getAction() ) {\n\t\t\t\t\t\tcase ERROR: {\n\t\t\t\t\t\t\tthrow new EventListenerRegistrationException( \"Duplicate event listener found\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase KEEP_ORIGINAL: {\n\t\t\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\t\t\tlog.debugf( \"Skipping listener registration (%s) : `%s`\", strategy.getAction(), listener );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase REPLACE_ORIGINAL: {\n\t\t\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\t\t\tlog.debugf( \"Replacing listener registration (%s) : `%s` -> `%s`\", strategy.getAction(), existingListener, listener );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tprepareListener( listener );\n\n\t\t\t\t\t\t\tlistenersWrite[i] = listener;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// we've found a match - we should return: the match action has already been applied at this point\n\t\t\t\t\t// apply all pending changes:\n\t\t\t\t\tsetListeners( listenersWrite );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// we did not find any match.. add it\n\t\tcheckAgainstBaseInterface( listener );\n\t\tperformInjections( listener );\n\t\tadditionHandler.accept( listener );\n\t}\n\n\tprivate void prepareListener(T listener) {\n\t\tcheckAgainstBaseInterface( listener );\n\t\tperformInjections( listener );\n\t}\n\n\tprivate void performInjections(T listener) {\n\t\tif ( listener instanceof CallbackRegistryConsumer ) {\n\t\t\t( (CallbackRegistryConsumer) listener ).injectCallbackRegistry( callbackRegistry );\n\t\t}\n\n\t\tif ( listener instanceof JpaBootstrapSensitive ) {\n\t\t\t( (JpaBootstrapSensitive) listener ).wasJpaBootstrap( isJpaBootstrap );\n\t\t}\n\t}\n\n\tprivate void checkAgainstBaseInterface(T listener) {\n\t\tif ( !eventType.baseListenerInterface().isInstance( listener ) ) {\n\t\t\tthrow new EventListenerRegistrationException(\n\t\t\t\t\t\"Listener did not implement expected interface [\" + eventType.baseListenerInterface().getName() + \"]\"\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Implementation note: should be final for performance reasons.\n\t * @deprecated this is not the most efficient way for iterating the event listeners.\n\t * See {@link #fireEventOnEachListener(Object, BiConsumer)} and co. for better alternatives.\n\t */\n\t@Override\n\t@Deprecated\n\tpublic final Iterable<T> listeners() {\n\t\treturn this.listenersAsList;\n\t}\n\n\tprivate static Set<DuplicationStrategy> makeDefaultDuplicationStrategy() {\n\t\tfinal Set<DuplicationStrategy> duplicationStrategies = new LinkedHashSet<>();\n\t\tduplicationStrategies.add(\n\t\t\t\t// At minimum make sure we do not register the same exact listener class multiple times.\n\t\t\t\tnew DuplicationStrategy() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean areMatch(Object listener, Object original) {\n\t\t\t\t\t\treturn listener.getClass().equals( original.getClass() );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Action getAction() {\n\t\t\t\t\t\treturn Action.ERROR;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\treturn duplicationStrategies;\n\t}\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    },
    {
        "type": "Extract Method",
        "description": "Extract Method\tprivate createListenerArrayForWrite(len int) : T[] extracted from private internalPrepend(listener T) : void in class org.hibernate.event.service.internal.EventListenerGroupImpl",
        "diffLocations": [
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerGroupImpl.java",
                "startLine": 252,
                "endLine": 275,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerGroupImpl.java",
                "startLine": 265,
                "endLine": 286,
                "startColumn": 0,
                "endColumn": 0
            },
            {
                "filePath": "hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerGroupImpl.java",
                "startLine": 354,
                "endLine": 357,
                "startColumn": 0,
                "endColumn": 0
            }
        ],
        "sourceCodeBeforeRefactoring": "private void internalPrepend(T listener) {\n\t\tprepareListener( listener );\n\t\tfinal T[] listenersRead = this.listeners;\n\t\tfinal T[] listenersWrite;\n\n\t\tif ( listenersRead == null ) {\n\t\t\t//noinspection unchecked\n\t\t\tlistenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), 1 );\n\t\t\tlistenersWrite[0] = listener;\n\t\t}\n\t\telse {\n\t\t\tfinal int size = listenersRead.length;\n\n\t\t\t//noinspection unchecked\n\t\t\tlistenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), size+1 );\n\n\t\t\t// put the new one first\n\t\t\tlistenersWrite[0] = listener;\n\n\t\t\t// and copy the rest after it\n\t\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 1, size );\n\t\t}\n\t\tsetListeners( listenersWrite );\n\t}",
        "filePathBefore": "hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerGroupImpl.java",
        "isPureRefactoring": true,
        "commitId": "052eb0b78c6d5864e0a1b1ec63b487382c82ec1b",
        "packageNameBefore": "org.hibernate.event.service.internal",
        "classNameBefore": "org.hibernate.event.service.internal.EventListenerGroupImpl",
        "methodNameBefore": "org.hibernate.event.service.internal.EventListenerGroupImpl#internalPrepend",
        "invokedMethod": "methodSignature: org.hibernate.event.service.internal.EventListenerGroupImpl#prepareListener\n methodBody: private void prepareListener(T listener) {\ncheckAgainstBaseInterface(listener);\nperformInjections(listener);\n}\nmethodSignature: org.hibernate.event.service.internal.EventListenerGroupImpl#setListeners\n methodBody: private synchronized void setListeners(T[] newListeners) {\nthis.listeners=newListeners;\nif(newListeners == null || newListeners.length == 0){this.listenersAsList=emptyList();\n}{this.listenersAsList=asList(newListeners);\n}}",
        "classSignatureBefore": "class EventListenerGroupImpl<T> implements EventListenerGroup<T> ",
        "methodNameBeforeSet": [
            "org.hibernate.event.service.internal.EventListenerGroupImpl#internalPrepend"
        ],
        "classNameBeforeSet": [
            "org.hibernate.event.service.internal.EventListenerGroupImpl"
        ],
        "classSignatureBeforeSet": [
            "class EventListenerGroupImpl<T> implements EventListenerGroup<T> "
        ],
        "purityCheckResultList": [
            {
                "isPure": true,
                "purityComment": "Changes are within the Extract Method refactoring mechanics",
                "description": "All replacements have been justified - all mapped",
                "mappingState": 1
            }
        ],
        "sourceCodeBeforeForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.event.service.internal;\n\nimport java.lang.reflect.Array;\nimport java.util.Collections;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.CompletionStage;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiFunction;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\nimport org.hibernate.event.service.spi.DuplicationStrategy;\nimport org.hibernate.event.service.spi.EventActionWithParameter;\nimport org.hibernate.event.service.spi.EventListenerGroup;\nimport org.hibernate.event.service.spi.EventListenerRegistrationException;\nimport org.hibernate.event.service.spi.JpaBootstrapSensitive;\nimport org.hibernate.event.spi.EventType;\nimport org.hibernate.jpa.event.spi.CallbackRegistry;\nimport org.hibernate.jpa.event.spi.CallbackRegistryConsumer;\n\nimport org.jboss.logging.Logger;\n\nimport static java.util.Arrays.asList;\nimport static java.util.Collections.emptyList;\n\n/**\n * Standard EventListenerGroup implementation\n *\n * @author Steve Ebersole\n * @author Sanne Grinovero\n */\nclass EventListenerGroupImpl<T> implements EventListenerGroup<T> {\n\n\tprivate static final Logger log = Logger.getLogger( EventListenerGroupImpl.class );\n\tprivate static final Set<DuplicationStrategy> DEFAULT_DUPLICATION_STRATEGIES = Collections.unmodifiableSet( makeDefaultDuplicationStrategy() );\n\tprivate static final CompletableFuture COMPLETED = CompletableFuture.completedFuture( null );\n\n\tprivate final EventType<T> eventType;\n\tprivate final CallbackRegistry callbackRegistry;\n\tprivate final boolean isJpaBootstrap;\n\n\t//TODO at least the list of listeners should be made constant;\n\t//unfortunately a number of external integrations rely on being able to make\n\t//changes to listeners at runtime, so this will require some planning.\n\tprivate volatile Set<DuplicationStrategy> duplicationStrategies = DEFAULT_DUPLICATION_STRATEGIES;\n\tprivate volatile T[] listeners = null;\n\tprivate volatile List<T> listenersAsList = emptyList();\n\n\tpublic EventListenerGroupImpl(\n\t\t\tEventType<T> eventType,\n\t\t\tCallbackRegistry callbackRegistry,\n\t\t\tboolean isJpaBootstrap) {\n\t\tthis.eventType = eventType;\n\t\tthis.callbackRegistry = callbackRegistry;\n\t\tthis.isJpaBootstrap = isJpaBootstrap;\n\t}\n\n\t@Override\n\tpublic EventType<T> getEventType() {\n\t\treturn eventType;\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn count() <= 0;\n\t}\n\n\t@Override\n\tpublic int count() {\n\t\tfinal T[] ls = listeners;\n\t\treturn ls == null ? 0 : ls.length;\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\t//Odd semantics: we're expected (for backwards compatibility) to also clear the default DuplicationStrategy.\n\t\tduplicationStrategies = new LinkedHashSet<>();\n\t\tsetListeners( null );\n\t}\n\n\t// For efficiency reasons we use both a representation as List and as array;\n\t// ensure consistency between the two fields by delegating any mutation to both\n\t// fields to this method.\n\tprivate synchronized void setListeners(T[] newListeners) {\n\t\tthis.listeners = newListeners;\n\t\tif ( newListeners == null || newListeners.length == 0 ) {\n\t\t\tthis.listenersAsList = emptyList();\n\t\t}\n\t\telse {\n\t\t\tthis.listenersAsList = asList( newListeners );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void clearListeners() {\n\t\tsetListeners( null );\n\t}\n\n\t@Override\n\tpublic final <U> void fireLazyEventOnEachListener(final Supplier<U> eventSupplier, final BiConsumer<T,U> actionOnEvent) {\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null && ls.length != 0 ) {\n\t\t\tfinal U event = eventSupplier.get();\n\t\t\t//noinspection ForLoopReplaceableByForEach\n\t\t\tfor ( int i = 0; i < ls.length; i++ ) {\n\t\t\t\tactionOnEvent.accept( ls[i], event );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic final <U> void fireEventOnEachListener(final U event, final BiConsumer<T,U> actionOnEvent) {\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null ) {\n\t\t\t//noinspection ForLoopReplaceableByForEach\n\t\t\tfor ( int i = 0; i < ls.length; i++ ) {\n\t\t\t\tactionOnEvent.accept( ls[i], event );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic <U,X> void fireEventOnEachListener(final U event, final X parameter, final EventActionWithParameter<T, U, X> actionOnEvent) {\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null ) {\n\t\t\t//noinspection ForLoopReplaceableByForEach\n\t\t\tfor ( int i = 0; i < ls.length; i++ ) {\n\t\t\t\tactionOnEvent.applyEventToListener( ls[i], event, parameter );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic <R, U, RL> CompletionStage<R> fireEventOnEachListener(\n\t\t\tfinal U event,\n\t\t\tfinal Function<RL, Function<U, CompletionStage<R>>> fun) {\n\t\tCompletionStage<R> ret = COMPLETED;\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null && ls.length != 0 ) {\n\t\t\tfor ( T listener : ls ) {\n\t\t\t\t//to preserve atomicity of the Session methods\n\t\t\t\t//call apply() from within the arg of thenCompose()\n\t\t\t\tret = ret.thenCompose( v -> fun.apply( (RL) listener ).apply( event ) );\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic <R, U, RL, X> CompletionStage<R> fireEventOnEachListener(\n\t\t\tU event, X param, Function<RL, BiFunction<U, X, CompletionStage<R>>> fun) {\n\t\tCompletionStage<R> ret = COMPLETED;\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null && ls.length != 0 ) {\n\t\t\tfor ( T listener : ls ) {\n\t\t\t\t//to preserve atomicity of the Session methods\n\t\t\t\t//call apply() from within the arg of thenCompose()\n\t\t\t\tret = ret.thenCompose( v -> fun.apply( (RL) listener ).apply( event, param ) );\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic <R, U, RL> CompletionStage<R> fireLazyEventOnEachListener(\n\t\t\tfinal Supplier<U> eventSupplier,\n\t\t\tfinal Function<RL, Function<U, CompletionStage<R>>> fun) {\n\t\tCompletionStage<R> ret = COMPLETED;\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null && ls.length != 0 ) {\n\t\t\tfinal U event = eventSupplier.get();\n\t\t\tfor ( T listener : ls ) {\n\t\t\t\t//to preserve atomicity of the Session methods\n\t\t\t\t//call apply() from within the arg of thenCompose()\n\t\t\t\tret = ret.thenCompose( v -> fun.apply( (RL) listener ).apply( event ) );\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic void addDuplicationStrategy(DuplicationStrategy strategy) {\n\t\tif ( duplicationStrategies == DEFAULT_DUPLICATION_STRATEGIES ) {\n\t\t\tduplicationStrategies = makeDefaultDuplicationStrategy();\n\t\t}\n\t\tduplicationStrategies.add( strategy );\n\t}\n\n\t@Override\n\tpublic void appendListener(T listener) {\n\t\thandleListenerAddition( listener, this::internalAppend );\n\t}\n\n\t@Override\n\t@SafeVarargs\n\tpublic final void appendListeners(T... listeners) {\n\t\t//noinspection ForLoopReplaceableByForEach\n\t\tfor ( int i = 0; i < listeners.length; i++ ) {\n\t\t\thandleListenerAddition( listeners[i], this::internalAppend );\n\t\t}\n\t}\n\n\tprivate void internalAppend(T listener) {\n\t\tprepareListener( listener );\n\t\tfinal T[] listenersRead = this.listeners;\n\t\tfinal T[] listenersWrite;\n\n\t\tif ( listenersRead == null ) {\n\t\t\t//noinspection unchecked\n\t\t\tlistenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), 1 );\n\t\t\tlistenersWrite[0] = listener;\n\t\t}\n\t\telse {\n\t\t\tfinal int size = listenersRead.length;\n\n\t\t\t//noinspection unchecked\n\t\t\tlistenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), size+1 );\n\n\t\t\t// first copy the existing listeners\n\t\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 0, size );\n\n\t\t\t// and then put the new one after them\n\t\t\tlistenersWrite[size] = listener;\n\t\t}\n\t\tsetListeners( listenersWrite );\n\t}\n\n\t@Override\n\tpublic void prependListener(T listener) {\n\t\thandleListenerAddition( listener, this::internalPrepend );\n\t}\n\n\t@Override\n\t@SafeVarargs\n\tpublic final void prependListeners(T... listeners) {\n\t\t//noinspection ForLoopReplaceableByForEach\n\t\tfor ( int i = 0; i < listeners.length; i++ ) {\n\t\t\thandleListenerAddition( listeners[i], this::internalPrepend );\n\t\t}\n\t}\n\n\tprivate void internalPrepend(T listener) {\n\t\tprepareListener( listener );\n\t\tfinal T[] listenersRead = this.listeners;\n\t\tfinal T[] listenersWrite;\n\n\t\tif ( listenersRead == null ) {\n\t\t\t//noinspection unchecked\n\t\t\tlistenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), 1 );\n\t\t\tlistenersWrite[0] = listener;\n\t\t}\n\t\telse {\n\t\t\tfinal int size = listenersRead.length;\n\n\t\t\t//noinspection unchecked\n\t\t\tlistenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), size+1 );\n\n\t\t\t// put the new one first\n\t\t\tlistenersWrite[0] = listener;\n\n\t\t\t// and copy the rest after it\n\t\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 1, size );\n\t\t}\n\t\tsetListeners( listenersWrite );\n\t}\n\n\tprivate void handleListenerAddition(T listener, Consumer<T> additionHandler) {\n\t\tfinal T[] listenersRead = this.listeners;\n\t\tif ( listenersRead == null ) {\n\t\t\tadditionHandler.accept( listener );\n\t\t\treturn;\n\t\t}\n\t\tfinal T[] listenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), listenersRead.length );\n\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 0, listenersRead.length );\n\n\t\tfinal boolean debugEnabled = log.isDebugEnabled();\n\n\t\tfor ( DuplicationStrategy strategy : duplicationStrategies ) {\n\n\t\t\t// for each strategy, see if the strategy indicates that any of the existing\n\t\t\t//\t\tlisteners match the listener being added.  If so, we want to apply that\n\t\t\t//\t\tstrategy's action.  Control it returned immediately after applying the action\n\t\t\t//\t\ton match - meaning no further strategies are checked...\n\n\t\t\tfor ( int i = 0; i < listenersRead.length; i++ ) {\n\t\t\t\tfinal T existingListener = listenersRead[i];\n\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\tlog.debugf(\n\t\t\t\t\t\t\t\"Checking incoming listener [`%s`] for match against existing listener [`%s`]\",\n\t\t\t\t\t\t\tlistener,\n\t\t\t\t\t\t\texistingListener\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif ( strategy.areMatch( listener,  existingListener ) ) {\n\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\tlog.debugf( \"Found listener match between `%s` and `%s`\", listener, existingListener );\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch ( strategy.getAction() ) {\n\t\t\t\t\t\tcase ERROR: {\n\t\t\t\t\t\t\tthrow new EventListenerRegistrationException( \"Duplicate event listener found\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase KEEP_ORIGINAL: {\n\t\t\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\t\t\tlog.debugf( \"Skipping listener registration (%s) : `%s`\", strategy.getAction(), listener );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase REPLACE_ORIGINAL: {\n\t\t\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\t\t\tlog.debugf( \"Replacing listener registration (%s) : `%s` -> `%s`\", strategy.getAction(), existingListener, listener );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tprepareListener( listener );\n\n\t\t\t\t\t\t\tlistenersWrite[i] = listener;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// we've found a match - we should return: the match action has already been applied at this point\n\t\t\t\t\t// apply all pending changes:\n\t\t\t\t\tsetListeners( listenersWrite );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// we did not find any match.. add it\n\t\tcheckAgainstBaseInterface( listener );\n\t\tperformInjections( listener );\n\t\tadditionHandler.accept( listener );\n\t}\n\n\tprivate void prepareListener(T listener) {\n\t\tcheckAgainstBaseInterface( listener );\n\t\tperformInjections( listener );\n\t}\n\n\tprivate void performInjections(T listener) {\n\t\tif ( listener instanceof CallbackRegistryConsumer ) {\n\t\t\t( (CallbackRegistryConsumer) listener ).injectCallbackRegistry( callbackRegistry );\n\t\t}\n\n\t\tif ( listener instanceof JpaBootstrapSensitive ) {\n\t\t\t( (JpaBootstrapSensitive) listener ).wasJpaBootstrap( isJpaBootstrap );\n\t\t}\n\t}\n\n\tprivate void checkAgainstBaseInterface(T listener) {\n\t\tif ( !eventType.baseListenerInterface().isInstance( listener ) ) {\n\t\t\tthrow new EventListenerRegistrationException(\n\t\t\t\t\t\"Listener did not implement expected interface [\" + eventType.baseListenerInterface().getName() + \"]\"\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Implementation note: should be final for performance reasons.\n\t * @deprecated this is not the most efficient way for iterating the event listeners.\n\t * See {@link #fireEventOnEachListener(Object, BiConsumer)} and co. for better alternatives.\n\t */\n\t@Override\n\t@Deprecated\n\tpublic final Iterable<T> listeners() {\n\t\treturn this.listenersAsList;\n\t}\n\n\tprivate static Set<DuplicationStrategy> makeDefaultDuplicationStrategy() {\n\t\tfinal Set<DuplicationStrategy> duplicationStrategies = new LinkedHashSet<>();\n\t\tduplicationStrategies.add(\n\t\t\t\t// At minimum make sure we do not register the same exact listener class multiple times.\n\t\t\t\tnew DuplicationStrategy() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean areMatch(Object listener, Object original) {\n\t\t\t\t\t\treturn listener.getClass().equals( original.getClass() );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Action getAction() {\n\t\t\t\t\t\treturn Action.ERROR;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\treturn duplicationStrategies;\n\t}\n\n}\n",
        "filePathAfter": "hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerGroupImpl.java",
        "sourceCodeAfterForWhole": "/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.event.service.internal;\n\nimport java.lang.reflect.Array;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.CompletionStage;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiFunction;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\nimport org.hibernate.event.service.spi.DuplicationStrategy;\nimport org.hibernate.event.service.spi.EventActionWithParameter;\nimport org.hibernate.event.service.spi.EventListenerGroup;\nimport org.hibernate.event.service.spi.EventListenerRegistrationException;\nimport org.hibernate.event.service.spi.JpaBootstrapSensitive;\nimport org.hibernate.event.spi.EventType;\nimport org.hibernate.jpa.event.spi.CallbackRegistry;\nimport org.hibernate.jpa.event.spi.CallbackRegistryConsumer;\n\nimport org.jboss.logging.Logger;\n\nimport static java.util.Arrays.asList;\nimport static java.util.Collections.emptyList;\nimport static java.util.Collections.singleton;\nimport static java.util.concurrent.CompletableFuture.completedFuture;\n\n/**\n * Standard EventListenerGroup implementation\n *\n * @author Steve Ebersole\n * @author Sanne Grinovero\n */\nclass EventListenerGroupImpl<T> implements EventListenerGroup<T> {\n\n\tprivate static final Logger log = Logger.getLogger( EventListenerGroupImpl.class );\n\n\tprivate static final DuplicationStrategy DEFAULT_DUPLICATION_STRATEGY =\n\t\t\tnew DuplicationStrategy() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean areMatch(Object listener, Object original) {\n\t\t\t\t\treturn listener.getClass().equals( original.getClass() );\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic Action getAction() {\n\t\t\t\t\treturn Action.ERROR;\n\t\t\t\t}\n\t\t\t};\n\tprivate static final Set<DuplicationStrategy> DEFAULT_DUPLICATION_STRATEGIES =\n\t\t\tsingleton( DEFAULT_DUPLICATION_STRATEGY );\n\n\tprivate static final CompletableFuture<?> COMPLETED = completedFuture( null );\n\t@SuppressWarnings(\"unchecked\")\n\tprivate static <R> CompletableFuture<R> nullCompletion() {\n\t\treturn (CompletableFuture<R>) COMPLETED;\n\t}\n\n\tprivate final EventType<T> eventType;\n\tprivate final CallbackRegistry callbackRegistry;\n\tprivate final boolean isJpaBootstrap;\n\n\t//TODO at least the list of listeners should be made constant;\n\t//unfortunately a number of external integrations rely on being able to make\n\t//changes to listeners at runtime, so this will require some planning.\n\tprivate volatile Set<DuplicationStrategy> duplicationStrategies = DEFAULT_DUPLICATION_STRATEGIES;\n\tprivate volatile T[] listeners = null;\n\tprivate volatile List<T> listenersAsList = emptyList();\n\n\tpublic EventListenerGroupImpl(EventType<T> eventType, CallbackRegistry callbackRegistry, boolean isJpaBootstrap) {\n\t\tthis.eventType = eventType;\n\t\tthis.callbackRegistry = callbackRegistry;\n\t\tthis.isJpaBootstrap = isJpaBootstrap;\n\t}\n\n\t@Override\n\tpublic EventType<T> getEventType() {\n\t\treturn eventType;\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn count() <= 0;\n\t}\n\n\t@Override\n\tpublic int count() {\n\t\tfinal T[] ls = listeners;\n\t\treturn ls == null ? 0 : ls.length;\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\t//Odd semantics: we're expected (for backwards compatibility)\n\t\t//               to also clear the default DuplicationStrategy.\n\t\tduplicationStrategies = new LinkedHashSet<>();\n\t\tsetListeners( null );\n\t}\n\n\t// For efficiency reasons we use both a representation as List and as array;\n\t// ensure consistency between the two fields by delegating any mutation to both\n\t// fields to this method.\n\tprivate synchronized void setListeners(T[] newListeners) {\n\t\tlisteners = newListeners;\n\t\tlistenersAsList = newListeners == null || newListeners.length == 0\n\t\t\t\t? emptyList()\n\t\t\t\t: asList( newListeners );\n\t}\n\n\t@Override\n\tpublic void clearListeners() {\n\t\tsetListeners( null );\n\t}\n\n\t@Override\n\tpublic final <U> void fireLazyEventOnEachListener(Supplier<U> eventSupplier, BiConsumer<T,U> actionOnEvent) {\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null && ls.length != 0 ) {\n\t\t\tfinal U event = eventSupplier.get();\n\t\t\t//noinspection ForLoopReplaceableByForEach\n\t\t\tfor ( int i = 0; i < ls.length; i++ ) {\n\t\t\t\tactionOnEvent.accept( ls[i], event );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic final <U> void fireEventOnEachListener(U event, BiConsumer<T,U> actionOnEvent) {\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null ) {\n\t\t\t//noinspection ForLoopReplaceableByForEach\n\t\t\tfor ( int i = 0; i < ls.length; i++ ) {\n\t\t\t\tactionOnEvent.accept( ls[i], event );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic <U,X> void fireEventOnEachListener(U event, X parameter, EventActionWithParameter<T, U, X> actionOnEvent) {\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null ) {\n\t\t\t//noinspection ForLoopReplaceableByForEach\n\t\t\tfor ( int i = 0; i < ls.length; i++ ) {\n\t\t\t\tactionOnEvent.applyEventToListener( ls[i], event, parameter );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic <R, U, RL> CompletionStage<R> fireEventOnEachListener(\n\t\t\tfinal U event,\n\t\t\tfinal Function<RL, Function<U, CompletionStage<R>>> fun) {\n\t\tCompletionStage<R> ret = nullCompletion();\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null ) {\n\t\t\tfor ( T listener : ls ) {\n\t\t\t\t//to preserve atomicity of the Session methods\n\t\t\t\t//call apply() from within the arg of thenCompose()\n\t\t\t\tret = ret.thenCompose( v -> fun.apply( (RL) listener ).apply( event ) );\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic <R, U, RL, X> CompletionStage<R> fireEventOnEachListener(\n\t\t\tU event, X param, Function<RL, BiFunction<U, X, CompletionStage<R>>> fun) {\n\t\tCompletionStage<R> ret = nullCompletion();\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null ) {\n\t\t\tfor ( T listener : ls ) {\n\t\t\t\t//to preserve atomicity of the Session methods\n\t\t\t\t//call apply() from within the arg of thenCompose()\n\t\t\t\tret = ret.thenCompose( v -> fun.apply( (RL) listener ).apply( event, param ) );\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic <R, U, RL> CompletionStage<R> fireLazyEventOnEachListener(\n\t\t\tSupplier<U> eventSupplier,\n\t\t\tFunction<RL, Function<U, CompletionStage<R>>> fun) {\n\t\tCompletionStage<R> ret = nullCompletion();\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null && ls.length != 0 ) {\n\t\t\tfinal U event = eventSupplier.get();\n\t\t\tfor ( T listener : ls ) {\n\t\t\t\t//to preserve atomicity of the Session methods\n\t\t\t\t//call apply() from within the arg of thenCompose()\n\t\t\t\tret = ret.thenCompose( v -> fun.apply( (RL) listener ).apply( event ) );\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic void addDuplicationStrategy(DuplicationStrategy strategy) {\n\t\tif ( duplicationStrategies == DEFAULT_DUPLICATION_STRATEGIES ) {\n\t\t\t// At minimum make sure we do not register the same exact listener class multiple times.\n\t\t\tduplicationStrategies = new LinkedHashSet<>( DEFAULT_DUPLICATION_STRATEGIES );\n\t\t}\n\t\tduplicationStrategies.add( strategy );\n\t}\n\n\t@Override\n\tpublic void appendListener(T listener) {\n\t\thandleListenerAddition( listener, this::internalAppend );\n\t}\n\n\t@Override\n\t@SafeVarargs\n\tpublic final void appendListeners(T... listeners) {\n\t\t//noinspection ForLoopReplaceableByForEach\n\t\tfor ( int i = 0; i < listeners.length; i++ ) {\n\t\t\thandleListenerAddition( listeners[i], this::internalAppend );\n\t\t}\n\t}\n\n\tprivate void internalAppend(T listener) {\n\t\tprepareListener( listener );\n\t\tfinal T[] listenersRead = listeners;\n\t\tfinal T[] listenersWrite;\n\n\t\tif ( listenersRead == null ) {\n\t\t\tlistenersWrite = createListenerArrayForWrite( 1 );\n\t\t\tlistenersWrite[0] = listener;\n\t\t}\n\t\telse {\n\t\t\tfinal int size = listenersRead.length;\n\n\t\t\tlistenersWrite = createListenerArrayForWrite( size + 1 );\n\n\t\t\t// first copy the existing listeners\n\t\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 0, size );\n\n\t\t\t// and then put the new one after them\n\t\t\tlistenersWrite[size] = listener;\n\t\t}\n\t\tsetListeners( listenersWrite );\n\t}\n\n\t@Override\n\tpublic void prependListener(T listener) {\n\t\thandleListenerAddition( listener, this::internalPrepend );\n\t}\n\n\t@Override\n\t@SafeVarargs\n\tpublic final void prependListeners(T... listeners) {\n\t\t//noinspection ForLoopReplaceableByForEach\n\t\tfor ( int i = 0; i < listeners.length; i++ ) {\n\t\t\thandleListenerAddition( listeners[i], this::internalPrepend );\n\t\t}\n\t}\n\n\tprivate void internalPrepend(T listener) {\n\t\tprepareListener( listener );\n\t\tfinal T[] listenersRead = listeners;\n\t\tfinal T[] listenersWrite;\n\n\t\tif ( listenersRead == null ) {\n\t\t\tlistenersWrite = createListenerArrayForWrite( 1 );\n\t\t\tlistenersWrite[0] = listener;\n\t\t}\n\t\telse {\n\t\t\tfinal int size = listenersRead.length;\n\n\t\t\tlistenersWrite = createListenerArrayForWrite( size + 1 );\n\n\t\t\t// put the new one first\n\t\t\tlistenersWrite[0] = listener;\n\n\t\t\t// and copy the rest after it\n\t\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 1, size );\n\t\t}\n\t\tsetListeners( listenersWrite );\n\t}\n\n\tprivate void handleListenerAddition(T listener, Consumer<T> additionHandler) {\n\t\tfinal T[] listenersRead = listeners;\n\t\tif ( listenersRead == null ) {\n\t\t\tadditionHandler.accept( listener );\n\t\t\treturn;\n\t\t}\n\t\tint size = listenersRead.length;\n\n\t\tfinal T[] listenersWrite = createListenerArrayForWrite( size );\n\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 0, size );\n\n\t\tfinal boolean debugEnabled = log.isDebugEnabled();\n\n\t\tfor ( DuplicationStrategy strategy : duplicationStrategies ) {\n\n\t\t\t// for each strategy, see if the strategy indicates that any of the existing\n\t\t\t//\t\tlisteners match the listener being added.  If so, we want to apply that\n\t\t\t//\t\tstrategy's action.  Control it returned immediately after applying the action\n\t\t\t//\t\ton match - meaning no further strategies are checked...\n\n\t\t\tfor ( int i = 0; i < size; i++ ) {\n\t\t\t\tfinal T existingListener = listenersRead[i];\n\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\tlog.debugf( \"Checking incoming listener [`%s`] for match against existing listener [`%s`]\",\n\t\t\t\t\t\t\tlistener, existingListener );\n\t\t\t\t}\n\n\t\t\t\tif ( strategy.areMatch( listener,  existingListener ) ) {\n\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\tlog.debugf( \"Found listener match between `%s` and `%s`\",\n\t\t\t\t\t\t\t\tlistener, existingListener );\n\t\t\t\t\t}\n\n\t\t\t\t\tfinal DuplicationStrategy.Action action = strategy.getAction();\n\t\t\t\t\tswitch (action) {\n\t\t\t\t\t\tcase ERROR:\n\t\t\t\t\t\t\tthrow new EventListenerRegistrationException( \"Duplicate event listener found\" );\n\t\t\t\t\t\tcase KEEP_ORIGINAL:\n\t\t\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\t\t\tlog.debugf( \"Skipping listener registration (%s) : `%s`\",\n\t\t\t\t\t\t\t\t\t\taction, listener );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tcase REPLACE_ORIGINAL:\n\t\t\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\t\t\tlog.debugf( \"Replacing listener registration (%s) : `%s` -> `%s`\",\n\t\t\t\t\t\t\t\t\t\taction, existingListener, listener );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tprepareListener( listener );\n\t\t\t\t\t\t\tlistenersWrite[i] = listener;\n\t\t\t\t\t}\n\n\t\t\t\t\t// we've found a match - we should return: the match action has already been applied at this point\n\t\t\t\t\t// apply all pending changes:\n\t\t\t\t\tsetListeners( listenersWrite );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// we did not find any match, add it\n\t\tcheckAgainstBaseInterface( listener );\n\t\tperformInjections( listener );\n\t\tadditionHandler.accept( listener );\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate T[] createListenerArrayForWrite(int len) {\n\t\treturn (T[]) Array.newInstance( eventType.baseListenerInterface(), len );\n\t}\n\n\tprivate void prepareListener(T listener) {\n\t\tcheckAgainstBaseInterface( listener );\n\t\tperformInjections( listener );\n\t}\n\n\tprivate void performInjections(T listener) {\n\t\tif ( listener instanceof CallbackRegistryConsumer consumer ) {\n\t\t\tconsumer.injectCallbackRegistry( callbackRegistry );\n\t\t}\n\t\tif ( listener instanceof JpaBootstrapSensitive sensitive ) {\n\t\t\tsensitive.wasJpaBootstrap( isJpaBootstrap );\n\t\t}\n\t}\n\n\tprivate void checkAgainstBaseInterface(T listener) {\n\t\tif ( !eventType.baseListenerInterface().isInstance( listener ) ) {\n\t\t\tthrow new EventListenerRegistrationException( \"Listener did not implement expected interface [\"\n\t\t\t\t\t+ eventType.baseListenerInterface().getName() + \"]\" );\n\t\t}\n\t}\n\n\t/**\n\t * Implementation note: should be final for performance reasons.\n\t * @deprecated this is not the most efficient way for iterating the event listeners.\n\t * See {@link #fireEventOnEachListener(Object, BiConsumer)} and co. for better alternatives.\n\t */\n\t@Override\n\t@Deprecated\n\tpublic final Iterable<T> listeners() {\n\t\treturn listenersAsList;\n\t}\n}\n",
        "diffSourceCodeSet": [
            "@SuppressWarnings(\"unchecked\")\n\tprivate T[] createListenerArrayForWrite(int len) {\n\t\treturn (T[]) Array.newInstance( eventType.baseListenerInterface(), len );\n\t}"
        ],
        "invokedMethodSet": [
            "methodSignature: org.hibernate.event.service.internal.EventListenerGroupImpl#prepareListener\n methodBody: private void prepareListener(T listener) {\ncheckAgainstBaseInterface(listener);\nperformInjections(listener);\n}",
            "methodSignature: org.hibernate.event.service.internal.EventListenerGroupImpl#setListeners\n methodBody: private synchronized void setListeners(T[] newListeners) {\nthis.listeners=newListeners;\nif(newListeners == null || newListeners.length == 0){this.listenersAsList=emptyList();\n}{this.listenersAsList=asList(newListeners);\n}}"
        ],
        "sourceCodeAfterRefactoring": "private void internalPrepend(T listener) {\n\t\tprepareListener( listener );\n\t\tfinal T[] listenersRead = listeners;\n\t\tfinal T[] listenersWrite;\n\n\t\tif ( listenersRead == null ) {\n\t\t\tlistenersWrite = createListenerArrayForWrite( 1 );\n\t\t\tlistenersWrite[0] = listener;\n\t\t}\n\t\telse {\n\t\t\tfinal int size = listenersRead.length;\n\n\t\t\tlistenersWrite = createListenerArrayForWrite( size + 1 );\n\n\t\t\t// put the new one first\n\t\t\tlistenersWrite[0] = listener;\n\n\t\t\t// and copy the rest after it\n\t\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 1, size );\n\t\t}\n\t\tsetListeners( listenersWrite );\n\t}\n@SuppressWarnings(\"unchecked\")\n\tprivate T[] createListenerArrayForWrite(int len) {\n\t\treturn (T[]) Array.newInstance( eventType.baseListenerInterface(), len );\n\t}",
        "diffSourceCode": "-  252: \tprivate void internalPrepend(T listener) {\n-  253: \t\tprepareListener( listener );\n-  254: \t\tfinal T[] listenersRead = this.listeners;\n-  255: \t\tfinal T[] listenersWrite;\n-  256: \n-  257: \t\tif ( listenersRead == null ) {\n-  258: \t\t\t//noinspection unchecked\n-  259: \t\t\tlistenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), 1 );\n-  260: \t\t\tlistenersWrite[0] = listener;\n-  261: \t\t}\n-  262: \t\telse {\n-  263: \t\t\tfinal int size = listenersRead.length;\n+  252: \tpublic void prependListener(T listener) {\n+  253: \t\thandleListenerAddition( listener, this::internalPrepend );\n+  254: \t}\n+  255: \n+  256: \t@Override\n+  257: \t@SafeVarargs\n+  258: \tpublic final void prependListeners(T... listeners) {\n+  259: \t\t//noinspection ForLoopReplaceableByForEach\n+  260: \t\tfor ( int i = 0; i < listeners.length; i++ ) {\n+  261: \t\t\thandleListenerAddition( listeners[i], this::internalPrepend );\n+  262: \t\t}\n+  263: \t}\n   264: \n-  265: \t\t\t//noinspection unchecked\n-  266: \t\t\tlistenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), size+1 );\n-  267: \n-  268: \t\t\t// put the new one first\n-  269: \t\t\tlistenersWrite[0] = listener;\n-  270: \n-  271: \t\t\t// and copy the rest after it\n-  272: \t\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 1, size );\n+  265: \tprivate void internalPrepend(T listener) {\n+  266: \t\tprepareListener( listener );\n+  267: \t\tfinal T[] listenersRead = listeners;\n+  268: \t\tfinal T[] listenersWrite;\n+  269: \n+  270: \t\tif ( listenersRead == null ) {\n+  271: \t\t\tlistenersWrite = createListenerArrayForWrite( 1 );\n+  272: \t\t\tlistenersWrite[0] = listener;\n   273: \t\t}\n-  274: \t\tsetListeners( listenersWrite );\n-  275: \t}\n+  274: \t\telse {\n+  275: \t\t\tfinal int size = listenersRead.length;\n   276: \n-  277: \tprivate void handleListenerAddition(T listener, Consumer<T> additionHandler) {\n-  278: \t\tfinal T[] listenersRead = this.listeners;\n-  279: \t\tif ( listenersRead == null ) {\n-  280: \t\t\tadditionHandler.accept( listener );\n-  281: \t\t\treturn;\n-  282: \t\t}\n-  283: \t\tfinal T[] listenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), listenersRead.length );\n-  284: \t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 0, listenersRead.length );\n-  285: \n-  286: \t\tfinal boolean debugEnabled = log.isDebugEnabled();\n-  354: \t\tif ( listener instanceof JpaBootstrapSensitive ) {\n-  355: \t\t\t( (JpaBootstrapSensitive) listener ).wasJpaBootstrap( isJpaBootstrap );\n-  356: \t\t}\n+  277: \t\t\tlistenersWrite = createListenerArrayForWrite( size + 1 );\n+  278: \n+  279: \t\t\t// put the new one first\n+  280: \t\t\tlistenersWrite[0] = listener;\n+  281: \n+  282: \t\t\t// and copy the rest after it\n+  283: \t\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 1, size );\n+  284: \t\t}\n+  285: \t\tsetListeners( listenersWrite );\n+  286: \t}\n+  354: \t@SuppressWarnings(\"unchecked\")\n+  355: \tprivate T[] createListenerArrayForWrite(int len) {\n+  356: \t\treturn (T[]) Array.newInstance( eventType.baseListenerInterface(), len );\n   357: \t}\n",
        "uniqueId": "052eb0b78c6d5864e0a1b1ec63b487382c82ec1b_252_275_354_357_265_286",
        "moveFileExist": true,
        "compileResultBefore": true,
        "compileResultCurrent": true,
        "compileJDK": 21,
        "testResult": true,
        "coverageInfo": {
            "INSTRUCTION": {
                "missed": 9,
                "covered": 31
            },
            "BRANCH": {
                "missed": 1,
                "covered": 1
            },
            "LINE": {
                "missed": 2,
                "covered": 9
            },
            "COMPLEXITY": {
                "missed": 1,
                "covered": 1
            },
            "METHOD": {
                "missed": 0,
                "covered": 1
            }
        },
        "refactoringMinerResult": false,
        "compileAndTestResult": false,
        "refactoredCode": "##########################\nprivate void prepareListener(T listener) {\n    checkAgainstBaseInterface(listener);\n    performInjections(listener);\n}\n##########################",
        "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprivate void internalPrepend(T listener) {\n\t\tprepareListener( listener );\n\t\tfinal T[] listenersRead = this.listeners;\n\t\tfinal T[] listenersWrite;\n\n\t\tif ( listenersRead == null ) {\n\t\t\t//noinspection unchecked\n\t\t\tlistenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), 1 );\n\t\t\tlistenersWrite[0] = listener;\n\t\t}\n\t\telse {\n\t\t\tfinal int size = listenersRead.length;\n\n\t\t\t//noinspection unchecked\n\t\t\tlistenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), size+1 );\n\n\t\t\t// put the new one first\n\t\t\tlistenersWrite[0] = listener;\n\n\t\t\t// and copy the rest after it\n\t\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 1, size );\n\t\t}\n\t\tsetListeners( listenersWrite );\n\t}\n\nClass content:\n/*\n * Hibernate, Relational Persistence for Idiomatic Java\n *\n * License: GNU Lesser General Public License (LGPL), version 2.1 or later.\n * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.\n */\npackage org.hibernate.event.service.internal;\n\nimport java.lang.reflect.Array;\nimport java.util.Collections;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.CompletionStage;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiFunction;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\nimport org.hibernate.event.service.spi.DuplicationStrategy;\nimport org.hibernate.event.service.spi.EventActionWithParameter;\nimport org.hibernate.event.service.spi.EventListenerGroup;\nimport org.hibernate.event.service.spi.EventListenerRegistrationException;\nimport org.hibernate.event.service.spi.JpaBootstrapSensitive;\nimport org.hibernate.event.spi.EventType;\nimport org.hibernate.jpa.event.spi.CallbackRegistry;\nimport org.hibernate.jpa.event.spi.CallbackRegistryConsumer;\n\nimport org.jboss.logging.Logger;\n\nimport static java.util.Arrays.asList;\nimport static java.util.Collections.emptyList;\n\n/**\n * Standard EventListenerGroup implementation\n *\n * @author Steve Ebersole\n * @author Sanne Grinovero\n */\nclass EventListenerGroupImpl<T> implements EventListenerGroup<T> {\n\n\tprivate static final Logger log = Logger.getLogger( EventListenerGroupImpl.class );\n\tprivate static final Set<DuplicationStrategy> DEFAULT_DUPLICATION_STRATEGIES = Collections.unmodifiableSet( makeDefaultDuplicationStrategy() );\n\tprivate static final CompletableFuture COMPLETED = CompletableFuture.completedFuture( null );\n\n\tprivate final EventType<T> eventType;\n\tprivate final CallbackRegistry callbackRegistry;\n\tprivate final boolean isJpaBootstrap;\n\n\t//TODO at least the list of listeners should be made constant;\n\t//unfortunately a number of external integrations rely on being able to make\n\t//changes to listeners at runtime, so this will require some planning.\n\tprivate volatile Set<DuplicationStrategy> duplicationStrategies = DEFAULT_DUPLICATION_STRATEGIES;\n\tprivate volatile T[] listeners = null;\n\tprivate volatile List<T> listenersAsList = emptyList();\n\n\tpublic EventListenerGroupImpl(\n\t\t\tEventType<T> eventType,\n\t\t\tCallbackRegistry callbackRegistry,\n\t\t\tboolean isJpaBootstrap) {\n\t\tthis.eventType = eventType;\n\t\tthis.callbackRegistry = callbackRegistry;\n\t\tthis.isJpaBootstrap = isJpaBootstrap;\n\t}\n\n\t@Override\n\tpublic EventType<T> getEventType() {\n\t\treturn eventType;\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn count() <= 0;\n\t}\n\n\t@Override\n\tpublic int count() {\n\t\tfinal T[] ls = listeners;\n\t\treturn ls == null ? 0 : ls.length;\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\t//Odd semantics: we're expected (for backwards compatibility) to also clear the default DuplicationStrategy.\n\t\tduplicationStrategies = new LinkedHashSet<>();\n\t\tsetListeners( null );\n\t}\n\n\t// For efficiency reasons we use both a representation as List and as array;\n\t// ensure consistency between the two fields by delegating any mutation to both\n\t// fields to this method.\n\tprivate synchronized void setListeners(T[] newListeners) {\n\t\tthis.listeners = newListeners;\n\t\tif ( newListeners == null || newListeners.length == 0 ) {\n\t\t\tthis.listenersAsList = emptyList();\n\t\t}\n\t\telse {\n\t\t\tthis.listenersAsList = asList( newListeners );\n\t\t}\n\t}\n\n\t@Override\n\tpublic void clearListeners() {\n\t\tsetListeners( null );\n\t}\n\n\t@Override\n\tpublic final <U> void fireLazyEventOnEachListener(final Supplier<U> eventSupplier, final BiConsumer<T,U> actionOnEvent) {\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null && ls.length != 0 ) {\n\t\t\tfinal U event = eventSupplier.get();\n\t\t\t//noinspection ForLoopReplaceableByForEach\n\t\t\tfor ( int i = 0; i < ls.length; i++ ) {\n\t\t\t\tactionOnEvent.accept( ls[i], event );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic final <U> void fireEventOnEachListener(final U event, final BiConsumer<T,U> actionOnEvent) {\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null ) {\n\t\t\t//noinspection ForLoopReplaceableByForEach\n\t\t\tfor ( int i = 0; i < ls.length; i++ ) {\n\t\t\t\tactionOnEvent.accept( ls[i], event );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic <U,X> void fireEventOnEachListener(final U event, final X parameter, final EventActionWithParameter<T, U, X> actionOnEvent) {\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null ) {\n\t\t\t//noinspection ForLoopReplaceableByForEach\n\t\t\tfor ( int i = 0; i < ls.length; i++ ) {\n\t\t\t\tactionOnEvent.applyEventToListener( ls[i], event, parameter );\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic <R, U, RL> CompletionStage<R> fireEventOnEachListener(\n\t\t\tfinal U event,\n\t\t\tfinal Function<RL, Function<U, CompletionStage<R>>> fun) {\n\t\tCompletionStage<R> ret = COMPLETED;\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null && ls.length != 0 ) {\n\t\t\tfor ( T listener : ls ) {\n\t\t\t\t//to preserve atomicity of the Session methods\n\t\t\t\t//call apply() from within the arg of thenCompose()\n\t\t\t\tret = ret.thenCompose( v -> fun.apply( (RL) listener ).apply( event ) );\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic <R, U, RL, X> CompletionStage<R> fireEventOnEachListener(\n\t\t\tU event, X param, Function<RL, BiFunction<U, X, CompletionStage<R>>> fun) {\n\t\tCompletionStage<R> ret = COMPLETED;\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null && ls.length != 0 ) {\n\t\t\tfor ( T listener : ls ) {\n\t\t\t\t//to preserve atomicity of the Session methods\n\t\t\t\t//call apply() from within the arg of thenCompose()\n\t\t\t\tret = ret.thenCompose( v -> fun.apply( (RL) listener ).apply( event, param ) );\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic <R, U, RL> CompletionStage<R> fireLazyEventOnEachListener(\n\t\t\tfinal Supplier<U> eventSupplier,\n\t\t\tfinal Function<RL, Function<U, CompletionStage<R>>> fun) {\n\t\tCompletionStage<R> ret = COMPLETED;\n\t\tfinal T[] ls = listeners;\n\t\tif ( ls != null && ls.length != 0 ) {\n\t\t\tfinal U event = eventSupplier.get();\n\t\t\tfor ( T listener : ls ) {\n\t\t\t\t//to preserve atomicity of the Session methods\n\t\t\t\t//call apply() from within the arg of thenCompose()\n\t\t\t\tret = ret.thenCompose( v -> fun.apply( (RL) listener ).apply( event ) );\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic void addDuplicationStrategy(DuplicationStrategy strategy) {\n\t\tif ( duplicationStrategies == DEFAULT_DUPLICATION_STRATEGIES ) {\n\t\t\tduplicationStrategies = makeDefaultDuplicationStrategy();\n\t\t}\n\t\tduplicationStrategies.add( strategy );\n\t}\n\n\t@Override\n\tpublic void appendListener(T listener) {\n\t\thandleListenerAddition( listener, this::internalAppend );\n\t}\n\n\t@Override\n\t@SafeVarargs\n\tpublic final void appendListeners(T... listeners) {\n\t\t//noinspection ForLoopReplaceableByForEach\n\t\tfor ( int i = 0; i < listeners.length; i++ ) {\n\t\t\thandleListenerAddition( listeners[i], this::internalAppend );\n\t\t}\n\t}\n\n\tprivate void internalAppend(T listener) {\n\t\tprepareListener( listener );\n\t\tfinal T[] listenersRead = this.listeners;\n\t\tfinal T[] listenersWrite;\n\n\t\tif ( listenersRead == null ) {\n\t\t\t//noinspection unchecked\n\t\t\tlistenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), 1 );\n\t\t\tlistenersWrite[0] = listener;\n\t\t}\n\t\telse {\n\t\t\tfinal int size = listenersRead.length;\n\n\t\t\t//noinspection unchecked\n\t\t\tlistenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), size+1 );\n\n\t\t\t// first copy the existing listeners\n\t\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 0, size );\n\n\t\t\t// and then put the new one after them\n\t\t\tlistenersWrite[size] = listener;\n\t\t}\n\t\tsetListeners( listenersWrite );\n\t}\n\n\t@Override\n\tpublic void prependListener(T listener) {\n\t\thandleListenerAddition( listener, this::internalPrepend );\n\t}\n\n\t@Override\n\t@SafeVarargs\n\tpublic final void prependListeners(T... listeners) {\n\t\t//noinspection ForLoopReplaceableByForEach\n\t\tfor ( int i = 0; i < listeners.length; i++ ) {\n\t\t\thandleListenerAddition( listeners[i], this::internalPrepend );\n\t\t}\n\t}\n\n\tprivate void internalPrepend(T listener) {\n\t\tprepareListener( listener );\n\t\tfinal T[] listenersRead = this.listeners;\n\t\tfinal T[] listenersWrite;\n\n\t\tif ( listenersRead == null ) {\n\t\t\t//noinspection unchecked\n\t\t\tlistenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), 1 );\n\t\t\tlistenersWrite[0] = listener;\n\t\t}\n\t\telse {\n\t\t\tfinal int size = listenersRead.length;\n\n\t\t\t//noinspection unchecked\n\t\t\tlistenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), size+1 );\n\n\t\t\t// put the new one first\n\t\t\tlistenersWrite[0] = listener;\n\n\t\t\t// and copy the rest after it\n\t\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 1, size );\n\t\t}\n\t\tsetListeners( listenersWrite );\n\t}\n\n\tprivate void handleListenerAddition(T listener, Consumer<T> additionHandler) {\n\t\tfinal T[] listenersRead = this.listeners;\n\t\tif ( listenersRead == null ) {\n\t\t\tadditionHandler.accept( listener );\n\t\t\treturn;\n\t\t}\n\t\tfinal T[] listenersWrite = (T[]) Array.newInstance( eventType.baseListenerInterface(), listenersRead.length );\n\t\tSystem.arraycopy( listenersRead, 0, listenersWrite, 0, listenersRead.length );\n\n\t\tfinal boolean debugEnabled = log.isDebugEnabled();\n\n\t\tfor ( DuplicationStrategy strategy : duplicationStrategies ) {\n\n\t\t\t// for each strategy, see if the strategy indicates that any of the existing\n\t\t\t//\t\tlisteners match the listener being added.  If so, we want to apply that\n\t\t\t//\t\tstrategy's action.  Control it returned immediately after applying the action\n\t\t\t//\t\ton match - meaning no further strategies are checked...\n\n\t\t\tfor ( int i = 0; i < listenersRead.length; i++ ) {\n\t\t\t\tfinal T existingListener = listenersRead[i];\n\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\tlog.debugf(\n\t\t\t\t\t\t\t\"Checking incoming listener [`%s`] for match against existing listener [`%s`]\",\n\t\t\t\t\t\t\tlistener,\n\t\t\t\t\t\t\texistingListener\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif ( strategy.areMatch( listener,  existingListener ) ) {\n\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\tlog.debugf( \"Found listener match between `%s` and `%s`\", listener, existingListener );\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch ( strategy.getAction() ) {\n\t\t\t\t\t\tcase ERROR: {\n\t\t\t\t\t\t\tthrow new EventListenerRegistrationException( \"Duplicate event listener found\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase KEEP_ORIGINAL: {\n\t\t\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\t\t\tlog.debugf( \"Skipping listener registration (%s) : `%s`\", strategy.getAction(), listener );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase REPLACE_ORIGINAL: {\n\t\t\t\t\t\t\tif ( debugEnabled ) {\n\t\t\t\t\t\t\t\tlog.debugf( \"Replacing listener registration (%s) : `%s` -> `%s`\", strategy.getAction(), existingListener, listener );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tprepareListener( listener );\n\n\t\t\t\t\t\t\tlistenersWrite[i] = listener;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// we've found a match - we should return: the match action has already been applied at this point\n\t\t\t\t\t// apply all pending changes:\n\t\t\t\t\tsetListeners( listenersWrite );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// we did not find any match.. add it\n\t\tcheckAgainstBaseInterface( listener );\n\t\tperformInjections( listener );\n\t\tadditionHandler.accept( listener );\n\t}\n\n\tprivate void prepareListener(T listener) {\n\t\tcheckAgainstBaseInterface( listener );\n\t\tperformInjections( listener );\n\t}\n\n\tprivate void performInjections(T listener) {\n\t\tif ( listener instanceof CallbackRegistryConsumer ) {\n\t\t\t( (CallbackRegistryConsumer) listener ).injectCallbackRegistry( callbackRegistry );\n\t\t}\n\n\t\tif ( listener instanceof JpaBootstrapSensitive ) {\n\t\t\t( (JpaBootstrapSensitive) listener ).wasJpaBootstrap( isJpaBootstrap );\n\t\t}\n\t}\n\n\tprivate void checkAgainstBaseInterface(T listener) {\n\t\tif ( !eventType.baseListenerInterface().isInstance( listener ) ) {\n\t\t\tthrow new EventListenerRegistrationException(\n\t\t\t\t\t\"Listener did not implement expected interface [\" + eventType.baseListenerInterface().getName() + \"]\"\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Implementation note: should be final for performance reasons.\n\t * @deprecated this is not the most efficient way for iterating the event listeners.\n\t * See {@link #fireEventOnEachListener(Object, BiConsumer)} and co. for better alternatives.\n\t */\n\t@Override\n\t@Deprecated\n\tpublic final Iterable<T> listeners() {\n\t\treturn this.listenersAsList;\n\t}\n\n\tprivate static Set<DuplicationStrategy> makeDefaultDuplicationStrategy() {\n\t\tfinal Set<DuplicationStrategy> duplicationStrategies = new LinkedHashSet<>();\n\t\tduplicationStrategies.add(\n\t\t\t\t// At minimum make sure we do not register the same exact listener class multiple times.\n\t\t\t\tnew DuplicationStrategy() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean areMatch(Object listener, Object original) {\n\t\t\t\t\t\treturn listener.getClass().equals( original.getClass() );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Action getAction() {\n\t\t\t\t\t\treturn Action.ERROR;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\treturn duplicationStrategies;\n\t}\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"
    }
]